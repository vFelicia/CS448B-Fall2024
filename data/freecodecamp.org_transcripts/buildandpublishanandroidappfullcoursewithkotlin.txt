00:00 - hey everyone welcome to this tutorial
00:02 - where we're going to start with a brand
00:04 - new android project
00:05 - and see it all the way through to
00:07 - publishing on google play
00:09 - my name is rahul and i'm a software
00:11 - engineer and youtuber who loves teaching
00:14 - i think the best way to learn something
00:15 - is to build things and so we're going to
00:17 - build
00:17 - a memory game app to learn android
00:20 - development with kotlin
00:21 - as you go through this if you have any
00:23 - questions or feedback i'd love to
00:24 - connect with you
00:25 - i'm at rponde1234 on youtube and twitter
00:29 - the memory game is the perfect way to
00:31 - cover a lot of core android concepts
00:34 - we'll talk about dynamic layouts
00:36 - multiple screens
00:37 - image loading and persistence with
00:39 - firebase
00:40 - along the way i'll share some practical
00:42 - tips and tricks about app development
00:44 - and my checklist that i always go
00:46 - through before publishing any app onto
00:48 - google play
00:49 - i'm going to assume you have some
00:51 - programming experience
00:52 - and if you have a basic familiarity with
00:55 - android that's an added bonus
00:57 - we're going to be using a programming
00:58 - language called kotlin which is now the
01:00 - recommended way to develop android apps
01:03 - you're welcome to follow along if you're
01:04 - new to kotlin or even if you're new to
01:06 - programming
01:07 - but i'd recommend that you go through a
01:09 - quick kotlin intro first
01:12 - once you're done building the app share
01:13 - it on social media with the hashtag
01:15 - mymemory and don't forget to tag me so i
01:18 - can check it out as well
01:20 - let me do a quick demo of the memory app
01:22 - that we're going to build
01:23 - this game is really popular i played it
01:25 - a lot growing up and i'm sure
01:26 - it's familiar for many of you the
01:28 - objective is to try and find pairs with
01:30 - matching images
01:31 - so here i have two cards which don't
01:34 - match when i flip over a third card
01:36 - then the other two will flip back down
01:38 - and the reason this is called memory is
01:39 - because
01:40 - once you've identified where a image is
01:42 - you have to use your memory or
01:43 - concentration to find out where have you
01:45 - previously seen that
01:46 - card so here i know the matching flower
01:48 - image is over there
01:49 - and now i can continue until i have
01:51 - found all of the pairs
01:56 - once i found all the pairs in the game
01:58 - then the confetti falls and i have that
02:00 - message and we can also see
02:01 - information about the game at the bottom
02:03 - of the screen
02:04 - in the menu i can tap this button to
02:06 - restart the game and that shows me new
02:08 - random images and i can also choose a
02:10 - different size
02:11 - memory board so right now we're showing
02:13 - an eight card game which is
02:15 - four pairs and i can make it a little
02:16 - bit harder by choosing the hard version
02:18 - which is
02:19 - 24 cards and so now you can see how we
02:21 - are dynamically changing the size of
02:23 - each memory card in order to
02:24 - fill up the phone width and height
02:28 - one other thing we can do is download a
02:30 - custom game so this is a really cool
02:32 - part of the game
02:33 - it is that anyone in the world can
02:34 - create their own memory game with photos
02:36 - from their phone
02:37 - and we can actually play that so for
02:39 - example i created a
02:41 - custom memory game called bitmoji
02:44 - so bitmoji is my bitmoji character my
02:47 - cartoon doing different activities and
02:49 - so now
02:50 - if you flip over a card you can see
02:52 - these are images from my phone that i
02:54 - uploaded into a custom memory game and
02:56 - we can play the game like normal where
02:57 - we're trying to match up images
02:59 - and finally of course you can also
03:02 - create your own custom
03:04 - memory game so i'm going to choose to
03:06 - create an easy game which means i have
03:07 - to upload four images
03:09 - this will now launch the existing
03:11 - gallery app on your phone
03:13 - and i can select photos from my phone so
03:16 - i have these
03:17 - very adorable photos of corgis i want to
03:20 - give this game name
03:22 - the name of corgi and tap save and what
03:24 - this is doing is it's
03:25 - persisting these images to firebase and
03:28 - once that's done now we can actually
03:30 - play our custom game
03:32 - so you can see the images of the core
03:33 - keys that we have here
03:35 - and the cool thing is now i can share
03:37 - this game name corgi with anyone in the
03:39 - world and they can play the same game
03:42 - so there's a lot of really cool concepts
03:44 - i want to cover in the process of
03:46 - building this
03:46 - and i'm really excited to get started
03:48 - with you i'm going to make it really
03:50 - easy for you to follow along with me
03:51 - which means i'm going to keep copy paste
03:53 - to a minimum and the only tools that you
03:55 - really need
03:56 - are android studio and a working
03:58 - emulator or
03:59 - a phone an android phone i'll also leave
04:02 - a link in the description to the github
04:04 - repository which contains all the code
04:06 - so you can
04:06 - feel free to reference that as well
04:08 - here's a picture cloud representation of
04:10 - the main concepts we'll be covering so
04:12 - first off we're going to become
04:13 - very familiar with android studio we're
04:15 - also going to be talking about
04:16 - vector icons so android studio will help
04:18 - us to create a bunch of these
04:20 - vector images that will be used as a
04:22 - default memory game
04:24 - images we'll also talk about views and
04:27 - measuring out
04:28 - how much space to allocate with the
04:29 - content the padding and the margin which
04:31 - lives outside the view
04:34 - all that content will live largely
04:37 - inside of a recycler view which is how
04:38 - we're displaying
04:40 - the grid of memory cards so recyclerview
04:42 - is a very core component
04:44 - in android and we'll talk about the
04:45 - different parts that make up a
04:47 - recyclerview
04:48 - we're also going to be dealing with two
04:50 - firebase services the first is cloud
04:52 - storage which is what will be storing
04:54 - our images
04:55 - second is cloud firestore which will be
04:57 - the database associating our game name
04:59 - to a list of image urls then finally
05:02 - we're going to
05:03 - spend a bit of time talking about how do
05:05 - we create a release app
05:07 - that we can then publish onto google
05:08 - play and also talk about how to optimize
05:10 - your google play store listing
05:12 - i'll leave a link to the published app
05:14 - in the google play store in the
05:15 - description so you can
05:23 - in the download segment we are going to
05:25 - construct the layout for the main screen
05:27 - or main ui
05:28 - for our application just one more thing
05:30 - i wanted to say a big thank you to free
05:32 - codecamp for building out an amazing
05:34 - platform to reach
05:35 - so many students subscribe to their
05:37 - channel and check out my channel if you
05:38 - want more content like this
05:40 - we're going to get started by creating a
05:42 - brand new android studio project
05:44 - and then the goal for this segment is to
05:46 - set up the scaffolding for the main
05:48 - layout or main
05:49 - ui for our memory game here's what the
05:52 - final user interface for our app will
05:54 - look like
05:54 - at the top we have an action bar which
05:56 - comes in by default
05:58 - in every internet app and it describes
05:59 - how the user can navigate through your
06:01 - app
06:02 - the bulk of the screen will be taken up
06:03 - by something called a recycler view and
06:05 - that's how
06:06 - we're going to power this grid of memory
06:08 - cards
06:09 - that make up our memory game at the
06:11 - bottom we have
06:12 - two labels or two text views that
06:14 - describe the current state of the game
06:16 - and so at the end of this part here's
06:18 - what our ui will look like at the top we
06:20 - have the default action bar
06:21 - at the bottom we have a horizontal
06:23 - linear layout with
06:25 - two text views with dummy data and the
06:27 - rest of the screen will be filled up
06:29 - with an empty recycler view
06:31 - let's open up android studio and you can
06:33 - see here that i'm running version 4.1
06:35 - any recent version of android studio
06:37 - should do so i'm going to
06:39 - tap the option for creating a new
06:41 - project and let's go ahead and pick the
06:43 - empty activity template
06:45 - tap on next and we're going to call this
06:47 - project my memory
06:49 - because it's a customizable memory game
06:52 - the package name has to be a unique
06:53 - identifier for your app and it will
06:55 - dictate the directory structure for your
06:57 - project
06:57 - typically i'll take my domain name
06:59 - rkpuna.com or my email address and flip
07:01 - it backward
07:02 - pick a location for where you want to
07:03 - save it we're going to pick the language
07:05 - of kotlin which is the more modern and
07:07 - recommended
07:07 - way of building android apps going
07:09 - forward the minimum sdk i'm going to
07:11 - pick
07:11 - api level 21 which is android 5.0
07:14 - otherwise known as lollipop and you can
07:16 - see here
07:16 - android studio is telling us that if we
07:18 - pick api 21
07:20 - that means our app will run on 94
07:22 - percent of devices
07:24 - so that means around six percent of
07:25 - android devices are running a version of
07:27 - android which is more than five years
07:29 - old and they won't be able to download
07:31 - our app
07:32 - but there's a lot of pain associated
07:34 - with actually
07:35 - back porting your app and making sure it
07:36 - runs on all these super old
07:38 - android os so i would recommend that you
07:40 - stick with api 21.
07:42 - let's tap on finish and then android
07:46 - studio initially when it creates your
07:47 - project it will
07:48 - actually try building it based on the
07:50 - scaffolding that you picked so we have
07:52 - empty activity which means that
07:53 - we just have a kind of a blank activity
07:55 - here which will say hello world
07:57 - and the very first thing i like to do
07:59 - whenever i create a brand new project is
08:00 - simply to run it and running it will
08:03 - give me the confidence that i haven't
08:04 - screwed anything up in the setup i have
08:06 - android studio set up properly i have an
08:08 - emulator set up properly
08:09 - and i'm actually able to compile and run
08:11 - my app
08:13 - i have a bunch of emulators already set
08:14 - up here if you don't have
08:16 - any emulators click on avd manager it's
08:19 - android virtual device manager and that
08:20 - will guide you through the process of
08:22 - creating a new
08:23 - emulator that you can install the app on
08:25 - i'm going to go with this pixel 2 api
08:28 - 29 emulator and without making any code
08:31 - changes
08:32 - i'm simply going to hit this green
08:34 - triangle in order to run the app
08:36 - and boot up the emulator in the process
08:40 - awesome so you can see down here at the
08:41 - bottom how it says the operation
08:43 - succeeded
08:44 - and just like we want we're able to see
08:46 - this default empty
08:48 - application which says hello world so
08:50 - let me quickly talk through what we get
08:52 - in the starter project here there are
08:54 - really two files that you should be
08:55 - concerned about
08:56 - one is the main activity.kotlin file the
08:58 - dot kt means it's a kotlin file
09:00 - in the world of android you can think of
09:02 - an activity like one screen in your
09:03 - application
09:05 - so this file main activity.kotlin will
09:07 - be
09:08 - where we write the core logic for the
09:09 - memory game it'll be the brain of our
09:11 - app
09:12 - and the critical line here is set
09:14 - contentview
09:15 - r.layout.activitymain so what this is
09:17 - referring to is that there is a
09:19 - resource file called activity main so r
09:22 - stands for resource
09:23 - and r.layout means look inside of the
09:25 - layout directory
09:26 - of the resources and look for a file
09:29 - called activity main
09:30 - so we can actually try doing that my
09:33 - preference is to select the
09:34 - android view of our project the initial
09:37 - perspective which is
09:38 - simply called project represents the
09:40 - actual file hierarchy
09:42 - of the project on disk but it's a little
09:44 - harder to navigate
09:45 - and the android view is how i
09:47 - conceptually think about my project
09:49 - so instead of the android view in the
09:50 - app directory there's a folder here
09:52 - called dress which is short for
09:54 - resources so like we talked about
09:56 - there's a layout directory
09:57 - inside of res let's check that and
09:59 - there's one file here called
10:01 - activitymain.xml and that's what is
10:03 - creating a link between the main
10:04 - activity
10:05 - and the underlying ui or layout
10:09 - so i can go to the definition of
10:11 - activity main by hitting
10:12 - ctrl b or command b
10:16 - and that will jump to this other file
10:18 - activity main in android we define
10:20 - layouts using xml a markup language
10:22 - which
10:23 - allows us to define the views on the
10:24 - screen their position
10:26 - and how they're structured with one
10:27 - another so you can have views
10:29 - inside of another view and you can see
10:31 - here how it's really simple right now
10:33 - all it is is a constraint layout as the
10:35 - root element and inside there's a text
10:37 - view
10:38 - which just says hello world and that is
10:41 - how we are
10:42 - seeing the hello world text when we ran
10:44 - our application
10:45 - now we can start making changes and i
10:46 - want to be really precise about what
10:48 - we're going to do
10:49 - in this segment which is i just want to
10:51 - add a bottom component which will
10:52 - describe
10:53 - info about the current game being played
10:55 - in particular there'll be two text views
10:56 - one for the number of moves on the left
10:58 - and one on the right side showing how
11:00 - many pairs have been matched
11:02 - so that means we're going to have to be
11:04 - modifying the activity main.xml
11:06 - and you'll notice here that there are
11:07 - three different perspectives of this
11:09 - xml file so we have the code which is
11:11 - basically the underlying xml
11:13 - representation
11:14 - split which is both and then design
11:16 - which is just looking at the
11:18 - preview rendered in android studio
11:20 - itself
11:21 - so to give us give ourselves a bit more
11:23 - space i'm going to double tap on
11:24 - activity main and that basically
11:25 - minimized
11:26 - this project tool window and the first
11:29 - thing i want to do is get rid of the
11:31 - default hello world and we are now going
11:34 - to drag out a
11:35 - linear layout which is horizontal
11:38 - orientation because these are going to
11:39 - be
11:40 - right and left the two texts at the
11:41 - bottom are going to be horizontally
11:43 - aligned
11:45 - and we are going to set the layout width
11:48 - to be match constraint which means that
11:49 - we're going to have
11:50 - the width be dictated by the constraints
11:52 - that means that we should add some
11:53 - constraints
11:54 - so from the left end of the screen i
11:56 - want it to be zero dp
11:57 - which means i just wanted to be flush
11:59 - with the left end and same thing on the
12:02 - right
12:02 - and essentially what that did is it's
12:04 - making the width of this linear layout
12:06 - the whole screen width
12:09 - we also want to constrain the bottom of
12:11 - this linear layout to the bottom of the
12:12 - screen
12:14 - so add 0 down here as well i also want
12:16 - to
12:17 - change the height of this to be wrap
12:19 - content
12:20 - which basically means i want the linear
12:21 - layout to only have as much height as
12:23 - whatever is inside of it
12:25 - inside of linear layout we are going to
12:27 - contain two elements
12:29 - and these are going to be card views and
12:30 - the card views are actually what
12:32 - will contain the text view so card views
12:35 - are a really nice android component
12:37 - which show some elevation so it's a
12:40 - material design
12:41 - recommended ui so that's what we'll use
12:44 - to create some separation between the
12:46 - text views and we'll actually also use
12:47 - it for each memory card
12:49 - so i have a card view here i'm going to
12:51 - change the corner radius to be 8 dp here
12:56 - and then inside of the card view i want
12:57 - to drag out a
12:59 - text view so a couple changes i want to
13:03 - make here
13:03 - first off i want to make the width and
13:05 - height to be match parent
13:08 - so this texture takes up the whole width
13:10 - and height of the parent which is the
13:11 - card view
13:12 - i want to make the text appearance large
13:14 - make it a little bit bigger
13:16 - let's also give it some dummy text here
13:18 - so this is this one is going to
13:20 - represent the number of moves that the
13:21 - user has done so we'll start out with
13:23 - zero moves and then i'd like to add some
13:26 - padding onto this text view
13:28 - so let me search for this attribute
13:30 - called padding
13:32 - and let's give give this textview a
13:34 - padding of 8dp
13:36 - all around so you can see how it created
13:38 - some space let me zoom in on the design
13:40 - preview just so we can get a closer look
13:42 - at
13:42 - the changes we're making the last thing
13:45 - on this textview is i want to set the
13:46 - gravity of it to be center
13:48 - which basically means out of all the
13:50 - space that we have i want to be
13:52 - centered inside of the card view so
13:54 - search for gravity
13:55 - and then we are going to set the gravity
13:57 - to be center
13:58 - you can see how it got centered in there
14:01 - now going back to the card view one
14:02 - thing i want to add
14:03 - onto the card view is a margin so we can
14:06 - see
14:06 - a separation between the card view and
14:08 - the background which is the linear
14:09 - layout
14:10 - so search for margin and we are going to
14:14 - add a margin of
14:16 - 10 dp on all sides
14:19 - so now you can start to actually see
14:20 - this card you take shape and have
14:22 - this elevation that i mentioned earlier
14:26 - we actually want two different card
14:28 - views on the bottom in the linear layout
14:30 - so what i'm going to do is i'm going to
14:30 - go over here
14:31 - copy this then go and select the linear
14:33 - layout and then paste it
14:35 - what we did here is we are embedding two
14:38 - card views in the linear layout
14:39 - and in order to make them show up side
14:41 - by side there's a property on the
14:43 - elements in the linear layout called
14:45 - weight and the weight
14:48 - dictates how much space should the
14:50 - linear layout allocate for this child
14:52 - so if we set the value to be equal on
14:55 - each of the
14:56 - card views that basically means we want
14:58 - an equal amount of space allocated
15:02 - that looks good so now in the text here
15:05 - on the right
15:06 - we don't want that to represent the
15:07 - number of moves we want that to
15:08 - represent
15:09 - how many pairs have been found i'll call
15:12 - this
15:13 - pairs and then we'll say zero out of
15:16 - four all right and then you can see how
15:19 - one
15:19 - issue that we have right now is that the
15:20 - id of these textures is identical so
15:23 - let's go back into the code tab now and
15:24 - fix this
15:26 - so you can see again here in the code
15:27 - tab the red
15:29 - error highlighting and one thing to keep
15:31 - in mind also is that any change that you
15:32 - make in the design tab
15:33 - there's a one to one correspondence
15:34 - between that and what you see in the
15:36 - code tab so you can kind of see here
15:37 - we have a linear layout and inside that
15:39 - linear layout is a card view
15:40 - with the text view inside and then the
15:42 - same thing down here so we would like to
15:44 - change the id
15:45 - of this one to be tv
15:48 - num moves because it represents a text
15:51 - view with number of moves
15:52 - and then the id of this one should be tv
15:55 - num
15:55 - pairs the one more thing i want to do
15:58 - while we're
15:59 - in the code section is i would like to
16:01 - add a background color on the linear
16:02 - layout
16:04 - i'm just going to add the background
16:06 - attribute and the
16:09 - value of this i would we wanted to set
16:11 - to attribute
16:12 - and there's one inbuilt called color
16:14 - secondary variant which is
16:15 - kind of this teal color and if we go in
16:17 - the design tab you can see
16:18 - what that looks like cool that looks
16:20 - pretty good so now if you're on the app
16:22 - we should no longer be seeing the hello
16:24 - world text and we should now be seeing
16:26 - this linear layout at the bottom with
16:27 - that hard-coded text that we have
16:29 - awesome next we're going to drag out a
16:32 - recyclerview and this is going to be the
16:33 - primary component which will hold on to
16:35 - all the cards in our memory game
16:38 - and i want to set the left and right
16:41 - constraints of this to be 0 dp so i want
16:43 - to take up the whole screen with
16:44 - the top constraint should be flushing at
16:46 - the top of the screen and the bottom
16:48 - constraint i want this to be
16:49 - actually up against the top of the
16:52 - linear layer at the bottom in order to
16:54 - have that take a visible effect we need
16:55 - to change
16:56 - the layout height to be zero dp and now
16:59 - you can see how the recyclerview is
17:01 - basically taking up
17:02 - all the remaining space after we've
17:04 - allocated the space for
17:05 - the linear layout at the bottom of the
17:07 - screen and also the
17:09 - layout width we can also make it match
17:10 - constraint zero dp
17:12 - because we've properly defined the the
17:14 - constraints
17:15 - on the left and right side
17:18 - and this recyclerview won't have any
17:20 - visible ui change because we haven't
17:21 - actually written the logic to populate
17:23 - it yet
17:23 - that's what we'll do in the next part
17:26 - the last thing i want to do
17:27 - to wrap up this part though is go back
17:29 - to main activity and let's actually grab
17:31 - references
17:32 - to each of the views that we have on the
17:34 - screen now so in particular i would like
17:36 - to be able to get references to
17:38 - any of the components that we have that
17:40 - we will need to change programmatically
17:42 - so in particular these two text views
17:44 - and the recycler view so give this an id
17:46 - name of rv board
17:48 - because it represents our memory board
17:50 - tap on refactor
17:52 - tv num moves looks good tv numpair looks
17:54 - good and i'll just let's just go ahead
17:55 - and change the default name of the id
17:57 - here of linear layout 2 and make this
18:00 - ll game info which stands for linear
18:02 - layout game info this is a container
18:05 - with all of the information of the game
18:06 - and then let's refactor
18:08 - and android studio will take care of
18:09 - updating anywhere else that this id is
18:11 - referenced
18:13 - so now in mainactivity the pattern here
18:15 - is any
18:16 - widget that we have in our layout we can
18:18 - reference in mainactivity and we'll
18:20 - define that as a
18:22 - private member variable and all these
18:24 - will be private late in it var
18:26 - so for example rv board and this is
18:29 - going to be of type recyclerview
18:31 - and then similarly we're going to have
18:33 - one for tv
18:35 - num moves this is going to be a text
18:38 - view
18:39 - and there's going to be one more which
18:40 - is tv numpairs
18:42 - and that's also a textview and the
18:45 - reason it's a late init var
18:46 - is because we know that these variables
18:48 - will be set
18:49 - but they'll be set in the oncreate
18:51 - method which is invoked by the android
18:53 - system they're not going to be created
18:55 - at the time of construction of the main
18:57 - activity and that's why this is a late
18:59 - in it
18:59 - late initialization so now in the on
19:02 - create as soon as we've called set
19:03 - content view
19:04 - now we can set these newly defined
19:05 - variables equal to
19:07 - the corresponding view in the layout and
19:09 - we'll do that by calling a special
19:11 - method
19:11 - find view by id and provide the id that
19:14 - we assigned
19:15 - so for the recyclerview we give it an id
19:17 - of rv board
19:19 - and similarly tv num moves
19:24 - and then finally tv num pair
19:27 - [Music]
19:30 - now we've set up the scaffolding for the
19:32 - main activity and we have references
19:34 - to the key views on the layout the goal
19:36 - the next part is to
19:38 - add in data to the recycler view in a
19:40 - 4x2 grid
19:41 - of memory cards that we'll define so we
19:44 - have now
19:45 - this linear layout at the bottom which
19:47 - shows information about the current game
19:49 - and we have this empty recycler view
19:51 - which takes up all the remaining space
19:53 - our goal for this part is to fill up
19:56 - that recycler view with a grid of icons
19:58 - which will
19:59 - which will eventually be each memory
20:00 - card that you can tap on and flip over
20:02 - but for now we're just going to put in
20:03 - some dummy icon and the interesting
20:05 - thing here
20:06 - is that the size of each of these cards
20:09 - that you're seeing
20:10 - are not hard-coded instead we're going
20:12 - to dynamically
20:13 - set the width and height according to
20:16 - how much
20:16 - space we have so on a larger phone or on
20:19 - a tablet these will appear bigger
20:21 - on a smaller phone we're going to reduce
20:23 - the size appropriately
20:24 - we're going to make them just large
20:26 - enough that we can fill up the entire
20:27 - space
20:28 - that we're given in this recyclerview
20:31 - so jumping back into the code every
20:33 - recyclerview has
20:34 - two core components one is the adapter
20:36 - and one is the layout manager
20:39 - given some views that should be shown in
20:40 - the recyclerview the layout manager is
20:42 - responsible for measuring and
20:44 - positioning those items
20:45 - so the layout manager is actually quite
20:47 - simple for us
20:48 - we're going to use a predefined layout
20:50 - manager that comes with android called
20:51 - the grid layout manager
20:53 - and this is how we're going to have this
20:54 - nice grid effect
20:56 - so this takes in two parameters one
20:58 - which is a context so we're passing in
21:00 - this which is referencing the main
21:01 - activity
21:02 - because the main activity is an example
21:03 - of a context and a second parameter here
21:06 - is the span count otherwise known as how
21:09 - many columns
21:10 - are in your recycler view so for now
21:12 - we're going to hard code this four by
21:13 - two grid so there's going to be two
21:15 - columns
21:15 - and each column was going to have four
21:17 - rows we're going to pass in two here and
21:18 - then later on we're going to have to
21:19 - make this dynamic
21:20 - based on what the user has picked the
21:22 - other component
21:23 - that we're going to define for the
21:25 - recycler view
21:26 - is an adapter the adapter is more
21:29 - involved than the layout manager because
21:31 - it's responsible for taking in
21:32 - the underlying data set of the recycler
21:34 - view and turning that into
21:36 - or adapting each piece of data into a
21:39 - view
21:41 - i'm going to set this adapter property
21:43 - on the recycler view and we're going to
21:44 - define a new class
21:46 - which has all the logic for the adapter
21:48 - called memory board
21:49 - adapter and this will take in two
21:52 - parameters one which is the context
21:54 - so i'm going to pass in this and second
21:56 - will be how many elements
21:58 - total are in our grid and we're gonna
22:01 - hard code this in
22:02 - as eight for now and we'll change that
22:04 - later on
22:05 - before we define this memory board
22:07 - adapter there's one more thing
22:08 - that i want to point out which is
22:10 - optional but it's a performance
22:12 - optimization
22:13 - which is that there's a method on the
22:14 - recycler view called
22:16 - set has fixed size and we're going to
22:19 - pass in true here
22:21 - and what this method does if you look at
22:23 - the documentation
22:27 - is that we know the size of the recycler
22:29 - view is not affected by the adapter
22:31 - contents
22:31 - so like we talked about earlier the size
22:34 - of the recycler view on the screen is
22:36 - always going to be defined as soon as
22:38 - the app boots up and it won't change
22:40 - regardless of how many memory cards are
22:43 - inside the recycler view
22:44 - and so by setting has fixed size to be
22:46 - true
22:47 - we can make our application a bit more
22:50 - efficient
22:51 - okay so now let's go back and you can
22:53 - see how under studio is complaining that
22:54 - this
22:54 - class isn't defined so let's have inner
22:56 - studio help us to define
22:58 - this class so tap on the red light bulb
23:00 - and tap on create class memory board
23:01 - adapter
23:02 - and we're going to extract this out into
23:04 - a separate file in the same package name
23:07 - okay so the first parameter is going to
23:08 - actually be a context
23:10 - not an activity and the second
23:14 - constructor parameter will be num pieces
23:16 - representing how many memory cards there
23:18 - are and that will be an integer
23:20 - then hit tab one more time one thing i
23:22 - want to do is i want to prefix each of
23:24 - these
23:24 - constructor parameters with private val
23:27 - and that will actually allow us to
23:29 - use this in the body of our class what
23:32 - we have here
23:32 - is a class memory board adapter which is
23:35 - a subclass
23:36 - of the recyclerviewadapter class you'll
23:38 - notice that this is parametrized
23:40 - by something called
23:42 - recyclerview.viewholder
23:43 - so a viewholder is an object which
23:46 - provides access to
23:47 - all the views of one recyclerview
23:49 - element and so
23:50 - in our case that will represent one
23:52 - memory piece or one memory card in the
23:54 - game
23:55 - and we're going to define our own view
23:57 - holder which will encapsulate
23:59 - that memory card view and so what i'm
24:01 - going to do is i'm going to actually
24:02 - define an inner class here
24:05 - called viewholder and this is going to
24:09 - inherit from the recyclerview view
24:10 - holder
24:11 - [Music]
24:13 - hit this red lightbulb and then we need
24:14 - to match the constructor invocation of
24:17 - the view holder
24:18 - and now that we've defined this view
24:19 - holder instead of being parameterized by
24:22 - the
24:22 - base class i want to be parametrized by
24:24 - this inner class that we just defined
24:27 - so we'll need to import that
24:30 - okay and now that we've defined the
24:32 - inner class and we're parameterized by
24:33 - that
24:33 - now hit this red light bulb that android
24:36 - studio is complaining about for the
24:38 - memory board adapter and implement the
24:41 - numbers
24:41 - the recyclerview adapter class is an
24:43 - abstract class which means that we have
24:45 - several methods that we need to override
24:48 - in order for it to function and there
24:50 - are three that we need to override i'm
24:51 - going to select all three and tap on ok
24:54 - and my preference is to have the inner
24:55 - class show up at the bottom of the class
24:57 - so i'm going to have that i'm going to
24:59 - move that down here
25:01 - and now there are three methods here
25:03 - oncreateviewholder is responsible for
25:05 - figuring out how to create one view of
25:08 - our
25:08 - recyclerview getitemcount is actually
25:11 - really easy so i'm going to define that
25:12 - right now which is how many elements are
25:14 - in our recycler view and that will
25:15 - simply be
25:16 - the constructor parameter that we passed
25:18 - in num pieces
25:20 - and then onbindviewholder is responsible
25:23 - for
25:24 - taking the data which is at this
25:25 - position and
25:27 - binding it to this view holder which is
25:29 - passed in here
25:30 - so we'll we'll come to that in a little
25:31 - bit but first let's define
25:33 - the oncreateviewholder method so the
25:36 - pattern here typically is we're going to
25:37 - use a layout inflator i'm going to
25:40 - create it from the context which is the
25:43 - parameter that we passed in the
25:44 - constructor
25:45 - and we're going to inflate a resource
25:48 - file which defines our layout
25:50 - with the r.layout.memory underscore card
25:54 - and this takes in two more parameters
25:56 - one which is the view group the root
25:57 - view group and that'll be the parent
25:59 - which is the perimeter passed in
26:00 - and then the third parameter is attached
26:02 - to root we're going to pass in false
26:03 - here
26:05 - we have to now define this layout file
26:09 - again android video will help us with
26:10 - this create
26:12 - layout resource file have the root
26:15 - element of this be a linear layout
26:17 - tap on ok the objective here is to add
26:21 - in some children elements on this linear
26:23 - layout such that we create
26:25 - the view for one individual memory card
26:28 - in our game
26:29 - so if i go into the design tab what
26:31 - we'll do is
26:33 - first off let's change the height of
26:35 - this linear layout to be
26:36 - wrap content let's drag in a card view
26:41 - and inside the card view will be an
26:43 - image button
26:45 - we'll drag out an image button and let's
26:47 - have the
26:49 - underlying drawable or icon behind that
26:51 - image button be this icy launcher
26:53 - background which is a screen grid you
26:54 - should have that already from the
26:56 - default android studio project
26:58 - tap on ok let's have the id simply be
27:01 - image button
27:03 - and have the width and height be match
27:04 - parent
27:06 - now you can see how it takes up the full
27:08 - dimensions of the
27:10 - card view which is apparent let's set
27:13 - the background to be white
27:15 - this is a solid white color and the
27:18 - scale type can be center crop
27:21 - well and the card view represents one
27:24 - actual
27:24 - memory card so there's a couple design
27:26 - tweaks i want to do here first off
27:28 - i want to hard code the width and height
27:30 - to be 120 dp
27:31 - just to give it a more realistic feel of
27:34 - what a memory card might actually look
27:35 - like
27:36 - but we're going to change this to be
27:37 - dynamically measured later on
27:39 - but for now 120 is a pretty good default
27:44 - let's change the card corner radius and
27:46 - height to be 8 dp
27:48 - so it stands out a bit more
27:52 - and let's also give this an id of card
27:54 - view
27:55 - finally the last thing i want to do is
27:58 - set the gravity of this parent linear
28:00 - layout to be centered so this card view
28:02 - goes into the center of the screen
28:03 - so search for gravity and then
28:07 - hit center
28:10 - all right awesome so you can see how
28:12 - we're now aligned to the center of the
28:13 - screen
28:15 - so going back into the memory board
28:16 - adapter now this error went away
28:18 - and the return value of layout inflator
28:20 - inflate will be the actual view
28:23 - which was created i'll say valve view
28:26 - and then what we want to return here is
28:29 - the view wrapped inside of a view holder
28:33 - and then in on bind view holder what i
28:35 - want to do
28:36 - is for now just called holder dot bind
28:40 - [Music]
28:42 - position and bind to something which is
28:45 - not yet defined because
28:46 - energy is looking for this method to be
28:48 - defined on the viewholder class it
28:50 - doesn't exist yet so industry will help
28:52 - us to create it
28:55 - and for now this is going to be a no-op
28:58 - and then later on
28:59 - we'll come back and address this okay
29:01 - let's run the app
29:03 - and see what happens
29:06 - awesome so what you can see here is we
29:09 - are now
29:10 - getting eight different elements in our
29:13 - recyclerview
29:14 - in this grid four by two grid and you
29:15 - can kind of see the outlines of the
29:17 - different cards that we've laid out
29:19 - so what you can see here is that we're
29:21 - not really making a good use of all the
29:23 - space that we've allocated for the
29:24 - recyclerview right like we have this
29:26 - kind of awkward white space at the
29:27 - bottom and also we want to ideally have
29:30 - some margin between each of the memory
29:32 - cards in our
29:33 - recycler view so let's figure out how to
29:36 - do that
29:37 - the first thing that's worth pointing
29:38 - out is that the space allocated for each
29:41 - memory card
29:41 - will depend on how many memory cards we
29:43 - have so right now we have this
29:45 - four by two grid which means we have two
29:47 - cards across and
29:48 - four cards tall on the other hand if we
29:52 - have
29:52 - a slightly larger board where we have
29:54 - three cards across and four cards tall
29:56 - now we have 12 cards instead of eight
29:58 - that means that the amount of width
30:00 - allocated for each memory card is going
30:01 - to shrink
30:02 - so let's implement that first going back
30:04 - into the code
30:06 - we need to measure what is the width and
30:08 - height of the
30:10 - recycler view which is containing all
30:12 - the memory cards and based on that
30:14 - change the width of our card view so
30:17 - instead of having this be hard-coded to
30:18 - be 120 dp
30:20 - we want to measure that according to the
30:23 - recyclerview width and height
30:24 - and that turns out not to be that
30:25 - difficult because the recyclerview is
30:27 - actually the parent which is passed in
30:28 - here
30:29 - so if we wanted to figure out what is
30:31 - the
30:32 - width of the card so i'll say val card
30:35 - width
30:36 - then that will be the parent dot the
30:38 - width
30:39 - divided by however many columns we have
30:42 - in our grid so in this example because
30:44 - we're hard coding is four by two
30:46 - grid the width will be divided by two
30:49 - and then similarly for the card height
30:52 - we have four cards tall so we're going
30:55 - to
30:55 - divide the height of the recycler view
30:58 - by four
30:59 - and we're going to mandate that each
31:01 - memory card in our game is going to be
31:02 - square
31:03 - so we're going to take the smaller of
31:04 - the card with a card height
31:06 - so i'll call it card side length
31:10 - that's going to be the minimum of card
31:13 - width
31:14 - and card height and you might have to
31:17 - import min which is coming from
31:19 - kotlin.math.min at the top here
31:21 - so now we need to actually grab out the
31:25 - card view
31:26 - from the view that we've inflated and
31:29 - set the width and height of that card
31:30 - view to be card side length
31:32 - the way we do that is we say view dot
31:34 - find view by id
31:36 - pull out the card view which we gave it
31:38 - an id of card view
31:41 - and we're going to get a reference to
31:43 - the layout params
31:46 - and this is going to be equal to layout
31:48 - params
31:49 - a variable that we defined and on these
31:51 - layout param this is what will allow us
31:53 - to change the width and height
31:55 - the width will be card side length and
31:58 - the height
31:59 - will also be card side length so let's
32:02 - try this one more time
32:03 - and hopefully now we shouldn't have this
32:05 - awkward white space at the bottom
32:07 - and you can see that that is fixed right
32:10 - so
32:10 - we are actually taking up the whole
32:13 - screen width and screen height
32:17 - there's one more observation i want to
32:18 - make which is that we don't actually
32:20 - want
32:20 - the card to take up the full dimensions
32:23 - of the space we allocate to it
32:24 - so for example if we're putting a memory
32:26 - card into this yellow square
32:28 - [Music]
32:29 - we want to have some margin between the
32:31 - actual icon
32:32 - and the space around it and the reason
32:36 - we want that is because if there's a
32:37 - neighboring card we want
32:38 - to have some white space in between the
32:41 - two
32:42 - [Music]
32:44 - and so that's the next thing i want to
32:45 - implement with you which is how do we
32:47 - add some margin
32:48 - so that we're not always flush with the
32:51 - card next to us and this also turns out
32:54 - not to be that difficult we're going to
32:56 - define a constant
32:57 - which is the margin size i'm going to
32:59 - define that in a companion object
33:02 - in kotlin companion objects are
33:03 - singletons where we'll define constants
33:06 - we can access its members directly
33:08 - through the containing class
33:09 - think of companion objects similar to
33:11 - static variables in java
33:13 - let's define a constant called margin
33:15 - size and i'll set that equal to 10
33:16 - that's what i found to be a reasonable
33:18 - distance between each memory card
33:20 - so the card width we actually want it to
33:23 - be reduced
33:24 - by the amount of margin on either side
33:26 - to the right and left and so i'm going
33:28 - to subtract
33:29 - 2 times the margin size and similarly we
33:32 - want to reduce the maximum allowable
33:34 - card height by the margin on the top
33:36 - and bottom so we'll subtract two times
33:38 - the margin size again
33:39 - now we're measuring the dimensions of
33:40 - the card taking into account the margin
33:42 - but we actually need to set it
33:43 - when we grab the card view reference
33:46 - from the view
33:47 - we have to cast the layout params as a
33:50 - special type of layout params called
33:51 - margin layout params
33:53 - and once we've done that now we should
33:55 - be able to
33:57 - set the margin on the layout params so
33:59 - let's say set margins and we're going to
34:00 - set the margin size all around
34:04 - on all four sides let's try it
34:09 - that's so much better now we have this
34:10 - nice white space margin between each
34:12 - memory card
34:13 - one quick improvement i'd like to make
34:14 - here is adding some margin on the
34:16 - recycler view as a whole at the top and
34:18 - bottom so going back into activity main
34:21 - i'm going to add a 8 dp margin to the
34:24 - top and bottom
34:25 - and let's just see if that looks a
34:26 - little bit better now
34:28 - great i like that a lot more because it
34:30 - gives us some breathing room between the
34:31 - memory cards and the underlying parent
34:33 - view
34:33 - right now when i tap on any of these
34:35 - elements nothing actually happens to
34:36 - wrap up this segment i would like to
34:38 - actually register a click listener on
34:40 - each image button which is what these
34:42 - are so going back into
34:45 - the memory board adapter inside of the
34:48 - view holder when we bind the view holder
34:51 - we're going to
34:51 - grab a reference to the image button
34:53 - which is inside that card view
34:55 - so the way we can do this is in the
34:57 - constructor of the view holder
35:00 - i'm going to define the image button
35:02 - [Music]
35:08 - the id we gave it was image button
35:12 - and so here we want to actually set the
35:14 - image button click listener
35:18 - [Music]
35:21 - i'm going to add a log statement here
35:23 - click
35:24 - on position and then let's
35:28 - print out the position so we need to
35:30 - define this tag which we'll do in the
35:32 - companion object
35:35 - and the convention that i use is the tag
35:37 - name is always the class name
35:39 - so in this case the class name is memory
35:41 - board adapter
35:43 - and let's try this one more time so
35:44 - we're going to run the application and
35:46 - also open up logcat
35:49 - so i am going to filter out only for
35:52 - info level logs because we actually have
35:54 - this at info level
35:55 - and i'm also going to look for logs from
35:58 - memory board adapter so i started typing
36:01 - in memory
36:02 - and now if we tap on an element you can
36:04 - see okay we do see click on position
36:06 - zero if i go down here
36:07 - that's position two position four and
36:09 - this last one is position seven which
36:11 - makes sense
36:11 - because we have eight cards from
36:13 - position zero to position seven
36:16 - just one more thing before before we
36:17 - wrap up this segment if you
36:19 - notice if we go to the ends of the
36:21 - recycler view and scroll up or down we
36:23 - get these
36:24 - shadows which are the material design
36:26 - way of
36:27 - indicating that we're at the end of this
36:29 - recycler view there's no more content
36:31 - in our app it doesn't really make that
36:33 - much sense because we are mandating or
36:35 - guaranteeing
36:36 - that the content of the recyclerview
36:38 - will be fit
36:39 - to the screen dimension because the
36:41 - content is never scrollable we should
36:42 - never be seeing this visual indicator
36:44 - called edge effect
36:45 - and so if we go back into activity main
36:48 - and then go into the recycler view
36:49 - and then search for this attribute
36:51 - called over scroll mode
36:53 - and set that to never that should
36:56 - address that issue so if we
36:57 - rerun the app now
37:00 - when i scroll up or down you can see
37:03 - that there is no shadow
37:04 - the goal for the next part is to
37:06 - introduce the notion of a board size so
37:08 - we don't have to keep hard coding in a
37:09 - 4x2 grid
37:10 - and we'll create some icons that the
37:12 - user will eventually pair up as part of
37:14 - the memory game
37:17 - now we have this hard-coded 4x2 grid of
37:19 - 8 memory cards
37:20 - the first thing i want to do in this
37:22 - segment is create some flexibility so we
37:24 - can
37:24 - easily increase or decrease the number
37:26 - of memory cards in our game
37:28 - and the second thing i want to do is
37:30 - create a bunch of vector icons
37:32 - which will be used as the default icons
37:34 - when we play a new memory game
37:36 - so first off in order to build in more
37:38 - flexibility into the dimensions of our
37:40 - memory game
37:41 - there's a couple things we need to
37:42 - adjust so first off right now
37:45 - we are passing in two and four here as
37:48 - the dimensions of the board which is
37:50 - incorrect
37:51 - that'll change depending on how many
37:53 - cards are in a memory game
37:54 - and second we also are passing in two
37:57 - here for the span count which is how
37:58 - many columns are in our board and that
38:00 - also might change
38:01 - so in order to encode all the different
38:03 - information about the size of the board
38:05 - i'm actually going to create an enum
38:07 - called board size and so if you open up
38:10 - the directory where main activity is
38:11 - located i'm going to create a new
38:12 - package here
38:15 - a new package called models and we're
38:18 - going to add to this
38:19 - later on with a couple other things but
38:20 - for now the only thing this will have
38:22 - is a
38:26 - kotlin file called board size
38:30 - and this is going to be an enum and an
38:33 - enum can optionally take in
38:35 - a value and so we're going to pass in a
38:38 - vowel here called num cards this is
38:41 - going to be an int
38:42 - so in our current example what we have
38:44 - now num cards would be eight
38:46 - because four by two we're going to have
38:49 - three different values of board size
38:51 - first is easy
38:54 - second is medium and that'll be 18 cards
38:58 - and then lastly is hard which is 24
39:00 - cards
39:01 - and these are the different options for
39:03 - the memory game
39:04 - so the current version that we're
39:06 - playing is easy there's only eight cards
39:07 - medium is 18 and
39:08 - hard is 24. we also want to encode
39:12 - in this enum information about the width
39:14 - and height
39:15 - corresponding to each board and so i'm
39:17 - going to define a
39:19 - couple other methods here one is called
39:21 - get with
39:23 - it's going to return int and depending
39:26 - on the value of the enum
39:28 - i would like to be able to figure out
39:31 - what is the width
39:32 - of the game and so the way we can do
39:34 - this is say
39:36 - return using the when construct
39:39 - this is referring to the board size on
39:41 - which we're operating easy medium or
39:42 - hard
39:43 - and the one expression is similar to a
39:45 - switch statement so it'll evaluate a
39:47 - list of conditions and it'll return when
39:49 - the first one is met
39:50 - so we're going to have android studio
39:51 - help us to create all the remaining
39:53 - branches and what that did
39:54 - is create a branch for each of the three
39:56 - enum values
39:58 - and so in the case of easy the number of
40:00 - cards
40:01 - width-wise is going to be two in the
40:03 - medium case we're gonna have a six by
40:04 - three
40:05 - board so we'll have three cards by and
40:07 - in the hard case we're gonna have four
40:08 - cards wide they'll be six by four
40:11 - we're also going to have one method here
40:12 - which is get height
40:15 - and one thing to observe is that the
40:17 - height is fully determined
40:18 - once we know the number of cards and the
40:21 - width
40:22 - right and so the value here is simply
40:24 - going to be
40:25 - the number of cards divided by get with
40:29 - [Music]
40:30 - and finally there's one more method i
40:33 - want to
40:34 - add in here called get num pair
40:37 - is also going to return in and this
40:39 - method is going to represent
40:41 - how many pairs of cards are there right
40:43 - so if we have
40:44 - eight memory cards in our game that
40:46 - means we're gonna have four unique pairs
40:48 - and so this is simply going to be the
40:51 - number of cards divided by
40:52 - two okay awesome
40:55 - so now back in main activity instead of
40:57 - hard coding in eight
40:59 - let's define a variable up here called
41:02 - private var board size
41:07 - this is of type of our enum that we
41:10 - defined
41:10 - and initially the value is going to be
41:12 - board size dot easy
41:15 - and i would like the memory board
41:17 - adapter to take in the board size
41:18 - instead of the number of pieces and then
41:21 - the grid layout manager
41:23 - the second parameter is how many columns
41:26 - are there and that'll simply be
41:27 - board size dot get width
41:31 - now let's fix up the adapter and the
41:32 - second parameter should be
41:34 - of type board size instead of the int so
41:36 - i'm going to tap this rear light bulb
41:37 - and change the parameter
41:39 - to the board size so going back into
41:41 - memory board adapter
41:42 - let's change the variable name to
41:44 - reflect that
41:47 - and now that we have this we can
41:51 - update get item count to be board size
41:54 - dot num cards that's the total number of
41:57 - elements in our memory game and the
42:00 - final thing we need to do is update what
42:02 - we're dividing
42:02 - the width and height by and this is
42:04 - going to be the width divided by
42:06 - the board size get width and the height
42:09 - we're going to divide by
42:11 - how many elements tall is our board
42:16 - let's try it from the ui perspective
42:18 - this should be identical
42:20 - and you can see it is but the benefit of
42:23 - what we did what we did
42:24 - is we can now very easily adjust the
42:27 - size of the board for example making it
42:28 - hard
42:29 - and now we should expect to see a 6x4
42:32 - grid instead of a 4x2 and you can see
42:34 - that that actually happened
42:35 - and the dimensions and spacing of these
42:36 - memory cards is looking good
42:38 - awesome so the next thing i want to do
42:40 - in this segment is create
42:42 - icons which will be the actual
42:44 - underlying image for each of these cards
42:46 - and this luckily turns out to be really
42:48 - easy because android studio has a really
42:50 - nice way to do this
42:52 - open up the res directory which stands
42:53 - for resources and right click on
42:55 - drawable
42:56 - and go to new and tap on vector asset if
42:59 - you look at clipart here
43:01 - android studio comes bundled in with all
43:03 - of these
43:04 - free open source icons that we can use
43:07 - and this is what we're going to be using
43:08 - to power the default version of our
43:10 - memory game
43:12 - so for example why don't we start by
43:14 - creating one icon which is the face
43:16 - so just search for face and we have this
43:18 - nice clip art
43:19 - and i want to change the color of this
43:22 - to be red
43:23 - so red is 255 255.00
43:26 - choose that and then let's also rename
43:28 - this to be icyface
43:30 - tap on next and then this is just
43:33 - telling us that
43:34 - it'll be located inside of the drawable
43:35 - directory ic underscore face and tap on
43:38 - finish
43:38 - let's peek inside the created file and
43:41 - one of the things that amazed me
43:42 - when i first learned about vector
43:43 - graphics is that the file is simply
43:46 - xml data which describes the set of
43:49 - points
43:50 - lines and curves along with associated
43:52 - color information so the image that
43:53 - we're seeing on the right is completely
43:55 - described by the text in the xml file
43:58 - and so the really nice thing about these
44:00 - vector assets is that they're much much
44:01 - smaller
44:02 - compared to a jpeg or png file where you
44:05 - have to encode information about all
44:06 - these different pixels and there could
44:08 - be
44:08 - thousands of pixels in your image and
44:11 - the other nice thing about this is that
44:13 - these are infinitely scalable so because
44:14 - we're just defining the path data here
44:16 - whether the image is a hundred by a
44:18 - hundred or a thousand by a thousand
44:20 - this image will always be crystal clear
44:23 - so that's a really nice
44:24 - thing about these vector assets and so
44:26 - if we look back to the board size
44:28 - the maximum size of our board is 24
44:32 - and that means we need to create 12
44:33 - unique icons for our memory game
44:36 - so right now we have one we're going to
44:37 - create 11 more so let me explain
44:39 - the logic behind how i created the
44:41 - vector icons and you can do something
44:43 - similar
44:44 - so you're free to choose whatever icons
44:45 - you want in order to build your memory
44:47 - game
44:47 - but i did some thinking about it and
44:49 - there are two things that we would like
44:51 - to optimize
44:51 - for as we pick our icons one is that the
44:54 - icons the vector icons that we create
44:56 - should be distinct shapes
44:58 - and second they should be distinct
44:59 - colors and the idea here is that
45:01 - when you're playing memory you want to
45:03 - have each unique image be as
45:05 - distinct as possible the shapes will
45:08 - come simply because we're choosing
45:09 - different icons
45:10 - the colors are a bit more interesting so
45:13 - as we think about
45:14 - what colors to make our icons each color
45:16 - is represented as a red
45:18 - green blue component and each of these
45:20 - three components
45:21 - is an integer between 0 and 255. if you
45:24 - wanted to create
45:25 - as distinct colors as possible the way
45:28 - you would do this
45:29 - is try and have the distance between
45:32 - each color
45:32 - as per the rgb value be as different as
45:35 - possible
45:36 - so the first thing that comes to mind is
45:38 - why don't we light up
45:39 - or maximize each individual component
45:41 - that's how we get
45:42 - a solid red solid green and solid blue
45:45 - just by having
45:46 - each of the three components be 255 we
45:48 - can also do something
45:49 - like this where we go halfway on each so
45:52 - you have 128 0
45:53 - 0 and that becomes a little bit of a
45:55 - darker red and similarly for
45:56 - this dark green and this dark blue
46:00 - for the other six colors we can combine
46:03 - each of these three primary colors so we
46:05 - can make yellow by combining red and
46:07 - green
46:08 - and then i picked a couple others as
46:09 - well that you're welcome to
46:11 - copy from me as well so combining these
46:13 - colors with different icons that we
46:15 - picked
46:15 - here's what i came up with on the left
46:17 - is what i'll name
46:18 - each icon i see face flower gift and so
46:21 - on
46:22 - the second column indicates the name of
46:24 - this icon in the vector asset studio so
46:26 - you can find it
46:27 - and the third column shows you what the
46:29 - icon will look like with the selected
46:31 - color
46:32 - now let's go create these in android
46:34 - studio let's repeat the process for
46:36 - creating the face icon several more
46:38 - times
46:38 - so we'll right click on drawable go to
46:40 - new and go to vector asset
46:43 - the next asset we'll create is the
46:44 - flower local florist is the name
46:47 - and we'll change the name in our project
46:50 - to the ic flower
46:51 - and we'll change the color to be green
46:58 - tap on finish and now i'm going to speed
47:00 - through this for the other 10 icons
47:10 - [Music]
47:28 - all right done now we have these 12
47:31 - different icons
47:32 - the next step is to reference them in
47:34 - column code so we can start to use them
47:36 - in our memory game
47:37 - so the way i'm going to do this is i'm
47:38 - going to create a new package
47:41 - called utils and inside of the utils
47:45 - it's going to be a
47:45 - kotlin file called constance
47:52 - and we're going to now define a list of
47:54 - these drawables that we just created
47:56 - so i'll call this default icons
48:00 - and it's going to be a list of all the
48:03 - different drawables so i see face
48:08 - then we have to import resources and
48:11 - similarly for the other 11 icons that we
48:13 - created i'm just going to reference all
48:15 - of them by saying r.drawable dot
48:17 - the name of the icon now we have this
48:20 - list variable
48:21 - called default icons which will be the
48:23 - icons we use in our memory game
48:25 - let's go back now into the main activity
48:29 - let me exit out a couple of these files
48:33 - and what we would like to do is pass
48:35 - into the adapter
48:36 - the list of image icons these drawables
48:40 - that should make up that game so we're
48:42 - going to have we're going to end up
48:43 - adding one more parameter here
48:45 - the way we'll do this is grab the
48:47 - default
48:48 - icons that we just defined i'm going to
48:51 - randomize
48:52 - that list and then we're going to take a
48:54 - certain number
48:56 - and the number of images that we take
48:58 - will be board size
49:00 - dot get num pairs and the reason we want
49:03 - to do this is because for example in the
49:06 - eight card memory game we're going to
49:07 - have four distinct images right
49:09 - it'll be the number of cards that i bet
49:11 - you which is what we're doing in get num
49:13 - pairs
49:13 - so we're going to take four images out
49:15 - of the default icons so this is going to
49:17 - return to us
49:18 - the set of chosen images for our memory
49:21 - game
49:23 - and now what we want to do is we want to
49:25 - double up those images so we'll end up
49:26 - with two copies of each image
49:28 - we'll say randomized images
49:31 - is equal to chosen images double it up
49:35 - so we have each image in there twice and
49:38 - we want to randomize that list by again
49:39 - calling dot shuffled
49:42 - and now this randomized images list is
49:44 - what we're going to pass in to the
49:45 - adapter
49:46 - [Music]
49:48 - so tap on that red light bulb and add
49:51 - the
49:51 - randomized images as a parameter tap on
49:54 - refactor
49:55 - and then now let's go into the
49:56 - definition of memory board adapter
49:59 - and i'm going to rename this to be card
50:00 - images
50:03 - it's going to be a list of int these
50:05 - integers represent
50:06 - one of these drawable resources so now
50:09 - we can actually start to reference this
50:11 - inside of bind so what we want to do is
50:14 - based on the position we want to grab
50:17 - the corresponding image
50:19 - and that should be the image on the
50:21 - image button
50:22 - so they set image resource and that'll
50:25 - be
50:26 - card images oops we have to actually
50:29 - make this card images
50:30 - a private valve so we can reference it
50:32 - [Music]
50:33 - now go back here card images and
50:38 - position let's try it
50:41 - and looks like we have a build error
50:42 - here i need to add in the closing
50:45 - bracket let's try it again this
50:47 - succeeded
50:48 - so right now you'll remember in
50:50 - mainactivity.kotlin we're hard coding in
50:52 - the board size of hard which means we
50:54 - have 24
50:55 - memory cards in the game and you can see
50:57 - that all the vector icons that we
50:58 - created are in this board and there are
51:00 - exactly two copies of each
51:02 - and because we're randomizing it if i
51:04 - run this application again
51:05 - we should see that these images are in
51:07 - different places so right now we have
51:08 - this
51:08 - graduation cap the school icon in the
51:10 - top left let's run this again
51:12 - and hopefully that should be in a
51:14 - different position now so you can see it
51:15 - is
51:16 - and then if we also go back into the
51:18 - easy
51:19 - version of the board run this now we
51:22 - should be randomly picking four
51:23 - images out of the 12 that we have and
51:25 - there should be two copies of each
51:27 - placed randomly among the eight
51:28 - positions and if we run the app again we
51:31 - should
51:31 - have chosen different images and they
51:33 - should be in different positions which
51:34 - we are seeing here awesome
51:36 - so now we have this well-defined board
51:38 - size concept along with a set of icons
51:40 - to play the game
51:42 - in the next part we'll start
51:43 - implementing the game logic
51:46 - the goal for this segment is to lay the
51:48 - groundwork for the memory
51:50 - game logic that will write and the key
51:52 - observation here
51:53 - is that every memory card will have an
51:56 - associated state
51:57 - so for example a memory card can either
51:59 - be face up which means that the image
52:01 - is showing or it can be face down which
52:04 - is the default state
52:05 - in how the game starts and so in order
52:07 - to capture all of that
52:09 - we're going to create a data class in
52:10 - kotlin representing one memory card
52:13 - so open up the project tool window and
52:16 - inside of the models directory let's
52:19 - create a new
52:21 - kotlin file called memory card
52:24 - [Music]
52:27 - this is going to be a data class and
52:30 - the objective here is we want to list
52:32 - out every attribute
52:34 - of a memory card so first off is
52:37 - we're going to capture the idea of an
52:39 - identifier for the card
52:41 - this represents the uniqueness of the
52:43 - memory icon which is the
52:44 - underlying resource id integer of the
52:47 - memory card
52:50 - and this is going to be of type int
52:51 - because the actual identifier is going
52:53 - to be a drawable resource that we
52:54 - defined earlier
52:56 - the second attribute of a memory card is
52:58 - whether it's face up or face down
53:00 - so we're going to define another
53:01 - attribute called is face up which will
53:03 - be a boolean
53:04 - and this will initially be false because
53:06 - everything will start out all memory
53:07 - cards will start out
53:08 - face down there's an important
53:10 - distinction here
53:11 - of val versus var a vowel is something
53:14 - which
53:15 - once it's set the value of it can't be
53:17 - changed whereas
53:18 - var means that the value can be changed
53:21 - during the course of a memory game we'll
53:22 - be flipping cards over
53:23 - which means that the is face up property
53:25 - will change over time and therefore
53:27 - it has to be a var on the other hand the
53:29 - memory card identifier
53:30 - will never change once it's set so
53:32 - that's why we made that a vowel
53:34 - there's one more attribute of the memory
53:36 - card which is
53:37 - is matched and that represents if this
53:39 - memory card has found
53:40 - its corresponding pair and as you play
53:43 - the game you're going to be matching up
53:44 - cards and when you've matched everything
53:45 - up
53:46 - you won the game and so this is also
53:48 - going to be a var
53:49 - is matched and it'll be a boolean with
53:51 - initial value of false
53:53 - okay so now that we have this data class
53:55 - in main activity.kotlin
53:57 - each randomized image that we have this
54:00 - list of images that make up the
54:02 - memory game each of those will
54:04 - correspond to one memory card
54:06 - and i want to create a list of these
54:08 - memory cards and the way we'll do that
54:10 - is we're going to utilize the map
54:13 - function
54:14 - on randomized images and what that does
54:16 - is for every element of randomized
54:18 - images
54:19 - we're going to do an operation and
54:20 - create a new list we're going to
54:22 - transform randomized images into a new
54:24 - list
54:24 - in particular create a new memory card
54:26 - object
54:28 - we're going to call the constructor
54:29 - memory card this takes the three
54:31 - parameters that we just defined
54:32 - first is it is the identifier and that
54:34 - will be the current randomized image
54:36 - that we're mapping over and we refer to
54:37 - that as
54:38 - it and then there are two more
54:40 - parameters here
54:41 - one which is is face up and third is
54:45 - is matched because we define a default
54:47 - value for is face up and is matched
54:50 - we actually don't need to specify here
54:52 - so this can be as simple as
54:55 - randomized images.map memory card of
54:58 - it and this is now going to return to us
55:00 - a list of memory cards
55:06 - and instead of passing in the list of
55:08 - randomized images i instead will
55:10 - will want to pass in the list of memory
55:11 - cards so let's update the third
55:14 - parameter
55:14 - of the adapter to be of type memory card
55:19 - going to memory let's go into the
55:20 - adapter and change this to be
55:23 - just cards
55:24 - [Music]
55:28 - now we can actually start doing
55:29 - something interesting with setting the
55:30 - image resource
55:31 - by default the image resource should be
55:34 - face down it should be the default image
55:36 - and only if the card is face up do we
55:39 - want to
55:40 - show the corresponding image and so here
55:43 - what we're going to do is
55:44 - grab the card at that position and check
55:47 - is it face up or not and
55:50 - if it is face up then we want to
55:54 - show the drawable image so we'll call
56:00 - cards position and then passing the
56:03 - identifier
56:05 - and otherwise we want to pass in the
56:08 - default icon which is the face down and
56:10 - that will be r.drawable
56:12 - dot ic launcher background and one thing
56:15 - we can do just to make this a little bit
56:16 - cleaner is
56:17 - save the variable of card's position
56:19 - into a local variable
56:21 - so what we're saying here is that if the
56:23 - memory card is face up then we will
56:25 - use that as the image otherwise we'll
56:28 - use the background
56:29 - so if we try this now we should see a
56:32 - change
56:32 - such that all the cards are face down
56:34 - initially and
56:35 - the next step is when we actually tap on
56:37 - one of these we would like to be able to
56:39 - toggle
56:39 - or switch the value of this property is
56:42 - face up
56:42 - before doing that one more thing i'd
56:44 - like to do is have a separate class
56:46 - which will encapsulate all the logic for
56:49 - the memory game
56:50 - so right now we have a data class which
56:52 - represents one memory card
56:53 - but there's also a notion of the game
56:57 - itself has some state
56:58 - and we would like to be able to maintain
57:00 - that in in a class as well
57:02 - and so we're going to again go back into
57:04 - the same directory which has memory card
57:06 - the models class
57:07 - and let's define a new column file
57:09 - called memory game
57:12 - [Music]
57:14 - and this memory game is going to take in
57:17 - the
57:17 - board size and we want to delegate a
57:19 - responsibility of creating all the cards
57:21 - into the memory game that shouldn't
57:23 - happen in the main activity that should
57:24 - actually happen
57:25 - inside of the memory game and so let's
57:28 - add in
57:29 - as a constructor the board size here
57:33 - [Music]
57:34 - the cards are going to be a member
57:36 - variable in this class
57:40 - i'm also going to have a couple more
57:41 - which we're going to add over time but
57:43 - to start out with we're going to have
57:44 - one which is
57:45 - num pairs found and this is going to be
57:48 - zero when you start the game you have
57:50 - found no pairs
57:51 - in the constructor of the memory game
57:53 - we're going to do the work to populate
57:56 - these list of memory cards i'm going to
57:58 - add this in the init block
58:00 - and the work we're going to do here is
58:02 - exactly the work that we already did
58:04 - over here i'm going to copy all this
58:11 - the idea is that we are constructing the
58:14 - list of cards
58:14 - based on the board size we are picking
58:17 - some random
58:18 - images and then based on that creating a
58:20 - memory card data class
58:22 - so now all we need to do is construct
58:26 - our memory game
58:27 - [Music]
58:34 - and the third parameter of memory board
58:35 - adapter should be the
58:37 - list of cards which we can now get a
58:39 - reference to
58:40 - using the cards property of the game
58:44 - awesome so again there's no functional
58:46 - change here all we're doing is kind of
58:47 - moving some code around
58:48 - so it's cleaner to understand where
58:50 - we'll add logic in the future
58:52 - the last thing i want to do is changing
58:54 - the state
58:55 - of a memory card when we tap on it going
58:57 - into the memory board adapter
58:59 - here is where we are getting notified of
59:01 - a click on an image button and we would
59:03 - like to notify the main activity
59:05 - of this click so that the main activity
59:06 - can then tell the memory game
59:08 - class that the user has taken some
59:10 - action and we should update the state
59:12 - appropriately
59:12 - and so the standard pattern for doing
59:14 - this is to define an interface
59:17 - so let's do that up here it'll be
59:20 - interface
59:21 - card click listener
59:22 - [Music]
59:25 - and this is going to have one method
59:28 - called
59:29 - on card clicked and it's going to take
59:32 - in a position which is of type int
59:36 - and the reason why we're defining this
59:37 - interface is because whoever constructs
59:39 - the memory board adapter
59:40 - it will be their responsibility to now
59:42 - pass in an instance
59:44 - of this interface and so i'm going to
59:46 - add one more variable
59:48 - in the constructor called card click
59:51 - listener
59:52 - [Music]
59:54 - and this is of type card click listener
59:56 - and now
59:57 - when an image is clicked we are going to
59:59 - invoke this
60:00 - method on the interface so i'll say card
60:02 - click listener
60:03 - dot on card clicked with this position
60:07 - well and so now back in the main
60:10 - activity we're going to get an error
60:11 - right here
60:11 - because we haven't passed in
60:13 - cardclicklistener object and the way
60:15 - we'll do that
60:16 - is by writing the word object and
60:19 - specifying we want to create an
60:22 - anonymous class
60:24 - which is of type cardclicklistener
60:27 - and here android studio can help us with
60:29 - this red underline
60:30 - under object android tells us hey
60:34 - this is the interface so in order to
60:36 - implement this you have to
60:38 - override this one method on card clicked
60:40 - and so now here is where we can
60:42 - add logic for toggling the is face up
60:46 - property of this card
60:47 - so for now i'm just going to put a log
60:48 - statement here
60:51 - just to make sure that we are able to
60:53 - actually get notified of the card click
60:56 - back in main activity
60:59 - and then we need to find a tag for this
61:01 - let's do that
61:06 - [Music]
61:07 - all right let's run it so we're not
61:10 - expecting any functional change but now
61:11 - if we open up logcat
61:18 - so now we're seeing two log messages
61:20 - every time we click on
61:22 - one of the cards the first one is coming
61:24 - from the memory board adapter and the
61:25 - second one
61:26 - is main activity being notified of this
61:28 - card click
61:29 - at the same position so in the next
61:32 - segment we're actually going to
61:34 - write the game logic for being able to
61:36 - flip over the card and also create
61:38 - matches our goal now is to implement the
61:41 - logic
61:41 - for the memory game so when i tap on a
61:43 - memory card i should be able to flip it
61:45 - over
61:45 - and also there should be some logic to
61:47 - check if two cards that have flipped
61:49 - over
61:49 - are matched this is a interesting
61:52 - challenge and you'll find that if you
61:53 - break it down case by case
61:55 - the code actually becomes quite simple
61:58 - so in mainactivity.kotlin we have a log
62:01 - statement here
62:02 - for when the card has been clicked and
62:05 - so i'm going to delete that
62:06 - and let's actually delegate the work of
62:07 - this into a method called
62:09 - update game with
62:13 - flip at this position
62:20 - all right and the idea here is that this
62:22 - method is responsible for
62:23 - updating the memory game with an
62:25 - attempted flip
62:26 - at this position all right and so
62:30 - we're gonna just delegate the work here
62:32 - into the memory game
62:34 - and so in order to reference memory game
62:36 - i need to make this a
62:38 - property of the class so create property
62:41 - memory game
62:43 - and it'll be late init var so late in it
62:45 - because we know that memory game is
62:47 - going to be initialized
62:48 - properly but it will only happen on
62:50 - create so that's why we're going to add
62:52 - this as late in it
62:53 - and then one other variable that i would
62:55 - like to make into a property
62:57 - is the adapter so we're going to split
62:59 - the assignment
63:00 - and the declaration of the variable
63:04 - and then we're going to define another
63:06 - variable which is a property of the
63:07 - class
63:08 - called adapter and this is of type
63:10 - memory board adapter
63:12 - so now we can reference adapter from
63:14 - multiple methods and not just the
63:16 - oncreate method
63:17 - so in the update game with flip the
63:19 - memory game itself should be responsible
63:21 - for handling
63:22 - what happens in the state of the game
63:24 - when the memory card at this position
63:26 - is flipped we're going to create a
63:28 - method on the memory game class called
63:30 - flip card and it'll take in a integer
63:33 - parameter called position
63:34 - analytics video will help us to create
63:36 - it
63:40 - and then i'll put this down here here is
63:42 - the
63:43 - game logic that we're going to write to
63:45 - start out with just to make this simple
63:47 - why don't we simply change the value
63:50 - of the is face up property of this card
63:53 - so i'm going to grab the card
63:55 - at this position save that into a
63:58 - variable called card
64:00 - and then we're just going to say card
64:02 - dot is face up
64:04 - is the opposite of what it was so if it
64:06 - was face down before it's gonna be face
64:08 - up if it was face up it's gonna be face
64:09 - down because the user is
64:12 - flipping it over and so once we've
64:14 - flipped the card
64:15 - then we need to tell the recyclerview
64:18 - adapter
64:18 - that the contents of what it's showing
64:21 - has changed and so it should update
64:22 - itself
64:23 - and the way you do that is
64:24 - adapter.notifydatasetchain
64:27 - let's try it
64:30 - so now if i tap on any of these you can
64:32 - see that this underlying
64:34 - image resource is shown and i can go
64:36 - back and forth as well so i can toggle
64:38 - between them
64:40 - so now let's think a little bit more
64:42 - about what exactly should happen
64:44 - when the user attempts to flip over a
64:46 - card
64:47 - so for example if i restart the game
64:51 - if i flip over this card and let's just
64:54 - pick another one like this
64:56 - the next card i flip over should
64:58 - automatically flip
64:59 - back to the default state the two cards
65:01 - that are currently flipped over
65:03 - and so the memory game has to have some
65:06 - some state or some notion of
65:08 - which cards have been previously flipped
65:10 - over and which have not
65:12 - and as soon as i flip over another card
65:14 - now both of these
65:16 - should have gone back down to face down
65:19 - and if you think a little bit more about
65:20 - this it really comes down to
65:23 - exactly three cases so first is there
65:25 - were zero cards previously flipped over
65:28 - [Music]
65:30 - second is there was exactly one card
65:34 - previously flipped over and the third
65:36 - valid case is there are two cards
65:38 - previously flipped over this is the
65:41 - totality
65:42 - of what is possible in a valid memory
65:44 - game you can never
65:45 - ever have three cards flipped over at
65:48 - once so now let's go case by case and
65:49 - figure out how the memory game should be
65:51 - updated when there were zero cards
65:53 - previously flipped over all we need to
65:54 - do is simply flip over that card
65:56 - there's no need to flip over any other
65:58 - cards in the game and
66:00 - there's no way a match could be found
66:01 - yet because after this turn is over
66:04 - only one card will leave left over but
66:05 - you need two in order to make a match
66:07 - moving on to the next case if there was
66:09 - one card previously flipped over
66:11 - we will always flip it over but we also
66:13 - now want to check whether the two cards
66:15 - that are
66:16 - going to now be flipped over if they
66:18 - match and if they do match we want to
66:19 - indicate to the user at the ui layer
66:21 - that the match has been found and we no
66:24 - longer want to allow these cards to be
66:25 - selected or flipped over again
66:28 - and finally in the third case when there
66:30 - were two cards previously flipped over
66:32 - we first want to restore the cards and
66:34 - make them face down again
66:36 - and then we want to take the card at
66:38 - this selected position that the user
66:39 - tapped on and flip that card over
66:42 - so if you can understand these three
66:44 - cases then
66:45 - the rest of the logic is pretty
66:47 - straightforward and one thing i can
66:49 - do to make this even simpler is you'll
66:52 - notice that
66:53 - this case when there are zero cards
66:54 - flipped over or there are two cards left
66:56 - over
66:57 - they're actually identical and the
66:58 - reason is because i could just copy over
67:01 - the same statement restore cards plus
67:03 - flip over selected card
67:05 - into the first case and the idea here is
67:07 - that if there were no cards flipped over
67:09 - previously
67:10 - then this restore card is essentially a
67:12 - no-op so it has no impact
67:14 - and then we will flip over over the
67:16 - selected card
67:17 - and so we've reduced these three cases
67:19 - down into two cases
67:21 - that means the only information we need
67:23 - to distinguish between these two cases
67:25 - is if there was one card previously
67:27 - flipped over and in particular the
67:28 - position of that one card because we'll
67:30 - need that in order to check if the
67:31 - images match
67:32 - this is the key in sight and so what
67:35 - we're going to do is have a variable
67:36 - here
67:37 - called private var index
67:40 - of single selected card
67:44 - and the type of this variable will be a
67:45 - nullable int with initial value of null
67:48 - because when you make a new memory game
67:50 - there is no single selected card
67:52 - so now we can actually start hooking
67:55 - this
67:56 - state up into the flip card method
67:59 - so if the index of the single selected
68:03 - card is null
68:05 - what does that mean that means that
68:07 - there were either
68:08 - zero cards previously flipped over or
68:10 - there were two cards previously flipped
68:12 - over
68:13 - [Music]
68:14 - so in this case like we broke down here
68:17 - in the pseudocode the first thing we
68:18 - want to do is restore the cards
68:22 - and then the second thing we want to do
68:24 - is update
68:26 - the single selected card to be this
68:28 - flipped card
68:29 - right so let's say index of single
68:30 - selected card is now equal to
68:33 - this position that was flipped over
68:36 - so let's define this method restore
68:38 - cards
68:41 - and this turns out to be fairly easy
68:43 - we'll just iterate through the list of
68:44 - all cards that we have
68:46 - [Music]
68:49 - and we want to set the
68:52 - is face up to be false which basically
68:54 - means turn everything back to the
68:56 - default state
68:57 - there's one caveat here though which is
68:59 - that if the card isn't matched
69:02 - then we don't want to do that right so
69:04 - we only want to
69:06 - set the card to be face up if the card
69:08 - is not matched so i'm going to add
69:10 - exclamation mark here
69:11 - and say if the card is not matched then
69:13 - restore it to its default state
69:17 - awesome so in the else condition this is
69:20 - when we have
69:21 - exactly one card previously flipped over
69:25 - so now as per our pseudo code we need to
69:27 - flip over the card
69:28 - and then check if the images match and
69:31 - so let's
69:31 - write that logic add a method here check
69:34 - for match
69:36 - and we're going to pass into this method
69:39 - two positions
69:40 - on the board on the memory board and the
69:42 - objective is that this
69:44 - function will return to us true or false
69:46 - on whether those two positions
69:48 - on the board are identical images or not
69:50 - the first
69:51 - parameter will be index of single
69:52 - selected card and the second will be
69:54 - position
69:55 - and this is going to return to us
69:57 - whether we found a match or not
70:02 - so let's define this method check for
70:04 - match so the first parameter can just be
70:05 - position one
70:08 - and the second can be position two
70:11 - and the return type will be a boolean on
70:12 - whether a match is sound or not
70:14 - so if the card at position one
70:18 - if the identifier of that is not equal
70:21 - to
70:23 - the identifier at position two
70:24 - [Music]
70:27 - then we know that the user has picked
70:30 - incorrectly these two cards are not a
70:32 - match
70:33 - however if these cards do match then we
70:36 - need to update the state
70:38 - of those cards to be is matched is equal
70:41 - to true because now we found the pair
70:43 - the user has found the pair so we should
70:44 - set is match to be equal to true
70:48 - and if this happens we want to update
70:50 - this variable
70:51 - num pairs found and increment it and
70:53 - then let's hit return true
70:56 - all right let's see what is the issue or
70:58 - happening here the num pair is found we
71:00 - defined it as a vowel
71:01 - and it actually should be a var because
71:03 - that will change over time
71:05 - okay and there's one more error here
71:07 - saying that smart cast to int
71:09 - is impossible because index of selected
71:11 - card is a mutable property
71:12 - in order to force this to be a
71:14 - non-nullit i can just use a double
71:16 - exclamation mark
71:17 - to tell the collin compiler to not worry
71:19 - about this
71:20 - and the last thing we're going to do
71:21 - here is that if we get into the else
71:24 - branch which means there was exactly one
71:26 - card previously flipped over after the
71:28 - user has
71:29 - finished flipping the card then there
71:32 - will no longer be
71:33 - exactly one card slipped over and so we
71:35 - need to set index of single selected
71:36 - card to be
71:37 - null and the reason i wanted to save
71:40 - this found match variable is i would
71:42 - like flip card to return to us a boolean
71:45 - on whether a match was found or not and
71:48 - so i'm going to
71:49 - define a variable up here called var
71:51 - found match
71:52 - this is initially going to be false
71:57 - and then it might turn true
72:00 - when the user has flipped over two cards
72:03 - and we're checking the value
72:04 - and then here we're going to return the
72:05 - value of found match
72:08 - before testing this out one more thing i
72:10 - want to do is in the check for match
72:12 - method
72:13 - if our logic is correct we will now set
72:15 - the boolean property
72:16 - is matched when cards are indeed matched
72:19 - and so back in the memory board adapter
72:21 - we can use that information to update
72:23 - the ui appropriately
72:24 - in the bind method based on whether the
72:26 - memory card is matched or not we will
72:28 - set the alpha property
72:29 - of the image button view so the alpha
72:32 - value
72:32 - refers to the opacity how visible is the
72:35 - the image button
72:36 - and so if the memory card is matched
72:38 - we'll set it equal to a lower value 0.4
72:40 - in order to fade it out and make it less
72:42 - prominent and the
72:44 - f here stands for float which is a
72:45 - different kind of number compared to an
72:47 - integer
72:48 - and in the else condition we will set
72:50 - the value to 1.0 which is a default
72:52 - full bleed opacity and one more thing we
72:55 - can do here is
72:58 - if the memory card is matched then
73:01 - we can change the background of matched
73:03 - cards to
73:04 - be a little bit grayed out and the way
73:06 - you can do that is i can say context
73:08 - compat
73:09 - dot get color state list
73:13 - context r dot color dot
73:17 - color gray and we're going to define
73:19 - what that is
73:21 - also null this is now going to be a
73:23 - color state list
73:29 - and we're going to call this method view
73:32 - compat
73:33 - dot set background tint list image
73:35 - button
73:36 - color state list the idea here is that
73:40 - the set background tint list is a way to
73:42 - set a background or shading onto the
73:44 - image button
73:45 - and so if the image is matched we're
73:46 - going to have a
73:48 - gray background which we create using
73:51 - contextcompat.getcolorstatelist with the
73:52 - gray color
73:54 - and that will be one more visual
73:56 - indication of the user that this
73:57 - card has been matched so let's now
73:59 - define
74:00 - this color resource so have indirect
74:03 - video help me to create a color value
74:05 - resource color gray
74:06 - and the value is going to be this gray
74:09 - color
74:10 - eo times three tap on okay
74:14 - and just to show you what that did if we
74:17 - command click or control click on color
74:18 - gray
74:19 - it added one more line into the color
74:21 - xml with the color that we picked
74:24 - all right let's try it
74:28 - it looks like we have an error here
74:29 - invalid color and i think i just forgot
74:31 - the hash
74:32 - symbol here all right let's try one more
74:33 - time
74:36 - so i'm going to flip over a card flip
74:37 - over one more and in this case
74:39 - these cards don't match so we don't
74:42 - apply
74:42 - the different ui effect of cards being
74:45 - matched but now the here's the real test
74:47 - when i flip over a next card
74:49 - both of these cards should go back to
74:51 - being flipped over
74:53 - let's see if that happens okay awesome
74:55 - so you can see that
74:56 - both of these did go back and now we're
74:58 - flipping over exactly one card
75:01 - so we're playing a valid game of memory
75:03 - now
75:05 - let's see if i can find a match so
75:06 - here's a house and the other house was
75:08 - here
75:10 - so there you can see that we found a
75:11 - match and that resulted in us having
75:13 - this gray background color applied to
75:14 - the
75:15 - button and the alpha value goes down to
75:19 - 0.4
75:19 - this is a nice way of telling the user
75:22 - that these cards have been matched
75:23 - already
75:25 - all right we found one more match and
75:28 - one more thing i want to try here now is
75:29 - both of these cards are flipped over
75:31 - let's say now i actually tried to
75:34 - tap on this graduation cap one more time
75:38 - that's a little bit weird it actually
75:40 - led to this memory card being flipped
75:42 - back to the state and this one stays
75:44 - flipped over the correct thing to do
75:46 - here is
75:47 - not allow the user to make this invalid
75:49 - move
75:50 - let's try one more time so if i click
75:53 - this card again
75:54 - we're kind of in this bad state now
75:57 - where
75:58 - the user is able to tap on something
76:01 - which shouldn't be a valid move in
76:02 - memory
76:03 - that is what we're going to handle in
76:06 - this update game with flip method
76:08 - so here we need to do some error
76:10 - handling
76:12 - there are two errors that can happen one
76:13 - is if we've won the memory game
76:15 - and second is if that memory card is
76:17 - already face up
76:19 - so first if we've won the game of memory
76:23 - this is going to be a method defined on
76:25 - the memory class on the memory game
76:27 - class
76:27 - then we want to return because this
76:30 - move isn't valid so we want to maybe
76:32 - alert the user
76:35 - and the other error case is if
76:37 - [Music]
76:41 - the card at that position is already
76:43 - face up
76:48 - and then same thing in that case we want
76:49 - to tell the user that this what they're
76:51 - trying to do is invalid
76:52 - and then return early so let's define
76:55 - have one game
76:58 - but this is pretty straightforward
77:00 - because we know how many pairs
77:02 - have been found that's this variable
77:04 - here num pair is found
77:05 - so we know we've won the game when the
77:07 - number of pairs
77:11 - is exactly equal to the total number of
77:13 - pairs that should be in this board
77:15 - so we'll say board size dot get num
77:18 - pairs
77:20 - let's also define this is card face up
77:22 - method
77:23 - and again this is pretty straightforward
77:26 - all we need to do here
77:27 - is grab the cart at that position and
77:29 - check the value
77:30 - of is face up
77:35 - so in order to check if this actually
77:36 - worked i would like to
77:38 - show some ui when either of these things
77:41 - happen
77:41 - and the way we can do this is by using a
77:44 - snack bar
77:44 - the snack bar is an android component
77:46 - which shows up at the bottom of the
77:47 - screen
77:48 - and you can use it as a way to message
77:51 - to the user
77:52 - about something so i'm going to say
77:54 - snackbar.make
77:56 - and we need to pass in a view here the
77:58 - root view
78:00 - i'll call this yellow root and i'll
78:01 - define that in just a little bit
78:03 - i'll say u already one
78:08 - and then we need to find a length here
78:09 - snack bar dot length long
78:11 - and then show it and then
78:14 - if the card is face up then
78:18 - invalid here we need to define
78:22 - the root element on which this snack bar
78:24 - will be anchored and that's
78:26 - pretty easy to do all we want to do is
78:28 - go into the activity main
78:30 - and this cl root is going to refer to
78:32 - the constraint layout the very
78:34 - root element so i'll give this an id of
78:36 - cl root
78:38 - go into main activity and let's define
78:40 - that up here
78:41 - [Music]
78:46 - just subtype constraint layout and then
78:49 - we need to
78:50 - add it right here clru is able to find
78:53 - view by id r dot id
78:54 - cl root okay so hopefully the errors
78:57 - went away with the snack bar awesome
78:59 - let's try running this one more time
79:02 - i flip over a card let's try flipping
79:04 - over the card one more time
79:06 - and you can see invalid move which is
79:08 - great so
79:09 - in a in actual game of memory you
79:11 - shouldn't be allowed to flip over the
79:12 - same card twice
79:13 - so we have to flip over one more card
79:15 - after we flip this one over
79:17 - awesome so if i do the same thing that's
79:19 - invalid
79:20 - and let's actually play the game
79:25 - okay now we've won so now at this point
79:27 - we shouldn't be allowed to flip over any
79:29 - card
79:29 - right so if i tap on any card you can
79:32 - see that we get that snack bar you
79:33 - already won
79:34 - so just to review what we're doing here
79:36 - is in the update game with flip method
79:38 - the user is
79:39 - attempting to flip a card at that at
79:41 - this position in the
79:42 - recycler view and we're doing some error
79:45 - checking to begin with
79:46 - and then down here we're actually
79:48 - flipping over the card
79:50 - and this flip card method returns a
79:52 - boolean now i'm going to capture that
79:54 - let's put a log statement here
79:56 - indicating that we found a match
79:58 - and let's also print out the number of
80:00 - pairs that the user has found so far
80:02 - and that data will come from the
80:03 - property num pairs found on the memory
80:05 - game
80:06 - this is the core game logic for playing
80:09 - memory so if you have any questions or
80:10 - confused about anything
80:11 - drop a comment and i'm happy to help as
80:13 - much as possible in the next part we're
80:15 - going to update the text views at the
80:16 - bottom of the screen
80:18 - in order to show how the game is
80:19 - progressing the last part was
80:21 - quite heavy because we were implementing
80:22 - the core game logic fortunately this
80:25 - part
80:25 - is quite a bit easier because all we
80:27 - want to do is update the text views at
80:29 - the bottom of the screen
80:30 - to show the progress in the game let's
80:33 - start with the text view showing the
80:34 - number of pairs found
80:36 - so right here we are capturing the
80:38 - return value of memory game.flipcard and
80:39 - if that returns true
80:41 - the user has successfully found a pair
80:43 - of matching memory cards
80:45 - and so in that case we would like to
80:47 - reference that text view which is tv
80:48 - numpairs
80:49 - and set the text attribute
80:51 - [Music]
80:53 - to show this higher number of pairs
80:56 - found
80:56 - let's say memory game dot num pair is
80:58 - found and this is a value
81:01 - out of the total number of pairs which
81:04 - is
81:04 - board size dot get num pairs
81:08 - [Music]
81:09 - and here also we can do one additional
81:12 - check if
81:13 - the match is found then there's a
81:15 - potential that the user has also
81:16 - won the game and so we're going to check
81:19 - that so if memory game dot
81:21 - have one game and in that case we just
81:23 - want to show a message to the user
81:28 - u1 congratulations
81:35 - one quick correction from before if the
81:37 - user has made an invalid move by tapping
81:38 - on a card which is already faced up i
81:40 - want to make the snack bar length short
81:41 - instead of long
81:43 - the second text view in the bottom is
81:45 - for the number of moves the user has
81:47 - made
81:48 - if the user has gotten past the first
81:49 - two error checks the user has made a
81:51 - valid card flip
81:52 - and so right here we want to update the
81:56 - textview showing how many moves the user
81:57 - has made
82:01 - memorygame.getnum moves
82:03 - this method doesn't exist yet on the
82:05 - memorygame
82:06 - class so android studio can help us to
82:08 - create it and this is going to return an
82:10 - int of how many moves the user has made
82:15 - so the logic here is that as soon as i
82:17 - flip one card over
82:18 - i haven't actually completed my move yet
82:21 - my turn in the game or my move
82:22 - is only over after i've flipped over two
82:24 - cards so the number of moves will be
82:27 - half the number of card flips so we're
82:29 - going to define
82:30 - one more member variable or property on
82:32 - the class
82:33 - called num card flips this property will
82:36 - be private because we don't need to
82:37 - expose
82:38 - this information outside of the member
82:39 - game class and a var because
82:41 - the number of card flips will change as
82:43 - the game is being played we'll set it
82:44 - equal to 0 initially because
82:46 - in a new game there are no cards flipped
82:48 - yet and we'll increment this num card
82:50 - flips variable
82:51 - every time we get into the flipkart
82:52 - method because we know at that point we
82:54 - have a valid
82:54 - card flip now we simply use this value
82:56 - to compute the number of moves
82:59 - and we'll just do num card flip divided
83:01 - by two and notice here that we are going
83:03 - to be doing integer truncation so if the
83:05 - number of card flips is five
83:06 - when we divide by two the result of that
83:08 - will be two because we're rounding down
83:11 - and that makes sense because when i've
83:12 - made five card flips i'm in the middle
83:14 - of my third move i haven't yet completed
83:16 - it and so we still want to show
83:18 - number of moves being two let's try it
83:22 - so now as we play our game we should see
83:25 - both of these numbers go up
83:29 - okay so i made two card flips and then
83:31 - this makes sense now i
83:32 - made one move
83:35 - okay so now i made two moves because i
83:37 - flipped over four cards total
83:39 - and i got lucky with this last one and i
83:41 - found a pair so you can see how this
83:43 - also got incremented
83:44 - let's keep going
83:51 - awesome so now we see the snack bar u1
83:54 - and the total number of moves is
83:55 - reflected properly
83:57 - along with the number of pairs the last
83:59 - thing we want to do
84:00 - in this segment is i would like to
84:01 - actually add in color interpolation
84:05 - on the number of pairs and this is a
84:06 - nice visual way for the user to know
84:09 - using a color their progress in the game
84:12 - so every time we increment the number of
84:15 - pairs
84:15 - we want to also update the color of the
84:19 - text view we'll say tv numpairs dot set
84:22 - text
84:22 - color we're going to pass in a color
84:24 - here and this color is going to be the
84:26 - result of
84:27 - interpolation so interpolation is a
84:29 - fancy statistical term
84:31 - but it's actually quite simple if i tell
84:33 - you that i'm walking a thousand steps
84:35 - and i'm 75 done then you would probably
84:38 - tell me
84:39 - i should roughly have taken 750 steps
84:41 - and what you're doing in your head is
84:42 - linear interpolation
84:44 - at the starting point i've done zero
84:45 - steps at the ending point i've done a
84:47 - thousand steps
84:48 - and so when i say i've done 75 progress
84:51 - you are estimating that
84:52 - i should be roughly 750 steps into that
84:55 - journey
84:56 - we're doing something identical here
84:57 - we're going to use a built-in class in
84:59 - android called argb evaluator
85:01 - which will take in the worst color
85:03 - meaning no progress has been made
85:05 - zero pairs have been found and another
85:07 - color representing full progress
85:08 - has been made which means the user has
85:10 - won the game and all the pairs have been
85:12 - found
85:13 - and all we need to do then is provide
85:15 - progress of how many pairs have been
85:16 - found so far in the game
85:18 - and based on that we will do
85:19 - interpolation between the worst color
85:21 - and best color
85:22 - and this is possible because like we
85:24 - talked about earlier colors are simply
85:26 - integer values behind the scenes so
85:28 - here's how we can compute the fraction
85:30 - of what
85:31 - progress has been made so far the number
85:33 - of pairs
85:34 - found divided by the total number of
85:35 - pairs and the issue here is that it
85:37 - expects a float rather than int
85:39 - so we're going to cast the numerator as
85:41 - a float
85:43 - the second and third parameter are the
85:44 - start and end value representing
85:46 - no progress made and complete progress
85:49 - made
85:50 - and so we're going to use context compat
85:52 - to get the color and then we're going to
85:53 - actually define
85:54 - the colored resource in our colors.xml
85:56 - file
85:57 - i'll call the color resources color
85:59 - progress none and color progress full
86:02 - so now we will create the color value
86:04 - resource and what i
86:06 - put in here is this red color because
86:08 - red kind of indicates to me that you've
86:10 - made no progress
86:11 - you're stopped so that's the burst value
86:14 - and then for color progress full
86:19 - i am using this green value which means
86:21 - that you've made it
86:23 - green means go so you've you've made a
86:25 - lot of progress and you've won the game
86:27 - awesome and then the set text color
86:29 - requires an integer
86:30 - and so we're going to now cast the value
86:32 - of this argb evaluator as an int
86:37 - let's try it as i make progress
86:40 - in this eight memory card game there are
86:43 - four pairs
86:44 - each time i should be 25 percent closer
86:47 - to hitting that green value
86:51 - so after one pair you can see the color
86:52 - changing a little bit
86:57 - and now you can see the full green color
87:00 - at the very end when i've won the game
87:02 - one thing you'll notice is that at the
87:04 - very beginning of the game we should
87:06 - see the color of that text view be red
87:08 - to indicate no progress but right now
87:10 - it's that default black color so let's
87:11 - fix that inside of the oncreate method
87:14 - after we've defined
87:15 - tv numpairs let's set the text color of
87:18 - that text view
87:19 - to initially be the color representing
87:22 - no progress color progress none which is
87:23 - a red color
87:24 - and if we try it we can see that the
87:26 - text view color is indeed red
87:28 - at this point we're able to play a fully
87:30 - functional memory game
87:31 - along with having information at the
87:32 - bottom showing how the game is going
87:35 - the goal for the next segment is to give
87:37 - the user some control
87:38 - to restart the game and also allow the
87:41 - user to control
87:42 - what size memory board they're playing
87:44 - with easy medium or hard
87:46 - the goal for this segment is to allow
87:48 - the user to restart the game that
87:49 - they're currently playing
87:51 - or to pick a new board size and try a
87:54 - different game
87:55 - so let's start out by adding a menu
87:57 - option for restarting the current game
87:59 - so let's go into project and go into
88:02 - resources
88:02 - and we're going to create a new resource
88:04 - directory
88:07 - android resource directory which is of
88:08 - type menu
88:11 - inside of this directory we'll create a
88:13 - menu resource file called
88:14 - menu main
88:19 - and let's start out with just one menu
88:21 - item we'll give this menu option a title
88:23 - of refresh
88:24 - but we'd actually like for this action
88:26 - to have an icon associated with it so
88:27 - we'll create a new vector asset
88:29 - called refresh give it a name of ic
88:32 - refresh
88:33 - and then tap on finish and we're going
88:35 - to set the icon
88:37 - attribute of this menu option to be this
88:39 - newly created icon
88:40 - we'd like for this menu option to show
88:42 - up as an action rather than being buried
88:44 - by default inside of the overflow menu
88:46 - which is what we're seeing here
88:48 - so i'm going to hit the show as action
88:50 - attribute and hit always
88:51 - which indicates the android system that
88:53 - we want this to be an icon
88:55 - rather than text in the three dot menu
88:59 - now we have to actually inflate this
89:01 - menu resource file that we just created
89:03 - in main activity so there's a method we
89:06 - will override
89:07 - called oncreate options menu so if you
89:10 - just start typing
89:12 - on create options then you should find
89:13 - it and we are going to
89:15 - get the menu inflator and inflate
89:19 - the r dot menu menu main
89:22 - and the second parameter here is the
89:24 - menu which is
89:25 - the parameter and then we'll return true
89:28 - because this method on create options
89:30 - menu requires a boolean return value
89:33 - now we want to get notified when the
89:35 - user has tapped on
89:36 - that particular menu item so first going
89:39 - back into menu main
89:41 - we want to add an id i'll call this
89:44 - mi refresh which stands for menu item
89:47 - refresh
89:48 - copy that and then the way we get
89:51 - notified of
89:52 - the user tapping on an option menu is
89:55 - through this method
89:56 - on options item selected
90:00 - so here we'll use the when construct so
90:04 - say when
90:05 - dot item id so based on the item id
90:08 - of this menu item we'll take a different
90:09 - action so the only one we have right now
90:12 - is r.id.mi refresh
90:15 - and in this scenario we want to
90:20 - set up the game again
90:22 - [Music]
90:24 - so setting up the game again basically
90:25 - entails
90:27 - doing all this logic again where we
90:30 - create a new memory game
90:31 - we set up a new adapter and then we set
90:33 - up the recyclerview
90:35 - with this new data let's push all of
90:37 - this logic into a separate function
90:39 - which we can then
90:40 - easily reuse so i'll call this setup
90:42 - board and paste in that logic in the
90:44 - newly created function
90:45 - and then my preference is usually to put
90:46 - all of these private functions
90:49 - below all of the functions that we're
90:51 - overriding i'm going to put this down
90:53 - here
90:56 - all right awesome so now let's just
90:58 - simply call
90:59 - setup board right here let's try it
91:02 - so hopefully now we should see a menu
91:04 - option up here where we can refresh
91:06 - so just click a few of these
91:09 - and then if i hit this option now i
91:12 - should be able to refresh the whole game
91:15 - yep and you can see that now we have
91:16 - different cards show up
91:18 - awesome one thing that is worth doing
91:20 - though is that if i'm in the middle of a
91:22 - game like this i've already made
91:23 - three moves and i already have found one
91:25 - pair i'd like to warn the user
91:27 - that they're about to lose their
91:29 - progress on the game
91:31 - and so right here if the
91:34 - number of moves in the memory game get
91:36 - num moves
91:38 - if that's more than zero and the user
91:41 - hasn't won the game yet
91:46 - then we should be showing a alert dialog
91:48 - to the user
91:49 - informing them that this is a dangerous
91:51 - operation because they might
91:52 - be very close to winning but they
91:55 - accidentally hit the refresh button for
91:56 - example so i'm going to delegate that
91:58 - work of showing the alert dialog to a
92:00 - method because we're actually going to
92:01 - show
92:02 - several alert dialogs depending on which
92:04 - menu option the user taps on so i'll say
92:06 - show
92:07 - alert dialog
92:11 - and then create a function for this
92:13 - we're going to leverage the alert dialog
92:15 - builder in order to create
92:16 - and show the dialog it takes in a
92:17 - context we'll pass in a title which will
92:20 - be passed as a parameter
92:21 - same thing with the view and then we'll
92:23 - get to the negative and
92:25 - positive button click listener a bit but
92:26 - first let's go back and add the title
92:28 - and view
92:29 - as parameters now we'll set the negative
92:31 - button
92:32 - text to be cancel and by passing null
92:34 - here we're basically saying just dismiss
92:36 - this alert dialog
92:37 - if the user taps on cancel we're also
92:39 - going to add in a
92:40 - positive button which will be okay and
92:43 - here we need to actually take action
92:45 - based on the user tapping on the ok
92:48 - button
92:48 - if we go into the declaration of set
92:50 - positive button the second parameter is
92:52 - onclicklistener which is an interface
92:53 - which has one method
92:55 - and that one method has two parameters
92:57 - but neither of these
92:58 - is actually relevant to what we need to
93:00 - do here so in order to indicate that
93:01 - we're still adhering to that
93:03 - signature we're going to put in
93:04 - underscores to say that that's the
93:06 - method we're
93:06 - writing and this is where we now need to
93:09 - take the action
93:10 - based on what happens when the user taps
93:13 - on ok
93:14 - and that has to be something that's
93:15 - passed in as a parameter to show alert
93:17 - dialog
93:18 - so i'm going to add a third parameter
93:19 - here called positive button click
93:21 - listener
93:22 - and that will be of type
93:23 - view.onclicklistener
93:25 - now we can call the on click method of
93:27 - the positive click listener which takes
93:28 - in
93:28 - a parameter of u which we don't care
93:30 - about so we'll pass in null here
93:32 - so now let's look at how we can use this
93:34 - in the show our dialogue method we'll
93:35 - pass
93:36 - in the title which will be quit your
93:37 - current game we don't need to show any
93:38 - additional information so the view of
93:40 - the alert dialog can be null
93:42 - and then we're going to pass in the
93:44 - positive button click listener
93:45 - which is what should happen when the
93:47 - user confirms this alert dialog and
93:48 - we're just going to call setup board
93:50 - and in the else condition the user is
93:51 - not in the middle of a game so we can
93:52 - just unconditionally call
93:53 - setup board
93:58 - so if i make some moves like this and
94:00 - now i refresh
94:02 - you can see that before setting up the
94:05 - game again we had this dialog which has
94:06 - the title that we specified along with
94:08 - two buttons
94:09 - cancel or okay so if i cancel all we're
94:11 - doing is exiting the alert dialog but we
94:13 - haven't actually taken
94:13 - action which is what we want on the
94:15 - other hand if i tap ok
94:16 - now we are properly resetting the board
94:19 - which is exactly what we want
94:21 - one other issue that you'll notice is
94:22 - that we aren't resetting the
94:25 - value of these text views properly when
94:27 - we call
94:28 - setup board so let's fix that so go into
94:31 - the setup board method
94:33 - so depending on the board size we would
94:35 - like to
94:36 - reset the value of those text
94:39 - text views at the bottom so board size
94:43 - is an enum and so now because it's an
94:44 - enum we know
94:46 - what are the possible values of this so
94:48 - we'll have android studio help us to add
94:50 - the remaining else branches
94:51 - in the easy case we'll first set the tv
94:54 - num move text view and we'll set that to
94:55 - be equal to the current game being
94:57 - played which will be easy
94:58 - and that's a four by two grid and the
95:00 - number of pairs is going to start at
95:01 - zero and there are four pairs total in
95:04 - the medium case
95:05 - we'll describe that the board is six by
95:07 - three and the number of pairs total will
95:09 - be nine
95:10 - and then finally in the hard case the
95:12 - board dimensions will be 6x4
95:14 - and the number of pairs is 12. because
95:16 - there are 24 cards
95:21 - so i'm making some moves and so now if i
95:25 - reset you can see the number of pairs
95:27 - has gone back to zero
95:28 - and i also reset this back to a
95:31 - description of what game we're playing
95:34 - awesome the next thing we want to do is
95:35 - add one more menu option which will
95:37 - allow us to
95:38 - change the size so right now the only
95:39 - game we can play is easy but i'd like to
95:42 - have one more menu option which allows
95:43 - us to
95:44 - select easy medium or hard so for that
95:47 - let's add one more menu option in menu
95:50 - main
95:54 - and this one i wanted to actually show
95:57 - up in the
95:58 - overflow menu so i'm going to say show
96:00 - as action never
96:04 - and the id of this will be mi
96:07 - new size title will be
96:11 - choosing size all right so going back
96:14 - into main activity
96:16 - in order to handle that menu item being
96:18 - clicked in the on options item selected
96:20 - in the when
96:21 - expression we'll add the id and we'll
96:23 - create a function called show new size
96:24 - dialog
96:25 - one thing i'll also do is add return
96:26 - true every time that we're handling the
96:28 - menu item collect both for
96:30 - the refresh and this one so in this new
96:32 - function shown in size dialog we're
96:34 - going to
96:34 - call that function show alert dialog
96:36 - that we just created and the title will
96:38 - be
96:38 - choose new size we're going to pass in a
96:40 - view i'll
96:41 - pass in null for now but that should be
96:44 - a list of all the different options of
96:45 - board sizes and then when the user taps
96:48 - on ok
96:49 - we should change the value of the board
96:51 - size variable in the main activity
96:53 - all right so the objective here is that
96:56 - we want to
96:56 - create a new view which allows the user
96:58 - to pick between
97:00 - the various board sizes and the way
97:02 - we're going to do this is have
97:03 - a radio group and the radio group will
97:06 - have three radio buttons
97:07 - easy medium hard and that's how the user
97:09 - can specify which
97:10 - game they want to play and so we're
97:13 - going to
97:14 - inflate that view similar to what we did
97:17 - in the adapter
97:18 - the contacts which is this and we want
97:21 - to inflate
97:23 - r.layout.dialog board size
97:28 - and pass in null for the second
97:29 - parameter and this is going to return to
97:31 - us
97:32 - a board size view
97:35 - so now we have to define dialog board
97:37 - size
97:38 - so hit that red light bulb and let's
97:40 - create a layout resource
97:42 - file and then constraint layout is
97:45 - fine for the new element let's go into
97:47 - the design tab
97:48 - i'd like to i'd like to drag out a radio
97:51 - button group
97:54 - let's give the radio group an id a radio
97:56 - group and let's also add
97:58 - some horizontal constraints on the left
97:59 - side it'll be 0dp
98:01 - from the parent and also on the right
98:02 - side that means we can make the layout
98:04 - with
98:04 - 0tv or match constraint now let's drag
98:08 - out
98:08 - 1 2 3 radio buttons let's give the first
98:11 - radio button an id of rbez
98:14 - and then give it a updated text of easy
98:17 - 4x2 to describe the game
98:18 - the second radio button can be rb medium
98:22 - and the text will be medium which is 6x3
98:25 - and then the third data button will be
98:27 - rb hard
98:30 - and that will have a text of hard six by
98:32 - four
98:33 - in the component tree you can see that
98:34 - red exclamation mark which indicates
98:36 - error and it says that there's a missing
98:38 - constraint on the radio group
98:40 - so if i go into the radio group we can
98:42 - see that it's actually not vertically
98:43 - constrained so i'll
98:44 - add a 0dp top margin from the radio
98:47 - group to the parent
98:48 - and that should resolve that issue one
98:50 - other thing i'll do is
98:52 - add a left and right margin of 16dp and
98:54 - 8db margin on the top
98:56 - just so we can create some space between
98:58 - the radio group and the parent
99:00 - alert dialog okay so now we have the
99:05 - dialog board size so this view is fine
99:08 - so now we want to figure out if the user
99:11 - taps on the ok button then the code here
99:13 - will get executed
99:15 - the value of the board size that we set
99:17 - in here will depend on which radio group
99:20 - button was selected and so we need to
99:22 - first
99:23 - define that radio group we need to pull
99:25 - it out of the board size view so i'll do
99:26 - that now
99:27 - and the radio group will mandate that
99:29 - only one of the buttons inside of it can
99:30 - be selected at a given time
99:32 - so depending on which of those was
99:33 - selected which is a checked radio button
99:35 - id
99:36 - we will set the board size accordingly
99:39 - [Music]
99:43 - so we want to add in three ids here rb
99:45 - easy
99:46 - and in that case the board size should
99:48 - be easy
99:50 - if the id selected was medium
99:53 - then the board size should be medium and
99:55 - otherwise
99:57 - the board size should be hard
100:01 - one more thing before we try this out is
100:04 - when we open up the dialog i want the
100:08 - current size board to be the one which
100:10 - is automatically selected
100:12 - in the in the dialog so depending on the
100:14 - board size
100:17 - [Music]
100:21 - we want to tell the radio group which
100:24 - items should be checked so in the case
100:26 - of easy then we want to check the rbez
100:29 - [Music]
100:35 - and once we have specified a new board
100:37 - size then we simply call
100:39 - setup board and that should take care of
100:42 - redrawing our whole board before running
100:44 - this we need to actually pass in the
100:46 - board size view which we constructed on
100:48 - 77
100:49 - and pass it into the show alert dialog
100:51 - method let's run it and see what happens
100:53 - now we are able to see this radio button
100:55 - group and we have the easy radio button
100:57 - selected
100:58 - because we were playing a 4x2 grid let's
101:01 - select medium and see
101:02 - how the recycler view gets updated to
101:04 - properly show the
101:06 - 18 cards and let's also try out the
101:09 - hard version so if we go to the dialog
101:11 - again we see the medium is pretty
101:12 - selected
101:13 - and hard shows us the 6x4 grid and you
101:16 - can also see at the bottom
101:18 - the game info is also correct the last
101:21 - thing i want to do in this part is to
101:22 - update the color of the refresh icon
101:24 - because it's a little bit hard to see
101:25 - right now
101:26 - so this icon is what we just created
101:29 - it's called ic
101:30 - refresh and the color of it is dictated
101:33 - by this
101:34 - attribute here called android tint so
101:36 - i'm going to replace that and just
101:37 - use fff which is white in running the
101:40 - app again we do see that the
101:42 - menu icon is now white now we are fully
101:45 - done
101:45 - building out the memory game played with
101:48 - the default icons
101:49 - in the next part we'll allow users to
101:51 - create their own custom memory games
101:54 - by taking photos from their phone and
101:55 - using that as the
101:57 - back of each memory card instead of
101:58 - these icons in this segment we're going
102:00 - to embark on the creation flow
102:02 - where the user can create their own
102:04 - personalized memory game using photos
102:07 - from their phone the idea is that each
102:09 - memory card instead of having one of the
102:11 - default icons that we
102:12 - have put into the app we're going to
102:14 - have each memory card be
102:16 - a photo that the user has picked up so
102:19 - to start out with we're going to
102:20 - just add one more menu option here which
102:22 - will launch the creation flow
102:24 - so i'm going to go into menu main let's
102:26 - drag out one more menu item
102:28 - and then the title here will be create
102:31 - custom game
102:34 - let's give this an id of mi custom which
102:37 - stands for menu item custom
102:39 - [Music]
102:41 - and then show us action will be never we
102:42 - always want this to
102:44 - be underneath the three dots of the menu
102:48 - so now that we have that let's go into
102:49 - main activity
102:51 - and
102:55 - here is where we can register some
102:58 - action to happen when the user taps on
102:59 - that menu item
103:00 - i'll say r dot id dot mi custom
103:06 - [Music]
103:09 - and then we'll put this into a new
103:11 - function called
103:12 - show creation dialog
103:21 - let's define this create function and
103:24 - this creation dialog wall should be
103:26 - quite similar to show new size dialog
103:29 - because the very first thing we want
103:30 - before we navigate the user to the
103:32 - creation flow is we need to understand
103:34 - what size of a memory game do they want
103:37 - to create and so we're going to reuse
103:38 - the exact same
103:39 - dialog board size here and inflate that
103:41 - and that will be what we show in a
103:42 - dialog
103:43 - before we allow the user to go into the
103:45 - creation flow
103:46 - so i'm going to go ahead and just copy
103:48 - all of this
103:50 - and now we are going to
103:53 - show the alert dialogue so i'm going to
103:54 - copy this now although we're going to
103:56 - modify
103:57 - this a little bit so the title of this
103:59 - other dialogue shouldn't be choose new
104:00 - size
104:01 - it should be create your own memory
104:04 - board
104:07 - then the view will be the three
104:09 - different options of memory games
104:11 - and here we would like to figure out
104:14 - which board size has been picked once
104:17 - they tap on the ok
104:18 - button and so for that that'll be a
104:20 - local variable called
104:21 - val desired board size
104:24 - board
104:28 - and we're not going to set up anything
104:29 - here we just we want to navigate the
104:30 - user
104:31 - to a new screen or a new activity where
104:34 - they can actually start
104:35 - choosing which photos they like one
104:37 - thing i like to do before going forward
104:39 - is open up the dialog board size
104:41 - and have a default radio button selected
104:43 - so we're going to choose the
104:45 - easy radio button and what that means is
104:47 - by default when the user is creating a
104:49 - new
104:49 - memory board they're going to be
104:50 - creating an easy board but they have the
104:52 - option
104:52 - to pick medium or hard if they want now
104:55 - our objective is to create a new screen
104:56 - or new activity
104:58 - when the user has tapped on the ok
105:00 - button of this alert dialog
105:02 - so open up the same directory where my
105:03 - activity is located right click on it
105:05 - and go to new
105:06 - activity and we're going to choose empty
105:08 - activity
105:09 - and call this create activity because
105:12 - this will be
105:12 - the screen for creating a new board and
105:15 - then we'll just tap finish
105:18 - so the way we navigate between
105:20 - activities or screens in android is
105:22 - through something called the intent
105:23 - system so intents are fundamental to
105:24 - android
105:25 - they're basically requests to the
105:27 - android system or to another application
105:30 - to do some certain action so the intent
105:32 - that we're doing here
105:33 - is an intent to go from the main
105:35 - activity and launch the create activity
105:38 - so i'll say val intent is equal to
105:42 - intent
105:44 - and there are two parameters in the
105:46 - intent constructor the first is the
105:47 - context which is we're going to pass in
105:49 - this which is referring to the
105:50 - where we're coming from and the second
105:52 - parameter is the class that we want to
105:53 - navigate to
105:55 - and that will be the create activity dot
105:58 - java
106:01 - and now in order to actually navigate to
106:03 - the create activity we need to
106:05 - call this method start activity and
106:07 - there are two versions of the start
106:08 - activity method one is start activity
106:10 - and the other is start activity for
106:11 - result
106:12 - the start activity for result is
106:14 - necessary if you want to get some data
106:16 - back
106:17 - from the activity that you've launched
106:19 - so in our case we're going to be
106:20 - launching the creativity
106:22 - the user will be creating a brand new
106:23 - board there and then whenever that's
106:25 - done
106:26 - we actually want to get that data back
106:27 - in the main activity and allow the user
106:29 - to play that custom game that they just
106:30 - created
106:31 - and so we do want star activity for
106:33 - results because we want to get that
106:34 - signal back from our child activity
106:37 - about
106:38 - what is a newly created game so
106:41 - i'll say start activity for result and
106:43 - pass in the intent that we just created
106:45 - and because we're doing selectivity for
106:47 - result we also need to pass in a second
106:49 - parameter which is the request code
106:51 - i'm going to define that as a constant
106:52 - called create request code
106:55 - and we're going to have that be defined
106:57 - inside of the companion object
106:59 - of main activity say private const val
107:02 - create request code and i'll set this
107:04 - equal to 248.
107:06 - it doesn't actually matter what this is
107:07 - as long as it's some unique integer
107:09 - within your activity 248 is near and
107:11 - dear to my heart because that's the area
107:13 - code of where i grew up
107:14 - in michigan let's test this out by
107:18 - running the app and what we expect is
107:20 - when i tap on the menu option to create
107:22 - a new
107:22 - board and i confirm the alert dialog by
107:26 - picking a size
107:27 - then i should be navigated to a new
107:29 - screen
107:30 - which should be empty that should be the
107:32 - create activity
107:33 - and we can see that it's an empty
107:35 - activity and our goal now is to actually
107:36 - fill out the ui
107:38 - to allow the user to create this custom
107:39 - board one piece of information that we
107:41 - need in order to properly show the
107:43 - create flow
107:44 - is what size board does the user want to
107:46 - create what size game did they choose
107:48 - and that's actually the data that we
107:49 - collected
107:50 - via the radio buttons but we're not
107:51 - doing anything with that data and so
107:54 - android has a system with intents to
107:56 - pass additional data along with
107:58 - the request to do an action so here
108:00 - we're making the request to
108:02 - start the create activity inside of that
108:04 - intent we're going to put in
108:06 - an extra and that will be the desired
108:08 - board size
108:09 - so the extra has a key and value the key
108:13 - is always a string
108:14 - and the value is the the variable that
108:17 - we want to pass between these activities
108:19 - so the key i'm going to define as a
108:21 - constant extra
108:23 - board size and the value is going to be
108:26 - desired board size
108:28 - so we have to define extra board size
108:30 - i'm going to put this inside of
108:32 - the constants.kt file that we have from
108:34 - earlier
108:34 - [Music]
108:38 - and this has to be a string so i'm just
108:40 - going to have the string value be extra
108:42 - board size
108:44 - let's import this and the reason i'm
108:47 - defining extra board size into a
108:48 - separate file as opposed to within main
108:50 - activity itself
108:51 - is because we're actually going to be
108:52 - referencing extra board size and create
108:54 - activity and so for anything which is
108:56 - shared
108:56 - a shared constant between multiple files
108:58 - i'm going to put that into
109:00 - constants.kt rather than defining it
109:02 - into a single file
109:03 - now we've added this let's go into
109:05 - createactivity and let's pull that data
109:07 - out
109:07 - from the intent but the way this works
109:09 - is we
109:10 - will get the intent and get
109:14 - the serializable extra extra board size
109:17 - and we're going to cast this as board
109:20 - size right
109:21 - and we're going to save that into a
109:22 - variable called board size
109:26 - and actually i want this to be a member
109:28 - variable so we can reference it
109:29 - reference it across multiple methods say
109:32 - private late init var board size and now
109:36 - we don't need to declare it in the
109:37 - uncreate function
109:38 - one more thing i want to do is based on
109:40 - the board size i want to modify the
109:42 - title
109:43 - of the create activity to indicate how
109:44 - many pictures
109:46 - does the user have to select from their
109:48 - phone in order to make
109:49 - a valid game so the number of pictures
109:53 - the user has to select will be half of
109:55 - the number of cards
109:56 - in that game of memory so for example if
109:57 - i have a hard game that i picked which
109:59 - is 24 cards
110:00 - i need to pick 12 unique images from my
110:02 - phone
110:03 - and so that's what i want to communicate
110:05 - in the title of this
110:06 - action bar so in order to change the
110:09 - text we can say support action bar
110:11 - dot title and then this is going to
110:13 - complain because support action bar
110:15 - technically is nullable
110:16 - and so we can use a question mark
110:18 - operator which says
110:19 - only call this attribute if support
110:22 - action bar is not null
110:24 - and if that's the case then we want to
110:25 - set this equal to
110:27 - some string and we're going to set this
110:29 - equal to choose picks
110:32 - 0 out of 12 for example so if we pick
110:35 - the hardboard it would be 12 here if you
110:36 - pick medium it would be
110:38 - 9 and so on of course we can't hard code
110:40 - in 12 here so i'm going to define
110:42 - another variable
110:43 - which is num images required
110:46 - so this will be a private bar num
110:50 - images required and initially this is
110:53 - going to be negative one
110:55 - but as soon as we get the intent extra
110:58 - now we can set this equal to
111:03 - boardsize.getnumpairs and so now instead
111:05 - of hard coding in 12 here
111:06 - i'm going to pass in numbers required
111:10 - and one more thing i want to do before
111:11 - we test this out is on the support
111:12 - action bar
111:13 - there's an ability to instead of having
111:17 - the default appearance we can have a
111:19 - back button which allows the user to
111:20 - easily exit out of this flow and go back
111:22 - to the main activity if they want
111:23 - the way we can do this is say support
111:25 - action bar
111:26 - dot set display home as up enabled
111:30 - and pass in true here that'll modify the
111:32 - action bar to show a back button
111:35 - and then we need to actually take some
111:36 - action when the user has tapped on that
111:38 - back button this is similar to what we
111:41 - have done before so i'm going to
111:42 - override this method on options
111:44 - item selected i'll say if the item id
111:50 - is equal to android.r.id.home
111:57 - then we'll just say finish which means i
111:59 - want to finish this activity
112:00 - and go back to the main activity return
112:02 - through here
112:04 - and the reason this is android.id.home
112:06 - is because this id
112:07 - is defined within the android system the
112:09 - android sdk this is not a menu item that
112:11 - we added
112:12 - so that's why it has the android prefix
112:14 - here let's try it
112:18 - to go into the creation flow let's pick
112:21 - easy
112:22 - and so now you can see that we have um
112:24 - the back button and it says choose pix04
112:26 - which makes sense because they're going
112:28 - to be eight images in the easy
112:29 - version of the game so that means we
112:30 - have to pick four different pictures
112:33 - if i tap on back then we go back to the
112:35 - main activity
112:36 - the last thing i want to do in this
112:38 - segment is do some quick adjustments
112:40 - into the ui
112:41 - in the activitycreate.xml so right now
112:44 - it's just a blank screen
112:45 - let's give us give ourselves a bit more
112:47 - space i'm going to minimize this and
112:48 - also let's delete some of the
112:50 - extra files that we don't care about
112:52 - right now
112:56 - so by default we have this constraint
112:58 - layout which is a new element and that's
112:59 - fine
113:00 - what i want to do is i want to drag out
113:01 - a button and this will be anchored to
113:03 - the bottom of the screen
113:05 - and this is going to be how the user can
113:07 - save their newly created game
113:09 - so i'm going to consider it to the
113:10 - bottom and also to the right and left
113:13 - and i want this to take up the whole
113:15 - screen width because it's a primary
113:17 - action
113:18 - this is what the user really is
113:19 - intending to do when they come to this
113:21 - screen width will be match constraint so
113:24 - it takes out the whole width and then
113:26 - i'm going to have
113:27 - a 16 dp margin on the left and right let
113:29 - me zoom in and show you a little bit
113:31 - closer and then also on the bottom
113:35 - let's add an 8 dp margin from the bottom
113:37 - of the screen let's change the
113:38 - the id to be btn safe
113:44 - and then let's also give this text
113:47 - of safe one thing that we'll want to do
113:51 - is by default the user shouldn't be
113:52 - allowed to tap on this button because
113:54 - they haven't actually provided the
113:56 - correct data in order to create this
113:58 - game right like it doesn't make sense to
114:00 - save the game without having chosen some
114:03 - images which we'll do in the later on
114:05 - and so to start out with search for this
114:07 - attribute called enabled
114:09 - and we're going to set this to be false
114:13 - so that grays out that button it looks
114:15 - good
114:17 - and then one more widget i want to drag
114:20 - out
114:20 - is an edit text
114:23 - and this edit text represents the name
114:26 - of this custom game that the user is
114:28 - creating
114:28 - so i want this to also be full width so
114:31 - drag this to the left and right
114:33 - and have it also be 16 dp on the left
114:36 - and right side of the screen
114:38 - and then i want it to be constrained to
114:40 - the top of the save button
114:41 - let's give it a margin of 8 dp from the
114:44 - bottom
114:45 - and the width can be matched constraints
114:48 - it takes out the whole
114:50 - screen with let's change the input type
114:52 - to just be
114:53 - text we don't want this to be a person
114:55 - name we just want it to be regular text
114:58 - and by default there should be no text
115:00 - here that's for the user to fill out
115:02 - but we do want to give the user a hint
115:04 - of what should be
115:05 - what what they should write in this edit
115:07 - text so in the hint
115:08 - attribute i'm going to write game name
115:12 - example
115:16 - panda fun
115:19 - and just a few more things before we
115:21 - wrap up first off
115:22 - i would like to set an attribute called
115:24 - digits on this edit text
115:26 - so search for digits
115:30 - and what digits represents is what is
115:31 - the valid allowable input
115:33 - in this edit text this game name that
115:35 - the user writes
115:37 - is going to be living in our database
115:39 - that we'll get to later
115:40 - and so we want to be we want to
115:41 - constrain what the user is allowed to
115:43 - actually put in here
115:45 - you can kind of copy what i did i'm
115:47 - allowing the user to enter in
115:49 - any of the digits one through zero
115:51 - through nine
115:52 - or a b c d all the lower case
115:56 - letters or underscore or dash
115:59 - that's it so there's no slashes allowed
116:01 - no question mark no period things like
116:03 - that
116:03 - and the reason for this is because i
116:04 - want it to be easy for people to be able
116:06 - to
116:07 - share the game name so for example panda
116:09 - underscore fun is a valid game name and
116:11 - that's also easy for me to
116:12 - communicate out to someone else as soon
116:14 - as we start introducing uppercase
116:15 - lowercase letters
116:16 - or slashes or things like that that will
116:19 - make it harder to communicate
116:20 - the game name to other people and also
116:22 - it actually might cause some issues
116:23 - in our database so it's better to
116:25 - constrain the user input here
116:28 - a couple other things i played around
116:30 - with this a little bit i want to set the
116:31 - ime options
116:33 - to be done action done and what that
116:36 - will do is they'll
116:37 - change the keyboard to have a check mark
116:39 - at the bottom right to indicate to the
116:41 - user that
116:41 - they've finished filling out this field
116:44 - and
116:45 - we can also change the id here to be et
116:47 - game name
116:49 - so it stands for edit text game name and
116:52 - if you go into the code tab
116:53 - there's one more change i want to make
116:55 - which is called important for autofill
116:57 - i'm going to set this to
116:59 - no and what this means is that we don't
117:02 - want the
117:02 - android system to be over eager and auto
117:05 - fill this field
117:06 - and finally specify the maximum number
117:08 - of lines allowed in this edit text which
117:11 - will be
117:11 - one that basically means that there are
117:13 - no line breaks allowed in this edit text
117:15 - which
117:16 - kind of makes sense we want the game
117:17 - name to be short concise and fit onto a
117:19 - single line
117:20 - let's try it so now when we navigate
117:24 - into the creation activity then we
117:26 - expect
117:27 - to see this ui at the bottom of the
117:29 - screen
117:30 - awesome so you can see the button is
117:31 - disabled and we have this
117:33 - edit text which has the hint that we
117:36 - specified and
117:37 - i can type in abcd and the letters like
117:40 - that
117:40 - but if i try typing in a question mark
117:43 - you'll see that it doesn't actually show
117:44 - up same thing with capital letters or
117:46 - slash and so on so that looks like it's
117:48 - working
117:50 - awesome so we have the shell of the ui
117:52 - for our create activity
117:54 - in the next segment we're going to start
117:56 - flushing this out a little bit more
117:58 - by allowing the user some ui where they
118:01 - which they can tap
118:02 - and select photos from their phone the
118:04 - goal for this segment
118:05 - is to continue to flesh out the ui for
118:08 - the create activity
118:09 - and in particular we want to show a grid
118:11 - of gray
118:12 - boxes which will be a indication of the
118:14 - user to tap on those in order to pick an
118:16 - image from their phone
118:18 - and the way we'll do this is actually
118:19 - quite similar to what we've already done
118:21 - with the main activity
118:23 - we're going to have a recyclerview which
118:25 - has a grid
118:26 - layout manager and that'll be how we
118:27 - construct this grid of
118:29 - images or grid of gray boxes for now the
118:32 - first thing i want to do is
118:34 - in the activity create in the design tab
118:36 - let's drag out a recyclerview
118:40 - let me zoom out a little bit so i want
118:43 - this recyclerview to be constrained to
118:47 - the
118:47 - right end of the parent and left end of
118:49 - the parent
118:51 - that's how we get zero and zero over
118:52 - here also concerning to the top of the
118:54 - parent
118:55 - and the bottom should be actually
118:57 - constrained
118:58 - to the top of this edit text and in
119:01 - order
119:02 - to have this to actually take an effect
119:04 - we have to change the layout width and
119:05 - height to be
119:07 - match constraint
119:10 - awesome so you can see how the recycle
119:11 - view now is taking up whatever is
119:13 - remaining
119:13 - after subtracting out these bottom
119:15 - components
119:17 - let's give this an id of rv image picker
119:24 - now in the create activity the first
119:26 - thing i want to do is get a reference to
119:28 - the three views on the screen the
119:29 - recycler view
119:30 - the edit text and the button so all
119:32 - these will be late in it var because
119:34 - we're going to declare them
119:35 - as member variables but actually set the
119:37 - value in oncreate
119:39 - so we'll just say rv image picker find
119:41 - viva id with the corresponding id
119:42 - and similarly for the edit text and save
119:44 - button similar to the main activity the
119:46 - recyclerview will have two core
119:47 - components the adapter and
119:49 - the layout manager the layout manager is
119:51 - easier so
119:52 - that'll be equal to the grid layout
119:54 - manager will pass in the context which
119:55 - is this
119:56 - and the second parameter is the number
119:58 - of columns that'll be the get with
120:00 - method on the board size one thing we
120:03 - can also do here is similar to the main
120:05 - activity
120:05 - i'm going to call this method set has
120:07 - fixed with
120:09 - set this equal to true because we are
120:11 - guaranteeing that the recyclerview
120:13 - dimensions won't change because we've
120:15 - allocated just enough space for it
120:18 - and now we want to set the adapter so
120:19 - i'm going to say
120:21 - rv image picker dot adapter and we're
120:24 - going to set this equal to an image
120:25 - picker adapter
120:26 - and this is the class that we're going
120:27 - to define
120:31 - this will take in three parameters first
120:33 - is the context
120:34 - and then we are going to pass in a list
120:37 - of the images that the user has chosen
120:41 - and so i want to define that as another
120:43 - variable up here
120:45 - call this private val chosen
120:49 - image uris there's going to be a mutable
120:51 - list
120:52 - of uri so a uri we're able to import
120:56 - this
120:57 - is a uniform resource identifier you can
120:59 - kind of think of it like a string
121:01 - which unambiguously identifies where
121:03 - does a particular resource
121:05 - live and so the resource in our case is
121:07 - an image this is an image which
121:09 - lives on the phone it's physically
121:11 - stored on the phone the uri
121:12 - is describing what is the directory path
121:14 - to locate this photo so when the user
121:16 - has picked
121:17 - two or three photos for example there
121:19 - will be two or three elements in this
121:20 - list two or three uris
121:22 - so that'll be the second parameter and
121:24 - the third parameter will be the board
121:26 - size
121:26 - let's have android studio help us to
121:28 - create this class we'll extract it to a
121:30 - separate file
121:31 - and the first parameter i'll rename it
121:34 - to be context the private vowel context
121:36 - second parameter is the chosen image
121:38 - uris and i want this to be just a normal
121:40 - list and not a mutable list
121:42 - and the third parameter is the board
121:43 - size and all of these should be private
121:45 - val
121:47 - just like before we would like to define
121:50 - an inner class
121:50 - view holder and that will be what we
121:52 - parameterize the constructor of the
121:55 - image picker adapter by so i'll define
121:57 - inner class view holder which inherits
121:59 - from recycler
122:00 - view holder and once we define this
122:02 - inner class now we can go ahead and
122:04 - override the three members or three
122:07 - methods of the adapter
122:12 - okay so the get item count is
122:13 - straightforward the number of images
122:16 - that the user has to
122:17 - pick is the number of pairs in this game
122:20 - so if i have a 24 card memory game then
122:22 - the user has to pick 12 images and we
122:23 - should be returning 12 here
122:25 - that'll be board size dot get num pairs
122:27 - that's why we passed in the board size
122:29 - as a constructor parameter
122:31 - and now let's implement the
122:32 - oncreateviewholder so again this is
122:34 - going to be quite similar to what we
122:35 - already did
122:36 - in the memory board adapter i'm going to
122:39 - call layoutinflator.from
122:41 - passing the context which is a
122:43 - constructor parameter
122:45 - i'm going to inflate a custom
122:48 - layout file that we'll define i'll call
122:50 - it card
122:51 - image parent
122:54 - and false this is going to be a view
122:59 - and let's now define this card image
123:03 - resource file
123:06 - i'm going to have the root element here
123:08 - be a linear layout because we can keep
123:09 - this
123:10 - file a little bit simpler and this is
123:12 - going to be
123:13 - really straightforward there's no need
123:14 - to embellish the design with any kind of
123:16 - card elevation or rounded
123:18 - edges or anything like that so the only
123:19 - thing we need to do is drag out an image
123:21 - view
123:25 - well and so i want to just hard code the
123:27 - width and height just to make this look
123:28 - a little bit more realistic
123:30 - to be 100 dp each
123:34 - give this an id of iv custom image
123:41 - and let's change the scale type to be
123:43 - center crop
123:44 - just like we had done earlier
123:48 - and let's also provide some margin on
123:50 - this element just so that the
123:52 - card views that we show in the creation
123:55 - and the creativity
123:56 - aren't glued next to each other there's
123:57 - going to be some space in between them
123:58 - so i'll search for margin here
124:02 - and set this equal to 8 dp
124:06 - cool one more thing is that
124:09 - the parent element the linear layout i
124:11 - want the
124:13 - height of this to be wrap content and
124:15 - then finally
124:16 - we want the image view inside of the
124:18 - linear layout to be centered so we're
124:20 - going to set the gravity
124:21 - of the linear layout to be center
124:26 - and one more thing we can do here also
124:28 - is on the image view
124:30 - if there is no image selected which will
124:32 - be the default state
124:33 - then i want to see the background color
124:35 - of the imageview
124:36 - and we're just going to have this be a
124:37 - hard-coded color
124:39 - which is coming from the android system
124:42 - called darker gray
124:45 - and you can't see that in the preview
124:47 - because we are using this
124:49 - sample image but you'll see it when we
124:51 - run the app
124:52 - so going back to the image picker
124:53 - adapter now we have this proper
124:56 - card image that we're inflating and
124:58 - similar to what we did last time this
125:00 - image view it shouldn't have a hard
125:02 - coded height of 100 dp
125:04 - we should instead be making proper use
125:06 - of the space
125:07 - of the screen and so we're going to do
125:08 - something quite similar
125:12 - so i'm going to look at the width of the
125:14 - parent which is the recycler view how
125:15 - much space have we allocated for the
125:16 - recycler view
125:17 - and i want to partition that up into
125:20 - however many
125:21 - images the user should pick across so
125:24 - that's the board size
125:25 - dot get width that'll be the card with
125:29 - and then the card height the maximum
125:32 - allowable card height
125:34 - will be the height divided by the number
125:36 - of rows in our board which is board size
125:38 - dot get height
125:39 - and again similar to last time we're
125:41 - going to define a card side length which
125:43 - is
125:43 - the minimum value of the card width and
125:45 - the card height so we're gonna have to
125:47 - import math.main from kotlin
125:49 - and so now we can grab a reference to
125:51 - this
125:52 - image by using the id so i'll say
125:56 - view which is the linear layout plus the
125:59 - image view and then inside of that view
126:01 - we're going to find
126:02 - the image view with this particular id
126:07 - r.id.iv custom image we're going to get
126:09 - the layout parameters
126:13 - and on the layout parameters now we can
126:14 - set the width and height to be the card
126:16 - side length that we just computed
126:18 - [Music]
126:23 - and finally the return value of this
126:26 - oncreateviewholder is a viewholder
126:29 - so we're going to construct this new
126:31 - view holder class
126:33 - and pass in the view
126:36 - that we inflated we can actually make
126:39 - this card height a valve just because
126:40 - we're not changing any of these again so
126:42 - similar to
126:43 - a view card with card height because
126:44 - these values are not changing
126:47 - we can set all these to be val and
126:49 - finally the onbindviewholder method
126:52 - so the intention here is given a
126:54 - particular position we want to
126:56 - define how do we display the ui there
126:59 - are two cases
127:00 - here so if you think back to the second
127:03 - constructor parameter the list of image
127:05 - uri so let me show you rename this to be
127:06 - just image uris
127:10 - so if the position that we're binding
127:11 - here is
127:13 - less than the size of the image uris
127:16 - that means
127:16 - that means that the user has actually
127:18 - picked an image for this position and we
127:20 - should show that image
127:22 - on the other hand if the position is
127:24 - larger than image uris
127:26 - the size of image uri something that we
127:27 - should just show the default kind of
127:29 - gray background to indicate to the user
127:31 - that they still need to pick an image
127:33 - if the position is less than image
127:36 - uris.size
127:39 - that means that we should showing the
127:41 - image selected in the image view so
127:43 - i'll delegate the work there to be in
127:45 - this bind method so i'll say
127:47 - imageuris.position
127:50 - on the other hand if position is
127:54 - greater than or equal to the size of the
127:56 - image uris the user hasn't yet picked an
127:58 - image at this point so we'll just say
128:01 - holder dot bind there's not really much
128:02 - to do but we're just going to define
128:03 - this method dot bind
128:05 - so there are two methods now that we're
128:07 - going to find in the view holder one
128:09 - which is bind without
128:10 - any parameters and the other has one
128:12 - parameter which is the
128:13 - uri at that position the view holder is
128:16 - wrapping the custom
128:17 - view that we defined in card image.xml
128:20 - so we'll grab a reference to the
128:21 - image view by saying private val iv
128:23 - custom image and that'll equal
128:24 - the find view by id on the item view
128:28 - now that we have a reference to the
128:29 - image view in the first version of the
128:30 - bind method the one which takes in a uri
128:32 - all we need to do
128:33 - is set the image uri on that ib custom
128:36 - image
128:36 - and the other thing we'll want to do is
128:38 - set a null click listener
128:40 - which basically means that we don't want
128:41 - to respond to clicks on this
128:43 - image view so in the second case this is
128:46 - where we want to actually
128:47 - be able to listen for the user tapping
128:49 - on this square
128:50 - on this image view because that will be
128:52 - an indication that they want to choose
128:54 - an image
128:54 - so what we'll what we'll do is say iv
128:56 - custom image.set on click listener
128:58 - and we'll implement this in the next
129:00 - part the goal is to launch an intent
129:02 - for the user to select photos let's try
129:05 - it
129:05 - and see what it looks like so as our app
129:08 - gets a little bit more complicated
129:10 - one thing that's worth investing in is
129:12 - thinking about how can we
129:13 - improve the efficiency of getting to the
129:15 - creativity right now we have to go to
129:16 - the menu
129:17 - tap on a couple different buttons and
129:18 - then finally get there one thing we can
129:20 - do which is a hack for
129:21 - developer efficiency is back in main
129:23 - activity in the oncreate function
129:26 - we can directly create the intent to
129:29 - navigate to the create
129:30 - activity so this will be similar to what
129:32 - we're doing when we
129:34 - tap on the menu option but we'll just do
129:35 - it right away so i'm going to create a
129:37 - new intent
129:38 - pass in the medium board size and then
129:40 - launch the activity right away
129:42 - this is definitely not something that we
129:44 - want to ship to production but in
129:45 - general
129:46 - anytime you have an opportunity to
129:48 - improve the efficiency
129:49 - with which you develop it's worth
129:51 - investing in so now when we start the
129:52 - app
129:53 - you can see we get a brief glimmer of
129:55 - the main activity but now we're
129:56 - navigating directly into the create
129:58 - activity
130:00 - we're seeing nine gray squares here
130:01 - because we hard coded in the board size
130:03 - of medium
130:04 - and what these gray squares are
130:05 - communicating to the user is that they
130:07 - can tap on them in order to select a
130:09 - photo from their device and that will be
130:11 - what's used
130:11 - in order to create their custom memory
130:13 - game one quick improvement we can make
130:16 - is if i scroll up or down in the
130:17 - recycler view we see this purple shadow
130:19 - which communicates to the user that
130:21 - there's no more content in the recycler
130:22 - view
130:23 - but that doesn't make sense in our
130:24 - context because we are
130:26 - guaranteeing the size of the
130:28 - recyclerview so if we go into the rv
130:29 - image picker
130:30 - and look for over scroll mode then we
130:33 - can set that to never and
130:35 - address that issue hey one quick tip i
130:38 - wanted to share with you
130:39 - if you're using an emulator like i am
130:41 - then in the next part we're going to be
130:42 - using
130:43 - some photos that live on your phone or
130:45 - on your emulator
130:46 - as part of building out the app and so
130:49 - if you're like me
130:50 - you probably don't have some photos by
130:52 - default on the emulator
130:54 - and so i wanted to show you really quick
130:55 - how you can do that so
130:58 - if you have a image
131:01 - like this one then all you need to do in
131:03 - order to have it show up in your
131:04 - emulator is drag and drop it
131:06 - onto the emulator and that'll copy the
131:08 - file and now in order to have it show up
131:11 - open up the list of all apps and look
131:14 - for photos
131:15 - or whatever is your gallery app on your
131:17 - emulator
131:18 - open up that gallery app and i found
131:20 - that sometimes it's helpful to force
131:22 - restart the photos app and then open it
131:24 - up again and hopefully we should now see
131:26 - this new photo that we drag and dropped
131:28 - onto the emulator
131:31 - now we can see the image that was
131:32 - previously on our laptop and now it's on
131:34 - our emulator
131:35 - so this is the easiest way for you to
131:38 - take images that are on your computer
131:39 - drag them into the emulator and then you
131:41 - can use them
131:41 - in subsequent parts when we start to
131:44 - build out
131:44 - the ability to choose photos from your
131:47 - phone in order to customize the memory
131:48 - game
131:49 - in the next segment we'll hook up the
131:51 - behavior of what should happen when a
131:52 - user taps on these
131:54 - grey image views in this segment our
131:56 - goal is to hook up the click listener
131:58 - when the user taps on any one of these
132:00 - gray squares or image views in the
132:02 - recycler view
132:04 - and the way we'll do this is once again
132:05 - quite similar to what we did with the
132:07 - main activity
132:08 - which is that in the image picker
132:10 - adapter we're going to define an
132:11 - interface
132:12 - and that interface will have one method
132:14 - indicating
132:15 - indicating that the user has tapped on
132:18 - this element
132:19 - and that will be how the create activity
132:20 - gets informed of
132:22 - a click and the create activity is what
132:25 - will launch the
132:26 - flow for allowing the user to pick a
132:28 - photo from their device
132:29 - so let's define an interface here
132:35 - image click listener
132:38 - [Music]
132:40 - and then this is gonna have exactly one
132:42 - function inside of it inside this
132:43 - interface
132:44 - called on placeholder clicked
132:50 - and the final parameter of the adapter
132:53 - is going to be an
132:54 - instance of this image click listener
132:55 - class so private vowel
132:58 - image click listener and it's of type
133:00 - image click listener
133:03 - in the view holder when we bind the set
133:06 - on click listener on the image view
133:08 - we're going to invoke the on click
133:11 - listener method
133:12 - of the interface so we'll say on
133:14 - placeholder clicked
133:16 - for image click listener and so now back
133:18 - in creativity
133:19 - we need to pass in this fourth parameter
133:22 - which is the instance
133:23 - of the interface so right object here
133:27 - and this is defining an anonymous class
133:29 - which implements the interface
133:31 - image click list center
133:35 - and there's one method we need to
133:36 - override and integrate will help us with
133:38 - that
133:39 - and tap on implement numbers and here is
133:42 - where now
133:43 - play on placeholder click means that the
133:45 - user has tapped on one of these gray
133:47 - squares these image views
133:48 - and so here is where we're going to
133:50 - launch the photo
133:52 - choosing flow and i'm going to delegate
133:54 - that into a method
133:55 - called launch intent for photos
133:59 - so this is the second time we're dealing
134:00 - with intents now we had one intent to go
134:02 - from the main activity to the create
134:03 - activity
134:04 - we're also going to have an intent here
134:06 - to launch
134:07 - the flow for the user to pick a photo
134:09 - and this is called the implicit intent
134:11 - because we don't actually
134:12 - care which application on the phone will
134:14 - handle this intent this request but we
134:16 - just want
134:17 - the user to choose either google photos
134:18 - or a gallery app or something else on
134:20 - their phone which will allow them
134:22 - to pick an image for our application to
134:24 - consume so what we had earlier was an
134:27 - explicit intent because we were
134:28 - explicitly navigating to this
134:29 - create activity and here the create
134:31 - activity is going to launch an implicit
134:33 - intent to allow the user to choose an
134:35 - image
134:36 - so let's define this method
134:40 - and i'll put this at the bottom below
134:42 - all of the overwritten methods
134:44 - and here we're going to have an intent
134:49 - and because this is an implicit intent
134:51 - we're going to just pass in
134:52 - uh intent action here intent dot
134:56 - action pick and there's a
134:59 - property on the intent called type and
135:02 - we're going to pass an image slash star
135:05 - communicates that we only really care
135:06 - about images we don't want
135:08 - video files or pdfs or any other kind of
135:10 - file
135:11 - and we'll pass one extra into the intent
135:13 - we'll say intent.put extra
135:15 - and this is a constant on the intent
135:16 - class intent.extra allow multiple
135:19 - so extra allow multiple is a constant
135:21 - defined on the intent class
135:23 - so this is the key and the value is true
135:25 - basically what this means is
135:26 - if the app that the user opens up
135:28 - supports it we want to allow the user to
135:30 - select
135:31 - multiple images and this is valuable
135:33 - because if i have to pick 12 images one
135:35 - at a time that can get tedious
135:36 - instead i might say i want to pick all
135:38 - the photos from today
135:39 - have all of them be imported into my
135:42 - application
135:43 - so once we have this now we can say
135:44 - start activity for result
135:47 - and we're going to say intent dot create
135:50 - chooser and we're going to pass in the
135:53 - intent that we just created
135:54 - called intent and then the second
135:57 - parameter is
135:58 - a car sequence or a string we'll pass
136:01 - and choose picks here
136:04 - [Music]
136:05 - and this is basically some text which
136:07 - which shows up when the user has
136:09 - multiple apps on their phone that can
136:11 - service this request
136:12 - and the second parameter to start
136:13 - activity for result similar to last time
136:15 - is a request code
136:16 - so i'm going to define a request code
136:18 - pick photos request code
136:20 - and we're going to define this inside of
136:21 - the companion object of create activity
136:23 - so inside the companion object
136:25 - we will define this constable pick photo
136:28 - code and i'll set it equal to
136:29 - 655 which is the street address of my
136:32 - favorite dorm
136:33 - at stanford brainerd hall one really
136:36 - important observation about what we're
136:37 - doing here
136:38 - is that with this request our
136:40 - application is going to
136:41 - need access to files on the user's phone
136:44 - and by default
136:46 - the android system doesn't give your app
136:48 - this permission this is where we're
136:49 - going to have to request
136:51 - permissions in the android permission
136:52 - model the first thing we'll do is open
136:55 - up the android manifest file
136:57 - and at the top let's declare that our
136:59 - application uses this permission
137:01 - and the permission is called read
137:03 - external storage because for example if
137:05 - the photo is located in the downloads or
137:06 - document
137:07 - directory of the phone we're going to
137:09 - read that location of storage which is
137:11 - external to our app
137:13 - there are two kinds of permissions in
137:14 - android normal and dangerous
137:16 - read external storage is a dangerous
137:18 - permission and what that means
137:20 - is just writing user's permission read
137:22 - external storage
137:23 - in the android manifest isn't enough for
137:25 - our app to actually
137:27 - exercise that permission instead
137:30 - at runtime the user has to be shown a
137:32 - dialog
137:33 - which informs them that this app my
137:36 - memory
137:37 - is trying to use this permission do you
137:39 - want to allow it or reject it
137:41 - and so that's what we're going to
137:42 - implement next so
137:44 - before we call this launch intent for
137:46 - photos
137:47 - function we need to check if the user
137:49 - has granted the permission or not
137:51 - i'll say if is permission granted
137:58 - then we can go ahead and call launch and
137:59 - temper photos like normal
138:01 - but if not then we need to actually
138:04 - request permission
138:08 - what i've written here is pseudocode so
138:09 - it won't actually compile
138:11 - but i just want to walk through the
138:12 - logic if the permission is not granted
138:14 - then we
138:15 - need to first request permission and
138:17 - then get a call back
138:19 - if the user has accepted and then once
138:21 - again call launch intent for photos
138:23 - to properly implement these we need to
138:25 - make calls into
138:26 - android system functions and i always
138:28 - have a hard time remembering them and i
138:30 - find them a little bit verbose and
138:32 - hard to parse and so i'm going to create
138:34 - a utility class
138:35 - called permission utils and have all the
138:37 - messiness of interacting with the
138:39 - android permissions api
138:40 - in that class inside of permission utils
138:43 - we'll define two functions
138:44 - first is permission granted and this
138:46 - will take in a context
138:48 - and a permission string and it'll return
138:51 - a boolean on whether the permission is
138:52 - granted or not
138:54 - and the body of the function will be
138:55 - context compat
138:57 - check self permission with the context
138:58 - permission and we see if the return
139:00 - value of that is equal to package
139:01 - manager dot permission granted
139:04 - the second function is request
139:05 - permission which takes in three
139:06 - parameters
139:07 - first is the activity which you'll need
139:09 - to import
139:11 - the permission which is a string and a
139:13 - request code which is an integer
139:15 - and the body of the function is activity
139:17 - compat.request permissions with the
139:18 - activity
139:19 - we need to pass an array of permissions
139:21 - so we'll construct that in line
139:22 - right here and then the request code
139:26 - so back in create activity let's
139:29 - actually use these permission utils
139:31 - functions in is permission granted the
139:33 - first parameter will be a contact so
139:35 - we'll pass in this at create activity
139:37 - and the second parameter is a string
139:40 - representing the permission so for that
139:41 - i'm going to define
139:42 - it as a constant called read photos
139:44 - permission in the companion object
139:46 - and this will be coming from
139:48 - android.manifest.permission read
139:49 - external storage
139:51 - to pass that in for the second function
139:53 - request permission i first want to
139:54 - define the request code
139:56 - so i'll say read external photos code
139:58 - and make it equal to 248
140:00 - doesn't really matter what it is but as
140:01 - a best practice we should keep the two
140:03 - request codes distinct in request
140:05 - permission the first parameter is the
140:06 - activity so i'll pass in this at
140:08 - creativity
140:09 - second is the permission which is read
140:11 - photos permission and the request code
140:13 - is what we just defined
140:14 - we're almost done now this request
140:16 - permission function is going to launch
140:18 - an android system dialog
140:19 - asking the user if they want to allow my
140:22 - memory this app
140:23 - the read external storage permission
140:26 - regardless of whether the user accepts
140:28 - or rejects we will get a call back
140:30 - called on request permissions result and
140:33 - that's what we'll override
140:34 - there are three parameters here the
140:35 - first is the request code and the third
140:37 - one which is what we'll care about is
140:39 - the grant results
140:40 - so the first thing we'll do is check if
140:42 - the request code is equal to the read
140:44 - external photos code that we
140:45 - used to launch the permission dialog
140:48 - then we'll check the grant results and
140:49 - it should be
140:50 - non-empty because we're getting the
140:51 - results here and we'll check if that is
140:53 - equal to permission granted which means
140:55 - that the user
140:55 - has granted the permission if this
140:57 - happens we can go ahead and call
140:59 - launch intent for photos if not the user
141:02 - has rejected
141:03 - our app from getting the permission and
141:05 - we should inform the user
141:06 - the impact of this so we'll show a toast
141:09 - and we'll tell the user in order to
141:10 - create a custom game
141:11 - our app needs to have permission to get
141:14 - the photos from their phone
141:16 - let's try it and once you're on the app
141:20 - and we tap on one of these image views
141:23 - these gray
141:24 - squares if we've done our job correctly
141:26 - we should now see an android system
141:27 - dialog
141:28 - asking if we allow this application the
141:32 - read external photos permission so tap
141:35 - on it
141:35 - and you can see we do have this pop-up
141:37 - show up and this is a dialog that we
141:39 - didn't write it's coming from android
141:41 - so let's actually start by hitting deny
141:43 - and then we get the toast that we wrote
141:46 - now let's show one more time and let's
141:48 - allow it
141:49 - and now as a result of that implicit
141:51 - intent an application on the phone is
141:53 - opened up google photos which allows us
141:55 - to pick
141:56 - one or more photos that we can then
141:58 - surface in the my memory app
142:00 - let's go ahead and pick these set of
142:02 - three images
142:03 - and tap on done and you'll see that we
142:05 - don't actually update the ui at all
142:08 - with the images that we get back from
142:10 - the intent from the on
142:11 - activity result and so let's fix that
142:14 - and show the images here
142:16 - back in create activity the place that
142:18 - we're launching the implicit intent
142:20 - is right here and when we call start
142:22 - actually for a result
142:23 - whatever is the result of the launch
142:26 - activity we'll come back
142:27 - in a function that we're going to
142:29 - override called on activityresult
142:31 - the first thing i want to do in
142:33 - onactivityresult is check
142:34 - the request code does that match up with
142:37 - the request code that we passed in
142:40 - pick photo code that we passed in to
142:42 - launch the activity do those match
142:44 - if so then we know that we're getting
142:45 - we're processing the auditive results
142:47 - for the right intent and actually i'd
142:49 - like to do the negation of this
142:50 - because there are several cases where we
142:52 - know the data we get back is invalid if
142:54 - the request codes don't equal
142:55 - if the result code is not activity dot
142:57 - result okay
142:58 - or if the data is null in all three of
143:00 - these cases we should log a warning and
143:02 - return early because
143:03 - we won't be able to find valid photo
143:05 - data
143:06 - so we're going to add a log statement
143:07 - here and we'll log at the warning level
143:09 - log.w
143:10 - did not get data back from the launch
143:11 - activity user likely cancelled
143:13 - the selection flow now let's go up and
143:16 - define the tag in the companion object
143:18 - private cost val tag is equal to create
143:20 - activity
143:25 - and if any of these conditions are met
143:27 - we will simply return early
143:31 - on the other hand if we've gotten this
143:32 - far in the function we know we have
143:34 - valid data inside of the data intent and
143:37 - i've tested this
143:38 - on several different devices and based
143:40 - on my experience
143:41 - there are actually two different
143:43 - attributes that we care about on the
143:44 - data intent
143:46 - first if the application that's launched
143:48 - in order for the user to pick a photo
143:50 - only supports picking one photo then
143:53 - the selected photo will come back in the
143:56 - data.data attribute and that'll be a uri
144:00 - on the other hand if the application
144:02 - launched
144:03 - supports picking multiple photos and
144:05 - either picks multiple photos
144:07 - then that data will come back as part of
144:09 - data.clip data
144:12 - and we will prefer to use the clip data
144:14 - because that will have multiple images
144:16 - and the first thing we'll do is check if
144:18 - clip data is not equal to null
144:21 - and in that case we'll log at info level
144:25 - the clip data num images how many items
144:27 - are in the clip data
144:28 - along with the actual contents of the
144:30 - clip data object
144:34 - now we're going to iterate through the
144:36 - clip data so i'll say for i
144:38 - in 0 until the clip data item count
144:41 - we'll retrieve the
144:43 - clip item at that position in the clip
144:45 - data
144:46 - and now what we'll do is we want to get
144:49 - the
144:50 - image uri out of the clip item object so
144:52 - we're going to add this
144:54 - image uri into the chosen image uris and
144:57 - you'll remember we pass
144:58 - in the chosen image uris into the
145:00 - adapter and so having the image show up
145:02 - in our recycler view is as simple as
145:04 - adding it into
145:05 - chosen image uris so first we'll check
145:07 - if we still need to populate the chosen
145:09 - image uris
145:10 - check the size and if so then we can go
145:12 - ahead and add
145:13 - the clip item.uri into the chosen image
145:16 - uris
145:17 - the other case is if selected uri is not
145:19 - null
145:20 - so in that case we'll log the selected
145:23 - uri with a tag
145:24 - and just print it out and we'll also add
145:27 - it to the chosen image uris list
145:29 - the reason we're able to add selected
145:31 - uri unconditionally in this case
145:33 - whereas before we had to check the size
145:35 - of the chosen
145:36 - image uris list is because if we get
145:39 - into this method on it to be result
145:40 - that means the user has tapped on the
145:43 - gray placeholder image view
145:45 - and that means there's space for at
145:46 - least one more image in the chosen image
145:48 - uris list
145:49 - on the other hand in the case of clip
145:51 - data the user might have picked an
145:52 - arbitrary number of images for example
145:54 - 20 images
145:54 - but we only want the amount specified by
145:57 - num images required
145:58 - that's why in every iteration of the for
146:00 - loop we check how many images are in our
146:02 - uri list
146:04 - now we have added the image uris into
146:07 - the list so we can notify the adapter
146:10 - that the underlying data set has changed
146:11 - in order to do that we need to make
146:13 - the adapter a property or a member
146:15 - variable of the class
146:17 - so let's do that
146:21 - well adapter is equal to that and i'll
146:24 - just set
146:24 - the image picker adapter to be adapter
146:28 - and now this adapter it shouldn't be
146:29 - locally defined it should be defined as
146:31 - a member variable so let's do that
146:34 - private late init var adapter
146:38 - image picker adapter and so now let's
146:40 - get rid of the declaration here
146:42 - and just set this equal to the property
146:46 - awesome so now coming back here you can
146:48 - say adapter dot
146:50 - notify data set changed one more thing
146:53 - we should update
146:54 - is the title of the activity which
146:56 - informs the user how many images they've
146:58 - picked so far
146:59 - so on the support action bar we'll we'll
147:01 - update the title attribute
147:03 - to say choose picks and now the
147:05 - numerator will be
147:06 - the size of chosen image uris and the
147:08 - denominator
147:09 - will similar to last time be the number
147:11 - of images required
147:12 - all right let's try it out okay so we're
147:16 - in the creation activity
147:18 - let's go ahead and grab all three of
147:20 - these images
147:22 - awesome so we can see right away that
147:24 - the first three
147:25 - image views in our grid of nine are
147:28 - populated with those
147:29 - images that we picked and if we look at
147:32 - logcat
147:32 - we can see the log message from the
147:34 - creativity at info level
147:36 - which says the clip data num images is
147:39 - three which makes sense because that's
147:40 - how many images we're seeing in our
147:42 - recycler view
147:43 - let's also try out the case where we
147:44 - only pick one image
147:46 - so we'll tap on the great image view
147:47 - which is a placeholder
147:49 - and select the image of rochester
147:52 - downtown
147:53 - tap on done and now we can see that gets
147:55 - populated and again the logcat shows
147:57 - that this is
147:58 - clip data which means that we're falling
147:59 - into the case of the clip data not being
148:02 - null
148:03 - so on this phone we are always getting
148:04 - clip data back i have found that in some
148:06 - phones or in some applications where
148:08 - you're not allowed to select multiple
148:09 - images that's when you get into the case
148:11 - of the selected uri
148:12 - not being null try it out on your phone
148:15 - and see what happens
148:17 - one more thing worth pointing out is
148:18 - that once an image is
148:20 - shown in an image view you can no longer
148:22 - click on it
148:23 - so if we go into image picker adapter
148:25 - we're setting the click listener to null
148:26 - and that's what
148:27 - is preventing the click from being
148:29 - registered and that's a product decision
148:31 - that once an image is picked then the
148:34 - user has no ability to change it
148:35 - and if you wanted to you could modify
148:37 - this behavior to allow this kind of edit
148:39 - functionality but for now we're going to
148:41 - leave it as is
148:42 - notice at the top of the activity we
148:44 - have the action bar title
148:46 - to say choose picks 4 of 9 and looks
148:48 - like i
148:49 - am missing the ending parenthesis so
148:51 - let's go into creativity and fix that
148:55 - there's one final thing i want to get
148:57 - started on in this part
148:59 - which is the logic to enable or disable
149:01 - the save button
149:02 - there are two conditions that must be
149:04 - met in order to enable the save button
149:06 - first all the images must be selected so
149:09 - in this case we have nine images all of
149:10 - them have to be valid images
149:12 - and second there has to be a valid game
149:14 - name in the edit text
149:16 - and so when either of those two
149:18 - components on the screen changes that's
149:20 - when we might
149:20 - be enabling the save button so in the
149:23 - bottom of the
149:25 - audit tv result which means that the
149:26 - image has been selected
149:28 - i'm going to call this method should
149:29 - enable save button
149:31 - this function is responsible for
149:33 - deciding whether we should enable the
149:35 - save button or not
149:36 - but for now let's simply return true and
149:39 - try this out
149:40 - so now as soon as i select any image and
149:43 - i
149:44 - come back into the create activity now
149:45 - you can see how the save button is
149:47 - enabled because we're turning through
149:48 - there
149:49 - nothing happens when i tap on that
149:50 - button the handling of that
149:53 - will happen in subsequent parts this was
149:56 - a really critical part of the creation
149:57 - flow dealing with permissions
149:59 - and intents and filling out these images
150:01 - in the grid view
150:03 - all right this segment should be a
150:04 - little bit lighter our goal is
150:06 - to properly figure out whether we should
150:08 - enable the
150:09 - save button based on if the user has met
150:12 - the two conditions in order to save a
150:13 - new game
150:14 - first is they have to have picked out
150:15 - every image and second they have to
150:17 - fill out a custom game name
150:20 - the first condition is if the size of
150:22 - the chosen image uris list
150:24 - is not equal to the number of images
150:25 - required and that means the user hasn't
150:26 - picked enough images
150:28 - for the memory game size desired and in
150:30 - this case we'll simply return false
150:32 - the button should not be enabled the
150:34 - other condition is around the length of
150:36 - the game name
150:36 - the user creates for this memory board
150:38 - obviously an empty name is invalid but
150:41 - we also want to mandate a minimum length
150:43 - of the name for example a single letter
150:45 - like a
150:45 - or b shouldn't be a valid name so we're
150:47 - going to have two conditions
150:48 - if the et gamename.txt if it's blank
150:52 - or if the length is less than three
150:55 - then we want to return false and
150:56 - otherwise we can return true which would
150:58 - enable the button
150:59 - we're currently calling this method
151:00 - should enable save button whenever the
151:02 - user has picked an image but we also
151:05 - would like to call it
151:06 - whenever the text of that edit text at
151:09 - the bottom for the game name has changed
151:11 - so in the oncreate method we're going to
151:13 - add a text
151:14 - change listener on et game name
151:18 - we have to provide as the parameter a
151:20 - text watcher
151:21 - so the object text watcher and this has
151:24 - three methods that we need to override
151:26 - and we only really care about the first
151:28 - one after text change so i'm just gonna
151:30 - delete the body for the other two
151:32 - and leave them as empty and the logic
151:34 - here is very simple we're simply going
151:36 - to call that method should enable save
151:37 - button again and that will dictate
151:39 - the is enabled property of the btn save
151:42 - so every time the user makes any
151:43 - modification in that edit text
151:45 - we will potentially enable the save
151:47 - button one more thing that we should do
151:49 - here
151:50 - is set a maximum length of the
151:53 - game name so if the text of the game is
151:56 - too long it'll
151:56 - be painful to share with friends and
151:58 - family and so we're going to restrict
152:00 - the maximum length to be
152:01 - 14 characters and this turns out to be
152:04 - pretty straightforward
152:05 - there's a filters attribute on the edit
152:08 - text and we are going to
152:09 - set that equal to an array of filters
152:11 - and we're going to pass in one filter
152:12 - and it'll be an inbuilt filter
152:14 - called inputfilter.lengthfilter and we
152:16 - pass in
152:17 - 14 which is the maximum allowable length
152:20 - the result of what we've done
152:21 - is that the minimum length of a game
152:23 - name is 3 characters and the maximum is
152:25 - 14.
152:25 - this is a general good engineering
152:27 - practice which is always
152:28 - validating user input no matter what the
152:30 - user does the application should never
152:32 - crash
152:33 - and the steps you've taken here help to
152:34 - prevent anything unexpected from
152:36 - happening
152:37 - along those lines one more good practice
152:40 - is to define constants for these key
152:43 - values for example
152:44 - the minimum game length and the maximum
152:46 - game length can both be constants so min
152:48 - game
152:49 - name length will be 3 and max will be
152:51 - 14. so now it's very obvious
152:53 - in the code what these magic numbers
152:55 - represent
152:59 - so i'll pass in the max game length and
153:02 - the min game length as appropriate
153:06 - awesome so at this point if the save
153:08 - button is enabled based
153:10 - on the logic we wrote the user should be
153:12 - able to
153:13 - take the data that they've collected and
153:16 - save all that to firebase so anyone in
153:18 - the world can play
153:19 - their custom memory game so in order to
153:22 - make that happen
153:22 - let's add a click listener on the save
153:24 - button
153:26 - and the code that will execute when the
153:29 - button is clicked
153:30 - is going to be a method that we're going
153:31 - to define in a little bit
153:33 - called save data to firebase
153:36 - this method is responsible for taking
153:37 - all the images and the associated game
153:40 - name and saving that to firebase
153:42 - so let's have another studio create this
153:44 - function and i'm going to move this
153:45 - pilot function
153:46 - down below any of the other override
153:49 - functions that we have
153:51 - the actual logic of integrating with
153:53 - firebase we will do that in a
153:55 - subsequent segment but for now i want to
153:58 - put a log statement here
153:59 - and i want to write some logic for down
154:01 - scaling the image
154:03 - and the reason why i want to downscale
154:05 - is because the images
154:06 - typically on your phone are going to be
154:08 - quite large more than a megabyte or two
154:10 - megabytes
154:11 - and we're only showing you the image in
154:14 - the memory game in a very small square
154:16 - so downscaling the image means that we
154:18 - are able to
154:19 - use up less storage in firebase storage
154:21 - and also when we download the image
154:23 - it'll be faster download if you only
154:25 - have a few hundred users
154:27 - then the amount of storage you're going
154:29 - to take up on firebase storage
154:30 - is going to be minimal anyway so feel
154:32 - free to skip this part if you're not
154:33 - interested
154:34 - but it's also something interesting to
154:37 - learn about
154:40 - so let's put a log statement here
154:44 - and i'm going to have a for loop which
154:45 - now iterates over
154:47 - the chosen image uris and we're going to
154:50 - iterate
154:50 - through it with both the index and the
154:53 - element and i'll call that photo uri
154:57 - so we'll have this chosen image uris
155:01 - that with index
155:05 - so i'm going to find a method called get
155:07 - image byte array
155:10 - and this will take in a photo uri
155:13 - and this will return to us a image byte
155:15 - array
155:17 - and that image battery is what we're
155:19 - actually going to be uploading to
155:20 - firebase storage
155:22 - and this method is going to take care of
155:25 - all the
155:26 - downgrading of quality that we want so
155:28 - let's define this method
155:31 - and the return type should be a byte
155:33 - array
155:36 - the first thing we'll do here is get the
155:38 - original bitmap
155:39 - based on the photo uri and this will
155:41 - depend on the api version of the phone
155:44 - that this app is running on
155:45 - so i'll call this original bitmap
155:48 - and if the build.version.sdkint
155:52 - is greater than or equal to p which is
155:55 - android pie then the way to get the
155:58 - original webmap
155:58 - is by using something called
156:01 - imagedecoder.createsource
156:02 - content resolve a photo uri and then we
156:04 - call imagedecoder.decodebitmap with that
156:07 - source otherwise if we're running a
156:09 - lower version
156:09 - then we'll say
156:13 - mediastore.images.media.getbitmap
156:14 - contentresolver with the photo uri
156:16 - so this conditional is interesting what
156:18 - it means is that if the
156:20 - phone operating system that we're
156:21 - running on is running android pi
156:24 - or higher then the original bitmap will
156:26 - come from running those two lines of
156:27 - code
156:28 - and otherwise on an older version we'll
156:30 - run this one line of code in order to
156:31 - get the
156:32 - original bitmap now let's log the width
156:34 - and height of the original
156:35 - map so we can compare the size now
156:38 - versus after we scale it down
156:40 - so we'll log at the info level original
156:42 - bitmap.width and originalbitmap.height
156:45 - so i'm going to invent a method here
156:47 - called
156:49 - dot bitmapscaler.scale to fit height
156:50 - passing the original bitmap along with
156:52 - 250. let's define this class now
156:56 - i'm going to extract it to a separate
156:57 - file and put it into the utils
156:59 - directory tap on ok and the idea of
157:03 - bitmap scalar
157:04 - similar to permissionsutil.kotlin which
157:07 - we defined earlier
157:08 - is simply to create a nicer looking api
157:11 - or nicer looking method
157:13 - around some of the android apis so
157:15 - rather than typing out the code i'm just
157:17 - going to paste it in
157:18 - and then we can talk about it so as the
157:22 - comments describe
157:23 - the intention of these methods is to
157:25 - keep the same aspect ratio of the bitmap
157:27 - but scale it down as per the width or
157:31 - height passed in
157:32 - you can read through the math that's
157:34 - happening here in order to
157:36 - scale the bitmap appropriately it's not
157:37 - that complicated but the broader point
157:39 - here
157:40 - is that whenever you're able to take
157:42 - something complicated
157:43 - or harder to understand and wrap that
157:46 - around something simpler
157:47 - that's a big win computer science is
157:50 - largely about
157:50 - communication and what we've done here
157:53 - is we've taken something which is
157:55 - harder to communicate and wrap that
157:57 - complexity into something
157:58 - which makes it much simpler and that's a
158:00 - huge win now let's
158:02 - turn this into an object because this is
158:04 - a utility class it doesn't make sense to
158:05 - have multiple instances of a bitmap
158:07 - scalar so
158:09 - we can just call bemouthscaler.scale2fit
158:11 - height with a height of 250
158:13 - and once we've done that now let's print
158:15 - out the scaled bitmap width and height
158:20 - the last thing we need to do in this
158:21 - function is to return
158:23 - the byte array and so at the
158:26 - bottom of the function we're going to
158:28 - define a new byte array output stream
158:31 - we'll take our scaled bitmap and then
158:33 - call the compress method on it
158:35 - and we'll pass in a compressed format of
158:38 - jpeg
158:39 - the second parameter is the quality
158:41 - reduction hundred means no reduction in
158:42 - quality
158:43 - and zero means a severe downgrading
158:45 - quality so we'll pass on 60 here
158:47 - and then we'll pass in the byte array
158:49 - output stream that we just defined
158:51 - and finally we'll return byte output
158:53 - stream dot 2 byte array
158:56 - so at this point we have gone through
158:58 - and down scaled the quality
159:00 - of each image the user has selected the
159:03 - job for the next part will be to figure
159:04 - out how to upload this
159:05 - to firebase storage at this point we
159:09 - have the list of all the images that we
159:10 - want to upload to firebase
159:12 - and we've downscaled them appropriately
159:14 - and we are now converting them into a
159:15 - byte array which is
159:16 - what firebase will take in in the upload
159:18 - process
159:19 - so in this segment we're going we're
159:21 - going to write the core logic for
159:23 - taking these photos and actually
159:26 - uploading them
159:27 - to firebase storage this will obviously
159:29 - require
159:30 - the use of the internet in order to
159:32 - communicate with our client our android
159:34 - device
159:34 - to firebase storage so let's open up
159:36 - android manifest
159:38 - and add in the internet permission
159:42 - one thing to observe here is that
159:43 - internet is a normal permission
159:45 - while read external storage is a
159:46 - dangerous permission which means that we
159:48 - don't need any of the
159:49 - runtime permission logic that we needed
159:51 - for read external storage we get
159:53 - internet permission for free
159:54 - in order to now upload this into
159:57 - firebase we need to have
159:58 - a new firebase project so what you
160:01 - should do is
160:02 - go to console.firebase.google.com let's
160:05 - tap on add project
160:07 - and let's call this project my memory
160:11 - [Music]
160:13 - continue and then let's disable google
160:15 - analytics for now
160:16 - it's not strictly required for what
160:18 - we're building
160:19 - and now firebase will take a couple
160:22 - seconds in order to
160:23 - build out your firebase project
160:29 - all right so we're done let's tap on
160:31 - continue
160:32 - and we're going to add an app an android
160:34 - app to get started so we're going to
160:35 - associate our android app to this
160:37 - firebase project so for the packaging
160:41 - let's go back into android studio
160:42 - go up to the very top and then here is
160:44 - our package name
160:45 - which is the thing that we had defined
160:47 - at the beginning when we were creating a
160:49 - new project
160:51 - copy that i'm going to leave the rest of
160:53 - this blank it's a register app
160:56 - and now we need to download this file
160:58 - google services.json
161:03 - and what we want to do is we want to
161:04 - actually drag this into
161:06 - the app directory the way we can do this
161:09 - is
161:09 - as shown in that photo go into the
161:12 - project tool window
161:13 - go into the project perspective of your
161:17 - project and inside of the app directory
161:19 - is where we're going to
161:20 - drag and drop that google services.json
161:23 - file
161:29 - so i just dragged it in and now in order
161:31 - to do it saying move file over so i'll
161:33 - say yes i do want to move this file over
161:35 - and now we can see we have google
161:36 - services.json
161:39 - so now let's go back into the browser
161:41 - and see what else we have to do
161:44 - so now we have to add in the firebase
161:47 - sdk or software development kit
161:49 - into our android app so in the project
161:51 - level build.gradle file we want to first
161:52 - check if we have the google repository
161:54 - and also
161:55 - in the dependency section add class path
161:58 - let's go back into the android
162:00 - perspective
162:03 - in gradle scripts the one which is in
162:06 - the
162:07 - root level we already have google up
162:09 - here and we also already have google
162:10 - down here we just need to add
162:12 - the class path for google services tap
162:14 - on sync now
162:18 - now in the app level build.gradle file
162:20 - we want to
162:22 - add this line for the gms google
162:25 - services plugin
162:27 - so let's exit this build.gradle file and
162:29 - open up this one
162:30 - and here at the top is we're going to
162:31 - add that copy that line and we have to
162:33 - modify this to
162:34 - match the format like that
162:38 - and now we need to add the dependencies
162:40 - for for whatever parts
162:42 - of firebase that we want so firebase
162:44 - actually has dozens of services
162:46 - within it we're going to only really
162:48 - need a couple of them
162:49 - so i'm going to copy this line for the
162:51 - firebase bill of materials
162:56 - so we added that and now below this
162:58 - we're going to add the dependencies for
163:00 - whatever products that we care about
163:01 - so let's open up this url
163:04 - [Music]
163:06 - there are two products in firebase that
163:07 - we care about firestore
163:09 - and storage so first off is
163:12 - cloud firestore and make sure that
163:14 - you're actually in the kotlin tab here
163:17 - so you get the kotlin version of these
163:20 - libraries
163:22 - so we're gonna have to say
163:23 - implementation
163:25 - with this library and the second product
163:29 - is cloud storage
163:36 - and the nice thing with including this
163:39 - build of material is that we no longer
163:40 - need to specify the version on each
163:42 - firebase product that we're
163:43 - adding in so let's tap on sync now now
163:46 - we've pulled in firebase into our
163:47 - project
163:48 - let's go back into our browser tap on
163:50 - next here
163:51 - and then tap on continued account
163:52 - console and here we need to enable the
163:55 - two firebase services that we're going
163:56 - to integrate
163:57 - into our project so let's start with
163:58 - storage and then tap on get started
164:01 - and tap on next choose a location which
164:04 - is close to you so for me it's us
164:05 - central tap on done
164:08 - so now we have firebase storage set up
164:10 - go into the rules tab
164:12 - and by default read and write are only
164:14 - possible
164:15 - if there is a logged in user on the
164:17 - client who's doing the request
164:18 - and we don't have a notion of an account
164:20 - or a logged in user in our app so i'm
164:22 - just going to
164:23 - set this equal to true
164:26 - and then if you're publishing this app
164:27 - of course you want to kind of be more
164:29 - mindful about
164:30 - who you're allowing to read and write
164:31 - data into firebase storage but for our
164:33 - purposes
164:34 - this is going to be fine the other
164:35 - product that we're going to use is cloud
164:36 - firestore
164:38 - so i'm going to create database and
164:40 - we're going to start this in test mode
164:41 - and test mode basically is
164:43 - something similar to what we just did
164:44 - it's saying that anyone can read and
164:46 - write
164:47 - to our firestore database as long as the
164:50 - time stamp of the request is within a
164:53 - month so for the next 30 days
164:54 - anyone can view edit or delete data in
164:57 - our database
164:58 - and again we're going to put the same
164:59 - location
165:02 - perfect so now we have our two products
165:04 - set up firestore
165:05 - and storage i wanted to spend just a
165:08 - couple minutes
165:08 - describing how cloud storage and cloud
165:11 - firestore
165:12 - work together in order to allow the user
165:14 - to create a custom memory game in our
165:16 - application
165:17 - this is the most critical part and most
165:19 - complicated part of our application
165:21 - so when the user creates a new memory
165:23 - game they're going to pick various
165:24 - images from their phone
165:26 - and each of them will be stored inside
165:28 - of cloud storage
165:29 - and when we successfully upload
165:32 - something into cloud storage we're going
165:34 - to get back
165:34 - a url which defines how we can retrieve
165:38 - that image later on
165:40 - so once we have a list of image urls for
165:43 - each
165:44 - photo that the user wants to attach into
165:46 - their memory game
165:47 - we're going to then take those list of
165:48 - image urls and
165:50 - upload that or push that to cloud
165:52 - firestore along with the associated key
165:55 - so for example in this case we have a
165:57 - memory game called
165:58 - corgi and corgi will have four unique
166:01 - images
166:02 - associated with that which is how we're
166:03 - getting eight memory cards and that will
166:04 - live in cloud firestore
166:06 - and so now when another user somewhere
166:08 - in the world wants to play
166:10 - this game this corgi game they can type
166:12 - that in to
166:13 - the memory game app and we will pull
166:15 - down
166:16 - all the images from firestore associated
166:19 - with corky and that'll be a list of four
166:21 - different image urls
166:22 - then that's how we'll be able to allow
166:24 - the user to play this custom game called
166:26 - corgi
166:27 - so the complexity here is due to the
166:30 - fact that
166:31 - uploading these images is an
166:32 - asynchronous operation
166:34 - so there are two kinds of programming
166:36 - one is asynchronous programming and the
166:38 - other is synchronous programming
166:39 - so most of the operations that you might
166:41 - be familiar with are probably
166:42 - synchronous
166:43 - for example if you're doing two plus two
166:44 - or any kind of simple arithmetic in
166:46 - kotlin
166:46 - or if you're combining strings those are
166:48 - synchronous operations
166:50 - in the sense that when you execute that
166:52 - you can
166:53 - expect a result immediately however what
166:56 - we're dealing with here
166:57 - is asynchronous which means that when we
166:59 - execute the operation
167:00 - we will not immediately find out whether
167:02 - it succeeded or failed because it might
167:04 - take
167:05 - a longer amount of time image uploads
167:07 - are a good example because images are
167:09 - inherently quite data rich there's going
167:11 - to be a lot of data
167:13 - and uploading that over the internet
167:14 - anything you do with the internet is
167:16 - going to require more time
167:17 - and so we're going to start the upload
167:19 - process on all the images that the user
167:21 - has picked out for their custom memory
167:23 - game in this case where
167:24 - the user has picked out the corgi game
167:26 - and we're going to start uploading all
167:27 - of them
167:28 - into cloud storage and the tricky thing
167:29 - is that the rate at which
167:32 - these images get uploaded it's not in
167:33 - our control so for that first image
167:36 - it might be halfway done uploading the
167:38 - second image might be totally not
167:40 - uploading
167:40 - and so on for the third and fourth we
167:42 - might have a different rate of uploading
167:45 - so the question now becomes how can we
167:47 - figure out
167:48 - when all of these operations have
167:50 - succeeded so we can record
167:51 - the image url corresponding to each
167:54 - image that we've uploaded
167:56 - and the way we'll do this is by getting
167:58 - notified
167:59 - when each image has successfully been
168:01 - uploaded so as soon as the image reaches
168:03 - cloud
168:04 - storage we will get a corresponding
168:07 - download url for that image and we'll
168:10 - track how many download urls have we
168:12 - received and the size of that list of
168:14 - download image urls is equal to the
168:16 - number of images that we're uploading
168:17 - then we know we're done and so we're
168:19 - going to continue this upload process
168:21 - until we get to this state which means
168:23 - that all the images have
168:24 - finished uploading and now
168:28 - we will have a list of image urls for
168:31 - each
168:32 - of the four corgi images that we have
168:34 - we're going to combine that
168:35 - with the custom game name which is
168:37 - called corgi
168:39 - and that is what we're going to send to
168:40 - firestore that is what we're going to
168:42 - implement
168:43 - at least partially in this segment
168:46 - so let's go back into android studio
168:50 - the first thing we'll do is get a
168:52 - reference to firebase storage and
168:54 - virastor so at the very top of the file
168:56 - call in the library that we included
168:58 - makes it super easy let's say private
169:00 - val
169:01 - storage is equal to firebase dot storage
169:06 - and then private val db which represents
169:11 - firestore
169:12 - [Music]
169:15 - and so going back now to
169:19 - where we have defined this image byte
169:20 - array our goal is to
169:23 - upload these into firebase storage the
169:26 - way that works
169:26 - is we're going to define a file path on
169:28 - where this image should live in firebase
169:30 - storage
169:36 - and i want this file path to actually be
169:39 - dependent on
169:40 - the game name so if you ever wanted to
169:43 - look at this
169:43 - from the firebase console it'll be easy
169:45 - to tell which images
169:47 - belong together so custom
169:50 - game name let's define this
169:56 - as et gamename.txt
170:02 - and then inside of that directory let's
170:06 - specify the current time in milliseconds
170:09 - dash the index
170:13 - [Music]
170:14 - and then this will be a jpeg file
170:17 - based on the logic that we wrote in get
170:19 - image by array and so the idea here is
170:21 - that
170:22 - if i have four images for example in the
170:25 - corgi game then that'll be saved in
170:28 - images slash corgi slash the current
170:30 - time in milliseconds
170:32 - dash zero one two three because there
170:35 - are four images
170:36 - this is a nice way to combine all the
170:38 - images associated with one memory game
170:43 - so now we have exactly what we need to
170:45 - upload the
170:46 - image to storage we have a file path and
170:49 - the actual underlying data for this
170:51 - image so we'll get a reference to the
170:52 - location of where we want to save this
170:54 - photo which will be
170:55 - storage.reference.child with that file
170:56 - path that we defined
170:57 - and we'll put the image better data at
170:59 - that location
171:01 - all right so this is the operation which
171:02 - will actually do this expensive work of
171:05 - uploading the bytes representing the
171:08 - image
171:08 - to firebase storage and so instead of
171:11 - getting the result of this
171:13 - as some return value here
171:16 - we will instead get a task which we have
171:19 - to now wait for
171:21 - until it succeeds or fails and so the
171:23 - way we can
171:24 - do this is we're going to say continue
171:26 - with task
171:28 - and what that means is this is an api
171:30 - defined by firebase which says
171:33 - this is a long running operation once it
171:35 - concludes
171:36 - then i want you to execute this code and
171:39 - i want you
171:40 - to also execute one more task so we're
171:43 - going to define what that is
171:44 - at the end but first the result of this
171:47 - put bytes is a photo upload task
171:53 - [Music]
171:56 - and from here we can actually conclude
171:59 - how many
172:04 - bytes were uploaded just to get some
172:06 - more info about what happened
172:08 - so photo upload task dot result
172:13 - and then if it's not null then we can
172:14 - check this bytes transfer field
172:18 - okay and then we have to end this block
172:20 - this lambda block
172:21 - with another task that's why we wrote
172:23 - continue with task
172:24 - and the task we're going to continue
172:25 - with is once this photo has been
172:27 - uploaded
172:28 - now we want to get the corresponding
172:30 - download url
172:31 - photo reference dot download url
172:34 - now you can see how the error went away
172:37 - again getting this download url is going
172:39 - to
172:39 - give us a task and so now we have to
172:41 - wait for the completion of that task
172:43 - and that's an asynchronous operation so
172:45 - in order to get notified of that we'll
172:47 - call
172:47 - add on complete listener
172:49 - [Music]
172:51 - and the parameter here will be the
172:54 - result of this this operation that we
172:57 - just triggered
172:58 - so it'll be called download url task
173:01 - [Music]
173:03 - and the first thing we want to check is
173:05 - did this operation succeed or not
173:07 - so if download url task that
173:10 - is if it didn't succeed then let's log
173:13 - in error
173:19 - and let's also show a toast telling the
173:21 - user failed to upload image
173:23 - if any of the images encountered an
173:25 - error while uploading
173:26 - let's set this as a boolean flag here
173:28 - did encounter
173:30 - error is equal to true so initially this
173:34 - variable is going to be false
173:35 - see about var don't encounter error is
173:38 - equal to
173:39 - false and then if we encountered an
173:41 - error in uploading any of these
173:43 - images then we're going to set that
173:45 - equal to true
173:46 - and if this happens we're going to
173:48 - return do a premature return because
173:50 - there's no point continuing
173:54 - the important thing to realize is that
173:55 - this add on complete list center will be
173:57 - called
173:58 - for every image which is uploaded and we
173:59 - don't control the order in which these
174:01 - are called right
174:02 - and so if this particular image url
174:05 - failed to upload then we'll go into this
174:07 - if block but if some other image upload
174:10 - failed then we wouldn't actually know
174:12 - from here
174:13 - and that's why we actually added this
174:14 - boolean did encounter error
174:16 - so if didn't counter error is true at
174:19 - this point
174:20 - that means that some other image has
174:22 - failed to upload
174:23 - and we again want to just return from
174:25 - the add-on complete listener because
174:26 - there's no point in continuing
174:28 - otherwise we have been able to
174:30 - successfully get a download url
174:34 - so look inside the task look at the
174:36 - result
174:38 - and then cast it to a string and that
174:40 - will give me a url
174:41 - [Music]
174:42 - and at this point now we want to make
174:45 - note of the fact that this image has
174:47 - successfully been uploaded
174:49 - the way we'll do that is by keeping an
174:51 - array of all the images that have been
174:52 - uploaded so far
174:55 - so we'll call this val uploaded
174:58 - image url and that's equal to a mutable
175:00 - list of
175:02 - a string
175:03 - [Music]
175:06 - so down here we'll say uploaded
175:10 - imageurls.add
175:11 - and we'll pass in this download url now
175:14 - let's put a log statement here
175:16 - saying log.i with this tag and we'll say
175:19 - finished
175:20 - upload photo ui
175:31 - so if we think back now to that diagram
175:32 - how do we know when all the images have
175:34 - been uploaded
175:35 - turns out that's pretty easy right
175:36 - because we're keeping a track of all of
175:38 - the images that have
175:39 - succeeded so far in this list all we
175:41 - need to do is check the size
175:43 - of that list so if the size of uploaded
175:46 - image urls
175:47 - is equal to the number of images that
175:49 - the user has picked
175:50 - then we know we're done so we'll say
175:53 - handle
175:54 - all images uploaded
175:59 - so this is in some sense the success
176:01 - callback for the images having been
176:03 - uploaded
176:03 - and from here in this method we're going
176:05 - to pass in
176:06 - the game name and the uploaded image
176:09 - urls and this is exactly the information
176:11 - that we need
176:12 - if you remember to upload into firestore
176:14 - so that's what we're gonna
176:16 - handle later on uploading these two key
176:19 - pieces of information into firestore
176:22 - let's rename the parameters here to be
176:23 - image urls and game name
176:28 - [Music]
176:30 - alright that was some pretty heavy logic
176:33 - to think about
176:34 - and implement let's test it out and see
176:36 - if it works
176:41 - so one thing i want to do is right now
176:43 - we're launching the create activity with
176:45 - the medium size board which requires me
176:47 - to upload nine images that's too much
176:49 - for me
176:50 - i'm feeling lazy so i'm going to change
176:52 - this to be
176:53 - the easy board size rear on the app
176:57 - so we only have to upload four images
176:59 - now instead of nine
177:01 - let's tap on one of these images and
177:02 - let's grab
177:05 - these three so now we have one more to
177:07 - upload
177:08 - so let's get this panda picture
177:12 - okay so we still can't save the game
177:13 - because we haven't given it
177:15 - a name yet so let's say testing
177:17 - [Music]
177:19 - okay so now because we've added a valid
177:21 - game name now the save button is enabled
177:24 - and this
177:24 - tapping the save button is what will
177:26 - trigger these images to be
177:27 - uploaded into firebase storage let's try
177:31 - it
177:32 - and before i hit save i'm going to open
177:33 - up logcat
177:36 - and as we upload images we should see
177:40 - this log message
177:42 - in the creativity for the number of
177:45 - bytes that are uploaded
177:48 - along with the progress the status of
177:51 - how many images have been uploaded so
177:53 - far let's let's
177:54 - see if we can see those
178:00 - okay awesome so we can see that we
178:04 - have sporadically these log messages
178:06 - let's filter for create activity because
178:08 - that's all we really care about
178:11 - so you can see how the original width
178:13 - was a certain dimension and the scaled
178:15 - width is
178:15 - smaller because we're restricting the
178:17 - height to be 250 db this is logic that
178:19 - we wrote from before
178:20 - now we have four images that we're
178:22 - uploading so you can see we have four
178:24 - we're seeing this uploaded bytes log
178:25 - message four times which is great
178:27 - and as we upload each image
178:30 - we can see that the num uploaded goes up
178:32 - each time
178:34 - awesome so now to validate that this
178:36 - properly worked
178:37 - let's go back into the firebase console
178:41 - and check um firebase storage we don't
178:43 - expect anything to change in
178:44 - firestore but in storage we should
178:46 - hopefully have
178:48 - one extra directory in storage
178:51 - for this game and that's what we see
178:54 - exactly here
178:54 - so we have a directory called testing
178:57 - and this should
178:57 - have four images they're all prefixed by
179:00 - the current time milliseconds followed
179:02 - by the index which is what we have here
179:04 - and if you look at the preview we're
179:06 - seeing exactly what
179:07 - we had uploaded which is really
179:09 - promising
179:12 - awesome that looks really good and you
179:14 - can see kind of the rough size this is
179:16 - around 14k
179:18 - 4k and about 2.7 k so this is
179:22 - really pretty small so we're not
179:24 - actually eating up
179:25 - too much of the storage capacity in
179:27 - firebase storage and it's also going to
179:28 - make our app
179:29 - feel a lot faster because we're
179:31 - downloading less data as well and here's
179:33 - what the image looks like
179:34 - in the browser in the next segment we'll
179:37 - finish off the missing link of taking
179:38 - the image urls that we have
179:40 - along with the custom game name and
179:41 - uploading that to firestore
179:45 - so we're now able to upload images into
179:47 - storage but we haven't made the link yet
179:49 - to
179:50 - storing those image urls into firestore
179:53 - so that's what i want to do
179:54 - with you right now so if we open up
179:56 - android studio
179:57 - here's where we left it to do for given
180:00 - this game name and the set of image urls
180:02 - we now want to talk to firestore the way
180:05 - we do this is
180:06 - reference the db object that we have
180:08 - defined above and we're going to put
180:11 - this data into a document firestore
180:13 - organizes
180:14 - its data into collections and documents
180:17 - so all
180:18 - documents have to live in a collection
180:20 - and one document
180:21 - represents one entity in our
180:24 - database so each memory game will be one
180:27 - document and that document is gonna live
180:28 - in a collection
180:29 - which we're going to call games
180:33 - inside of games will be a list of all
180:34 - the custom games that people around the
180:36 - world have created
180:38 - and the parameter here is the path of
180:41 - the document which is basically
180:42 - the name of this document and it'll be
180:44 - game name
180:47 - and here we're going to set the data
180:50 - associated with this game
180:52 - and it'll be very simple all we really
180:54 - want to do
180:55 - is associate the image urls
180:58 - to a key called images images
181:03 - maps to image urls that is the data that
181:07 - we're going to put inside the document
181:09 - now let's get notified when this
181:11 - operation succeeds
181:13 - add-on complete listener and the
181:15 - parameter of this lambda function will
181:17 - be
181:18 - a game creation task which indicates if
181:21 - this succeeder failed
181:23 - so if it didn't succeed game creation
181:26 - task
181:27 - is successful then let's log an error
181:31 - [Music]
181:32 - here
181:39 - and if this happens we'll return early
181:43 - otherwise we have succeeded so we can
181:48 - they successfully
181:51 - created game
181:54 - game name and then in this
181:58 - scenario let's show an alert dialog to
182:01 - the user to communicate to them that
182:03 - they've made the game and let's navigate
182:05 - back now to the
182:07 - main activity and play the game that
182:08 - they just created
182:24 - the user is only going to have one
182:25 - option on this alert dialog which is to
182:27 - tap on the ok button
182:29 - and when they tap on the ok button we
182:32 - want to
182:33 - pass back to the main activity the game
182:35 - name which has been created
182:36 - so i'm going to create an empty intent
182:38 - here and inside of this intent we are
182:40 - going to
182:42 - pass the game name they'll say put extra
182:45 - extra game name
182:49 - pass in the game name and then we'll say
182:52 - set result
182:54 - activity result okay
182:58 - and result data and then finally once
183:02 - we've set that data properly we'll
183:03 - call finish
183:07 - and we're going to show the seller
183:09 - dialog so we should define
183:11 - extra game name and this will be defined
183:12 - inside of the constants
183:14 - file
183:21 - let's import it awesome so let's
183:25 - try this now if we wrote our code
183:27 - correctly that means
183:28 - now we should not only upload images to
183:31 - firebase storage but also
183:33 - to firestore let's grab a couple images
183:41 - here
183:43 - okay so i added four and let's say
183:46 - test two and tap on save
183:53 - okay so after a couple seconds we can
183:55 - see that we have this dialogue pop-up
183:56 - where it says upload complete
183:58 - let's play your game test two so that
184:00 - seems promising let's see if it actually
184:02 - worked instead of firestore so i go back
184:03 - to firestore
184:04 - let's refresh this page and hopefully we
184:06 - should see a new collection called games
184:07 - now
184:08 - yes and we do the document name is test2
184:11 - which is the same
184:12 - as the game name and inside of
184:15 - the document is exactly one field called
184:18 - images
184:18 - and images is an array of strings and
184:21 - each string represents
184:22 - the url for the image so for example i
184:25 - could copy this url
184:27 - open it up and we see one of the images
184:29 - that were uploaded
184:30 - awesome this looks great so there's a
184:34 - couple things i want to improve on here
184:36 - first you might notice that
184:39 - in save data firebase we are grabbing
184:42 - the custom game name
184:43 - based on the edit text and
184:47 - we are unconditionally creating a new
184:49 - game
184:50 - with this data however if another user
184:53 - in the world has already created a game
184:55 - called test2 or testing or whatever it
184:57 - might be then we're going to override
185:00 - that data right so we're going to go
185:02 - into firestore
185:04 - and when we call dot set all the
185:06 - previous data
185:07 - that was inside of that document if
185:09 - there was a previous document that will
185:10 - be overwritten
185:12 - and so what we actually want to do here
185:14 - is
185:15 - check if there already exists a
185:18 - firestore document with this game
185:20 - with this game name so right here the
185:22 - intention of the code that we're going
185:23 - to write
185:24 - is to make a check on firestore and
185:27 - ensure that we're not
185:28 - overriding someone else's data
185:31 - so the consequence of this logic is that
185:33 - once i create a game of a certain name
185:34 - for example
185:35 - abc no one else in the world can create
185:37 - a game with that same name abc
185:39 - and that seems like a reasonable
185:41 - decision to make
185:42 - so here what we want to do is call
185:44 - db.collection
185:46 - i'm going to target the same collection
185:48 - games and check do we have a document
185:50 - with this game name
185:53 - let's get it and that'll be how we
185:56 - figure out whether
185:57 - there is a game or not
186:02 - so the result of this asynchronous
186:05 - operation
186:07 - in this callback is we get a document
186:09 - and now we should just check
186:10 - if the document is null and
186:14 - if the if the document's not null and
186:16 - the data of the document
186:17 - is not null a game with this name
186:19 - already exists in our database and so we
186:22 - should not allow the user to create
186:24 - another game with this name so i'll say
186:26 - alertdialog.builder
186:30 - set title to be name taken
186:34 - set message
186:44 - set positive button okay
186:48 - no show
186:52 - all right otherwise we want to then
186:54 - execute all of this logic
186:56 - that we had from before so i'm going to
186:58 - actually put all that logic into a
186:59 - separate function
187:00 - called handle image
187:08 - uploading
187:10 - so let's create a function here and then
187:12 - let's move
187:14 - the parameter can be called game name
187:17 - and let's move all of this logic
187:23 - into that function
187:31 - we renamed this parameter to be just
187:33 - game name
187:39 - awesome so we added an unsuccessful
187:41 - center we should also
187:43 - add a failure listener in case
187:47 - for whatever reason we were not able to
187:48 - retrieve this document
187:51 - i don't really want to do anything too
187:52 - meaningful here just log and error so we
187:54 - can debug this if this ever happens
188:12 - one more thing that i want to do is as
188:14 - soon as the user taps on the
188:16 - save button then we would like to
188:19 - disable
188:20 - the button
188:24 - and the reason i want to add this button
188:26 - dot
188:27 - is enabled is equal to false as soon as
188:29 - the user
188:30 - starts making the network request is
188:32 - because if the user spams the button
188:34 - they would be attempting to create the
188:36 - same game multiple times which doesn't
188:37 - make sense
188:38 - so as soon as they hit the save button
188:40 - we wouldn't disable it so that no more
188:42 - saves are triggered and if we get a
188:45 - failure
188:46 - then we would like to enable the button
188:48 - again
188:49 - so they can fix this issue and change
188:51 - the name of the game and then they can
188:53 - try saving it one more time and same
188:56 - thing down here actually
188:57 - if there was a failure for some unknown
188:59 - reason like a network error
189:01 - then we'll allow them to retry by
189:03 - setting the
189:04 - button to be enabled again let's try
189:06 - that logic so we already have
189:08 - a game that we just uploaded called
189:11 - test2 so let me grab some images
189:21 - call this test 2 and save it and
189:24 - hopefully we should see an error
189:26 - saying name taken perfect so we say name
189:28 - taken a game already exists with this
189:30 - name
189:30 - name two please choose another okay and
189:33 - now we have the
189:34 - save button enabled again and we can try
189:36 - changing it to be test three
189:38 - and now hopefully this should work so
189:40 - you can see while the image upload is
189:41 - happening
189:42 - the button is disabled so the upload is
189:45 - complete
189:45 - and now we can go back to firestore and
189:49 - now we have test three here
189:50 - with these four images that we uploaded
189:54 - great the last thing i want to do in
189:56 - this segment is i'd like to give the
189:57 - user
189:58 - some visual indication of how much
190:01 - progress has been made
190:02 - in uploading these different images
190:04 - because this operation could take some
190:06 - time especially if you have
190:07 - the hard version of the memory game so
190:09 - you have 24 cards or 12 unique images
190:11 - uploading 12 images
190:13 - could take a while and so it'll be nice
190:16 - to provide the user some feedback on how
190:18 - many
190:18 - images have been uploaded already and
190:21 - this turns out to be
190:22 - fairly straightforward we can open up
190:24 - activity create
190:26 - and what i like to do is drag out a
190:28 - horizontal progress bar
190:30 - let's actually create some distance with
190:32 - the save button
190:33 - so i'm going to change this to be
190:37 - 150 dp from the bottom just so we can
190:39 - create a bit more space
190:41 - and now let's drag this out
190:44 - and i want the save button to be
190:46 - anchored to the top
190:48 - of the progress bar so
190:52 - get rid of that constraint and have this
190:54 - be referred to the top there
190:57 - and then the progress bar should be
191:00 - match constraint for the width and then
191:02 - we'll set the left constraint to be zero
191:04 - from the left end of the screen and also
191:06 - zero from the right end of the screen
191:07 - well it shouldn't be zero dp it should
191:09 - have some margin so let's have
191:10 - maybe a margin of 16 from the left and
191:12 - right end of the screen
191:15 - and also 16 dp from the bottom
191:23 - awesome that looks good so now as soon
191:25 - as we hit the save button we want this
191:26 - progress bar to show up
191:28 - and that will be the visual indicator to
191:30 - the user of how much
191:32 - how many of the images have been saved
191:34 - the one thing here
191:35 - is that the progress bar should only
191:37 - show up when this upload is in progress
191:40 - so initially it should be not visible at
191:43 - all and so for that
191:44 - i'm going to go into the progress bar
191:46 - and change the visibility to
191:48 - gone and the other way you can do this
191:50 - is if you
191:52 - tap on that progress bar element and the
191:54 - search for
191:55 - visibility you can change it to gone
191:57 - right here
191:59 - cool let's give this progress bar an id
192:01 - of
192:02 - pb uploading copy the id because
192:06 - we'll need that we'll need it for the
192:07 - create activity
192:10 - so let's go over here and
192:15 - call it pb uploading and this is a
192:17 - progress bar
192:20 - all right let's define that right here
192:26 - okay so now we have the progress bar as
192:29 - soon as the upload starts
192:31 - then we want to set the progress bar to
192:33 - be visible
192:35 - so where does that happen um in save
192:37 - data firebase
192:38 - what we're doing here is checking if the
192:40 - game name
192:41 - is unique so let's we're not going to
192:43 - set the progress bar to be visible here
192:45 - but as soon as we start uploading images
192:47 - that's when we want to
192:48 - set it equal to visible so i'll say
192:52 - pbuploading.visibility is equal to
192:54 - view.visible and here
192:58 - if we encounter an error then we want to
193:00 - set the visibility to be
193:02 - gone again because we'll we'll we won't
193:05 - make any progress at this point
193:06 - view dot gone
193:10 - and the interesting thing happens
193:11 - whenever we have successfully uploaded
193:13 - one image so right here is a success
193:15 - case
193:16 - we want to update the progress of the
193:18 - progress bar
193:20 - i'll say uploaded image urls dot size
193:24 - divided by the total number of images
193:27 - that we need to upload
193:28 - so for example in the hard version of
193:30 - the memory game we have 12 minutes to
193:32 - upload and we might have uploaded
193:33 - maybe six of them so far so that would
193:35 - be 50 progress
193:37 - so this progress requires
193:41 - some integer but the integer should be
193:43 - something between
193:44 - 0 and 100 and so right now this will
193:47 - always be
193:48 - 0 because we're doing integer division
193:49 - which will lead to truncation so in
193:51 - order to get
193:52 - something between 0 100 we're just going
193:53 - to multiply by 100.
193:55 - now the only thing left to do is let's
193:57 - set the
193:59 - prog the visibility of the progress bar
194:01 - to be gone
194:02 - when we're totally done with everything
194:05 - so when we get to the
194:06 - success case of all images uploaded and
194:08 - we've uploaded this to firebase as well
194:14 - right here we can set the view to gone
194:16 - again
194:18 - and actually i think it makes sense to
194:19 - do this even before we check if the
194:22 - game creation task is successful or not
194:23 - because once we've gotten into here
194:25 - we're no longer doing any network
194:27 - operations so we should set the progress
194:28 - bar to be gone
194:30 - okay let's try it
194:33 - so in order to make it a little bit more
194:35 - visible let's go back
194:36 - and choose the medium version
194:40 - of the game just to have more images to
194:42 - upload
194:43 - and let's pick all six of these images
194:47 - now we have three more to pick let's
194:50 - pick the three over here
194:54 - and then let's call this large test
194:57 - tap on save awesome so we see a progress
195:01 - bar and you can see how it's slowly
195:03 - making progress
195:04 - to upload each of those nine images so
195:06 - that's pretty cool
195:07 - and then we get the progress bar gets to
195:09 - the very end then
195:10 - shortly after that once firestore has
195:13 - informed us that it has successfully
195:14 - received the data
195:15 - then we show this dialog upload complete
195:18 - so tap on okay and then we go back to
195:20 - the main activity
195:21 - just to confirm this one more time now
195:22 - we do have in firestore
195:24 - this large test and it will have nine
195:26 - images instead of four
195:27 - because that's how many images we were
195:29 - uploading
195:32 - so now that we were done with the
195:34 - creation flow
195:36 - in the main activity that hack that we
195:38 - had earlier
195:39 - to automatically navigate there let's
195:42 - remove that
195:44 - after the creation activity is launched
195:46 - from here
195:47 - then we're calling start activity for
195:49 - result
195:50 - and so what we're going to do in the
195:51 - next segment is figure out the result
195:54 - passed back from the creativity
195:56 - and if it's successful and we have a new
195:58 - game created we would like the user to
195:59 - play that custom game
196:01 - now the user is able to create a brand
196:03 - new customized
196:04 - memory game our goal in this
196:08 - segment is to be able to allow the user
196:10 - to play that game
196:11 - in the main activity in the main screen
196:13 - and so we launched the creation flow
196:15 - with the start activity for result
196:17 - so we're going to capture the
196:20 - result of whatever the tile activity has
196:21 - done the creation activity
196:23 - in the on activity result method
196:26 - [Music]
196:28 - what we'll do first is just check if the
196:30 - request code
196:32 - is equal to the request code that we
196:35 - launched this with which is create
196:36 - request code
196:38 - and if the result code
196:43 - is equal to result code activity dot
196:46 - result okay
196:51 - so if that's the case then let's
196:54 - retrieve the custom
196:56 - game game name
196:59 - out of the data intent parameter
197:04 - so get string extra extra game name and
197:06 - so you'll remember
197:07 - the reason i'm i'm doing this is because
197:09 - in the create activity
197:11 - as soon as the operation to create the
197:14 - game is done then we
197:16 - set the extra game name to be the newly
197:19 - created game
197:19 - so that's what we're retrieving right
197:21 - here in the main activity
197:23 - if for whatever reason the custom game
197:25 - name is null then something has gone
197:27 - wrong
197:27 - and we'll just log that as an error
197:30 - [Music]
197:34 - and we'll return early otherwise we know
197:36 - the custom game name is not null so we
197:38 - have a valid game
197:39 - i would like to create a method called
197:42 - download game
197:43 - with this custom game name
197:47 - let's create this function
197:51 - and the idea of this function is to
197:53 - query firestore
197:54 - retrieve the corresponding set of image
197:57 - urls and use that to play the game of
197:59 - memory
198:00 - instead of our default icons so at the
198:02 - top of the file
198:03 - we need a reference to firestore similar
198:06 - to what we had in the create activity
198:09 - so right here i'll say private val
198:12 - db is equal to firebase top firestore
198:17 - and let's also capture the value of the
198:20 - game being played so it'll be private
198:23 - var game name
198:24 - [Music]
198:26 - is a nullable string and it's initially
198:28 - going to be null because when you're
198:29 - playing a default game with just the
198:30 - icons that we've predefined
198:32 - there is no game name um it's only set
198:35 - when the user is playing either their
198:38 - own custom game or a custom game made by
198:40 - someone else
198:44 - so back in the download game method
198:46 - we're going to query firestore
198:49 - inside of the game's collection that's
198:50 - where everything lives and we're going
198:52 - to try and retrieve
198:53 - the document called game name
198:57 - let's get it and then that operation
199:00 - might take some time this is
199:01 - asynchronous call
199:02 - so we're going to add a on success
199:04 - listener
199:07 - and we also will need to add a failure
199:09 - listener and then this
199:11 - this is easy but it's going to kind of
199:13 - log this so we can
199:14 - keep track of um
199:18 - what happened
199:19 - [Music]
199:25 - okay so in the success case here is
199:28 - where we're doing something interesting
199:30 - we are going to get back a document
199:32 - which has
199:33 - one field in that document which is
199:35 - called images and that will
199:36 - correspond to a list of image urls a
199:39 - list of string
199:40 - and so that mapping of taking this
199:43 - document which is what we're going to
199:44 - get back here
199:45 - and turning that into a kotlin data
199:47 - class is something that firestar will
199:49 - help us with so we'll say document.2
199:51 - object
199:52 - and we want to map this to a data class
199:54 - that we're going to define
199:55 - and i'm going to call it user image
199:58 - list
200:02 - like that so let's define this now
200:04 - create class
200:05 - and i want to put it into the
200:09 - models directory that we already have
200:12 - and this is going to be a data class
200:15 - there's no body the only thing that we
200:17 - really need to define here
200:19 - is the field name of what this entity or
200:23 - this data class will hold and there's
200:24 - only one which is called images
200:26 - so it'll be val images
200:30 - and it's going to be a list of string
200:34 - and it's going to be nullable and the
200:35 - reason it's nullable is because firebase
200:37 - mandates that every time you do this
200:38 - kind of mapping
200:40 - between a document you get back from
200:42 - firestore and into a
200:44 - data class it needs to have a default
200:46 - value and so it's going to have a
200:47 - default value of null
200:50 - and one other thing that we should do is
200:52 - annotate this
200:53 - field with a property property name
200:56 - i'll say property name
201:01 - images this is how firebase will know
201:05 - that
201:05 - here's the key called images which is
201:07 - defined over here
201:09 - and it maps to this attribute which is a
201:12 - list of string
201:15 - cool so back in my activity now that
201:17 - we've done this document.2 object
201:19 - we will get back a val
201:23 - user image list
201:27 - if user image list is null or if the
201:30 - images attribute of user image list is
201:32 - null then something has gone wrong
201:33 - and the shorthand for this is to do user
201:36 - image list question mark dot
201:38 - images so i want to log this as an error
201:43 - invalid custom game
201:46 - data from firestore
201:52 - let's also put a snack bar here to just
201:54 - message this out to the user
201:57 - cl root
202:04 - and then this is the error case so where
202:06 - it's going to return
202:07 - early here okay so if you've gotten past
202:10 - this return statement
202:12 - if you've gotten past this if block that
202:14 - means that we have found
202:15 - a game successfully so now we want to
202:17 - reset up
202:18 - the recyclerview with this custom data
202:22 - so first off let's compute how many
202:24 - cards are in our memory game
202:26 - so val num cards is equal to user
202:31 - imagelist.psy.images.size
202:33 - times two so for example if there are
202:35 - four images
202:36 - inside of our image list that means that
202:38 - the total number of cards should be
202:39 - eight because we're making pairs
202:41 - so now given that we have eight cards we
202:44 - can now figure out
202:45 - the board size the board size has to be
202:48 - one of the enums that we've defined over
202:50 - here it has to be either
202:51 - easy medium or hard and what we know is
202:53 - we know the value so we need to figure
202:54 - out
202:55 - how to take the value 24 and map that to
202:57 - hard 18 maps to medium and eight maps to
203:00 - easy
203:00 - and the way we're going to do this is by
203:02 - adding a companion object
203:04 - inside of the enum called fun
203:07 - get by value and just as the name
203:10 - implies
203:11 - based on the value that we pass in here
203:13 - which is an integer
203:15 - we're going to return one of these three
203:17 - enums
203:20 - so we'll say the body of this function
203:23 - is going to be a one-line function we're
203:25 - going to look at all the values
203:27 - of this enum through this method called
203:29 - values and we're going to find the first
203:31 - one
203:31 - among this
203:34 - such that the number of cards in that
203:37 - enum is equal to
203:38 - the value
203:44 - so this is a nice cute one-liner and the
203:47 - reason this is valuable is now
203:48 - we can set the property board size from
203:50 - before
203:52 - based on the number of cards so the
203:55 - number of cards
203:57 - and we can also set the game name to be
203:59 - the game name defined here
204:03 - this actually leads to some naming
204:05 - conflict so i'm going to rename
204:07 - this local variable to be custom game
204:10 - name
204:14 - and now it won't be ambiguous that i'm
204:15 - trying to set
204:17 - the property game name to equal the
204:19 - local variable game name
204:21 - okay and so now there's a complaint here
204:23 - board size value of requires a string
204:25 - but the actual is a
204:27 - int oh it should be get by value
204:31 - okay the next thing we want to do
204:35 - is call this method setup board
204:38 - but setup board has to actually now have
204:41 - information about
204:42 - what is a list of image urls right and
204:43 - we're not actually saving that inside of
204:45 - any property so let's add that as a
204:47 - property now
204:49 - i'm going to add one more private member
204:52 - variable
204:52 - called
204:55 - custom game images and this is going to
204:58 - be a list of
205:00 - string and it'll be nullable because in
205:02 - the default case
205:03 - this list will always be empty right it
205:06 - doesn't make sense to have
205:07 - a list of image urls when we're just
205:09 - playing with the default icons
205:11 - so we're going to set this equal
205:15 - right here when we query firestore and
205:18 - get back
205:18 - a list of images so this is going to be
205:20 - equal to user
205:22 - image list dot images
205:25 - so now let's go into setup board and
205:28 - actually start using
205:29 - the custom game images variable that we
205:33 - have
205:33 - along with the game name
205:36 - the objective here is we want to prefer
205:40 - using the custom image list if it's
205:43 - there
205:44 - over the icons because that means that
205:46 - the user is explicitly intending to play
205:48 - this custom game
205:50 - so the change we're gonna make is we're
205:51 - gonna pass in the
205:53 - custom game images as a constructor
205:56 - parameter on the memory game
205:57 - so let's add this as a parameter
206:00 - [Music]
206:01 - hit refactor and we're going to call
206:04 - this custom images
206:08 - [Music]
206:12 - and here the memory cards that our
206:14 - memory game is going to contain
206:17 - will depend on whether custom images is
206:20 - set or not
206:22 - so if it's not set so if custom images
206:26 - is equal to null that means we'll just
206:27 - do what we've already been doing
206:30 - which is to look at the default icon
206:32 - list grab some icons out of those
206:34 - and create memory cards out of them
206:35 - however if
206:37 - custom images is not null then the
206:39 - memory cards
206:40 - should instead be using the image urls
206:44 - as the underlying picture of that memory
206:48 - card
206:49 - so we're going to say val randomized
206:52 - images
206:54 - is equal to custom images and we're
206:56 - going to get
206:57 - two copies of each image in that list
207:02 - then randomize it and now
207:05 - the list of memory cards is going to
207:07 - equal
207:09 - randomizedimages.map
207:11 - and we're going to create a new memory
207:13 - card for each of these
207:17 - so one thing you'll notice here is
207:18 - there's an issue which is that
207:20 - this randomized images here is a list of
207:22 - string
207:23 - that makes sense because each element is
207:25 - an image url which is a string
207:27 - but memory card if you remember the
207:29 - first parameter
207:30 - is a identifier which represents the
207:33 - image resource
207:34 - the drawable resource and we don't have
207:37 - that in the
207:38 - case of a custom game so what we're
207:40 - going to do is add
207:41 - one more constructor parameter called
207:44 - image url
207:45 - and this is going to be of type string
207:47 - and this will be optional
207:48 - because in the case of the default game
207:50 - this is it doesn't make sense to have
207:52 - anything here
207:55 - having the default value of null here we
207:57 - can create memory cards identically to
207:58 - how they were created before
208:00 - but now if we wanted to we can also
208:02 - specify an image url and that's exactly
208:03 - what we're going to do
208:04 - over here and pass in it for the second
208:07 - parameter
208:08 - now the first parameter we need to pass
208:10 - in some identifier
208:11 - which is an integer and so in order to
208:13 - do that we now need to figure out how
208:15 - can we take an image url
208:16 - and turn it into a unique integer and
208:19 - the easy way of doing this is by using
208:22 - a method called hashcode this is
208:23 - something that's defined on every single
208:24 - object including strings
208:26 - and the idea is that for two different
208:28 - strings the probability of them having
208:30 - the same hashcode
208:31 - is very very small it's almost
208:34 - impossible
208:35 - and so by having it.hashcode we're just
208:38 - basically
208:39 - taking the string whatever it might be
208:40 - and translating that into an integer and
208:42 - that will be
208:43 - our new memory card it's almost done in
208:46 - the memory
208:47 - board adapter now
208:51 - this is where we are actually rendering
208:53 - that drawable
208:55 - from the default list of icons that
208:57 - happens right here
208:58 - we're saying image button dot set image
208:59 - resource so if the card is face up
209:02 - we are setting the image resource to be
209:04 - that drawable resource
209:06 - otherwise the background however in this
209:08 - case we don't want to do this
209:09 - right in the case of a custom game image
209:11 - if there is
209:12 - a image url on the memory card we would
209:15 - instead of setting an image resource we
209:17 - want to actually download that image
209:19 - from that url
209:20 - so in order to download an image and
209:22 - show it into
209:24 - an image view there are a couple
209:25 - libraries on android which makes this
209:28 - super easy and the one that we're going
209:29 - to use is called picasa so if you use
209:31 - google for
209:32 - android picasa github you'll come to
209:33 - this page and what
209:35 - you should do is scroll down to the
209:36 - download section and copy this line
209:38 - implementation now add this
209:42 - line into the build.gradle which is
209:43 - located in the app module
209:46 - tap on sync now
209:50 - and going back into memory board adapter
209:51 - now we can use picaso
209:54 - to render the image at that image url
209:57 - inside of this image button
209:59 - so the logic will be if the memory card
210:01 - is face up
210:02 - [Music]
210:04 - then we should check is the
210:08 - image url of this memory card not equal
210:11 - to null
210:12 - if it's not null that means that there
210:14 - is a valid custom image
210:16 - at this memory card that we should be
210:18 - rendering instead of a
210:20 - resource identifier so we'll call
210:22 - picasso
210:25 - so we're going to import that dot get
210:28 - and we're going to load in the image url
210:32 - into the image button that's how simple
210:36 - it is to use picasso
210:38 - otherwise we're going to do what we had
210:41 - before
210:42 - which is image button dot set image
210:44 - resource
210:45 - on the memory card identifier and this
210:48 - is going to be one of the icons that we
210:50 - had created
210:53 - if the memory card is face down then
210:55 - we're going to go into this else branch
210:56 - and then we're going to do we're going
210:59 - to set the
211:00 - launcher background so just just that
211:05 - all right so we just wrote a lot of code
211:07 - hopefully it all makes sense let's try
211:08 - it out try it out
211:09 - i'm going to run the app and we're going
211:11 - to create a new game
211:13 - and save it and then when we save it
211:15 - we're going to come back into the main
211:16 - activity and hopefully we'll be able to
211:19 - play this new custom game that we
211:20 - created so i'm going to
211:22 - create a custom game make it easy so we
211:25 - don't have too many images to upload
211:27 - and let's
211:31 - do this the four images here
211:35 - and say play game as the name
211:38 - tap on save
211:43 - all right so we can see the progress bar
211:44 - upload complete so now
211:46 - we should be going back into main
211:47 - activity and main activity
211:49 - should at that point fetch all these
211:52 - image urls from firestore and display
211:54 - them
211:54 - in the memory game let's see if it works
211:57 - so now it all looks identical to what
212:00 - was there before because right now
212:01 - everything is face down
212:03 - but when we flip over a card you can see
212:06 - hey it actually downloads this image
212:07 - that we had which is amazing
212:09 - i got lucky with a match on the first
212:11 - one
212:14 - okay so this is working so we're able to
212:16 - download the images
212:17 - from this custom game and we can play
212:20 - the game like normal
212:21 - so the logic of figuring out which two
212:24 - images are the same
212:25 - works because the hash code of these
212:27 - images
212:28 - if they're the same image should be the
212:30 - same so that logic
212:31 - is all identical to what we had from
212:34 - before
212:36 - awesome so we won and we have the same
212:38 - logic there from before
212:40 - all right so to finish off there are two
212:41 - really quick things i want to do
212:43 - back in main activity so first off
212:47 - in the setup board method one thing that
212:49 - would be nice
212:50 - is as soon as we call setup board if
212:52 - there is a custom game which the user is
212:54 - playing
212:55 - we should change the title of this
212:58 - to be the name of the game rather than
213:01 - the default my memory so in this case
213:03 - we should hopefully have seen play
213:05 - underscore game
213:06 - as a title instead of my memory and we
213:09 - can do that pretty easily
213:10 - just by saying support action bar dot
213:12 - title
213:13 - and set this equal to game name
213:17 - and the game name might be null so in
213:18 - the case that it is null
213:20 - then we want to set it equal to the name
213:23 - of the app
213:24 - it's r dot string.app name that's one
213:27 - thing i wanted to do
213:28 - second thing i wanted to do is a bug fix
213:29 - so right now one thing you'll notice is
213:31 - that
213:31 - if we create a new default game of a
213:34 - different size
213:36 - we're going to trigger this method show
213:38 - new size dialogue and so
213:40 - if the user is playing a particular game
213:43 - and they
213:44 - create a medium sized game then we're
213:46 - going to call setup board
213:48 - but the issue is that setup board might
213:50 - still be using
213:51 - the cached data the save data inside of
213:55 - game name and custom game images and so
213:57 - basically the the key thing here is we
213:59 - need to reset
214:00 - these values every time the user
214:03 - goes back to a default game so
214:07 - in the show new size dialog right before
214:08 - we set up the board let's just
214:10 - null out the game name and also
214:15 - the custom game images should also be
214:17 - null
214:19 - awesome huge progress in this video what
214:22 - i want to do
214:23 - next is allow the user to enter in the
214:27 - game name that they want to play using a
214:29 - menu option
214:31 - but right now the only way to play a
214:32 - custom game is by creating it and then
214:34 - we immediately will play it
214:35 - back in the main activity so what i want
214:38 - to do here
214:39 - is add one more menu option for
214:41 - downloading
214:42 - an arbitrary custom game so to do that
214:45 - we're going to
214:46 - add a menu option so open up
214:49 - menu main and we're going to add in one
214:52 - more
214:52 - final menu item
214:58 - let's give this a title of
215:01 - download custom game
215:04 - and the id can be mi
215:08 - download it's a menu item download
215:11 - and similar to the other two above it
215:13 - we're gonna
215:14 - have show as actually never so we always
215:17 - want this to be in the overflow menu
215:18 - let's copy the id go back into main
215:21 - activity
215:22 - and register a listener for when that
215:26 - menu item gets tapped so r
215:29 - dot id dot mi download
215:33 - and in this case we would like to call
215:36 - this method show download dialog
215:39 - download dialog and then return true
215:44 - okay let's define this method
215:48 - so i'm going to put this below the
215:51 - functions that were overriding
215:55 - and then i misspelled downloads let me
215:56 - fix that
215:58 - [Music]
216:00 - so this download dialog is going to be
216:02 - simple all it is is
216:04 - the ability for the user to enter in
216:06 - through an edit text
216:08 - the name of the game that they want to
216:10 - download so i'm going to use the layout
216:12 - inflator to
216:14 - inflate that view which has the edit
216:16 - text so i'll take
216:17 - layout inflator from this
216:21 - inflate r.layout.dialog
216:25 - download board
216:29 - null is a second parameter this is going
216:32 - to be
216:33 - a view that we're going to call board
216:35 - download view
216:40 - and the idea is going to be we're going
216:42 - to call that same method that we have
216:44 - show alert dialog the title will be
216:47 - fetch memory game and the view
216:52 - is going to be the board download view
216:54 - that we are about to define
216:56 - and the third parameter is what should
216:58 - happen when the user taps on ok
217:00 - so it'll be view dot on click listener
217:04 - and what we want to do here is grab the
217:06 - value
217:08 - text of the game
217:12 - name
217:15 - so let's first define the dialog
217:17 - download board layout
217:18 - the root element here can be a
217:19 - constraint layout that's fine the only
217:21 - view that we need in our constraint
217:23 - layout will be in edit text
217:25 - and before modifying individual
217:26 - attributes of the edit text directly
217:28 - here
217:28 - one thing to notice is that we're going
217:30 - to be using many of the same exact
217:32 - attributes as the edit text that we
217:33 - showed
217:34 - in the creation flow and so i'm going to
217:36 - open up activity create
217:37 - and we have edit text here i'm going to
217:39 - go ahead and copy all of that
217:41 - go into the code tab of the dialog
217:43 - download board and copy over
217:45 - that same edit text we'll have to add in
217:47 - the app namespace declaration many of
217:48 - the attributes for example the allowable
217:50 - input digits
217:51 - number of max lines input type important
217:54 - for autofill all of that should be
217:55 - identical
217:56 - in this edit text in the edit text in
217:58 - the creation flow but there are a few
217:59 - modifications we'll want to make
218:01 - let's change the margin bottom to be
218:02 - margin top and make it 16 dp
218:05 - let's update the hint to say enter game
218:07 - name so the user knows what to do with
218:09 - this edit text
218:10 - and the constraint bottom doesn't make
218:11 - sense anymore because there is no btn
218:13 - save
218:13 - so i'm just going to say constraint top
218:15 - to top of parent which makes it flush
218:16 - with the alert dialog top
218:18 - finally let's update the id to be et
218:20 - download game
218:21 - now we can grab the edit text from that
218:23 - board download view
218:25 - find view by id with the specified id
218:29 - and now the game to download will be the
218:30 - text attribute of this
218:32 - edit text that will say
218:35 - etdownloadgame.txt.2string.trim
218:37 - and now we can call our method download
218:39 - game with this game to download
218:41 - string okay let's try it
218:46 - run the app and now we should hopefully
218:48 - see one more menu option
218:51 - next we do download custom game and i am
218:54 - going to
218:55 - try out the larger game that we had
218:57 - tried from before large
219:00 - test tap on ok
219:04 - so this is good it's promising because i
219:06 - do remember that we had
219:08 - made the large underscore test game a
219:10 - medium-sized game which means there are
219:11 - 18 cards or nine images that we added
219:15 - and yeah you can see that this is indeed
219:18 - the
219:19 - images that we had uploaded so one thing
219:22 - you'll notice is that there's a little
219:23 - bit of a delay
219:24 - the very first time that we download
219:26 - that particular image
219:28 - it takes a couple hundred milliseconds
219:29 - or maybe even one second
219:31 - and then every subsequent time that we
219:32 - download that same image for example the
219:34 - golden gate bridge
219:35 - subsequent times that we display the
219:36 - image is much faster because picasso is
219:38 - caching that image once we've downloaded
219:40 - it once subsequent times are much much
219:42 - faster to load
219:43 - so that's one optimization i'd like to
219:44 - do which is in the download game method
219:48 - as soon as we're successfully found the
219:50 - game
219:52 - one thing we should do is pre-fetch all
219:54 - the images with with picasso
219:56 - and this makes this is actually it's
219:58 - pretty straightforward i'm just going to
219:59 - say for image url
220:00 - in user image list dot images
220:05 - and i'm going to say picasso
220:08 - dot get and i'm going to just load the
220:11 - image url
220:12 - dot fetch and what this dot fetch is
220:15 - doing is saying hey let's go ahead and
220:16 - even though we're not displaying this
220:18 - into an imageview right away go ahead
220:20 - and
220:20 - download it and fetch it so it's saved
220:22 - in the picasso cache
220:24 - and one other thing i'd like to do here
220:26 - as well actually just
220:28 - show a snack bar to indicate to the user
220:30 - that they're playing this custom game
220:35 - [Music]
220:40 - let's try it
220:43 - so we have a couple games we've uploaded
220:45 - so far large test play game test tune
220:47 - test three let's try
220:48 - maybe test three and one other thing to
220:52 - look for is that the
220:53 - title of the screen in the action bar
220:55 - should also update
220:57 - appropriately let me say this test three
221:01 - okay so we are playing test three we got
221:03 - the snack bar and now you can see
221:05 - that the image images are loading much
221:06 - faster which is a great sign
221:09 - now we can play the game like a normal
221:11 - game of memory one bug you'll notice at
221:13 - the top
221:14 - is the activity action bar title hasn't
221:16 - been updated appropriately
221:18 - so let's debug that if we go into the
221:21 - setup board
221:22 - method that's where we set the title and
221:24 - so it relies on game name and the bug
221:26 - here is that the game name should be set
221:28 - before calling the setup board method
221:30 - so by doing that now that bug should be
221:32 - fixed let's try it one more time
221:36 - so let's try downloading a game called
221:39 - game two
221:43 - oh there is no game two what did we call
221:45 - it
221:47 - test two
221:54 - awesome and so you can see how now the
221:56 - title of this activity has changed to be
221:58 - test two and got that snack bar
222:00 - and we should hopefully be playing this
222:02 - new custom game and now it feels so much
222:04 - snappier so that's great
222:06 - one last optimization i want to make on
222:08 - the picasso side which is that
222:10 - there's still no way to avoid the fact
222:12 - that we might have to
222:14 - spend a little bit of time downloading
222:16 - the image the very first time
222:17 - and so when that happens in the memory
222:19 - board adapter
222:20 - there's a nice functionality in picasso
222:23 - to load a placeholder image
222:25 - while the image url is being fetched
222:28 - and so i would like to add that as well
222:30 - i'll say r.drawable.ic
222:32 - image and so we're going to define one
222:35 - more vector
222:36 - asset which will be kind of the
222:37 - placeholder image a silhouette of
222:40 - an image like a black and white image so
222:42 - let's go into project
222:44 - go into the resources and let's create a
222:47 - new
222:48 - vector asset in the drawable directory
222:53 - called image
222:57 - so we'll call this ic image and
223:00 - yeah let's leave it as color gray and
223:03 - then finish
223:04 - okay so this error went away and let's
223:07 - see
223:08 - if we can actually see the placeholder
223:10 - image so if we're really quick
223:12 - after we download a game then we might
223:14 - be able to see it briefly
223:17 - i'll say large test
223:20 - [Music]
223:24 - yeah and then you might have briefly
223:26 - seen the very first image i flipped over
223:28 - we were able to see that placeholder
223:30 - image and all the subsequent images are
223:31 - much
223:32 - faster to load because we're doing that
223:33 - prefetch operation
223:35 - so that's a really good sign it's a much
223:36 - better experience now
223:39 - before moving on to the next segment
223:41 - which is focused on design
223:42 - and style improvement there's one more
223:44 - small improvement i want to make here
223:46 - which is that if we have this snack bar
223:49 - show up
223:50 - right now there's no way to actually
223:51 - dismiss it and it's not that hard to
223:54 - make the snack bar dismissible and give
223:55 - the user more control over the ui
223:58 - simply by going into the activity main
224:02 - and right now the root element is
224:05 - a constraint layout if we instead change
224:08 - that to be
224:09 - a coordinator layout then any snack bar
224:12 - can then be dismissed by the user so let
224:14 - me do that
224:16 - coordinator layout
224:20 - and then we're going to add a bunch of
224:23 - these properties
224:24 - in the coordinator layout
224:34 - so copy this put it at the end
224:38 - and then i'm going to hit command option
224:40 - l in order to fix the indentation
224:43 - and we also need the layout width and
224:44 - height on the constraint layout of
224:46 - course
224:48 - and this id of cl root we're actually
224:51 - going to apply that
224:53 - onto the coordinator layout so
224:55 - everything else is identical because the
224:57 - only time we
224:58 - were referencing cl group is as the
225:00 - anchor for the snack bar
225:01 - and by making the anchor for the snack
225:03 - bar coordinator layout now the user
225:05 - should be able to
225:06 - dismiss the snack bar with more control
225:08 - let's try it okay it looks like we
225:11 - are crashing and i think i know why yeah
225:14 - the
225:15 - reason is because there's a class cast
225:18 - exception if you go back into main
225:19 - activity
225:21 - you'll remember at the top of the file
225:23 - right now we're
225:24 - defining cl root as a constraint layout
225:27 - but this should actually be a
225:27 - coordinator layout
225:30 - and here clru is finding you by id and
225:32 - that's fine so
225:33 - now let's try it hopefully we won't
225:35 - crash
225:36 - so we are able to boot up properly and
225:38 - if i trigger
225:40 - the snack bar now you can see how i was
225:42 - able to dismiss it
225:45 - in the next part i want to do some low
225:47 - hanging design improvements with all of
225:49 - you
225:50 - and then we'll be done with all of the
225:51 - functionality and design for the whole
225:53 - app
225:54 - in this segment i want to make a couple
225:56 - of very easy but powerful
225:58 - improvements in the app the first one is
226:01 - not so much an improvement but avoiding
226:03 - an issue in the app which is if you
226:05 - rotate the screen
226:06 - so you can see that whenever you don't
226:08 - hit the screen in android the activity
226:09 - is destroyed and recreated
226:11 - and we are not doing a great job with
226:14 - managing
226:14 - the space here our app isn't very smart
226:17 - around
226:17 - when the phone is wider than it is
226:19 - taller the number of
226:21 - columns in the memory grid should be
226:23 - larger but right now we're still
226:25 - assuming this portrait mode where we
226:28 - will always have
226:29 - more rows than we will have columns and
226:32 - so we have two options
226:33 - one is we could actually properly
226:35 - address this
226:36 - and that would require some logic inside
226:38 - of the memory board adapter and figuring
226:40 - out
226:41 - how much space to allocate in the width
226:43 - and height
226:44 - the other option is to do the lazy thing
226:46 - which is not allow
226:48 - the user to change the mode of these
226:51 - activities
226:52 - to be in landscape and that's what we're
226:53 - going to end up doing so if we open up
226:56 - android manifest
226:59 - we have two activities in our app
227:00 - creativity and main activity
227:02 - and we're going to update the
227:05 - screen orientation attribute to be
227:09 - portrait and that's it that's the only
227:11 - valid option
227:12 - [Music]
227:15 - and by adding this line into the android
227:18 - manifest file
227:19 - even if the screen is rotated even if
227:21 - the user rotates their phone
227:22 - then android won't actually go through
227:24 - the activity lifecycle we're not going
227:26 - to be destroying the activity
227:27 - and so we're still looking at the same
227:29 - portrait mode ui even in landscape
227:32 - the two-line solution that we came up
227:33 - with here to lock the orientation in
227:35 - portrait
227:35 - is definitely the lazy solution but i
227:38 - would argue that this is actually
227:39 - a reasonable trade-off to make our job
227:42 - as engineers is about efficiency
227:44 - and so you have to make the decision
227:46 - about how much value are you delivering
227:48 - to users by implementing
227:49 - proper landscape mode in the app versus
227:52 - how much engineering time or developer
227:54 - time would that take and can you use
227:55 - your time better elsewhere
227:56 - you can definitely implement this if you
227:58 - want to learn more but the key takeaway
228:00 - here
228:00 - is thinking about what problem are you
228:02 - trying to solve the
228:04 - second improvement i want to make is i
228:06 - want to add a little bit more
228:08 - festivity when the user wins the game so
228:10 - right now let me quickly see if i can
228:12 - win the game
228:18 - so we just have this snack bar show up
228:20 - u1 congratulations
228:22 - i'd also like to have something a bit
228:23 - more festive and in particular i want to
228:25 - have some confetti pop up
228:28 - and this turns out to be really easy
228:29 - because we can use a library which does
228:31 - this for us
228:32 - so if you go to your browser and just
228:34 - google for android confetti library
228:36 - you'll come up with
228:37 - this github repository and this is the
228:40 - one that we're going to end up using
228:42 - so i'll show you how to use it but right
228:43 - now all you need to do is copy over this
228:45 - line
228:46 - to add this into your build.gradle file
228:48 - which is located in the app module
228:52 - tap on sync now so we can pull this
228:54 - library into our project
228:56 - and now let's go into main activity and
228:59 - let's figure out where do we actually
229:00 - detect that we won the game
229:04 - so as soon as we flip over a card that's
229:06 - the only time when we have the potential
229:08 - to win the game and we have this
229:10 - snack bar that we show up right now so
229:12 - right here is where i'd like to now
229:14 - show this confetti and it turns out that
229:17 - we can do this with
229:17 - literally one line of code i'm going to
229:19 - invoke a static method in the library
229:21 - i'll say common confetti
229:25 - import this and we're going to call this
229:27 - method raining confetti the first
229:28 - parameter here
229:29 - is the container that'll be the parent
229:32 - element on which the confetti should be
229:34 - falling so
229:34 - call cl root and then the next parameter
229:38 - is the
229:39 - colors that you want the confetti to be
229:41 - so i'll say
229:42 - int array of and we're just going to
229:44 - pass in some
229:45 - colors that are already defined for us
229:47 - by the android system
229:48 - and you can kind of pick whatever you
229:50 - like here's the ones i picked
229:52 - yellow green and
229:55 - magenta in order to actually launch
229:58 - the confetti we call this method one
230:00 - shot
230:02 - and that's it let's try it and see how
230:05 - it looks
230:13 - amazing so you can see how this confetti
230:14 - is falling and there's some like
230:16 - particle physics
230:18 - inside of the library some map so that
230:21 - we have
230:21 - some particles some confetti falling
230:23 - quickly some falling slowly and they
230:25 - also will drift side to side
230:26 - so it's a really nice simple way to make
230:28 - the app more fun
230:30 - the next thing i'd like to do is update
230:32 - the color scheme of the app
230:34 - and there's definitely no right answer
230:36 - here you can be creative and pick
230:37 - whatever color you like
230:38 - but what i recommend most people do is
230:41 - go to color.adobe.com
230:46 - and this is a really nice way to pick
230:47 - out a color palette you can kind of
230:49 - take this drag it around and figure out
230:51 - what color scheme you like
230:53 - and if you don't like uh this one which
230:55 - by default is analogous you can pick out
230:57 - one more like monochromatic triad
230:59 - complementary or whatever you want and
231:00 - this
231:01 - gives you a nice working set of colors
231:04 - which we can then use
231:05 - to update our android app we have a
231:08 - couple different colors like the status
231:09 - bar color
231:10 - this action bar color and this
231:12 - background color of the linear layout
231:13 - so those are the colors that i want to
231:14 - update so let's open up the
231:18 - colors.xml file i'm going to add three
231:21 - more colors here
231:22 - first we'll define green dark then we'll
231:24 - have one more called green darkest
231:26 - and then a third one called green blue
231:28 - and you can pick whatever colors you
231:30 - want for this like we talked about
231:32 - here's what i picked for green dark
231:33 - green darkest is a darker shade of green
231:35 - dark
231:35 - and then finally green blue is a teal
231:37 - and you can see a preview on the left
231:39 - hand side
231:40 - now we have to make use of these newly
231:42 - defined colors
231:43 - and we'll do that in themes.xml we'll
231:45 - define color primary to be
231:48 - green dark we'll define color primary
231:51 - variant to be
231:52 - green darkest and notice on line 13 the
231:54 - status bar color
231:55 - is the color primary variant and finally
231:58 - in the secondary brand color
231:59 - category we'll update both the color
232:01 - secondary and color secondary variant
232:03 - to be green blue one more thing i'd like
232:06 - to call out
232:06 - dark mode is all the rage these days and
232:08 - so android studio actually has
232:10 - a separate file themes.xml located
232:13 - inside of values
232:14 - night and so if the app or phone
232:16 - supports dark mode
232:17 - then the colors inside of the
232:19 - values-night themes file will be read
232:21 - instead of the one that we defined
232:23 - just something to keep in mind if you're
232:25 - into that sort of thing
232:27 - let's try our app with these new colors
232:28 - and if we've done our job correctly we
232:30 - should no longer see this purple color
232:31 - at the top we should instead be seeing
232:33 - the palette of green we picked out so we
232:35 - have a green action bar
232:36 - a darker green for the status bar and
232:38 - the bottom the blue green
232:40 - the final design improvement i'd like to
232:41 - make is to change the
232:43 - view of the memory card when it's face
232:45 - down this green grid because it just
232:47 - feels like our app is still under
232:48 - construction
232:49 - and instead use some custom image for
232:52 - the
232:53 - default state so you're welcome to pick
232:55 - whatever image you want for this
232:57 - i'm going to open up the drawable
232:58 - directory and the image that i found i
232:59 - downloaded from the internet
233:01 - is this picture of bamboo so everyone
233:03 - loves pandas
233:04 - therefore everyone should love bamboo
233:06 - i'm going to drag this bamboo.png file
233:09 - into the drawable directory now let's
233:12 - reference this bamboo.png file
233:14 - inside of the memoryboard adapter which
233:16 - is where we are
233:17 - setting the icon when a memory card is
233:19 - facedown
233:20 - so right here on line 65 is where we're
233:23 - setting the image resource
233:24 - if the card is face down and we're going
233:26 - to set this equal to bamboo
233:29 - so let's run the app and see what this
233:32 - looks like
233:34 - perfect so you can see how now we have
233:36 - the bamboo background and we can play
233:37 - the game like normal
233:40 - all right okay so let's try just for
233:42 - good measure let's
233:43 - play the whole game and go through the
233:46 - creation flow as well so i'm going to
233:47 - create a brand new game
233:49 - i'm going to call i'm going to have this
233:51 - be easy i'm going to call this
233:53 - corgi and of course i can't save the
233:55 - game right now because i haven't added
233:56 - the images
233:57 - but let's add our wonderful images of
234:00 - the corgi
234:02 - so i have four images of a corgi here
234:05 - and then let's tap on save
234:10 - perfect it looks like it succeeded tap
234:12 - on okay and now immediately we go back
234:14 - into the main activity
234:15 - and we can see that the title has
234:16 - changed to be corgi and hopefully we
234:18 - should be able to play our game now
234:26 - yay and you can see that okay we have
234:28 - this confetti following we have a snack
234:29 - bar
234:30 - we are recording the number of moves
234:31 - properly and
234:33 - we have this green text showing that we
234:35 - are 100 done
234:36 - and we found all the pairs we can replay
234:39 - the game
234:40 - and this works because we're still
234:42 - holding on to the
234:43 - image url list of all these corgi images
234:46 - and we can play like normal
234:48 - i can also choose a different size so i
234:50 - can pick like a medium sized board
234:53 - and here notice that we are reverting
234:55 - the title back to my memory because this
234:57 - is now playing a default game with
234:58 - default icons
235:00 - and we're also updating the text at the
235:01 - bottom and so now we're playing with the
235:03 - default icons
235:04 - rather than the image urls coming from a
235:07 - user
235:09 - this looks really quite good if you've
235:11 - also gotten this far in the game
235:13 - i would love to hear from you drop a
235:15 - comment and let me know
235:16 - i'll leave you with some extension ideas
235:19 - the really nice thing about the memory
235:20 - game
235:21 - is that there are so many creative and
235:23 - fun ways to
235:24 - extend the functionality of what we've
235:27 - built together
235:28 - so one idea i had was simply to add
235:30 - different board sizes so right now we
235:32 - have three enums representing the
235:33 - different dimensions of the board
235:35 - easy medium and hard we could simply add
235:37 - a couple more enums
235:39 - for different configurations another
235:41 - idea i had
235:42 - was to introduce user authentication and
235:45 - if you allow the user to log in then you
235:48 - have this
235:49 - really nice ability to be able to see
235:52 - all of the custom
235:53 - games all the custom boards that that
235:55 - logged in user has made
235:56 - so you have this notion of history or
235:58 - profile
235:59 - for that user and finally there could be
236:02 - a lot of interesting work around
236:04 - discovery of other people's boards so we
236:06 - could imagine
236:07 - there are hundreds of different custom
236:09 - boards created and i want to see which
236:10 - ones are popular and i could also
236:12 - enjoy playing other people's games so if
236:15 - you do end up doing any of these
236:17 - i'd love to see it drop a link to the
236:19 - published app or the github repository
236:21 - and we can
236:22 - celebrate your app in the next segment
236:24 - we're going to prepare our app for
236:25 - release
236:26 - so i'll walk through a checklist with
236:28 - you about what i typically do before i
236:30 - publish any app on the google play store
236:34 - if you've gotten this far i really hope
236:36 - you're planning on publishing what
236:37 - you've built
236:38 - the app that we have is really full
236:41 - featured and really fun to play with
236:43 - and there's a social aspect as well so
236:45 - in this segment
236:46 - i want to walk through a checklist of
236:48 - some of the things i always think about
236:50 - before publishing any app
236:51 - onto the play store first is the app
236:54 - icon
236:54 - so if we tap on the home button and then
236:56 - swipe up to open up the app launcher
236:57 - screen
236:58 - you can see the app we have here is the
237:00 - default one so of course before
237:02 - publishing
237:02 - we'll want to have a unique app icon for
237:05 - our app
237:06 - my memory you can design the app icon
237:08 - yourself or use a design agency or
237:10 - something like fiverr in order to get a
237:11 - high quality app icon
237:13 - here's what i came up with it's a grid
237:15 - of nine squares of different colors
237:17 - to indicate that there's some sort of
237:19 - pairing or matching going on
237:20 - the main thing to keep in mind with app
237:22 - icon is that you want it to be square
237:24 - and you want to avoid text or anything
237:26 - which is too detailed
237:28 - in the image because users won't have
237:30 - that much time
237:31 - or the ability to see your app icon in
237:33 - hi-res so you want to be very
237:35 - obvious at a glance what your app is
237:39 - so once you have something you're happy
237:40 - with then go into the drawable directory
237:42 - go to new and tap on image asset
237:46 - and this asset studio will help us to
237:49 - create
237:49 - all the different icons that we need
237:51 - depending on the
237:52 - kind of phone that you have so i'm going
237:54 - to tap on path and we're going to choose
237:57 - that icon that we had just created
238:02 - so now you can see a preview of how this
238:05 - icon might look so depending on the kind
238:06 - of phone if you have a samsung phone or
238:08 - a
238:08 - google pixel or something else the icon
238:11 - might look a little different and this
238:12 - is all the different ways
238:13 - that it might be rendered so i'm pretty
238:16 - happy with that
238:16 - so we're going to leave it the layer
238:18 - name as i see launcher foreground
238:20 - tap on next and this is basically just
238:22 - saying that we're going to overwrite
238:24 - the default ic launcher let's tap on
238:27 - finish
238:29 - great and so now if we run the app let's
238:31 - see
238:32 - if we actually have the app icon
238:35 - properly reflected so i'm going to exit
238:37 - the app and go here and you can see
238:39 - it does indeed show our new app icon
238:41 - awesome
238:43 - so that's one thing you want to do the
238:45 - other is enabling
238:46 - minification and proguard if you open up
238:48 - the build.gradle file i can show you
238:50 - what i'm talking about
238:52 - you should have a section in your app
238:54 - level build.gradle file
238:55 - for release and build types and what
238:57 - this is saying is
238:59 - what are the steps of the build process
239:01 - that you want to run
239:03 - on the release build when you actually
239:04 - publish your app you're going to be
239:05 - publishing a release build what we've
239:06 - been doing so far
239:08 - is a debug build by default android
239:10 - studio is going to have this minify
239:11 - enabled
239:12 - option as false in release builds it's
239:14 - important that you turn this on to true
239:16 - and the reason you want to do this is
239:18 - because it will shrink the size of your
239:20 - app so an app which might be 20
239:21 - megabytes
239:22 - with minifi enabled it'll be much
239:24 - smaller than 20 megabytes
239:25 - in my experience the size savings can be
239:28 - more than 50 percent
239:30 - and the reason app size is important is
239:32 - because users often don't have that much
239:34 - space
239:35 - on their phone and also people may not
239:37 - have good connectivity
239:38 - and so a large app may deter them from
239:41 - downloading it
239:42 - from google play and just to demystify
239:45 - this a little bit
239:45 - when you enable minification what's
239:48 - happening is there's something called
239:49 - proguard and proguard will basically
239:52 - look at all the libraries that your
239:53 - project is including
239:55 - and strip out methods that are not being
239:58 - used or not being referenced
240:00 - and through that it's a it's a really
240:01 - nice way to get rid of code and
240:04 - resources which are not
240:05 - are not referenced and reduce the size
240:07 - of your application or of the apk which
240:08 - is generated at the end of the day
240:10 - and that's downloaded onto the device
240:12 - you do want to be a little bit careful
240:13 - with proguard
240:14 - because it's stripping out methods
240:16 - sometimes it's a little bit over
240:17 - eager and it may strip out something
240:19 - which you actually do need in your
240:21 - project and so you want to make sure
240:22 - that you test out your release build
240:24 - properly
240:24 - and make sure there are no issues that
240:26 - come up in the release build
240:28 - that don't happen on the debug build for
240:29 - example one thing i discovered
240:32 - after turning on minification is that i
240:34 - previously didn't have
240:36 - in the user image list i didn't have
240:38 - this property name
240:39 - images in the data class and this
240:42 - actually worked fine in the debug build
240:44 - but when making a release build this
240:46 - caused a crash and so i needed to
240:47 - explicitly add
240:48 - property name images in order for
240:51 - firestore to be able to construct the
240:53 - user image list
240:54 - correctly tip number three is
240:58 - if you want to understand better what
241:00 - your users are doing in the app once you
241:02 - publish it
241:02 - i'd recommend that you integrate
241:04 - firebase analytics
241:06 - and so there's a guide here you can
241:07 - google for but this is a way
241:09 - for you to understand how many users are
241:11 - opening up the app
241:12 - how many users are taking a particular
241:14 - action in the app and you can define
241:16 - what that action might be so that's an
241:18 - option that we're not going to walk
241:19 - through here but
241:20 - if you really want more detailed
241:22 - analytics about
241:23 - how people are behaving then this is a
241:25 - good way to do that
241:28 - one other thing that you want to do for
241:29 - sure is test your app on different
241:32 - phones and different api versions so
241:34 - right now we've only tested our app
241:36 - on this pixel 2 phone which is running
241:38 - api 29
241:39 - but you want to make sure that you test
241:40 - your phone on a tablet if you want to
241:42 - target tablets
241:43 - you want to test it on the most recent
241:44 - api version api 30 for example
241:47 - you want to also go back five or six
241:49 - years and test
241:50 - your app out on a phone which is running
241:52 - api
241:53 - maybe 24 25 and make sure that
241:56 - everything works
241:57 - look in our build.gradle and you can see
241:59 - the minimum sdk version is 21.
242:01 - so you probably want to test a phone
242:03 - running api 21 as well
242:05 - we've only been testing our app right
242:07 - now on emulator it probably is also
242:09 - worth testing on a physical phone if you
242:11 - have one
242:11 - just because that will give you a
242:12 - genuine experience of how real users
242:14 - will interact with your app
242:16 - emulators are great for testing out your
242:18 - phone on very old devices or devices
242:20 - that are physically hard to get a hold
242:21 - of
242:22 - but it's definitely worthwhile to try
242:24 - out the app at least once
242:26 - on a physical phone and the final tip i
242:28 - have
242:29 - is to translate your strings
242:32 - right now we have a bunch of text that
242:34 - we show to the users those are called
242:35 - strings
242:36 - and these strings are all written in
242:37 - english for example here snackbar.move
242:40 - we say invalid move and this is
242:42 - bad practice because if the user is
242:45 - changing the locale
242:46 - of their phone to let's say spanish or
242:48 - hindi or some other language
242:50 - then we would want to be able to
242:52 - translate this text
242:53 - into that language and the way you do
242:56 - this typically
242:57 - is by having all the user facing strings
243:00 - belong in this strings
243:01 - xml file so right now we literally only
243:03 - have one string which is
243:04 - the app name but if you wanted to
243:07 - internationalize your app and have it be
243:09 - popular in
243:10 - countries that are not english speaking
243:12 - then what you'll want to do
243:13 - is move all of these strings out into
243:15 - the xml file
243:16 - and then reference the strings.xml file
243:19 - instead of having hardcoded text
243:21 - and once you have all the strings in an
243:23 - xml file like this
243:24 - you can create an additional version of
243:27 - the strings xml
243:29 - for each language so you'll have one
243:30 - strings xml for english
243:32 - one for spanish one for french one for
243:33 - hindi and so on so
243:35 - there are probably a bunch of other
243:37 - things that you could do to optimize
243:38 - your release
243:39 - and make sure it's successful this is a
243:41 - very quick list of what i typically
243:43 - think about when i publish
243:45 - if you have other ideas or other things
243:47 - on your checklist i'd love to hear
243:49 - what you do let me know in the comments
243:51 - how you think about it
243:53 - at this point not only are we done with
243:54 - the debug version of the app but also
243:56 - the release version which is the
243:58 - optimized version of our app
244:00 - for publishing in the next segment we'll
244:02 - upload our release app to google play
244:05 - and create a listing for our app on the
244:08 - play store
244:09 - the goal for this part is to publish our
244:11 - app on google play which is the dominant
244:13 - android app ecosystem run by google
244:16 - once we do this we can easily share our
244:18 - app with friends and family which will
244:19 - be really
244:20 - fun and you can point to your app in
244:22 - your resume or your app portfolio which
244:25 - will help you in landing a job
244:27 - google makes it relatively quick and
244:29 - easy to
244:30 - become a developer on their platform
244:32 - compared to the apple app store which is
244:35 - the app store for iphones and ipads and
244:38 - there are two
244:39 - big differences between google and app
244:40 - apple here one is that it's way cheaper
244:42 - to become a developer for google
244:44 - it's a one-time fee of 25 to become a
244:47 - google developer
244:48 - compare that to apple which is 99 every
244:51 - year
244:52 - so that actually adds up really quickly
244:54 - on the apple side whereas google is much
244:55 - much cheaper
244:57 - and the second reason that it's easier
244:58 - to become a developer with google
245:00 - is because the review process for
245:03 - publishing an android app is much
245:04 - lighter compared to apple
245:06 - the google's process for reviewing our
245:08 - app is largely automated which means
245:10 - that the turnaround time is a lot faster
245:12 - whereas apple will have a real-life
245:14 - human manually check your app
245:16 - and you might be rejected if your app is
245:19 - deemed low quality or if it's doing
245:20 - something
245:21 - that apple doesn't like and so there's
245:23 - been a lot of articles talking about
245:25 - the pros and cons of each approach i
245:26 - would say that the
245:28 - average app quality on apple is going to
245:31 - be higher because
245:32 - they actually do reject quite a few apps
245:34 - and they have a higher quality standard
245:36 - but the diversity of apps on google play
245:38 - is way higher with more than two million
245:41 - published android apps and that's
245:42 - because google accepts most of the apps
245:44 - that are submitted to the play store
245:46 - and the other impact of the automated
245:48 - review system of google is that the
245:50 - iteration speed
245:51 - is a lot faster so with apple you might
245:54 - have to wait
245:54 - more than a week in order to get a
245:56 - review and get your update published
245:58 - but with google as you make improvements
246:00 - those updates will go out faster
246:02 - to the end user so we're going to spend
246:05 - a lot of time
246:06 - in the google play console in order to
246:08 - create a new app and
246:09 - update it with all the information but
246:11 - before we do that there are
246:12 - two pieces of prep work that i want to
246:14 - do one in the emulator and one in
246:16 - android studio
246:17 - so first in the emulator this is where i
246:18 - want to spend a few minutes just taking
246:20 - some screenshots
246:21 - of the app so the way you can do that is
246:23 - ctrl s on a pc
246:24 - or command s on a mac so we can just
246:27 - take one of the home screen
246:28 - why don't we take a screenshot with some
246:30 - of the cards flipped over
246:32 - let me try and get a match
246:36 - well that looks good let's do one more
246:37 - screenshot here maybe we can do a
246:39 - different size
246:42 - for a couple
246:48 - and then maybe we can also include a
246:50 - couple of the creation flow
247:00 - and then finally maybe we can show folks
247:03 - that they can download a custom game
247:12 - okay awesome so those have now been
247:14 - saved by default they're going to be
247:15 - safe at the desktop
247:16 - we're going to use those later when we
247:18 - create our google play listing
247:20 - so the next thing we'll do is open up
247:22 - android studio and we're going to create
247:24 - a release bundle from android studio and
247:27 - that'll be what we upload to google play
247:28 - if you go into the menu go to build and
247:30 - tap on generate signed bundler apk
247:33 - you have two options here an under app
247:35 - bundle or an apk
247:36 - so the android app bundle is recommended
247:38 - because it's a newer file format that
247:39 - google was pushing
247:40 - and you can kind of think of it like a
247:41 - zip file which contains
247:43 - other files inside of it and in
247:44 - particular it contains the compiled code
247:47 - for your project
247:48 - plus the resources and it lets google
247:50 - play
247:51 - create an optimized apk that users will
247:53 - get on their device and so depending on
247:55 - the kind of device
247:56 - and the screen size and other things
247:59 - google play will optimize
248:01 - what code and resources needs to be
248:02 - downloaded by that user and that results
248:04 - in a smaller download size
248:05 - so i want to pick android app bundle tap
248:07 - on next and here we need to
248:10 - create a key store and this is
248:13 - a key store is basically a way that
248:14 - google can validate the authenticity of
248:17 - the developer
248:18 - and so i'm going to choose the location
248:21 - as the desktop
248:23 - then i'll give this a name of keystore
248:26 - dot chaos and then provide a password
248:29 - and make sure you keep the summary
248:30 - secure because if you lose this
248:32 - you're going to have to create a brand
248:33 - new app on google play rather than
248:35 - updating your existing app
248:37 - [Music]
248:40 - same thing with the key you need a alias
248:44 - we'll leave as the default key 0
248:46 - use some password here
248:50 - and then for the certificate i'm just
248:51 - going to put my first and last name
248:53 - and that's all we need for now
248:56 - of course my passwords don't match let
248:58 - me try this one more time
249:01 - [Music]
249:03 - okay seems like that worked tap on
249:05 - remember password just so that
249:07 - as we make changes in the future we
249:09 - don't have to keep typing all this
249:10 - information again
249:12 - tap on next and then we want a release
249:15 - version of the app
249:16 - and so our app is fairly small so this
249:18 - building of the release
249:19 - app shouldn't take too long but if you
249:21 - have a larger app this can certainly
249:22 - take
249:23 - several minutes all right so it looks
249:26 - like we are able to generate the signed
249:27 - bundle so i'm going to locate it
249:31 - shows up over here and so you can see
249:33 - here the aab file is 2.5 megabyte and
249:36 - that's pretty good
249:36 - it's a pretty small app and keep in mind
249:39 - that this is an upper bound of the size
249:40 - because the aab
249:42 - is essentially a zip file and google
249:44 - play will optimize
249:45 - what apk generates for the user's device
249:47 - so 2.5
249:48 - megabytes is an upper bound on the size
249:50 - of our apk
249:52 - so what i have over here are all the
249:55 - screenshots that we took so i'm going to
249:56 - drag over the aab file into this
249:58 - directory
249:59 - and this is now everything we need in
250:01 - order to create a
250:02 - good google play listing so let's go
250:05 - back now
250:06 - to google chrome and go to the google
250:09 - play console
250:10 - i'm going to create a new app we'll
250:13 - update this with a bit more detail later
250:14 - on but just for now i'm going to call it
250:15 - my memory
250:16 - the default language is english us it's
250:18 - going to be a game this is a
250:20 - free app and then we're going to agree
250:23 - to
250:24 - a couple of policies and then tap on
250:26 - create app
250:29 - all right so google play here will walk
250:31 - you through a bunch of different
250:33 - questions and policy things that you
250:35 - need to answer
250:36 - and then after we do that then we're
250:38 - going to upload our aab
250:43 - the first is app access in our case
250:46 - everything is available without special
250:47 - access there's no such thing as logging
250:49 - into our app
250:50 - let's go back to the dashboard let's go
250:52 - to ads we have no ads
250:58 - content rating we need to fill out a
250:59 - questionnaire i'll put in my email
251:01 - address
251:02 - our app is a game tap on next
251:10 - all right the only thing that we have to
251:11 - answer yesterday is actually this
251:12 - question because the app does natively
251:14 - allow users to exchange content
251:16 - through sharing images that's if you
251:18 - create a new memory board and someone
251:20 - downloads that that's one way for users
251:22 - to interact with each other so we tap
251:23 - answer yes on that question but we can
251:26 - answer no
251:26 - on all of these
251:30 - all right and then if you look through
251:32 - you can see the rating that we
251:34 - got in our app it looks like as expected
251:36 - our app is
251:37 - pretty friendly for everyone submit
251:40 - let's go back now and see what else have
251:42 - we not done all right so the next is the
251:45 - privacy policy so every app has to have
251:47 - a privacy policy and typically what i
251:49 - recommend for this is if you don't want
251:50 - to go through the hassle of setting up
251:51 - website
251:52 - just create a google doc which describes
251:55 - the privacy policy and paste that in
251:57 - i put that together over here and i can
251:59 - actually link this if you want to
252:00 - copy a similar privacy policy i
252:04 - basically took this as a template from
252:05 - some other app
252:06 - it just describes the app and how we're
252:09 - using some google services
252:10 - so i'm going to copy this make sure it's
252:13 - accessible to anyone with the link
252:16 - paste that in click tap save
252:20 - and then target audience we are going to
252:22 - target anyone 13 and up
252:24 - if you target people less than 13 there
252:26 - are some other compliance rules that i
252:27 - want to deal with
252:28 - around targeting kids tap on next
252:32 - and then our store listing will not
252:34 - intentionally unintentionally appeal to
252:37 - children
252:37 - so tap on no there and then we're done
252:40 - with this section
252:41 - tap save all right and then
252:44 - it seems like we have one more section
252:45 - here is our app a news app and there's
252:47 - no
252:49 - all right so we have completed all the
252:52 - questions about
252:53 - the app content that's great so now
252:55 - let's
252:56 - actually go into the store listing i'm
252:59 - going to the main store listing
253:01 - and there's a couple things that are
253:03 - required anything with asterisks is
253:04 - required
253:05 - regarding metadata about our app like
253:07 - things that are describing
253:09 - our app so i have a
253:12 - note over here where i spent some time
253:14 - putting together a
253:16 - name description and full description
253:18 - [Music]
253:20 - so i'm putting in a name of my memory
253:22 - image matching game
253:24 - and the app name is actually really
253:26 - really important because that's how
253:28 - google play will figure out when to
253:30 - surface your app for
253:31 - search queries on google play and i have
253:34 - a friend
253:34 - alex who wrote a really good article
253:36 - about how to think about naming your app
253:38 - and it really comes down to two things
253:41 - number one
253:42 - know what people are searching for in
253:43 - order to try and find your app
253:45 - and number two put those words that
253:47 - people are searching for in the title of
253:48 - your app
253:49 - and so i'm basically guessing that if
253:51 - people want to download our app they're
253:53 - going to be searching for
253:54 - things like memory or image matching or
253:56 - game and that's what i've put
253:58 - in the title one thing you can do is if
254:00 - you're publishing the same app
254:02 - i'd love for all of us to be able to
254:04 - find each other and try out the
254:05 - different versions of the app that
254:06 - people have built
254:07 - so just put your name here
254:10 - [Music]
254:12 - so that way anyone else who's looking
254:14 - for this particular app they can find it
254:17 - by they can find out who made it by
254:19 - looking at the last section of the title
254:23 - and this this topic of seo or search
254:26 - engine optimization is a huge topic
254:28 - you can read a lot about how do you game
254:30 - that and how do you make sure that your
254:31 - app
254:32 - gets the best chance of being surfaced
254:34 - i'll leave a link to alex's article if
254:35 - you want to learn more about that
254:38 - so short description is um something
254:40 - which is 80 characters or less
254:42 - so what i did for that is this
254:46 - a free customizable memory game on
254:47 - android match pairs images
254:50 - and then the full description can be a
254:51 - little bit more uh robust and long
254:55 - so i'm not going to read it all right
254:56 - now but basically what i'm describing is
254:58 - that this is a
254:59 - totally free open source app it's
255:02 - customizable memory game um
255:04 - there are no ads and i'm documenting
255:06 - some of the main features here
255:10 - all right so the next thing is graphics
255:12 - there are two required graphics one
255:14 - which is the app icon and one which is a
255:15 - feature graphic so the app icon has to
255:18 - be 512 by 512.
255:20 - um these pixels are exact so it can't be
255:22 - even one pixel off and then the feature
255:24 - graphic has to be 1024x500
255:26 - and so what i recommend you do for this
255:28 - is open up a program like sketch
255:32 - let me show you what i've done here are
255:34 - all of the assets that
255:36 - we use for the memory game here's the
255:38 - app icon which is 512x512
255:40 - and for example if you wanted to create
255:42 - the feature graphic you can
255:43 - insert a rectangle in sketch and then
255:45 - update the dimensions as appropriate so
255:47 - we'll want it to be 1024 wide
255:49 - and 500 tall and then you can kind of
255:52 - play with this however you want change
255:53 - the color add in some shapes add in some
255:54 - images
255:55 - and then once you're happy with what you
255:58 - have then you can export both the icon
256:00 - and the feature graphic
256:01 - let's come back into the google play
256:04 - console and we will drag and drop
256:06 - our feature graphic and app icon so for
256:09 - the feature graphic
256:10 - let me show you what i put together
256:14 - so just a picture of the corgi just
256:16 - because that's kind of the
256:17 - main custom game that we've created uh
256:19 - with
256:20 - this same color scheme of the app
256:24 - drag that over and then while that's
256:26 - uploading i'm going to also upload the
256:27 - app icon
256:29 - and so what i did for that is what you
256:31 - already saw
256:32 - just this grid of squares
256:33 - [Music]
256:36 - and so now both the app icon and feature
256:38 - graphic are updated
256:39 - and finally we get to the phone
256:41 - screenshots so i'm going to go back
256:43 - to this directory where we have all the
256:46 - screenshots
256:48 - and drag those out
256:51 - okay that looks good and you can have up
256:52 - to eight screenshots minimum of two
256:54 - and there are some really fancy things
256:55 - that you can do to make these look a
256:57 - little bit better
256:58 - like having some sort of colored
256:59 - background or combining two of the
257:01 - screenshots into a continuous
257:03 - shot but we're going to leave it simple
257:05 - for now
257:07 - we are going to ignore the tablet
257:09 - screenshot so let's basically
257:11 - reuse the phone screenshots same thing
257:14 - with the 10 inch
257:14 - and we don't have a video for now tap on
257:17 - save
257:19 - so now we have the basics for our main
257:21 - store listing
257:22 - we're going to go into the release
257:24 - section go into production here's where
257:26 - we're going to create
257:27 - a new release and just one thing i'll
257:29 - mention we're not going to deal with it
257:30 - currently but
257:31 - there is an option here for testing your
257:33 - app before you do a broad production
257:35 - rollout so you have open testing as an
257:36 - option or closed testing
257:38 - and also internal testing these are
257:39 - basically various options to
257:41 - allow you to test out your app with a
257:43 - trusted set of users
257:44 - in your company or with friends and
257:45 - family or just have an open beta program
257:48 - prior to releasing it publicly we're not
257:51 - going to deal with any of that just to
257:52 - keep it simple
257:53 - so i'm just going to go into production
257:54 - track and create a new release
257:57 - and we're going to use app signed by
258:00 - google tap on continue
258:03 - and then we're going to drag and drop
258:04 - our aab or android app bundle
258:07 - so i'm going over here drag dragging
258:10 - that
258:10 - the release name can be initial release
258:13 - [Music]
258:16 - and then release notes i'm just going to
258:17 - leave as the default tap on save
258:21 - all right that looks good one thing that
258:22 - we'll need to do is specify which
258:24 - countries
258:26 - we want to release our app to so tap on
258:28 - this add countries and regions and i'm
258:29 - going to go ahead and select all of them
258:32 - so we're going to add all 151 countries
258:34 - then we're going to go back to releases
258:37 - tap on edit and then go to reviewed
258:40 - release
258:42 - it looks like we have some errors all
258:44 - right so it says that our app can't be
258:45 - published yet complete the
258:46 - steps listed in the dashboard so let's
258:49 - see what did we miss in the dashboard
258:53 - so we have to specify an app category
258:54 - let's do that we are a game
258:57 - and in particular we are a puzzle game
259:00 - let's just quickly add a tag called
259:02 - memory
259:03 - [Music]
259:06 - apply that now we'll leave our email
259:08 - address and opt
259:09 - into external marketing and hit save so
259:12 - now let's go back into the production
259:14 - release section
259:15 - go into releases tap on edit
259:18 - and let's see if we are able to properly
259:22 - release this now okay amazing
259:25 - so we have set up our store listing
259:28 - properly we've done all the
259:29 - questionnaires all the
259:30 - policy agreements and we can see the
259:33 - internet bundle and then we'll hit this
259:35 - button for start rollout to production
259:37 - so the review process might take a
259:39 - little bit longer
259:40 - now because of chronovirus and and the
259:43 - lack of
259:44 - staff but my experience historically has
259:46 - been that still
259:47 - with a simple app like this we should be
259:49 - able to get a review
259:51 - and have it approved within two or three
259:53 - days
259:54 - hey everyone welcome back the my memory
259:57 - app that we submitted to google play
259:59 - just got approved into the store so what
260:01 - i want to do
260:02 - in this segment is walk through the
260:04 - google play listing
260:05 - along with doing a quick concept review
260:07 - of everything we've talked about to get
260:08 - to this point
260:09 - and then we will celebrate so here's the
260:13 - store listing it's pretty much what
260:15 - you'd expect the app
260:16 - icon and the title are what we submitted
260:19 - into the google play console
260:21 - it shows the developer name here along
260:23 - with on the right side more
260:24 - apps by that developer so i have two
260:26 - other apps live in the play store which
260:27 - you can see here
260:28 - we have the category of the app
260:29 - screenshots description
260:31 - and then when we get reviews those will
260:33 - show up over here
260:35 - this section what's new is about release
260:37 - notes for subsequent versions of the app
260:39 - you can leave a message
260:40 - to users about what has changed and the
260:42 - magical thing about software
260:44 - is that it's so easy to change to
260:46 - iterate and to improve
260:48 - so i actually already made one
260:50 - improvement in the app which is i added
260:52 - a couple more colors
260:53 - into the dark theme so that the app will
260:55 - render better
260:57 - if your phone is using dark mode so i
261:00 - would encourage you not to view
261:01 - publishing your app into the play store
261:03 - as an ending point but instead a
261:05 - starting point where now you can make
261:06 - a bunch more improvements in terms of
261:09 - features or designs
261:12 - at the bottom we have additional
261:12 - information for example when was the app
261:15 - updated
261:16 - how large is the app 2.3 megabytes how
261:18 - many installs does it have
261:20 - and also requires android 5.0 and up and
261:23 - this is coming from
261:24 - the minimum api version of 21 in our app
261:27 - and it tells
261:28 - users how recent does their android
261:30 - phone have to be in order to download
261:32 - this app
261:33 - so the really cool thing about having
261:35 - this app published is now we can take
261:37 - the url
261:38 - and share that with anyone in the world
261:40 - and they can very easily
261:41 - download this application my memory on
261:44 - their phone and tablet and play
261:47 - one of the core features that we built
261:48 - into the app is the ability to create
261:50 - your own custom memory game
261:52 - using photos from your phone so you're
261:54 - already familiar with the
261:55 - corgi game that we used during the video
261:58 - walkthrough for
261:59 - the creation flow i also have one called
262:01 - bitmoji which is my bitmoji character
262:03 - doing different things
262:04 - and then one more you can try out is the
262:07 - board game i created called rao which is
262:09 - pictures of me is doing various
262:11 - activities
262:12 - so if you also have a funny or creative
262:14 - custom
262:15 - memory game with your own photos drop a
262:18 - comment and i would love to play it out
262:20 - one more note on the topic of publishing
262:22 - from the time that i submitted the app
262:24 - until it got approved by google it was
262:26 - about three days i'm not really sure
262:28 - what the standard is given cova 19
262:30 - if you had a much shorter review time or
262:32 - much longer i'd love to also hear from
262:34 - you
262:34 - the last thing i want to do in this
262:36 - segment is a review of everything we've
262:38 - covered
262:39 - so there's a ton of really fundamental
262:42 - concepts that we've
262:43 - learned that you can now apply to
262:44 - whatever else you want to build
262:46 - we created a brand new android studio
262:48 - project so we started from scratch
262:50 - and then the main ui of our application
262:54 - is built on top of the recycler view
262:57 - and the interesting thing is that the
262:58 - contents of that recycler view will be
263:00 - dynamically measured based on the screen
263:02 - width and height
263:04 - we also started thinking about how do we
263:06 - use models to represent the different
263:09 - objects in the memory game the memory
263:11 - card and memory game
263:13 - and this is going toward the direction
263:14 - of app architecture so we didn't
263:16 - explicitly
263:17 - talk about different kinds of app
263:19 - architectures but basically app
263:20 - architecture means how do you organize
263:23 - your code and so by using
263:24 - the recyclerview and using the memory
263:27 - card
263:27 - memory game we have already better idea
263:31 - of how to partition up the logic so it's
263:33 - easier to debug and extend our
263:35 - application
263:37 - and we also integrated with two firebase
263:39 - services storage
263:40 - and firestore for the creation flow and
263:43 - finally we were able to publish our app
263:45 - into google play and we talked about
263:47 - some of the best practices there
263:49 - so here is the same picture cloud
263:52 - representation that i showed you in the
263:53 - very beginning
263:54 - of all the different things we learned
263:56 - we made a brand new android studio
263:57 - project so you're
263:58 - definitely familiar with android studio
264:00 - now we talked about how to
264:02 - create vector icons and use that as a
264:04 - default memory card
264:05 - we talked about views on android and how
264:07 - they have content padding and then
264:09 - margins live outside the view and we
264:10 - take that into account
264:11 - when creating the view width and height
264:16 - the recycler view is the core component
264:18 - which is
264:19 - responsible for displaying that grid of
264:21 - memory cards we talked about how there's
264:22 - a layout manager which
264:24 - puts things in the grid the adapter
264:26 - which is responsible for binding
264:28 - a view in the recycler view to the
264:30 - underlying data set
264:31 - which is a list of memory cards we also
264:34 - are uploading images to cloud storage
264:37 - and we're using cloud firestore as
264:39 - the database which is associating the
264:41 - game name to a list of image urls
264:44 - and then finally like we just talked
264:46 - about we are now live
264:48 - in the google play store so the result
264:51 - of all that work
264:52 - is this where we are able to create
264:55 - a custom game with these very cute
264:57 - corgis
264:58 - we won the game and we have confetti
264:59 - falling and we have that message at the
265:01 - bottom
265:02 - and furthermore anyone in the world can
265:05 - now
265:06 - download our app from the play store and
265:08 - play play this game as well
265:11 - throughout the whole process if you have
265:12 - any questions or feedback
265:14 - i would love to hear from you i'm on
265:15 - twitter youtube and linkedin
265:17 - and instagram at rponde1234 so i'd love
265:20 - to connect with you
265:22 - and as you share the progress of what
265:25 - you're building
265:26 - or if you have a really funny or cute
265:29 - custom memory game
265:30 - um please use this hashtag mymemory in
265:32 - social media that way we can all see
265:34 - the progress we are all making and
265:36 - giving encouragement or feedback
265:38 - to people all right that's all i had for
265:40 - this project
265:41 - i hope you had as much fun building out
265:43 - this project as i had teaching it
265:45 - if you want to help me out hit that like
265:47 - button and subscribe so you can become
265:49 - part of this
265:50 - learning community until next time i
265:53 - hope you're all staying safe
265:54 - and i will see you in the next one bye