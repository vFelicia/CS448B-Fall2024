00:00 - This course is a detailed introduction to system design for software developers and engineers. Gaurav Sen developed this course.
00:08 - He is an experienced software engineer and he also has a popular YouTube channel.
00:13 - You will learn about basic engineering design patterns that are used to build large-scale distributed systems.
00:19 - In the second part of the course you will learn how to use the principles from the first part 
00:23 - to design and code a live streaming video app.
00:27 - Hello everyone.
00:27 - Welcome to the System Design course.
00:30 - This course is for beginners in a
sense that if you have never done
00:33 - system design before or you have done
very little system design or you have
00:37 - just heard of it or read about it,
but not got an opportunity to actually
00:40 - do it, this course is right for you.
00:42 - At the end of this course, you'll be
able to identify some basic engineering
00:46 - design patterns, which are used to
design large scale distributed systems.
00:50 - Let me define each of
these terms in detail.
00:54 - Large scale distributed systems,
as the first part of the term, says
00:59 - large scale, meaning that something
which is being used a lot or is very
01:04 - intensive in terms of compute or data
or any, computer engineering principle.
01:10 - For example Google, let's say Google Maps.
01:14 - This is large scale because
A: it has a lot of data.
01:18 - The whole world's map has
to be stored, incited.
01:21 - B: it's being used by a lot of people.
01:23 - C: it's being updated very
frequently, and b, it has a lot of
01:28 - performance expectations from it.
01:30 - You don't expect Google Maps to go down.
01:32 - You expect Google Maps to
return results quickly.
01:35 - You expect it to be
accurate, so on and so forth.
01:38 - So it's a very good product
being used at a large scale.
01:41 - Distributed systems means that the server
or the code that is actually executing
01:47 - this program is not in one place.
01:49 - It's disputed all around the world.
01:52 - So you might have one server in
India, one server in the us, one in
01:55 - Japan for tolerance, so that if one
of these servers crashes, the rest
02:00 - of the servers can take the load.
02:01 - It's also for performance.
02:04 - If the Indians want a Google Map result,
they go and talk to the Indian server
02:08 - because that gives a quick result back.
02:10 - While if they go to the US server, they
have to go across continents and then
02:14 - get a response, which is a slow result.
02:17 - Okay?
02:17 - So that's the point of a large
scale distributed system.
02:20 - Many of these companies which
provide these solutions, Expect
02:23 - their engineers to know about system
design, to know how to build these
02:26 - large scale distributed systems.
02:28 - So to do this, their engineering
team depends on design patterns,
02:32 - which we mentioned earlier.
02:33 - Design patterns are particular practices,
principles, or processes which are used
02:39 - by engineers to build these systems.
02:41 - For example, you have a common
problem of a celebrity posting on
02:47 - social media and that post being
distributed to a lot of their followers.
02:52 - For example, if Brad Pitt posts
something on YouTube and then post on
02:55 - LinkedIn, the problem is very similar.
02:58 - It's one piece of content which has
to be made into an event and notified
03:03 - to millions of people potentially.
03:05 - And what you want to do is you want to
notify them quickly, but you also don't
03:09 - want to put too much load on your service
so that the rest of the requests, which
03:12 - are coming into it continue being served.
03:14 - This is a common problem, so you
extract out a common problem and you
03:19 - solve it using a common solution.
03:21 - , this would be a design pattern.
03:23 - Right now, you don't know what design
patterns exist, but one popular design
03:27 - pattern for this kind of a problem is
a publisher subscriber model where Brad
03:32 - Pit is a publisher and their event is
subscribed to by millions of people.
03:37 - And Intermediately decides the pace at
which you send these notifications, which
03:42 - keeps the server loaded low, and also
make sure that all the notifications
03:46 - actually reach all the subscribers.
03:47 - Now, seeing this, you can tell that as an
engineer you can take a lot of business
03:51 - requirements and convert them into
technical solutions, and engineers use
03:54 - system design patterns to make reliable,
scalable, and maintainable systems.
03:59 - This helps them convert business
requirements into technical solutions.
04:02 - If this sounds exciting to you,
watch's the rest of the video
04:05 - and you won't be disappointed.
04:15 - Okay, let's start with an example.
04:17 - Let's say that you join a company
which does broadcasting of
04:21 - videos to millions of people.
04:23 - This could be Hot Star, it could
be YouTube, it could be Zoom also.
04:28 - So some sort of events which are
being broadcast to millions of people.
04:33 - And you as an engineer have to devise
the solution for this, come up with some
04:38 - technology which can handle this problem.
04:40 - So the first thing that we need to
do as engineers is to define these
04:44 - requirements from the user's perspective.
04:48 - And often engineers don't do this.
04:51 - They're product managers and a company
which write a product requirement
04:54 - document based on user feedback and data.
04:58 - So that's good to have.
05:00 - You have a well documented, thought
business banked document, which the
05:07 - engineer can then read and decide
on how they can make it happen.
05:11 - Amongst these, you pick up the
most important features first.
05:15 - Taking the example of a live streaming
system, users who tune into your system
05:19 - should be able to watch the stream live.
05:21 - Whether you see it at HD quality or you
see it at four 80 p, that's probably
05:25 - a secondary issue, but being able
to see the video is a primary issue.
05:30 - So for that, you have to make sure
that your server doesn't go down, and
05:33 - you have to also make sure that your
bandwidth requirements are sufficient.
05:36 - Second, you reduce these
features to data definitions.
05:41 - So one of the features which might be
defined is users should be able to like a
05:45 - video or should be able to like a comment.
05:48 - What you then do is you look at
the concept of a, like the abstract
05:52 - concept of somebody liking something.
05:54 - What does that mean?
05:55 - It means that a particular user
likes a particular comment.
06:00 - Okay, so it has a like id, it
has a user ID who's done this.
06:03 - It has a timestamp.
06:04 - When was this video liked or
when was this comment liked?
06:07 - The comment itself is an abstract concept.
06:09 - It's probably going to
be mapped into an object.
06:11 - It has an id, it has a user
who has typed this comment.
06:13 - It has a creation time and maybe it also
has a thread in which it was posted.
06:20 - So you're seeing that I'm taking features
or I'm taking these abstract concepts
06:24 - from the product requirement document and
converting them into data definitions,
06:28 - which are used, useful for an engineer.
06:31 - These definitions can then be
mapped into objects, which can
06:34 - then be mapped into the database.
06:36 - Once you've defined the data that
you need to store, you need to
06:39 - define endpoints through which this
data can be manipulated or queried.
06:45 - So I want to read comments, give me an
API and sgp api ftp API for all WeCare.
06:52 - The network protocol at this point
is not important, but some method
06:55 - by which I can send an electronic
signal from one place to our server,
06:59 - and our server can respond to that
signal with the data that they need.
07:03 - So our server is now encapsulating
this data as per the user
07:07 - requirement and defining some
endpoints, which are called APIs.
07:11 - So that external users can
query and manipulate our data.
07:14 - We do this for every feature that
we have, core features and also
07:19 - optional or good to have features.
07:21 - Usually a product requirement
document does not define optional
07:24 - or good to have features.
07:25 - These are all core features which
are required in the document.
07:29 - The good to have features will
be probably picked up in the next
07:31 - document, so you don't need to think
of which features are optional,
07:36 - but you do think of which features
are most important as an engineer.
07:40 - The second thing is you also have
certain engineering requirements.
07:44 - When you're creating these designs or
coming up some code, you want to make
07:49 - sure that none of your services fail
If there is an outage, so for example,
07:54 - if you have an outage in India and your
common service is in India, then you
07:59 - don't want the entire system to collapse.
08:01 - We talked about this a little
earlier, that you have multiple
08:04 - server spread across the world to
avoid a single point of failure.
08:08 - . You may also have multiple
servers in India itself.
08:12 - So if one Indian server fails, another
one picks up its responsibility.
08:17 - So here you might have some sort
of data duplication because of
08:20 - which the other server is quickly
able to pick up the responsibility.
08:23 - Or you have some sort of partitioning
that 50% of the users are going
08:26 - to this server, 50% of the users
are going to another server.
08:30 - So just 50% of the users are affected
under the common and often missed
08:33 - out engineering requirement is
extensibility, which means it's not
08:37 - just about the technical solution
that you come up with, but also how
08:42 - easy it is to change that solution.
08:45 - For example, if you write code to
send a message to millions of users,
08:50 - and you need to make a small tweak to
that code because now you don't want
08:54 - to just send it to 1 million users.
08:55 - You also want to check whether
they have read those messages.
08:59 - So read
08:59 - receipt.
09:00 - The problem
09:02 - with writing code, which is
highly coupled with the feature.
09:05 - Is that whenever there's a changing
requirement, you have to put in a
09:09 - lot of effort to redesign, test,
and actually deploy that code again.
09:15 - So you want your features,
your engineering features.
09:17 - To be extensible for this, you
have to take out your engineering
09:20 - pistol ball and gaze deeply
09:22 - into it.
09:23 - Actually what
09:24 - you do is, as an experienced
engineer, especially, you look back at
09:27 - your past projects you look
09:30 - back at things that you have done,
you look back at things that people
09:33 - have done.
09:34 - You know what
09:35 - the world is doing.
09:36 - And based on that combined knowledge,
you build a system so that you can
09:42 - reasonably expect it to scale and
extend as requirements change and as
09:46 - more and more users join you, finally
this design needs to be tested.
09:50 - This is an important part
of system design, which is
09:52 - not really thought through
09:55 - in interviews, but in the real
world, when you have a system
09:59 - which is designed by, let's say a
10:00 - senior engineer that design
10:02 - has to
be tested.
10:03 - You run through
10:05 - a couple of requests with edge
10:08 - cases, with common
cases, and whether these
10:12 - requests are having a sensible
flow in the system at a high level.
10:17 - The other thing that you can do is you
can use sophisticated tools to load test
10:21 - this design.
10:22 - You can have
10:23 - some sort of capacity estimation
to actually see whether this design
10:26 - is feasible, but importantly, you
have to test this design before
10:30 - you start getting into the code.
10:32 - Okay.
Let's recap with an example.
10:35 - Let's say we have a live streaming system.
10:37 - How would we go about designing this?
10:40 - Requirements would be streaming
video, processing video, sending
10:45 - video to multiple customers.
10:47 - So that is
broadcasting not failing
10:50 - is a requirement.
10:51 - Showing advertisements, allowing
reactions, showing disclaimers
10:56 - or news flashes, having graceful
degradation of video quality
11:00 - in case you have low bandwidth,
allowing multiple device support.
11:03 - and so on.
11:04 - Amongst these, you'll see that
the product requirements are
11:07 - mainly showing video to a lot
11:08 - of users.
11:09 - That's a major
11:11 - requirement.
11:11 - And also, of course, comments is a thing
and being able to react as a thing.
11:14 - You may also consider product requirements
to be showing a banner in case there's a
11:17 - problem.
11:18 - It is, but the core requirement,
11:22 - of course, is just showing a video,
so I'll pick this feature first.
11:25 - This means that I have to capture
video from a source, let's say, which
11:30 - is shooting at eight K, and I should
be able to store it in someplace
11:35 - in my server so that I can query it
later in a live streaming system.
11:40 - The later part, the query it later
is probably milliseconds, so I may
11:46 - not want to query that data at all.
11:48 - I may want to directly stream it
from the video camera onto millions
11:53 - of people taking a step back.
11:55 - It looks impractical because if I'm
shooting at eight k at very high
12:00 - quality,  and this
12:02 - is raw
12:02 - footage.
12:03 - Sending that
12:05 - much data to people on their
mobile phones is unreasonable.
12:09 - So yes, I need to store it in some
sort of a database or a file system,
12:13 - and then I should be able to stream
that or query that out so that I can
12:18 - distribute it to all of my customers.
12:20 - But I don't want my customers
to know exactly how I'm
12:23 - doing this or I don't
12:24 - want them to know about, there's a
change in implementation tomorrow.
12:27 - I want this to be a black
box so that they can pay me
12:30 - and relax.
12:31 - They just
12:32 - hit an API and their problem is solved.
12:35 - Of course, I might give them
clients which are download on the
12:38 - app store which take
12:40 - care of all of this API and querying
also so that as end users, they can
12:44 - just enjoy watching an event instead
of thinking about how the technical
12:48 - part of this is actually happening.
12:50 - These APIs have well defined signatures.
12:52 - You can tell that if I want
12:53 - this video Id in a particular
12:56 - format, then I have to query a
particular API called Get video.
13:00 - , which is going to be
returning me objects of
13:02 - type frames.
13:03 - And those
13:04 - frames are also well defined.
13:06 - So if you have ever written a program,
you know that these API signatures
13:10 - are very similar to method signatures.
13:13 - The only difference being that these APIs
might be queried not through a programming
13:16 - language, but through a network protocol
like G R P C, htp, ftp, any kind of
13:24 - protocol which defines exactly how an
electronic message is going to be taken
13:27 - from one place and sent to another.
13:29 - And also how the response is
going to come back and how the
13:31 - behavior of this interaction is
13:33 - going to be that is defined
13:35 - by the protocol.
13:36 - So this
13:36 - is great.
13:37 - We have a
13:38 - system which is storing some
data, which is valuable to us
13:41 - because we want to watch this
13:42 - event live.
13:44 - And this data
13:46 - is going to be queried using APIs.
13:48 - Also, these APIs are going
to be tested beforehand
13:50 - so that, the clients
13:52 - who are using this work, paying for
this service are not disappointed
13:55 - when they actually query it.
13:56 - As engineers, we have to think
of various failures and our use.
14:00 - . What if the database, which is
stored in your videos crashes?
14:04 - What if a particular firewall
on the internet starts
14:07 - blocking all of your requests?
14:09 - What if one of the services that
you've written in your entire
14:12 - system, one program, one piece of
code, starts misbehaving because
14:17 - you have, introduced
14:18 - a bug in it?
14:19 - Or there is somebody who has
maliciously entered the system and
14:23 - changed the code in that system?
14:24 - We have to use some design principles
that we talked about earlier.
14:27 - This challenge may also be a feature
request, like if you want the musician
14:31 - who's playing in this live event to
be able to talk to the audience, do
14:35 - a back and forth with some audience
members who they select either
14:39 - randomly or based on their activity.
14:42 - So you have to display those users to this
musician live and be able to broadcast two
14:49 - parties to millions of people out there.
14:51 - So taking these requirements, let's try
to design a live streaming application.
14:55 - So there's two ways to approach this.
14:56 - One is, From customers or our
clients to our server, which is
15:02 - out there in different parts of
15:03 - the world.
15:04 - And then to
15:05 - our database, which may be, again,
in different parts of the world.
15:10 - That's one way to think.
15:12 - And the other way to think is
from our database to our server.
15:16 - So what kind of detail do I need
to store to enable my server?
15:20 - And what kind of APIs do I
need to expose to enable my
15:24 - customers to be able to use my
15:25 - product?
15:25 - Okay.
15:26 - Both of these
15:28 - approaches are fine.
15:29 - They require different
ways of thinking, though.
15:32 - When it comes to a data based approach,
you will need to consider what
15:37 - kind of data do you need to store.
15:39 - And often you'll be thinking of these
15:43 - pieces of data as tables.
15:46 - So you need to store a video
15:48 - with an id.
15:49 - The video
15:50 - has a name, it has a size,
and it has some data.
15:55 - That's one way to think.
15:56 - I prefer the other approach where
customers define their problems, which are
16:02 - then fulfilled using APIs on the server,
which are then fulfilled by storing
16:09 - some sort of data in the server, in the
16:12 - database.
16:12 - And that data
16:14 - is then mapped onto
16:15 - tables like and so for
16:17 - this system, this is the
product we'll be using.
16:21 - Okay?
16:22 - In our case, customers are live streaming
customers, so they may be streaming from
16:27 - their cell phones or laptops or the tv and
we can't assume which device is being used
16:35 - more often.
16:36 - In certain
16:36 - countries you'll have
certain devices being
16:38 - used more.
16:39 - There, there
16:40 - could also be a tablet of course,
from which they're streaming this
16:43 - video.
16:43 - But that there
16:44 - are multiple devices which need to be
16:46 - catered to.
16:47 - This is a
16:48 - front end UI design problem.
16:51 - System design is more to do
with the distributed systems'
16:55 - backend part of things.
16:57 - There is some system design involved when
it comes to API interactions and how to
17:02 - store or cash data on the front end, but
that is not what we are focusing on here.
17:07 - We are focusing on the
backend part of the system.
17:09 - Okay?
17:10 - So these clients need to be able
to query our server in real time.
17:15 - So what does our server need to have?
17:17 - Its APIs are going to be something like
get video and you pass in the video
17:22 - ID and you pass in your device type.
17:25 - So I send you the resolution based
on your device type and you might
17:29 - have a particular offset that
you know, I've already seen the
17:32 - first 10 minutes of the video.
17:33 - Show me everything after the 10th minute.
17:36 - If I have a video API like this,
I also need to return something.
17:41 - So the return type could.
17:43 - Some frames, some
17:45 - video frames.
17:46 - Let's say
17:47 - each of these frames is 10 seconds long.
17:49 - So a single frame is what I
sent back, such that it is off
17:52 - this video for this
17:54 - device.
17:55 - And after 10 minutes, so 10 minutes to
10 minutes and 10 seconds, that frame
18:00 - is picked up and sent to the client.
18:02 - If you know about
18:03 - API design, that this
18:05 - API is not
18:06 - well named.
18:07 - Get video
18:08 - means you get an entire video,
but you're returning a frame.
18:12 - So maybe we can rename
this to get video frame.
18:15 - Other thing is if you're using a
18:17 - REST protocol get is going
18:20 - to be defined in the request itself.
18:22 - So g e
18:23 - t or here is going
18:25 - to say that Get Me Video is
enough to say that you want
18:30 - a video.
18:31 - In our case,
18:32 - like we said, it's a frame, so
maybe get frame or get video
18:35 - frame is what we are looking at.
18:37 - You notice that Wimu also has a similar
API when it comes to getting the next 10
18:42 - seconds.
18:42 - YouTube also has
18:45 - an api which tells you from which point to
which point do you want to see the video?
18:49 - I'll give you all those things.
18:50 - Great.
So we have this, what else?
18:53 - You should be able to
comment on the video.
18:55 - Okay.
18:56 - So what you should be able to do is
you should be able to post a comment.
19:00 - Again,
19:01 - I'm using well-known
19:03 - concept in rest post means you want
to put something in the server, you
19:08 - want to manipulate some data, you
want to add some data to the server.
19:12 - So if I say post a comment with an ID
here, I don't care about which device
19:17 - it is coming from because the comment is
just data, which has to be persisted in
19:20 - the server.
19:21 - Based on that,
19:22 - I'm not
going to be, changing my
19:24 - response or changing the behavior
in which I'm posting the comment.
19:27 - So I don't need that.
19:28 - I don't need an offset, but
I do need the comment data.
19:31 - I need the author of the comment.
19:33 - I need the post on which
this comment was made.
19:35 - So maybe the video on which
this comment was made.
19:38 - So the video ID.
19:40 - And similarly for each requirement, we
can expose APIs, which will allow us to
19:46 - query and manipulate the data as we want.
19:49 - So that roughly defines our
server side capabilities.
19:54 - Okay, we haven't spoken
19:55 - about anything in detail.
19:59 - We haven't talked about the network
protocol also that we use, but
20:02 - roughly this is what it's, okay.
20:04 - Now let's go for the next part,
which is the database side of things.
20:09 - What kind of data we need to
store to satisfy these APIs.
20:14 - Returning frames is
something we want to do.
20:16 - Storing comments is something we want
to do and also probably get those
20:18 - comments.
20:19 - And to get video
20:22 - frames, we also probably
need to put video frames.
20:25 - What kind of database should we use?
20:27 - Comments are rather simple.
20:28 - You can store this in an SQL database
such that an SQL table having an ID
20:33 - with you.
20:34 - The data of
20:36 - the comments are text.
20:38 - being stored as a
20:38 - problem.
20:39 - The author,
20:40 - which is a foreign key
to a user table, right?
20:43 - So in a user table, you
20:45 - have an id and this
20:47 - author is going to be
mapped to an ID over here.
20:50 - Along with that, we have a video id.
20:51 - So there's a video table also,
which has an ID and some data.
20:57 - The video IDs are going to
be mapped in this way, okay?
21:01 - An example of this would be
video ID 10 is over here.
21:06 - This is a cricket match.
21:08 - Video ID 11 would be a musical
21:10 - event.
21:11 - Okay?
21:11 - And this is
21:13 - a comment table.
21:14 - So for this cricket match, a comment
was made in which they said, Hey,
21:21 - and the author was author number one.
21:23 - Author number one happens to be called.
21:26 - That's their username.
21:28 - So if you have to display all comments,
In the front end for a particular video.
21:35 - What you want to do is you want
to get all of the comments in
21:38 - this table for that video 10.
21:42 - Then you want to get the data for that
user because you want to display the
21:45 - username who has made that comment.
21:48 - And you also want to get some video data
because you have to display that on top
21:52 - of the page where the comment was made.
21:55 - So in this way, we are able
to satisfy our requirement of
21:58 - posting comments, posting video.
22:00 - Now, overall, this system is complete.
22:03 - We have a
22:03 - system which can answer
22:06 - queries.
22:07 - Okay?
This is good enough to
22:10 - start with.
22:11 - This diagram
22:12 - is not
22:12 - incomplete.
22:13 - It's very rough
22:16 - or
high level.
22:17 - There's nothing
22:18 - here which is concrete, nothing,
which is, let's say, useful
22:23 - when it comes to implementation.
22:24 - A at this point in time, we have a
rough idea of how we are going to be
22:28 - talking to each other, not what we
are going to use to make this happen.
22:32 - So let's get into those
implementation details.
22:35 - Firstly, on the client side, is
there something we need to do?
22:40 - Yes, different APIs require
different behaviors.
22:45 - Posting a comment means that I'm posting
this once and I'll be querying that
22:51 - comment maybe soon, but it's not like
I need something to keep happening.
22:54 - I don't need continuous
updates on the comment.
22:57 - Those notifications can be given
periodically to me, or maybe I
23:01 - don't need those notifications
at all after a few months.
23:04 - I just don't need
notifications on that comment.
23:08 - So you see over here, you
have non real time behavior.
23:13 - What about a video frame?
23:16 - When I ask for a video frame, I
usually need to ask for the next
23:21 - video frame immediately after that.
23:23 - So I'm watching a live video,
I ask for a video frame.
23:27 - I am sorted for the next 10 seconds.
23:29 - In five seconds, I'll be
asking the next video frame.
23:33 - . So that behavior is different.
23:34 - It's a more continuous behavior.
23:37 - Okay?
23:37 - So maybe we need to use different
network protocols to make
23:41 - this happen.
23:42 - What would
23:43 - I use for a comment?
23:44 - I would use the most common
network protocol when it
23:50 - comes to disability systems,
23:51 - which is hdp, HTP gives
23:54 - us the benefit that you
have a stateless server.
23:58 - You don't need to store any information
when you're handling a request.
24:01 - A stateless server is basically, I
24:03 - have no idea where you
24:05 - are from or what you want.
24:08 - Define everything in the request.
24:10 - Okay?
24:11 - Goon wants the next 10 seconds of video.
24:14 - What do you mean by the next 10 seconds?
24:17 - Who is God of San?
24:18 - Okay, so what should be there
in the request is here's Gossen.
24:23 - This is his user id.
24:24 - You can actually go and
look it up in your database.
24:28 - It's not the next 10
24:29 - seconds that he wants the
24:30 - video from minute number 10 to 10 minutes.
24:33 - 10 seconds.
24:34 - Okay.
24:34 - That video length is also well defined.
24:37 - There is no concept of
the next point of view.
24:39 - And the video ID is mentioned.
24:41 - It's not like Gora wants the next 10
seconds of the video he was watching.
24:45 - No, I have no idea what we do.
24:46 - He was watching you define which
video needs to be pulled up here.
24:51 - You might think that this is an obvious
point, like what's so special about
24:55 - defining everything in the client
24:56 - itself.
24:56 - It looks a
24:58 - little tedious and stupid, but doing it
25:00 - is fine.
25:01 - Doesn't everyone
25:02 - do it?
25:03 - Not
necessarily.
25:04 - When you ask
25:06 - for the next 10 seconds of video, for
example, very often as a client, you don't
25:12 - know what the next 10 seconds should be.
25:15 - Take an example.
25:18 - Give me the video at 10 minutes, then 10.
25:22 - 10 seconds from 10 minutes.
25:23 - Okay?
25:23 - That's one chunk.
25:25 - Let's say you make that request.
25:27 - And the server is taking
time to give a response.
25:29 - Now you come back and you say,
give me the same video because
25:32 - you didn't receive it in time.
25:35 - The server is going to look
at that request and serve
25:38 - you the same response again.
25:40 - The other approach to this would
be the client making a request.
25:44 - Gimme the next 10 seconds, where
next is known to the server.
25:49 - Okay, so here the definition is not 10
minutes to 10 minutes and 10 seconds.
25:55 - The definition here is
the next 10 seconds.
25:58 - The server is now going to take
this request, look at the user's
26:02 - current pointer, and then decide
which 10 seconds to pull out.
26:06 - So in the first case, it'll take 10
minutes to 10 minutes, 10 seconds.
26:10 - In the second case, it's going
to make a decision to send you
26:14 - the video from 10 minutes, 10
seconds to 10 minutes, 20 seconds.
26:19 - What's the benefit?
26:20 - The client didn't need to know which
part of the video it wants to watch.
26:26 - , it lets the server handle it.
26:28 - It makes the overall network more
efficient because the client is not
26:32 - making duplicate requests, and it makes
the client code a little more simple.
26:37 - You don't need to define everything
every single time you let the
26:40 - server figure it out with context.
26:43 - That's a difference between a
stateful and a stateless protocol.
26:47 - HTP is stateless.
26:49 - Its benefit is that the
server is kept simple.
26:51 - If the server crashes, there is no
context on memory that is lost in
26:55 - the server.
26:56 - If you forget
26:57 - where the client currently was
pointing to, then this is a serious
27:00 - problem, right?
27:01 - You can go
27:02 - and store it in your database
instead and make a service stateless.
27:06 - Therefore, the protocol that you're going
27:07 - to use htp can be stateless.
27:11 - The best part about this is
you can add new servers without
27:13 - any issue.
27:14 - You have no
27:15 - state being stored in server.
27:16 - So whenever a new
27:17 - server pops up a new request
27:19 - comes with total context in the
request itself, which you use.
27:24 - To query your data, right?
27:25 - What about
27:26 - video frames?
27:26 - Do you want
27:28 - to query video frames?
27:29 - You want to get the next one?
27:31 - What kind of a protocol will be nice?
27:34 - You can use HTP here also, but
a much better protocol would be
27:40 - something which is designed for video
transmission, because in video you
27:43 - have to consider some other parts.
27:46 - What happens if I have a mobile device,
which does not have much resolution?
27:50 - What happens if I have poor bandwidth?
27:52 - What kind of video am I transferring?
27:53 - If it's a live streaming thing, then the
current video is the most important video.
27:58 - What happened previously
does not matter anymore.
27:59 - If I missed that packet, if
that packet was dropped in the
28:02 - network, let go.
28:04 - If it's a,
28:06 - if it's a live streaming lecture
where you know, there needs to
28:09 - be full context to understand the
next part of this lecture, then you
28:13 - probably want to send it properly.
28:14 - You want to send it over a
28:15 - reliable network and over
28:17 - a reliable protocol.
28:19 - Okay.
28:19 - So if you want a reliable protocol,
a TCP back protocol is a good idea.
28:24 - If you want a realtime efficient protocol,
then a UTB backed protocol is a good idea.
28:31 - So over here I'm going to use
a protocol like Web RTC here.
28:35 - Web RTCs, a peer-to-peer protocol.
28:37 - So you actually are able to send
video from the server to the client.
28:41 - Certain protocols have a
client to server expectation.
28:43 - So the client is the only person who can
28:45 - send data who can make
28:48 - a request to the server.
28:49 - The server cannot send data
by itself to the client.
28:52 - Okay?
28:52 - So what I'm doing again here is
using a peer-to-peer protocol for
28:56 - the video, but for comments, it's
always gonna be client to server.
29:00 - So you see that network protocols
are also important when it
29:05 - comes to designing systems.
29:07 - Okay, finally, on the server side, what
are some considerations we have to take?
29:11 - Similar to the
29:13 - server side we have to
29:14 - think about how are we going
to talk to the server, but.
29:18 - Most database solutions, let's say MyQ
or post case, define exactly how you're
29:24 - going to be talking to the databases.
29:26 - So this is a TCP backed protocol
usually, but the protocol is defined
29:30 - well, so we don't need to think of that
when it comes to talking to service.
29:36 - Elastic Search, for example, has HSTP
29:38 - based protocol Cassandra,
29:41 - Amazon db, Amazon
29:43 - Diameter db MySQL, post
29:45 - Grace, all
29:45 - of them, the protocols
29:47 - are identified.
29:49 - The problem then becomes which
database solutions should we use?
29:52 - Because there's a ton of solutions
out there, and they have tradeoffs.
29:57 - We could store data in
29:59 - the MySQL database
30:00 - also, but it's going to be expensive, and
it could be potentially very slow also.
30:07 - So what is this
30:08 - video data?
30:09 - It's effectively
30:10 - a file.
30:11 - So storing it in a file
system is not a bad idea.
30:15 - And you don't want to build
a file system yourself.
30:17 - So you want to use a
well-known file system
30:20 - solution for this maybe hdfs.
30:23 - That's one solution.
30:24 - You could also use a video
hosting solution like wimu.
30:29 - Yeah, it's off the shelf.
30:30 - You can just use it.
30:33 - You can use wimu, by the
way, to host events also.
30:36 - So it's best to mention this in the
30:37 - system design requirement,
30:39 - like maybe an enterprise solution from
will take care of the entire thing.
30:43 - But if you can't do that,
if you can't have a live
30:44 - streaming requirement
30:46 - and you don't wanna lose your job, maybe
30:48 - because  then you can use a file system
30:54 - like sdfs or s3, Amazon s3.
30:59 - The benefit of S3 or
sdfs is that it is cheap.
31:02 - It's
31:03 - easy to query and you can
31:05 - store very large files inside it, okay?
31:08 - In a
database.
31:09 - Yes, it's
31:11 - also, it's
31:12 - not cheap but it is
31:13 - easy to query and you can store very large
31:15 - files inside.
31:16 - The capabilities
31:17 - that a database gives you in terms
of updating data or querying data
31:21 - may or may not be very relevant
to you when you have a static
31:24 - file, which is a video file, okay?
31:27 - You're primarily looking at low cost
when it comes to storing video solutions.
31:33 - What about the user or the comment table?
31:36 - These two tables can have a
skill solutions back in them,
31:39 - let's say MyQ or post quiz.
31:41 - You may say that a comment
is a complex data structure.
31:44 - Every time, a requirement
31:46 - changes, the comment table also needs
31:48 - to change.
31:49 - Maybe you
31:49 - want to persist a lot of data
in the comment table per entry.
31:53 - You want to persist all the replies
of the comment also in the same entry.
31:57 - So on MySQL database or a SQL database
is not what you're looking for.
32:02 - You're looking for a NoSQL database,
which is not ideal when it comes
32:07 - to transactions or relational.
32:09 - Joins, but you don't
have that requirement.
32:13 - You're looking for scale When it comes
to comments, you just want to persist
32:16 - that data in a key value fashion.
32:19 - So that's no sequel.
32:21 - Great.
32:21 - This is very rough
32:24 - idea of how we are going to be designing,
which is satisfying the requirements
32:29 - of the system, and also defining
the protocols or the solutions that
32:34 - we'll be using to make it possible.
32:37 - For example, we talked about web
RT Cstp when it comes to network
32:40 - protocols, and when it comes to
database solutions, we talked about
32:43 - MySQL and a file system,
32:46 - a design can go in more
and more depth based on how
32:49 - important that requirement is.
32:51 - So doing a recap, we see that we have
a system, a very rough blueprint even
32:57 - now, which talks about how our customers
are going to be accessing our APIs
33:02 - and how those APIs are going to be
accessing the data in our database.
33:07 - The data in our database may be being
filled by customers like in Facebook.
33:10 - Usually the customers are the people
who are filling the data, or it may
33:14 - be filled by an external service.
33:17 - In a live streaming system, it's probably
33:19 - going to be a really
33:21 - high efficient camera, which is
going to be recording the video
33:23 - live and persisting to our database.
33:27 - Okay.
33:27 - The network protocol that you probably
want to look at is rtmp Realtime
33:33 - Media Protocol which is
33:36 - a guaranteed protocol.
33:36 - You don't lose any data
when you are shooting video
33:40 - using this.
33:41 - And the idea
33:42 - is web rtc, you might lose some data.
33:45 - That's okay.
33:45 - It's the end user watching a
33:47 - live stream.
33:47 - They want
33:48 - data quick and real, but at the source
of everything, you don't want to lose
33:52 - any data because everybody else will lose
the data if you lose it at the source.
33:55 - So a highly reliable network can
be set up over here in a high
34:00 - bandwidth, expensive network
34:02 - because, that video
34:05 - camera is really going to need a
high bandwidth, expensive network to
34:08 - process that amount of data into your
database and then this data can be sent.
34:12 - You're seeing that I've skipped a lot of
34:14 - requirements.
34:14 - That I can't
34:15 - take this high quality data
and just send it, broadcast
34:18 - it to everybody on the planet.
34:20 - What I need to do is transform this data.
34:22 - Okay?
34:23 - So now what we are doing is we
34:25 - have looked at high level
34:27 - what the solutions are
34:27 - going to be and now really
34:29 - getting into the nitty gritties
of designing the system.
34:33 - So the first part of this is how
do we take this raw footage, this
34:37 - data over the higher level network,
which comes to our database, our
34:40 - file system, and convert it into data
that we have to serve our customers.
34:44 - Four adp, seven 20 P, so on and so forth.
34:47 - You can't serve eight K definition.
34:49 - So how do you do that?
34:51 - There needs to be some sort of a
transformation service over here,
34:55 - which is going to be taking this live
stream and converting it into different
34:59 - resolutions.
35:00 - 10 80 p, which
35:03 - is full hd.
35:05 - You have seven 20 P,
35:06 - which is hd four 80 P,
35:09 - which is decent for quite a few mobiles.
35:12 - And I don't know if this is something
you want to do, but if the live
35:16 - part of your stream is really
important, then 1 44 P is also okay.
35:20 - Because as long as people are getting
information and they're able to see
35:23 - roughly what's going on, they're going to
35:25 - be happy.
35:27 - Sometimes
35:27 - these resolutions are defined well in
the product requirement document itself,
35:32 - the p I d, because after speaking
to customers and getting their real
35:35 - feedback, which resolutions
35:37 - are acceptable or tolerable for the
customer, there might be some customers
35:41 - who ask for premium 4K transfer also.
35:45 - Okay, so that's fine.
35:47 - You're watching
35:48 - it on tv, then you probably
wanna watch it at 4k.
35:50 - Okay.
35:52 - This raw video needs to be
converted to these resolutions.
35:56 - How do you do that?
35:57 - So the first thing you'll do is
you'll break this video to segments.
36:00 - This entire raw video is going to be
broken into segments of 10 seconds.
36:06 - So you collect video for 10 seconds, chop
it off, you break that into one segment,
36:11 - and then you give it for processing
at point number 0, 1, 2, 3, and four.
36:19 - So let's say you have these zero
to four, which is five programs,
36:23 - which take the raw video and
convert it to different resolutions.
36:27 - So if you pass in 1 44 p,
then a particular program
36:31 - picks it up.
36:32 - If you pass
36:33 - in four 80 p then another program
36:35 - picks it up.
36:36 - And maybe
36:37 - you have the same program, which is
running in, in five concurrent pieces and
36:41 - five threads based on
36:42 - the resolution that you pass.
36:44 - It converts the video, the ten second
video footage into that resolution.
36:49 - Similarly, you can think
of different formats.
36:54 - So if you have a device, which is
an Android device, , it probably
36:59 - has to see the video in a different
37:00 - format.
37:01 - Okay.
37:01 - It can't read
37:02 - all sorts of video.
37:03 - It has some formats which are well defined
inside it in the device, so it can read
37:08 - that format.
37:09 - Similarly,
37:09 - apple devices might
have a different format.
37:12 - So these formats define how you're
going to read this piece of data.
37:14 - This video data, which is going
to be sent over you through
37:17 - the network common video
37:20 - format is H 2 64.
37:23 - Apart from H 2 64, you might
have your own proprietary
37:27 - formats.
37:27 - Let's say
37:28 - you have a format which is more
efficient than H 2 64 or for your
37:33 - particular type of event, a music event.
37:35 - You research and you
37:37 - find that there's a
37:38 - way to store video more efficiently.
37:41 - So this is more of a very large scale
problem, like Netflix has its own
37:45 - formats, but if you're
37:47 - a small company, edge 0.2 64 is very good.
37:50 - Okay?
37:50 - So different resolutions.
37:52 - Different formats.
37:53 - We need to take our raw video
footage and convert this into a
37:57 - combination of a resolution and format.
37:59 - So over here we use a design
pattern of map reduce.
38:05 - I won't go into too much detail of
this design pattern, but the basic
38:08 - idea is you can take one video split
into pieces, which is 10 seconds
38:15 - long, and send it to different
servers to get different outputs.
38:22 - Okay?
38:22 - You might have something else also
in the process, apart from just
38:25 - transforming the type of video.
38:27 - Maybe you want to compress
it here in the next step.
38:31 - That can be in
38:31 - step two.
38:32 - The servers
38:33 - being used here might
be s3, S two and S one.
38:36 - So you see S one is
being used here and here.
38:39 - S3 is being used here and here.
38:40 - So
38:41 - there is no there is
38:43 - no guaranteed execution server that
you have for one part of the process.
38:48 - Any server, which is free.
38:50 - We'll pick
38:50 - up a task and execute
38:53 - it, whether it's compression
or transformation.
38:56 - Again, finally you get three
different outputs, which you
39:01 - can store in your database.
39:04 - So this would be the map reduced pattern.
39:06 - It's a very high level overview of this.
39:09 - It's almost a ca of the map
reduced pattern cause there's
39:11 - no reduce in this process over here.
39:14 - But have a look
39:15 - at this design pattern.
39:16 - It is useful when it comes to
taking a single piece of data or
39:20 - a data lake and converting it into
the data streams that you need.
39:25 - Next, how is this data actually
going to go to the users
39:28 - who are looking to view it?
39:30 - So this data has to go over here to
39:33 - the server which is
39:34 - exposing these APIs of get put post.
39:38 - When you query this data using a
protocol, you should be able to get it.
39:42 - We spoke about web RTC earlier, which
is a peer-to-peer protocol and it's
39:45 - really good for video conferences.
39:48 - Because multiple people are
streaming video together.
39:52 - However, in this case, it's a
broadcast, not a conference.
39:56 - So we can take a step back and say,
instead of web rtc, we are going to use
40:00 - a protocol which is more suitable for
40:02 - streaming.
40:03 - There's a
40:06 - couple of protocols here.
40:06 - Also.
40:08 - The most popular one would be EG
dash, EG is a popular protocol.
40:14 - DASHER stands for Dynamic Adaptive
Streaming or sstp, which means
40:19 - that depending on your bandwidth,
depending on the network that
40:22 - you're on you are going
40:24 - to be able to see high quality
video or low quality video.
40:27 - For
example, you are going
40:29 - in a car, you're watching the video
at 10 adp, you enter a tunnel, your
40:33 - network is really poor.
40:35 - So you start watching it at 1 44 p as
a client, you don't want to handle it.
40:39 - You want the network
protocol to handle it.
40:42 - It's
defined in impact dash.
40:45 - Very similar protocol is hls.
40:46 - This is
useful for iOS or MAC
40:50 - devices.
40:51 - Okay.
40:51 - And finally, what kind of data do
you want to store on the server?
40:54 - Do you want to store any data at all?
40:55 - Do you wanna make it totally stateless?
40:57 - Yes, statelessness is useful
when it comes to request
41:00 - serving and keeping context
41:02 - for every user.
41:03 - But for some things you can keep some
41:06 - state when it comes
41:08 - to video, you can cash the last 10
minutes of video on your server.
41:14 - So anybody asking for video in
41:15 - the last, that video,
41:17 - which is inside the last 10 minutes,
is going to get it from the cash.
41:20 - Instead of you making a full network call
to the database all the way over here,
41:25 - you instead server from server itself.
41:27 - So you avoid this network call
saving time and bandwidth, both.
41:30 - So these are the high level
considerations that you have
41:32 - when it comes to a system design.
41:35 - Like we said, this is a large
scale distributed system.
41:38 - Our assumption is that you have
a lot of users because of which.
41:42 - This much planning and this kind
41:43 - of a design makes sense
41:45 - cost-wise and engineering
41:46 - effort wise.
41:47 - We mentioned
41:48 - that there needs to be
fall tolerance here.
41:50 - There needs to be performance here.
41:52 - So you can use things like CDN solutions.
41:55 - So you can use content delivery
networks to persist some
41:59 - static data and have
42:01 - the clients actually pull
the starting data from here.
42:04 - Webpages are a good idea.
42:05 - You can also have some
42:06 - video data posted on
42:08 - the CDNs, in which case authentication
becomes a bit of a challenge because you
42:12 - don't want everyone to be able to see
42:13 - this data.
42:14 - And does the
42:15 - CDN do the authentication for you?
42:17 - Do you write some code and then
host it on the cdn, which does the
42:21 - authentication?
42:21 - These are
42:22 - the challenges that you have,
especially when you are designing
42:25 - a large scale distributed
system where performance is key.
42:28 - Okay,
so this is at a high
42:30 - level the things we need to consider when
we are designing any sort of a system.
42:35 - Where the requirements are defined.
42:36 - Maybe in the product requirement
document, maybe it's a
42:38 - startup.
42:39 - It's at a very, nascent stage.
42:42 - There is no requirement document.
42:43 - You're directly talking to the
customers and coming up with a
42:46 - technological solution, which is
going to satisfy the requirements.
42:49 - The important things to notice are
that you define the requirements
42:55 - as abstract concepts like
42:57 - objects.
42:57 - These objects
42:59 - then need to be able to be manipulated
and queried using APIs on your server.
43:05 - The data representations need
to be stored in databases.
43:09 - Once this high level blueprint is done,
we start thinking about what exactly do
43:14 - we need to make this system possible?
43:17 - So what protocols are we going to use?
43:18 - What kind of database
solutions can we use?
43:20 - In some cases, you also think of what.
43:23 - Intermediate design pattern solutions
you can use, like you have load
43:26 - balances, you have message queues.
43:28 - These are all design
43:29 - patterns.
43:30 - And these
43:31 - have been converted into
tools by various companies.
43:34 - Redis, for example,
43:34 - provides cas load balances
43:37 - and many other things are also
provided by cloud solution providers.
43:40 - Aws, you want to use these already
well-built, well-tested solutions
43:47 - instead of rebuilding it yourself unless
43:49 - you know the trade
43:50 - off in terms of cost and performance
is significant and it's worth it.
43:54 - Finally, once you have decided on the
tools, you think about the interactions
43:57 - of these tools and the interactions of
these services to meet your requirements.
44:02 - So we thought about how are we going
to take a video and show it to the
44:06 - user?
44:06 - Oh, we have to
44:08 - transform that video.
44:09 - We have to convert it into different
formats, otherwise it won't be visible
44:13 - in different operating systems.
44:15 - We then thought about how we are going
to stream this video to the server.
44:19 - We then thought about how we
are going to stream this video.
44:21 - To the client device.
44:23 - And finally, we are touched upon actually
streaming the video through a CDN solution
44:27 - instead of from your server, because
maybe your server is in the us and even
44:31 - if it is, close to the
44:33 - person who's streaming, you don't want
your server to handle all that load, all
44:37 - of that load all for some static content.
44:39 - You want to be giving that load
away to well-known solutions like
44:44 - content delivery networks, which
can be tied up with their ISPs.
44:47 - You can have a look at
how Netflix does it here.
44:51 - Another part of system
design is low level design.
44:54 - This is in contrast with what
we just saw, which is high
44:57 - level design where we
44:59 - took different components of the
entire system and thought about how
45:04 - those components are going to interact
with each other using network calls,
45:07 - using APIs.
45:08 - And then you're
45:10 - going to be sending data
from one place to another.
45:13 - But largely if you look at these
45:15 - systems, they own the business
45:19 - data related to that service.
45:21 - Now what we are going to do
is take certain functions of
45:25 - these services and try to
45:26 - code it out, which means we
are going to go into much
45:30 - more depth.
45:31 - But because
45:32 - of that, we are probably
going lose some breadth.
45:35 - Okay?
45:35 - When you, at the high design
of a system, you are looking at
45:38 - everything from how the users will be
45:39 - interacting with your gateway.
45:41 - The gateway is going to be
actually sending these requests
45:43 - to your internal services.
45:45 - The internal services
are looking at databases.
45:47 - You can't code all of
45:48 - this out.
45:49 - Even in, at work.
45:51 - You
45:51 - can't just have this all
in one document, one page.
45:54 - So you take small chunks of the system
and you try to elaborate on each chunk.
46:00 - That would be the Louis design.
46:02 - The core functionality of live streaming
is to be able to view a video as a
46:08 - customer, as a person who's paid.
46:10 - Maybe it's a subscription,
maybe it's a one-time
46:12 - purchase.
46:12 - But what we are
46:13 - looking at here is how
does a user fetch video?
46:18 - View video and fetch more of the video
and continue doing so, video ends, right?
46:24 - We are not looking at onboarding
the video, onboarding a
46:27 - movie or how the livestream
46:30 - is going to be moved from the
source camera to our system.
46:34 - We are looking on the other side,
the user side of how it's going
46:37 - to be consumed by the users.
46:38 - To do this, we again, have two approaches.
46:41 - One is to think of the code in the start.
46:45 - So if you are an object oriented
programming language person,
46:49 - you might think of what kind
of objects do I need to have in
46:52 - my system?
46:53 - How are these
46:54 - objects to interact with
46:55 - each other?
46:55 - Is there any
46:56 - kind of inheritance I have
to take into consideration?
46:59 - But as earlier, this is a little difficult
to think of unless the requirements
47:03 - are extremely well specified or they're
so generic that you have to look at
47:08 - the data that you're storing for.
47:09 - Before you think of the function, I
would suggest you think of the user.
47:13 - So even over here, we think about.
47:16 - , what are the actions
that a user can perform?
47:20 - So what I'll be doing is on my phone
or on my desktop, I'll be scrolling to
47:25 - a particular place, watch the video.
47:29 - Okay?
47:29 - So I'll be scrub the video up to a
particular point that can happen.
47:32 - I can also click on play from the start.
47:34 - So start the video at the beginning at
47:36 - timestamp zero.
47:37 - Both of these
47:39 - are very close to each other.
47:40 - So
47:41 - effectively the action
47:43 - is play video at timestamp X
under the functionality that
47:47 - I need is to pause the video.
47:49 - Okay.
47:50 - In which case, what do you do?
47:52 - Do you continue fetching more
segments from the backend or
47:56 - do you stop touching segments?
47:59 - So the behavior is dependent on the
user experience that you want to give.
48:03 - If you don't wanna clog up their mobile
with the entire video, while they've just
48:06 - kept it, in the background then you
48:08 - have to be smart about it.
48:09 - Probably the next 20 or 30 seconds or
one or two minutes can be buffered.
48:15 - into your device.
48:16 - So that behavior also has to be
coded inside, despite pausing.
48:20 - We go for the next two minutes of video
from the place that you have seated
48:25 - right now under the important requirement
is that depending on your device, the
48:30 - video quality, which is going to be
fetched, is going to be either hd.
48:35 - Let's say you are using
another desktop or for atp,
48:39 - let's say for low resolution
48:41 - devices, and one final feature is up
to what point have you played a video?
48:46 - Which means if you had a one hour long
video, let's say there's a cricket match
48:50 - between India and Pakistan, and it's
one hour long and you are seen up to
48:54 - the 20th minute, if you log out and come
back and want to watch the same video,
48:59 - we should start at the 20th minute.
49:02 - We should store that somewhere so
that you have a good user experience.
49:05 - You might want to cash the video like we
were doing earlier, the next two minutes.
49:09 - You want to hit that
49:10 - buffer so that you start
49:11 - playing immediately when the user
has come, or you may not want to
49:14 - do that.
49:15 - You might
49:15 - want to do that just for some videos,
which have been recently watched.
49:18 - The older videos then can be kicked outta
49:20 - the cash.
49:21 - That What
49:22 - I'm considering here are
memory optimizations, user
49:27 - behavior, and API calling.
49:29 - This is largely what lu design
will mean when it comes to
49:32 - interacting with services.
49:34 - Depending on your level of seniority,
and depending on the use case, you might
49:38 - have issues of concurrency, latency
and throughput also come in here.
49:44 - An example use case will be
the workflow that we had for
49:47 - chunking and transforming videos.
49:50 - I'll leave that as an
49:51 - exercise to you.
49:52 - But there
49:53 - are cases where you want to increase
your throughput to the maximum, so
49:57 - you don't really care that much about
49:59 - latency.
49:59 - How quickly
50:01 - do you get those videos
through the pipeline?
50:02 - That's not your concern.
50:04 - You want to make sure that
your pipeline is continuously
50:07 - functioning right.
50:08 - Another cases
50:10 - where the moment a video
comes in,  the new video.
50:13 - You want to respond to it as
quickly as possible with the
50:16 - assumption that video
50:17 - is really important.
50:18 - So there's going to be some sort
of context switching over there.
50:21 - Okay.
I'll leave that as
50:21 - an to you.
50:22 - I won't give
50:23 - you too many details, but it's
interesting to think about how these
50:27 - different low level design requirements
affect the code that we write.
50:33 - Similar to what we did earlier,
we are going to take a structured
50:35 - approach to solving this problem.
50:37 - The first tool that we like to
use is called a use case diagram.
50:41 - As a name suggests, we think about
what are the use cases that we
50:45 - need to fulfill for every user.
50:49 - For example, you can see
three actors in this system.
50:52 - An actor is a person who can do actions,
so an admin can do actions in our system.
50:58 - They can add videos.
50:59 - Maybe a videographer is a person who
can upload videos, so it may not be
51:05 - necessarily that every video which has
been uploaded will be added to the system.
51:09 - Before it gets added, it
has to have some metadata
51:11 - added to it.
51:12 - What's the
51:13 - description?
51:13 - What are the
51:14 - timestamps what kind
51:15 - of video is this?
51:16 - How do you
51:17 - tag it?
51:18 - That might
51:18 - be taken care of by an admin.
51:20 - The video rougher shoots the video,
51:22 - uploads it specifies
51:24 - the quality and everything else.
51:26 - So that's a separate actor and a customer.
51:29 - The person who consumes the video, we
said that this is the most important
51:33 - person for us, so this is the only actor
that we're going to be thinking about.
51:38 - Let's get rid of these two actors.
51:40 - We mentioned that the four things
that we want the customer to be
51:42 - able to do, let's note them down.
51:45 - The first thing is to be able
to play a video from her.
51:51 - Okay?
51:53 - Then comes another requirement, which is,
52:01 - This is them coming back to
the old video that they watched
52:04 - partially and they
52:05 - want to start watching our game
from the left of timestamp.
52:08 - We also want to, we are the
52:10 - maximum quality allowed by
52:13 - network and device.
52:16 - So if you're on a low quality network,
52:17 - that's okay.
52:18 - You low quality
52:20 - video is also fine.
52:21 - But if I'm on my
52:22 - home wifi I wanna see
52:25 - the best quality video that I
possibly can have paid for the
52:28 - subscription.
52:29 - There's things
52:30 - which are also happening
in the background.
52:32 - Of course, like we said, concurrency,
fault tolerance, throughput.
52:35 - These are things which the
end user does not need to
52:37 - think about.
52:38 - You might
52:39 - say latency is something that affects the
52:41 - user.
52:42 - It does.
52:43 - But we are
52:45 - not looking into it.
52:46 - We are assuming that all of our requests
have to be answered within 10 seconds
52:51 - quickly enough.
52:52 - And this brings
52:54 - us to our next point.
52:55 - We need to
52:55 - continuously buffer.
52:57 - Our video,
52:58 - right?
So have nonstop play when
53:03 - watching videos.
53:04 - This is assuming of course, that bandwidth
53:08 - is not messed up.
53:09 - If your bandwidth is messed up, you
can't prefer, so that's not a problem.
53:12 - But if my bandwidth is fine,
then for the next two minutes, I
53:15 - should be able to watch the video.
53:17 - Okay?
53:17 - This is
53:18 - a customer if we can
53:19 - fulfill these requirements, they're
going to be a happy customer, which
53:23 - matters a lot as an engineer,
53:26 - okay?
53:28 - These would be called use cases, right?
53:31 - You can have many use cases.
53:32 - Some of them are core use
cases, some of them are not.
53:35 - When it comes to system design, the
expectation is that if there is a
53:39 - PRD that has been given to you, a
product requirement document, usually
53:42 - it's just on one use case, right?
53:44 - You add a feature and
each feature is important.
53:48 - So we'll take all of these and
mark them as reasonably important.
53:54 - The next step is to
convert these requirements.
53:56 - Into classes and objects.
53:59 - This is where things usually go wrong.
54:01 - When you look at the use case
54:02 - diagram it looks like
54:04 - everything is to do with the
customer view at maximum quality
54:09 - allowed by networking device.
54:11 - But is the customer actually doing that?
54:14 - Is the customer saying that, please
gimme the best quality video?
54:18 - No, that is obvious.
54:20 - That part is obvious.
54:21 - So who's going to handle that?
54:24 - If the customer's not going to handle
that part of the system, then the
54:27 - system has to handle that part.
54:30 - Okay?
54:30 - So there needs to be another actor in this
system, but it's not a, it's not somebody
54:35 - who does actions like physically, they're
going to be interacting with your system.
54:39 - So we are maximum quality
54:40 - offered by the network.
54:43 - Who's going to handle that?
54:45 - There needs to be some sort of a
54:46 - controller or the brains
54:48 - behind.
54:49 - How much video should you send?
54:51 - So I'll just call this, okay.
54:55 - sometimes the entire service,
the entire functionality can be
55:00 - handled just by using a tool.
55:04 - So we offload the problem to a
tool, or in our case, what would
55:08 - be ideal is to use a network
protocol, which takes care of this.
55:14 - Depending on my device and depending
on my network requirements,
55:18 - you take care of the bandwidth.
55:19 - An adaptive protocol is
going to handle this.
55:23 - Sstp dash will handle it.
55:25 - So we'll assume that this entire service,
which was going to look at the user's
55:30 - requirements and then
55:31 - offer them video particular bandwidths,
can be taken care of by simple protocol.
55:37 - So the speed limiter does not need
55:38 - to exist.
55:39 - Instead whenever
55:40 - you're connecting to our system,
it's going to happen over
55:43 - TP dash and that is a pretty
55:48 - big deal.
55:49 - One entire
55:49 - use case taken care of just cause you
know what tool to use now in an interview.
55:55 - Scenario you might be asked, how
does S STP dash work exactly?
55:59 - How does it work internally For
that, you can either read some
56:03 - papers which help you learn the
56:05 - protocol in terms database
56:07 - internal are also very similar.
56:08 - Operating system internals
are also very similar.
56:10 - Or you can guess in this case,
you should probably specify that,
56:15 - hey, I'm just guessing over here.
56:17 - But I think what's going to happen
in this adaptive retreat resemble
56:20 - exponential back off and dcp.
56:23 - Now for the next bit clear video from a
timestamp, this means that every video
56:30 - needs to actually store a corresponding
timestamp for a particular user.
56:36 - Okay, that can
56:37 - be done.
56:38 - We need to
56:39 - have an object here.
56:42 - Our service, which is video
server, a video consuming service
56:47 - is going to be used by end users.
56:50 - Play a video from a timestamp.
56:53 - Okay?
56:54 - So this has to be taken
care of by the video zooming
56:57 - service.
56:58 - So that will
56:59 - be play video
57:01 - for a user.
57:03 - And this is
57:04 - the video I, okay, so I'll
just remove the play for this.
57:11 - And I'll also mention the time
stamp that is being busti.
57:16 - You see that?
57:16 - I'm still thinking in terms of APIs.
57:18 - The clearer your APIs are, the
easier your lower design will be.
57:22 - The more you think about how the
users or each feature is going to be
57:26 - implemented using the
57:29 - services that you have,
the easier your design will
57:32 - be.
57:33 - Okay?
57:34 - Go back to
57:36 - video and watch from left off timestamp.
57:38 - This is quite
57:39 - straightforward.
57:40 - You have seek
57:45 - for this user and this video,
what is a seek position?
57:49 - So let's say we call it
get seek position, but
57:51 - like we say if you're
57:52 - using a.
57:53 - Rest api.
57:54 - Then you can just, you can mention
in the method it's get, so that
57:59 - will send you back the seek
58:00 - position.
58:01 - It's best
58:01 - to mention the return type.
58:03 - Also,
58:03 - like I said the clearer
58:07 - you make your API, the
better it usually is.
58:10 - So video frame will be sent back here.
58:12 - And similarly, what will be
sent back here is the timestamp.
58:19 - So what's going to happen is when you
come back to a video, which you have
58:22 - left off, you're going to first sync what
is the position where you should go to.
58:26 - So that will give you a timestamp.
58:28 - And then you say, okay, play this video
for this user from this timestamp.
58:32 - Alright?
58:33 - Have nonstop
58:35 - play when watching videos.
58:36 - This is interesting.
58:38 - We need to get frames in future.
58:42 - So what do we do?
58:44 - Do we save play here or do we
save, get video frame for a
58:51 - particular user?
58:53 - And a video
58:57 - with a given timestamp.
59:00 - Do you see that these two are very
similar since what this API is also
59:06 - going to return you is a video frame
and you're gonna stack these video
59:10 - frames together and buffer them
into the video, into the phone.
59:15 - Yes.
59:16 - I see a very close
59:18 - linking between this API and this api.
59:22 - At this point, you ask
59:23 - yourself, what does
59:26 - the product need?
59:27 - Is play a different action from
fetching the future content.
59:32 - And here I'll make a decision
of yes, it is different.
59:38 - It's strange to think of because
they're doing the exact same thing.
59:40 - What they're doing is they're,
the user is saying, claiming
59:43 - this video from this time stamp.
59:46 - That's okay.
59:47 - And the other one is that the player,
the video player is saying, get me The
59:52 - video frame for this timestamp looks
extremely similar, but the business use
59:58 - cases are very different.
59:59 - If the user says, get me a video from
this timestamp, it means that they
60:03 - are probably seek to that position.
60:05 - They like what they saw their, or they
found it exciting and they clicked on it.
60:09 - So it's very different behavior
compared to, Hey, get me the next two
60:13 - minutes of video in the background.
60:16 - Okay.
60:17 - That's one very important thing.
60:20 - When you are
60:21 - designing any api think about
60:24 - who's using it, what is
it being used for, right?
60:27 - And then think about the
common functionalities.
60:30 - So these two APIs are very similar.
60:33 - And on the server side, what you would,
I'd really like to do is just merge these
60:39 - two APIs.
60:40 - The client
60:42 - should figure out
60:43 - by itself that what
60:45 - video frame doesn't want to pick.
60:47 - , so maybe you cut down
60:49 - on the APIs that you
60:50 - have
to maintain by replacing
60:55 - the current API of play
with what we have here.
61:01 - So maybe every time you play from a
particular point, we should sign an
61:05 - event to the backend service saying that
this is an exciting part of the video.
61:10 - The user actually came to this
timestamp, seek Q and clicked on the
61:13 - video.
61:13 - Okay.
61:14 - That there is a seek api,
61:18 - which is
61:19 - primarily for when you're
61:21 - left off a video.
61:21 - So if you left off, came back and started
watching from there, maybe it's not super
61:26 - exciting, it's just the place that you're
61:28 - leading off from you, you wanna
61:30 - continue from.
61:31 - But during the video while watching
it, if you came to a particular
61:35 - position and started viewing,
that requires an event that
61:39 - shows that, this part
61:40 - of the video is sought after.
61:43 - So it feels like you're splitting
hair here, but from the side of the
61:47 - business or from the side of analytics,
they're very different use cases.
61:51 - From the side of engineering,
it's the exact same
61:53 - behavior.
61:53 - Someone asks
61:54 - you for 10 seconds of video, you
give them 10 seconds of video.
61:57 - But for analytics or for the
business, this part should be
62:01 - converted into a three load.
62:03 - This part is just for user experience,
so it depends on you As an engineer,
62:10 - I personally would take this API and
I would see who's making this request.
62:16 - So a flag would probably say
that the user made this request
62:20 - or the device, the mobile made
the request all good buffering.
62:25 - And depending on that flag, I would then
62:28 - file an event for showing
62:30 - interest in this part of the video.
62:33 - Alright, so that is the use case
62:34 - diagram.
62:35 - We can now
62:36 - think about the class diagram.
62:38 - Let's draw the class
62:39 - diagram out.
62:40 - The first
62:41 - class that we need is a video.
62:43 - Two things that we need to store for
every class are states and behaviors.
62:49 - States are data that an
object needs to perform.
62:54 - Behaviors.
62:56 - For example I am speaking
62:58 - right now, so I need a throat.
63:01 - I need
63:02 - a tongue.
63:02 - I probably
63:03 - need a brain to speak and what
I'm doing right now is teaching.
63:08 - So the behavior will be
teaching while the data that
63:12 - I need is my body parts
63:15 - to actually work in tandem.
63:16 - Similarly, you might have a video
which has certain data that it needs.
63:21 - So that would be the bites of the video.
63:25 - Let's say frames.
63:26 - Cause we have been using
this term that's in
63:28 - every video.
63:29 - You might
63:30 - have
some metadata who's the
63:33 - uploader of this video?
63:35 - How long is it?
63:36 - What kind of tag do you want to add?
63:37 - So on and so forth.
63:39 - , what operations can you perform on the
63:41 - video?
63:42 - You can get
63:44 - a
frame, right?
63:46 - That's pretty
63:47 - much it.
63:48 - Okay.
63:48 - You can't add a frame after you've added
63:50 - a video.
63:51 - You can't do anything apart from
63:54 - just getting a frame
from a particular point.
63:56 - So that's the simple class.
63:58 - You also have the class
63:59 - of user.
64:01 - That I'm not
64:03 - focusing on the class diagram.
64:05 - So user has a
64:08 - name, an email more metadata around them,
64:14 - but nothing else really.
64:16 - The most important thing, probably to
be an ID in your case could be an email.
64:20 - A video also will have an id and for
the user, you can probably get there.
64:30 - Id, okay.
64:31 - Very simple class again, which
brings us to the most exciting
64:34 - class, which is watch video.
64:39 - Okay, so a watched video is
going to be an action by a user
64:43 - who's basically watching a video.
64:45 - So this needs a video id.
64:48 - Which video have you watched?
64:49 - Who is watching it?
64:50 - That is the user id an ID of the
action so that you can refer to
64:55 - it later.
64:56 - Up to what
64:57 - timestamp have they watched this video?
64:59 - So seek timestamp.
65:02 - And coming back to the use cases,
we might want to buffer up to a
65:07 - particular point, but let's assume
that the client handles that.
65:09 - The client knows how long, how much
video you have buffered already in
65:13 - the device.
65:15 - Going back
65:16 - to a particular place is possible
because of the timestamp.
65:19 - The final class is
video consuming service.
65:21 - This also requires a class
to be explicitly shown here.
65:26 - So that is video consuming service.
65:33 - Let's first define the
behaviors that this class has.
65:36 - So that is API one.
65:38 - And if you two,
65:45 - and to do this, it just
needs to set watch videos,
65:55 - which user, okay?
65:58 - That takes of our entire class.
66:01 - You've seen, this is a
very simple class diagram.
66:03 - What is more challenging
actually is the sequence diagram.
66:09 - Okay?
66:09 - How is a user going to watch a video?
66:12 - So this would be called a class
diagram where we have defined what
66:18 - state and what behaviors are possible
for each object in our system.
66:24 - Fine.
66:26 - These two diagrams of a class and use
case are sufficient in most cases.
66:32 - However, in some places where
the interaction is complex, like
66:36 - over here , you need
66:39 - another diagram which defines
the sequence of actions.
66:42 - In this case, it's not very
clear how the user is behaving.
66:46 - These are the actions that they can do.
66:48 - Okay?
66:50 - These are the things that you need
to store and the behaviors you need
66:54 - to expose for the action to happen.
66:57 - That's also right.
66:58 - What is the sequence of actions?
67:00 - What happens first?
67:01 - What happens second?
67:03 - That's not clear.
67:04 - And for that you need a sequence icon.
67:06 - So let us try doing that.
67:12 - This is what you call a timeline.
67:15 - The y axis basically is time, but in
67:18 - descending order.
67:18 - So you have
67:20 - three timelines here.
67:21 - One is
67:21 - that if a user does certain
actions things happen
67:25 - to a video, okay?
67:27 - And the video consuming service
actually uses a video's current.
67:31 - Seek time to get the next frame.
67:34 - So this might not just be a video,
it could be a video service, which is
67:38 - providing an api to consume
67:40 - the next frame of the video.
67:43 - We'll see how this
67:43 - happens.
67:44 - First the
67:45 - user sends a message.
67:47 - What message
67:48 - is this?
67:49 - Like we said earlier this is going
67:51 - to continue your information
and the video information.
68:05 - This is responded to by the video
consuming service immediately because
68:09 - it knows up to what point has a user,
68:11 - the video.
68:12 - So that is
68:14 - you return a timestamp.
68:15 - Now the user is going to make
another interaction, which is
68:19 - play or get video frame, right?
68:21 - So the video frame as this user or
68:26 - this video at a timestamp,
68:29 - and the tool I'm using here
68:30 - is lucid.
68:31 - As you can
68:32 - see, if you use tools, it helps
instead of reinventing the
68:37 - wheel or, doing it in
68:39 - a
half way.
68:39 - This is much
68:40 - better.
68:45 - The video consuming service
cannot get you the frame though.
68:48 - However, it's best that the user interacts
with the video consuming service, so
68:53 - it could send a message to the video
68:54 - service and say get me the
68:57 - video frame
69:06 - Okay.
69:06 - The important thing to notice
here is that the video service
69:10 - has no idea who the user
69:13 - is, whether they're
authenticated or not, to watch
69:16 - this video.
69:17 - And it just
69:19 - gives you a timestamp.
69:20 - Okay.
69:20 - I could have taken this request and
sent it directly to the video service.
69:25 - Okay.
69:26 - And the video service could
69:27 - say, sure, I don't care
69:29 - about what, who,
69:30 - which user is is trying
69:32 - to access this video.
69:33 - Just tell me the video and the time
stamp and I'll give you the response.
69:36 - But authentication would
be a bit of a problem.
69:41 - So that's the reason why I'm
assuming authentication is going
69:43 - to happen here for every frame that
69:45 - you ask.
69:46 - And then the
69:47 - video timestamp, as we mentioned,
I'm going to be sending back
69:57 - a response of a video frame.
70:06 - I could also send back multiple
frames in the hope that you
70:10 - can use them later.
70:12 - But
70:12 - I'm assuming that the
frame lasts for 10 seconds.
70:14 - And if you really feel like you can send a
request in between and get another frame.
70:19 - So it's a single frame and
this is then sent back.
70:29 - To the user.
70:30 - Okay, that's the interaction for a while.
70:34 - The moment you get a frame,
you want to repeat this action.
70:49 - And so the data keeps
70:50 - flowing.
70:51 - Very similar
70:53 - to how a TCP connection works
70:54 - actually.
70:55 - Initially
70:56 - you have some sort of a handshake, right?
70:59 - You get some initial information, set
up the connection, and then what's
71:01 - happening is you're constantly pinging.
71:04 - One of the
71:04 - drawbacks that I can
71:06 - see here in my diagram is that the video
consuming services are intermediately.
71:10 - There's so much communication happening
between the video service and the user.
71:13 - This is just wasting time.
71:15 - I don't know if that is worth
it, if just authentication.
71:20 - is worth completing
71:21 - our flow
71:22 - this much.
71:23 - You can put
71:24 - some authentication here in the
video service itself, so you'll
71:28 - save on two network calls, which
71:32 - is a lot.
71:33 - So yeah, maybe
71:35 - I should just take this, put
71:37 - this here and take
71:38 - this, put this
71:40 - over here.
71:41 - Don't go into
71:44 - the video consuming service.
71:46 - That's what we'll be doing in the code.
71:48 - So now we finally jump
71:49 - to coding.
71:50 - Remember to
71:51 - use the diagrams that we have made
as a reference because most of our
71:55 - thoughts and most of the interactions
are documented well over there,
71:59 - it would be a waste not to use it.
72:01 - The whole purpose of making these
diagrams is to take away the
72:05 - thinking effort required by coding.
72:07 - Coding is basically us typing
out or writing the things which
72:11 - have been mentioned or thought
through in these diagrams.
72:16 - Okay, that
72:16 - will speed things and
72:17 - also help you avoid mistakes.
72:20 - So the
72:21 - first class that we talked
72:22 - about
is a video class video.
72:27 - The state
72:29 - that we talked about is it has an id, it
has frames, so maybe a set of frames here,
72:39 - but then the frames are also ordered.
72:40 - So an area of frames
72:42 - make sense.
72:43 - And then some
72:45 - metadata.
72:46 - So in our case, I'll
just say meta data, json.
72:52 - Of course, in the real world, you
would actually have the creator
72:55 - of the video, the uploader of the
video, and many other parameters, the
72:58 - length of the video, everything else.
73:00 - But we don't need that
73:01 - right now.
73:03 - So I just
73:05 - create
73:08 - a class.
73:10 - That an ID
73:13 - helps you create classes
73:14 - much better.
73:16 - These classes
73:17 - that I'm creating are
just plain Java objects.
73:21 - You can use the same thought
73:23 - process for c plus for C
73:25 - shop and many other languages.
73:27 - Any object or in programming language.
73:29 - If you're coding in
73:30 - Python or Scala it might
73:33 - be slightly different, right?
73:35 - But the logic is very similar.
73:38 - Come to the point of defining things as
objects and the interactions between them.
73:44 - And finally, define the states
and the behaviors of every
73:48 - object and then put them out.
73:50 - Okay?
So this is largely language agnostic.
73:52 - This approach.
73:55 - You
have a video which needs
73:56 - a thing.
73:57 - A frame is going to be a bunch
of bites, so that's okay.
74:08 - And maybe it has a
74:09 - timestamp That is in
74:13 - thanks stamp.
74:14 - You also have a class of
user from the diagram.
74:17 - A user has a string id, it has
a string name string email.
74:24 - These are basically
74:25 - metadata.
74:25 - And we talked
74:27 - about some behaviors
that these classes need.
74:29 - So written return of frame,
when someone says get frame
74:43 - and which frame should we return?
74:45 - You should return
74:46 - the frame which is
74:48 - being called for a particular timestamp.
74:50 - So you see our class diagram
missed that we can go back
74:53 - and fix it or we can
74:56 - fix it in code.
74:56 - I would suggest fixing it in both
places because if the documentation
75:01 - is up to speed, it helps in timestamp.
75:06 - You can also have timestamp as an
75:07 - object.
75:07 - for, making sure
75:10 - that the inea is greater than zero and all
that, all the validations that you want.
75:14 - But I'm just keeping
75:15 - things simple.
75:15 - Pass on a
75:16 - timestamp.
75:17 - Here we are going to be
iterating over the frames.
75:20 - This can be improved of course, but
what you want to do is you want to go
75:26 - over the frames and return the timestamp
75:35 - and return the frame.
75:36 - Only if the timestamp of the frame
is less than the timestamp you
75:42 - have asked for less than equal to.
75:46 - And there also has to be some
sort of an end times time.
75:48 - So we can assume that every frame is of
75:50 - 10 seconds in which
75:52 - case the start time is this.
75:55 - This has to be less than equal to,
and the end time mentioned over
76:01 - here, plus 10, is greater than all
76:05 - equal to this time.
76:07 - Okay.
76:07 - Or rather greater than then
this frame belongs to this.
76:11 - If you don't get the frame,
then you just return none.
76:16 - You can also throw an
76:17 - exception here.
76:19 - Let's see.
76:21 - I would say throwing an exception makes
76:22 - sense because the meaning
76:25 - of an exception is that I didn't
know how to react to this.
76:30 - None would mean that, oh, you get
76:33 - blank.
76:33 - So if a timestamp
76:35 - of 20 hours is sent for a video,
having just one hour, a blank
76:41 - frame is not exactly what you want.
76:42 - You wanna say, oh, you're out of bounce.
76:44 - So
76:49 - index, under bounds
76:49 - exception being thrown
76:52 - here is going to be
76:56 - okay.
76:57 - Now there's another small
problem I see here, which is
77:00 - the magic constant of plus 10.
77:02 - You don't really want to do this.
77:03 - It doesn't
look good.
77:04 - . Because tomorrow
77:06 - if your frames get optimized and can
store 30 seconds of video, then you
77:10 - have to go and change it in the code.
77:12 - So you might have this in a constant,
in the video itself, let's say
77:16 - no, a class constant, so public
static in frame time equal to 10.
77:27 - And then what you have is if you
need to make any change, then you
77:31 - make a change in a single place.
77:34 - But
77:35 - even that would not
77:37 - be suggestible because this is
something related to the frame.
77:40 - So let's take that, put it in
the frame class, and then what
77:45 - you have is framed or framed.
77:49 - Time
77:52 - has to be this, but that is also,
77:56 - that's fine.
77:57 - It's good.
77:58 - There's just one.
78:00 - data point for the entire class.
78:03 - All of your frames
78:03 - have the same amount of
78:05 - frame time.
78:06 - It could be different, it could be that
78:09 - these frames some frames
78:11 - are really high quality.
78:12 - There's a lot of movement over there.
78:13 - So it's not even 10 seconds long.
78:14 - It's just two seconds long.
78:16 - And some
78:16 - frames are, like this
78:18 - coding frame
78:19 - over here.
78:19 - You can store
78:20 - 10, 15 seconds of video because
there's not much happening over here.
78:24 - There's not any face moving or something.
78:27 - So I'll just take this and
I'll leave it to the object,
78:32 - not the class, but the object.
78:35 - So it does not become a class property,
which is going to be for every object.
78:38 - It is defined by each object.
78:43 - So any timestamp,
78:50 - and then this becomes start timestamp.
78:55 - Alright, so this is.
78:57 - This
is better.
78:58 - I don't need
78:58 - to say, I don't need to
mention start timestamp.
79:01 - I just said timestamp has to be greater.
79:05 - Okay.
79:05 - This is much more flexible code.
79:08 - This is what will set you apart from just
79:11 - the portal.
79:12 - You're going
79:12 - to be a engineer then.
79:18 - Okay.
79:18 - So now we
79:19 - have a user you can get
79:22 - their id.
79:24 - This is not really related to
what we are doing, but that's
79:30 - okay in get ID and return the id.
79:42 - Okay.
The next class is more interesting.
79:46 - There's watched video, which
is a class here we have the ID.
79:56 - Of this action we have the video id.
80:02 - We also have the user who's actually
watching this video, who's doing this
80:06 - action, and we have a seek bank stamp.
80:09 - So that is seek tank.
80:14 - Okay, we mentioned that
there's going to be
80:22 - a method to get seat time.
80:28 - Important to notice that APIs having
rest have the keyword, get inside them
80:34 - often, like you can't mention that
you're posting something or getting
80:37 - something, but the objects here can have
a get of their own because you don't
80:42 - exactly know what's happening, right?
80:44 - It's not a
80:45 - HTP API here it's a Java
80:48 - object, so it gets 10.
80:49 - Makes more sense here.
80:51 - So this defines
80:52 - everything.
80:53 - Except for
80:55 - the last couple of behaviors, which are
actions by a user or actions by a system.
81:01 - So the video consuming
service, show me the seek time.
81:05 - This is going to be a public ink, seek
time, return for this watched video,
81:18 - seek time, had a user ID and a video id.
81:29 - Let's assume that watched
video is a database call,
81:47 - and once you have this watch video,
what you want to do is you want
81:49 - to get this done and return that.
81:52 - Okay.
81:54 - For this to
81:58 - work, we need to have a database,
82:11 - which we are going to
create as a dummy object.
82:15 - Okay?
82:16 - Create that and turn on.
82:22 - Okay.
82:22 - This is great.
82:23 - It gives you the seek time.
82:25 - And then finally, the other
API that we look for is class.
82:32 - We do service.
82:35 - So the final class is going to be using
a file system, let's say, because videos
82:40 - are usually stored in the file system.
82:44 - And let's define that
class, this class file
82:48 - system.
82:49 - Okay.
82:50 - Now there's
82:52 - a public method similar to the previous
service, which is going to be returning
82:58 - a frame.
82:59 - And that is
83:00 - get frame for a particular video
with a video ID and a timestamp.
83:13 - Okay.
And how's the interaction going to happen?
83:14 - We first need the video, so
let's say our file system gets
83:21 - us a video with this video id
83:30 - what?
83:31 - Once you have
83:31 - the video you need
83:33 - to return the frame
corresponding to this tank stamp.
83:42 - And that's it.
83:44 - That's pretty much it.
83:45 - You have something backing your services.
83:48 - Some sort of database or
83:49 - file system.
83:51 - Once you have
83:52 - them persistent, you can always get
to them and pull data from them.
83:58 - Once these systems are being
backed by a database, then you
84:02 - can actually manipulate this data
84:04 - that you have by exposing
84:06 - APIs.
84:07 - And the best way to manipulate the data
is to abstract them out into objects
84:11 - which have their own state and behavior.
84:13 - So the code is simplified and you
can reuse a lot of the behaviors
84:17 - for different types of use cases.
84:20 - This would summarize a
low level design process.
84:23 - Alright then that's a reasonably well
detailed introduction to system design.
84:28 - If you want to look at more videos on
system design, there's a free section
84:33 - that I have on Interview Ready, which
is all about the design patterns and the
84:37 - basics of system design, load balancing,
84:40 - rate limiting charting and scaling.
84:43 - And if you
84:44 - want a more advanced version
of system design, I have a paid
84:48 - section in that same course.
84:50 - I would suggest go ahead and check
out the free resources first.
84:54 - If you really like it and you
think that you know it's time to
84:56 - level up, go for the paid section.
84:59 - All the best.