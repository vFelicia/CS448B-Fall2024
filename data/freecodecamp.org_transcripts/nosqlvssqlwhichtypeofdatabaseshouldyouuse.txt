00:00 - hello everyone here on the free codecamp
00:02 - channel today
00:04 - my name is anu kubo and i'm a software
00:06 - developer as well as course creator
00:07 - online in this online course i'll be
00:10 - talking to you about the differences
00:12 - between the terms sql and nosql when it
00:15 - comes to databases as well as which kind
00:17 - of database you use when and why
00:20 - in this course we are going to go back
00:22 - to basics and look at what exactly a
00:24 - database is and how it's defined we're
00:27 - then going to look at database design
00:29 - and why it's important what a database
00:31 - management system is we'll then look at
00:33 - relational databases followed by an sql
00:35 - crash course we will then move on to
00:38 - look at non-relational databases
00:40 - followed by sql vs nosql as well as the
00:43 - pros and cons of using relational
00:44 - databases versus non-relational ones we
00:47 - will finish off with some use cases and
00:49 - then a nosql crash course and don't
00:52 - worry you'll leave this course with a
00:54 - much better idea of when to use what
00:56 - database technology
00:58 - before we dive into the types of
01:00 - databases that exist let's talk about
01:02 - why they matter to your career as a
01:04 - developer
01:06 - data is an important part of it
01:08 - without data computers and even the
01:10 - internet would be a pretty uninteresting
01:12 - place
01:13 - if you are aiming to become an
01:15 - application or full site developer
01:17 - databases are your friend the market
01:19 - today pretty much expects fluency with a
01:22 - relational model but there is an upside
01:24 - here according to stackoverflow's recent
01:27 - surveys nosql skills can really help
01:29 - differentiate you from the pack for
01:31 - example in their 2021 survey the top
01:34 - four top paying database salaries were
01:36 - all nosql databases dynamodb
01:40 - elasticsearch cassandra and redis
01:42 - so go grab a hot beverage roll up your
01:45 - sleeves and let's get started if you
01:47 - think the ranger choices are a little
01:48 - overwhelming now just wait until you get
01:51 - into the universe of javascript
01:52 - programming so what are we waiting for
01:55 - let's get to it by the way this course
01:57 - is brought to you by data stacks if
01:59 - you'd like to follow along with code
02:00 - examples you can sign up for the data
02:02 - such as db free plan and a few clicks if
02:06 - you want a deep dive into relational and
02:08 - non-relational databases after the
02:09 - course check out the intro to sql course
02:12 - and the introduction to nosql course
02:15 - right here on the free codecamp channel
02:17 - now let's start with taking a moment to
02:20 - go back to basics and talk through what
02:22 - exactly a database is a database is a
02:25 - systematic collection of data in the
02:28 - world of computing this collection of
02:29 - data can be accessed electronically
02:32 - you can access it electronically to get
02:34 - data add data delete data or update data
02:38 - small databases can usually be stored on
02:41 - a file system on a simple storage device
02:44 - this can be something like a sd card a
02:46 - hard drive or a usb
02:48 - larger databases on the other hand while
02:51 - in the past on mainframes or beefy
02:53 - individual servers are usually hosted
02:55 - today on computer clusters or cloud
02:58 - storage
02:59 - a file system is essentially something
03:00 - that lives on a storage device such as a
03:03 - hard drive it defines how files are
03:05 - named stored and retrieved
03:07 - for example imagine you are using your
03:10 - laptop which is a mac and you plug in
03:12 - your storage device or hard drive which
03:13 - contains data into your mac in order to
03:16 - retrieve a file that you put on it
03:19 - now without any kind of file system
03:21 - implemented your max operating system
03:23 - won't be able to find the data that you
03:25 - are looking for it would all be a big
03:27 - mess essentially
03:28 - file systems bring in order this is the
03:31 - same for computer clusters on which
03:33 - large databases are usually hosted on
03:36 - now so far we have looked at the example
03:38 - of one hard drive but what if you have
03:40 - way more data than we can fit on this
03:42 - tiny little hard drive what if you need
03:45 - 10 hard drives what if you need 10
03:47 - computers or more
03:49 - this is what a computer cluster is you
03:51 - are essentially linking a bunch of
03:53 - computers together across a network to
03:55 - work as one
03:56 - a cluster can be viewed as a single
03:58 - system or in other words one computer
04:01 - clusters can be grouped together under
04:02 - one control plane which is what manages
04:05 - connecting all the computers together
04:06 - and the outside communications
04:09 - fun fact the first computer database was
04:11 - sabre the airline reservation system the
04:14 - process for reservations outgrew the
04:16 - paper card system they used and ibm came
04:18 - up with a new solution in the 1960s to
04:21 - help scale up operations at american
04:24 - airlines
04:25 - so
04:26 - that is how we can store our databases
04:28 - so on a file system for small databases
04:31 - and things such as computer clusters for
04:33 - large databases
04:35 - but what about databases themselves how
04:38 - are they organized
04:39 - this is all down to database design
04:43 - there are many ways a database can be
04:45 - designed heck you could even design your
04:47 - own database if you really wish all
04:48 - you'd need to do is decide on a database
04:51 - model
04:51 - a database model will determine exactly
04:53 - how you want your data to look and not
04:56 - only that but how you want it to
04:58 - interact with other data
04:59 - for example you may have a database
05:02 - model that follows the idea of a table
05:04 - this will mean that all your data has to
05:06 - fit in the structure
05:08 - now if i'm collecting data on how well
05:10 - each student did as a specific subject
05:12 - in terms of grades then a table would be
05:14 - great however what if i also then decide
05:17 - i want to add how much the student
05:19 - enjoyed the subject then this table
05:21 - would not work we would have to redesign
05:24 - our database and perhaps use a different
05:25 - database model perhaps a document model
05:28 - would work better
05:30 - this is why database design is so
05:32 - important and has to be thought of early
05:34 - on in any project
05:36 - here are just some examples of database
05:38 - models as you can see there's a lot we
05:41 - will go into the most popular ones like
05:43 - the relational model document model
05:45 - white column and key value model and how
05:47 - they define the modern database
05:48 - landscape first off though let's talk
05:51 - about how developers interact with these
05:52 - databases
05:54 - a database management system or dbms is
05:56 - a way for us to essentially communicate
05:59 - with our database
06:00 - think of it as a layer or interface
06:02 - between the data and our little fingers
06:04 - on the keyboard it allows us to get
06:07 - existing data create new data update
06:09 - data and delete data from our database
06:12 - we have our data in our database here
06:15 - then we have the dbms and then we have
06:17 - the end user great any given database
06:21 - management system may provide one or
06:23 - more models we'll talk about the
06:24 - multi-modal databases briefly at the end
06:27 - and for this tutorial we are going to
06:29 - use a cloud database since they all
06:32 - usually provide a free plan or tier and
06:34 - it's much faster than downloading
06:36 - installing and configuring it
06:38 - then we can just focus on the code and
06:40 - core concepts i use astrodb a lot so
06:44 - i'll be using it since it allows me to
06:46 - create different types of nosql
06:47 - databases in one place then i'm not
06:49 - switching platforms all the time during
06:51 - the course
06:52 - however you don't have to use it there
06:55 - are plenty of other database management
06:56 - systems out there some only deal with
06:59 - one type and some are multi-modal which
07:01 - we'll talk about again later on
07:04 - here is a list of some popular dbms you
07:07 - will come across as a developer
07:09 - now i'm going to show you what a typical
07:12 - cloud database experience is like these
07:13 - days to get started with astrodb sign up
07:16 - for free just go ahead and do the
07:19 - process of that by clicking on the sign
07:21 - up to try astra for free button
07:23 - once here i want you to sign up i'm
07:26 - going to go ahead and sign in as i've
07:28 - already created an account for this
07:30 - wonderful
07:31 - here is the dashboard we are on the free
07:33 - current plan which is more than enough
07:35 - for research and development work
07:37 - without being prompted for a credit card
07:40 - so what we're going to have to do is
07:42 - create our first database just go ahead
07:44 - and click the button and it will take
07:46 - you to this page once on here let's name
07:49 - our database something i'm going to call
07:50 - this tutorial as it is for tutorial
07:53 - purposes and the schema name or as
07:55 - apache cassandra calls them key spaces
07:58 - now we're going to create a few key
08:00 - spaces the first one we create is going
08:02 - to be called wide column as it's going
08:03 - to be for creating a wide column
08:05 - database
08:06 - let's go ahead and do that now we're
08:08 - going to select a provider and region
08:10 - again i'm just going to choose the one
08:12 - closest to me so this will be mumbai
08:15 - india and let's go ahead and click
08:17 - create
08:18 - next you'll see this page show up in
08:20 - which we're going to be given all our
08:22 - tokens and necessary things to
08:24 - communicate with our database so here's
08:27 - what it looks like just copy all of this
08:28 - and make sure to keep it somewhere safe
08:30 - for the upcoming tutorial and go ahead
08:33 - and click on the go to database button
08:35 - great
08:36 - at the moment this is pending we are
08:39 - going to have to wait for this to be
08:40 - active before we can use it but as soon
08:42 - as it's active you will see the status
08:44 - change to active so great we know this
08:47 - is active because we can see options
08:48 - such as connect cql and more in the tabs
08:51 - above and we have our first key space
08:53 - which is white column under the word key
08:55 - spaces below
08:57 - we could also add more schema or key
09:00 - spaces as they are called in cassandra
09:02 - which we will be doing later see
09:04 - much easier than downloading installing
09:06 - and configuring it just so you can play
09:08 - with some code
09:10 - most cloud databases are pretty similar
09:12 - in how to create a database so you can
09:13 - start coding straight away
09:16 - wonderful let's move on
09:18 - now that we know how to get set up with
09:20 - our dbms let's get into talking about
09:22 - the different types of databases we
09:24 - could have
09:25 - the first thing we are going to look at
09:26 - is the relational database we are going
09:29 - to do this in order to understand the
09:30 - differences between sql and nosql
09:33 - but to get to that point we still have a
09:35 - little bit of knowledge to cover and
09:37 - what better place to start than looking
09:39 - at the most familiar and most strongly
09:41 - consistent database in my eyes which is
09:43 - the relational database
09:45 - as we now know databases depend on their
09:48 - design and what type of models they use
09:51 - relational databases provide a store of
09:53 - related data tables these tables have a
09:56 - fixed schema use sql or the structure
09:58 - query language to manage data and
10:01 - support asset guarantees
10:03 - in general rdbms assumes you can
10:06 - structure your data and trades off the
10:08 - strongest consistency guarantees and
10:10 - ease of use for ensuring consistency
10:13 - with scalability volume and availability
10:16 - there is a great deep dive on how to
10:18 - design a relational database right here
10:20 - on youtube if you want to learn more
10:22 - popular open source examples here are
10:25 - mysql postgres and mariadb
10:29 - the relational database uses that
10:31 - relational model and looks something
10:33 - like this kind of a table with columns
10:35 - and rows are linked together if we wish
10:38 - usually each table has some kind of
10:40 - theme going on or in other words entity
10:43 - type just like we saw with the grades
10:45 - for our students before
10:47 - in that instance each row has a student
10:50 - and each column was a class topic
10:52 - in relational databases each row has a
10:54 - unique identifier so we can pick it out
10:57 - thanks to this unique identifier we can
10:59 - now also link these rows or students to
11:02 - other tables such as this one which each
11:04 - student's enjoyment level of topic we
11:06 - can even take this one step further to
11:08 - really clean up and take out the names
11:11 - of the students and put them in a third
11:13 - table now all the data we want to be
11:15 - linked is linked thanks to the id number
11:18 - these links are called foreign keys and
11:20 - relational design
11:22 - sounds simple right
11:24 - now i'm going to show you how to create
11:25 - your own using sql for creating clearing
11:28 - and maintaining databases i'm going to
11:30 - be showing you how to do this with some
11:32 - slides sql or the structured query
11:35 - language is a language that became
11:36 - prominent in the late 1970s for managing
11:39 - data and relational database management
11:41 - systems it's worth noting that while
11:43 - ansi sql does indeed define a standard
11:46 - syntax each rdbms has some subtle
11:49 - platform specific considerations some of
11:52 - them in the syntax of the code outside
11:54 - the standard anci sql specifications and
11:57 - some in how the sql query execution
12:00 - engine functions at runtime many also
12:02 - have wholly proprietary extensions for
12:04 - more advanced features
12:10 - now let's see what creating a schema and
12:12 - table in an sql database is like
12:15 - let's try a simple example together
12:18 - here is what the syntax for sql looks
12:20 - like for example to create a student
12:23 - table of grades we would use a statement
12:26 - this statement is create table
12:28 - after this statement we then define what
12:31 - we want to choose to call our table
12:33 - i'm going to choose to call it student
12:35 - grades
12:37 - next we define our columns
12:39 - on this occasion we will define column 1
12:41 - as the id
12:42 - column 2 as the name column 3 as the
12:45 - subject math column 4 as the subject art
12:49 - and column 5 as the subject geography we
12:52 - also need to find the type that goes
12:54 - into each column
12:55 - for example we can have varchar integer
12:58 - date and much more
13:00 - we are going to define our id column as
13:03 - taking integers our name column as
13:06 - varchar so it takes characters or text
13:09 - and for the other columns we are going
13:11 - to put varchar as well as we want to put
13:13 - 8 out of 10.
13:15 - if you'd like to just put in an 8
13:16 - however you could choose to use integers
13:19 - instead
13:20 - we can also define a primary key the
13:23 - primary key constraint uniquely
13:25 - identifies each record in a table
13:28 - in this example we will want our id to
13:30 - be that unique identifier
13:32 - primary keys must contain unique values
13:35 - and cannot contain null values
13:37 - finally we put in the semicolon and the
13:40 - statement and press enter
13:42 - great
13:43 - now that we have defined our table let's
13:46 - get to putting data into the table that
13:49 - we have just made
13:50 - to put in data into our table we use two
13:52 - statements insert into and values the
13:56 - full statement would look like this we
13:58 - would use the command insert into and
14:01 - then we will use whatever we decide to
14:03 - call our table in this case it was
14:05 - student grades
14:06 - and then we will rewrite the column
14:08 - names that we want to put data into i'm
14:10 - just going to put in all of them
14:12 - on the next line i'm going to use the
14:14 - values command to insert data into those
14:16 - columns
14:17 - and of course we need a semicolon to end
14:20 - this statement
14:21 - inserted one line into our database but
14:25 - how do we actually look at our database
14:27 - well for this there's a very simple
14:29 - command we use the command select
14:31 - followed by a star which means all
14:34 - from our table called student grades
14:37 - okay
14:38 - so
14:39 - great now let's test it out for this i'm
14:42 - going to use the sql playground on
14:46 - w3schools and all i'm going to do is
14:48 - literally paste in the commands that we
14:51 - wrote before
14:52 - so we need to create a table first so
14:55 - here we are creating a table called
14:57 - student grades with an id name math art
15:00 - and geography column as well as defining
15:02 - our primary key and hitting run sql
15:05 - okay so that has now been added to our
15:08 - database the next thing we need to do is
15:10 - add in our
15:12 - line
15:13 - so add in some data so i'm going to
15:15 - delete this and just use this command so
15:18 - this is going to insert into student
15:20 - grade it's going to insert the id the
15:22 - name of the student the math the art and
15:24 - geography scores so let's run that as
15:27 - you can see changes have been made to
15:29 - the database run row has been affected
15:32 - and now to get the data well we use
15:34 - select all
15:36 - from and whatever we called the table
15:39 - which is student
15:41 - grades
15:43 - and you will see our table with the id
15:46 - the name the score the student got for
15:48 - maths art and geography
15:51 - wonderful
15:52 - so that was a quick crash course about
15:54 - making relational databases using sql
15:58 - let's continue
16:00 - now this is not an sql tutorial i'm
16:03 - simply giving you a very quick crash
16:05 - course and how to use it for the purpose
16:07 - of this tutorial
16:09 - sql has a lot to offer and is a very
16:11 - well thought out language that takes a
16:13 - while to learn
16:14 - if you would like to deep dive into the
16:16 - topic after this course then please do
16:18 - check out some tutorials on this that we
16:20 - have on free coca
16:22 - so we now have a good idea about what a
16:24 - relational database looks like and how
16:27 - we can manage data in it using sql the
16:30 - structured query language
16:32 - but there are also such things as
16:34 - non-relational databases and there are a
16:37 - few of them
16:38 - we are not going to look at all of them
16:40 - we're simply going to look at the three
16:41 - most popular ones
16:43 - so we are going to look at the wide
16:45 - column database type the document
16:47 - database type that uses the document
16:49 - model and the key value database type
16:52 - which you guessed it uses the key value
16:54 - model
16:55 - all of these non-relational databases
16:57 - are commonly referred to as nosql
16:59 - databases and whilst you might be
17:01 - thinking ah so they do not use sql the
17:04 - structure query language that we just
17:06 - learnt you would be totally wrong
17:08 - nosql means not only structured query
17:11 - language which allows you to use the
17:13 - language or not use it to get the data
17:15 - and it's considered to be an approach to
17:17 - database management
17:19 - nosql's appearance on the scene is noted
17:22 - as somewhere around the 2000s
17:25 - so if we compare this on a table you
17:27 - will see here that under sql i put an
17:30 - icon to represent a relational database
17:32 - as we can use sql to query relational
17:35 - databases we now know that we can also
17:38 - use sql to query some non-relational
17:40 - databases
17:42 - or at least the ones that offer
17:43 - relational as a secondary database model
17:46 - and a sql interface anyway
17:49 - nosql uses different query languages for
17:51 - key value document and tabular or white
17:55 - column and so on
17:57 - now when people look at nosql and sql
18:00 - they might be tempted to compare the two
18:02 - but by now we know we can't do this
18:05 - why
18:06 - this is because sql is a database
18:08 - management approach and sql is a query
18:11 - language so two completely different
18:13 - things
18:14 - it might be better going forward to
18:16 - start referring to nosql databases as
18:19 - non-relational databases
18:21 - so let's go ahead and switch that so we
18:23 - can compare them to relational databases
18:25 - from now on
18:27 - okay great
18:28 - so now that we have that down let's look
18:31 - at the pros and cons of each
18:33 - first off let's look at standardized
18:36 - schema when working with relational
18:38 - databases you can have the benefit of
18:40 - schema being standardized for example
18:43 - imagine i'm working at a pizza
18:44 - restaurant as a chef and each waiter
18:46 - instead of showing people menus for
18:48 - people to pick from started just asking
18:50 - them what kind of pizza they want you
18:53 - would have a huge range of pizzas to
18:54 - make and this would add some level of
18:56 - difficulty to your job
18:58 - in this scenario the menu is built using
19:01 - a pizza schema it comes with a list of
19:03 - well-known pizzas that people can pick
19:06 - and you can make
19:07 - it's the same with data and relational
19:10 - databases by providing a schema that
19:12 - everyone's familiar with and used to
19:14 - using it makes working with relational
19:17 - databases worldwide a whole lot easier
19:20 - now
19:21 - some people might find this rigidity a
19:23 - con
19:24 - but in general it's viewed upon
19:26 - favorably
19:28 - next up let's look at large user
19:29 - communities another pro we have is that
19:32 - relational query languages such as sql
19:35 - have a larger user community
19:37 - as sql has been around for nearly 50
19:39 - years it has a strong community of
19:41 - supporters as well as a lot of help and
19:43 - resources out there for learning
19:44 - purposes
19:46 - next up is standardized query language
19:49 - another pro for relational query
19:51 - languages such as sql is that it's
19:53 - considered to be quite an easy language
19:55 - to learn as it uses simple keywords
19:58 - we use these keywords in managing and
20:00 - searching through databases
20:02 - anyone that's worked with spreadsheets
20:04 - can relate to this model as it's often
20:06 - covered in university courses
20:09 - next up we have acid the final pro we
20:12 - have for relational databases is that
20:14 - they tend to be acid compliant which
20:16 - stands for atomicity consistency
20:19 - isolation and durability you will see
20:21 - this acronym pop up a lot
20:24 - this level of compliance keeps tables in
20:26 - sync and guarantees the validity of
20:28 - transactions
20:30 - now let's look at the cons of relational
20:32 - databases first up is difficulty
20:35 - clustering the main cons of traditional
20:37 - databases are that they tend to scale up
20:40 - vertically
20:41 - what this means is that the only way to
20:43 - scale your database is to increase your
20:45 - ram cpu or ssd on your existing server
20:48 - or to migrate to a larger more expensive
20:51 - one altogether you'll need to
20:52 - continually increase hard drive space as
20:55 - your data grows and you'll need faster
20:57 - machines to run evolving and more
20:58 - sophisticated technologies the database
21:01 - vendor you'll use will likely require
21:03 - you to periodically level up your
21:05 - hardware just to run their latest
21:06 - releases
21:08 - in this environment hardware can quickly
21:10 - become outdated
21:12 - each upgrade is expensive and resource
21:14 - intensive most relational database
21:17 - hardware also needs ongoing everyday
21:19 - maintenance
21:21 - next up is data normalization developed
21:24 - at a time when the cost of data storage
21:26 - was high relational databases such as
21:29 - sql ones attempted to negate the data
21:31 - duplication
21:32 - each table has different information and
21:35 - they can be connected and queried using
21:37 - common values
21:38 - however as these databases get large the
21:41 - lookups and joins required between
21:43 - numerous tables can slow things down and
21:45 - be too complex to code and debug
21:48 - next up is schema first
21:50 - sql relational database schemas must be
21:53 - defined before use
21:55 - once in place they are inflexible and
21:57 - modifications are typically difficult
21:59 - and have a wide blast radius affecting
22:02 - both data and application
22:04 - non-relational databases vary in this
22:06 - respect
22:07 - for example document databases do not
22:10 - require schema up front while they say
22:12 - wide column does for that reason
22:14 - substantial time needs to be invested in
22:17 - upfront planning before the database is
22:19 - ever put into production so it follows
22:21 - that they're only appropriate when all
22:23 - your data is also structured and you
22:25 - don't expect much change either in
22:27 - volume or data type
22:29 - next up is resource intensive scaling
22:32 - as mentioned earlier relational
22:34 - databases normally scale vertically by
22:37 - assigning more resources to the existing
22:38 - hardware investment
22:40 - this can be expensive and time consuming
22:43 - newer relational databases or cloud
22:46 - services aka new sql can horizontally
22:49 - scale a relational sql database through
22:52 - partitioning or sharding
22:54 - make sure to understand how the addition
22:56 - of partitioning or sharding for rdbms
22:59 - affects acid consistency guarantees as
23:02 - it can be different from non-cluster
23:04 - deployments
23:06 - remember that all rdbms or relational
23:09 - database management systems are subject
23:11 - to the limitations of cap theorem the
23:14 - moment a network link is introduced
23:17 - now that we have covered the pros and
23:18 - cons of a relational databases let's
23:20 - look at the pros and cons of
23:22 - non-relational databases
23:25 - first up is continuous availability with
23:28 - non-relational databases data is
23:30 - distributed across multiple servers and
23:32 - regions so there is no single point of
23:35 - failure as a result non-relational
23:37 - databases are designed to be more stable
23:39 - and resilient with continuous
23:41 - availability and zero downtime
23:43 - particularly with cloud deployments
23:46 - next up is query speed non-relational
23:48 - databases are denormalized without worry
23:51 - or data duplication for example in white
23:54 - column databases the information needed
23:56 - for a particular query will often be
23:58 - stored together no joins required
24:01 - this makes lookups easier especially
24:03 - when working with large data volumes
24:06 - it also means non-relational databases
24:08 - can be very fast for primary key or
24:10 - indexed queries
24:12 - for data without an index however query
24:14 - speed can taper off as non-relational
24:16 - databases reach high levels of scale
24:18 - without the right data model
24:21 - next up is agility
24:23 - non-relational databases were developed
24:25 - as large data storage costs were
24:27 - beginning to drastically drop and
24:29 - systems were being distributed and or
24:31 - deployed on the cloud
24:32 - data duplication was no longer a concern
24:35 - non-relational schema are generally
24:37 - designed to give the developers more
24:39 - control over database integrity and
24:41 - schema as well as trade-offs between
24:43 - consistency availability and performance
24:47 - there are a variety of different
24:48 - non-relational approaches
24:50 - acid-compliant databases hide the
24:52 - complexity of a very costly operation
24:55 - and give you no other choices with the
24:57 - approach to trading of consistency for
24:59 - performance
25:00 - also there are times where all those
25:02 - guarantees of the relational models
25:04 - simply aren't truly needed most
25:06 - developers have been conditioned to
25:08 - reach for the high data integrity
25:09 - relational model without challenging
25:11 - themselves to think deeply about where
25:13 - those guarantees are truly needed
25:16 - however understanding the data model now
25:18 - and in the future is arguably the most
25:20 - important thing so future business
25:22 - requirements continue to align with the
25:23 - strengths of the approach you've chosen
25:25 - agility comes in other forms as well for
25:28 - example document databases don't have to
25:30 - have predefined schemas instead they are
25:33 - dynamic with the ability to handle all
25:35 - types of data including structured
25:37 - semi-structured unstructured and
25:39 - polymorphic data you can skip upfront
25:42 - database schema definitions and get
25:44 - right to development
25:46 - developers can redefine json document
25:48 - structure anytime and easily add data
25:50 - types and fields at runtime without
25:52 - requiring a schema change
25:55 - all of this makes the nosql approach a
25:57 - great fit for modern agile development
25:59 - teams
26:00 - the flexibility and adaptive nature of
26:02 - non-relational databases makes them a
26:04 - great fit for organizations that have a
26:06 - variety of data types and expect to
26:09 - continuously add new features and
26:10 - functionality
26:12 - non-relational databases are not one
26:15 - size fits all
26:16 - unlike the relational databases they
26:18 - aren't constrained to a single
26:19 - normalized data model a single approach
26:22 - to consistency or single approach
26:24 - indexing in their quest for scalability
26:27 - and availability at scale
26:29 - next up we have low cost
26:32 - non-relational databases scale out
26:34 - horizontally making it cost effective to
26:36 - expand capacity rather than upgrading
26:39 - expensive hardware they can cheaply
26:41 - expand by simply adding commodity
26:43 - service or cloud instances
26:45 - open source non-relational databases
26:47 - provide affordable options for many
26:49 - organizations they are a good fit for
26:52 - cloud computing and handle extremely
26:54 - large and quickly growing data sets
26:57 - now let's move on to the cons
27:00 - next up is no standardized query
27:02 - language there isn't a standard language
27:04 - to conduct no sql queries
27:07 - some like key value databases are so
27:09 - simple they don't need one
27:11 - other nosql systems even provide direct
27:14 - support for ncsql
27:16 - the syntax used to query data varies for
27:18 - the different types of non-relational
27:20 - databases but unlike relational
27:23 - databases where there is just one easy
27:25 - to learn language to master nosql has a
27:28 - steeper learning curve sure each
27:31 - relational sql execution engine does
27:33 - certain things a little differently has
27:35 - proprietary extensions and so on but at
27:38 - least syntactically they all have the
27:40 - ansi sql standard syntax in common
27:43 - for example it might be difficult for a
27:45 - developer to quickly get up to speed
27:47 - working on a wide column database if all
27:50 - their prior experience for example
27:52 - consists of building and managing graph
27:54 - databases
27:55 - however there is an emerging trend to
27:57 - start exposing databases as de facto or
28:00 - popular apis it's a helpful alternative
28:02 - for many developers who are able to
28:04 - trade off some level of performance for
28:06 - developer productivity
28:08 - using database api gateways saves on you
28:11 - hard coding what would have otherwise
28:13 - been boilerplate data access code
28:16 - also using apis like rest craftql json
28:20 - grpc may already be familiar to many app
28:22 - developers overcoming some concerns here
28:25 - about standardization
28:28 - next up we have the smaller user
28:30 - community developers have been using
28:32 - non-relational databases or nosql
28:34 - databases for more than a decade and the
28:37 - community is growing quickly however
28:39 - it's still less mature than the sql
28:42 - community so it could be harder to solve
28:44 - undocumented issues
28:46 - there are also fewer consultants and
28:48 - experts on the nosql side
28:51 - next up let's look at developer skills
28:53 - required flexibility comes with a price
28:55 - with a variety of approaches found in
28:57 - non-relational databases there's more to
28:59 - learn this as we know is unlike learning
29:02 - how to use sql which is relatively
29:04 - simple
29:05 - even the simplest of nosql queries will
29:08 - still likely require programming
29:09 - experience or possibly to learn an api
29:13 - this means more technical and costly
29:15 - staff like developers or data scientists
29:17 - we need to perform the queries
29:20 - next up is data retrieval and
29:22 - consistency the distributed nature of
29:24 - non-relational databases enable data to
29:27 - be available faster however it can also
29:29 - make it more difficult to ensure the
29:31 - data is always consistent
29:33 - queries might not always return updated
29:35 - data and is possible to receive
29:37 - unaccurate information
29:39 - with its distributed approach the
29:41 - database could return different values
29:43 - at the same time depending on which
29:45 - server happens to be queried
29:47 - this is one of the reasons some
29:49 - non-relational databases don't achieve
29:51 - acid level compliance
29:53 - consistency is the c in acid which
29:56 - states that the data must be valid and
29:58 - consistent at the start and end of a
30:00 - transaction
30:01 - instead most non-relational databases
30:03 - adhere to base consistency models
30:06 - whether e stands for eventual
30:07 - consistency in other words the data will
30:10 - be consistent at some point later on
30:13 - different non-relational databases vary
30:15 - in their approaches to consistency and
30:17 - transactions so it's difficult to
30:19 - generalize
30:20 - in the real world this is often a very
30:22 - small delay only of a few milliseconds
30:24 - so for many applications that likely
30:26 - won't matter for example social media
30:29 - posts going live or an online shopping
30:31 - cart being updated that won't really
30:32 - matter too much
30:34 - in those situations lower latency and
30:36 - high availability outweighs the value of
30:38 - providing the exact same data at the
30:41 - exact times uses
30:44 - however think of when you make an online
30:46 - stock purchase then it would really
30:48 - matter
30:49 - non-relational databases value speed and
30:52 - availability over consistency compared
30:54 - to relational databases
30:57 - each project must decide if that aligns
30:59 - with their goals
31:01 - now that we have covered that it's time
31:03 - for a quick crash course and learning
31:05 - about some non-relational databases for
31:08 - a full tutorial on nosql check out the
31:11 - intro to nosql right here on
31:13 - freecodecamp
31:14 - our quick crash course will include
31:16 - looking at the document database type
31:19 - the key value database type and the wide
31:22 - column database type so let's do it
31:26 - the first one we're going to look at is
31:27 - the wide column database type
31:30 - now as astrodb is built on apache
31:33 - cassandra we're actually going to be
31:34 - using cql or the cassandra query
31:37 - language to demonstrate some of the
31:38 - different approaches to nosql
31:41 - the cql query language is a subset of
31:44 - sql so the basic commands we're using
31:46 - here in this video are exactly the same
31:49 - okay so just so we understand we are
31:51 - going to be using cql the query language
31:54 - which is very similar to sql however
31:56 - we're going to be using to create a
31:58 - non-relational database and on this
32:00 - occasion the non-relational database we
32:02 - will be using is a wide column database
32:05 - okay
32:06 - sounds confusing don't worry we're going
32:08 - to go into this in a lot more detail
32:10 - coming up when approaching your
32:12 - databases choices in general it's
32:14 - helpful to understand the models for the
32:16 - concepts behind them that you like to
32:18 - use as points of comparison
32:20 - carnage melon's database of databases
32:22 - provides an excellent much comprehensive
32:24 - technical resource in this regard but
32:27 - pragmatically here's a few important
32:28 - aspects for comparing dbms
32:34 - in the spectrum of non-relational
32:36 - databases wide column aka column family
32:39 - is sort of in the middle of a spectrum
32:41 - with relational databases on one side
32:44 - and key value on the other
32:46 - on one side you have rdbms or relational
32:49 - database management system and acid dbms
32:52 - with lots of built-in features and
32:53 - performance overhead to the much more
32:55 - simplistic less feature rich but way
32:57 - faster dbms like key value
33:00 - popular open source options here include
33:02 - apache cassandra apache hbase and many
33:05 - others
33:06 - they are often used for operational app
33:09 - database tasks like scaling time series
33:11 - data e-commerce or inventory management
33:14 - content management personalization
33:16 - recommendations fraud detection
33:19 - transaction logging tracking and many
33:22 - other right-intensive infrequent update
33:24 - use cases
33:26 - wide column stores like apache cassandra
33:28 - use the notion of column families a
33:30 - database object that contains multiple
33:32 - columns of related data that are used
33:34 - together similar to traditional
33:37 - relational database management tables
33:39 - within a given column family all data is
33:42 - stored in a row by row fashion such as
33:44 - the columns for a given row are stored
33:46 - together rather than each column being
33:48 - stored separately
33:50 - put another way a column family is the
33:52 - key value pair where the key is mapped
33:55 - to a value that is a set of columns
33:58 - in analogy with the relational databases
34:00 - a column family is a table
34:02 - each key value pair being a row
34:05 - for developers y column tables can
34:07 - present themselves as a row and column
34:09 - table that is familiar and easy to work
34:11 - with in code or apis
34:14 - understanding how the primary key in y
34:16 - column database is different from
34:18 - relational primary keys is essential
34:20 - followed by proficiency in data modeling
34:23 - to learn more about both of these i
34:25 - recommend this course in apache
34:27 - cassandra as an example
34:29 - so using apache cassandra as an example
34:32 - the two biggest differences between y
34:34 - column databases and relational
34:36 - databases are why column has partition
34:39 - and clustering keys relational uses
34:41 - foreign keys
34:43 - recently white column databases are
34:45 - evolving allowing the ability to provide
34:47 - relational style secondary indexes for
34:49 - columns outside and even full asset
34:51 - transactions so the spectrum we just
34:54 - spoke about is changing over time
34:56 - learn more about these secondary indices
34:58 - right here on youtube in the link
35:00 - showing up
35:01 - so to look at this encode cql or
35:03 - cassandra query language is a subset of
35:05 - ansi sql to compare them this is cql
35:09 - select syntax using ebnf notation it is
35:13 - a subset of sql
35:15 - sql also supports binary operators such
35:18 - as inner outer joins union accept
35:20 - intersect nested sub-queries and clause
35:23 - having
35:24 - in addition cql restricts what columns
35:27 - can be used in different clauses
35:29 - this is the cql create table syntax
35:31 - using eb and f notation
35:34 - we can learn some more sql basics right
35:36 - here on youtube following the link
35:38 - popping up
35:42 - okay so here we go let's create some
35:45 - tables that store data
35:47 - so in order to do this i'm just going to
35:49 - click the cql tab up here which will
35:52 - bring up our cql console
35:54 - wonderful
35:56 - now just to check this works i'm just
35:58 - going to write show host and that should
36:00 - show us our hosts and next if you want
36:02 - to check the version i'm just going to
36:04 - type the commands show version and then
36:07 - follow with a semicolon to finish off
36:09 - this statement and hit enter
36:12 - now any version will support what we've
36:14 - shown here in the tutorial since we're
36:16 - just showing straightforward basic
36:18 - syntax
36:19 - new commands may be available in newer
36:21 - versions so it might be worth checking
36:23 - what version of cql you are using
36:26 - now the first thing i want to do is just
36:28 - list out all the key spaces that we have
36:31 - in this database
36:33 - so to do this i'm going to use the d e s
36:36 - c command for describe
36:38 - key spaces and just hit semicolon again
36:42 - and that will run that statement and it
36:44 - will bring up all the key spaces that we
36:47 - have in our database
36:49 - so as you can see the wide column key
36:51 - space that we made earlier is here this
36:54 - is the one that we want to use for this
36:56 - part of the tutorial so we need to go
36:58 - into this key space
37:00 - now we can do so using another command
37:03 - which is the use command followed by the
37:06 - key space name which in this case is
37:08 - wide column
37:09 - follow it off with a semicolon to finish
37:11 - this statement and hit enter so as you
37:14 - will see we are now in the wide column
37:16 - key space great
37:18 - so once again this is the key space we
37:20 - made previously and that's what we are
37:23 - in now
37:25 - now once here it's time for us to start
37:28 - you guessed it creating some data
37:30 - creating a table to put in this key
37:31 - space
37:32 - so to do this you guessed it we're going
37:35 - to use the create
37:37 - table
37:38 - command as we saw previously as part of
37:40 - the sql tutorial but we're also going to
37:43 - put if not exists
37:45 - so if that table does not exist i want
37:47 - to create a table
37:49 - and what should we call our table
37:51 - well i'm going to call it pizzas
37:53 - so that is what i have chosen to call my
37:56 - table
37:56 - next up we need to actually define the
37:59 - columns and data types that make up our
38:01 - tables so let's get up our parenthesis
38:04 - and i'm just going to hit enter to start
38:06 - this on a new line so it's more readable
38:08 - and our first column well let's go ahead
38:11 - and call that something i'm going to
38:12 - call it pizza id as this is going to
38:14 - store the pizza id of my pizza
38:18 - and the data type for this i'm going to
38:21 - choose use the data type uuid which is a
38:24 - data type that comes with cql
38:28 - great
38:29 - and next the other column is for the
38:32 - brand of pizza that we're going to have
38:35 - so once again let's call our column
38:38 - something which in this case is going to
38:39 - be brand and i'm going to define the
38:42 - data type to be text
38:45 - so in cql we can just write the word
38:48 - text like so to say that anything in
38:50 - this column must only be text
38:54 - great
38:55 - on to the next column the next column
38:57 - well i just want to store the actual
38:59 - name of the pizza so let's go ahead and
39:01 - call our column name and once again the
39:04 - data set for this is just going to be
39:06 - some text so let's go ahead and define
39:09 - that
39:10 - next up i'm going to show you how to
39:12 - work with an array of things so for this
39:15 - we're going to have an ingredients
39:17 - column
39:18 - let's go ahead and call that ingredients
39:21 - and then if i want to say that i want to
39:24 - only take
39:25 - texts but multiple texts i am going to
39:29 - use the set keyword to do this
39:33 - so we're going to use set and then using
39:36 - these brackets i'm going to put in some
39:38 - text so what i am saying
39:40 - is that the ingredients column will only
39:44 - take
39:45 - an array of texts
39:48 - great
39:49 - so that's another data type that we have
39:51 - just learnt
39:52 - and next well we are actually going to
39:56 - want to define how we search for rows in
39:59 - our pizzas table and i'm going to say
40:02 - that we are going to be able to search
40:04 - for the pizzas by their pizza id
40:06 - and to do this we need a primary key so
40:10 - i'm going to use the primary key
40:13 - command
40:15 - and just pass through the pizza id into
40:18 - parenthesis to make sure that our table
40:22 - knows that this is the value we can
40:24 - search our tables by that will bring
40:27 - back the whole row
40:28 - great and of course finish off the
40:30 - statement with a semicolon and just hit
40:33 - enter
40:34 - so wonderful we have just defined our
40:36 - pizzas table
40:38 - let's just check that has worked so i'm
40:40 - going to use the desc command
40:44 - followed by the key space command and
40:46 - then the key space we want to describe
40:49 - and then we just finish this off
40:51 - and wonderful so there we can see how we
40:54 - have defined our table
40:56 - that is working the next thing i want to
40:59 - do is of course stop putting stuff into
41:01 - the table
41:02 - so let's carry on
41:05 - now to start putting stuff into the
41:07 - table we're going to have to use the
41:09 - command insert into
41:11 - so let's go ahead and use the insert
41:13 - into command and of course we want to
41:15 - insert something into the pizzas table
41:18 - so let's get that up
41:20 - and actually we are going to have to
41:23 - tell this
41:25 - console exactly which columns that we
41:27 - want to put stuff into
41:29 - so i'm just going to pick all of them
41:31 - i'm going to pick the pizza id column
41:33 - the brand column the name column and of
41:37 - course the ingredients column and not
41:39 - finish this off yet i'm just going to
41:41 - create a new line so it's more readable
41:44 - we are next going to use the values
41:46 - keyword in order to insert values into
41:49 - those columns
41:51 - now we can of course write our own
41:54 - unique identifier or we can use a
41:56 - function so i'm going to use a function
41:58 - for this and it will randomly generate a
42:01 - uuid for us so i'm just going to use the
42:03 - function uuid and call it
42:06 - next up well we know that the brand
42:09 - column only takes strings or text so i'm
42:13 - just going to go ahead and put in the
42:15 - string of etzkis as the brand
42:19 - the name is going to be a pineapple
42:21 - pizza so once again we need to specify
42:23 - this as a string as we have said that
42:26 - this column takes text
42:28 - and next up we need the ingredients so
42:30 - to put in the ingredients i'm just going
42:32 - to get up some curly braces this time
42:35 - and make sure that everything we put in
42:37 - here is separated by commas and as text
42:40 - so once again we need to make sure that
42:42 - they are strings so i've just put in
42:44 - pineapple cheese and ham
42:47 - and now we can finish off this statement
42:50 - great now let's check if that has worked
42:53 - to check if this has worked i'm going to
42:55 - use another command yet another command
42:58 - and this time it is select
43:00 - so i'm going to select all
43:03 - this star means all i'm going to select
43:05 - all from the
43:07 - table that we called pizzas
43:10 - and then you guessed it finish this off
43:12 - with a semicolon and that will bring up
43:15 - our table with the data as you will see
43:18 - a unique identifier has been generated
43:20 - for us it's in green this is also the
43:22 - primary key okay as we did specify that
43:25 - when we were describing our table and of
43:28 - course we've got the brand we've got the
43:30 - ingredients and we have the pizza name
43:33 - wonderful
43:35 - shall we put in something else into our
43:37 - table i think we should so to do this
43:41 - i'm actually just going to press the up
43:44 - button this will bring up the last
43:46 - commands that we wrote and i'm just
43:48 - going to get the insert into command up
43:51 - and all i'm going to do is just switch
43:53 - out some of the values
43:54 - so we are going to switch out the
43:57 - brand of the pizza and i'm going to
43:59 - switch that out to be pizza hut again
44:02 - making sure that that is a string of
44:04 - course we can leave the uuid function as
44:07 - it was that will generate a new
44:09 - unique identifier for us
44:12 - the next thing we need to do is change
44:14 - the pizza name so i'm going to change
44:17 - this to be
44:18 - barbecue pizza just like so and on the
44:21 - ingredients i'm just going to switch
44:23 - these up too so we can have a few
44:24 - different while keeping maybe one the
44:27 - same so beef and barbecue sauce
44:31 - great
44:33 - so let's check that has worked once
44:34 - again i'm just going to press the up
44:35 - command to select all from pizzas
44:39 - and tada we can now see two we can see
44:42 - two pizzas in our table this is looking
44:45 - wonderful
44:47 - now before moving on i just want to put
44:49 - one last row in so just bear with me
44:52 - once again i'm just going to press the
44:54 - up
44:54 - button so that we can get up the command
44:57 - that inserts into the table pizzas and
45:00 - once again i'm going to keep the uuid
45:03 - function there so it can generate a new
45:06 - unique identifier for us
45:08 - i'm going to change the brand name of
45:09 - the pizza to make it another notable
45:12 - pizza brand this time is ristorante i'm
45:14 - also going to change the name of the
45:16 - pizza this time to be a broccoli pizza
45:19 - for all of you broccoli fans out there
45:22 - and of course in the ingredients we are
45:24 - gonna have to put some broccoli in there
45:26 - we're also gonna put some mozzarella and
45:28 - let's also put some corn okay
45:31 - so
45:32 - lovely pizza make sure that is all
45:34 - strings and hit enter
45:37 - so now if we get the select all from
45:39 - pizza's command we will see three pieces
45:42 - in there wonderful that's a lot more for
45:44 - us to work with let's move on
45:48 - now
45:48 - i can write a command that will select
45:54 - a certain pizza from the table based on
45:57 - the id
45:58 - and to do this we are going to use these
46:01 - select all from pizzas commands
46:03 - so select all from pizzas but we're not
46:06 - going to use the semicolon we're not
46:07 - going to finish this off quite yet let's
46:10 - make a new line i'm going to use the
46:13 - where command
46:14 - so where is another command where the
46:17 - pizza id so we're getting the column
46:19 - name equals
46:21 - the
46:22 - id of well if we want this pizza right
46:25 - here the pineapple pizza to come back to
46:27 - us so the whole row to come back to us i
46:30 - would just simply grab the unique
46:31 - identifier and hit enter after the
46:35 - semicolon and that will bring back
46:38 - just the pineapple pizza in our table
46:42 - okay so if you ever need to just get one
46:44 - row from your table that is how to do it
46:46 - using the where command just like we did
46:49 - previously
46:51 - great
46:53 - okay so that was a quick crash course in
46:57 - cql please do not be fooled as i said
47:00 - there are so many other commands you can
47:02 - do you can become really complex with
47:05 - these commands here just a few to your
47:07 - disposal we are not going to go into
47:09 - this as i said at the beginning of this
47:11 - tutorial this is just a basic overview
47:14 - so you get the idea between writing
47:16 - relational databases with sql and making
47:19 - a wide column non-relational database
47:22 - with cqr there are plenty of courses on
47:25 - both of these languages on free codecamp
47:27 - so if you want to take things a step
47:28 - further please refer back to the
47:30 - beginning of this course for the video
47:32 - you need to watch
47:34 - now the next non-relational database
47:36 - type we're going to look at is the
47:37 - document database type
47:40 - document databases are popular with
47:41 - mobile apps content management games
47:44 - some iot scenarios anywhere where you
47:47 - aren't quite sure how your data is going
47:49 - to be structured
47:50 - they don't require joins as they use
47:52 - hierarchal collections of denormalized
47:55 - data where fields can be indexed
47:58 - popular open source options here are
48:00 - things like mongodb couch base and
48:03 - couchdb
48:05 - so wait i don't have to decide how my
48:08 - data is gonna be structured that sounds
48:10 - great so why wouldn't i use that all the
48:13 - time for everything
48:15 - well ideally data should be as
48:18 - structured as it can be
48:20 - you'll pay a price down the road when
48:22 - you want to join it troubleshoot data
48:24 - type conversion errors and so on
48:27 - more strongly type data and data
48:29 - modeling better defines your app to
48:32 - database interactions which lower
48:34 - overall cost
48:36 - for example data modeling consumes a
48:38 - fraction of the overall developer time
48:40 - in a project and can have a large impact
48:43 - on code quality
48:44 - data modeling catches errors and
48:46 - oversights early when they are easy to
48:48 - fix
48:49 - this is better than fixing errors once
48:52 - the software has been written or worse
48:54 - yet is in customer hands
48:56 - however
48:58 - document or document orientated database
49:01 - types are arguably the easiest types to
49:03 - deal with from the perspective of
49:04 - development because they require no
49:06 - schema in contrast to models like
49:09 - relational and white column that
49:11 - requires schema before they can be used
49:13 - by an application developer
49:15 - before in the table we made so in other
49:17 - words the wide column database we had to
49:20 - define the column that made up our table
49:22 - as part of that upfront schema
49:24 - definition process
49:27 - with document databases we don't have to
49:29 - do any of that as long as our data comes
49:32 - as an object it's fine the objects are
49:34 - made up of keys and values and look like
49:36 - this
49:37 - this is an example of perhaps an item
49:40 - you might find on a to-do list
49:42 - the values can be strings numbers
49:44 - booleans arrays or even objects
49:46 - themselves this is called json or
49:49 - javascript object notation and is the
49:51 - most popular format for document
49:53 - database types
49:55 - now a group of documents is called a
49:58 - collection we will not be using the word
50:00 - tables anymore it has now been replaced
50:02 - by collections
50:04 - keep that in mind moving forward
50:06 - now what are we waiting for let's get to
50:08 - it in this next section i'm going to
50:10 - make a collection of pizzas using the
50:12 - document api but why not a query
50:15 - language well using api like rest
50:18 - graphql or json may already be familiar
50:21 - to many app developers so it reduces
50:23 - some of the learning curve
50:25 - now for those of you who haven't heard
50:27 - of the term api let's do a quick crash
50:29 - course
50:30 - an api stands for application
50:32 - programming interface they allow
50:34 - developers to enable technologies to
50:36 - essentially talk with each other and are
50:39 - essential to so many automated services
50:41 - that we rely on today they are behind
50:44 - most apps that we use on a day-to-day
50:46 - basis and can shape the information
50:48 - passed between one technology to another
50:51 - they can even connect things such as our
50:53 - cars fridges or pens to the internet
50:55 - apis are everywhere
50:58 - as a developer you might use the twitter
51:00 - api to get live tweets on your site a
51:03 - map api that will allow us to get data
51:06 - from a third party to use in our new
51:08 - delivery app we are building or even use
51:10 - them in a two-way stream to get post or
51:12 - delete data from a customer relationship
51:15 - management system for example
51:17 - there's a reason why these words are
51:18 - popping up and let's go into why
51:21 - in this next section you are going to be
51:23 - seeing these words and using them to
51:25 - communicate with the database you make
51:27 - in this context they are called http
51:30 - request methods
51:32 - the most common are the get request post
51:35 - requests
51:36 - put requests and delete request there
51:39 - are others too but for the sake of the
51:41 - tutorial these are the ones you need to
51:43 - know get essentially gets data and
51:46 - that's it so imagine you have a client
51:50 - or in other words your computer and a
51:52 - server
51:53 - you are on your computer and the url
51:57 - which is where you want to get your data
51:59 - from is on a server the client so once
52:03 - again your computer
52:05 - sends an http get request to the server
52:09 - to retrieve the data we want
52:12 - so here we have a get request or a
52:15 - visualization of a get request the
52:18 - client is requesting that the server
52:20 - gives it the necessary resources
52:23 - that we need
52:25 - then after the server has sent the
52:27 - response
52:29 - so request and response
52:32 - we say that we've got it
52:34 - thank you
52:36 - after the server sends the response it
52:38 - closes something called a tcp or
52:40 - transmission control protocol connection
52:44 - we also have post requests and put
52:47 - requests so here we have a visualization
52:50 - of how the requests would work with post
52:52 - requests so simply sending something to
52:55 - the server and with put requests which
52:58 - are the same we are sending something to
53:00 - the server but essentially with the put
53:02 - request we are sending something to edit
53:05 - something that already exists or in
53:07 - other words overwrite it and of course
53:09 - we also have the delete request which
53:11 - will delete an existing piece of data on
53:14 - the server so to get interacting with
53:17 - our data you will see these different
53:20 - endpoints
53:21 - simply put an endpoint is where a
53:23 - resource lives so with this
53:27 - point here forward slash burgers
53:30 - i could get all my burgers i can also
53:33 - create a new burger and add it to my
53:36 - existing burgers with this endpoint
53:38 - right here forward slash burgers making
53:41 - sure it's a post request to create a new
53:44 - one i can also edit a singular burger i
53:48 - would do so by defining the id of that
53:50 - particular burger in an end point that i
53:53 - have chosen and make sure that this is a
53:55 - put http request
53:58 - and finally the same for delete i would
54:01 - identify the individual data by writing
54:04 - a url that also has the identifier in it
54:08 - and make sure this is a delete http
54:11 - request
54:12 - okay so now that we've got that let's
54:15 - get to actually using this information
54:18 - in practice with a tutorial
54:24 - so once again on the data sags astro
54:28 - dashboard where we can see our key
54:30 - spaces in the tutorial database well
54:33 - we're going to have to create a new key
54:34 - space so let's go ahead and click on the
54:37 - add key space button to the right
54:40 - and then that should bring up
54:42 - a panel in which we can name our new key
54:46 - space
54:46 - so i'm going to name this document so
54:50 - that can show you how to work with
54:52 - document types
54:54 - okay
54:55 - so great if we refresh this it should
54:58 - show up right here under the previous
55:01 - key space that we used
55:04 - now to
55:05 - connect to this well i'm just gonna go
55:08 - to the connect tab
55:10 - and then i'm gonna choose the document
55:13 - api to connect to our key space
55:17 - okay
55:18 - and to do this we actually have some
55:20 - swagger ui to make our life a lot easier
55:23 - and to launch it we just have to click
55:25 - on this url right here okay so this will
55:28 - launch these swagger docs for us and
55:31 - this is super helpful in letting us know
55:34 - what kind of commands we need to write
55:38 - in order to add data get data delete
55:41 - data or edit data okay just by simply
55:44 - filling out some
55:46 - inputs okay
55:48 - so for example if we want to create a
55:52 - collection so in the previous tutorial
55:54 - we essentially made tables this time
55:57 - instead of tables we're going to work
55:59 - with collections okay so replace table
56:02 - in your mind with a collection and let's
56:03 - try it out
56:05 - so there has been a default token given
56:08 - for us however if you want to use your
56:10 - own so the one that you saved at the
56:12 - beginning of this tutorial or if you've
56:14 - lost that and want to try another one
56:17 - you can actually generate a new one so
56:19 - if you go back here and create a new
56:21 - token
56:22 - we're simply going to select a role i'm
56:25 - going to just do admin and generate a
56:27 - token so now we can use the default one
56:29 - or we can use this one so i'm going to
56:31 - copy that
56:33 - and then back in here delete this and
56:35 - just use the one we generated
56:38 - you are free however to just keep the
56:40 - default if you wish
56:42 - so the first input that we can put in is
56:45 - the namespace or in other words key
56:47 - space that we want to put our collection
56:49 - in and we know that this is the nosql
56:52 - document type key space that we have
56:54 - just made
56:55 - so in the docs this is called namespace
56:58 - but for us in data stacks asteroids
57:00 - called the key space this is just a
57:02 - naming difference so keep that in mind
57:05 - and by filling in these two inputs we
57:07 - are now able to write a body that will
57:10 - allow us to name the collection
57:13 - so to do this we need a name as a string
57:17 - as the property and the value is going
57:20 - to be the actual name of the collection
57:21 - which again i'm just going to choose to
57:23 - call pizzas
57:24 - and then once we have that i'm going to
57:26 - click execute
57:27 - great
57:28 - so that has worked we get a 201 response
57:33 - and if we want to do this outside the
57:35 - swagger ui a request url has been
57:38 - generated for us based on the inputs
57:40 - that we used
57:41 - okay
57:43 - great
57:45 - wonderful so we've created our
57:47 - collection the next thing we need to do
57:49 - is add a document to this collection
57:51 - so once again let's select the correct
57:55 - endpoint so this is going to be a post
57:57 - request
57:58 - to the collection that we just created
58:02 - by the collection id and let's try this
58:05 - out so we can populate the inputs to
58:07 - generate a url for us
58:10 - so once again let's just paste in the
58:12 - cassandra token the namespace of the
58:15 - collection that we want to work in is
58:18 - called document and the collection id
58:20 - where we hold our collection pizzas so
58:22 - let's just put that in here
58:24 - and now we can create our
58:27 - document
58:28 - okay
58:30 - so
58:30 - let's go ahead and create our first
58:32 - document i'm going to
58:35 - make this have a key of name
58:39 - and a value of pineapple pizza as a
58:42 - string okay
58:44 - so there we go we're kind of working
58:45 - with the same days that we did before
58:47 - but i'm going to show you why this way
58:49 - of working is different the previous way
58:51 - of working in cql in a bit
58:54 - so let's go ahead and have the brand as
58:56 - well
58:57 - so the brand of this is going to be
58:59 - pizza hut
59:01 - okay so just like so making sure to make
59:03 - all of these strings and make sure to
59:05 - put all the commas in the correct places
59:07 - too
59:08 - we are also gonna have a pizza id so
59:10 - once again a pizza id and this time i'm
59:13 - just gonna put some random numbers as
59:15 - the pizza id just like so so just put in
59:17 - some random numbers too for this
59:19 - tutorial
59:21 - next we're going to have an ingredients
59:23 - key so once again let's get up the word
59:26 - ingredients as a string
59:28 - and this time i'm going to make an array
59:30 - also of text so i'm just going to put in
59:32 - some text however you will note we are
59:34 - not defining that this has to be text
59:37 - anywhere we are not writing a schema
59:40 - okay we're simply putting in a document
59:43 - so
59:44 - now after i put in some things into my
59:46 - ingredients
59:48 - so i'm going to put pineapple cheese and
59:50 - ham
59:52 - and just go ahead and click execute
59:54 - you will see that has worked okay we got
59:56 - a 201 code the response body has
59:58 - generated the document id
60:00 - for this json document
60:02 - okay in case we ever need it and the
60:04 - request url has been generated for us
60:07 - based on the inputs that we put in
60:09 - great
60:11 - wonderful
60:12 - okay so now if i want to bring back all
60:15 - the documents in our pizza collection i
60:17 - would get the get request that will
60:20 - search for documents in a collection
60:22 - let's once again try this out
60:25 - so i'm just going to click on the try it
60:27 - out button
60:28 - populate these inputs so we know that
60:30 - the cassandra token goes here
60:32 - the namespace id well we're working in
60:35 - the nosql document type namespace or
60:38 - keyspace and the collection is called
60:40 - pizzas now if i click execute this will
60:44 - bring back the document that we put in
60:47 - this collection at the moment there is
60:49 - just one document that is the document
60:51 - id that got generated when we
60:53 - successfully put in this document into
60:55 - the collection this is all under data
60:58 - okay but right now we only have one
61:00 - document in here
61:03 - great
61:04 - okay
61:05 - so now why this is different to cql well
61:08 - i'm going to show you now
61:10 - let's go ahead and go back and create a
61:12 - new document
61:14 - so
61:15 - here is the previous pizza that we put
61:18 - in or in other words the json document
61:20 - that we put in
61:22 - now because we haven't defined a schema
61:25 - as in we haven't said what kind of key
61:28 - let's go in here into my object
61:31 - so this time let's just get rid of
61:32 - everything in here okay and start from
61:34 - scratch and this time i'm literally just
61:37 - gonna have one key value pair okay so
61:40 - i'm just gonna have the name of a pizza
61:43 - right because once again we have not
61:45 - defined how many key party pairs have to
61:48 - go
61:48 - in the documents that go into our pizzas
61:50 - collection we literally didn't do any of
61:52 - that we can put anything in our pizzas
61:54 - collection so if i just simply put this
61:56 - and click execute
61:59 - okay so that has worked a document id
62:02 - has been generated for me
62:04 - and now if i go back to getting all the
62:06 - documents in the pieces collection so
62:08 - once again just go back here making sure
62:11 - to use the get request
62:14 - and click execute
62:16 - you will see that's worked now we have
62:18 - two document ids two documents in here
62:22 - okay but
62:23 - two different structures to each one
62:26 - so hopefully you can see why this can be
62:29 - problematic for example if i was to be
62:31 - making a pizza app and decided to
62:34 - perhaps map the brand names onto
62:36 - something the cauliflower pizza would be
62:38 - missing the brand name okay
62:41 - so that is just something to look out
62:43 - for when working with the document type
62:47 - now not only does this apply to you know
62:50 - the keys but also the data types you can
62:53 - put any data type under here because
62:55 - once again we have not specified
62:56 - anything we don't have any schema
62:59 - and of course we can also add new key
63:01 - value pairs so for example i'm just
63:03 - going to do this one more time i'm going
63:05 - to create another new document so let's
63:08 - get our post request to do this to the
63:10 - collection of pizzas
63:12 - and i can just go ahead and add a new
63:15 - key value pair this time i'm going to
63:17 - choose calories
63:18 - so calories is the key as a string and
63:22 - then the value is just going to be
63:24 - 200 okay so not a string and if we click
63:28 - execute you will see that has worked
63:32 - and then if we go back and get all the
63:34 - documents in our pieces collection so
63:36 - once again i'm just going to run execute
63:40 - you will see three completely different
63:41 - document types there is no real
63:44 - sense or logic to this we're just simply
63:46 - chucking stuff in there
63:51 - okay
63:52 - now let's look at one of the other often
63:54 - used non-relational databases the key
63:57 - value store
63:58 - key value databases are one of the
64:00 - simplest types of non-relational
64:02 - database popular examples are things
64:04 - like memcache redis or etcd
64:07 - there is no query language native to
64:09 - this model to learn it's highly similar
64:11 - to language level data structure so the
64:14 - key value databases don't need them
64:16 - key value databases are most often used
64:19 - as caches but that's not all they're
64:21 - good for
64:22 - a creative use case fit here can when
64:25 - new valuable performance gains over
64:27 - relational models
64:29 - so
64:29 - let's look at key value databases they
64:32 - look like this
64:34 - you have a key column and then you have
64:36 - a value column you can actually have as
64:39 - many value columns as you wish
64:41 - the most important thing here is that we
64:43 - can retrieve data back to us so an
64:45 - entire row by the key and that is the
64:49 - identifier in this case
64:51 - let's have a quick look at an example
64:53 - rather than switching database platforms
64:55 - we can use a key value trick and
64:57 - implement the key value pattern which is
65:00 - highly similar across databases so let's
65:02 - see how to apply the key value pattern
65:05 - using a graphql api but implemented on a
65:08 - wide column database for example
65:10 - back here on our astra db interface all
65:14 - i'm going to do is create a new key
65:15 - space that we can work in once again i'm
65:18 - just going to click on the add key space
65:20 - button what should we call this key
65:22 - space well let's keep an eye on the
65:24 - previous one so no sql key value type
65:28 - please go ahead and call this whatever
65:30 - you wish
65:31 - this is what i'm choosing to call mine
65:32 - and i'm just going to confirm that
65:34 - great now once that has finished
65:37 - creating itself i'm just going to
65:38 - refresh this page in order for it to
65:40 - show up
65:41 - we can now connect to it this time i'm
65:43 - going to choose to connect our key space
65:44 - using the graphql api just because in
65:47 - the previous section we did it using the
65:49 - document api
65:50 - i'm going to show you how to do it using
65:52 - the graphql api this time
65:54 - in order to start adding a table to our
65:56 - key space i'm going to have to write a
65:58 - mutation using graphql
66:01 - to make our lives easier i'm just going
66:02 - to go ahead and open up the playground
66:04 - which will help us do all of this
66:07 - just go ahead and click on this link
66:08 - right here in order to open up the
66:10 - playground
66:12 - now this playground will essentially
66:13 - help us write our queries and mutations
66:16 - thanks to the documentation provided
66:17 - that auto generates based on what we put
66:20 - in the key space
66:21 - to access this we're of course going to
66:23 - have to put in our cassandra token now
66:26 - we can use the one that has been auto
66:27 - generated for us or if you wish you can
66:30 - replace it with the one that you saved
66:32 - so go ahead and do that or just choose
66:35 - to leave the one that's there as default
66:37 - the choice is up to you
66:39 - then once we have done that we should be
66:42 - able to check out the docs
66:44 - just go ahead and click on the green tab
66:46 - and that will bring up all the
66:48 - documentation that is to our disposal in
66:50 - order to help us write our queries and
66:52 - mutations
66:54 - great
66:55 - the first thing we're going to do is you
66:57 - guessed it create a table
66:59 - this is the mutation we need it is a
67:02 - mutation hence it's on the mutations tab
67:05 - and we're going to use the mutation
67:07 - create table
67:08 - just go ahead and write that on the left
67:11 - in the playground
67:13 - now if we click on the create table
67:15 - mutation in the documentation it will
67:17 - tell us what we can put into our create
67:19 - table mutation in order to create the
67:22 - table
67:23 - the first thing we are going to have to
67:24 - do is
67:26 - this is required because we see a bang
67:28 - here we're going to have to put in the
67:30 - key space name
67:32 - let's go ahead and do that
67:34 - i'm just going to put the key space in
67:36 - the here in parenthesis
67:38 - the key space that we want to work with
67:40 - is of course the key value key space
67:42 - that we created
67:44 - go ahead and put that in there as a
67:46 - string
67:47 - the next thing we need to do here is put
67:50 - in the table name this is also required
67:53 - as you can see here by the bang
67:55 - so go ahead and put that table name in
67:58 - here again as a string
68:01 - we're going to choose to call it pizzas
68:03 - just to be consistent with everything
68:04 - we've been doing so far
68:06 - next what is also required is that we
68:09 - have a partition key
68:11 - this functions as a key in the key value
68:13 - pattern we're implementing here
68:15 - so once again let's write partition key
68:18 - according to the documentation this
68:20 - needs to be an array
68:21 - it needs to be an array so let's go
68:23 - ahead and make this an array
68:26 - the array needs to take a name which is
68:28 - required as a string and also a type
68:32 - we're going to have to define the type
68:34 - that goes in here
68:35 - the type well we actually have all these
68:38 - types to our disposal it's essentially a
68:40 - nice cheat sheet for us but we know that
68:43 - we're going to have to use the type
68:45 - basic of uuid
68:47 - because we've done this a few times
68:49 - already
68:50 - a uuid is what we're going to have with
68:53 - the pizza id it is our choice
68:56 - we can of course have any from the list
68:59 - great
69:00 - once we have defined our table so we
69:03 - define exactly what the table is going
69:05 - to be called and what our partition key
69:07 - is going to be
69:08 - once again this will function as our key
69:10 - in the key value scenario we are also
69:13 - going to have to define some of the
69:15 - values that are going to go into our
69:17 - table which of course played the other
69:19 - value role in the key value pattern
69:23 - i'm going to say that our table here is
69:25 - going to have the value of name
69:27 - the name of this is literally going to
69:29 - be the string name and the type of this
69:32 - is just going to be text we are going to
69:34 - say that our pizza table is going to
69:36 - have a name and it's also going to have
69:38 - a brand
69:40 - we're also going to have another value
69:42 - in here
69:44 - this time i'm going to find the string
69:45 - brand and the type of this the brand is
69:48 - also going to be the type of text
69:51 - great
69:52 - let's go ahead and see if that has
69:54 - worked
69:55 - i'm not going to have all the same
69:57 - columns as we had previously because
70:00 - there is a lot to learn i'm just going
70:02 - to show you the most basic form of
70:04 - creating a table using gql or graphql
70:08 - we're just going to run this and we
70:10 - should see create table true we now know
70:13 - that our table has indeed been created
70:16 - this is all looking fantastic
70:18 - great
70:19 - now that we have defined the schema of
70:21 - our table we're going to add data to the
70:24 - table based on the schema
70:26 - in order to do this we actually need to
70:28 - change the endpoint
70:30 - so what i'm going to do is just change
70:32 - this from graphql schema to graphql
70:35 - forward slash and then my keyspace name
70:37 - just go ahead and do that let's get rid
70:40 - of the mutation we wrote here as well
70:44 - now if we look in the docs you'll see
70:46 - the docs have been updated this is a
70:48 - different endpoint and you will see that
70:50 - the queries have changed we will now see
70:52 - the queries to get the pizzas
70:55 - as well as this you will also see the
70:56 - mutations have changed
70:58 - now i have a mutation in order to add a
71:00 - pizza to my pieces table delete a pizza
71:03 - or update a pizza and the bulk insert
71:06 - pizza into my pieces table is also there
71:09 - wonderful
71:11 - go ahead and insert our first pizza
71:14 - for this again i'm going to choose a
71:16 - mutation the mutation we are going to do
71:19 - is insert pizzas and then we are going
71:21 - to have to write this on the left
71:24 - once again we know this is a mutation so
71:26 - let's use the mutation keyword
71:28 - and now let's use the insert pizzas
71:30 - mutation
71:32 - once again i'm going to get up our
71:34 - parenthesis our doctors are actually
71:36 - helping us do this because it is telling
71:38 - us exactly what we need to do which
71:40 - fields or which values are required and
71:42 - which ones aren't and so on
71:44 - of course the pizza id is required so
71:47 - let's go ahead and put in our pizza id
71:50 - i'm just going to put any random unique
71:52 - identifier in here as a string
71:54 - i'm also going to define the name as
71:56 - that is one of the values that we have
71:57 - defined in our schema
71:59 - the name of my pizza is going to be
72:01 - pineapple pizza
72:03 - just go ahead and put that in as a
72:05 - string
72:06 - it must be a string because we defined
72:08 - that it must be a string
72:10 - we're also going to have a brand which
72:12 - again is going to be a string and in
72:14 - this case i'm going to put dominoes just
72:16 - to check this has worked i'm going to
72:18 - return some values in fact i'm going to
72:20 - return all the values i'm going to
72:22 - return the pizza id and i'm also going
72:24 - to return the name and the brand
72:27 - this is just the return values to see if
72:29 - this has worked okay and everything is
72:31 - working fine we could have just returned
72:34 - one of the values if we wish
72:36 - ah we have an error this is because the
72:39 - pizza id needs to be a certain format
72:41 - the uuid does not take a certain format
72:44 - i'm just going to generate a unique
72:46 - identifier online for us just to make
72:48 - sure the format is okay and just copy it
72:50 - and paste it in here like so and click
72:53 - run
72:55 - great
72:56 - we now know this does work because we're
72:58 - getting the values back we're getting
73:01 - the pizza id back we're getting the name
73:03 - back and we're also getting the brand
73:05 - back this is all looking wonderful
73:07 - great
73:08 - we have officially added a pizza to our
73:10 - pizza table
73:12 - we can also update the pizza that we
73:14 - just added in order to do this once
73:17 - again i'm going to write a mutation i'm
73:19 - going to use the mutation keyword
73:21 - we are going to use update pizzas this
73:24 - time and update pizzas well we're going
73:26 - to have to update the pizza
73:29 - we're going to have to search for it by
73:31 - its unique identifier or in other words
73:33 - the key in this key value scenario
73:37 - let's also pass through the other values
73:39 - we want to change
73:40 - in this example i want to change the
73:42 - name
73:43 - i'm going to pass through the name value
73:45 - and then i'm just going to change it to
73:46 - this time to be watermelon pizza
73:49 - i'm just going to put the string of
73:51 - watermelon pizza in here like so
73:53 - if we don't put in any other values that
73:56 - are associated with this pizza i'm just
73:58 - going to show you what happens at the
74:00 - moment i have missed out the brand and
74:02 - let's just return the values of pizza id
74:05 - once again i'm just going to return
74:07 - value and then open up some curly braces
74:09 - and put pizza id in
74:11 - i'm also going to put the name of course
74:13 - and the brand because those two things
74:16 - are the things that make up my pizza
74:18 - if i click the button you will see i've
74:20 - updated the pizza i've searched for the
74:22 - pizza bites id again your key in this
74:25 - key value scenario and i've updated the
74:27 - name to be watermelon pizza but because
74:30 - i didn't add a brand the brand is simply
74:32 - no
74:33 - it's as if you said hey you didn't put a
74:35 - value for the brand so the band is now
74:37 - null
74:38 - great
74:40 - we are also going to have to add the
74:42 - brand back in so i'm just going to go
74:44 - ahead and put the brown back in as a
74:45 - string dominos that's all i'm doing i'm
74:48 - putting the brand in as dominoes
74:51 - great now if we click run again you will
74:54 - see what our pizza looks like
74:56 - wonderful
74:58 - there's one more mutation i want to show
75:00 - you and that is the mutation to delete a
75:02 - pizza
75:03 - to do this once again i'm going to get
75:05 - the mutation so we can look at the dots
75:08 - i'm going to get the mutation keyword
75:10 - and then i'm going to use delete pizzas
75:13 - once again let's get up our parenthesis
75:15 - so we can pass the value and we want
75:17 - this to be the id so the pizza id
75:21 - i'm just going to pass through the pizza
75:22 - idea like so and i'm gonna paste it in
75:25 - so i'm just paste it in the pizza idea
75:27 - that we created previously
75:29 - so it's now called watermelon pizza i'm
75:31 - just gonna return something that we know
75:33 - this has worked
75:35 - on this occasion i'm just gonna return
75:37 - back their pizza id that's all i'm doing
75:39 - so value pizza id
75:42 - now if we press this button we would
75:44 - have deleted the pizza because the value
75:46 - is returning back
75:48 - so we now know this has worked
75:51 - now if i try search for the pizza by
75:53 - that pizza id i'm going to use a query
75:56 - this time because we're going to search
75:58 - for the pizza in our pizzas
76:00 - i'm going to use the query keyword let's
76:03 - go ahead and get up our kylie braces
76:06 - i'm going to use pizzas because that is
76:09 - what we call the table and then i'm
76:11 - going to search for the pizza by a value
76:14 - we're going to have to open up some
76:15 - parentheses again
76:17 - we're going to use value and then we're
76:18 - going to use some kylie braces to search
76:20 - for the pizza id based on the pizza id
76:23 - we want to search for
76:24 - now i'm going to get up my curly braces
76:26 - and just return back some stuff so we
76:29 - know what is coming back to us this time
76:31 - when we search for the pizza by the
76:34 - pizza id in the pizzas table
76:37 - once again at this time i'm just going
76:39 - to put values
76:41 - curly braces and i want to return back
76:43 - the pizza id of the pizza we are
76:45 - searching for the name and the brand
76:49 - just go ahead and do that and click on
76:51 - the play button you will see nothing
76:54 - comes back
76:55 - this is because we've successfully
76:56 - deleted the pizza with the delete pizza
76:59 - mutation from our pizzas table
77:02 - wonderful
77:03 - this is looking good
77:05 - now i'm just going to do one more thing
77:07 - actually i'm just going to add another
77:09 - pizza first i'm going to show you that
77:12 - even though we are adding this data with
77:14 - gql or the graph query language it is in
77:17 - our database and we can actually access
77:19 - it however we want we can even access it
77:22 - with cql
77:24 - once again this is some good repetition
77:26 - for you
77:27 - i'm going to use the mutation keywords
77:29 - and i'm going to use the insert pizzas
77:31 - mutation and open up my parenthesis in
77:34 - order to enter the values that we want
77:36 - to enter for our pizza
77:38 - we're going to have to give it a pizza
77:40 - id which i'm going to generate
77:43 - so let's write pizza id and then i'm
77:45 - just going to generate a uuid for us
77:48 - later
77:49 - we're also going to have to have the
77:52 - name of the pizza we want to insert
77:55 - on this occasion i'm going to say
77:57 - chocolate pizza because why not as a
78:00 - string
78:01 - we're also going to have to have the
78:03 - brand so let's go ahead and put in a
78:05 - chocolate brand so i'm going to put in
78:07 - lint
78:09 - now
78:10 - we're just going to paste in our
78:11 - generated uuid i just made this one up
78:14 - and let's return the values
78:17 - i'm going to return the value of pizza
78:18 - id
78:19 - name
78:20 - and the brand just to check that this
78:22 - pizza has been inserted and everything
78:24 - works if we go ahead and press the play
78:27 - button we will see that it has worked
78:30 - because the values are returning
78:32 - if we now go into our astra db console i
78:35 - want to check that this has worked using
78:36 - my cql console
78:39 - how do we do this
78:40 - well again this is a great refresher to
78:42 - the cql part of this course
78:46 - first off i'm going to use the desc
78:48 - keyword for describing the key spaces
78:51 - that live in our database you will see
78:54 - there is a key space we need so there it
78:56 - is i'm going to use the keyword use in
78:58 - order to go into this key space
79:01 - use and the key space name followed by
79:03 - the semicolons to finish off the
79:05 - statement and hit
79:07 - enter
79:08 - next up i'm going to check that the
79:11 - schema is the same one that we just
79:13 - wrote in the graphql playground
79:16 - to do this i'm going to use the desc
79:19 - keyword for the described keyword again
79:22 - i'm going to describe the key space to
79:24 - see what schema live in it
79:26 - great
79:27 - you will see there it is
79:29 - there is the schema i made we've got the
79:32 - pizza id we've got the brand and we've
79:35 - got the name this is looking good we
79:37 - even know that the piece id is the
79:39 - primary key
79:41 - wonderful
79:42 - now if we select the pizzas table so if
79:45 - we select everything select keyword all
79:48 - the star means all from the pizzas table
79:51 - ta-da you will see our chocolate pizza
79:54 - that we added using gq app
79:57 - and we've got the whole table using cql
80:00 - back to us so we can view it in the cql
80:03 - console this is looking wonderful
80:06 - so can most non-relational databases and
80:10 - even relational databases easily be used
80:12 - in a key value pattern
80:14 - sure
80:15 - however database is used in this way
80:17 - with a key value pattern as a secondary
80:19 - model are different from the key value
80:21 - as the primary or only model for example
80:24 - like in memcache or redis a key value
80:27 - primary system is inherently much
80:30 - lighter weight compared to the other
80:32 - models as they have simpler or smaller
80:35 - footprint runtimes compared to the other
80:37 - non-relational databases
80:39 - this is why they are so often used for
80:42 - low-latency high-performance cash use
80:44 - cases applying the key value pattern to
80:47 - say a tabular or wide column database
80:51 - could make a lot of sense
80:53 - assuming the extra functionality tabula
80:55 - brings over key value also makes sense
80:58 - for a majority of the application's code
81:00 - base and use case
81:02 - but there will be a limit to the number
81:05 - of levels deep you can nest key value
81:08 - pairs
81:09 - when applying the key value pattern to
81:11 - document databases such as couchdb and
81:14 - mongodb that store entire documents in
81:17 - the form of json objects you can think
81:20 - of these objects as nested key value
81:22 - pairs
81:23 - unlike tabular databases you can nest
81:25 - key value pairs as much as you want
81:28 - json also supports arrays and
81:30 - understands different data types such as
81:32 - strings numbers and boolean values
81:36 - coming back to the true key value
81:37 - databases like memcache or redis they're
81:40 - a great fit for features like
81:41 - leaderboards or simple data structures
81:44 - in an app that need to be in real time
81:46 - ectd for example is a well-known key
81:49 - value system built for housing for
81:51 - distributed app configuration data as a
81:53 - service in kubernetes making app or api
81:57 - infrastructure another great use case
81:59 - for the key value database
82:01 - multi-model databases are also quite
82:03 - popular and can perform the role of
82:05 - multiple nosql database models against a
82:07 - single integrated backend both
82:10 - relational and non-relational databases
82:12 - can be multi-modal postgres and
82:14 - cassandra stargate provide json document
82:17 - interfaces atop relational and
82:19 - tabular-wide columns respectively
82:21 - there are two main approaches to multi
82:23 - model you can use a polygot database
82:26 - architecture or use a multi-model dvms
82:29 - some examples here are oracle db
82:32 - offering document graph and rdf
82:34 - capabilities making it a multi-model
82:36 - dbms similarly non-relational systems
82:40 - redis key value store extends its
82:42 - application scenarios with downloadable
82:44 - modules into a multi-model dbms and
82:47 - cassandra added a json document
82:49 - interface with stargate
82:51 - some non-relational dbms will build an
82:52 - inception process different data in
82:54 - different shapes like orango rendb or
82:57 - cosmos tb
82:59 - now let's finish off the course with a
83:01 - summary of when to use relational and or
83:04 - non-relational dba messes while no sql
83:07 - databases have many advantages they're
83:10 - not the right choice for every situation
83:12 - sometimes sticking with a tried and true
83:14 - sql database is the way to go
83:17 - summing all up here are some good
83:18 - reasons to use or stay with an rdbms or
83:21 - relational database management system
83:24 - if these are true it may not be worth
83:26 - switching
83:27 - instead augment existing apps with nosql
83:31 - so in other words adding microservices
83:33 - is a perfect opportunity you can mix and
83:36 - match people do it all the time with key
83:38 - value caches and rdbms's
83:41 - try graph for fraud detection wide
83:43 - column or tabular for your app or api or
83:46 - the document database for content
83:48 - management
83:49 - however if you know your operational
83:52 - database needs low latency at high load
83:55 - big or unbounded data sets
83:57 - global or regional deployment or
83:59 - replication flexible data modeling and
84:02 - high availability as well as handling
84:04 - global scale at lower costs one of the
84:07 - available nosql stores is a great choice
84:11 - when you are considering migration for
84:13 - example to a wide column nosql store
84:16 - ensure that you understand the
84:18 - differences between normalized and
84:20 - denormalized data understand your
84:22 - application ui and data access layer
84:25 - code build an entity relationship
84:27 - diagram adapting your data model define
84:30 - your access patterns grouping data
84:32 - together wherever possible design your
84:34 - primary keys and indexes and plan
84:37 - deployment and move data
84:39 - it's a similar story when migrating to a
84:41 - document database you'll need to adapt
84:44 - your data model to documents collections
84:46 - fields and more adapt your application
84:49 - code plan your deployment and move your
84:51 - existing data
84:54 - we've compared sql and nosql databases
84:57 - across several factors and giving you
84:59 - plenty of places to continue your
85:00 - learning spend the time to think about
85:02 - how each would apply to your data
85:04 - profile and use cases and best of luck
85:08 - thanks for watching and see you again
85:10 - soon
85:41 - you