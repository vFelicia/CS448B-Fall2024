00:00 - In this course, you will learn to create an
Android app using the jetpack compose UI library.
00:06 - Along the way, you will learn about graph
algorithms and data structures.
00:10 - Ryan MK teaches this course.
00:12 - He is a very experienced developer and instructor.
00:16 - What's up everybody?
00:17 - This is Ryan here, and I would like to welcome
you to my tutorial series on the graph Sudoku
00:21 - application.
00:23 - This is an application I wrote primarily to
refine my understanding of graph data structures
00:27 - and algorithms, and the new UI library on
Android jetpack compose.
00:33 - In this part of the series, I will Overview
The main goals and topics of the series and
00:38 - discuss a few design decisions which may come
as a surprise to you.
00:41 - I will try to keep the public version of the
project source code up to date.
00:45 - And it will be your responsibility to look
at that source code if something becomes deprecated
00:49 - or stops working.
00:51 - The format of this series is a code along
style, which implies that the best way to
00:56 - learn is to write the code with me as I explain
it.
00:59 - For advanced developers, the full source is
available for direct learning, but you can
01:03 - watch the videos to clear up any holes in
your knowledge.
01:07 - I use some fairly advanced features of the
kotlin language and the timeless principles
01:12 - of software architecture, so you might learn
a thing or two.
01:15 - For beginners, it is very important that you
follow along with me in code but at your own
01:20 - pace.
01:22 - You might not feel like you're making progress
at first, but understand that you will be
01:26 - practicing the skill of writing code even
if you don't yet understand what you're writing.
01:30 - I will also secretly be teaching you how to
write code which is easy to write, read, fix,
01:36 - improve and test.
01:38 - But instead of asking you to memorize the
timeless principles of software design, you
01:42 - will learn and use them in practice as we
build this application.
01:47 - There are four general topics that This tutorial
will demonstrate graph data structures and
01:51 - algorithms jetpack compose clean UI architectures,
and kotlin language features.
01:59 - We will explore the topic of directed colored
graphs and my experiments in writing algorithms
02:04 - to generate solve and unsolved n sized Sudoku
puzzles.
02:09 - We will build the entire user interface using
jetpack compose, which allows us to create
02:13 - our UI entirely in kotlin.
02:16 - As opposed to XML views and styles.
02:19 - I will show you how to wire up a simple app
using principles commonly expounded in solid
02:24 - and clean architectures.
02:25 - However, I teach these topics in my own way,
so do not expect a bunch of jargon or over
02:31 - engineering.
02:32 - I will also demonstrate how and when to use
basic and advanced features of this beautiful
02:38 - programming language.
02:40 - This part of the video is intended more for
intermediate and advanced developers.
02:45 - Understanding this design decision is not
required to complete the tutorial.
02:49 - Throughout this tutorial, you will notice
that apart from compose and proto data store,
02:54 - I use almost no libraries from Android jetpack
In fact, very few third party libraries in
03:00 - general, by relying on kotlin and Java standard
libraries and the Android SDK, my code becomes
03:06 - more resistant to deprecations and changes
in libraries.
03:10 - This is because the Android SDK, and the standard
libraries tend to change less frequently than
03:17 - third party libraries, such as those you see
an Android jetpack.
03:21 - It also means that some things which libraries
like jetpack viewmodel, jetpack, navigation
03:26 - or help might handle must be hand written
by us.
03:29 - I actually like that, but you might have a
different value system.
03:33 - And my goal here is not to discourage you
from learning these tools if you're interested
03:37 - in them.
03:38 - With that being said, you might be surprised
at how easy it is to write your own viewmodel
03:43 - navigation or dependency injection code without
them in a small app like this one.
03:49 - This application uses Model View whatever
architecture, which is my way of saying that
03:54 - I don't follow anyone else's style.
03:57 - Having studied this topic for many years,
I let the project requirements in my understanding
04:02 - of the principles of good software design
guide my architecture.
04:06 - In this case, I find that compose is made
for an MVVM based approach, but I added a
04:12 - presentation logic class for a specific reason.
04:15 - This reason is called passive view or humble
object.
04:19 - Instead of having the view or the view model
manage the control flow of each screen, I
04:24 - pulled that logic into a separate class.
04:27 - This class is super easy to write and test
because it has no third party dependencies.
04:32 - And it prevents my view model from becoming
an ugly God object.
04:36 - You should try it sometime.
04:38 - I designed this architecture simply by applying
the single most important principle of software
04:43 - architecture, separation of concerns.
04:47 - That's it for this part of the series.
04:49 - Now we begin coding.
04:50 - The domain package represents two things,
the most general pieces of information, such
04:57 - as data classes, constants, and enough Which
the program must virtually represent.
05:03 - Also, the most general things this program
must do, which the program represents using
05:09 - functions and interfaces.
05:11 - In essence, it is the foundation of any new
program I rate and I use a repeatable process
05:18 - to design my domain package or module.
05:21 - For a clear and simple introduction to that
process.
05:24 - Check out this video on my channel, how to
design information systems and applications.
05:30 - That video is a recording of a talk I gave
to some software engineers in Egypt about
05:36 - that particular topic.
05:38 - Anyways, most of the code in this package
is simple, but it does include a design pattern,
05:43 - which I will introduce now.
05:45 - This package contains several interfaces,
which are used to employ the repository design
05:51 - pattern.
05:52 - This pattern is also known as the facade pattern.
05:55 - And the general goal of the pattern is simpler
than its technical definition.
06:01 - The technical definition of the facade or
repository pattern is to hide the details
06:06 - of a subsystem, in this case, data storage
mechanisms behind an abstraction, in this
06:12 - case, an interface.
06:14 - Let's look at a practical example.
06:15 - To make sense out of that definition, our
presentation logic classes will hold references
06:21 - to these repository interfaces, instead of
the classes which implement the interfaces.
06:28 - This gives several benefits to our presentation
logic classes.
06:32 - They can be built independently of each other
without causing a compiler error, they can
06:37 - be tested with a fake implementation of the
interface without requiring us to change any
06:43 - code within the presentation logic class.
06:47 - Also, if we decide to use a different implementation
of the interface, such as switching from file
06:53 - storage to a room database, we can also do
that without requiring any changes to the
06:59 - presentation logic class.
07:01 - These benefits are a result of building software
systems, which are loosely coupled.
07:06 - And the repository or facade pattern is an
easy way to promote loose coupling.
07:12 - In fact, interfaces in general tend to promote
loose coupling.
07:16 - Now don't feel the need to use this pattern
everywhere.
07:19 - A good general rule is to use them in significant
architectural boundaries.
07:25 - In this case, I'm using them as a boundary
between the front end and the back end of
07:29 - this application.
07:31 - To start things off, right click on the domain
package, go to New kotlin file and create
07:38 - a file called difficulty.
07:41 - And that's going to be an enum class.
07:44 - enum classes in kotlin, and Java and various
other languages are useful for creating a
07:49 - restricted set of values.
07:52 - As we'll see later on, you can use sealed
classes in kotlin to create a restricted set
07:56 - of types.
07:58 - In any case, the main benefit outside of just
creating that set of restricted values is
08:02 - that enums can greatly improve the legibility
of your program.
08:07 - As we'll see in a moment, let's add in our
enum entries.
08:17 - quite obviously, this enum will represent
the difficulty of a given Sudoku puzzle.
08:22 - However, we need to add one more thing before
moving on, we will actually be using some
08:26 - values for each of these entries in the algorithms
to basically dictate the difficulty of the
08:33 - Sudoku puzzle.
08:35 - So in order to add a value to an enum in kotlin,
we need to give it a property or some properties.
08:52 - As you can see, our entries are now read,
so obviously, we need to give them some doubles.
09:12 - And that's everything we need to do here.
09:14 - Right click on the main package, go to New
kotlin file for class.
09:19 - And we're going to create a data class called
settings.
09:24 - settings is our first data model, as I like
to call it or a plain old kotlin object.
09:29 - And as we'll see in a moment, it will contain
both the difficulty and the boundary, which
09:34 - is the size of the Sudoku puzzle.
09:37 - So a four by four Sudoku puzzle will have
a boundary of four, a nine by nine will have
09:42 - a boundary of nine.
09:44 - The data keyword when put ahead of a class
keyword basically adds or generates a couple
09:50 - of helper methods, such as equals hash code
or copy.
09:54 - We'll definitely be making use of copy later
on maybe not in this class, but in some of
09:59 - them and others.
10:00 - certain point, we will also make use of the
generated hash code function.
10:04 - Anyways, this is a really simple class, we're
just going to add two properties to it.
10:21 - And that's it.
10:22 - Right click on the domain package, go to New
kotlin class or file.
10:27 - And this time, we're going to create a class
called user statistics.
10:31 - And that's going to be a data class.
10:33 - Now, the purpose of this class is to represent
the user's shortest slash best times for solving
10:40 - any particular difficulty or size of Sudoku
puzzle.
10:44 - So we're basically just going to add a whole
bunch of properties that are pretty much the
10:47 - same.
10:53 - Now, one thing you can do in IntelliJ IDEA,
or Android Studio is you can just click there
11:03 - and then hit Ctrl D, however many times you
need and that will copy to a new line.
11:39 - That's basically it for this class.
11:40 - Now, you might be wondering, why are we using
long here, we're actually storing the time
11:44 - it takes for the user to complete a particular
game in milliseconds.
11:47 - So that's why we want the long integer value.
11:50 - Again, right click on the domain package,
go to New kotlin filer class, and this is
11:55 - going to be a data class named Sudoku note.
11:59 - Now, this is where things start to get a little
more complicated and interesting with our
12:04 - data models.
12:05 - So what I'm doing here is I'm representing
an individual node in a graph data structure,
12:11 - we're going to talk a lot more about graph
data structures later on when we get to the
12:15 - part of the tutorial dedicated to it.
12:18 - But just to give you an idea, so we are actually
going to be building a directed colored graph.
12:25 - And an important thing here to note is that
in this particular case, this term color really
12:30 - just refers to a number, it's just a value
we associate in some kind of node.
12:36 - And again, to give you a preview ahead, when
I say graph data structure, a better name
12:41 - for it would be a network data structure,
because that's essentially what it is.
12:46 - It's a collection of nodes, and edges, which
are essentially like lines between the nodes
12:52 - relationships between the nodes.
12:55 - Anyways, this particular node structure in
our data structure is going to have a color
13:01 - or a value, which is just an integer from
one through nine or one to four, also, including
13:07 - 00 represents like an empty Sudoku tile, but
that's more concern of the front end.
13:13 - These notes will also include an X and Y coordinate,
so the top left will be x zero y zero, the
13:20 - bottom right will be x eight, y eight, and
we're going to be using Zero Based indexing.
13:27 - So instead of starting from x one to x nine,
we just basically subtract that by one.
13:32 - So that's it for that preamble, let's get
started writing the code.
13:36 - So we'll start with the x and y values.
13:44 - Next, we will add the color which will be
a variable because it can change throughout
13:53 - the course of execution.
13:56 - Then we will add a Boolean called read only
and I'll explain what that is after we write
14:01 - it.
14:05 - Now, the purpose of the read only Boolean
here is quite simple.
14:14 - When we essentially generate and then unsolved
a Sudoku puzzle, which is another way of saying
14:20 - we create a new Sudoku puzzle then remove
a certain number of clues to make the game
14:24 - actually playable and fun.
14:27 - Some of those numbers on the Sudoku board
or in the Sudoku graph data structure will
14:32 - be read only those are like the given clues
that the user is not supposed to be able to
14:37 - change themselves.
14:39 - As we'll see later on.
14:40 - This will also affect the user interface because
we will draw the read only Sudoku nodes or
14:45 - tiles differently than the ones which the
user can edit.
14:48 - Now, we're not quite done yet, we need to
override the hash code function which was
14:53 - provided by the data class keyword as I discussed
earlier, and then we also need to add a function
14:58 - to get a hash code.
15:04 - Okay, so hash code will have a default implementation,
which is based on the values provided up here
15:13 - in the different properties, we're actually
just going to do something different.
15:17 - So we're going to type get hash, like that.
15:22 - And this is actually a function that we are
going to create also, we'll add in two parameters
15:26 - here for x and y.
15:29 - Okay, we're now going to add the get hash
function, and it's going to be top level,
15:35 - which means it sits outside the brackets of
our Sudoku node class.
15:45 - Okay, let's just implement this function,
and then I'll explain what we're doing here.
16:07 - Okay, so let me start by explaining what exactly
a hash code or hash value is.
16:25 - So it's essentially some kind of generated
key or unique identifier based on some kind
16:31 - of algorithm.
16:32 - In this case, I have a very simple algorithm,
all I do is multiply the x value by 100.
16:38 - And I leave the y value alone.
16:40 - And I basically just combine those two values
together into an integer.
16:45 - Now, the reason why I multiply x by 100, is
if I didn't do that in a nine by nine Sudoku
16:52 - puzzle, there would be certain edge cases
where the even though the X and Y value are
16:57 - technically different, the resulting hash
code would not be unique for several different
17:04 - nodes.
17:07 - Simply put, I'm multiplying by 100 to make
the hash codes unique for every individual
17:12 - tile in the Sudoku puzzle.
17:15 - As for why we're using hash code, in general,
I'll try and keep it fairly straightforward.
17:19 - Basically, we're going to be storing each
node in the graph in a linked hash map.
17:25 - So the hash values will represent the key
for that hash map.
17:29 - A hash map has key value pairs, in case you're
not aware it, we'll be seeing that in a moment.
17:34 - But this turns out to be really useful because
our user interface as well will be representing
17:39 - things in that kind of X and Y coordinate
style.
17:43 - So just take my word for it.
17:44 - Hash codes are pretty handy in situations
where you have a large number of elements,
17:48 - and you don't necessarily want to have to
maintain a reference for every individual
17:53 - element.
17:54 - Instead, we can just retrieve a reference
by getting a hash code.
17:57 - Oh, and before we go, we need to add one more
thing here, we're going to make this thing
18:01 - implement serializable.
18:05 - Now essentially, what this does is it allows
us to read and write our Sudoku nodes and
18:09 - also the whole puzzle to a file.
18:12 - Since we're only going to be storing one puzzle
at a time, I didn't really want to use something
18:16 - like a database, it kind of just made more
sense to use the file system, and serializable
18:22 - and makes it easier to do that essentially.
18:25 - Okay, we have one final data model to create
in this particular package again, right click
18:30 - New kotlin file our class, this one's going
to be called Sudoku puzzle.
18:36 - And again, it's going to be a data class.
18:39 - A good way to think of data models, as I like
to call them is that they are virtual representations
18:45 - of a real world object, in this case, a Sudoku
puzzle.
18:49 - The way that I initially designed this class
is by asking critical questions about what
18:54 - constitutes a Sudoku puzzle.
18:56 - Things like the boundaries, so are there four
tiles per row or column or are there nine
19:01 - tiles for example, we have the difficulty.
19:04 - And most importantly, we have the graph data
structure itself.
19:09 - There's also the elapsed time which the user
has taken to solve a particular puzzle.
19:15 - So let's go ahead and add those properties
in and then I'll explain some of them the
19:19 - ones that need to be explained afterwards.
19:32 - Also, before I forget, let's add in the serializable
implementation here.
20:23 - Okay, so you're probably wondering what build
new Sudoku is.
20:28 - So what we'll be doing is we're actually going
to be calling a large series of top level
20:34 - functions, which will form all of our different
algorithms, which are necessary to build and
20:39 - generate a new Sudoku puzzle, based on a given
size, which is what boundary represents and
20:44 - a given difficulty.
20:46 - Also, if you're wondering about what's going
on with the linked hash map, which is full
20:50 - of linked lists, that's kind of a way of representing
an adjacency list.
20:55 - Again, I'm going to go into those details
on graph data structures and different ways
20:58 - you can represent them, or at least how I
represent them in this particular application
21:03 - later when we get to that particular package
and topic.
21:07 - But for the time being understand this represents
our virtual Sudoku puzzle, the last thing
21:12 - we're going to do is just add in a small little
method, which just makes it a little more
21:16 - obvious and legible how to get ahold of the
graph itself, at least in my opinion.
21:34 - And we're going to use single expression syntax.
21:36 - So I'm just going to type equals graph.
21:41 - Let's create a new interface called I game
repository.
21:45 - I like to use this naming convention of putting
a capital I in front of the interfaces.
21:55 - And then as we'll see later on, in the persistence
package, I will add a suffix of I MPL, which
22:02 - stands for implementation to naturally the
classes which implement this interface.
22:08 - When designing a small to medium scale application,
one thing you can do is you can actually conceptually
22:15 - think of the functions in your repository
interfaces.
22:20 - As use cases themselves, the things we're
going to be writing here are going to be called
22:24 - like save game update game update node, which
is very similar if you're doing like a user
22:30 - stories in the use cases type application
design.
22:34 - So I just wanted to throw that in there.
22:36 - In a more complicated application, where I
needed to do more coordination of multiple
22:41 - different data sources and repositories, I
probably would have like an interactor, or
22:47 - a use case, as it's commonly talked about,
between Martin Fowler or Robert Martin, Uncle
22:52 - Bob.
22:53 - But in this particular case, in simpler applications,
generally speaking, the use case as a class
22:58 - itself, is typically an unnecessary extra
layer of abstraction.
23:03 - So with here, we're just going with our presenter,
or view model or whatever, talking directly
23:08 - to a repository.
23:10 - And that is a sufficient amount of abstraction
for an application of this size.
23:16 - Now, how an interface works is that it's very
similar to a class except as we'll see, in
23:21 - a moment, we're not actually allowed to implement
or give a body to the functions that we'll
23:27 - be writing, we just write what are commonly
called either abstract functions or functions
23:34 - stubs.
24:01 - Now there's two important points here.
24:03 - Firstly, the suspend keyword is applied there,
because these functions will actually be called
24:10 - from co routine scopes, which exists in the
logic class or the presenter that will be
24:15 - referencing this particular interface.
24:18 - So that's all we need to do to establish concurrency
for now.
24:22 - Now, in case you're not familiar, what I'm
using here is what's known as a function type.
24:28 - And so what we'll do is we will be actually
passing in a reference to two functions which
24:34 - exist in the logic class the presentation
logic will pass those functions in.
24:40 - And then in the repository implementations
the things which implement this particular
24:46 - interface, that is how they will call back
with some kind of result, either a successful
24:51 - result or a failure.
24:53 - Now you might be wondering, why do we have
unit and then it returns unit which is what
24:57 - that arrow means, in this particular case?
25:00 - This is something we kind of have to do in
order for the kotlin compiler to understand
25:05 - exactly what we're telling it to do.
25:07 - So this would be kind of equivalent to passing
in void or like basically nothing into this
25:12 - particular function, and then returning nothing
from that particular function.
25:17 - But what it will do is it will signal something
like an oncomplete if you have any experience
25:23 - with RX Java, where basically we just want
to resume the application successfully when
25:29 - this function is called.
25:31 - But this particular function does not actually
need to return anything.
25:36 - Later on, we'll see some examples of when
we actually need to return a value through
25:40 - our on success function type.
25:51 - Again, you might be wondering what is the
difference between saving a game and updating
26:04 - a game?
26:05 - Well, essentially, in the update game function,
we're going to be wholesale writing an entire
26:10 - Sudoku puzzle, which includes an elapsed time,
although there are some situations where all
26:15 - we really need to do is simply update the
elapsed time of the game, such as when the
26:21 - user navigates away from the application.
26:23 - So what I'm doing here is I'm creating sort
of specialized functions depending on what
26:28 - we want to achieve from the user's point of
view.
26:48 - Now I'm going to demonstrate when we actually
want to return a value from these particular
26:53 - function types.
27:01 - Okay, so for onsuccess, what we're effectively
saying here is that this particular function
27:13 - must be called with some kind of Boolean value,
obviously, either true or false when it's
27:19 - called in the implementation of this particular
suspending function.
27:24 - Now, basically, what we're doing here is when
the user updates a single node or tile in
27:30 - a Sudoku puzzle, there's a possibility that
that might be the final tile in the puzzle.
27:37 - And in that particular case, assuming the
puzzle is correct, and the user has inputted,
27:41 - the final tile, that would signal that the
gain is complete.
27:46 - So it might be a little bit confusing here.
27:48 - But onsuccess does not necessarily mean that
the game itself has been completed.
27:52 - So that's why I'm differentiating there.
28:00 - Okay, now, in this particular case, what we're
doing is when the user returns to an active
28:20 - game, we obviously want to get a current game.
28:23 - And there is actually an edge case where the
user completes the game, navigates away from
28:27 - the application, and then restarts the application.
28:31 - And so that's why we're still passing in that
is complete flag.
28:50 - Here we're going to return obviously, a settings
object.
29:18 - Let's create another interface.
29:21 - And it's going to be called I gain, data storage.
29:26 - And that's obviously an interface.
29:28 - Now, before we write the interface itself,
we're going to do something a little bit different.
29:32 - We are going to create a result wrapper or
Well, let's just say it's inspired by an either
29:39 - mon ad from functional programmers, but no
one really cares what functional programmers
29:43 - think or talk about anyways.
29:49 - Seal classes are truly one of my favorite
simple features of the kotlin programming
29:58 - language.
29:59 - It allows us to create In a restricted set
of types, and those types can contain particular
30:05 - values, and visca.
30:06 - What this will do And as we'll see in a moment
is it allows us to return an object from a
30:12 - particular function have I gained data storage,
and this particular object is capable of representing
30:19 - multiple different states.
30:21 - So like I showed you before in AI game repository,
here, we're representing an error state and
30:27 - a success state as two separate function references.
30:30 - In this example, we're going to be representing
both of those states through a single object.
30:49 - Now, one final point, before we move on, if
you have, for example, some kind of situation
31:10 - where you want to represent just a success
case, so equivalent to just returning unit
31:16 - in onsuccess, what you can do is you can actually
just use an object so you could say like object
31:21 - on complete, etc.
31:23 - But we don't actually do the that in this
application.
31:26 - So you don't need to add that in.
31:27 - Now, let's finish off 
31:56 - the interface.
32:12 - Create another interface called I settings
storage.
32:17 - Now, we're also going to use result wrappers
here.
32:23 - So I'm actually going to just copy and paste
this over.
32:28 - And we're just going to rename a few things.
32:36 - Okay, and now we can write the interface.
33:02 - One more interface to go for this package.
33:04 - This one is going to be called pi statistics
if I can spell it repository, and obviously,
33:12 - it's going to be an interface.
34:22 - Now one final point, again, is record is going
to actually affect something in the user interface
34:26 - based on whether or not a statistic that gets
updated is a record ie the shortest possible
34:33 - time of completion for a particular boundary
or size of Sudoku puzzle, and a particular
34:39 - difficulty.
34:41 - The common package contains code which is
reused in a variety of different classes and
34:46 - functions.
34:47 - In this part of the tutorial, we will learn
about many different kotlin language features,
34:51 - which are designed for sharing code in an
intelligent and efficient way.
34:57 - Topics covered include extension functions
and problem These abstract classes, the open
35:02 - closed principle, object, Singleton, and co
routine dispatchers.
35:08 - Before we write the code, let's talk about
the open closed principle.
35:12 - The OCP is a relatively confusing concept,
but I will try to explain it in the clearest
35:16 - way i can to give you my own verbal definition,
which we'll break down later.
35:21 - Any commonly reused software entity, which
is expected to change should have a fixed
35:27 - public interface, and a way to change its
implementation.
35:32 - In order for that particular definition to
make sense, there's a couple things that I
35:36 - need to unpack.
35:37 - Firstly, when I say software entity, I'm generally
speaking about a class or a function, but
35:42 - it could be a few other things.
35:44 - So let's examine what I mean by public interface
and why I argue that it should be fixed if
35:50 - it's commonly reused.
35:52 - By public interface, I am not speaking of
a Java or kotlin interface specifically, instead,
35:58 - I mean any publicly visible aspect of a class
or a function.
36:03 - Since this is an Android tutorial, let us
take the example of the activity class.
36:08 - An activity fits my requirement of being commonly
reused and expected to change over time.
36:14 - So it is a perfect case to think about the
OCP.
36:18 - Every subclass of activity must include the
onCreate function, which is a part of the
36:22 - public interface, which it makes available
to classes which reference it.
36:28 - The reason why we want this public interface
not to change is very simple.
36:32 - Suppose that the Android platform developers
suddenly decided to deprecate and remove saved
36:38 - instance, state bundles from all lifecycle
functions.
36:42 - Because this public interface is used by pretty
much every Android program around this platform
36:48 - update would break everyone's code.
36:51 - What I mean specifically is that all activity
subclasses in all code bases, which have not
36:56 - removed this parameter would not be able to
compile.
37:00 - So this is why I'm talking specifically about
commonly reused software entities like activity,
37:06 - and why it is important that their public
interfaces change as little as possible.
37:12 - Since we've established why fixed public interfaces
are really important.
37:17 - The next question is simple.
37:18 - How do we then provide a mechanism or way
for the implementation of the public interface
37:24 - to change?
37:25 - Well, it turns out the kotlin gives you many
options to solve this problem.
37:29 - Rather than explain them all, verbally, I
will teach you how to use them in code.
37:33 - As we build this application, right click
on the common package, and go to new Colin
37:39 - filer class.
37:40 - And this is actually going to be an abstract
class which they don't give an option for
37:44 - here.
37:45 - So what we're going to do is type in base
logic, we will add in the abstract keyword.
37:53 - Unfortunately, I don't have the time to explain
the difference between an abstract class and
37:58 - interface in plain old inheritance.
38:01 - In this particular course, this is something
I go into and explained very clearly in my
38:05 - other video courses.
38:07 - But what I will do is explain why we're using
an abstract class here instead of an interface.
38:13 - The reason why we would want to use an abstract
class is for situations when we want to share
38:18 - behavior.
38:19 - So for example, we'll be writing a function
stub or abstract function, which I want to
38:26 - be shared across any class, which inherits
from base logic.
38:31 - And I also want to share a variable, but this
particular variable will have to be protected
38:37 - as opposed to public.
38:38 - And if we were to try and do this using an
interface, then necessarily that particular
38:43 - value would be public, we're also going to
use a generic type.
38:46 - So I'll show you how to do that.
38:51 - So the syntax for a generic type is to just
use angle brackets.
38:54 - And then you could take quite literally whatever
you wanted between those angle brackets.
39:00 - But my suggestion to you is to not use something
which is already used, hence why I'm using
39:05 - this all capitals event.
39:07 - Now, if it doesn't make sense what we're doing
here, it will make more sense when we write
39:12 - the classes which inherit from base logic.
39:15 - Let's go ahead and finish this off.
39:37 - To briefly explain the intent of this abstract
class.
39:40 - Basically, I'm saying that I want a set of
classes, the ones which will inherit from
39:45 - base logic, all of which will have this function
on event.
39:49 - In other words, these classes will handle
events from the user interface.
39:53 - And then as we'll see, we're going to use
this job object which comes from the coroutines
39:58 - API as a way to Cancel child co routines.
40:02 - And also to make each of these logic classes
as its own co routine scope.
40:06 - I'll explain that when we get to that particular
part of the tutorial, right click on the common
40:11 - package and create a new kotlin file, which
is just going to be a plain old file, and
40:17 - it's going to be called extensions.
40:19 - gotlands extension functions and extension
properties are among my favorite features
40:25 - of the language as a whole.
40:27 - Without getting too technical here, extensions
allow you to employ the open closed principle,
40:33 - which states that software entities should
be open for extension, but closed for modification.
40:39 - If that doesn't make sense, don't worry about
it is kind of a confusing definition.
40:43 - But it allows us to add new functionality
to existing source code without having to
40:49 - modify the original source code.
40:52 - Now, this particular file extensions.kt is
kind of like a replacement for static utilities
40:59 - that we might have used in Java or something
like that.
41:02 - It's really just a place where you stick utility
code which is used across the application.
41:07 - Let's write our first extension function to
see how this works.
41:40 - The purpose of this particular extension function,
obviously it will be used within activities
41:45 - is really just syntactic sugar, its way to
make it so that I don't have to type out toast
41:50 - dot make text and supply this message toast
dot length long and dot show.
41:55 - Instead, in the activity where we'll be using
activities, I should say where we'll be using
42:00 - this particular extension function, we can
just type make toast, give it whatever string
42:04 - we want to display, and it's handled like
that.
42:08 - By making it an extension function of the
activity class, I can use it seamlessly in
42:14 - any activity.
42:15 - Let's write another much uglier utility extension
function.
44:10 - The purpose of this ugly little function here
is to take the elapsed time of the given puzzle
44:15 - which the user is currently working on, and
to attempt to convert it into a value based
44:20 - on minutes and seconds or a string to display
based on minutes and seconds.
44:25 - Now, if it takes the user longer than an hour,
then we end up just displaying like a generic
44:30 - more than 5959.
44:33 - Now if you think this code is ugly, in kotlin,
I challenge you to write it in Java.
44:39 - Now for beginners, this might not make sense
intuitively, but it's important to understand
44:43 - what this is referring to.
44:45 - This is actually referring to the long object,
which we will be calling dot two time on.
44:53 - That might make a little bit more sense when
we actually get to using this particular extension
44:58 - function.
44:59 - There's only one more extension, we need to
add, and it's actually going to be an extension
45:03 - property this time.
45:38 - So what I'm doing here is I'm hitting alt,
enter on this particular red thing, and then
45:42 - I'm going to hit Add remaining branches.
46:07 - going to hit alt enter, again, to import our,
these are obviously string resources.
46:12 - That's one thing, we're not going to be writing
by hand.
46:15 - So hopefully, what you've done is you've gone
and grabbed the source code for the starting
46:18 - point, which includes things like string resources,
right click on the common package again, and
46:24 - we're going to create a new kotlin interface,
which is going to be called dispatcher provider.
46:32 - This interface is very small, what we'll do
is we'll write the code and then I'll briefly
46:36 - explain what it does.
46:46 - Now, unfortunately, I can't briefly explain
what a co routine context is.
46:59 - But I can't explain the purpose of this particular
class and how we're going to be using these
47:04 - co routine contexts.
47:06 - So in most situations, most of the work that
we're going to be doing within co routines
47:10 - land is going to take place on the main thread
or the UI thread.
47:15 - Now, with that being said, there are a few
operations like writing to a file, which we
47:20 - don't actually want to occur on the main thread.
47:23 - And that would be a situation where we're
going to provide the IO context.
47:27 - Now, the actual purpose of this particular
interface is really key here.
47:32 - What we're going to be doing is that if we
wanted to hypothetically test any class, which
47:38 - needs to use these co routine contexts, in
a JVM environment, so not an actual running
47:46 - application, then what we could do is we could
return a particular kind of CO routine context,
47:52 - which allows us to test in that particular
environment.
47:55 - I know that's a lot of technical detail, but
I can't really make it a whole lot simpler
47:59 - than that.
48:00 - However, by using this interface here, when
we want to use our co routines in the production
48:05 - environment, we can provide the real UI main
thread context for the front end, and then
48:13 - we can provide a real dispatcher for the IO
thread.
48:18 - To make that even simpler, we're really just
making the code easier to test.
48:23 - Right click on the common package, go to New
kotlin file or class, this time, it's going
48:28 - to be an object.
48:29 - And hopefully I can spell this right production
dispatcher provider.
48:35 - Again, what we'll do is we'll write the code
here and then I'll explain how it works afterwards.
48:45 - I'm going to hit alt Enter again.
48:51 - And this is where we will return the actual
dispatchers that we'll be using in production
48:56 - as per the name of this particular object.
49:18 - Now there's a number of reasons why I'm using
the object keyword here.
49:22 - So basically objects in kotlin are in this
particular case Singleton's.
49:27 - So that basically means that we will only
ever have one of these production dispatcher,
49:30 - a provider software thingies floating around
in memory space at one particular time.
49:37 - They're also thread safe, which is important
because although co routine is not necessarily
49:42 - a thread, our dispatchers dot main and dispatchers.io
has something to do with threading.
49:48 - And the other thing that an object can do
is it can actually inherit from an interface.
49:52 - Now we're not actually going to be writing
any unit tests in this particular application,
49:57 - which require the dispatchers but just to
show you What you would do if you wanted to
50:01 - unit test some class which needs to use these
co routine context, what you can do is you
50:07 - can just instead return dispatchers dot unconfined,
and then you would return that for both the
50:14 - IO context and the UI context.
50:16 - And then that is what you would use in like
a JVM j unit test environment.
50:22 - The persistence package contains classes and
functions, which have the role of persisting
50:27 - or storing data beyond the lifecycle of an
Android process.
50:32 - If you don't know what a process is, it simply
means a program which is running on a device.
50:38 - Practically speaking, we will store the progress
which the user has made in the current Sudoku
50:42 - game, as well as the settings for that game,
and the user's personal records or statistics,
50:47 - as I call them.
50:48 - Here's a quick look at the architecture of
the persistence package.
50:52 - The game repository in this situation functions
as a back end decision maker for the two data
50:58 - sources, which coordinates the data sources
themselves.
51:03 - Just try to carry out CRUD operations, create,
read, update, delete, and either report with
51:08 - a success or a failure if an exception is
thrown.
51:12 - The general principle here is to keep things
together, which makes sense to be kept together
51:16 - to separate what doesn't need to be kept together,
and to also use an abstraction or an interface.
51:23 - In any place where the implementation might
change, I might decide to stop using the local
51:27 - file storage or proto data store.
51:30 - So hiding these details from the repository
is not over engineering, but rather a calculated
51:35 - decision.
51:37 - Speaking of data sources or storage mechanisms,
we will use two different mechanisms for storing
51:42 - our data.
51:43 - Firstly, we will store the user's preferred
Game Settings and their personal statistics
51:48 - in protro data store data store provides a
lightweight and efficient way to store this
51:53 - kind of data using protocol buffers.
51:56 - Protocol Buffers is a serialization language
similar to JSON.
52:00 - However, I find it easier to read than JSON.
52:02 - And fortunately, the library we will use also
comes with its own protobuf compiler that
52:09 - will generate some of the boilerplate code
which we would otherwise need to write ourselves.
52:14 - We also use the device's file storage to store
the progress of the user in the currently
52:19 - active game.
52:20 - Every Android app is given some memory space
to store files, which is what we will use.
52:25 - This is done by making all of the domain models
implement serializable.
52:29 - And using Java as input and output streams
to read and write objects from kotlin language.
52:35 - So in case you aren't following along with
the tutorial, and you haven't downloaded the
52:39 - starting point repository, what you're going
to want to do is you're going to want to add
52:44 - a directory called pro tau in the main source
set, the starting point repository should
52:50 - already have that directory.
52:52 - So just go ahead and right click on it, and
go to new file.
52:54 - And this file is going to be called gain underscore
settings, dot proto, and make sure it's all
53:02 - lowercase.
53:04 - Go ahead and type this in the top of the file.
53:12 - So protocol buffers are essentially like a
serialization language.
53:16 - It's very similar to JSON.
53:19 - If you want to look more into it, you can
about what the benefits and the pros and cons
53:23 - of using something like JSON.
53:25 - But personally, this being the only project
that I've used Protocol Buffers in so far,
53:30 - I'm quite happy with it.
53:32 - Okay, so let's just add two more lines.
53:34 - And I'll explain some more from there.
53:46 - Okay, so we'll talk a little bit more about
this in a moment.
53:59 - But basically, what's going to happen here
is, we're going to define this protocol buffer
54:04 - message, as it's called, which is kind of
like a data type for lack of a better term.
54:10 - And what we can do is, so this file will be
consumed by something called the protocol
54:16 - buffer compiler.
54:17 - And in this case, what we're basically telling
it is that we're going to be generating Java
54:22 - files.
54:23 - Now in the generated class files.
54:25 - The protocol buffer compiler is going to basically
add whatever we put in the Java package as
54:31 - the package for the generated Java class file.
54:34 - It's just useful to not mix up your namespaces
and stuff like that.
54:38 - And as for the second option, here, Java,
multiple files.
54:41 - If you don't have that turned on, then what
can happen is that basically, the generated
54:45 - Java files will all be in one single file.
54:48 - We don't really want that, although I'm not
sure if it's absolutely integral to getting
54:52 - this application to work.
54:54 - Like I say, we're going to go through this
pretty practically and I'm not an expert in
54:57 - protocol buffers.
54:58 - Okay, now, we're going to do Line a message
which is kind of like one of the main data
55:03 - types for lack of a better term in this particular
language.
55:29 - Okay, so let's talk about what we just did
here.
55:54 - So we've defined a message, which in Protocol
Buffers is kind of like a data type or a collection
55:59 - of fields.
56:00 - And we've done two things.
56:02 - So within the game settings message, we have
a 32 bit integers, like a kind of a smaller
56:08 - integer to represent the boundary of a Sudoku
puzzle.
56:12 - So when I say boundary, I mean like a four
by four Sudoku puzzle will have a boundary
56:17 - of four, a nine by nine Sudoku puzzle will
have a boundary of nine, obviously.
56:22 - And the other thing we did here is we defined
an enum in protocol buffers.
56:26 - Now when you're creating these enums, you'll
need like a default value unknown.
56:31 - And then you've got the other values that
the enum can potentially be.
56:36 - Also notice how in boundary and difficulty
the fields above the enum I'm giving it default
56:42 - values, naturally, those will be like the
values that the protocol buffer gets pre loaded
56:47 - with, like the first time you access it.
56:49 - Now, the important thing to understand here
is that assuming you've added the support
56:53 - for Protocol Buffers into your build Gradle
configuration, the proto buffer compiler is
56:58 - going to actually generate some Java files
or classes out of this particular message.
57:05 - Okay, so what I'm doing here is I've opened
up the completed project, and I'm just having
57:09 - a look at the file which was generated by
the protocol buffer compiler.
57:14 - And all I really want you to notice here is
that when you're using proto data store, what's
57:19 - going to happen is it's actually going to
generate a Java class for you.
57:24 - Obviously, you can see we have our gain settings
in camel case, which is what we defined as
57:29 - our message.
57:30 - And then we also have that enum defined below.
57:32 - So what does this actually do for us, basically,
this is going to allow us to serialize or
57:37 - basically translate from Java into the protocol
buffer language and vice versa.
57:42 - And it also means that we don't actually have
to create our own plain old Java object in
57:47 - order to do that.
57:48 - The library is going to generate that for
us.
57:51 - But we can still use it in our code, which
we'll do in a moment, we're going to add one
57:54 - more proto file.
57:56 - So go ahead and open up the protobuf directory,
right click again, go to file.
58:03 - And this one's going to be called user statistics
dot Proto.
58:06 - Alright, so I've just copied and pasted the
first three lines from the other protocol
58:12 - because we'll be reusing them.
58:14 - And we are going to create another message
here.
58:16 - Now when I say statistics, this is kind of
like my way of talking about the user's personal
58:21 - records.
58:22 - So what are the shortest times to completion
that a user has made in solving a particular
58:29 - size and difficulty in a particular Sudoku
puzzle?
58:35 - It's pretty straightforward.
58:36 - So let's just write it out.
59:18 - And there you have it.
59:19 - Now, you might be wondering why I'm using
64 bit integers here.
59:23 - So these actual values are going to be stored
in milliseconds, which is why I do want the
59:27 - 64 bit integer storage there instead of the
32 bit integer.
59:32 - I'm not actually 100% sure if that's necessary,
but I did that just to be safe, and realistically,
59:37 - it's not really going to eat up that much
extra memory.
59:40 - Okay, so that's it for our protocol buffer
files.
59:43 - Now, we're going to have to create some protocol
buffer data stores, which is how we're actually
59:47 - going to create and access our protocol buffers.
59:50 - Go ahead and right click on the persistence
package, go to New kotlin file or class and
59:56 - this is just going to be a file called data
stores.
59:59 - Okay, so before proceeding, you're going to
want to go to build and make project.
60:05 - Now the build will probably fail, but all
we really wanted to do is to generate the
60:09 - appropriate Java class out of the protocol
buffer.
60:13 - But if for some reason that doesn't work for
you, just follow along, and eventually it
60:18 - will work.
60:19 - Okay, so for each protocol buffer based data
source, we're going to need to provide a way
60:24 - to get ahold of it or create it from context,
then the other thing we'll need is a serializer.
60:35 - Go ahead and import everything.
60:56 - And there's two things we need to add into
the delegate here.
61:06 - Okay, so don't worry that it's showing up
red will actually write this serializer.
61:18 - Next, so I just wanted to explain what's going
on here.
61:21 - So we're creating a data store object, and
it takes the protocol buffer generated Java
61:27 - class, which is called Game Settings.
61:30 - And essentially, what this does is it creates
a reference which which we can use to either
61:35 - store or retrieve our protocol buffer.
61:38 - Now, you might be wondering what game underscore
setting.pb is, and why it has a different
61:43 - file extension than our proto files, to the
best of my understanding game underscore settings.
61:49 - PB is something that's generated after the
fact by the compiler, whereas the profile
61:53 - is something we write for the compiler to
consume.
61:56 - But in case I'm wrong on that, then feel free
to flame me on Twitter.
61:59 - The other thing we'll need is a serializer,
which takes care of serialization quite obviously.
62:19 - After that, you can just click here, hit alt
insert, override methods, and we only need
62:25 - the methods from the serializer interface.
62:28 - So again, let's read the code and then I'll
explain what I need to explain after the fact.
63:02 - Okay, so I'm going to keep the details here
pretty light.
63:36 - So obviously, when we create our data store,
it's given the game setting serializer here.
63:42 - And what the serializer does is it helps us
to read and write from input streams.
63:48 - So in other words, we're going to be obviously
reading from a protocol buffer file, and then
63:53 - that's going to be serialized, or rather D
serialized into Java, and vice versa.
63:57 - So basically, what the Android team has done
for us here is they've made it a lot easier
64:02 - to handle things like error handling and dealing
with input streams.
64:06 - Because if you've ever worked with input streams
in Java, then you can tell there's, you know,
64:12 - you're probably familiar with a lot of boilerplate
code to do with that.
64:15 - So basically, we do a little bit of boilerplate
work here.
64:18 - And it translates to a very simple API, when
we actually want to read and write with this
64:22 - particular tool in the back end, which we'll
be doing in a moment.
64:26 - Okay, now, obviously, we need to write another
data store and also serializer for the other
64:32 - data type.
64:33 - So this is going to be one of those rare scenarios
where I do actually just copy and paste because
64:38 - there's absolutely nothing new, we're just
going to change a couple of the words.
64:42 - So this would be one of the points where I
encourage you to have the complete source
64:45 - code open on the side and then that way, you
can do a little bit of copy paste action,
64:51 - like I'm going to do now.
64:52 - And that is our data stores file complete.
64:55 - Now obviously, if you had a whole bunch of
these, you'd probably want to use separate
64:58 - files, but since I only have Have the two
I just decided to stick them in the same file,
65:03 - right click on the persistence package and
go to New kotlin class.
65:07 - This one's going to be called local game storage
ample.
65:12 - So firstly, we're going to make a constant
which will represent the name of the text
65:16 - file that we will be reading and writing the
game data to.
65:22 - Next, we'll create the constructor.
66:02 - So you might be wondering where file storage
directory comes from.
66:05 - When we create the build logic of this application,
which is kind of like my inversion of control
66:10 - dependency injection type stuff, what's going
to happen is we're going to call this one
66:14 - function to the Android system, which will
return us the specific directory from the
66:19 - system where we can read and write things
like files.
66:23 - Let's go ahead and implement the interface.
66:29 - Now, I'm going to try to get through this
relatively quickly.
66:36 - But one thing I want to explain is that you'll
notice I'm making fairly extensive usage of
66:41 - helper functions.
66:42 - The reason for that is just to avoid writing
redundant code.
66:46 - Also, as with the other implementations, we're
going to be using the width context co routine
66:50 - builder to do this kind of IO work off of
the main thread.
67:22 - So what we'll do is we'll call a helper function
called update game data, and we'll pass it
67:27 - in the game data.
67:28 - And if that operation happens to be successful,
then we'll actually just return the same game
67:32 - object that was passed in because it should
be consistent.
67:41 - Okay, now we can create the helper.
68:13 - So here, we're going to throw the exception
so that it'll actually get picked up by the
68:17 - catch block in the functions that we'll be
calling this helper.
68:21 - Now, we're going to be using input and output
streams, which are part of the Java standard
68:26 - library in order to rate our data to and from
the file.
68:29 - If you're wondering kind of what this word
stream means, ultimately, what we're actually
68:34 - doing kind of at the low level, is we're going
to take our game or Sudoku puzzle object,
68:40 - and we're going to serialize it into basically
a stream or a very long sequence of textual
68:47 - characters.
68:48 - And that's what we'll actually be reading
and writing from the file.
68:58 - Okay, so two points, you always want to close
your streams.
69:30 - Also, you might be wondering, how is it that
we can say dot write object and pass in our
69:34 - Sudoku puzzle, but let's just check the parameters
here.
69:37 - So I'm going to hit Ctrl p within the parameter
brackets, and as you can see, it accepts any
69:43 - type.
69:44 - Now the important thing is that if our different
classes like Sudoku puzzle and Sudoku node
69:50 - did not extend serializable than we wouldn't
be able to do this without errors.
70:10 - So for update node, it's a little bit different,
we're just updating one individual node.
70:15 - So how this is going to work is we're going
to get the old data and then we're just going
70:19 - to update that individual node.
70:22 - And then we will rewrite the result back to
storage.
70:46 - So get game will be another helper, we write,
and what I'm going to do is I'm actually going
70:50 - to write that one right away.
70:51 - Otherwise, the autocomplete and error handling
stuff will be all over the place.
71:31 - Okay, that's what we need to do there.
72:20 - Now, just a quick reminder here, when we say
color, and really, whenever anyone talks about
72:37 - a color in a graph data structure, they're
really just talking about a number.
72:41 - So in this case, the number represents the
actual value placed in a particular Sudoku
72:46 - square.
72:47 - So it'll be like something from one through
nine, or one through four, depending on the
72:51 - boundary of the Sudoku 
will also update the elapsed time.
73:08 - After it's updated, we will write that result
to storage hopefully.
73:20 - And just to keep the front end synchronized
with everything else, then we will return
73:24 - that same game object.
73:25 - Now it has just come to my attention that
I have forgotten to add a particular integer
73:30 - called color to this particular function when
I wrote it, so let's just go ahead and fix
73:34 - that now.
73:38 - There we go.
73:48 - And I managed to save the easiest for last.
74:25 - And that's it for this file.
74:26 - Right click on the persistence package, go
to New kotlin class, this one's going to be
74:32 - called game repository info.
74:36 - So in case you jumped ahead, and you aren't
actually familiar with the repository pattern,
74:40 - I actually already explained that in part
two of this series where I built the domain
74:44 - package.
74:46 - In any case, let me just reiterate, reiterate
what the purpose of this particular classes,
74:51 - it's basically like a bridge and decision
maker for the backend.
74:56 - Now sometimes you'll have multiple different
repositories or datasets.
75:00 - In the back end, and it might be a good idea
to keep them separate.
75:03 - The reason why I didn't in this particular
case is because the game storage and the settings
75:09 - storage are actually inextricably linked.
75:12 - They are by nature closely related.
75:15 - So based on that, and the fact that this isn't
actually a very large application, I chose
75:19 - to put them together within this repository.
75:23 - And then how it will work is that the repository
will coordinate these two different data sources.
75:28 - Let's start with the constructor and the repository
interface.
75:53 - Okay, so as you can see, we have our work
cut out for us.
76:01 - So what I'm going to do is I'm going to try
to write the code relatively quickly.
76:05 - And after it's written, I'll explain what
76:47 - it does.
77:05 - So there shouldn't be anything new in this
particular function, except for the fact that
77:09 - we're making an assignment statement within
a control statement, Val current game result
77:14 - equals etc.
77:16 - We're allowed to do that because kotlin is
a beautiful and idiomatic language.
78:01 - This one's actually pretty simple.
78:14 - You know, for the life of me, I don't understand
why it keeps putting on air on top.
78:54 - I'll explain this function in a moment.
79:05 - So puzzle is complete is actually a function
which exists in the computation logic package,
79:10 - which we'll be writing later on, of course,
and all it does is exactly what it says.
79:14 - But it will return either a true or a false
based on whether the puzzle is complete or
79:18 - not.
79:19 - Hence is complete.
79:21 - Okay, so what I've done here is I've copied
and pasted in the plain language use case
79:25 - which describes this particular function.
79:28 - Now, as you can see, it's pretty complicated
to give a basic explanation of what's going
79:33 - on.
79:34 - And why did this when we request the current
game, ie when the application starts up, there's
79:40 - a number of different things that could happen.
79:42 - So for starters, the user could have a currently
active game and they just want to retrieve
79:47 - it.
79:48 - It could be the first run of the application,
so no game currently exists in storage.
79:53 - And then there are different situations where
errors could occur along the way.
79:57 - This is something that happens when you're
coordinating multiple different data sources.
80:01 - Now I have my own system of tracking these
different event streams, I use basically letters
80:07 - and numbers to denote steps and different
potential event streams.
80:11 - But whatever you do, my suggestion to you
is to write this down in plain language first
80:16 - and then go ahead writing the code.
80:18 - That's what I did this comment above you see
here, I wrote that before I wrote the code.
80:23 - Anyways, let's get started.
80:46 - Okay, so for our first Event Stream, we attempt
to retrieve the current game, and that returned
81:13 - successfully.
81:14 - And then we also want to know whether the
current game is complete or not.
81:40 - We can just get rid of oncomplete.
81:56 - And here we go again.
82:16 - So this is obviously the case where the user
has first loaded the application and we want
82:21 - to create a brand new game.
82:23 - And Looks like I'll have to do this manually
this time.
82:46 - The autocomplete is not helping me here.
82:48 - But in fairness, we haven't written that function
yet.
83:04 - Okay, I'm just gonna double check that I wrote
that correctly.
83:33 - Now, before I want to move on, I want to explain
one thing about my perspective on software
83:38 - architecture.
83:39 - While sometimes in a simpler application,
we can do something like have the presenter
83:44 - coordinate different repositories or back
end data sources.
83:48 - In this particular case, there was enough
complicated back end logic that I wanted to
83:53 - have also a decision maker class, which happened
to be this game repository imple on the back
83:59 - end, and part of the purpose of this class
is to take care of the logic of coordinating
84:04 - these different back end data sources, so
that I can keep the presentation logic class
84:08 - doing what it's supposed to do, managing presentation
logic, and then I have this class dealing
84:13 - with this messy kind of almost business logic
type stuff here.
84:18 - Anyways, we're not done yet.
84:19 - Okay, so it just occurred to me that I have
missed a function in the interface of a game
84:24 - repository.
84:25 - So let's just go ahead and add that in.
84:27 - So what I'm going to do is I'm just going
to copy update game, paste it down below.
84:33 - And what we're going to call this is create
new game.
84:40 - And it's going to take in a settings object
and that's it.
85:36 - So that's actually a helper function that
I created mostly for legibility, let's just
85:40 - go ahead and add that in right now.
86:44 - Just another quick note here, you'll notice
that I like incredibly long and descriptive
86:49 - names of everything that's going on.
86:51 - This is largely because I don't have a great
memory for fine details.
86:55 - So by making these things super long and descriptive,
I don't actually have to remember them, I
87:00 - can just read my code and pretty much understand
what it does.
87:03 - Even in these complicated situations where
we have all these different event streams
87:07 - and interactions occurring, okay, only two
more short functions to go.
88:06 - And that's it for our back end.
88:08 - In the top level of the UI package, we have
four small files, which we will use to create
88:14 - and apply styles, colors, fonts, and so on.
88:18 - One of those files is the global theme for
our application.
88:22 - And I will show you how to create both a light
and dark theme for the app in only a few extra
88:27 - lines of code.
88:29 - Stay tuned for the end of this section, as
I will do a live demo of the different themes.
88:33 - Right click on the UI package and create a
new kotlin file, which is going to be called
88:41 - color dot Katie.
88:44 - This file will essentially be a replacement
for colors dot XML, if you're used to working
88:50 - with the old resources system, which was based
in XML, let's create a color object.
89:04 - Make sure you import the Compose color class.
89:10 - Okay, so before we proceed, the most important
thing to understand here is how to read these
89:18 - particular values.
89:20 - So the first two characters here 0x.
89:23 - This basically tells the compiler, which is
the program that will be reading this code
89:28 - that this is in fact a hexadecimal number.
89:32 - The second two digits here indicates the alpha
value as a percentage.
89:37 - Alpha is another way of saying transparency
or how opaque something is.
89:42 - The remaining three pairs are the red, blue,
and green or RGB values, again in a hexadecimal
89:49 - percentage, and that's pretty much all there
is to know about these different color values.
89:54 - I've copied and pasted over the rest of the
values because there's absolutely no point
89:59 - in either was typing all this out.
90:01 - But also keep in mind that they have some
predefined values such as flack, for example,
90:06 - which you can also make use of right click
on the UI package, and we're going to create
90:10 - another new kotlin file.
90:13 - And this one's going to be called shape.
90:16 - So in the old view system, when you wanted
to do something like creating a background
90:21 - with rounded corners, or a button or widget
or something like that, you had to create
90:25 - usually something inside of the drawable folder,
which was XML based.
90:29 - Again, since this is compose, we can just
go ahead and do that in kotlin instead.
90:39 - And we'll just use some default parameters.
90:50 - Now, this might be your first time seeing
the.dp extension, let's just take a quick
91:04 - look at the source code.
91:05 - So as you can see, you can basically just
append it to an integer double and various
91:09 - kinds of numbers.
91:11 - The important thing to understand here is
that this basically tells the Compose framework
91:15 - that we want to use density independent pixels.
91:19 - If you want a more profound explanation of
what exactly those are, I strongly suggest
91:22 - you look into it because it's a little bit
complicated.
91:25 - Suffice it to say that the idea here is to
allow the framework to create values for heights
91:30 - and widths and things like that would work
across a variety of different screen sizes
91:35 - and form factors.
91:37 - Right click on the UI package, and we're going
to create another kotlin file, this one is
91:41 - going to be called type.
91:44 - Now in case you're wondering, when we say
type, we're not really talking about a type
91:49 - system, or anything to do with type theory,
it has to do with type Pog, Rafi or text and
91:54 - how this text is styled or presented.
91:57 - So again, this is very much the kind of thing
that we used to do and styles dot XML, we're
92:03 - basically going to create a bunch of different
text styles, which will use throughout the
92:07 - application.
92:08 - And then we'll kind of see how to wrap those
up in a typography object.
92:12 - And then we'll see how to add that typography
object to our sort of global compose theme.
92:18 - First, let's create a text style.
93:02 - Sometimes we have a situation where we want
to keep a bunch of default values, but we
93:06 - might want one or two values, which are actually
passed in as a parameter to create the text
93:11 - style object.
93:12 - So I'll show you another way to create these
text styles using function.
93:33 - Just gonna do some quick copy paste here.
93:40 - And then we can override the color.
93:45 - So again, what I'm going to do for the rest
of these textiles now that we've seen everything
93:49 - there is to see here is I'm going to copy
and paste them over.
93:52 - But there is one more thing that's new that
we need to create in this particular file.
93:56 - Okay, as you can see, we've got a couple different
textiles here.
94:01 - So the last thing we need to do is create
a typography object.
94:05 - So basically, what that's going to mean is
that we're going to assign some of the text
94:09 - styles that we've created below, which are
used in common things like the body text of
94:14 - a particular feature of the application, buttons,
titles, that kind of thing.
94:19 - If that doesn't make sense.
94:20 - Let's just write the code.
94:26 - Make sure you select compose dot material,
not kotlin dot txt.
94:34 - Okay, we're just gonna do To more.
95:04 - All right, and the only other thing we need
to do is set up our graph Sudoku theme.
95:29 - Right click on the UI package, and we've got,
you guessed it another kotlin file.
95:34 - And it's going to be called graph Sudoku themed.
95:38 - So one of the handy little features of jetpack
compose is that it is incredibly easy to create
95:44 - a theme for light and dark modes.
95:46 - As someone who uses generally speaking, dark
mode almost always actually really appreciate
95:52 - this particular feature of compose.
95:54 - The first step in that process is to create
two different color palettes.
95:58 - Let's start with the light color palette.
96:42 - So some of these properties should probably
be familiar to most Android developers like
96:46 - having a color primary.
96:47 - That's how we used to do it also in the old
XML system with colors, or at least that was
96:51 - a common naming convention.
96:53 - Now, one thing I want to point out here is
that there's a degree to which some of these
96:58 - more obscure ones like primary variant surface
on primary and so forth, I'm really just using
97:04 - those because it's convenient, they don't
necessarily have to mean anything in particular.
97:09 - But the important thing to understand here
is that if there's any different color between
97:13 - a light theme and a dark theme, we do want
to define it somewhere in here, and then use
97:18 - it appropriate in the composable, which we'll
be learning to do later on.
97:23 - Okay, that was actually supposed to be uppercase
there by convention.
97:27 - And also notice that I've copy pasted over
the dark color palette, because again, there's
97:30 - nothing new going on there.
97:33 - The next step, however, is very important,
we're going to create our theme, and it's
97:36 - actually going to be really, really easy.
97:39 - Here's a little shortcut I learned from a
friend, if you want to create a composable
97:42 - function really quickly start typing comp,
and then hit enter, just saves you a little
97:47 - bit of time.
97:53 - Now this theme is going to have two parameters
here.
98:10 - So before we write the body of this function,
I just wanted to discuss these two parameters.
98:15 - So as you can see, we're actually making a
function call is system in dark theme, what's
98:20 - going to happen is this system call will return
a Boolean, which will tell us whether the
98:24 - user has specified if the app is supposed
to be in dark mode or light mode.
98:29 - And then the content represents everything
that will be wrapped inside of this theme.
98:33 - What's important to understand here is that
everything that we put inside of this composable,
98:37 - ie the content will have access to all these
different colors, styles and typography information
98:43 - from within the theme itself.
98:45 - The actual utility of this will make a lot
more sense when we actually write the composable.
98:49 - Just to finish things off, we're going to
create a material theme composable.
98:56 - And we won't need the lambda expression.
99:24 - So there you have it, it only took a few minutes
to create like the color resources and styles
99:28 - and typography information necessary to render
both a dark color palette and a light color
99:33 - palette for different modes.
99:35 - What I'm going to do is show you a quick demo
of what this actually looks like in an application.
99:40 - Here I'm going to be starting the application
in the light theme.
99:44 - Then I'm going to navigate to the operating
system settings and set it to a preferred
99:48 - dark mode.
99:50 - And upon returning we see immediately that
the application now is using the dark theme.
99:55 - We're now ready to start building our user
interface.
99:58 - The UI components package contains reusable
elements of the user interface.
100:04 - Since this is a very small app, the only two
such elements are a toolbar, and a loading
100:08 - screen.
100:10 - One of the great features of compose is that
we can make our components reusable in different
100:15 - ways.
100:16 - Firstly, if a component needs to be positioned
according to where it fits in different parent
100:20 - composable, or parent screens, we can pass
in a modifier instead of creating a modifier
100:27 - within the child composable.
100:29 - This is worth experimenting with in case you
haven't already.
100:32 - Secondly, it is possible to pass in composable
as arguments, which also allows reuse and
100:39 - extension of functionality.
100:41 - In this app, we want different toolbar icons
for the two different UI screens.
100:46 - And we can achieve this by passing in the
icon compostables.
100:50 - From those parent UI screens, you'll see later
on how we can specify and handle different
100:55 - icons and different click events.
100:57 - Using the same toolbar will also create this
reusable loading screen and later, I will
101:02 - show you how to animate it, right click on
the UI package and go to new package.
101:08 - And this one's going to be called components.
101:11 - Just a brief explanation here, I've adopted
this particular convention from the composed
101:16 - samples repository.
101:18 - So what will go into this particular folder
are composable, which will end up being reusable
101:23 - across a variety of different UI elements
and different screens.
101:27 - In this case, we're going to be creating a
reusable toolbar, and also a reusable loading
101:32 - screen, right click on the components folder,
and go to New kotlin file, and this one's
101:38 - going to be called app toolbar.
101:42 - Let's create our functions stub, what I'm
going to do is I'm going to type co MP and
101:46 - then the autocomplete will create a composable
function.
101:50 - This one's going to be called app toolbar.
101:53 - First, let's write the parameter list and
I'll explain it a little bit.
102:02 - Make sure you select the compose.ui modifier.
102:20 - Let's start by talking a little bit about
modifiers.
102:22 - So modifiers are basically how you can create
most of these styles size and position kind
102:27 - of data for a particular composable.
102:30 - Now there's kind of two different main ways
to do this.
102:33 - We could of course, create this modifier and
use it within this widget.
102:37 - But that would be for a situation when the
widget itself is going to be deciding that
102:41 - kind of information.
102:43 - Since we're using a reusable component here,
an app toolbar, which we plan to use in multiple
102:48 - different places.
102:50 - In this particular situation, we're going
to pass the modifier into this function, which
102:54 - is a way of basically saying that the parent
composable will actually decide where to position
103:00 - and how to size this particular UI element.
103:03 - The title is pretty self explanatory, but
what is a little more complicated is the icon.
103:08 - And again, that will be dictated by something
in the parent composable.
103:13 - That's how I actually make this thing reusable
and allow it to handle different icons or
103:17 - different actions when it's clicked.
103:20 - After we finish off this particular composable,
I'll show you a quick preview of the actual
103:24 - icon that we'll be using.
103:26 - So hopefully that will make a little bit more
sense.
103:28 - The first thing we want to do is override
the top app bar composable.
103:52 - Let's just pause a moment and talk about different
colors.
103:55 - So one way to solve this problem would be
to hard code some kind of color in here.
103:59 - But in the previous section of this tutorial,
we went through the trouble of setting up
104:04 - both a light and dark theme.
104:06 - So what we're doing here is we're actually
going to be using a color which is based on
104:10 - the theme.
104:12 - Remember in the graph Sudoku theme composable,
there was a call to a function which was his
104:18 - system and dark theme or something like that.
104:21 - And that's actually going to dictate which
color palette we select.
104:24 - So by using material theme colors dot primary,
it will automatically inherit the appropriate
104:31 - color based on whether we're in light and
dark mode.
104:35 - And that would be one reason to avoid hard
coding something in here.
104:45 - In this case, we have a color which will be
the same regardless of whether it's light
104:48 - or dark mode.
104:56 - So we're just going to add in a text composable
which is effectively eight Extra view.
105:01 - But if you wanted to add something like a
logo for the application in front or after
105:05 - the title text, and what you could do is you
could add in a row here and then just add
105:10 - in both the icon and then the text composable.
105:13 - And then you'd be ready to go.
105:19 - Go ahead and import that.
105:35 - This is probably pretty self explanatory.
105:36 - But when we want to inherit style data for
particular fonts and stuff like that, then
105:41 - this is how we can do it.
105:50 - Again, this is something super handy.
106:01 - And you only see this in kotlin, certainly
not Java.
106:04 - So what we're doing here is we're explicitly
asking is the application currently in light
106:09 - mode, and then we're picking a text color
based on that.
106:12 - This is really just an alternative way of
handing this conditional UI logic without
106:17 - having to assign something to a theme specifically.
106:20 - Next, we'll deal with alignment.
106:32 - And that's it for the texts composable in
our toolbar.
106:42 - So action bar is probably something that will
be more familiar to the older Android developers.
106:47 - But basically think of this is like the icons
within the toolbar.
106:50 - Generally, they're used for very important
actions in the user interface, like navigating
106:55 - to a new feature, indicating that you're done
doing something.
106:59 - And note importantly, that this particular
lambda function is of type row scope.
107:04 - So basically, what that means is, if you have
several action buttons, you can place them
107:08 - within these two brackets here, and they will
automatically be lined up like a row.
107:12 - Now all we need to do is just type icon and
then add in the parentheses here.
107:17 - And this is because we're actually going to
be passing this icon in from the parent composable.
107:22 - As I said, moments ago, I just wanted to give
you a sneak preview of the icon itself.
107:26 - We're not going to be writing it yet, but
we will do so later on.
107:29 - The important thing to understand here is
that we're deciding about how to handle on
107:33 - click and what this thing actually looks like
in the parent composable, we're not actually
107:37 - doing it within the toolbar.
107:39 - And by pulling that responsibility out of
the toolbar, that's how we get the reusability
107:44 - that we want.
107:46 - Right click on the components package, go
to New kotlin file, and this one's going to
107:52 - be called loading screen.
107:56 - Let's create our loading screen composable.
108:03 - The first thing we'll need is 
108:17 - a surface.
108:37 - So you might be wondering, why are we using
a surface here in particular, in this case,
108:41 - I really just want like a space surface of
the UI, which has a particular color and specific
108:47 - dimensions.
108:48 - Here I've set Phil max height to a fraction
of point eight F, which is basically saying
108:53 - I want it to take up most of the width, or
sorry, most of the height of the user interface.
108:58 - But I might want some space for something
like a an ad banner or something of that nature.
109:03 - Anyways, I basically want an icon or an image
which is stacked on top of a progress bar
109:09 - which will be stacked on top of some kind
of like text.
109:13 - So for that kind of situation, obviously we're
going to want to use a column.
109:22 - Obviously, we'll be centering things.
109:39 - Go ahead and import that.
109:58 - Now I'm noticing it's not improperly importing
our I think there's something within the Compose
110:03 - libraries, which basically mimics our so let
me just fix those imports before we proceed.
110:08 - As you can see here, I've just copy and pasted
it in the our import.
110:11 - And now we're good to go.
110:32 - That's our logo.
110:56 - Here's your progress bar.
111:10 - Okay, so you might be wondering about this
painter thing.
111:38 - So basically, in the alpha version of compose,
we had to specify whether it was a vector
111:43 - asset or a bitmap asset and stuff like that.
111:46 - So we can just use this generic painter resource
thing and point it to basically anything in
111:51 - our drawable.
111:52 - And it will actually figure out whether it's
a bitmap or a vector asset.
111:55 - Also, I wanted to point out the copy function
here.
111:59 - Suppose you have a color and you want to slightly
change the alpha value or you have one of
112:03 - these textile objects and you want to make
some kind of change to it.
112:06 - The copy function is super handy for doing
that.
112:09 - In this part of the tutorial, we will create
the event sealed class view model and presenter
112:14 - for the act of game feature.
112:17 - Before we do that, let us look at a few design
decisions involved in this architecture.
112:22 - The purpose of our presentation logic class,
which I call logic, for short, is exactly
112:27 - as the name implies, it handles the work of
coordinating the container view model and
112:32 - backend repositories.
112:34 - If notified of a non stop event, it will also
cancel all co routines, it does not possess
112:40 - any Android platform code, which makes it
loosely coupled and very easy to test.
112:45 - I might also consider reusing it for a desktop
version of this app.
112:49 - But we'll see.
112:50 - The purpose of the view model is also to do
exactly what the name implies, it is a virtual
112:56 - representation of the user interface, which
the view observes.
113:00 - In simpler terms, it is a model of the view,
it exposes function types, which is a very
113:06 - simple and easy standing for the observer
pattern.
113:10 - In situations where we don't require multiple
observers.
113:14 - Each time our logic class updates the view
model, the view model will automatically publish
113:19 - the new data to the view.
113:21 - Another design decision with this view model
is that it does not extend jetpack view model.
113:27 - There are several reasons for this decision,
some of them simple, and some of them quite
113:31 - technical.
113:32 - The simple reason is that using jetpack view
model creates tight coupling with the Android
113:37 - platform.
113:38 - And it has its own set of boilerplate code
and dependencies, which I'm not a huge fan
113:42 - of.
113:43 - In short, it doesn't solve more problems than
it creates in this particular application.
113:48 - And I wanted to practice creating view models
which might be usable for kotlin desktop or
113:53 - kotlin.
113:54 - j s.
113:55 - The technical reason why is that in this application,
we simply don't need to persist the data across
114:01 - activity instances or process death in order
to have a good user experience.
114:06 - Instead, we just make a fairly cheap call
to the Android file system and reload the
114:11 - data from there if such events occur.
114:13 - Now, before you apply that reasoning in every
situation, understand that reloading data
114:18 - from a file system works fine in this application,
but should not be considered a suitable replacement
114:25 - for unsaved instance state in every application
you write.
114:29 - If you like the models in save state handle,
go right ahead and use it.
114:33 - We also employ the strategy pattern to clean
up the interface which our logic class exposes
114:38 - to the container in the view.
114:40 - Each subclass of the sealed class represents
an action that can occur in the view or container.
114:47 - Rather than having a function for every UI
event.
114:50 - We have one function that accepts a single
object that can represent multiple different
114:55 - paths of execution.
114:57 - That's the strategy pattern.
114:59 - Right click On the UI package, and go to new
package called active game, right click on
115:07 - this new package, go to New kotlin file or
class, and we're going to create an interface,
115:13 - and it's going to be called active game container.
115:19 - This word container is a technical term.
115:21 - The way I'm using it here is to kind of signify
something which contains a large portion of
115:26 - an application or an entire application.
115:29 - In my opinion, a container doesn't usually
deal much with the business kind of logic
115:33 - of the application.
115:34 - It basically just wires things together and
builds things and kind of serves as an entry
115:39 - point.
115:40 - In the next part of this tutorial, I'll explain
what we'll actually be using as a container.
115:45 - But by using an interface here, I'm basically
stating quite explicitly that I might change
115:49 - my mind about what we use as a container.
115:52 - Anyways, it only contains two abstract functions.
116:05 - Right click on the active game package again,
and we're going to create a sealed class this
116:09 - time.
116:11 - And it's going to be called active game event.
116:17 - So as I explained in the above comment, the
active game event sealed class represents
116:22 - every kind of user interaction of a given
feature, in this case, the active game feature.
116:28 - This is a very common pattern that I use and
we'll see how it works with our base logic
116:33 - abstract class which we created in the common
package.
117:01 - Okay, we are now going to create our view
model.
117:34 - Firstly, let's create a small little class
here which will be like a virtual representation
117:43 - of a single tile in a Sudoku puzzle.
118:16 - So obviously, x&y represent the x&y coordinates
of the particular Sudoku tile value will represent
118:23 - what we talked about in graph data structures
as the color again, it's literally just a
118:28 - number, I don't know why we need to call it
a color.
118:30 - Now it has focused indicates that the user
has clicked on a particular tile, after which
118:35 - they can click on one of the input buttons
to change that particular number.
118:39 - And finally, a read only tile you can think
of as a tile, which is like a given clue in
118:44 - the puzzle.
118:45 - So therefore, the user is not allowed to actually
change any read only tiles.
118:49 - So before we start reading this view model,
I just wanted to mention a couple of things
118:53 - here.
118:54 - As discussed in the introduction for this
particular section, I didn't actually want
118:58 - to use any of the jetpack libraries to achieve
a publisher subscriber relationship between
119:03 - the view model and the view.
119:05 - Now, it turns out that that publisher, subscriber
relationship or pattern is actually quite
119:10 - easy to implement.
119:12 - But in this case, I actually found it simpler
to just use kotlin function types to achieve
119:17 - what I would call a poor person's publisher,
subscriber pattern or observer pattern.
119:21 - So this really means something simple in practice,
although it might look kind of complicated
119:25 - for those who aren't really familiar with
working with function types.
119:29 - Our view model will possess these nullable
function type references.
119:33 - As we'll see in a moment, what we can do is
each time we update the view model from the
119:38 - presentation logic class, we can then update
the view by extension by invoking these function
119:44 - types from within the view model.
119:46 - Now, the reason why we're using notables here
is from within the view model.
119:50 - I can never be 100% certain if there is actually
anything listening.
119:54 - But with that being said, I feel like if I
played around with this particular class for
119:58 - a couple of hours, I could probably streamline
a little bit and maybe make some of these
120:02 - internal variables private or something like
that.
120:05 - So really what I'm saying here is Feel free
to take this general idea of having a view
120:10 - model, which isn't tightly coupled to Android
jetpack, but also feel free to experiment
120:14 - with it and see if you can optimize it.
120:16 - So with that out of the way, let's create
some function types.
120:39 - So all of these function types will be prefixed
with sub to ensure good legibility.
120:58 - Active game screen state is actually something
we will create in the next part of this tutorial.
121:02 - So just go ahead and leave it glowing red
here.
121:06 - Okay, let me just briefly explain these different
function types.
121:12 - So the board state is basically a virtual
representation of the Sudoku board.
121:17 - Obviously, the content state basically just
means three different states.
121:21 - So either we're loading the data, the user
has a currently active game that they're solving,
121:28 - or the user has completed a particular game,
we will use this to animate between different
121:33 - states in the user interface.
121:35 - Now, timer state has to do with the count
up timer, which basically records how long
121:39 - it takes for the user to complete a given
Sudoku game.
122:04 - So just to hopefully clear up any confusion
here, timer state will be the actual long
122:08 - value in milliseconds representing the time
and then sub timer state is the way that we
122:13 - actually update the user interface after we
update the new timer state.
122:18 - Let's finish off the rest of these variables.
123:42 - These are quite obviously default values.
123:44 - Next, we'll write a function to initialize
this view model.
124:06 - Okay, so let's just pause for a moment.
124:45 - What we're doing here is we're taking the
state of the data as it existed in storage,
124:49 - we're giving it to the view model, and then
what we're doing is we're building the view
124:53 - models own virtual representation of that
state.
124:57 - Now, the view models internal representations
will have things like has focus, which are
125:02 - concerned specifically of the user interface
and not necessarily something that I would
125:06 - include in the original domain model.
125:09 - Also, in case you're wondering, the key value
is basically created from hashing the x value
125:15 - and the y value.
125:17 - This is something that we covered very early
on in this tutorial, in case you've jumped
125:26 - ahead.
125:29 - Again, active gain screen state is something
that we will create in the Compose part of
125:36 - the tutorial.
125:54 - Here, we're binding that data to the view
model.
126:32 - And then we will invoke our function types
to update the view assuming it's listening.
127:01 - And that's it for our init function.
127:02 - Now, we just have a few more functions, which
will be called by our presenter to do various
127:07 - things with the state of the view model.
128:10 - So here, we're just updating an individual
tile.
129:30 - So what we're doing here is when the user
hits a particular tile, that's going to send
129:34 - a message into the presenter, which will have
a particular x and y coordinate, and then
129:39 - the presenter will call this particular function.
129:42 - And so what it will do is it will look for
the tile which the user clicked on based on
129:45 - that X and Y value, and set that one to has
focus equals true.
129:50 - And then for every other tile, we want to
set it to false.
129:53 - Otherwise, we could have a situation where
the user has selected multiple different tiles,
129:57 - which is not something our application is
supposed to be allowed to Do and this would
130:24 - be the situation where our back end has determined
that the current puzzle is complete.
130:30 - Right click on the active game package.
130:32 - And let's create a new kotlin class, which
is going to be called active game logic.
130:37 - Okay, so before we proceed, this is definitely
one of those situations where I strongly suggest
130:42 - having the complete source code open on the
side while you follow along here.
130:47 - Obviously, I'm going to do my best not to
make any mistakes, but it's possible that
130:51 - I will make a mistake.
130:53 - Active game logic represents the presentation
logic of this particular feature of the application.
130:59 - As we'll see, it coordinates between the container
the view model, and then by extension, the
131:04 - view, as well as the back end of the application.
131:07 - Let's start with the constructor.
131:29 - Okay, so just a bit of review before we move
on, for the time being the container will
131:55 - actually be an activity.
131:57 - But there's a possibility in the future, I
might move to using fragments as containers
132:02 - instead, at this point, I don't really want
to, but we'll just see if that makes sense
132:05 - in the future.
132:06 - But this is the entire reason why I have included
an interface here so that I can change what's
132:11 - behind the interface very easily.
132:14 - The view model is pretty clear, we just wrote
it.
132:17 - Game repo is where we store the game data.
132:19 - So that includes the game settings as well
as the current progress of the users game
132:23 - stats.
132:24 - repple is where we store the records for the
shortest times to completion of each different
132:29 - difficulty and size of puzzle.
132:31 - And if you're wondering what the dispatcher
is go back and watch the common package when
132:35 - we created that we created this dispatcher
provider and I basically explained what the
132:39 - purpose of it is there.
132:54 - Base logic is also something that we created
in the common package.
132:58 - And we'll see the function that we inherit
from that class in a moment.
133:03 - Okay, let's start for a moment about co routines.
133:08 - So one way to think about scopes, whether
we're talking about co routine scope, or dagger
133:12 - or whatever, is to really just consider that
it's about a life cycle.
133:16 - Now, you're probably wondering, why are we
not making something like a view model or
133:21 - a fragment or an activity, our life cycle
class?
133:24 - Well, in case you haven't noticed by now,
I don't like any kind of tight coupling to
133:27 - the Android platform, if I can avoid it.
133:30 - There's a number of other reasons.
133:31 - But one of the main ones is that because this
class contains all of the presentation logic,
133:36 - in a sense, it's the head decision maker for
this feature of the application, then, in
133:41 - my opinion, it makes sense to make it responsible
for cancellation of any co routines, which
133:46 - happened to be currently running as far as
this on event function, which we inherit from
133:50 - base logic.
133:51 - Well, basically, this is an implementation
of the strategy pattern.
133:54 - I won't give you a long and technical explanation
here.
133:57 - It's actually a very simple pattern.
133:59 - But basically, it provides sort of like a
singular entry point into this particular
134:03 - class.
134:05 - So instead of having like a single function,
for every event, we have one function, which
134:10 - takes in an argument, our active game event,
which is capable of representing all the different
134:15 - events, and I just find that really cleans
up the interfaces between different classes,
134:20 - interfaces is used in the general sense in
that statement.
134:23 - Okay, first, let's implement our co routine
context.
134:31 - Remember, jobtracker exists in base logic,
but we also need to initialize it Okay, now
134:53 - before we proceed, there's something really
important we need to implement which is a
134:56 - ko routine timer.
134:58 - As I mentioned before, the active game Screen
does have a count up timer.
135:02 - Now some of you are probably going to be wondering,
why didn't I use the Java timer class or the
135:07 - androids count up timer or whatever it's called.
135:10 - Basically, I did try using those things.
135:12 - And they presented different application breaking
problems.
135:16 - And it turned out to be easiest just to create
this kind of CO routine timer.
135:35 - Okay, so this requires a little bit of explanation,
obviously.
135:55 - So we'll notice two different keywords here,
which might be unfamiliar to some of you,
136:00 - we have the inline and cross inline keywords.
136:03 - So whenever you see the inline keyword, the
easiest way to understand that is to understand
136:10 - that it just means copy, paste.
136:13 - And if you want to know what that means in
code, then I suggest you decompile some of
136:18 - your kotlin code, which uses the inline modifier,
and you'll see how the inline function is
136:24 - actually copy and pasted into the call site.
136:27 - Now we have something else going on here,
which is a cross inline function type.
136:33 - So before I explain what the cross inline
action is, let's talk about what this function
136:36 - actually does.
136:38 - So here we have a pretty standard spin lock,
while true.
136:41 - So it's a loop that's going to just endlessly
execute, it's going to invoke that function
136:46 - type, and then it's going to delay for 1000
milliseconds.
136:50 - Now, there's a couple different things going
on here.
136:52 - Number one, you have to understand that we
will be delaying this ko routine, but it's
136:57 - not actually going to block the thread that
it's on, which is of course a big win.
137:01 - Now the other thing that's going on here is
action is going to be a lambda expression
137:05 - that we will pass into this particular function.
137:08 - Really the only thing crossing line does is
it basically makes it so that in the lambda
137:13 - function, which we will pass into this function
here, we're not allowed to write a return
137:18 - statement in that function.
137:21 - So in the most general sense here, what we're
doing is we're taking a preventative step,
137:26 - to avoid a situation where we might accidentally
return from within the lamda that we pass
137:31 - in here causing unexpected behavior.
137:34 - Now, you're probably wondering, since we have
this endless loop going on, how do we actually
137:38 - stop this particular core routine?
137:41 - Well, what we're going to do is we're going
to create a job.
137:44 - Let's just do that now.
137:54 - And what we'll do soon is we will actually
assign this job variable to our start co routine
138:00 - timer, and that will allow us to cancel it.
138:03 - Let's just write another quick extension function
to do with this timer business and then I'll
138:08 - explain what it does.
138:38 - In experimenting with the user interface,
how to make the timer the least janky or most
138:43 - accurate that it could be it turned out that
subtracting one from the value each time we
138:48 - write it to the back end created a more consistent
timer.
138:51 - But one particular edge case is if the value
equals zero, then obviously we don't want
138:55 - to subtract one from it.
138:57 - Otherwise the timer will say negative one
at first and that just doesn't look very good.
139:01 - Okay, so with all that done, we can get to
implementing the rest of the presentation
139:04 - logic Okay, so when the user hits an input
button, we can have two different situations
140:09 - that could occur.
140:10 - In one situation, the user has already selected
a tile, which would become the focus tile.
140:16 - Or it might be that they just hit an input
button without actually focusing a tile, in
140:20 - which case, we don't really want to do anything.
140:36 - Okay, so if you're wondering about the details
of game repo, you can go back to the part
140:55 - of the tutorial where we actually build it.
140:57 - Basically, we're going to be creating a lambda
to represent the success case, and then another
141:02 - lambda to represent like an error exception
case, to make that a little bit more legible.
141:07 - I'll just add in a comment here.
141:35 - Okay, so if you're again, wondering how we
actually cancel the timer, this is exactly
142:06 - how we do it, we cancel the job object.
142:09 - Now we'll write this other function in a moment.
142:11 - Basically, if it's a new record, then we want
to render the user interface slightly differently
142:15 - than if it wasn't a record.
142:17 - But before we do that, let's finish off the
error case.
142:54 - So in order to actually know if it's record,
we actually need to pass the value back into
142:58 - the stats repo just to check on that.
143:41 - So I'm going to be honest, the error handling
in this application is not the best, neither
143:45 - is it really the worst show error Well, for
the time being just actually show a toast
143:49 - message explaining that some error occur.
143:51 - Okay, just a quick fix.
143:53 - This is actually supposed to be elapsed time
not timer state.
143:57 - Next, we have on new game clicked.
144:14 - You'll notice a recurring theme here, which
is at any time we want to perform concurrent
144:19 - operations.
144:20 - So anytime we're working with the back end,
we're going to wrap that into a launch co
144:24 - routine.
144:25 - There's a lot of different ways to work with
CO routines.
144:26 - This is just one of the most simple straightforward
ways to do it.
144:29 - In my opinion.
144:34 - Okay, so 
145:02 - what we're doing here is first we're asking
the view model has the user completed the
145:06 - current game, if they haven't, we actually
want to store the progress the user has made
145:11 - in their current game, when they hit on new
game clicked, because maybe they hit it by
145:16 - accident, or they want to be able to go back
and finish the game or some reason like that.
145:26 - That's right The update with time function.
145:56 - Again, we have success and error cases.
146:14 - Hopefully, that's pretty clear at this point.
146:22 - Next, we'll implement that function.
146:41 - Next, we'll write the cancel stuff function.
147:01 - So basically, the cancel stuff function essentially
cancels every ko routine.
147:21 - Next, we'll write on start.
147:23 - I forgot to 
147:53 - mention earlier, the reason why we had an
underscore in one of the functions for is
147:57 - complete.
147:58 - It's just kind of a convention for a lambda
argument or parameter, which doesn't actually
148:03 - end up getting used.
148:05 - In this case, we're going to use it.
148:22 - Okay, so obviously, this is where we start
the coroutine timer, and we only want to do
148:34 - that when on start is called.
148:36 - Now, again, I feel like I could have handled
this a little bit better, it kind of goes
148:40 - against my rules to consider standard flow
the application as an exception.
148:45 - But basically, what we're going to do here
is in the event that we ask the storage for
148:50 - a current game, and it doesn't actually retrieve
anything, generally speaking, this situation
148:55 - is going to occur when the user has run the
application for the first time, and hence,
148:59 - there wouldn't actually be any data stored.
149:02 - So in that particular case, we would want
to do this.
149:07 - Now, we could also end up here because of
some kind of legitimate exception, but in
149:15 - that particular case, I still think navigating
to the new game feature is still actually
149:19 - a good way to handle that good but maybe not
the best.
149:22 - Next we have on stop.
149:28 - Okay, so onstop is actually tied to the lifecycle
of the Android activity or fragment that it's
149:34 - bound to.
149:35 - So when this function is called, that basically
means that we want to save the user's current
149:38 - progress and then kind of shut everything
down.
150:03 - Finally, we have on tile focus.
150:28 - So this would be when a user actually selects
a particular Sudoku tile.
150:44 - Now this function is incredibly complicated,
so brace yourself.
150:49 - Okay, I lied.
150:56 - That's actually everything we need to do.
150:58 - In this part of the tutorial, we will create
the user interface for the active game feature.
151:04 - Before proceeding I strongly suggest you watch
my video entitled How to Understand jetpack
151:09 - compose a beginner's guide to composable and
read composition.
151:14 - We will be writing many composable and setting
up re composition as well.
151:18 - But that video is made for people who are
just getting started with compose.
151:23 - It explains what a composable is, what read
composition is and how to avoid doing read
151:28 - composition the wrong way.
151:31 - And believe me, it is fairly easy to screw
up read composition if you aren't aware of
151:35 - how it works.
151:37 - I will link to this video in the pinned comment
below.
151:40 - This video is full of a ton of information,
so please take a look at the timestamps in
151:44 - the description box below.
151:47 - Topics include basic widgets, such as text,
text, button, image, icon, spacer, and divider
151:53 - layouts, such as box column row box with constraints
and my favorite constraint layout.
152:00 - Simple transition animations to animate between
a loading screen, active game and a complete
152:05 - game.
152:06 - I also show you how to communicate with our
presentation logic and our view model using
152:12 - function types and lambda expressions.
152:15 - Before we write the composed code, though,
I show you how to set up an activity as a
152:19 - container for composable.
152:21 - The process for doing this is almost identical
for fragments if you prefer them, I also show
152:26 - you how to write a very simple dependency
injection extension function, which hides
152:31 - the backend details from the front end.
152:34 - Right click on the active game package and
go to new activity and choose an empty activity.
152:42 - And make sure you uncheck generate a layout
file.
152:46 - And this activity will be called active game
activity.
152:51 - It will be the launcher activity.
152:54 - Now in case you're wondering why we're using
this wizard instead of just creating a class
152:58 - file.
152:59 - The reason is simply that by using the wizard
it will add an entry into the manifest so
153:02 - we don't have to do that.
153:04 - Just to briefly recap the purpose of this
activity here is as a feature specific container.
153:11 - Let's start by creating a reference to our
active game logic class.
153:19 - Next, let's implement the active game container
interface.
153:33 - Click on the red and hit alt enter.
153:36 - For show error, we will use the extension
function that we created way earlier on in
153:43 - this tutorial.
153:56 - Go ahead and import.
154:03 - Also in case you're wondering, this is single
expression syntax here it basically just replaces
154:07 - the brackets and return statement with just
an equal sign.
154:11 - Next one implement on new game click.
154:32 - Now obviously we haven't created new game
activity yet so that will show up as red until
154:36 - we do.
154:37 - We also need to override two more lifecycle
methods.
154:49 - Here will tell the logic class that everything
is ready to go 
155:02 - And then we'll also override on stop.
155:18 - And that will obviously signal the logic class
that it's time to cancel things and tear stuff
155:23 - down.
155:24 - Finally, we just need to add a few lines to
on create.
155:27 - First of all, create the view model.
155:34 - Now, this is a really important part, what
we're going to do next is we're basically
155:42 - going to anchor our composable that we'll
be creating in the next part of this tutorial,
155:48 - to the activity here.
155:49 - This is also something you can call inside
of a fragment.
155:57 - Go ahead and import that.
156:02 - Naturally, we're gonna wrap everything in
our compose theme.
156:09 - Now, this is a very critically important thing
to understand and a very important pattern.
156:19 - So when we create active game screen, we're
going to pass in a function type, which will
156:25 - serve as our event handler, which is basically
my way of saying that is the way in which
156:31 - we will forward the events, the onClick events
and stuff like that, that occur in the composable
156:38 - to our presentation logic class.
156:40 - So make sure you pay attention to what I'm
saying here, because this is a really important
156:43 - part, even if you don't use presenters wood,
or whatever.
156:48 - Function types are an excellent way to handle
on click events, especially if you combine
156:54 - them with the strategy pattern, which we discussed
in the previous section.
157:01 - Okay, now, if you've never seen a function
reference, I believe it's called basically
157:12 - what we're doing here is we are pointing to
the on event function of the logic class.
157:19 - This really is a function reference.
157:21 - So hopefully, you can understand what I'm
talking about here.
157:25 - We'll also pass in the view model.
157:30 - Now lastly, we actually need to build our
logic class.
157:33 - So what we'll do is we will write that code
in an extension function, but what we can
157:38 - do first is just read it here.
157:55 - And that's everything we need to do in our
activity.
157:58 - Right click on active game, go to new package,
and this package will be called build logic.
158:05 - Right click on that package and go to New
kotlin file or classes is going to be a file.
158:09 - And it's going to be called build active game
logic.
158:16 - If you've been watching my channel, or live
streams for some time, you'll know that I
158:19 - talk a lot about dependency injection service
locators.
158:23 - And one of the things I say all the time is
that in a small application, you really don't
158:28 - need to use di container, like hilt, dagger,
whatever, you can use it.
158:36 - But what I always advise for beginners is
to write the code that these things generate
158:41 - for you, yourself first, so that you understand
what these frameworks are doing for you.
158:46 - So that's exactly what we're going to do.
158:48 - We're going to write the kind of thing that
these frameworks generate for you.
158:53 - And in a small application, it's actually
very simple code to write.
159:12 - And, of course, it's going to return active
game logic.
159:45 - Okay, let's pause for just one moment here.
160:03 - So in case you're wondering how we get the
path to the storage directory that we can
160:08 - use for this application, you can call context
dot files dir dot path.
160:23 - Finally, our dispatcher.
160:39 - And that's all we need to do.
160:40 - Right click on the active game feature, and
create new kotlin file called active game
160:46 - screen.
160:47 - First, let's create an enum.
160:57 - This enum represents different states, which
this feature of the user interface can possess.
161:09 - The actual state is held in the view model,
but we will see how we can update our composable
161:14 - UI by binding to the view models function
types we created in the previous part of this
161:20 - tutorial.
161:30 - Active game screen represents the root composable.
161:34 - In this hierarchy of composable, it has the
responsibility of setting up the core elements
161:39 - of the UI, and also animating between them.
161:59 - event handler function type reference is how
we call back to the presentation logic.
162:04 - When the user interacts with the application,
it must be passed down to any composable,
162:09 - which has such interactions, we also pass
in the view model, which is how we actually
162:13 - give the data to our UI.
162:34 - In very simple language, whenever we have
some kind of data or state, which may change
162:40 - at runtime, we want to wrap that data in a
remember delegate.
162:45 - This tells the Compose library under the hood,
to watch for changes and to redraw the UI
162:50 - if a change occurs.
162:53 - Now mutable transition state is used specifically
for animations here, so don't use this everywhere.
162:59 - We will see a more general purpose example
of a remembered state later on.
163:12 - Remember, delegate prepares compose for updates,
but we also need a way to actually update
163:27 - the value.
163:28 - We do this by binding a lambda expression
to one of the function types which our view
163:33 - model possesses.
163:34 - When one of those functions is invoked in
the view model, the program automatically
163:38 - jumps to and executes this code within our
composable.
163:42 - This is what actually triggers the re composition.
163:57 - We have a remembered transition state and
a way to update that state from the view model.
164:02 - Now we need to set up the transition animations
themselves.
164:06 - This is where you can get as creative as you
like.
164:08 - In this app.
164:09 - Each content state has its own composable
associated with it.
164:13 - We animate between them simply by changing
the alpha value or transparency.
164:59 - Now it was truly up as red a moment ago, the
way I fixed that was to manually import the
165:04 - Compose runtime.
165:06 - So the transition spec tells compose details
about what the animation should look like.
165:11 - Essentially, this means we don't have to write
our own mathematical instructions, which is
165:15 - great for someone like me who sucks at arithmetic.
165:44 - One option for compose is to use the scaffold
composable as a skeleton for your UI.
165:49 - I personally prefer to do this myself, since
it's not really that difficult, and it doesn't
165:53 - hide anything from me.
166:03 - First, we have our app toolbar.
166:42 - Let's go ahead and create that new game icon.
167:03 - These icons come from the Compose material
library, I highly recommend you use it.
168:00 - This is how we actually trigger an on click
event.
168:25 - As explained in a previous part of the tutorial,
by creating our toolbar icon here and passing
168:30 - it into the app toolbar composable, we make
the app toolbar reusable.
168:35 - Below the toolbar we have the main content
of this screen, which can have three different
168:40 - states.
169:18 - Each time a re composition occurs, this one
statement will be executed again.
169:33 - The act of alpha value will change when the
transition animation occurs, thus fading out
169:39 - the previous content state and fading in the
new one.
169:45 - Obviously, we will create these in a moment.
170:30 - And that's it for our route composable the
most complex part of our UI comes from an
170:45 - active Sudoku game.
170:47 - A nine by nine puzzle has 81 different texts
composable, which is a large number of widgets.
170:54 - The way I went about writing this composable
was to think of each part of the Sudoku game
170:59 - as a particular layer or element.
171:02 - Be sure to avoid writing God composable by
making usage of helper functions, which break
171:07 - down the UI into the smallest reasonable parts.
171:22 - box with constraints is kind of like a composable
wrapper, which gives us information about
171:27 - the height, width and other measurements,
we can use that information within its lambda
171:32 - expression.
171:52 - We need to know the screen width in order
to determine how wide and tall the Sudoku
171:57 - board should be.
171:58 - Here we asked for the max width of this constraint
layout.
172:02 - Here we ask for the max width of this layout
composable.
172:06 - But we need that value to be in density independent
pixels, and it needs to be relative to the
172:11 - density of the current screen as well.
172:14 - That's where the two dp extension function
comes in.
172:17 - And it uses the local density to determine
that value.
172:56 - The margin of the board also needs to change
based on the screen density.
173:00 - I arrived at these values simply by testing
the app on various densities using the emulator.
173:07 - Next, we will write a constraint layout, which
is a totally awesome way to manage dynamic
173:18 - layouts.
173:30 - Now in order to constrain composable to each
other, we need a way for them to reference
173:35 - each other.
173:36 - This is equivalent to setting IDs for XML
views.
173:39 - First, we create these references and you
will see how to bind them later on.
173:44 - Let's create a layout container for the puzzle
board.
174:00 - Okay, so this is really important see how
we're passing in that reference in the constrain
174:34 - as parameter there.
174:35 - This is how we actually associate a particular
composable with a particular reference.
174:41 - This box composable will be associated with
the name board.
175:25 - Next we'll create the Sudoku board itself.
175:39 - Again, the boundary is like the size of the
puzzle.
175:53 - So it's either a four by four puzzle or a
nine by nine puzzle.
175:56 - So boundary would either be four or nine.
176:10 - This is supposed to say size.
176:13 - So the offset here is used to evenly distribute
the screen real estate for each Sudoku, tile
176:18 - and grid line.
176:27 - Here's a way to make a mutable state which
is not associated with some kind of transition
176:32 - animation.
176:33 - So this is the more general purpose approach.
176:45 - So the first argument here view model dot
board state can be thought of as the initial
176:49 - value, never equal policy ensures that even
minor changes in the state like has focus
176:55 - actually triggers a re composition.
177:05 - Again, this is how we actually update the
value once the view model is updated.
177:39 - As you can see, here, again, I'm making usage
of lots of helper functions to break things
177:44 - down.
177:51 - Here we render the text fields which represent
tiles in the puzzle, they can either be read
177:56 - only or mutable, thus, meaning that we need
to render them slightly differently.
178:30 - So here, we're saying if the user sets a particular
tile to a value of zero, we actually just
178:34 - want to render it as an empty tile.
179:45 - The main idea here is that we're using the
x and y values of each individual tile along
179:50 - with the offset in order to evenly position
each tile 
180:29 - So when the user selects a tile, it's going
to become focused and we want to render that
180:33 - tile obviously a little bit different than
an unfocused tile.
181:09 - Now we'll render the read only squares.
181:41 - Next we'll create the board grid.
182:13 - So Sq RT is an extension, which is actually
defined in the computation logic.
182:17 - In retrospect, I probably should have defined
that in the common package, but it's pretty
182:21 - obvious what it does.
182:23 - So this function here, we'll draw the grid
lines that separate the Sudoku puzzles.
182:27 - To make it more obvious to the user which
sub grids are which we draw different borders
182:32 - to separate the four by four or nine by nine
sub grids.
182:36 - This is why we're using modulo here.
183:43 - So this will draw both the vertical and the
horizontal lines.
183:46 - Okay, so we're jumping back into the game
content composable to finish it off.
183:51 - below our Sudoku board, we have some different
icons to indicate the difficulty of the puzzle.
185:36 - Next we need a layout container for the count
up timer that's great, the timer texts composable.
186:17 - Now 
186:36 - the default value, it's just empty.
187:03 - Okay, we're back in the game content composable.
187:31 - The last thing we need to do is just add a
layout container for the input buttons.
188:29 - Now we're about to hard code some values in
here and that is kind of bad practice.
188:33 - But the reason is that the Compose team deprecated
flow row, which I'm still upset about, and
188:37 - it worked perfectly for this situation, and
I've been too lazy to implement flow myself.
188:46 - Hey, at least I'm being honest.
189:10 - In case you're wondering, 0.4 and five dot
dot nine will emit a range inclusive of those
189:17 - values.
189:18 - Let's create that composable a spacer is pretty
self explanatory, it just takes up some space
190:04 - in the layout.
190:06 - Next we have the buttons themselves.
191:21 - This text button wrapper allows us to style
a nice looking button instead of just adding
191:25 - on click on a text composable.
191:48 - Alright, that's it for gain content.
192:12 - Now we need to do the game complete content
screen, which is obviously when a user finishes
192:17 - a game.
193:11 - So this is basically just two images stacked
on top of each other, but we're only going
193:15 - to render one of them if it is actually a
new record that the user made.
194:02 - So since we don't actually create the emoji
events icon, we can change the color of it
194:07 - using this color filter thing.
194:09 - Pretty handy.
194:38 - Next, we have to text composable.
195:57 - And that's it.
195:58 - Congratulations.
196:00 - In this part of the tutorial, we will examine
the topic of graph data structures, mostly
196:04 - with respect to solving Sudoku.
196:07 - Unlike the rest of this tutorial, which is
presented in a code along format, This lesson
196:11 - will be different.
196:13 - Instead of rewriting all the code, we will
look at the basics of a graph data structure.
196:18 - How I modeled a Sudoku puzzle as a graph data
structure, how I created, tested and improved
196:24 - my algorithms to the point where they could
generate 100 puzzles in roughly 400 milliseconds.
196:31 - before I proceed, I suggest you read my article
on Free Code Camp, which explains the fundamentals
196:36 - of software engineering in a clear and accessible
way.
196:40 - That article explains these topics assuming
only that you have some basic coding skills.
196:45 - Let's start by asking a question, what are
graph data structures?
196:49 - The simplest verbal explanation I can think
of is that they are a family of data structures,
196:54 - which are useful for modeling a bunch of things
which are connected in some way.
196:59 - To connect that definition with something
visual, you can imagine that the bunch of
197:03 - things are a series of nodes or points, and
the connections between them are a series
197:09 - of edges, which you can think of as lines
connecting the points.
197:13 - So whenever I say the phrase graph data structure,
a better term for most people to understand
197:18 - this topic is a network data structure.
197:21 - In fact, that is exactly how they are used
in apps like Facebook to represent users and
197:26 - friends.
197:27 - Google Maps to represent city addresses in
the roads connecting them or Sudoku puzzles
197:32 - to represent tiles which have relationships
to each other.
197:35 - According to the game's rules.
197:37 - Pictures and words are fine, but the code
is more important.
197:40 - How do we tell a computer system to virtually
represent a Sudoku puzzle?
197:45 - This process is more concrete than you might
think, though, it helps to be an expert in
197:49 - the programming language you're using.
197:52 - In principle, the process is to take all of
the information you know about the problem
197:56 - you're solving, ie the problem domain, and
start writing code which describes it.
198:01 - First, we represent a single tile in a Sudoku
puzzle with the class Sudoku node.
198:07 - It has a value x and y coordinates and a Boolean
to establish whether it can be edited or not
198:13 - by the user.
198:15 - Read Only true would indicate a node which
is a given clue at the start of a new Sudoku
198:20 - game.
198:21 - Now this term color really just means a value
from zero to the boundary of the puzzle.
198:26 - So a nine by nine puzzle would have the colors
zero to nine.
198:30 - To be honest, I don't like using the term
color as it confused my hyper literal brain.
198:36 - But please understand that it really is just
a number value.
198:39 - And the term color is actually irrelevant
in this problem domain.
198:44 - Where the word came from is that this kind
of data structure was used to solve a problem
198:49 - that involved coloring different countries
on a map using a fixed set of colors.
198:55 - We could have just as easily associated these
numbers with different kinds of sandwiches,
198:59 - but to the computer, it is the same thing.
199:02 - In any case, if you hear me say color, just
remember it's a value, it's a number, not
199:07 - literally a color.
199:09 - Now the data structure itself must include
every element, as well as the connections
199:14 - or relationships between every element.
199:17 - There is no single way to do this, but I arrived
at using a linked hash map datatype from the
199:23 - kotlin standard library.
199:25 - This data type preserves the ordering of its
elements, and allows me to find a specific
199:29 - element based on a hash code.
199:32 - The hash code itself comes from this simple
hashing function which generates a unique
199:37 - key based on the x and y values of a node.
199:40 - The linked lists themselves represent both
the root node at a given x&y location as well
199:46 - as any other node which happens to be in the
same row column or sub grid of that root node.
199:52 - The root node will always be the first node
in the list known as the head element.
199:57 - But other than that, we don't care about the
ordering of the rest of the So after I figured
200:02 - out how to model a Sudoku game in this way,
the next step was to start writing the algorithms
200:07 - to manipulate my chosen data structure.
200:10 - The first algorithm I wrote was called build
nodes.
200:13 - Its job was to build the skeleton of our data
structure.
200:16 - By adding an element for every tile in the
puzzle.
200:20 - A square size in Sudoku will have n squared
tiles or elements.
200:25 - So the first thing I did was write a unit
test to check for that condition.
200:30 - Here we see the first example of the process
I used to write these algorithms.
200:34 - I tried to solve the problem one step at a
time and to verify the correctness of each
200:39 - step as I went.
200:40 - Next, I knew that I needed to create the edges
or relationships between different tiles based
200:46 - on the rules of the game, nodes would share
a column may not have the same value or color
200:52 - nodes would share a row may not have the same
value, nodes would share the same sub grid
200:57 - may not have the same value.
200:58 - Now, we haven't actually added any values
yet, but we can still build the edges of the
201:03 - graph using these rules.
201:05 - After looking at a picture of a four by four,
nine by nine in 16.
201:09 - By 16 Sudoku puzzle, I was able to determine
that every tile will have the same number
201:14 - of edges as any other tile, and those numbers
happened to be 821 and 40, respectively.
201:21 - At first, the test was failing.
201:23 - But I figured out that a node can be for example,
in the same column and subgrid.
201:27 - So I needed in my algorithm to be smarter
about avoiding those kinds of repeats.
201:33 - The previous two algorithms were childsplay.
201:35 - Whereas now we get into some more difficult
problems.
201:38 - The seed colors algorithm caused me huge problems
and took many days to get working properly.
201:43 - The purpose of this algorithm was to provide
some initial values, ie seed values to make
201:49 - the next step in the algorithm easier.
201:52 - At first, I tried to do this by distributing
the values diagonally, which is a relatively
201:56 - safe way to avoid breaking the rules.
201:59 - But this approach led me to an uneven distribution
of initial values.
202:03 - I thought this was a problem and eventually
came up with a new algorithm that would make
202:07 - horizontal and vertical passes of the entire
puzzle, allocating numbers in such a way that
202:14 - was guaranteed not to break the rules and
provide an even distribution.
202:19 - While I'm proud of this algorithm in a certain
way, on a certain level, it's also disgustingly
202:23 - complicated and proved pretty difficult to
test, I settled on ensuring that it wasn't
202:27 - creating an invalid puzzle, and it was allocating
a number of values roughly equal to A quarter
202:33 - of the total number of tiles.
202:36 - If I allocated too many tiles, it would cause
problems though, so I had to include some
202:39 - hard coded edge cases, which I didn't really
like.
202:43 - Perhaps most important algorithm in this series
of algorithms is the solver algorithm.
202:49 - The solver algorithm takes in our seated graph
and attempts to solve the puzzle from there.
202:54 - Now I had already written a few other solver
algorithms that didn't use graph data structures.
203:00 - So I was curious to see if using a graph would
actually make this process easier.
203:04 - In some ways it did, but it was still overall
quite difficult to write a high performance
203:08 - solver for n sized Sudoku puzzles.
203:12 - Every algorithm for generating a Sudoku puzzle
that I'm aware of makes usage of three things.
203:19 - brute force random number assignment, checking
if these new assignments create an invalid
203:24 - puzzle.
203:26 - backtracking when an invalid puzzle is created,
or the algorithm is simply not able to allocate
203:31 - any new values without actually breaking the
rules of the game.
203:36 - The problem with brute force random number
assignment is that it scales very poorly as
203:40 - the size of the puzzle grows, randomly generating
a four by four Sudoku puzzle is quite easy
203:46 - that way.
203:47 - But even a nine by nine puzzle can take a
long time if you just use random numbers and
203:51 - backtracking.
203:53 - There's no way the app would be any good if
the user had to sit and wait for five minutes
203:56 - just for the app to generate a new puzzle.
203:59 - As is often the case, the solution to this
problem came from figuring out the right question
204:04 - to ask, How do I tell the computer to make
smart decisions about assigning values instead
204:10 - of just purely random decisions.
204:13 - In the end, I settled on giving the algorithm
a nice value, which is inspired by nice values
204:19 - in CPU scheduling.
204:21 - In principle, the algorithm will select an
empty tile and look at the number of possible
204:26 - values we can assign to that tile with respect
to the rules of the game.
204:31 - This is done by looking at the rest of the
elements in the linked list for that tile,
204:35 - and seeing how many of them are already colored
that is given a value in a nine by nine puzzle
204:41 - if eight other tiles in the list already have
a unique value than the tile we have currently
204:47 - selected, can only have one possible correct
value.
204:51 - If seven tiles are already colored, we have
a 50% chance of guessing the correct number
204:57 - which is still pretty good odds.
204:59 - So the nice value represents how picky the
algorithm is in deciding whether or not to
205:04 - assign a value.
205:06 - The nice value itself is adjusted constantly
with the basic idea being two things.
205:11 - If the algorithm has looked at many elements
and could not find a sufficiently safe guess,
205:16 - we increment the nice value, thus allowing
the algorithm to make riskier guesses.
205:21 - If the algorithm assigns a value, it becomes
pickier again by decrementing the nice value.
205:26 - The other important part of this algorithm
is the multistage backtracking.
205:31 - This part was very difficult to figure out,
and it required trying a lot of different
205:35 - approaches.
205:36 - In order to work smoothly for four, nine and
16 boundary puzzles, I settled on using three
205:41 - stages of backtracking.
205:44 - In the first stage, when the algorithm gets
stuck, we remove half of the values we have
205:48 - allocated to the puzzle.
205:50 - In the second stage, we remove all values
we have allocated to the puzzle, but we keep
205:55 - the same seated values.
205:58 - In the final stage, we remove all values and
generate a new seed then reset the algorithm
206:03 - to start from scratch.
206:04 - After playing around with both the nice values
and the conditions for each stage of backtracking,
206:10 - something magical happened, I made one small
change to the nice value adjustment.
206:15 - And suddenly, as you can see from my benchmark
tests, the algorithm was generating 101 nine
206:21 - by nine Sudoku puzzles in roughly 400 milliseconds
instead of over four minutes.
206:27 - At first, I didn't trust what I was seeing.
206:29 - But after removing the change I had just made,
we were right back two minutes instead of
206:33 - milliseconds.
206:35 - The key takeaway is that every time I made
a small change to the algorithm, I rerun the
206:40 - benchmarks to see what changed.
206:42 - Tests are absolutely critical when you are
writing new algorithms, as they tell you both
206:47 - the correctness and efficiency of your code.
206:51 - I was super excited to have a working Sudoku
solver that was crushing my benchmarks, but
206:56 - there was still one more algorithmic dragon
to slay.
207:00 - As you can guess a solved Sudoku puzzle is
not actually useful to a person looking to
207:04 - solve a Sudoku game, which happens to be our
entire user base.
207:09 - Having generated a complete and valid puzzle,
the next thing to do was to remove a certain
207:14 - amount of values to make the game playable
again.
207:17 - At first, I thought the difficulty of a Sudoku
puzzle was largely dependent on how many initial
207:22 - clues are given to the user.
207:24 - That idea is true at the extremes of a complete
puzzle or an empty puzzle, but not so true
207:30 - in the middle.
207:31 - What I mean is that you can definitely have
a Sudoku puzzle with 33 given clues that is
207:36 - easy to solve without guessing and have a
puzzle with 38 given clues that is impossible
207:42 - to solve without guessing.
207:44 - So I suddenly realized that I was going to
need to invent some way of establishing the
207:49 - difficulty of a Sudoku puzzle in a consistent
way.
207:53 - Now, I knew that there must be some way to
do this mathematically.
207:57 - But the truth is that mathematics is not a
natural way for me to solve problems.
208:01 - I was great at calculus, but only for the
reason that I could visualize the graphs which
208:05 - the equations described.
208:07 - Instead of trying to model this problem in
mathematical terms, I visualize the things
208:11 - that I actually do in order to solve various
difficulties of Sudoku puzzles.
208:16 - I then figured out how to tell the computer
to employ these different strategies to attempt
208:20 - to solve a puzzle without making any random
guesses.
208:23 - This led to creating three kinds of strategies
which dictate the difficulty of a given puzzle.
208:29 - In the basic solving strategy, a puzzle can
be solved simply by going through each square
208:34 - and asking if there is only one possible value
that can be placed in that square based on
208:39 - the rules of the game.
208:40 - In the advanced strategy, we still use the
basic strategy, but we also look for a situation
208:45 - where a node has two possible values, we then
look for another empty node, which has an
208:50 - edge to the original node that also has the
same possible two values.
208:55 - Finally, we test assigning both values to
both nodes.
208:59 - Three things can occur when this happens if
both result in a valid Sudoku puzzle.
209:04 - This doesn't actually help much because it's
possible to make valid assignments that still
209:08 - result in an invalid puzzle later on.
209:12 - If both result in an invalid puzzle, this
is obviously not a good situation.
209:16 - Finally, if one configuration is valid, but
the other isn't, then logically, the valid
209:21 - configuration is correct.
209:24 - The final solving strategy basically means
that the puzzle cannot be solved in a purely
209:28 - logical way, ie you must make guesses to solve
it, or it requires some kind of advanced strategy,
209:35 - which I'm not aware of.
209:36 - I'm not an expert in Sudoku, but I'm better
than the average player.
209:40 - So either way, I would consider that to be
a hard puzzle.