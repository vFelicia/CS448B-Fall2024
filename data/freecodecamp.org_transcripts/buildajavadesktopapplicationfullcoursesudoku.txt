00:00 - hi this is Ryan and you're watching my
00:02 - tutorial on Java in a moment we are
00:05 - going to build an entire application
00:08 - from start to finish and I'm going to be
00:10 - with you typing it out and explaining
00:12 - how it works the whole time now this
00:16 - video is a free complement to my course
00:18 - working class Java I prefer to teach
00:22 - people by building things because that's
00:25 - mostly how I learned I don't have a
00:27 - degree in anything but I want to make
00:30 - sure you have answers to questions like
00:34 - when exactly do I use an interface or an
00:38 - abstract class is there really such a
00:40 - thing as the perfect software
00:42 - architecture chances are you want the
00:45 - answer to that question because that is
00:46 - the most common question I have been
00:48 - asked from the thousands of people that
00:51 - I have taught over the years so in this
00:53 - video we are going to write code and
00:56 - solve specific problems I will include
01:00 - overlays which will point you to lessons
01:02 - in the course which explain in simple
01:05 - language and I do mean that virtually
01:08 - every concept from absolute beginner to
01:11 - things which even senior Java developers
01:14 - are not sure on believe me if you make
01:17 - it through these two learning resources
01:18 - you will have everything I wish I had as
01:22 - a beginner
01:23 - all I ask is that you follow along with
01:25 - me during the practical lessons even if
01:28 - they do not make sense at first sound
01:31 - fair enough great let's get started I
01:34 - don't care whether you are a UI UX
01:37 - designer an app developer or a database
01:39 - administrator every app you build starts
01:42 - with some form of problem domain
01:44 - analysis BOM domain analysis which I
01:46 - discuss in detail in working class Java
01:49 - can be summarized by asking two simple
01:51 - questions what data does my app need to
01:53 - represent what problems does my app need
01:56 - to solve for its users in this lesson we
01:59 - will build the first few classes for the
02:01 - Sudoku game these classes are very much
02:03 - like the foundation of a building as we
02:05 - will build the rest of the application
02:07 - on top of them so I've created a new
02:10 - project in IntelliJ IDEA and I'm just
02:13 - to correct the package name here and
02:16 - we'll delete the sample FX ml file
02:19 - that's one way in which you can build a
02:21 - user interface in Java FX but we're
02:24 - going to do it programmatically in Java
02:26 - instead yeah we won't need that
02:31 - controller class and also we will work
02:35 - on creating the main class properly in a
02:38 - different video when we talk about
02:40 - application containers so what we're
02:42 - going to focus on in this video like I
02:44 - say is the classes within the problem
02:46 - domain so the first one we're going to
02:56 - build is just a virtual representation
02:58 - of a Sudoku game as you can see here
03:13 - so this thing here gamestate is actually
03:15 - going to be an enum that we will create
03:17 - in the next lesson represents different
03:20 - states of a game it's my codes usually
03:22 - pretty easy to read
03:23 - I represent the actual Sudokus grid the
03:28 - puzzle itself as a two-dimensional array
03:30 - as you can see here and this is actually
03:33 - just a constant which I use throughout
03:35 - the application you'll notice that I
03:37 - forgot to write int I will fix that
03:39 - eventually but yeah 9 of course
03:43 - represents the number of squares in a
03:45 - Sudoku puzzle now I'm hitting alt insert
03:48 - here and that's allowing IntelliJ to
03:52 - open up a dialog to generate my
03:54 - constructor and some getters for the
03:57 - getter for the grid state I'm actually
03:59 - going to make it sort of immutable and
04:02 - what I mean by that is we're not
04:03 - actually going to just return grid state
04:05 - here we're going to return a copy of
04:08 - grid state a little mistake there how
04:12 - I'm going to do that is I've I will we
04:14 - will eventually create this class called
04:16 - Sudoku utilities which has a static
04:18 - function or method which will create a
04:21 - copy of that given array this basically
04:23 - protects this Sudoku game object from
04:25 - being messed with or changed over time
04:28 - and then we're also going to add
04:29 - implements serializable here this is
04:32 - just so that I can read and write this
04:34 - particular game data file to a file on
04:38 - the operating system easier we'll talk
04:41 - about all that later and there we go
04:42 - fixing the mistake there so the next
04:49 - thing we're gonna build is a little
04:50 - class here called coordinates and it's
04:52 - just going to contain an X and a y value
04:55 - and some interesting functions which we
04:57 - will use with our hash map
04:59 - implementation when we're at the user
05:01 - interface by the way there's a whole
05:06 - bunch of things going on here for
05:07 - beginners there's you see private you
05:09 - see final you see static I talked about
05:11 - all of this stuff in working class Java
05:13 - so do consider checking out the course
05:15 - so we're just going to make a
05:17 - constructor and some getters would be
05:19 - useful as well and then we're going to
05:22 - also add in some functions now or what
05:26 - say functions I mean methods every heir
05:28 - of their language basically calls them
05:29 - functions so what we have here this
05:33 - equals method comes from the object
05:37 - class in Java which every every class
05:40 - extends from object implicitly and the
05:44 - reason why we're doing this is we want
05:45 - to be able to store these coordinate
05:47 - objects in a hash map we're actually
05:50 - going to basically be using them as keys
05:52 - to key keep track of different UI
05:55 - elements anyways I'll talk about that
05:57 - more when we actually get to it got a
06:03 - little a reference to some Snoop Dogg
06:07 - here this and that it's like this and
06:09 - like that unlike this Sena sorry I
06:12 - apologize I grew up on gangster rap
06:14 - alright so yeah nothing super
06:18 - interesting going on here just a whole
06:19 - bunch of boilerplate code do try to
06:21 - follow along because as you can see here
06:23 - I'm not copy and pasting anything and it
06:25 - is my intention that you follow along
06:27 - with this tutorial now the other thing
06:29 - we're going to implement is a hash code
06:32 - function so basically what a hash code
06:35 - is it's kind of like a unique identifier
06:37 - which is generated from some kind of
06:40 - data that you give it so what we're
06:42 - gonna do is we're just gonna take the x
06:44 - and y value and we're going to use this
06:46 - objects hash function and what that's
06:49 - gonna do is it will generate a unique
06:51 - identifier from the specific X&Y value
06:54 - of the specific coordinates thing like I
06:57 - say we'll see more about that later and
07:01 - then you might be wondering why am i
07:04 - creating an interface here I actually
07:06 - decided on this interface during my
07:08 - problem domain analysis stage a cool way
07:11 - to use interfaces is to is to design
07:14 - parts of your application upfront ahead
07:17 - of time this is called design by
07:18 - contract or code to an interface or
07:21 - whatever also I'm anticipating i/o
07:25 - exceptions because this is an i/o device
07:27 - and yeah this is just basically read and
07:30 - write nothing else going on here if
07:33 - you're wondering about interfaces I go
07:34 - into great detail in them in part 4 of
07:37 - my course that's
07:40 - all for now as discussed extensively in
07:43 - part two of working-class Java we can
07:45 - ask a few simple questions about our
07:47 - data to best determine how to model it
07:49 - two great tools for modeling data which
07:52 - does not change throughout the runtime
07:54 - of the application our static final
07:57 - variables and enums the gamestate enum
08:01 - is rather self-explanatory it basically
08:03 - represents different potential states
08:05 - that the game might be in so we have
08:08 - complete active and new and we will see
08:11 - in later parts of this tutorial or a
08:14 - lesson series here where that kind of
08:17 - comes into play we're also going to make
08:19 - a couple different constants for
08:23 - different messages which will pop up in
08:25 - the application in this case this is
08:32 - just going to be a message that will pop
08:34 - up when the user wins a game and I'll
08:37 - have like a little dialogue alert dialog
08:39 - pop up I'll show you how to do that when
08:41 - we build the user interface and it's
08:43 - just gonna display a nice message here
08:45 - congratulations you have one new game
08:52 - and we'll also do a quintessential error
08:56 - message here always good to let the user
09:02 - know that an error has occurred also it
09:05 - took me a minute to remember how
09:06 - occurred was spelled and there's only
09:10 - one thing left to build which is another
09:13 - enum this time actually just selecting
09:16 - them there and this one's called rows
09:17 - all this is for is legibility concerns
09:21 - and you will see how that helps us way
09:23 - later on that's it for this one every
09:27 - application needs an entry point we will
09:29 - now set up an entry point for our Sudoku
09:31 - application in JavaFX now we're going to
09:34 - rename this class main here to Sudoku
09:37 - application and you'll see in a minute
09:40 - we'll actually create a new main class
09:42 - now this main class here exists purely
09:46 - for convenience to be able to actually
09:47 - launch this application from IntelliJ
09:50 - IDEA the reason for it is
09:54 - if we try to actually just run launch
09:55 - our sodoku application then there will
09:58 - be a crash so what we do is we invoke
10:00 - from here first and then in this main
10:03 - method we will actually call the main
10:04 - method within sodoku application which
10:07 - we will see in a minute but this is
10:08 - purely for a convenience sake some
10:13 - lightning fast typing skills here eh so
10:18 - within sodoku application other than
10:21 - fixing some typing errors we're just
10:22 - going to get set up here
10:33 - oh sorry didn't mean to yell so the
10:36 - first thing we're gonna add here is a
10:38 - reference to AI user interface contract
10:41 - dot view which actually is the user
10:43 - interface notice how I like to prefix
10:46 - interfaces with AI and then I will
10:49 - suffix their implementations with UI
10:51 - imple energist impulse pacifically so UI
10:56 - imple will be creating very shortly
10:58 - which represents the actual user
11:00 - interface this stage object that we're
11:03 - passing to it is basically a simple
11:05 - window which JavaFX gives us so that we
11:08 - can modify it and the sodoku build logic
11:12 - class will be actually writing that
11:13 - class at the very end it contains the
11:16 - build logic which is kind of like what
11:18 - you would see with a dependency
11:19 - injection type set up the code required
11:21 - to wire things together now that
11:26 - operation could potentially fail so we
11:28 - are ready to catch an i/o exception if
11:30 - that does actually occur also I didn't
11:36 - have to actually write the main method
11:38 - in this application class because it was
11:41 - automatically generated by IntelliJ IDEA
11:44 - but I'll just scroll down to show you
11:46 - you'll need to have that setup down
11:48 - there in case you're writing this all
11:50 - manually so the next thing we're going
11:51 - to do is we are going to figure out how
11:53 - to import Java FX into our IntelliJ
11:58 - project here so go to file project
12:00 - structure click on libraries hit the
12:02 - plus button hit java and then what you
12:05 - do is you'll select the lib folder in
12:08 - the Java FX SDK you will have to
12:10 - download that but that's all we're doing
12:12 - here go ahead and click OK and I hit OK
12:15 - again and now you can see application
12:18 - has been imported properly and we're all
12:20 - done ok we are now going to build the
12:22 - user interface for this Sudoku game
12:24 - please be aware that I designed the user
12:26 - interface ahead of time using envision
12:29 - now before we get to actually
12:30 - implementing the user interface I
12:32 - actually like to design it and the class
12:34 - that will talk to using Java interfaces
12:37 - now if you have any confusion over when
12:40 - to use interfaces or how they work and
12:42 - the same goes for abstract classes I
12:44 - explain this very
12:46 - and very simply in working-class Java
12:49 - and I really mean that I don't use a ton
12:51 - of words to explain it it's really quite
12:53 - simple if someone gives just a clear
12:55 - explanation which is pretty rare anyways
12:58 - so what we've got going on here as you
13:00 - can see I've actually nested the event
13:02 - listener interface in the I user
13:04 - interface contract basically what I'm
13:06 - doing is I'm using the parent interface
13:08 - as kind of like a namespace or a way of
13:11 - differentiating different interfaces so
13:14 - if I had multiple different user
13:16 - interface components or features this is
13:19 - how I would differentiate them because
13:21 - most of them would have like an event
13:22 - listener and a view and then the I user
13:25 - interface contract kind of points to
13:27 - which part of the application for the UI
13:29 - that we're talking about so it's kind of
13:32 - a handy little trick there the event
13:34 - listener will be something like a
13:36 - controller or a presenter I like to name
13:40 - things based on what they do because
13:42 - typically that's the best kind of name
13:44 - you can give something as for the view
13:47 - anyone who's familiar with three-layer
13:48 - software architectures will know that
13:50 - that is basically a name for some kind
13:52 - of part of the application which binds
13:54 - to the user interface that's typically
13:57 - what it means anyways
13:59 - I also talked about three layer
14:00 - architecture is a whole bunch in working
14:03 - class Java including answering the
14:06 - age-old question that I get asked all
14:08 - the time which is the best architecture
14:10 - is a mvvm MBP MVC and there is an answer
14:15 - it might not be the answer you like but
14:18 - I think I have a pretty good answer to
14:19 - that question in any case I explain the
14:22 - fundamentals of all the different types
14:23 - of architectures preferences aside now
14:27 - do notice I wrote a capital message and
14:29 - show dialog there I will fix that
14:31 - eventually but that was a little mistake
14:36 - so what we're making now is basically a
14:39 - special custom text field so text field
14:43 - actually comes from JavaFX just be
14:46 - careful when you're importing these
14:47 - things that you're not importing the
14:48 - java.awt that's a different UI library
14:52 - that we're not using so the purpose of
14:55 - this text field is all it does is it
14:58 - maintain
14:59 - an X and a y-coordinate essentially or
15:02 - just a value and there's another purpose
15:04 - which is that as a see in a moment by
15:08 - the way I'm gonna use code generation
15:09 - pretty heavily here because this is just
15:11 - not the kind of thing you want to be
15:13 - typing by hand honestly if you want to
15:16 - do that I've mentioned it before but in
15:18 - IntelliJ anyways you can hit fault
15:20 - insert and that will bring up the menu
15:22 - so I'm gonna override two functions from
15:26 - text field and the reason for this is
15:29 - that if you don't override these
15:31 - functions then you get kind of strange
15:34 - behavior with how can I say it when you
15:37 - when the user enters a number zero
15:40 - through nine into a Sudoku text box I
15:43 - would get like repeat numbers and just
15:47 - weird behavior so basically what this
15:49 - does is it makes it so that if the user
15:53 - just hits one on a text field then weird
15:56 - things won't happen and it will just be
15:58 - a single one that's actually entered
16:00 - into the text field hopefully I explain
16:02 - that right now oddly enough there's
16:04 - actually a second method which I need to
16:07 - override now we'll see that in a minute
16:11 - by the way I'll talk about reg X you can
16:13 - see that square bracket zero through
16:15 - nine that is what's known as a regular
16:17 - expression you're going to want to look
16:20 - that up and know a little bit about it
16:22 - it can be really ugly to write but it's
16:24 - basically a way of matching strings so
16:27 - what that means above is we're saying if
16:29 - the string s matches any of the numbers
16:33 - zero through nine then that expression
16:38 - will evaluate true raiga can get really
16:42 - ugly but it's basically just a way of
16:43 - matching text and stuff like that
16:47 - there's other ways you can do this but
16:50 - reg X although it's annoying to write
16:52 - sometimes it's usually pretty handy in
16:53 - that way this is the other function for
16:56 - some reason I needed to override both
16:59 - replace text and replace selection and
17:02 - if you're wondering about the super key
17:04 - word that basically just calls the
17:05 - method which I overrode from the parent
17:10 - class okay so now we're going to build
17:12 - the actual
17:13 - user interface here now this is gonna
17:15 - take a long time user interface code
17:17 - very often is quite tedious to write and
17:20 - for something like a Sudoku game with so
17:23 - many different UI elements that
17:25 - certainly applies so we're making it
17:27 - extend the view con interface that we
17:30 - just created event handler and key event
17:33 - come from JavaFX so that's actually
17:36 - actually how we listen for input from
17:38 - the keyboard from the user interface all
17:41 - I did there is again I clicked on the
17:43 - red text and I hit alt insert and then
17:45 - selected generate or implement methods
17:50 - from the interfaces so again I'm just
17:52 - letting the IDE do some of the work so
17:55 - what I've got here so stage comes from
17:57 - JavaFX again it's basically like the
18:01 - window the background window for the
18:04 - application and group is somewhat like a
18:11 - div if you're coming from like an HTML
18:13 - background a view group if you're coming
18:16 - from an Android background it's
18:20 - basically just a container of some kind
18:22 - now here's an important question how do
18:23 - we keep track of 81 different text
18:27 - fields now I'm going to demonstrate the
18:30 - wrong way to do it or a very tedious
18:32 - verbose awful way to do it one way you
18:35 - could do it is you could have a
18:36 - reference variable for every single text
18:39 - field so basically what we would do is a
18:44 - little bit of an error there my
18:46 - apologies something slipped through the
18:49 - editing basically we could do it like
18:51 - that 1 2 3 4 all the way up to 81 that
18:56 - would be an awful thing to do it would
18:58 - be incredibly verbose so I had to figure
19:00 - out a way to keep track of these 81
19:02 - different text fields without doing that
19:06 - so what I settled on doing was using a
19:10 - hash map now you if you've been
19:13 - following this an order you'll know that
19:14 - I overrode the equals and hashcode
19:18 - functions for the coordinates and you'll
19:21 - also remember that the Sudoku text field
19:22 - that we just created has an X and a y
19:25 - value so I'm going to store a wrap
19:26 - princes to all of these different text
19:31 - fields within a hashmap and we're going
19:33 - to use that hash function to retrieve
19:35 - and store them so you always want to be
19:38 - keeping an eye out for things which are
19:40 - just more elegant solutions now this
19:44 - event listener class is going to be like
19:45 - the controller or the presenter so this
19:47 - is what we will pass events which the
19:50 - user causes or propagates to and the
19:55 - listener which is basically a control
19:58 - logic class I call it will basically
20:00 - interpret those events and pass messages
20:02 - between the view the front end the UI
20:05 - and the back end so there's just going
20:09 - to be a little bit of boilerplate style
20:12 - code here now
20:14 - one thing in particular because this is
20:16 - a single this application lis as a
20:21 - single feature I'm including the style
20:23 - information in the user interface here
20:25 - if this you this application had
20:28 - multiple different UI screens I would
20:31 - not put it here I would put it in a
20:33 - separate file and make these things
20:35 - basically either protect it or public
20:37 - access so that I'm not basically
20:40 - redefining them in multiple different
20:42 - user interface implementations but yeah
20:46 - they're just stuff that I use to build
20:47 - the user interface how I want
20:49 - so window Y and window X dictates the X
20:52 - and y position in the screen like the
20:57 - actual monitor of the operating system
21:00 - or computer padding we'll see that later
21:04 - it's kind of like the padding between
21:06 - the window and the actual Sudoku board
21:10 - and the X&Y are kind of a again those
21:16 - are going to be x and y values within
21:17 - the window itself and the ones I'm
21:21 - writing our pretty self-explanatory I'll
21:24 - of course show some images of the actual
21:28 - Sudoku board so you can kind of get an
21:29 - idea of what it looks like
21:34 - and I used this string here just for a
21:37 - title
21:48 - okay so we have a lot of work to do here
21:51 - now I think what I'll do next is create
21:54 - the constructor
21:55 - I'm just moving handle down to the
21:58 - bottom that's just to make it look more
21:59 - like the application which has already
22:02 - been written on the side which I am
22:03 - basically copying from and if you're
22:07 - wondering why I'm copying and doing
22:10 - voiceover it's just a lot easier for me
22:12 - to teach and do that at the same time
22:13 - also I am NOT trying to go through this
22:16 - super quickly in case you're wondering
22:18 - why I'm moving so slowly okay so this is
22:20 - a constructor and we assign our stage we
22:23 - create a new group and then we create
22:26 - our hash map and then once that's done
22:29 - we jump immediately into a helper method
22:31 - I don't want my methods to be any larger
22:35 - than they need to be this is actually
22:37 - something I go into in part 5 of working
22:41 - class Java which is how to use how do we
22:43 - think about software architecture in
22:45 - terms of methods which in a sense
22:48 - just avoid giant methods by using lots
22:51 - of helper methods is what are what we're
22:53 - talking about here so what I'll do is
22:57 - for every kind of user interface
23:00 - component in this particular screen I'm
23:03 - going to create a helper method for it
23:05 - and then obviously within that helper
23:08 - method we will actually create it
23:10 - background title sodoku board text
23:12 - fields and the grid lines of the Sudoku
23:16 - board and so stage show is what's going
23:19 - to actually reveal the user interface
23:22 - once everything has been drawn and
23:24 - configured and set listener so what will
23:27 - happen is we'll have our build logic
23:31 - which will write in just later on
23:34 - basically assign our control logic class
23:37 - which is again like a controller or our
23:40 - presenter to this particular view
23:42 - obviously it'll be through the interface
23:45 - and yeah here's where we get to the
23:48 - interesting stuff so like I say this is
23:51 - going to take awhile there's doing user
23:54 - interface code is very often quite
23:56 - tedious so the first thing we'll do is
23:59 - we'll draw the grid lines
24:01 - the Sudoku board these aren't especially
24:05 - in top-to-bottom order so x and y will
24:13 - be where we start to draw these grid
24:15 - lines and obviously so as you can see
24:20 - they're basically we're going to be
24:21 - drawing the grid lines and just notice
24:23 - that the some of the grid lines are
24:26 - actually thicker than the others
24:28 - so the ones which separate the different
24:32 - squares are thicker and that's where we
24:34 - get this if index equals two or five we
24:37 - want the thickness to be a little
24:39 - thicker
24:54 - great alright
24:58 - so when we want to actually draw these
25:00 - lines we're just going to use the
25:01 - rectangle class from JavaFX and what
25:05 - we'll do is we'll draw the what's going
25:07 - to happen in this while loop is we will
25:09 - draw each line we'll do the vertical
25:11 - lines and also the horizontal lines and
25:22 - obviously we'll implement this getline
25:24 - method in a minute so if you're kind of
25:26 - wondering about what we're doing with
25:28 - the x and y etc so we're basically
25:33 - drawing a line and then moving it over
25:35 - by 64 pixels or units whatever the units
25:39 - are and then we will multiply that by
25:43 - the index and then the result will be
25:45 - basically a series of gridlines now the
25:55 - reason why I created this grid line
25:56 - method here sorry getline is that you'll
26:00 - see in a minute will also try a
26:01 - horizontal line and one thing you really
26:04 - want to look out for and this is again
26:06 - something I go into in working-class
26:08 - Java is you want to look for repetitious
26:11 - code so originally I had this code for
26:14 - both the vertical and the horizontal
26:15 - lines in the previous method we were
26:18 - just writing which we'll get back to in
26:20 - a minute and then I realized hey that's
26:23 - basically the same code except the only
26:25 - thing that the changes are some of the
26:27 - variables so whenever you see that
26:29 - that's usually a cue that you want to
26:30 - pull that code out into a helper method
26:33 - and that will reduce the number of lines
26:35 - of code in your project and just make
26:38 - things more legible because you're
26:39 - breaking things down a lot better and
26:43 - all that's going on here is we're
26:45 - basically just creating and styling a
26:47 - rectangle and remember it's going to be
26:49 - an align even though it's a rectangle
26:56 - and there is a plane flying by in the
26:59 - background if you hear some background
27:01 - noise
27:09 - a little mistake there okay so that's
27:16 - the vertical line and then what we will
27:19 - work on next is the horizontal line or
27:21 - lines I should say and so while we're
27:27 - like I say all we're doing here is it's
27:29 - basically the same code we're just going
27:31 - to swap around a couple of the
27:33 - parameters here arguments I should say
27:36 - and that will give us our lines which
27:40 - are drawn horizontally instead okay
27:56 - all right so this is how we actually add
27:59 - these UI elements to the the route the
28:03 - group which is again kind of like a view
28:05 - group or a div and this add all function
28:08 - means we can basically slap any kind of
28:09 - UI element in I think the route the
28:14 - superclass of the UI elements I think
28:17 - it's called a node and so we can add
28:20 - anything which is a child class of node
28:23 - don't quote me on that I'm going off of
28:26 - memory there and now we're gonna draw
28:29 - the text field so this is going to be
28:31 - kind of interesting how we do this so
28:34 - it's going to be a bit of a similar set
28:37 - up so we're going to have like an x and
28:39 - y origin so x and y Delta means the the
28:43 - change in the x and y value and what
28:46 - we'll do is we'll keep drawing these
28:48 - things in increments of 64 units apart
28:55 - from each other you're probably
28:57 - wondering what is that Oh N squared
28:59 - runtime complexity so I don't actually
29:01 - go into detail about this I mention it
29:04 - in working class Java this is an
29:06 - advanced topic here which has to do with
29:09 - data structures and algorithms but I
29:11 - just wanted to mention this this is
29:13 - really important especially for the
29:14 - beginners listening but honestly anyone
29:17 - who hasn't studied data structures and
29:19 - algorithms or runtime complexity what
29:22 - does that mean so there's a bird
29:26 - chattering in the background sorry about
29:27 - that so whenever you're using certain
29:33 - patterns or structures so here we have a
29:36 - nested for loop we have two loops nested
29:39 - with anything within each other now
29:42 - whenever you do nested loops especially
29:46 - if you're doing like more than two
29:48 - what's going to happen here is you want
29:51 - to be very careful doing that in this
29:55 - case it's fine
29:56 - because we're only looping nine times
29:59 - nine times so that's where we get that N
30:02 - squared I can't give you a whole
30:04 - introduction to runtime complexity right
30:06 - now but basically if you have nest
30:09 - loop's and there are different things
30:12 - you can do other than nested loops but
30:14 - that's a really easy example you do not
30:16 - want to be working with large indexes
30:19 - large numbers of elements and the reason
30:22 - why is that the runtime of the
30:24 - application will basically grow
30:27 - exponentially quadratically in this case
30:30 - relative to the number of inputs here so
30:34 - and it was if you want to learn more
30:36 - about that you can look up runtime
30:38 - complexity and Big O notation so this
30:45 - style sodoku tile method here again this
30:49 - is just to pull some code outside into a
30:52 - helper method so I just wanted to take
30:54 - the code which is responsible for
30:55 - styling a Sudoku tile and just put it in
30:58 - a different helper method like I say
31:00 - this just make think makes things more
31:02 - legible in this particular case it
31:05 - doesn't necessarily reduce the number of
31:07 - lines of code but it just think makes
31:09 - things more organized and legible and
31:11 - I'm a big fan of organization and
31:13 - legibility of course this is how we set
31:18 - the font in Java FX
31:34 - lay out X again that'll be like the x
31:37 - and y where the particular UI element
31:41 - will be drawn relative to the window I
31:45 - believe in this case or the stage I
31:47 - think they call it in Java FX the text
31:54 - fields will be 64 by 64 their size and
32:06 - this background empty is going to make
32:08 - them transparent the background will be
32:09 - supplied by the Sudoku board which we'll
32:11 - deal with later so this is how we
32:19 - actually listen for inputs from the user
32:22 - set on key pressed so you'll notice
32:25 - again this user interface simple class
32:27 - implements the I believe it was the
32:30 - event listener or event handler
32:33 - interface from Java FX and so that is
32:38 - exactly where we set that up so we're
32:40 - passing this and the reason why we're
32:42 - allowed to pass this is because this
32:44 - implements event handler text field
32:48 - coordinates is our hash map every time I
32:50 - draw one of these text fields I add it
32:54 - to my hash map and I use a coordinates
32:57 - object as the key so when we use the put
33:01 - function it supplies a key and a value
33:03 - so the coordinates becomes the key the
33:07 - text field reference becomes the value
33:09 - now we're going to draw the snow cout
33:11 - board which is pretty easy it's
33:13 - basically just a colored rectangle
33:22 - of course when you're doing user
33:23 - interface code rarely has anything
33:25 - really easy obviously you've got to set
33:28 - the X and y values and the width and the
33:30 - height and this than the other not to
33:35 - mention the color
33:58 - normally I have code completion on by
34:01 - the way which is a lot quicker you might
34:05 - also notice me making lots of kind of
34:08 - little typing errors part of that is
34:10 - because I have code completion on all so
34:12 - part of that is because I have
34:14 - relatively large fingers and I was born
34:17 - with hand tremors so typing is I can
34:21 - type really fast but sometimes my IQ
34:23 - accuracy is not the best and in this
34:26 - particular case I'm looking on the
34:28 - screen off to the side most of the time
34:30 - I'm type typing so that's why there's so
34:33 - many different errors there it's also
34:34 - because I suck but yeah just thought I
34:37 - would give you some excuses in case
34:40 - you're wondering ok so text obviously
34:43 - this is just going to be the title which
34:45 - goes below the Sudoku board that says
34:47 - Sudoku
35:03 - I believe set Phil actually sets the
35:08 - font color it's not immediately obvious
35:10 - but that's how you do that
35:28 - and again we're gonna add that
35:30 - particular UI element you're gonna see
35:31 - root dog cat children on a doll in this
35:34 - case I just have one element okay
35:41 - now the background is the kind of
35:43 - turquoise colored background scene is
35:51 - again I think it's something kind of
35:53 - like a view group it would basically be
36:05 - like the the background of the
36:07 - background or something equivalent to
36:09 - that and so just a quick point here
36:13 - you'll notice that I'm using very few
36:16 - hard-coded values yeah there are a few
36:19 - like I could make the font size a
36:21 - hard-coded value but I'm using a lot of
36:23 - static final constants and that just
36:25 - makes things more legible and it's also
36:27 - slightly more efficient when you really
36:29 - get down to it computers are so fast
36:31 - right now that certain things like that
36:33 - won't cause a huge it's not necessarily
36:36 - going to make things a whole lot more
36:37 - efficient but it's good to get in the
36:39 - habit of using the more efficient
36:41 - approaches but for me legibility is a
36:44 - primary concern and that's why I'm not
36:46 - afraid to use things like enums when
36:48 - appropriate
36:50 - so for updates square this is what will
36:53 - eventually be called when I just want to
36:55 - update a single square after the user
36:58 - has input a number rather than having to
37:01 - update the whole board which we do
37:03 - sometimes we're just trying to update a
37:07 - single UI element appropriately I kind
37:09 - of took that cue from messing around
37:11 - with react j/s in which it's kind of
37:16 - like a web platform for building user
37:18 - interfaces and our framework I should
37:22 - say and it's neat in that it will only
37:25 - update the UI elements that need to be
37:28 - updated instead of redrawing the whole
37:30 - thing
37:35 - and so text property dot set value
37:39 - that's going to set the actual text
37:41 - input that the user gave number from 0
37:43 - through 9 update board will wholesale
37:50 - update the entire board so that would
37:54 - occur when the user finishes their game
37:59 - or something like that starts a new game
38:03 - and I forgot to copy the for loop which
38:06 - was kind of silly like I say you've got
38:14 - to understand that I'm my eyes are glued
38:16 - to my secondary monitor while I'm typing
38:19 - list of this stuff so there's gonna be
38:21 - lots of little mistakes like that so for
38:30 - each text field we're going to grab it
38:34 - from the hashmap text field coordinates
38:38 - and I can grab them by creating a new
38:41 - coordinates object with a particular x
38:43 - and y value and the nice thing about the
38:46 - hash function which we talked about
38:49 - earlier is that I basically can recreate
38:54 - it any time I want as long as those
38:56 - values are the same that will create the
38:58 - same hash value which is quite handy
39:04 - obviously get copy of grid state creates
39:06 - a immutable copy of the game which is
39:10 - kind of important I do talk about
39:12 - immutability which is a big word for
39:14 - things which don't change extensively
39:17 - and that's a really important topic if
39:19 - you're especially if you're like an
39:21 - intermediate developer it's a really
39:23 - great way to make your code more
39:24 - resistant to bugs and changes and all
39:27 - kinds of things here double equals error
39:47 - now you'll see the if value equals zero
39:50 - I set the text field to just be empty
39:57 - basically zero or backspace represents
40:02 - kind of like a deletion thing so I had a
40:06 - little error what happened was game
40:07 - state which is an enum we created wasn't
40:09 - actually imported in my Sudoku game so
40:12 - just importing that fixed it so what
40:15 - we're doing now is we're checking if the
40:20 - value either equals that empty ok so
40:27 - actually let me backtrack a bit so what
40:31 - we're doing here so this will this
40:33 - function will basically be called when a
40:35 - new game is created so you can see this
40:37 - game state dot new so what's going to
40:39 - happen is if we have an empty square so
40:43 - if value dot equals blank then what
40:47 - we'll do is we want to enable that text
40:49 - field and set it to a slightly less
40:52 - thick font that was really annoying to
40:56 - do in Java FX so I finally actually had
40:58 - to resort to using a bit of CSS here is
41:00 - what's within those quotes if the number
41:05 - is already colored in I don't want the
41:07 - user to change it so we set disabled to
41:10 - true and we also set it to a slightly
41:12 - sorry I said thicker its opacity so
41:17 - opaque which would be an alpha value if
41:20 - you're familiar with alpha transparency
41:22 - is what I'm saying now that that's done
41:26 - we have the show dialog so this will get
41:28 - called when the logic center of the game
41:31 - the game logic indicates that the game
41:35 - is actually completed properly and then
41:38 - what we'll do is we will show this alert
41:40 - dialog which will then I correct that
41:43 - message thing there we show an alert
41:46 - dialog which basically will ask the user
41:48 - hey do you congratulations you won do
41:51 - you want to start a new game and show on
41:57 - wait will basically pause things and
41:59 - wait for interface
42:00 - our interaction from the user once that
42:04 - occurs we can tell the listener hey on
42:08 - dialog click the dialogue was clicked
42:09 - the user wants to start a new game and
42:11 - then the listener will figure out what
42:13 - to do at that point now if there's any
42:16 - kind of errors that occur so there can
42:18 - be an error which occurs when we either
42:20 - write or retrieve read or write the game
42:25 - state from storage so if any of those
42:29 - errors occur then we just want to let
42:31 - the user know hey something went wrong
42:34 - finally over the handle function again
42:36 - this comes from event handler which is
42:38 - the JavaFX
42:39 - interface so this is where if the user
42:42 - enters a number into a textbox that
42:45 - event will pop up here and what we're
42:48 - doing is we're checking the event type
42:50 - and we're saying okay was it a key that
42:52 - was pressed because I don't really care
42:53 - about other events like mouse clicks and
42:55 - things like that that's just noise if
42:59 - that event matches so here's a funny
43:03 - thing I'm using reg X here as I was
43:06 - recording this code I had this giant if
43:10 - statement full of or statements for the
43:13 - number zero through nine and I was
43:16 - looking at I was thinking didn't I just
43:18 - use regs to do this exact thing so I
43:20 - actually added this in immediately the
43:24 - Reg X and that just clean this method of
43:26 - a whole bunch usually there's very often
43:29 - a more elegant way of dealing with
43:31 - things instead of the brute force method
43:41 - so value is whatever the user has
43:43 - actually entered when they entered a
43:46 - number source will be the UI element the
43:50 - variable the the object that was
43:53 - actually clicked on so that's why I'm
43:55 - gonna use the event get source there to
43:57 - pass that reference and it will get
44:01 - passed to the handle input function
44:03 - method I should say as an object a Java
44:07 - object like the class and we also check
44:11 - for word backspace if it's a backspace
44:15 - then I want it to be treated like a zero
44:18 - essentially so that's why we're passing
44:20 - in zero there so if the user wants to
44:26 - like clear an entry in the sodoku or
44:28 - clear a sodoku square they can either
44:29 - hit zero or backspace
44:45 - I think that's just like a generic thing
44:47 - if the user types anything else then we
44:50 - just set it to empty I just want to
44:52 - avoid writing numbers and stuff like
44:53 - that event dot consume as far as I know
44:56 - what that will do is it will just
45:00 - basically once the event gets consumed
45:05 - then it's not going to propagate through
45:07 - the rest of the application that like
45:10 - the internal code within JavaFX or any
45:13 - of the other stuff and then again we're
45:16 - gonna let the once the input occurs
45:19 - we're gonna actually pass that input to
45:22 - the control logic class which is the
45:26 - listener here and we're going to say hey
45:28 - at this x and y value this value was
45:32 - called okay so we're now going to code
45:37 - the control logic class which is again
45:39 - kind of like a controller or presenter
45:41 - and it basically manages the
45:43 - interactions between the user and the
45:47 - user interface and the back end of the
45:50 - application which would be like the
45:52 - computation logic so it's going to
45:57 - extend the event listener interface
45:59 - which we defined in the previous lesson
46:01 - or video and again I'm going to hit alt
46:07 - insert and that will bring up that
46:09 - dialogue where I can implement the
46:11 - abstract methods now just an important
46:16 - note here whenever you're dealing with
46:19 - like a controller or a presenter or a
46:21 - view model or whatever I strongly
46:25 - recommend that you communicate at least
46:28 - with the back end here I communicate
46:30 - with the view as well the front end
46:32 - class through interfaces if you're not
46:35 - going to use interfaces anywhere else
46:37 - use them across very large and important
46:41 - architectural boundaries across your
46:44 - application this is very simple applied
46:47 - solid principles and it's just a really
46:51 - important thing to do a lot of people
46:53 - think it's a waste of time and
46:55 - I respectfully disagree because the
46:58 - other thing is that it helps me to
46:59 - design my application upfront without
47:01 - worrying about the implementation and if
47:04 - I need to change the storage
47:06 - implementation
47:08 - I can change it quickly and easily
47:10 - without having to cause any issues in
47:12 - this control logic class so what we're
47:20 - doing here is when the user basically
47:24 - inputs a number what we're gonna do or
47:29 - deletes a number we're going to write
47:31 - that to the game storage and the reason
47:35 - why we're doing that is we kind of want
47:36 - the game storage to be like the source
47:38 - of truth in terms of the actual game
47:42 - data now that can potentially fail it it
47:46 - hasn't yet but you just have to be aware
47:50 - that when you're using something like a
47:53 - input/output system you want to code you
47:57 - want your code to be capable of dealing
48:00 - with any errors that might pop up
48:01 - otherwise you're a bad programmer just
48:04 - saying now if that writes successfully
48:13 - then we create a new Sudoku game object
48:16 - the reason why we create a new one is
48:18 - I've designed it that way it's a it's an
48:20 - immutable object and this is actually
48:22 - how you work with immutable data models
48:25 - is you create a new one from the old one
48:40 - once we've successfully written to the
48:43 - storage then we can update the view and
48:45 - again like I said in the previous video
48:47 - if we don't need to update the entire
48:50 - user interface if we can get away with
48:52 - just updating one square that is a very
48:55 - much more preferable way to do things
49:09 - so now what we're doing here is we're
49:12 - just checking to see okay is the
49:14 - gamestate complete and that will be
49:17 - dictated by the code that we'll be
49:18 - writing in the next video and if it is
49:21 - complete then we want to show a dialogue
49:23 - to the user now if for some reason
49:34 - something does go wrong which is
49:36 - unlikely there's not a whole lot we can
49:39 - do beyond showing an error so that's
49:43 - what we do here and this will obviously
49:46 - show like a dialogue to the user so we
49:48 - can at least let them know that
49:49 - something's gone horribly wrong and if
49:57 - the user clicks the okay dialogue then
50:01 - this is where we will handle that and
50:03 - this will generate a new game for the
50:04 - user and again we're going to
50:11 - immediately update the storage first
50:13 - before we update the user interface
50:15 - because the storage is the source of
50:17 - truth we'll be writing the game logic
50:19 - class in the next video and that video
50:23 - is also going to take a little while
50:24 - because it turns out it's actually
50:25 - pretty complicated logic to implement a
50:27 - Sudoku game and once that works
50:31 - successfully then we will update the
50:34 - view know so this is kind of a more
50:39 - functional style of coding at least in
50:41 - the try block and you know as functional
50:44 - as Java can be
50:50 - okay we're now going to write the
50:52 - computation logic of the application and
50:54 - this will take a little while so buckle
50:57 - up so originally I just had a single
51:01 - class here which encapsulated all of the
51:04 - what I'll call computation logic called
51:08 - game logic and then as I went through
51:11 - actually implementing the logic required
51:14 - for the various steps to basically
51:17 - administer a Sudoku game I discovered
51:20 - that there was a lot of different steps
51:21 - involved and I broke this logic down
51:23 - into a number of different classes now
51:26 - the first one here we have is just like
51:28 - a utility class Stokey utilities so what
51:32 - it will do is it has a utility function
51:35 - a static function which will copy the
51:39 - values from one Sudoku array that's
51:42 - passed in one two-dimensional array into
51:45 - another two-dimensional array and then
51:48 - it also has a second function which will
51:53 - take in an old array and it will return
51:57 - a new array with the same values and
52:00 - you'll see that's kind of used in a
52:01 - couple different places in the backend
52:03 - logic of the application and also in the
52:06 - Sudoku game data model itself now before
52:12 - I proceed I need to explain something
52:13 - really important about the usage of
52:15 - static functions here in this part of
52:18 - the application static methods I should
52:20 - say in Java so something that I go into
52:24 - a great detail on in working class Java
52:28 - is how and when to use static methods
52:31 - and static variables and what exactly
52:34 - static means now I can't explain it here
52:38 - because I need to actually explain a
52:39 - little bit about how memory space works
52:42 - in particular the JVM memory space in
52:45 - order for you to really understand how
52:47 - static works I do go into great detail
52:50 - about that in the course now what I will
52:54 - tell you here is a little bit about how
52:57 - to use them safely you're going to
52:59 - notice that I use static methods X
53:03 - and Sallee in this part of the
53:05 - application now the important thing here
53:09 - is that I use them in such a way to
53:11 - avoid what in functional programming you
53:15 - would call side effects as much as
53:17 - possible what I might call shared
53:19 - mutable state problems so what that
53:23 - basically means is that these static
53:25 - functions are only going to reference
53:28 - and deal with either parameters that are
53:33 - passed in so for example old array here
53:36 - or variables which are created within
53:41 - the method body of that particular
53:44 - static function and they can also call
53:47 - other static functions methods I keep
53:50 - saying whenever I say function imagine
53:52 - method now what we basically want to do
53:56 - is the way I'm using static methods here
54:00 - is almost like a I heard someone else
54:02 - say a poor-man's version of functional
54:05 - programming but that's kind of a little
54:07 - bit accurate it's about as functional as
54:09 - you can get on Java so anyways I could
54:12 - go into a lot of detail here and I do in
54:14 - the course but I just want you to be
54:16 - aware you need to be careful when using
54:18 - static functions some people hate them
54:21 - some people say they are horrible and
54:23 - the Antichrist I don't think those
54:25 - people really understand what they're
54:28 - talking about there but there is
54:30 - definitely some truth that there are
54:31 - ways you can use static functions which
54:33 - are really bad and can make it your code
54:35 - difficult to test and all kinds of
54:37 - things so as you can see here again
54:39 - we're going a little bit functional by
54:41 - having these nested method calls so the
54:45 - first method we have here gets solved
54:48 - game will generate a solved Sudoku game
54:51 - this is going to be a little bit
54:53 - complicated
54:53 - this first algorithm here to generate a
54:57 - solved game was made entirely by me
55:01 - the will see later on there was another
55:04 - algorithm which I did not create but
55:06 - this particular algorithm was made by me
55:09 - now the reason why I did this
55:11 - it's not necessarily going to be the
55:13 - most efficient algorithm in particular
55:17 - later on I want to actually rebuild this
55:19 - algorithm as a graph coloring problem
55:23 - which that would be like an advanced
55:25 - topic in data structures and algorithms
55:27 - but I wanted to do something which was
55:31 - hopefully as easy as I could make it for
55:35 - a general kind of programmer to follow
55:38 - along now I'm not saying it's going to
55:41 - be easy but I'll do my best to kind of
55:44 - talk you through it here so the basic
55:47 - idea here first we seed a random number
55:49 - generator that's what random is and then
55:52 - we of course get our we create a new
55:55 - grid which will be based on the
55:58 - boundaries here the grid boundary which
56:01 - will of course be nine so what we're
56:03 - going to do is for the values one
56:05 - through nine we are going to allocate
56:08 - them nine times of course every Sudoku
56:12 - puzzle will have nine ones nine to s
56:14 - nine threes etc so that's what
56:17 - allocations does it tracks the number of
56:19 - times the number in the given value is
56:23 - allocated this interrupt is going to
56:26 - basically this is even a little bit
56:30 - difficult for me to kind of fall along
56:32 - here but what the internet interrupts
56:34 - will do is what we'll see is kind of a
56:38 - backtracking that occurs so if an
56:40 - allocation is attempted too many times
56:43 - then we will add basically we will
56:46 - increment our interrupt variable and
56:49 - then we also have an attempts variable
56:53 - here which works as a fail-safe we'll
56:55 - get to that in a minute so what we're
56:57 - doing is we're saying okay while the
57:00 - number of times we've allocated a
57:02 - particular number so for example one is
57:04 - less than nine keep attempting to
57:07 - allocate that number if the interrupt
57:11 - that is the number of times we attempt
57:14 - to allocate a number is greater than 200
57:17 - or sorry
57:19 - I think I'm mixing that up a little bit
57:23 - here yes okay so if we make more than
57:29 - 200 attempts
57:31 - to allocate a given number so for
57:34 - example 1 then what we do is that
57:36 - allocation tracker thing is basically
57:38 - just a list of coordinates so each time
57:41 - we will allocate a number we will add
57:44 - that to our allocation tracker so what
57:46 - we're doing here is if interrupts is
57:48 - greater than 200 then we want to go
57:51 - through the past numbers the nine
57:53 - numbers or whatever numbers we've
57:54 - allocated and we want to reset them to
57:57 - zero
57:58 - so basically in simple terms we're
58:01 - backtracking if we get stuck
58:04 - ie interrupts is greater than 200 we
58:07 - backtrack a little bit and we say okay
58:09 - let's just reset to zero and let's try
58:11 - this thing again now it turns out that
58:15 - is not enough it's possible that even
58:19 - doing that that we can just get stuck
58:22 - and this algorithm will run forever
58:24 - that's why we have the attempts tracker
58:27 - as well if a tense is greater than 500
58:32 - we are definitely stuck and what we do
58:34 - at that point is we clear the whole
58:37 - array we basically nuke everything and
58:40 - reset it all to zero and we try again so
58:44 - this is actually like a two-stage
58:45 - backtracking algorithm we're writing a
58:49 - little helper function here clear array
58:51 - which like I say it's just a simple
58:54 - array traversal and it'll reset every
58:56 - element in the two-dimensional array to
58:58 - zero so as you can see here it's there's
59:04 - a lot of stuff going on like I said
59:10 - before there's actually a way to model
59:12 - this differently using a graph data
59:15 - structure so that's something that I
59:17 - would like to do later on but the thing
59:21 - about that is it's gonna require a
59:23 - certain amount of explanation and
59:26 - practice and I haven't actually solved
59:28 - the problem yet myself so I'll need to
59:30 - do that first but hopefully now that
59:33 - I've talked you through what's going on
59:35 - here it should make at least a little
59:37 - bit of sense and like I say it's not
59:40 - necessarily the most efficient algorithm
59:42 - that wasn't really what I was going for
59:44 - I was
59:44 - trying to make it as legible as possible
59:48 - now what we do is each time we're about
59:52 - to allocate a number to our
59:54 - two-dimensional array we randomly select
59:57 - a square by using the random number
59:59 - generator here so give me an
60:00 - x-coordinate that's random
60:02 - give me a y-coordinate that's random now
60:05 - if that particular grid location does
60:10 - not equal 0
60:12 - or if it equals 0 we will now randomly
60:17 - or not randomly we will now allocate a
60:19 - value to it if it doesn't equal 0 then
60:25 - we just want to skip it because that
60:27 - number has already been added in so we
60:29 - don't want to overwrite the progress
60:30 - that we have already made now what we're
60:40 - doing here is once we allocate a value
60:42 - we actually immediately check to see if
60:45 - it's a valid or invalid Sudoku game will
60:49 - write the game logic class shortly well
60:52 - at the end of this particular s section
60:54 - and so if the Sudoku is invalid then we
61:00 - want to remove the value we just
61:03 - allocated and then we are going to add
61:07 - we're going to increment the interrupt
61:10 - tracker otherwise if we did just update
61:13 - a new square with a valid value then we
61:17 - want to add that particular allocation
61:20 - that number to our allocation tracker
61:22 - and that's again just to help with our
61:24 - backtracking if it becomes necessary
61:28 - also we want to add to our increment our
61:31 - allocations
61:38 - you
61:48 - and if all that works we return a new
61:50 - grid now that that's done we can work on
61:53 - the unsolved algorithm so this was a
61:55 - really interesting thing to work on so I
61:58 - wrote the unsolved algorithm but there's
62:00 - kind of an interesting problem here how
62:03 - do we actually know if a Sudoku game is
62:08 - solvable or not so when I was writing
62:11 - this unsolved algorithm I thought to
62:13 - myself okay what we'll do is we'll just
62:16 - randomly pick 40 numbers from the Sudoku
62:19 - game and we'll just remove them we'll
62:22 - set them to 0 so I you know initially I
62:26 - thought that probably it would make
62:29 - Sudoku which is solvable it turns out
62:32 - that was not the right intuition at all
62:34 - it's entirely possible to randomly
62:37 - remove 40 numbers and create a puzzle
62:39 - that is not solvable at all so this
62:44 - poses a very interesting problem how do
62:49 - I create a Sudoku puzzle that isn't
62:54 - solved
62:55 - hence unsolved game that is still
62:58 - solvable well what I ended up having to
63:01 - do is so first we do remove 40 numbers
63:06 - from the Sudoku game that has already
63:09 - been solved so that's that's why we pass
63:12 - you'll notice whatever returns from gets
63:16 - all game will basically be piped
63:18 - immediately into unsolved game so also
63:23 - the reason why I'm using Sudoku
63:24 - utilities here is I don't actually want
63:26 - to work on the original object for
63:30 - solved game and that's why we're using
63:31 - the copy Sudoku array values and this is
63:34 - something you want to be careful careful
63:36 - with if you don't really understand Java
63:37 - memory space which is something I
63:39 - explained extensively in working class
63:42 - Java how member verian or not remember
63:46 - but reference variables work anyways so
63:49 - what we're doing here is were removing
63:51 - 40 numbers from the two-dimensional
63:54 - Sudoku grid that's the first step here
63:59 - and similar idea we just randomly picked
64:02 - the 40 numbers you'll notice I want to
64:11 - write solvable with an e repeatedly in
64:13 - this particular video because for some
64:15 - reason solvable sounds like it should
64:16 - have an e Oh English language so what
64:25 - we're doing there is we're just checking
64:26 - to see did we already remove a value
64:29 - there as you can see I completely
64:32 - screwed that up again I don't know how I
64:34 - missed that in the editing well whatever
64:46 - all I meant editing is not my strong
64:48 - suit okay that's a little bit better so
64:52 - if it does not equal zero then we set it
64:56 - equal to zero if it does equal zero then
64:58 - we just loop again without incrementing
65:03 - index
65:17 - just making sure I'm in the right
65:19 - bracket here okay so we remove 40 values
65:24 - from our Sudoku puzzle now the next
65:29 - thing we need to do after we've remove
65:32 - those values is we actually need to
65:34 - solve the puzzle again or at least
65:37 - attempt to solve it so this was actually
65:39 - kind of a big deal because I it's
65:45 - actually not as easy as you might think
65:48 - to solve a Sudoku game it's not the most
65:52 - complicated algorithm that I've written
65:55 - I think probably writing red and black
65:58 - trees was pretty complicated for me
66:01 - that's a complicated data structure but
66:06 - yeah so we're gonna create again an
66:09 - immutable copy to be solved and then
66:12 - we're using that copy function and then
66:14 - we're gonna use this Sudoku solver class
66:16 - which again has static methods to
66:20 - actually check to see if this puzzle is
66:23 - solvable
66:24 - we passed the puzzle in that we just
66:27 - removed the 40 values from and then we
66:32 - want to see that class their Sudoku
66:35 - solver will tell us if it's solvable or
66:37 - not
66:47 - then we're going to jump in and go ahead
66:48 - and create that Sudoku solver now just a
66:54 - bit of background here so the algorithm
66:57 - aim I'm using to solve a Sudoku puzzle
67:00 - is called the simple solving algorithm I
67:03 - actually got this from the Cornell
67:08 - University website there's an article
67:11 - written by called rather solving any
67:15 - Sudoku now I'm not from Cornell or
67:21 - anything like that but I just wanted to
67:22 - give a shout out this is where I get
67:24 - this now part of this algorithm was
67:27 - basically doing what the person who made
67:30 - this algorithm called a type writer in
67:32 - numerate so what that basically means
67:35 - it's a big fancy way of saying we take a
67:37 - two-dimensional array and we turn it
67:41 - into a one-dimensional array so what we
67:44 - would do is so let's say array index 0
67:48 - through 8 of the one dimensional array
67:51 - would be the top row of the Sudoku and
67:54 - then array index 9 through o my poor
68:01 - brain 17 or whatever the hell the end
68:04 - would be 18 that would be the second row
68:08 - so that would be y equals 2 and then you
68:12 - basically just pull out the
68:14 - two-dimensional array into a one
68:16 - dimensional type thing like that and
68:18 - that's just a necessary step with this
68:20 - particular algorithm now it's kind of an
68:23 - interesting note to see how this is
68:26 - where data structures and algorithms
68:27 - does actually become pretty important
68:29 - because one of the most interesting
68:31 - things I learned when I was studying
68:33 - that topic and I didn't go to university
68:35 - for this stuff if in case you're
68:38 - wondering one of the coolest parts about
68:40 - it was you start to see that you can
68:42 - take the same data the same information
68:45 - represent it in a different data
68:47 - structure and that can make it easier or
68:50 - more difficult to solve problems in
68:53 - particular I guess a really really good
68:56 - data structure for Sudoku games is a
68:59 - graph
69:00 - structure anyways I won't go into detail
69:03 - on that
69:22 - now obviously here what we're doing is
69:26 - we are keeping track of empty cells and
69:32 - we're going to assume that the maximum
69:35 - number of empty cells is 40 so that's
69:38 - why we're doing if iterate iterator
69:40 - equals equals 39 there and so what we're
69:44 - trying to do here is we just want to
69:45 - know which cells are empty that's quite
69:49 - complicated isn't it
69:58 - now I just want to make another reminder
70:01 - here so we're using some nested loops
70:03 - here again you want to be careful when
70:07 - you're working with nested loops because
70:09 - they can if you have two nested loops
70:10 - you've got a quadratic or a square run
70:13 - time complexity if you're using three
70:16 - nested loops you've got cubed run time
70:19 - complexity if you don't know what that
70:21 - is basically just understand
70:23 - do not use nested loops when the index
70:27 - indexes or index I I'm not sure are very
70:31 - large the number of inputs is very large
70:34 - how you would say that technically is
70:36 - when n is large but with the sizes we're
70:41 - dealing with here it's not really a big
70:43 - issue
70:58 - so again we're just checking to see if
71:00 - the actual puzzle is valid at any given
71:04 - point in time
71:17 - so basically what we're doing here is we
71:21 - are checking to see which cells can't be
71:28 - solved essentially and what will happen
71:31 - is will eventually either solve the
71:35 - puzzle or we will implement we will hit
71:38 - an impasse where we can't solve the
71:41 - puzzle I'll be perfectly honest I'm I
71:45 - didn't actually write this algorithm and
71:46 - the inner mechanics of it are slightly
71:49 - escaping me at the moment
72:13 - I think what it is so we get every empty
72:15 - cell and we test numbers in that
72:18 - particular empty cell so we test the
72:20 - number one through nine and we basically
72:25 - just keep adding numbers to each empty
72:28 - cell and every time we add a number we
72:32 - check to see if the puzzle is still
72:34 - valid and so essentially we're using a
72:39 - algorithm which really just follows the
72:42 - basic rules of Sudoku it's going to just
72:46 - kind of incrementally go through it so
72:52 - now we're going to write the game logic
72:54 - class
73:02 - so this game logic class I'm going to be
73:04 - perfectly honest with you originally I
73:07 - assumed I was going to get away with
73:09 - maybe one or two classes in the backend
73:13 - to encapsulate the game logic as you can
73:16 - see things got a little bit more
73:17 - complicated than that
73:19 - in retrospect what I would rather have
73:21 - done here is I would rather have created
73:24 - an interface and then talking spoken to
73:27 - a facade pattern it's called and then
73:32 - that I would have that facade called the
73:34 - different static methods necessary like
73:39 - I say this is one of those situations
73:41 - where I really just thought it was going
73:43 - to be simpler than it actually turned
73:44 - out to be not to say that it's
73:46 - extraordinarily complex but it's there's
73:49 - a number of steps involved in getting
73:50 - this thing to work properly
74:10 - so the result of that is we have this
74:12 - class here game logic which the first
74:15 - thing I did is I encoded the rules to
74:18 - figure out whether a Sudoku game is
74:20 - valid or invalid and that part was
74:24 - relatively easy obviously you just see
74:26 - is any number repeated in a row repeated
74:30 - in a column or repeated in a square or
74:35 - sub grid nine by three by three grid
74:37 - rather and so we have this class here
74:41 - which is basically doing double-duty
74:43 - it's delegating to game generator and it
74:48 - is also encapsulating the logic to check
74:51 - whether or not the Sudoku game is valid
74:54 - or not so that's a bit of a breakage of
75:03 - separation of concerns so if I could do
75:09 - it again and I'm probably going to
75:10 - rebuild this application in Android and
75:12 - I will definitely do a better job with
75:14 - separation of concerns in that
75:15 - particular case it's not a big deal but
75:19 - I'm just saying I'm a bit of a
75:20 - perfectionist with separation of
75:22 - concerns and there is refactoring to be
75:28 - done so another rule we want to know to
75:34 - dictate whether or not a Sudoku game is
75:36 - complete is whether or not the tire
75:38 - tiles are all filled so we can have a
75:42 - perfectly legal valid Sudoku game but
75:47 - that doesn't necessarily mean that it is
75:48 - complete so that's another one of the
75:51 - victory conditions here
76:05 - again I'm gonna be making pretty
76:07 - extensive usage of helper functions to
76:10 - avoid just having gigantic functions or
76:13 - methods the methods were large enough in
76:16 - my algorithms now I mentioned before but
76:26 - squares obviously refers to the 3x3
76:28 - grids there are 9 3x3 grids that make up
76:32 - the whole nine by nine nine grid in a
76:35 - Sudoku puzzle now you're gonna notice
76:45 - something which might seem a little bit
76:47 - strange so we're going to be checking
76:49 - individual rows of squares now and
76:54 - you're also gonna see this rows top
76:56 - that's an enum I made way at the start
76:59 - in the constants class or package now
77:04 - the reason why I have this enum here I
77:06 - don't want you to be confused by it it
77:09 - is entirely to improve the legibility
77:12 - how we're going to select for the
77:15 - different squares and different rows of
77:17 - squares in this particular in the puzzle
77:21 - is we're going to have to use
77:23 - coordinates x and y-coordinates now just
77:28 - in my case I found it a little bit
77:32 - difficult to read and that is why I used
77:35 - in ohms here to just kind of help remind
77:37 - myself ok we're either talking about the
77:39 - top the middle or the bottom now I think
77:43 - in a general sense that is the main
77:46 - purpose of enums is to improve
77:50 - legibility there's different tools you
77:53 - can use that are more efficient than
77:54 - enums but i
77:57 - there aren't many that are a whole lot
78:01 - more legible than enums maybe like
78:04 - static constants but in this particular
78:06 - case they enum just seemed appropriate
78:09 - what we're going to do here is we're
78:11 - going to check the first second and
78:12 - third square in the top row and then
78:17 - we'll move down and do the middle and
78:18 - then the bottom
78:20 - now if you look up enums in Java then
78:27 - you're gonna see a lot of opinions
78:29 - talking about how you shouldn't use them
78:31 - because they're not memory efficient I
78:34 - would like to just say for the record
78:37 - two things number one enums have been
78:42 - optimized a lot now the thing about
78:47 - performance is you can almost never
78:49 - really say anything
78:51 - totally concrete about performance
78:54 - because operating systems differ JVMs
78:58 - differ are you working with the open JDK
79:00 - or the Oracle JDK or whatever so that's
79:04 - the first problem
79:07 - secondly it's very very rare that the
79:11 - impact you will have on your program
79:14 - using an enum versus maybe a more memory
79:17 - efficient alternative will actually ever
79:20 - be noticeable or even acknowledgeable to
79:24 - the user now I'm not saying you should
79:26 - use them everywhere in anywhere and make
79:28 - really huge enums all the time but what
79:31 - I am saying here is if you have read
79:32 - something about how enums are
79:34 - inefficient just understand these are
79:36 - people who are basically not really
79:41 - understanding the context of the
79:45 - situation okay
79:47 - we're saying they're inefficient that's
79:50 - very often not true what you're saying
79:53 - is they might be like infinitesimally
79:56 - more efficient than a slightly sorry
80:01 - less efficient than a slightly more
80:02 - efficient option but what it really
80:04 - comes down to is does it affect the
80:06 - users the performance of the application
80:09 - on the user side versus doesn't make
80:12 - your code more legible
80:31 - so what we're doing here is we pick out
80:34 - the say for example the top three
80:36 - squares and we add them to a list and
80:40 - then we're just going to pass that list
80:42 - to our collection has repeats function
80:47 - here
81:02 - and what that's gonna do is it's
81:05 - basically going to look at each square
81:09 - individually and we're just it's very
81:11 - simple we're just going to see is the
81:12 - number one repeated is the number two
81:14 - repeated is the number three repeated
81:16 - etc and that's how we kind of dictate
81:19 - whether or not the particular square is
81:22 - valid now zero can repeat that's fine
81:25 - it's just the other numbers that we're
81:27 - concerned about and this just comes from
81:30 - the rules of Sudoku in case you're
81:31 - wondering and we're going to use a handy
81:39 - little function there to make that a
81:41 - little easier collection stock frequency
81:43 - that comes from the Java standard
81:44 - library
81:58 - okay so now that we've got the top row
82:00 - configured here we will work on the
82:02 - middle and bottom rows
82:35 - now I just need to point something out
82:37 - here there is a slight mistake with the
82:39 - X index and the Y index those are
82:42 - actually supposed to be reversed so the
82:45 - 0 0 0 the 3 3 3 and the 666 those are
82:49 - supposed to be Y indexes which would
82:52 - indicate the top middle and bottom again
82:54 - when you're doing this amount of
82:57 - rewriting a whole bunch of code there's
82:58 - gonna be little mistakes like that but
83:00 - just understand those are supposed to be
83:01 - reversed now checking for whether
83:11 - columns or rows are invalid is very very
83:16 - easy we just look through the each grid
83:19 - each row or column in the grid and we
83:21 - again see if there are any repeat values
83:27 - now this is again something where we're
83:30 - gonna see I create another function
83:31 - called method called rows are invalid
83:35 - and the code is going to be very
83:36 - repetitious and that's actually a sign
83:39 - to me that I should probably apply some
83:42 - abstraction here and basically pull that
83:45 - code into one single method but
83:48 - unfortunately that didn't really occur
83:50 - to me until I was busy recording this
83:52 - thing so it is what it is they're not a
83:55 - big deal but again this is just me being
83:57 - an absolute perfectionist when it comes
83:59 - to abstraction and separation of
84:02 - concerns
84:18 - and all that's going on here for every x
84:23 - value we will add all of the Y values
84:26 - and we will just check to see again
84:28 - using our helper function collection has
84:30 - repeats whether or not it is actually
84:33 - valid and I misspelled collections has
84:35 - repeats so we'll just fix that there and
84:40 - then we'll code the function for rows
84:43 - now like I say this is a place where the
84:45 - codes very repetitious so that's usually
84:47 - a sign like I discuss in my course that
84:51 - there's some refactoring in order to fix
84:54 - that but yeah just thought I would point
84:56 - it out
85:08 - luckily I managed to fix that particular
85:10 - error that would have been buggy and
85:16 - that's basically it
85:26 - so what's happening now is we're just
85:28 - some of the static functions actually
85:31 - need to be public because they're used
85:32 - in different parts I could probably make
85:34 - them protected this was a particular
85:37 - case where as being lazy about my access
85:38 - modifiers but you know in actual like
85:44 - production code I would not just leave
85:46 - them public just an FYI there
85:57 - chances are at some point you've heard
85:59 - the term dependency injection or you've
86:01 - heard about the service locator pattern
86:03 - and you might have wondered what these
86:05 - things are actually about there's a more
86:08 - technical word which I really don't like
86:10 - to describe this but my favorite teacher
86:12 - for software architecture Martin Fowler
86:15 - describes it incredibly well he states
86:18 - essentially that we are applying the
86:20 - principle of separating configuration
86:23 - from use I in my own terms I would say
86:26 - that an object which uses other objects
86:30 - should not also build those objects you
86:33 - should pull the logic required to build
86:35 - those objects into a different class or
86:39 - function or something like that or
86:41 - method I should say so that's basically
86:43 - what's going on here we're taking the
86:44 - logic required to basically wire up all
86:47 - the different actors in our application
86:49 - together just before they launch for the
86:53 - user to use and we're encapsulating that
86:56 - into its own special little area of the
86:58 - application and the good thing about
87:00 - using interfaces is that we can use
87:03 - these interfaces within our build logic
87:06 - itself here like as you can see the user
87:08 - interface is being referred to or
87:10 - referenced as its interface same as
87:13 - storage etc etc now oftentimes we do
87:17 - need to refer to the concrete names when
87:19 - we're creating things like a new local
87:21 - storage imple but yeah you get the
87:24 - general idea here so visco what this
87:27 - class does is we attempt to get the game
87:29 - data from storage if it exists now if it
87:34 - doesn't exist then what will happen is
87:36 - the storage class which will write in
87:38 - the next part will throw an exception an
87:41 - i/o exception if that's the case then
87:44 - all we do is we just ask game logic for
87:46 - a new game we update storage if possible
87:50 - and then down below here is where we
87:53 - will actually bind everything together
87:55 - so the first thing we're doing here is
87:58 - we're creating our UI logic class the
88:01 - control logic class and that thing
88:06 - requires storage and our reference to
88:08 - the user interface in order for it
88:10 - do its job properly just gonna import
88:19 - that by the way I'm hitting alt enter to
88:22 - import there and then we need to of
88:26 - course bind the control logic class to
88:29 - our user interface so that they can talk
88:31 - both ways finally we call this method
88:34 - which will basically update the board
88:37 - with its initial State and things will
88:39 - start it'll start the ball rolling
88:42 - that's basically it okay so the last
88:46 - thing we'll do is we will implement our
88:47 - storage mechanism that's often called a
88:50 - persistence mechanism persistence just
88:53 - means persisting data in case you're
88:55 - wondering that could be referring to
88:59 - something like a database in this
89:00 - particular case what we're doing is
89:02 - we're actually just going to be writing
89:04 - a file to the local file system in order
89:08 - to store the data so of course I have my
89:10 - I storage interface which I will
89:12 - implement by hitting alt enter and we
89:17 - have two methods which we need to
89:18 - implement now what we'll write up here
89:24 - is something which is a file type
89:28 - reference variable now basically what
89:30 - this is it can be a bit confusing but
89:32 - it's more like a path or a URL rather
89:39 - than thinking of it as the file itself
89:41 - so system X dot get property will
89:43 - retrieve the operating systems kind of
89:46 - home directory and this child argument
89:50 - here will be the actual name of the file
89:53 - that we store so of course in the users
89:56 - home directory we will store a file
89:58 - called game data dot txt now we'll use
90:02 - this file object both for storing and
90:05 - retrieving the data in case you're
90:08 - wondering so the first method here
90:11 - update game data will of course write to
90:13 - the local file system in order to do
90:16 - that we will use output streams so the
90:19 - first stream will be a file output
90:21 - stream
90:24 - and streams are basically just ways it's
90:28 - about streaming data either in and out
90:31 - of the operating system or there's HTTP
90:36 - URL stream in Java if you want to stream
90:39 - data from the interwebs but yeah this is
90:42 - the most common way to like sort of
90:44 - write files and we'll also need to
90:48 - create an object output stream as well
90:51 - I'm going pretty slow here with the
90:53 - typing because there's a whole lot to
90:55 - type here and it's kind of complicated
90:57 - now why are we doing an object output
90:59 - stream as well so our Sudoku game class
91:05 - if you recall extends a I forget if it's
91:11 - a class or an interface but one of the
91:13 - two called serializable and so what that
91:18 - does is it basically allows us to
91:20 - serialize that class which means turning
91:24 - it into like a easy a data format which
91:28 - is easy to read and write in this case
91:31 - to a text file even and that just makes
91:35 - it easier for us to read and write that
91:37 - data there's other things you can do you
91:39 - could read and write to a JSON object
91:42 - but in this case serializable was the
91:45 - quickest easiest way for me to get the
91:46 - job done and that's often a good
91:49 - solution if for some reason the file
91:53 - doesn't exist or rather if if we try to
91:56 - update the game data and we're not able
91:58 - to we're just going to throw an IO
92:00 - exception obviously the message there is
92:03 - a little bit generic but I'm not super
92:05 - concerned about that now when we want to
92:09 - actually read the data from the file
92:11 - system then we're going to use input
92:14 - streams so it's almost identical except
92:16 - we're just using input stream instead of
92:18 - output streams again we'll use the game
92:23 - data file as a way of finding our
92:26 - resource
92:34 - as you can see it's very very similar
92:40 - now if for some reason we can't locate
92:44 - the file generally speaking because it
92:49 - doesn't exist so if it's the first time
92:51 - the user has run the application then we
92:54 - will throw an exception now this might
92:57 - be an important little thing to mention
92:58 - here exceptions don't always need to be
93:01 - critical errors you want to think of
93:04 - your exceptions is basically being of
93:05 - two different kinds so if you're having
93:08 - like a nullpointerexception that's going
93:10 - to obviously crash your application
93:12 - whereas things like io exceptions I'm
93:16 - not sure why I wrote class not found
93:18 - exception that is probably a typo there
93:22 - that should probably say IO exception
93:23 - but if you have something like an IO
93:25 - exception it might not actually be like
93:27 - a fatal error it might be just a way of
93:30 - basically using it like a control
93:32 - statement if it exists do this otherwise
93:34 - do that so you okay I do actually throw
93:38 - the IO exception there which is good so
93:42 - anyways that's basically all we have to
93:44 - do and then everything will work
93:45 - beautifully thank you for joining me in
93:51 - this tutorial if you would like to learn
93:52 - a lot more about programming and in
93:55 - different languages than just Java then
93:57 - check out my other tutorials and courses
93:59 - available across the web I maintain a
94:01 - YouTube channel where I host live Q&A
94:03 - sessions when I can and I am active on
94:06 - many different educational platforms
94:08 - such as you to me skill share and more
94:10 - this tutorial is dedicated to my friends
94:13 - Haemon dewater Marek de ho bitsy Chetan
94:17 - guard Jaime Corkhill Al Warren and the
94:20 - countless other people who have helped
94:21 - me build my skills as a developer and to
94:24 - share that knowledge with others peace
94:26 - out y'all I'm Odie