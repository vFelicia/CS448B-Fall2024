00:00 - In this course, I will show you how to identify
00:02 - and fix WordPress performance issues for good.
00:06 - And much of what I teach about performance
00:08 - applies to non-WordPress websites as well.
00:11 - So there will be something for everyone.
00:14 - My name is Beau Carnes.
00:16 - I've created popular courses about many topics
00:18 - including WordPress, Python, JavaScript, and more.
00:23 - Now I'm gonna teach you how to improve
00:24 - the performance of your website.
00:27 - InMotion Hosting provided a grant
00:29 - to make this course possible.
00:31 - They provide secure and reliable web hosting,
00:34 - but you don't need to use their hosting
00:35 - to implement the tips I share in this course.
00:37 - InMotion Hosting has also made a tier three VPS
00:41 - with WordPress installed available
00:44 - as a free one month trial for anyone following along
00:47 - with this course at home.
00:50 - Here are the top steps you can take right now
00:53 - to get immediate results.
00:55 - We'll be covering all of these in this course.
00:57 - Setting your performance goals,
00:59 - understanding a website request,
01:02 - DNS configuration and CDNs,
01:04 - server configuration and tuning for WordPress,
01:07 - caching techniques,
01:09 - and optimizing the WordPress application.
01:11 - Monitoring and adjusting website performance
01:13 - is a critical factor in the success of any website
01:16 - and optimizing your website for speed
01:18 - should be a top priority.
01:20 - This course is an invaluable resource
01:22 - for anyone looking to optimize their website's performance
01:25 - and gain a competitive edge in the online marketplace.
01:29 - By following the practical advice
01:31 - and best practices outlined in this course,
01:33 - you can improve your website's performance
01:35 - and provide your users with a fast, efficient,
01:38 - and enjoyable online experience.
01:43 - First, let's talk about setting your performance goals.
01:46 - Determining goals for optimizing website speed
01:48 - and performance is critical to achieving desired outcomes.
01:52 - Here are some steps to help you establish clear goals
01:55 - and objectives.
01:56 - Define your purpose.
01:58 - Start by understanding why you want to optimize
02:01 - your site's speed and performance.
02:03 - Is it to enhance user experience, reduce bounce rates,
02:06 - improve conversion rates,
02:08 - or achieve better search engine rankings?
02:10 - Clarifying your purpose will guide
02:12 - your goal setting process.
02:14 - Analyze current performance.
02:16 - Use tools like Google Lighthouse,
02:18 - Google PageSpeed Insights,
02:20 - Google Search Console, or Web Page Test
02:23 - to evaluate your website's current speed and performance.
02:27 - Identify areas where improvements are needed,
02:29 - such as slow loading times, excessive page weight,
02:33 - or high server response times.
02:36 - These insights will help you prioritize
02:38 - and set specific goals.
02:40 - Prioritize metrics.
02:41 - Determine which performance metrics
02:43 - are most important for your website.
02:45 - Common metrics include page load time,
02:48 - time to first byte,
02:49 - render start time, and interactive time.
02:52 - Line these metrics with your purpose
02:54 - to identify the most critical areas for improvement.
02:57 - Set measurable targets.
03:00 - Establish specific, measurable, achievable,
03:03 - relevant, and time-bound goals, or smart goals.
03:07 - For example, set a goal to reduce page load time
03:10 - by 30% within three months,
03:13 - or achieve a TTFB of under 20 milliseconds.
03:18 - Clear targets will provide a benchmark for progress
03:22 - and help you stay focused.
03:24 - Consider user expectations.
03:26 - Understand your target audience's expectations
03:29 - and browsing behavior.
03:31 - Different websites may require different levels
03:33 - of optimization based on their user base.
03:36 - Consider factors like device usage, mobile versus desktop,
03:40 - geographic location, and connection speeds
03:42 - to tailor your goals accordingly.
03:45 - Break it down.
03:46 - Divide your optimization goals
03:48 - into smaller, actionable tasks.
03:50 - For instance, optimize image sizes,
03:53 - minifying CSS and JavaScript,
03:56 - leveraging browser caching,
03:57 - or implementing a content delivery network.
04:01 - Breaking down goals into manageable steps
04:03 - makes them more achievable
04:04 - and allows for incremental improvements.
04:07 - Monitor and iterate.
04:09 - Regularly monitor your website's performance
04:12 - using performance monitoring tools or website analytics.
04:16 - Track progress toward your goals
04:17 - and identify areas that need further optimization.
04:21 - Continuously iterate your strategies
04:23 - to adapt to changing technologies and user expectations.
04:27 - By following these steps,
04:28 - you can establish well-defined goals
04:31 - for optimizing your website's speed and performance.
04:34 - Remember, the goals should be aligned
04:36 - with your website's purpose,
04:38 - be measurable and adaptable to evolving needs.
04:41 - Before I talk more about how to optimize websites,
04:45 - let's look at an unoptimized site.
04:48 - We'll see how the site performs now,
04:50 - and throughout the course, we'll optimize the site.
04:53 - Then we'll see how it performs at the end.
04:56 - So here's a site that's already set up on InMotion Central.
05:01 - This is a WordPress site,
05:02 - and here's actually the preview of the site,
05:04 - the Sprout Invoices.
05:06 - So this is the settings you get
05:08 - when you have your WordPress site
05:10 - hosted on InMotion Central.
05:12 - You have the preview of the site.
05:14 - You get your site stats, the URL.
05:17 - You can also manage the server from here,
05:20 - and you can do stuff for the plugin themes,
05:23 - and we have a whole section of optimization
05:26 - that we'll be talking more about later.
05:28 - And you can also access the WordPress admin page
05:32 - right from here.
05:34 - So the website is going to look like this.
05:37 - And now let's check out the performance.
05:41 - First of all, I've turned off this plugin,
05:44 - so it's not gonna have any just normal optimization,
05:48 - and we'll talk more about this plugin later.
05:50 - Now I'm at the PageSpeed Insights website,
05:53 - the pagespeed.web.dev.
05:57 - This is from Google,
05:59 - and it helps you check the performance of your website.
06:03 - So I'm just gonna get my URL here,
06:07 - and analyze.
06:13 - So if we scroll down,
06:14 - we can see the performance is only in the 47th percentile.
06:18 - Though we do have some better scores in these other areas,
06:20 - 100th percentile accessibility.
06:23 - So if we scroll down even further,
06:25 - we can see what were the bad things.
06:28 - So anything red is something that's a low performance.
06:33 - First Contentful Paint,
06:34 - Largest Contentful Paint, Total Blocking Time, Speed Index,
06:37 - and we'll actually be talking about all of these things
06:40 - a little more later.
06:41 - So if you scroll down, we can get more details,
06:44 - and it's showing a lot of things that could be improved.
06:47 - These are all the different opportunities,
06:49 - and it's showing how we can improve the site.
06:53 - And so this is kind of a good starting point
06:56 - for any website,
06:57 - you just go to this PageSpeed Insights,
06:59 - and it will give you some ideas on how to improve the site.
07:03 - Now throughout the rest of this course,
07:05 - we'll be going through a lot of these things in more detail.
07:09 - The mobile score is a little different
07:11 - than the desktop score,
07:13 - because it's emulating a mobile device
07:15 - and the network speeds.
07:17 - So on desktop, the performance is a little better.
07:20 - We're at 79, still not in the green range,
07:24 - which is what we would want.
07:26 - But that is a little better,
07:27 - but you want to design all of your websites.
07:30 - So they have good performance,
07:31 - both on desktop and mobile.
07:34 - But again, you can see all these things
07:37 - that you can improve on.
07:38 - Now let's talk about performance testing tools.
07:41 - There are many testing tools available online
07:43 - to gauge your website performance.
07:45 - In this section, we want to get a website
07:47 - to rank better on Google,
07:49 - so we will use Google's tools to achieve our goals.
07:52 - There are also some other pretty awesome optimization tools,
07:56 - such as GTmetrics, Pingdom, and many others.
07:59 - Before we explain how to assess your site prior to optimizing,
08:03 - let's go over a quick outline of how the different pieces
08:06 - are weighted in the Lighthouse tests.
08:08 - The Lighthouse score calculator
08:10 - gives us information at a glance
08:12 - and even allows you to plug in your own scores
08:15 - to understand how your overall page speed score is calculated.
08:19 - Inside Chrome's developer tools, or dev tools,
08:22 - you can use the code inspector
08:24 - to get to the open source extension for Google Lighthouse.
08:28 - It's helpful because it runs tests right within your browser,
08:31 - and it generates a report for you
08:33 - on how well the website you are looking at
08:36 - stacks up for both mobile and desktop versions.
08:39 - This test gives you information about performance,
08:42 - accessibility, best practices, and SEO.
08:45 - And here's a tip.
08:46 - When performing a test with dev tools,
08:49 - you want to use an incognito window or a guest account,
08:52 - as browser extensions typically interfere with the test
08:55 - and skew the results.
08:57 - PageSpeed Insights is an online tool that tests your site
09:00 - and then delivers a score for both mobile devices
09:03 - and desktop computers.
09:05 - You'll see a score and a breakdown of the metrics
09:07 - used to determine your site performance.
09:10 - PSI, that's PageSpeed Insights,
09:12 - will also provide a breakdown of the issues,
09:15 - causing any slowdowns to the performance of your site.
09:18 - Recommendations are provided on actions you can take
09:21 - to improve the performance.
09:23 - PSI uses simulations and real-world data
09:26 - when available to provide its scores.
09:29 - The Chrome User Experience Report
09:33 - is also called the Core Web Vitals metric.
09:36 - This is an aggregate of user experience metrics
09:39 - that is compiled from actual users
09:42 - that visit your website over the last 28 days.
09:45 - The data is not comprehensive, however.
09:47 - These users are limited to people that have opted
09:50 - to sync their browser history with Chrome,
09:53 - and the data is made available by PageSpeed Insights,
09:56 - Google's BigQuery project, and Data Studio.
10:00 - While it's helpful information when optimizing your website
10:03 - for speeding performance, it's not representative
10:05 - of everyone's experience with your site.
10:08 - The Page Experience Report in Google's Search Console
10:12 - provides you with a summary of their measurement
10:15 - for your visitor's user experience.
10:17 - Google evaluates these metrics for individual URLs
10:20 - on your website and will use them as a ranking signal
10:23 - in search results.
10:25 - This report covers Core Web Vitals,
10:28 - mobile usability, and HTTPS usage
10:31 - for every page that you have in Google's index.
10:34 - In order for a page to be counted in this report's data,
10:37 - it must have data in the Core Web Vitals report simultaneously.
10:42 - We should mention other tools as well
10:44 - because this is by no means an exhaustive list.
10:47 - In short, there are a ton of professional tools
10:49 - that you can use to measure your website's performance,
10:51 - such as GTmetrics, Pingdom, Web Page Test, and more.
10:56 - Any tool you use will guide you with things that need to be done
10:59 - to improve your website's speed.
11:03 - There are many factors that will impact the score you see on these tests.
11:07 - These variables can range from your location related to the website,
11:11 - activity on your server, network routes,
11:13 - and even the activity on your local computer.
11:16 - Because of these and many other factors,
11:18 - no two tests will show the exact same results.
11:22 - However, with a little persistence,
11:24 - you can minimize the impact that your server and website
11:27 - bring into the equation.
11:29 - Simply follow these suggestions,
11:31 - learn about them, and implement best practices.
11:34 - This will increase the likelihood that your visitors
11:37 - will have a good user experience.
11:41 - When testing your website's performance
11:43 - and putting together your plan of attack,
11:45 - the tool you use will dictate the metrics used in the audit.
11:49 - Here are the top performance indicators to pay attention to.
11:52 - I recommend focusing on achieving passing green scores on Core Web Vitals
11:57 - before you move on to the other performance metrics.
12:01 - So you can just check out this chart that we have on the screen now.
12:20 - The key to success for your website is to focus on the user experience.
12:25 - Google's Core Web Vitals are a set of metrics
12:28 - that measure real-world user experience for loading performance,
12:32 - interactivity, and visual stability of the page.
12:35 - These metrics are designed to help you understand
12:37 - how good the user experience is on your site
12:40 - compared to other sites on the web.
12:43 - Core Web Vitals are broken down into a subset of page experience signals
12:48 - that apply to all websites and should be measured by website owners.
12:52 - The metrics that make up the Core Web Vitals
12:55 - are subject to evolve over time as the signals are not set in stone
13:00 - and are intended to change as time passes
13:03 - to continue improving the overall user experience on the web.
13:07 - Page experience signals and Core Web Vitals
13:10 - are the best signals that developers have
13:12 - to measure and improve the quality of the user experience
13:16 - and they're broken down into largest contentful paint,
13:19 - first input delay, and cumulative layout shift.
13:24 - You can outline what each signal is
13:26 - and share some best practices and steps to take
13:29 - to ensure you improve your website's performance
13:32 - in relation to each metric.
13:34 - Tools that measure Core Web Vitals
13:36 - consider a page to be passing if it meets the recommended target
13:40 - for of 75th percentile for all three metrics.
13:44 - Largest Contentful Paint measures your website's loading performance
13:48 - in order to provide a good user experience for your visitors,
13:52 - or LCP, that's Largest Contentful Paint,
13:54 - should occur within 2.5 seconds of the initial page loading.
13:59 - The types of elements that are considered for Largest Contentful Paint
14:03 - are usually images or videos.
14:05 - It is important to understand that an element
14:07 - can only be considered the LCP once it is rendered
14:11 - and the user can see it.
14:13 - This metric is also tied to the first Contentful Paint
14:16 - which measures how long it takes for the initial DOM content to render.
14:21 - But First Contentful Paint does not account for how long
14:24 - it takes the largest and usually more important content
14:27 - on the page to render.
14:29 - So Largest Contentful Paint represents a user's perception
14:33 - of loading experience.
14:35 - And the Lighthouse performance score weighting is 25%.
14:39 - What it measures?
14:40 - The point in the page load time when the page's largest image
14:44 - or text block is visible within the viewpoint.
14:47 - How it's measured?
14:48 - Lighthouse extracts LCP data from Chrome's tracing tool.
14:53 - And is Largest Contentful Paint a Web Core Vital?
14:56 - Yes.
14:57 - So what elements are part of the Largest Contentful Paint?
15:00 - Well, image elements, image elements inside an SVG element,
15:05 - video elements, an element with a background image
15:08 - loaded via the URL function,
15:11 - block line elements containing text nodes
15:13 - or other inline level text elements children.
15:15 - And here's how to define the LCP using Chrome DevTools.
15:19 - First open the page in Chrome,
15:22 - then navigate to the performance panel of the DevTools.
15:25 - You can use command option I on Mac
15:27 - or a control shift I on Windows and Linux.
15:29 - Then you hover over the LCP marker in the timing section.
15:34 - And finally, the elements that correspond to LCP
15:38 - is detailed in the related node field.
15:42 - So what causes poor LCP?
15:44 - Poor LCP typically comes from four issues,
15:47 - slow server response time,
15:49 - render blocking JavaScript and CSS,
15:52 - resource load times and client side rendering.
15:56 - Now let's talk about how you can improve LCP.
15:59 - The usual suspects of a poor LCP can be caused by many things.
16:04 - Some of the causes can be slow response times from the server,
16:07 - render blocking JavaScript and CSS,
16:10 - slow resource load times and even client rendering.
16:14 - Slow server response times is the first thing you should tackle
16:17 - when optimizing for performance.
16:19 - Faster server response will typically impact
16:21 - and improve every page loading measurement, including LCP.
16:25 - If the cause is slow server response time,
16:27 - you need to optimize your server,
16:29 - route users to a nearby CDN,
16:31 - cache assets,
16:33 - survey HTML page,
16:34 - cache first,
16:36 - and establish third party connections early.
16:39 - If the cause is render blocking JavaScript and CSS,
16:42 - you want to minify the CSS,
16:44 - defer non-critical CSS,
16:46 - inline critical CSS,
16:48 - minify and compress JavaScript files,
16:51 - defer unused JavaScript,
16:53 - and minimize unused polyfills.
16:56 - If the cause is resource load times,
16:58 - you want to optimize and compress images,
17:00 - preload important resources,
17:02 - compress textiles,
17:04 - deliver different assets based on the network connection,
17:07 - and cache assets using a service worker.
17:10 - Finally, if the cause is client-side rendering,
17:14 - you want to minimize critical JavaScript
17:16 - or use another rendering strategy.
17:19 - Okay, first input delay, or FID,
17:23 - measures a website's interactivity
17:25 - and focus on input events from discrete actions
17:28 - like clicks, taps, and key presses.
17:31 - When a website does not respond in a certain amount of time
17:34 - after a user interaction,
17:36 - users experience this as a lag or slowdown.
17:40 - To provide a good user experience,
17:42 - your web pages should have a FID of 100 milliseconds or less.
17:47 - So what this represents is your user's first impression
17:50 - of your site's interactivity and responsiveness.
17:53 - It doesn't apply to the Lighthouse performance score.
17:57 - What it measures is the time when a user first interacts with your site,
18:01 - when they click a link, tap a button,
18:03 - or use a custom JavaScript power control
18:06 - to the time when the browser is actually able to respond to that interaction.
18:11 - How is measured?
18:12 - It requires a real user and thus cannot be measured in the lab.
18:15 - However, the total blocking time metric is lab measurable
18:19 - and can be used as a proxy as it correlates well with FID in the field
18:23 - and also captures issues that affect interactivity.
18:26 - And is this a web core vinyl?
18:29 - Yes.
18:31 - So what causes poor FID?
18:34 - The main cause is heavy JavaScript execution.
18:37 - Optimizing how JavaScript parses, compiles, and executes on your web page
18:41 - will directly reduce FID.
18:43 - How to improve it?
18:44 - Well, you can reduce the impact of third-party script execution,
18:48 - reduce JavaScript execution time,
18:51 - like by deferring unused JavaScript or minimizing unused polyfills,
18:56 - can break up long tasks,
18:58 - optimize your page for interaction readiness,
19:01 - use a web worker, minimize main thread work,
19:04 - or finally keep request counts low and transfer sizes small.
19:09 - Also, you should note that FID is being replaced by INP in March of 2024.
19:16 - INP is interaction to next paint.
19:19 - Cumulative layout shift or CLS measures visual stability.
19:25 - A good user experience is measured as having a CLS of 0.1 or less.
19:30 - This allows the experience to avoid any surprises for the user,
19:34 - but isn't particularly helpful for page speed.
19:37 - It's more measurement that your website is following best practices
19:41 - and is a necessary piece for achieving a high performance score for your page.
19:45 - These best practices including following common UX patterns
19:49 - that are optimized for CLS.
19:51 - When your page is loading, you should always be sure to set size attributes or reserve space.
19:56 - Specifically, specify the width or height attributes
20:00 - to create a placeholder for a content.
20:03 - This will help ensure your page does not jitter and move for the customer
20:07 - while they're trying to interact with it.
20:09 - Your website should never insert content above existing content
20:13 - unless a user interacts and expects the behavior.
20:16 - And you should always use transformation animations
20:19 - when transforming the layout during said interactions.
20:22 - So what it represents?
20:24 - The visual stability of a page.
20:26 - Instability is defined as unexpected movement or page content
20:30 - as the user is trying to interact with the page.
20:34 - And it's 15% of the Lighthouse performance score weighting.
20:38 - What it measures?
20:39 - It measures the largest burst of layout shift scores
20:42 - for every unexpected layout shift that occurs during the entire lifespan of a page.
20:48 - A layout shift occurs any time a visual element changes its position
20:52 - from one rendered frame to the next.
20:55 - How it's measured?
20:56 - To calculate the layout shift score,
20:58 - the browser looks at the viewport size
21:00 - and the movement of unstable elements in the viewport between two rendered frames.
21:05 - The layout shift score is a product of two measures of that movement.
21:09 - The impact fraction and the distance fraction.
21:13 - And is this a core, a web core value?
21:16 - Yes.
21:19 - So let's look at how to see CLS using Chrome DevTools.
21:23 - Use DevTools to help debug layout shifts
21:25 - by leveraging the experience pane under the performance panel.
21:29 - The summary view for a layout shift record
21:32 - includes the cumulative layout shift score
21:35 - as well as a rectangle overlay showing the affected regions.
21:40 - What causes poor layout shifts?
21:42 - Changes to the position of a DOM element.
21:45 - This is often the result of style sheets that are loaded late
21:48 - or overwrite previously declared style
21:51 - or delays in animation and transition effects.
21:54 - Also changes to the dimension of a DOM element.
21:57 - This is often the result of images, ads, embeds, and iframes without dimensions.
22:03 - Or insertion of or removal of a DOM element.
22:07 - Another cause is animations that trigger layout.
22:10 - This is often the result of insertion of ads and other third party embeds,
22:14 - insertion of banners, alerts, and modals,
22:17 - infinite scroll and other UX patterns that load additional content
22:20 - above existing content.
22:22 - Or finally, another cause is actions waiting for a network response
22:26 - before updating the DOM.
22:29 - And how you can improve it?
22:31 - Always set attributes to images and video elements
22:34 - or allocate the correct amount of space for that element while it's loading.
22:39 - Also, never insert content above existing content
22:42 - except during an intentional user interaction.
22:45 - And prefer transform animations to animations of properties
22:49 - that trigger layout changes.
22:51 - Finally, preload fonts using the link rel preload on the key web fonts
22:57 - and combine link rel preload with font display optional.
23:02 - Another performance opportunity is first contentful paint.
23:06 - This measures the time to render the first piece of the DOM content.
23:11 - It represents the amount of time it takes the browser to render
23:14 - the first piece of DOM content after a user navigates to your page.
23:18 - Images, non-white canvas elements, and SVGs on your page
23:22 - are considered DOM element, DOM content.
23:25 - This is 10% of the Lighthouse performance score.
23:29 - What it measures?
23:30 - This is a user centric metric for measuring perceived load speed
23:34 - because it marks the first point in the page load timeline
23:38 - where the user can see anything on the screen.
23:41 - How it's measured?
23:42 - The score is a comparison of your page's first contentful paint time
23:46 - and the first contentful paint times for real websites
23:49 - based on data from the HTTP archive.
23:52 - It is not a web core vital.
23:55 - Here are some ways to improve the first contentful paint.
23:59 - Eliminate render blocking resources.
24:02 - Minify CSS.
24:04 - Remove unused CSS.
24:06 - Preconnect to required origins.
24:09 - Reduce server response times.
24:12 - Avoid multiple page redirects.
24:14 - Preload key requests.
24:17 - Avoid enormous network payloads.
24:20 - Serve static assets with an efficient cache policy.
24:24 - Avoid an excessive DOM size.
24:27 - Minimize critical request depth.
24:29 - Insert text remains visible during web font load.
24:33 - Keep request counts low and transfer sizes small.
24:38 - Another thing to think about is the speed index, the SI.
24:42 - This represents the average time at which visible parts of the page are displayed.
24:46 - It's 10% of the Lighthouse performance score weighting.
24:50 - What it measures?
24:51 - The speed index measures how quickly content is visually displayed during page load.
24:57 - Lighthouse first captures a video of the page loading in the browser
25:00 - and computes the visual progression between frames.
25:04 - How it's measured?
25:05 - The speed index score is a comparison of your page's speed index
25:09 - and the speed indices of real websites based on data from the HTTP archive.
25:15 - It is not a web core vital.
25:21 - Here's some things you can do to improve speed index.
25:25 - Minimize main thread work.
25:27 - Reduce JavaScript execution time.
25:30 - Ensure text remains visible during web font load.
25:34 - Eliminate render blocking resources.
25:38 - Another thing to think about is the total blocking time, or TBT.
25:42 - This represents the total amount of time that a page is blocked from responding to user input,
25:48 - such as mouse clicks, screen taps, or keyboard presses.
25:52 - It's 30% of the Lighthouse performance score weighting.
25:56 - What it measures?
25:57 - This measures the time between first contentful paint and time to interactive.
26:02 - It is the lab equivalent of first input delay,
26:08 - the field data used in the Chrome user experience report
26:11 - and Google's page experience ranking signal.
26:15 - How it's measured?
26:16 - The total time in which the main thread is occupied by tasks
26:20 - taking more than 50 milliseconds to complete.
26:23 - If a task takes 80 milliseconds to run,
26:26 - 30 milliseconds of that time will be counted toward the TBT, the total blocking time.
26:31 - If a task takes 45 milliseconds to run, 0 milliseconds will be added.
26:39 - Is total blocking time a web core vital?
26:42 - Yes.
26:43 - It's the data, it's the lab data equivalent of first input delay.
26:55 - Total blocking time measures long tasks,
26:58 - those tasks taking longer than 50 milliseconds.
27:02 - When a browser loads your site,
27:04 - there is essentially a single line queue of scripts waiting to be executed.
27:09 - Any input from the user has to go into that same queue.
27:13 - When the browser can't respond to user input because other tasks are executing,
27:19 - the user perceives this as lag.
27:22 - Essentially, long tasks are like that person at your favorite coffee shop
27:26 - who takes far too long to order a drink.
27:28 - Like someone ordering a 2% venti, four pump vanilla, five pump mocha, whole fat froth,
27:33 - long tasks are a major source of bad experiences.
27:37 - Some things that cause a TBT on your page are heavy JavaScript and heavy CSS.
27:42 - And that's basically it.
27:45 - Here's how to see TBT using Chrome DevTools.
27:51 - And how to improve TBT, you can break up long tasks,
27:54 - optimize your page for interaction readiness,
27:57 - use web worker, and reduce JavaScript execution time.
28:00 - Now let's talk about time to first byte or TTFB.
28:04 - This is a foundational metric for measuring the time between the requests for a resource
28:09 - and when the first byte of a response begins to arrive.
28:12 - It helps identify when a web server is too slow to respond to requests.
28:16 - TTFB is the sum of the following request phases.
28:20 - Redirect time, server worker startup time,
28:23 - DNS lookup, connection TLS negotiation,
28:26 - and request up to the point at which the first byte of the response has arrived.
28:33 - So here are some ways to improve TTFB.
28:37 - Hosting web servers with inadequate infrastructure to handle high traffic loads,
28:41 - web servers with insufficient memory that can lead to thrashing,
28:45 - unoptimized database tablets, suboptimal database server configuration,
28:50 - avoid multiple page requests,
28:53 - pre-connect to required origins for cross-origin resources,
28:57 - submit your origin to the HSTS preload list to eliminate HTTP to HTTPS redirect latency,
29:04 - use HTTP2 or HTTP slash 3,
29:07 - and use server-side generation for markup instead of SSR where possible and appropriate.
29:13 - Minimizing TTFB starts with choosing a suitable hosting provider with infrastructure
29:18 - to ensure high uptime and responsiveness.
29:21 - This, in combination with a CDN, can help significantly.
29:27 - In this section, we'll discuss how the speed of a request to a website
29:31 - impacts overall website performance.
29:34 - When a user makes a request to load a website,
29:37 - a series of processes happen behind the scenes
29:40 - to deliver the requested content to the user's browser.
29:43 - This process can be broken down into the following steps.
29:47 - Step 1, DNS lookup. The domain name system is a distributed database
29:52 - that maps domain names to IP addresses.
29:55 - When a user types a URL into the browser,
29:57 - the browser first sends a request to a DNS server
30:00 - to look up the IP address of the domain name.
30:03 - Step 2, connection.
30:05 - Once the browser has the IP address of the website,
30:08 - it establishes a connection to the server hosting the website
30:12 - using the Hypertext Transfer Protocol, or HTTP.
30:16 - Or the more secure HTTPS protocol, the S stands for secure.
30:21 - Step 3, request.
30:23 - After establishing the connection,
30:25 - the browser sends an HTTP request to the server
30:29 - requesting the specific webpage or resource
30:32 - that the user wants to access.
30:34 - Step 4, processing.
30:36 - The server receives a request and begins to process it.
30:40 - This may involve executing scripts, querying databases,
30:44 - and retrieving files from the file system.
30:47 - Step 5, response.
30:49 - Once the server has processed the request,
30:52 - it sends an HTTP response back to the browser.
30:55 - This response includes the requested content,
30:58 - such as the HTML, CSS, and JavaScript,
31:01 - and any images or other resources required to display the website.
31:06 - Step 6, rendering.
31:08 - The browser receives the response from the server
31:11 - and begins to render the webpage.
31:13 - This involves parsing the HTML and rendering the layout,
31:16 - styling the page with CSS, executing JavaScript,
31:19 - and loading any images or other resources
31:22 - required to display the page.
31:24 - Step 7, user interaction.
31:27 - Finally, the user can interact with the webpage,
31:30 - clicking on links, filling out forms,
31:32 - and performing other actions.
31:34 - These steps happen very quickly,
31:36 - often in a matter of milliseconds,
31:38 - but any delay or bottleneck in any of these steps
31:41 - can cause the page to load slowly or not at all,
31:44 - leading to a poor user experience.
31:47 - To optimize website performance,
31:49 - it's important to identify and address any performance issues
31:52 - at each stage of the process.
31:56 - Some of the WordPress optimizations
31:59 - have to happen right on the server.
32:01 - So let me show you how to manage your server in Inmost and Central.
32:05 - Now, there will be a similar process,
32:07 - even if you're using another hosting provider.
32:09 - I'll go to Tools, then Manage Server.
32:12 - And then we can see the host name, the IP address,
32:15 - and then we can see that it's currently running.
32:19 - Now, you can see we can use this to restart or stop the server,
32:23 - but what we want to do is add our SSH key.
32:26 - That's going to allow us to connect to our server
32:29 - from our local machine.
32:31 - SSH keys are used to securely authenticate with the server
32:35 - so we can connect via the command line interface.
32:38 - This is usually the preferred method for advanced users
32:41 - to manage their servers,
32:43 - since you can quickly make changes without having to navigate
32:46 - through a graphical user interface.
32:49 - So to get our SSH key, we're going to have to generate one.
32:52 - So you can open a terminal on your local computer,
32:55 - and then we can type in ssh slash keygen or dash.
33:02 - Okay, then press Enter,
33:04 - and it's going to ask us to enter the file,
33:06 - where to save the key, and we'll just press Enter again.
33:10 - And mine already exists, so I'm not going to override it,
33:13 - but if you haven't created it before,
33:16 - that's what it would show you.
33:18 - And now we can get it by a copy where the key is,
33:22 - and then I'll do cat,
33:24 - and then just put the location.pub.
33:29 - And then we can see the whole key here.
33:34 - And then I can just copy this key.
33:38 - So I'll go to add SSH key,
33:40 - and then I will just paste in my public key, and then update.
33:47 - And now we will be able to connect to the server via SSH.
33:51 - So I need my IP address.
33:53 - So I'll just copy this IP address,
33:55 - or actually I'll just copy the host name here.
33:58 - Now we'll go back to a terminal SSH root at,
34:01 - and then the server name, or you could also use the IP address,
34:05 - and then we'll just hit enter here.
34:07 - And here we want to put yes, we are sure we want to continue.
34:12 - Okay, we're logged into the host, we're logged into the server.
34:17 - These tips explain what measures can be taken with Redis,
34:21 - MySQL, Opcache, and other technologies
34:24 - to achieve a high performance server.
34:26 - There are many opportunities to improve performance.
34:30 - I'll focus on fast storage and emphasize tuning the cache.
34:35 - Accessing files from NVMe storage, storing PHP scripts and Opcache,
34:40 - and compressing responses with Brotly
34:42 - are all part of a high performance server.
34:45 - I'm going to show you how to analyze your server performance
34:48 - and make incremental improvements.
34:52 - Services like Redis and Memcache
34:55 - can significantly improve WordPress performance
34:58 - by caching data in memory
35:00 - and reducing the number of database calls required to serve content.
35:05 - They act as key value stores
35:07 - that temporarily hold frequently accessed or computationally expensive data,
35:12 - resulting in faster response times and reduced server load.
35:16 - WordPress can be configured to use Redis as an object store
35:20 - by employing specific plugins,
35:23 - such as Redis Object Cache or W3 Total Cache.
35:26 - So once Redis is installed and configured,
35:29 - you can check the following items to ensure Redis is optimized
35:32 - and operating its full capacity.
35:34 - Right now I'm connected to my server through InMotion,
35:38 - the server that has the WordPress installations installed
35:42 - and already has Redis installed.
35:44 - So I can check the Redis memory usage with this command,
35:48 - Redis CLI info memory.
35:55 - And then we get all this information.
35:58 - So if I go scroll up a little bit,
36:01 - when the used memory peak is close to the max memory that's shown further down,
36:06 - Redis may not have enough resources to operate to its full capacity.
36:10 - In addition, Redis may be actually evicting keys from the cache
36:14 - to make room for new ones.
36:16 - This is not ideal and key evictions should be avoided if possible.
36:19 - So you can increase the max memory variable in your Redis configuration
36:23 - to solve the issue.
36:24 - And here are where the configuration files are.
36:27 - If you make any changes,
36:30 - make sure to restart everything to apply your changes.
36:34 - Key eviction.
36:36 - Key eviction is the process of removing old and unused data from the cache
36:40 - to make room for new data.
36:42 - This can be especially problematic for high traffic websites
36:45 - that rely on Redis caching to improve performance.
36:48 - If your system resources allows for it
36:51 - and the evicted keys count is high,
36:54 - it's again recommended to increase max memory.
36:56 - The following command will provide information about the number of keys
36:59 - and how many have been evicted.
37:02 - By examining these aspects and making the appropriate adjustments,
37:05 - you can optimize Redis to significantly enhance your WordPress site's performance.
37:11 - Optimize the database.
37:14 - If object caching like Redis is not available for the WordPress site,
37:18 - requests for database content go straight to the database.
37:21 - First, the database checks its cache to serve the results directly, if possible,
37:26 - and stores it for future use.
37:28 - If caching is unavailable or not allowed,
37:31 - the query proceeds to the database.
37:33 - The database combines cached and uncached information,
37:37 - requesting data from the operating system.
37:40 - The speed of retrieving the data depends on available RAM
37:43 - and the storage type, with NVMe being the fastest and HDD being the slowest.
37:49 - Simple queries return data immediately to the PHP call,
37:53 - while complex queries requiring temp tables demand more processing time
37:58 - and can slow down the website or cause server issues under high traffic.
38:03 - Several tuning techniques can improve performance.
38:07 - You can set the buffer pool size.
38:10 - The buffer pool is the area of memory that MariaDB uses to cache data and indexes.
38:16 - It's important to configure the buffer pool size appropriately
38:20 - based on the amount of available memory and the size of the database.
38:24 - The buffer pool size can be controlled using the
38:28 - nodb underscore buffer underscore pool underscore size variable.
38:32 - You can start with 128 or 256 megabytes,
38:36 - depending on the total available RAM on your server.
38:39 - Check the hit rate and adjust accordingly to ensure it's working as expected.
38:45 - You can see here where the configuration files are,
38:49 - and always make sure to restart your services to apply any of your changes after you configure this.
38:57 - One way to analyze buffer pool performance is by observing
39:01 - the nodb underscore buffer underscore pool underscore weight underscore free status variable.
39:06 - If it's decreasing, then you don't have enough buffer pool,
39:09 - or your or your flushing isn't occurring frequently enough.
39:13 - In this case, you should set the nodb underscore buffer underscore pool underscore size variable higher
39:19 - if your system resources allows for it.
39:22 - You can also enable query cache.
39:24 - Query cache is a feature that stores the results of frequently executed queries and memory,
39:30 - which can significantly improve query performance.
39:33 - It's recommended to enable query cache,
39:36 - but it's important to note that it may not be effective for all workloads.
39:41 - The query cache can be enabled or disabled using the query underscore cache underscore type variable.
39:48 - The SQL server store stats about the query cache.
39:52 - Query cache is actually deprecated in MySQL,
39:55 - but it still exists in MariaDB.
39:58 - Query cache has taken a less desirable place in most MySQL setups,
40:02 - because of the high adoption of multi core and multi server deployments,
40:07 - where it can be a bottleneck.
40:09 - For Mario DB, it's still useful for websites and fits well in our use case,
40:14 - where the deployment consists of a single site on the server.
40:20 - Q cache underscore inserts contains the number of queries added to the query cache.
40:26 - And Q cache underscore hits contains the number of queries that have made use of the query cache,
40:32 - while Q cache underscore low mem underscore prunes contains the number of queries
40:37 - that were dropped from the cache due to lack of memory.
40:41 - The example could indicate a poorly performing cache.
40:45 - More queries have been added and more queries have been dropped than have actually been used.
40:51 - You can set in memory table size limits.
40:55 - As previously mentioned, complex queries will cause the SQL server to create temporary tables.
41:01 - The SQL server will attempt to create tables in memory up to a certain size for performance.
41:06 - It's important to set the max size to an appropriate value to avoid creating on disk temporary tables.
41:14 - The variables that control this behavior are the tmp underscore table underscore size
41:20 - and max underscore heap underscore table underscore size.
41:23 - You can compare the number of internal on disk temporary tables created
41:29 - to the total number of internal temporary tables created
41:33 - by comparing the created underscore tmp underscore disk underscore tables
41:38 - and created underscore tmp underscore tables values.
41:43 - You can see if it's necessary to increase by comparing the status variables
41:47 - created underscore tmp underscore disk underscore tables and created underscore tmp underscore tables
41:53 - to see how many temporary tables out of the total created needed to be converted to disk.
41:59 - In this example, the SQL server is not having to create temporary tables on disk.
42:05 - This is considered optimal.
42:07 - Another thing you can do is to prune the WordPress database.
42:10 - Without intervention, WordPress will store junk and unused data in the database.
42:15 - Over time, this can add up causing database bloat and serious performance lags.
42:21 - This includes items such as post revisions,
42:25 - which includes autosaved drafts, trashed posts, trashed comments, comment spam,
42:31 - and tables for plugins and themes that are no longer active or installed, and transient records.
42:38 - In your wp-config.php file, add or edit the following setting
42:43 - to limit the number of post revisions saved to the database.
42:48 - Many resources exist on the internet for dealing with these items.
42:52 - Monitor performance.
42:53 - It's important to regularly monitor the performance of Mario DB and adjust the configurations as necessary.
43:00 - This includes monitoring CPU usage, memory usage, disk IO, and query performance.
43:06 - Use a tool like MySQL Tuner to gain insights on the performance of the SQL installation,
43:13 - or enable slow query logging to identify long-running queries.
43:20 - Opcache provides significant benefits when used with PHP FPM.
43:25 - When a PHP file has been previously requested and there's enough opcache available,
43:30 - the script is already stored in memory.
43:33 - This allows for faster execution as it stands ready to accept data inputs without having to reload the file from disk.
43:40 - It's important to maximize opcache hits and minimize misses.
43:45 - And here are where the configuration files are.
43:48 - If you make any changes, make sure to restart everything to apply your changes.
43:55 - For opcache, WordPress plugins are available that are restricted by auth.
44:00 - Standalone opcache dashboard pages need additional security,
44:04 - but WordPress plugins are behind authentication already.
44:09 - PHP provides several built-in functions to obtain information about opcache status and configuration,
44:15 - like opcache underscore get underscore status and opcache underscore get underscore configuration.
44:21 - Additionally, there are several web-based monitoring tools to visualize opcache usage and performance.
44:27 - Some popular options include opcache GUI,
44:30 - which is a single file PHP script that provides a simple and clean interface to monitor opcache usage and performance.
44:38 - And then there's OCP, which is a web-based opcache control panel
44:42 - that allows you to monitor and manage opcache settings in real time.
44:46 - Opcache status, which is a one-page opcache status page for the PHP 5.5 opcode cache,
44:53 - and cache tool, which allows you to work with APCU opcache
44:59 - and the file status cache through the CLI.
45:02 - It will connect to a fast CGI server like PHP FPM and operate on its cache.
45:09 - When reviewing opcache statistics, there are a few key items to look for and assess.
45:15 - Opcache hit rate.
45:17 - A hit rate is the percentage of requests that are being served using cached opcode
45:23 - instead of parsing and compiling the scripts anew.
45:27 - This hit rate suggests opcache requires more memory or resources to perform its full capacity.
45:34 - A hit rate close to 100 indicates that the cache is functioning effectively
45:40 - and providing the desired performance benefits.
45:43 - Monitoring the hit rate can help identify if adjustments to opcache settings
45:48 - are necessary to improve its efficiency.
45:51 - The next section will explain how to adjust the memory allocation for opcache.
45:56 - Memory consumption.
45:58 - Analyzing memory usage involves checking the amount of memory allocated to the opcache
46:03 - and how much of it is being used.
46:06 - In the output you can see here, the administrator would want to consider
46:10 - increasing the opcache.memory underscore consumption to a value higher than 128 megabytes
46:16 - as the cache full boolean is true and free memory is at 8 bytes.
46:21 - This information helps determine if there is a need to increase or decrease the memory allocation
46:27 - based on the size and complexity of your PHP scripts.
46:31 - Ensuring an appropriate memory allocation helps prevent cache evictions
46:35 - and promotes a more efficient use of server resources.
46:38 - Both numcache keys and maxcache keys are metrics that provide insights into the number of cache keys
46:45 - compiled PHP scripts currently stored in the opcache, the numcache keys
46:51 - and the maximum number of cache keys allowed, the maxcache keys.
46:55 - By comparing these values you can identify if the cache is nearing its capacity
47:00 - or if adjustments are needed to optimize the cache size.
47:03 - If numcache keys frequently approaches maxcache keys, it can be beneficial to increase
47:09 - the opcache.maxacceleratedfiles value to accommodate more scripts
47:14 - reducing cache evictions and further improving performance.
47:18 - Regularly reviewing these key items can help you optimize the opcache configuration
47:23 - leading to improved website performance and reduced server resource usage.
47:29 - As previously mentioned in the database optimization section,
47:34 - NVMe storage helps database server performance by providing significantly faster
47:39 - data access and reduced latency compared to traditional storage solutions.
47:44 - This results in quicker response times and more efficient query processing
47:49 - leading to improved overall server performance.
47:52 - Disk I.O. helps increase performance of all aspects of your web server
47:57 - and having NVMe speeds usually means that the database caching
48:01 - in W3.12 cache plugin is not needed
48:04 - and it can have adverse effects to performance if enabled.
48:08 - NVMe storage improves server performance for WordPress websites in several ways.
48:14 - Faster page load times.
48:17 - With its high speed data transfer and load latency, NVMe storage allows
48:22 - for quicker access to website files and assets such as images, style sheets, and scripts.
48:28 - This leads to faster page load times and a better user experience.
48:33 - Improved database performance.
48:35 - The benefits of using NVMe storage when processing database queries
48:39 - can be outlined as follows.
48:42 - When processing queries, the database relies on both cached and uncached
48:46 - MySQL data requiring interactions with the operating system to retrieve
48:50 - the necessary information.
48:52 - If the operating system has ample RAM,
48:55 - the files needed for a query might already be stored in RAM
48:59 - rather than only being available on a persistent storage device.
49:03 - Finally, in cases where data must be accessed from a storage device,
49:07 - an NVMe drive provides significantly faster data retrieval
49:11 - compared to a SATA SSD while traditional HHDs are much slower
49:16 - and typically not used in such scenarios anymore.
49:19 - Overall, the NVMe storage greatly enhances database query performance
49:23 - due to its rapid data access capabilities.
49:28 - Compressing data server responses with Brotli or gzip can significantly improve
49:33 - website performance by reducing the amount of data transferred over the network.
49:37 - This provides a final stage of optimization on the response
49:41 - being returned from the origin server.
49:44 - On average, gzip compression can reduce the size of web content by 60 to 70 percent
49:51 - while Brotli tends to provide even better compression rates
49:54 - often reducing content size by 70 to 80 percent.
49:58 - Enabling Brotli compression within Nginx is accomplished
50:02 - through the use of the Brotli Nginx module.
50:06 - The module can be compiled and installed alongside Nginx and loaded dynamically.
50:11 - Analyze a server response for compression.
50:13 - To determine if a request response was compressed with Brotli or gzip compression
50:19 - you can use Chrome or Firefox developer tools to review the content encoding headers.
50:24 - So you can follow these steps.
50:26 - Open the developer tools in your browser.
50:29 - Click on the Network tab in the developer tools.
50:32 - Refresh the webpage or initiate the action you want to analyze.
50:37 - This will populate the network panel with a list of requests made by the browser.
50:42 - Then we'll find the requests we're interested in
50:46 - such as the main document request or a specific resource like a CSS or a JavaScript file.
50:52 - We'll click on the request to open the detailed view.
50:55 - In the detailed view we'll look for the Headers tab.
50:59 - This should be the default tab in both browsers.
51:02 - Scroll down to the Response Headers section.
51:06 - Then we'll check the value of the content encoding header.
51:10 - If this response is compressed with gzip it will display gzip
51:14 - and if it's compressed with Brotli it will display br.
51:18 - If the header is absent or has a different value
51:21 - the response is not compressed using either of these algorithms.
51:24 - By examining the content encoding header in the developer tools
51:28 - you can quickly determine if a request response was compressed with Brotli or gzip.
51:36 - Serving requests from the NGINX CAS can result in significant performance improvements
51:42 - as it eliminates the need for the request to traverse the entire stack
51:46 - and access the backend services.
51:49 - This can lead to reduced processing times and improved response times
51:53 - resulting in a better user experience.
51:55 - According to benchmarks serving requests from the NGINX CAS
51:59 - can result in a 90% reduction in response times
52:03 - compared to requests that traverse the entire stack.
52:06 - This is due to the cache mechanism's ability to serve requests
52:11 - directly from memory or disk reducing the time taken to process the request.
52:16 - Furthermore serving requests from the NGINX CAS
52:19 - can significantly reduce server load and improve scalability.
52:23 - By reducing the number of requests that must be handled by backend services
52:27 - like PHP, FPM or MySQL
52:29 - the server can handle more requests concurrently
52:32 - leading to improved performance and faster response times.
52:36 - This is essential for a high-traffic website.
52:39 - The UltraStack NGINX configuration adds an x-proxy cache HTTP header to responses
52:46 - and the upstream cache status to NGINX access log entries.
52:51 - The following three techniques explain how to identify whether the page being received
52:56 - is a cache version served by NGINX.
53:00 - We can use curl.
53:02 - We can make a simple get request to the URL in question
53:05 - and use grep to check the x-proxy cache header.
53:09 - Also we can use chrome dev tools.
53:11 - You can use F12 or the other shortcut to bring up the dev tools window
53:15 - then click the network tab.
53:16 - Pick the box that says disable cache
53:19 - which will bypass chrome's internal cache
53:22 - then reload the page to capture all of the network information.
53:26 - Not disabling chrome's cache will allow you to see 304
53:30 - not modified responses for static assets
53:33 - which shows how the client side cache is working.
53:36 - The following are the possible values for upstream cache status.
53:41 - Miss the response was not found in the cache
53:44 - and so was fetched from an origin server.
53:47 - The response might then have been cached.
53:50 - Bypass the response was fetched from the origin server
53:54 - fetched from the cache because the response matched a proxy cache bypass directive.
53:59 - Expired. The entry in the cache has expired.
54:02 - The response contains fresh content from the origin server.
54:06 - stale. The content is stale because the origin server is not responding correctly
54:10 - and proxy cache use stale was configured.
54:14 - Updating. The content is stale because the entry is currently being updated
54:19 - in response to a previous request
54:21 - and proxy cache use stale updating is configured.
54:25 - Revalidated. The proxy cache revalidate
54:29 - directive was enabled and nginx verified that the current cache content was still valid.
54:35 - Hit. The response contains valid, fresh content
54:39 - direct from the cache. Another technique to explain how to identify whether
54:43 - the page being received is the cache version served by nginx
54:47 - is using the nginx access log. You connect to the
54:51 - server using SSH and read the access log with a tail or a
54:55 - cat. The value assigned to UCS or the
54:59 - upstream cache status will be one of the cache statuses we talked about before.
55:03 - Using central's managed server tools, here's how you would enable nginx
55:07 - proxy cache on your site. With nginx proxy cache configured
55:11 - you may use the ultra stack utilities to
55:15 - determine the cache hit rates for all requests to nginx.
55:19 - While this is a tool specific to in-motion hosting
55:23 - the information can be received using the third party nginx module
55:27 - VTS. So in summary, using nginx proxy cache will help
55:31 - drive performance for high traffic websites.
55:35 - While the exact amount depends on the specific
55:39 - workload of the website, a minimum of 4 GB and
55:43 - 2 vCPU cores is recommended when benchmarking your
55:47 - resource needs on a high traffic website. In a high performance
55:51 - server running MySQL, Redis, PHP, FPM, Apache, and
55:55 - nginx, having enough RAM is critical to allow each services
55:59 - caching techniques to work at their full potential. These services use
56:03 - RAM to cache frequently accessed data and reduce the time taken
56:07 - to retrieve it from disk or other storage devices. If the server
56:11 - does not have enough RAM, the caching will not be as effective, leading
56:15 - to longer processing times and slower website performance.
56:19 - For instance, MySQL uses the NODB buffer pool to
56:23 - cache frequently accessed data from the database, and Redis uses
56:27 - memory to store frequently accessed data in key value pairs.
56:31 - PHP FPM uses opcache to cache PHP
56:35 - scripts, and nginx uses RAM to cache frequently requested
56:39 - webpages and assets. If the server does not have sufficient
56:43 - RAM, these caching techniques will not be as effective, and the
56:47 - server may resort to swapping data in and out of slower
56:51 - storage devices, leading to a slower response times and reduced server
56:55 - capacity. Swap usage. To determine if a
56:59 - Linux server is swapping, you can use the free command to view the system's
57:03 - memory usage. If the swap value is greater than 0,
57:07 - it indicates that the server is currently using swap space to store
57:11 - data in memory. Additionally, you can use the vmstat command
57:15 - to monitor the amount of swapping activity occurring on the server,
57:19 - with the SI and SO values indicating the amount of memory
57:23 - being swapped in and out, respectively. This example
57:27 - does not use swap and is not swapping. OOM
57:31 - OOM kills. To determine if a Linux server is experiencing
57:35 - OOM, OOM or out of memory kills, you can check
57:39 - the system logs for messages related to OOM events.
57:43 - On most Linux distributions, the system log file is located
57:47 - at var slash log slash messages, or var slash log slash syslog.
57:51 - To view OOM related messages, you can search for
57:55 - the keyword OOM using the grep command.
57:59 - If OOM or OOM events are occurring, you'll see
58:03 - entries that indicate which process or application was killed by
58:07 - the OOM killer. Additionally, you can use tools like
58:11 - DMESG and journal control to view kernel messages
58:15 - related to OOM events. By having enough RAM on the server,
58:19 - each service can utilize caching techniques to their fullest extent,
58:23 - resulting in faster processing time, reduced
58:27 - disk usage, and an overall better user experience.
58:33 - There's a plugin that's super helpful when it comes to
58:37 - optimizing WordPress sites. Let me show you how to install it really
58:41 - easily with InMotion, but you can also install it basically
58:45 - with any WordPress installation. So we'll go to optimize
58:49 - and then WordPress. We have the W3
58:53 - Total Cache. Now you can see that it improves SEO
58:57 - and the user experience of your site by increasing website performance,
59:01 - reducing load times via features like content delivery network integration
59:05 - and the latest best practices. So basically I'm just
59:09 - going to click here and W3 Total Cache is one of the most popular
59:13 - ways to optimize and manage the cache for your WordPress site.
59:17 - So this is going to result in faster
59:21 - load times and less strain on your server, which is definitely going to
59:25 - help with SEO. You can also enable this within the
59:29 - WordPress dashboard if you don't have InMotion Central.
59:33 - And I'll show you how to do that in a second. Right now I'm going to click on setup guide.
59:37 - And this is going to help you set up things, but we're going to configure on our own
59:41 - so I'll skip this setup guide. So before we
59:45 - do that, I'm going to show you how you would install this with just WordPress
59:49 - if you don't have the InMotion settings. So we just go to plugins
59:53 - and then add new and then you just
59:57 - search for W3
60:01 - Total Cache.
60:05 - So here is where you would install it and activate it, but we already have
60:09 - installed and activated. So I'm going to go back to this performance
60:13 - tab here. That's the W3 Total Cache tab.
60:17 - And before I go through setting it up, let me just give you a little more context.
60:21 - So by default WordPress is a dynamic
60:25 - CMS. That means for every visitor request that WordPress has to process
60:29 - it must first connect to the database to see if the requested page even
60:33 - exists. In a lot of cases this might not be problematic
60:37 - on a site that just doesn't receive much traffic. However, a sudden surge in traffic
60:41 - caused by search engine bots or just a general increase in normal
60:45 - traffic can quickly cause your WordPress site to use up a lot
60:49 - of CPU resources from the server while trying to fulfill needless
60:53 - duplicate requests again and again. You can counter
60:57 - this increase in CPU usage by implementing a caching plugin.
61:01 - What these do is cast the first visitor's request of a new page
61:05 - to a plain HTML file on the server. Then when another visitor comes through
61:09 - and requests the same page, so long as the page wasn't
61:13 - updated in your admin section or updated by comment, the
61:17 - cached HTML page will be served. This can greatly reduce
61:21 - CPU usage of your WordPress site very easily.
61:25 - As an example, let's say you had 100 views of your front page. Without caching
61:29 - that would require the same database query to have to run 100 times
61:33 - and every time it's just getting back the exact same data anyway. With the caching
61:37 - plugin, only the first user would have the database query run to generate the
61:41 - cached HTML file. Then the next 99 visitors would get
61:45 - that cached HTML served to them right away without having to wait
61:49 - for any database activity to complete. This is basically always a win-win
61:53 - because your visitors don't have to wait as long for your pages to load and you're reducing
61:57 - the impact of WordPress's requests on the server's performance.
62:01 - Now I do want to note that database caching is not recommended for
62:05 - shared hosting as the process is dependent on the disk speed of the server.
62:09 - So due to the nature of shared system resources, disk speed
62:13 - may be limited. And so database caching may adversely affect
62:17 - the performance of the site. Really, what you want to do is experiment with different
62:21 - caching techniques to see which one works best for your site. So now
62:25 - let's see how to set up the w3 total caching plugin. I'm going to go to
62:29 - the general settings here. Okay, and then I'm going to
62:33 - make sure that the page cache is enabled. And then
62:37 - for all these settings, we're just going to want to click either save
62:41 - all settings, or save settings and purge caches
62:45 - after you update the settings. One thing to keep in mind is
62:49 - that you never want to use both nginx page caching
62:53 - and total cache, that would slow things down and would cause
62:57 - some conflicts with the caching. So you basically just want to use one
63:01 - or the other. Another good feature to use is the
63:05 - minify. You can see this is going to reduce the load time by decreasing the size
63:09 - and number of CSS and JavaScript files. So it's, it's going to
63:13 - make things load a lot quicker if you enable the
63:17 - minify. If you are enabling minify, you're going to want to make sure
63:21 - to check your WordPress site to make sure the site looks normal. If you see problems
63:25 - then you can disable the minification.
63:29 - And this is where you can use op cache to validate timestamps
63:33 - so it will request the cache with the latest version.
63:37 - And then you see the database cache.
63:41 - Caching, it caches the database objects and this decreases the response
63:45 - time of the site so it doesn't have to load from the database every time.
63:49 - We're not we have it disabled because it's best if object
63:53 - caching is not possible. By our case, we're going to use object
63:57 - caching. And you also have the browser cache
64:01 - and you can enable or disable a CDN.
64:05 - And when you're choosing a CDN, you're going to have to choose
64:09 - basically the CDN provider, which CDN you're going to use.
64:13 - I'm actually going to disable this because
64:17 - for a CDN you're going to have to sign up for
64:21 - a CDN account. And make sure not to click the CDN button
64:25 - if you don't have a CDN. That could actually mess some things up for your site.
64:29 - Okay, I'm going to save this. And then
64:33 - we'll go over to the page cache tab.
64:37 - So we're going to just check the settings on this page.
64:41 - We're going to we want to make sure we cast the front page, cast the feed,
64:45 - cast SSL. We don't want to cast the URIs. We want to
64:49 - cast the 404. Don't cast page for logged in users. Don't cast page for
64:53 - the following user roles, just the administrator role. So we're just going to use all these
64:57 - default settings. And this is just going to make sure we cast the page we want to
65:01 - cache and don't cast the pages we don't want to cache. So I'll just save
65:05 - settings and purge caches. So now I'm going to go to
65:09 - the website, I'll just go to visit site here.
65:13 - And I will go to view page source. And then if I go
65:17 - all the way down to the bottom, I should see something.
65:21 - Yep, performance optimized by w3 total cache.
65:25 - So now I know that it's you it's working correctly
65:29 - and it's installed correctly. So I'm back over on the total cache
65:33 - setting page. I want to talk about cleaning your WordPress cache.
65:37 - This is something you may need to do from time to time when using a caching plugin to speed up
65:41 - WordPress. If you make changes to your WordPress site and don't see the changes when
65:45 - visiting the updated page, you may need to clear your cache. This is because
65:49 - the caching plugin could still be showing the cached version of your page.
65:53 - So to force WordPress to show your most recent changes right away,
65:57 - you can delete the cache. So basically just go to the
66:01 - the main settings page and then we can
66:05 - click empty all caches just like that.
66:09 - All caches successfully emptied.
66:13 - Now let's talk about browser
66:17 - caching and some implementation techniques.
66:21 - e tags. The e tag HTTP response header
66:25 - is one that web servers and browsers use to determine
66:29 - whether a resource in the browser's local cache matches the
66:33 - one in the origin server. When a user revisits
66:37 - the site, one of two things happen. It displays content
66:41 - to the user in the browser if it's within the allowable cache
66:45 - refresh time, the time to live. If content is out
66:49 - of its cache time TTL expired, then
66:53 - if it has an e tag, then it will need to send an e tag to the
66:57 - resolved URL to see if it needs to refresh. Then if it gets
67:01 - the matching e tag, then it will keep the content it has
67:05 - no new downloading of content and set the existing content
67:09 - TTL into the future, which makes it a viable
67:13 - cached content for the TTL. And if it gets a different
67:17 - e tag, then it will trigger a fresh download of the new
67:21 - content. If it does not have an e tag, then it will
67:25 - send a request out to get the potentially new content
67:29 - and it will download that content regardless of whether it really is
67:33 - new or not. It's important to note that the e tag
67:37 - request and response is much, much smaller than a download of
67:41 - content. As most websites do not change between
67:45 - TTLs, the TTLs need to be low just in case the site
67:49 - does change. Therefore, the e tag process is much more
67:53 - efficient than TTLs by themselves.
67:57 - So how do you check if your server response is using e tags?
68:01 - Well, you open the developer tools in your browser using
68:05 - the shortcut key or you can right click on the web page and click inspect.
68:09 - Then click on the network tab in the developer tools.
68:13 - Next, refresh the web page or initiate the action you want to analyze.
68:17 - This will populate the network panel with a list of requests made by the browser.
68:21 - Next, locate a specific resource like a CSS or JavaScript file.
68:25 - Click on the request to open the detailed view. In the
68:29 - detailed view, look for the headers tab.
68:33 - Then scroll down to the response header section for the selected file
68:37 - and check for the presence of an e tag.
68:41 - How to configure e tags in W3 total cache. In your WordPress
68:45 - admin dashboard, navigate to performance browser cache.
68:49 - Scroll down to the general section. Check the box next to the
68:53 - set entity tag e tag setting. On the same page, using
68:57 - the same method, you can also enable or disable e tags for specific
69:01 - files types, including CSS and JS, HTML
69:05 - and XML media and other files. Finally,
69:09 - press the save settings and purge caches button within each respective
69:13 - setting box to save and apply the caching changes immediately.
69:17 - Time to live. The time to
69:21 - live value is the time that an object is stored in a caching system before it's
69:25 - deleted or refreshed. In the context of CDNs,
69:29 - TDL typically refers to the content caching, which is the process
69:33 - of storing a copy of your website resources on CDN
69:37 - proxies to improve paid load speed and reduce origin server bandwidth
69:41 - consumption. TDLs are used for caching purposes, and
69:45 - the value is stored in seconds. If the TDL value is set to a low number
69:49 - like 3600 seconds, the data will be stored in the cache for
69:53 - one hour. After one hour, a new version of the data needs to be retrieved.
69:57 - If the TDL value is set to a high number like
70:01 - 86,400 seconds, the data will be stored in the cache for
70:05 - 24 hours. High TDL values cache your data longer
70:09 - and lessen the frequency for retrieving new data. This gives your
70:13 - website a performance boost by reducing the server's load, which
70:17 - improves the user's experience. Let's look at how to set
70:21 - TTL policies in w3 total cache.
70:25 - You can make some limited changes to the TTL by
70:29 - going to page cache, and then you scroll all the way down
70:33 - to advanced.
70:37 - Here's the advanced section. And then we can update
70:41 - the garbage collection interval, which is how frequently the expired
70:45 - cache data is removed. And then also the comment cookie lifetime.
70:49 - This is going to reduce the default TTL for comment cookies
70:53 - and it's going to reduce the number of authenticated user traffic.
70:57 - Let's talk about the HTTP cache control
71:01 - headers. So here are the different ones. There's
71:05 - cache control max age. The max age directive specifies the maximum
71:09 - number of times that a resource may be cast by a client or a
71:13 - proxy server. After expiring, a browser must refresh
71:17 - its version of the resource by sending another request to a server.
71:21 - Cache control max age 3600 means
71:25 - that the returned resource is valid for one hour after which the browser
71:29 - has to request a new version. Cache control no cache.
71:33 - The no cache directive tells a browser or a caching server not
71:37 - to use the cache version of a resource and to request a new version of the
71:41 - resource from the origin server. Cache control
71:45 - no store. The no store directive tells browsers to never store
71:49 - a copy of the resource and not to keep it in the cache.
71:53 - This setting is usually used for sensitive information like credit card numbers
71:57 - and ensures PCI compliance by not storing this type of data
72:01 - in the cache. Cache control public.
72:05 - The public response directive indicates that a resource can be cached
72:09 - by any cache. This directive is useful for resources
72:13 - that change infrequently and when the resource is intended for
72:17 - public consumption. Cache control private.
72:21 - The private response directive indicates that a resource is user-specific.
72:25 - It can still be cached but only on a client
72:29 - device. For example a web page response
72:33 - marked as private can be cached by a browser but not a
72:37 - content delivery network. Now let's see how to set
72:41 - HTTP cache control headers in W3 total cache.
72:45 - So to set up the cache control headers in W3 total cache
72:49 - you go to the browser cache performance
72:53 - browser cache and then we are going to determine
72:57 - what are the cache control policies will be for
73:01 - some different files. So I can scroll down
73:05 - to the CSS and JavaScript section
73:09 - and then we'll set the cache
73:13 - control header. Now we'll select the cache
73:17 - control policy and I'll just select this one
73:21 - cache with max age. And then you can do the same
73:25 - thing for HTML and XML. We can set the
73:29 - cache control header, choose the policy, and then
73:33 - for the media and other files we can set the cache control
73:37 - header and set the policy. And then you always
73:41 - want to make sure to save changes and purge caches.
73:45 - Cache Busting
73:49 - cache busting is a technique used to force a browser or caching service
73:53 - to retrieve a new version of a resource rather than using the
73:57 - cached version. One way to do this is by using query parameters
74:01 - such as a timestamp or a version number
74:05 - in the URL of the resource. For example, instead of requesting
74:09 - resource at the URL example dot com slash style dot CSS
74:13 - a cache busting URL would look like example dot com slash style dot CSS
74:17 - and then you get the version one two three four where V equals one two
74:21 - three four is the query parameter. This query parameter
74:25 - can be a timestamp or a version number and will be ignored
74:29 - by the server but it will force the browser or caching server to treat
74:33 - the request as a new request rather than using the cached version
74:37 - of the resource. This technique is often used for static resources
74:41 - like like styleship scripts or images that are intended
74:45 - to be cached but they may not be needed to be updated frequently.
74:49 - By appending a query parameter to the URL
74:53 - a new version of the resource will be retrieved each time the query parameter changes.
74:57 - This technique is commonly used to ensure that the client gets the
75:01 - latest version of the resources after they're updated on the
75:05 - server side. To enable cache busting in WCTurtle
75:09 - cache we'll go to the performance and
75:13 - the browser cache section and then
75:17 - we just have to go to prevent
75:21 - caching of objects after settings change.
75:25 - This will add a random string at the end of static asset
75:29 - URLs.
75:33 - Cache storage is a finite resource so every bit of storage performance
75:37 - matters. Caching at proxy servers is one of the ways to reduce the
75:41 - response time perceived by web users. You have to choose
75:45 - between ease of use versus complicated configurations
75:49 - versus your needs. You have to look at the CDN level edge caching
75:53 - the server nginx proxy cache, the WordPress
75:57 - plugins application level caching. What do you have now? What's your budget?
76:01 - CDNs can be expensive. Where's your audience
76:05 - in relation to your server? What do we want to guide the user to do?
76:09 - Cache replacement algorithms play a central role in reducing
76:13 - response times by selecting specific websites assets for caching
76:17 - so that a given performance metric is maximized. They do this by
76:21 - deciding which objects can stay and which objects should be evicted
76:25 - the next time the website is accessed. The different policies are
76:29 - least recently used. This replaces the cache line that has been in the cache
76:33 - longest with no references to it. Then first in first out
76:37 - replaces the cache line that has been in the cache longest.
76:41 - Least frequently used replaces the cache line that has experienced
76:45 - the fewest references or random. Pick a line at random from the candidate
76:49 - lines.
76:51 - Page caching refers to caching the content of a whole page
76:55 - on the server side. Later when the same page is requested again, its
76:59 - content will be served from the cache instead of regenerating it from scratch.
77:03 - A page from a WordPress website contains
77:07 - dynamic content. PHP scripts, JavaScript, and SQL queries.
77:11 - Executing this dynamic content is very resource heavy
77:15 - and takes a lot of time. Page caching allows for forming a
77:19 - part of the website into static HTML. With page
77:23 - cache enabled, website content displays faster for a visitor with less load
77:27 - on the server. It's one of the most efficient ways to improve your website performance.
77:33 - Object caching is the process that involves storing
77:37 - database queries to serve a specific piece of data on the
77:41 - subsequent server request. As a result, there will be fewer
77:45 - queries sent to the database and the result is your website will load much
77:49 - faster. WordPress object cache. The idea of
77:53 - object cache is that WordPress core themes and plugins may store some data
77:57 - that is frequently accessed and rarely changed in the
78:01 - object store. This is so these objects will not have to be retrieved and processed
78:05 - on each request. WP object cache
78:09 - is WordPress's class for caching data.
78:13 - And by default, the object cache is non-persistent. This means that data
78:17 - stored in the cache resides in memory only and only for
78:21 - the duration of the request. Cache data will not be stored
78:25 - persistently across page loads unless you install a persistent
78:29 - caching plugin. Ultimately, object caching will reduce
78:33 - the total number of database queries required for each page load.
78:37 - When the CPU does not have to rebuild this box of data, your response time
78:41 - will decrease.
78:45 - Once the server and database have been tuned for performance,
78:49 - the next step is to ensure the application is optimized for performance.
78:53 - This can be done by leveraging techniques designed to deliver
78:57 - assets much more efficiently or removing any unnecessary
79:01 - data from them resulting in faster transfers. The following
79:05 - are some of the most effective techniques you can use when it comes to optimizing
79:09 - your WordPress site for speed. But it's not an exhaustive
79:13 - list. When focusing on page website performance, there are some essential
79:17 - tasks you can complete to help you achieve the performance results
79:21 - you're looking for. These tasks include configuring caching,
79:25 - following best practices for elements that can introduce layout
79:29 - shifts, and adjusting your assets to ensure they are configured
79:33 - for the fastest possible delivery to your visitors.
79:37 - One, page caching. WordPress is a dynamic program
79:41 - by default. So the easiest way to speed things up is to create a static
79:45 - version of your website pages and use redirects to serve those
79:49 - cached files instead of calculating the result again with PHP and MySQL.
79:53 - This cache can be stored on the disk in the server's RAM
79:57 - or if you're using a CDN on a point of presence or edge server.
80:01 - If you're storing the page cache on the web server, then it's
80:05 - recommended to use disk enhanced storage. So the web server
80:09 - redirects can serve the cache prior to the request reaching
80:13 - PHP, essentially making the site load faster by using the
80:17 - static files instead of recreating them with queries and calculations.
80:21 - Storing page cache on a CDN at
80:25 - the edge is a practice known as full site delivery
80:29 - or acceleration, where the website is served by sending a
80:33 - cached version of the website from a geographic location near the visitor
80:37 - as opposed to the request reaching out to the origin server
80:41 - where the data lives. This removes
80:45 - location introduced latency
80:49 - from the equation, making websites much faster for all of
80:53 - your visitors to object caching with Redis. By default the
80:57 - object cache in WordPress is not persistent. This means that data stored
81:01 - in the cache resides in memory for the duration of the request and is often
81:05 - removed after the response is delivered. To store these cached objects
81:09 - for reuse, you can use a plugin that connects the WordPress
81:13 - cache to Redis, a RAM based service that is used for
81:17 - persistent object storage. W3 Total Cache will allow you to
81:21 - use object caching with Redis. Redis stores the data as keys in the
81:25 - web server's memory, which allows for retrieval of the data to happen much faster
81:29 - than the WordPress method, which caches those objects to the options
81:33 - table in the database by default. Three, leveraging common
81:37 - UX patterns. When adding elements such as fonts, carousels,
81:41 - banners to your website, you want to ensure that you are following best practices.
81:45 - These types of elements can have a negative impact on Core Web Vitals
81:49 - if not implemented correctly. A great example of this is not explicitly
81:53 - setting proper placeholders or dimensions for images, videos, iframes
81:57 - or other similar embedded content throughout your page. When the content
82:01 - is loaded, this can cause layout shift and Core Web Vitals has very
82:05 - specific metrics, as the moving page can create a bad user experience for
82:09 - your visitor. Learning custom fonts on your website is another example where things can
82:13 - go wrong. Adding them incorrectly can delay the text rendering or even cause
82:17 - layout shifts. Typically your browser would delay displaying text until the font
82:21 - is loaded, which can also impact your FCP or
82:25 - LCP. If the text does load prior to your web font
82:29 - and there are different sizes, layout shifts will occur and directly impact
82:33 - your CLS score. Four, minification. When developing a website,
82:37 - most programmers tend to use spacing and comments to make code readable for both
82:41 - themselves and others. Minification is a technique used to reduce
82:45 - load times on a website by removing unnecessary characters and comments from the
82:49 - code for faster delivery and rendering. This technique can be used
82:53 - on HTML, CSS, and JavaScript files and can dramatically
82:57 - improve your site's performance. To minify your assets with W3 Total
83:01 - Cache, you'll need to enable it in general settings. There's an automatic mode which attempts
83:05 - to handle the heavy lifting for you, but if you have issues with it, you'll need to
83:09 - enable manual mode and add the assets you wish to be minified yourself under
83:13 - the minify page. There is a help wizard for setting up
83:17 - minify, which you can use to specify the template to use when loading the asset.
83:21 - Five,
83:25 - concatenation. The term concatenation refers to the action of linking
83:29 - things together in a series. In the context of a website performance,
83:33 - this means combining multiple CSS and JavaScript files into a few files
83:37 - to deliver the assets the browser needs faster with less requests.
83:41 - In W3 Total Cache, concatenating files is an option
83:45 - in general settings under minify. Checking the box will allow you to combine
83:49 - the asset files into one of three different files in the DOM.
83:53 - One in the head, one in the body, or one at the footer before
83:57 - closing the document. Six, eliminate render blocking resources.
84:01 - Render blocking resources is essentially coding your website files,
84:05 - usually CSS and JavaScript, that prevents a webpage from loading quickly.
84:09 - To ensure your site loads as efficiently as possible, you can specify
84:13 - attributes that tell the browser how to download the code in relation to the other
84:17 - site assets. When concatenating and minifying files
84:21 - using W3 Total Cache, you also have the option of embedding them before
84:25 - the the close of the document's head tag, or after the body tag.
84:29 - To improve performance, you have the option of setting rel attributes
84:33 - for the assets such as async or defer, which will tell the browser
84:37 - when and how to load the file. The minify wizard in Total Cache
84:41 - will allow you to specify which JS and CSS files load by template,
84:45 - allowing you to have to have fine tune control over which assets load
84:49 - when and where. Seven, preconnect and prefetch
84:53 - DNS hints. If your site is using multiple third party scripts, the
84:57 - location those scripts are hosted on will be considered a cross
85:01 - origin domain. That third party domain will need to be resolved to an IP
85:05 - address for the browser to download the file and complete the request. The time it
85:09 - takes for this DNS resolution to take place can introduce latency
85:13 - into the page load. And using preconnect and prefetch will instruct the browser to
85:17 - handle this prior to fetching the asset. This can help remove the latency
85:21 - introduced by resolving a large number of DNS requests for assets in the background.
85:25 - Using DNS prefetch and preconnect
85:29 - links will help your page load faster by performing these operations
85:33 - for later use. The DNS prefetch will do a DNS
85:37 - lookup while preconnect will establish the connection to the server.
85:41 - This connection established will also include a TLS handshake
85:45 - if served over HTTPS. The preconnect hint
85:49 - should be used sparingly and only for the most critical assets being used in the viewport
85:53 - during the initial page load. For non-critical assets, using
85:57 - only the DNS prefetch hint is recommended.
86:01 - Eight, image optimization. Image optimization refers to
86:05 - the practice of a website delivering the highest quality image with the right format
86:09 - with the right format, resolution, and dimensions for the
86:13 - device and viewport accessing them. This is done with the
86:17 - intent of keeping the file size as small as possible. There are several layers
86:21 - when dealing with optimizing your images, including removing metadata,
86:25 - converting to a different format, resizing, and lazy loading. One of the ways to
86:29 - reduce an image's file size is to remove any metadata attached to the file.
86:33 - This static can include information about the camera used to take the picture,
86:37 - GPS coordinates, the file's owners, comments, a thumbnail, and more.
86:41 - There are several types of metadata that can be added to the images
86:45 - including EXIF, IPTC, XMP.
86:49 - Removing this data will help to decrease the file size of the image.
86:53 - An added benefit is that removing metadata keeps these details from being
86:57 - publicly shared. WebP is a compression format
87:01 - for images developed by Google. When optimizing your images
87:05 - for speed, using WebP is the recommended format for websites.
87:09 - Most modern browsers now support the WebP image format. There are many WordPress
87:13 - plugins that offer this type of image conversion and most even assist with
87:17 - redirects to automate the process and a fallback option in case the browser
87:21 - does not support the WebP format. W3 Total Cache has a service for
87:25 - conversion of images and redirects under media library when
87:29 - image service extension is activated. Dynamic image resizing.
87:33 - When different devices are used to access your webpage, the image size
87:37 - needed will vary depending on the visitor's viewport. Dynamic image sizes
87:41 - can be used to make each of these devices load the image with a size
87:45 - tailored specifically to the viewport where the site is being rendered.
87:49 - A great example of this would be the hero image on your website. While a desktop would
87:53 - likely need the full size version of the image, the
87:57 - narrow viewport of a mobile device may only need an image that is 20%
88:01 - of that size. Providing the browser with the smaller size would reduce
88:05 - the time it needs to download the file and display it. There are many WordPress
88:09 - plugins and CDN providers that offer dynamic resizing for images.
88:13 - The solution you choose could be based on your audience. If your visitors
88:17 - are mostly local and your traffic is not high volume, a CDN's cost
88:21 - for this service may outweigh the benefits to you, so using a WordPress plugin may be
88:25 - your best option. 9 Lazy loading images and other
88:29 - embeds. Lazy loading is the practice of identifying non-critical
88:33 - assets and ensuring they only load later as needed to render
88:37 - the page in the browser. In the context of images, lazy loading is usually
88:41 - based on a user interaction such as scrolling, and loads
88:45 - images needed as the user gets near them. Lazy loading allows the first render
88:49 - to happen faster, as it instructs the browser to only load the critical
88:53 - resources needed to display what is being rendered in the viewport.
88:57 - Then, as you scroll, the application can detect when resources are
89:01 - needed and initialize the download. W3TrollCache offers lazy
89:05 - loading for images. Finally, using image facades for interactive
89:09 - elements. One of the biggest issues authors run across is having
89:13 - multiple video embeds from providers such as YouTube or Vimeo.
89:17 - Loading these videos will force your site to do DNS lookups,
89:21 - make connections to these third-party servers in the background, and download
89:25 - the elements needed to render the content. Providing an image that is
89:29 - stirred from your site's domain as an interaction point to trigger loading these types
89:33 - of content embeds can save you precious time rendering your webpage.
89:37 - It also saves a user from downloading JavaScript and CSS for an
89:41 - element they are not going to use, as the video does not render unless the user
89:45 - specifically clicks on the image anchor link to trigger it. This is also
89:49 - true for other interactive elements such as chat embeds or other interactive elements
89:53 - that are not hosted on your server and are being served to your visitor
89:57 - from a remote service.
90:01 - Okay, now that we've done some optimization
90:05 - to our WordPress page, let's enter the WordPress URL in the
90:09 - page speed insight and analyze it again.
90:13 - And we can
90:17 - see the numbers are better. Our performance is up
90:21 - and our performance is up on mobile
90:25 - and our performance is up on desktop. This was a basic
90:29 - overview for configuring your performance. And there are additional
90:33 - ways to drill down into your configuration when aiming for higher scores.
90:37 - A great example of this is using custom page templates for your most visited
90:41 - and important landing pages and using the minify help wizard to
90:45 - only load the critical CSS and JavaScript assets on those pages
90:49 - if they're needed. Some plugins like contact forms can load their resources
90:53 - on all pages, even if there's not a contact form embedded.
90:57 - You've reached the end of the course, you've learned about key metrics important to
91:01 - website performance, and you've learned a bunch of things you can do to
91:05 - optimize the performance of your website. Thanks for watching.