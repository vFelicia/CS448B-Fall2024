00:03 - okay so as you've probably guessed this
00:05 - is a talk about cryptography
00:07 - um i warn you up front it's quite theory
00:10 - heavy um not a great deal of php code
00:14 - and i am aware it is 4pm on friday so
00:18 - please try and stay in the room
00:21 - um so
00:23 - sort of introduction um
00:25 - what what what is it that we're talking
00:26 - about when we talk about cryptography
00:28 - so
00:29 - modern cryptography covers sort of three
00:32 - quite important areas the first one is
00:34 - probably the one that everyone sort of
00:35 - thinks of first is message privacy
00:38 - uh that means ensuring that any
00:40 - communications between two parties can
00:42 - only be read by the intended recipient
00:45 - and the sender
00:47 - um another another
00:49 - sort of facet to modern cryptography is
00:52 - being able to verify a message that's
00:54 - ensuring that a message that you've
00:56 - received
00:57 - is is the message that was actually sent
00:59 - by the person that that sent it and it's
01:01 - not been tampered with
01:03 - between you and the sender
01:05 - and and well the final sort of
01:07 - main areas that it deals with is
01:09 - identity verification
01:11 - so ensuring that
01:13 - the message that you've received did
01:14 - actually come from the person who claims
01:16 - to have sent it
01:17 - and it's not a fake message that you've
01:18 - you've received from someone who's
01:20 - trying to play a better joke on you
01:22 - um
01:23 - so so that's the third third area
01:26 - now
01:27 - if you've been to any other talks
01:29 - maybe at this conference or another one
01:31 - um on application security
01:33 - you mostly talk this i think this is
01:35 - from last year or two years ago
01:37 - um
01:39 - it looks a bit like this
01:40 - cryptography is
01:42 - really quite a hard thing to to get
01:44 - right
01:45 - especially if you start diving into
01:46 - designing your own algorithms and things
01:48 - like that
01:49 - um and so the the main purpose of this
01:51 - talk is to take a brief journey through
01:53 - the evolution of cryptography right from
01:55 - the very very beginning all the way up
01:57 - to the algorithms that we're using today
01:59 - um and try and give you a bit of an
02:00 - appreciation of quite why it's so hard
02:02 - and and why it's
02:04 - important to get it right
02:05 - um so i'm gonna start with some historic
02:07 - ciphers
02:08 - um which you can actually do on pen and
02:10 - paper if you if you want to
02:12 - um and then i'm gonna move on to some of
02:13 - the inner workings of of things like as
02:15 - and rsa crypto systems which
02:18 - are in use today
02:20 - um so first on to the historic ciphers
02:24 - the the first one to take a look at
02:25 - you've probably all heard of this one
02:27 - the caesar shift it's probably about the
02:29 - simplest cipher you could you could
02:31 - think up
02:32 - um and
02:34 - the basic idea is what you take a
02:35 - message with some words and in order to
02:38 - encrypt it you shift
02:39 - characters in the message up or down the
02:41 - alphabet by a fixed amount
02:43 - that
02:44 - looks a bit like this
02:46 - um and you can see we've got like an
02:47 - alphabet at the top
02:48 - and then in order to apply this user
02:50 - shift transformation encryption on on a
02:52 - message
02:54 - we sort of shift each letter so an a
02:55 - becomes a d
02:57 - um and then so on so forth
03:00 - um
03:02 - it's not going to be a very short talk
03:04 - if this was the state of the art modern
03:06 - cryptography
03:07 - um so so what's actually wrong with this
03:10 - cipher why why should you not use it
03:12 - um well turns out that for forgiving
03:15 - alphabet there's a very very small
03:17 - number of possible keys
03:19 - obviously you've only got 26 letters in
03:21 - the english alphabet
03:22 - um and that gives you 25 possible
03:24 - different shifts that you can use to
03:26 - encode a message using the scissor shift
03:29 - um obviously if you use a 26 when it
03:31 - just encodes it back to itself which is
03:33 - very useful either um even if you were
03:35 - to use like binary ascii and apply see
03:38 - the shift you're still only looking at
03:39 - 255 different possible shifts
03:43 - um that would mean that any anyone
03:44 - wanted to read a message that you've
03:46 - sent that you've you've encoded you're
03:47 - going to see the shift
03:48 - could simply just
03:50 - run through write a little script try
03:52 - every different possible shift
03:54 - and see which which one made a message
03:56 - that made sense and it'd be really easy
03:58 - for them to to quickly run through and
04:00 - and decode your message
04:03 - this is quite important to us because it
04:04 - illustrates a really important aspect of
04:07 - a strong cipher it's the fact that it's
04:09 - got to have a large number of possible
04:11 - keys that's preventing any attacker from
04:14 - just iterating through them all to try
04:15 - and decode your message
04:18 - um so move on to maybe a another
04:21 - straightforward cipher
04:23 - sort of an evolution step up
04:25 - um is a substitution cipher
04:28 - now this this works in a sort of a
04:30 - similar way but instead of just moving
04:32 - letters up we randomly shuffle them
04:34 - around
04:35 - um so you just swap
04:36 - the letter a letter in your your plain
04:38 - text
04:39 - for a letter
04:40 - for a different random letter okay
04:43 - and this looks a bit like this so
04:46 - in this this one i've sort of picked a
04:48 - an encoding which
04:50 - changes a to a z
04:51 - a b to a
04:53 - n
04:54 - c to q et cetera and you do that's the
04:55 - entire alphabet
04:57 - um
04:58 - how does it hold up
05:00 - this one is actually significantly
05:02 - better than the see the shift our
05:04 - algorithm
05:05 - um using just english for your
05:07 - substitution and just letters
05:10 - there are
05:11 - four hundred
05:12 - and three septillion
05:14 - 291 sextillion 461 quintillion 126
05:19 - quadrillion 605 trillion 635 billion
05:23 - 584 million possible different keys it's
05:26 - quite a big number
05:28 - um
05:29 - so
05:30 - with such a large large number of keys
05:32 - you'd think that this is a really really
05:34 - quite strong cipher right
05:36 - why aren't we why aren't we using a
05:37 - substitution cipher to to store people's
05:39 - bank details
05:41 - well
05:42 - turns out the weakness of the
05:44 - substitution cipher doesn't actually
05:45 - come from from the low number of keys
05:48 - um
05:49 - its security is equivalent to about an
05:51 - 88-bit key
05:53 - so that's obviously not as strong as
05:54 - some of the modern ciphers that use 128
05:56 - or 256 bits
05:59 - but it's still pretty strong and it's
06:01 - only sort of just within our
06:03 - computational capabilities to to brute
06:05 - force a key of that size
06:08 - um instead the substitution cipher falls
06:11 - foul of probably the greatest nemesis of
06:14 - of cryptographic algorithms which is
06:16 - statistics
06:18 - okay
06:19 - due to the simplicity of the cipher
06:21 - it it fails to hide any underlying
06:23 - patterns in the in the data that you've
06:25 - encrypted with it
06:26 - which means that
06:29 - if you want to recover the the original
06:31 - plain text if you've got a message that
06:32 - someone's sent and you want to read it
06:35 - you need to just look for the patterns
06:37 - if the pattern's english text
06:40 - this is the graph of all the various
06:42 - letter frequencies in in the english
06:44 - language
06:45 - so what you can do
06:47 - is you can you can count up all the
06:49 - letters
06:50 - in a cipher text that you've you've
06:53 - sort of intercepted
06:54 - and you can plot them on a graph like
06:56 - this
06:57 - and then you can sort of take a bit of a
06:59 - guess and say well the letter that
07:01 - occurs most commonly that's probably the
07:03 - letter e okay because that's the most
07:04 - common letter in in the english language
07:08 - and once you've done that you can you
07:09 - can get maybe a few others there's a
07:11 - peak at sort of like around s and t and
07:13 - and some of the other vowels a and o and
07:16 - you can sort of start to decipher bits
07:18 - and once you've got little bits you can
07:19 - maybe guess at words and say well that
07:21 - looks like left the word v which is one
07:22 - of the most common words that gives you
07:24 - a couple more letters and you can start
07:25 - decoding it and bit by bit you can sort
07:28 - of piece together the the full text of
07:30 - the message
07:31 - it takes a little bit of work but you
07:33 - can automate it with a script quite
07:34 - easily and and
07:36 - you can decode this on paper even
07:39 - so
07:40 - it's not really very strong
07:45 - so move on to
07:47 - obviously the the substitution cycle is
07:49 - quite an old cipher and
07:51 - during some like the 1500s 1600s people
07:55 - sought to to improve upon this because
07:57 - they they sort of realized that this
07:59 - this wasn't hiding the patterns quite so
08:00 - well
08:02 - and they came up with this cypher called
08:04 - the veganeer cipher
08:06 - now
08:07 - this is
08:08 - um one of a group of ciphers known as
08:11 - polyalphabetic ciphers
08:14 - it's these are so called this because
08:15 - instead of just using one possible
08:17 - encoding for each each letter in your
08:19 - your plain text
08:21 - it it uses several different encodings
08:23 - that helps it better disguise some of
08:25 - the the underlying patterns in the in
08:28 - the plain text
08:30 - how this works for the for the cipher
08:33 - is in order to to encode a message you
08:35 - need to first of all pick a key in this
08:37 - simple example here i've picked the key
08:39 - t
08:40 - probably not a good idea to use that as
08:42 - your your actual key but it works quite
08:44 - nicely here for an example
08:46 - and and what we do
08:48 - is using the um
08:50 - the letters here we
08:52 - set a to be equal to the first letter of
08:54 - the key and we get c the shift for that
08:58 - we do the same for e and the same for y
09:01 - and then
09:02 - we've got several different shifts that
09:04 - we use one after the other
09:06 - that looks a little bit like this so
09:08 - we've got a message that we want to hide
09:10 - that's pretty pretty secret message you
09:12 - probably don't want people people
09:13 - knowing that you're about to blow some
09:14 - up
09:15 - um
09:17 - you take the key
09:18 - and you encode the first letter of your
09:19 - message using the first seizure shift
09:21 - represented by the k
09:24 - alph letter the second one with e next
09:27 - one with y once you're on out of letters
09:29 - in your key you repeat it
09:31 - um and it looks like that so we we
09:33 - continue
09:35 - use it reusing this key and we get out
09:37 - the ciphertext at the bottom
09:39 - so
09:40 - anyone want to guess is this cypher
09:41 - secure
09:43 - nope
09:44 - absolutely not
09:46 - now it did take a while longer to break
09:49 - it um and it was credited to
09:52 - charles babbage who was quite quite no
09:54 - well-known historic figure um however it
09:57 - wasn't until 1985 that this was actually
09:59 - recognized because it was he he did it
10:01 - and the british government kind of kept
10:02 - it a bit secret because they didn't want
10:04 - anyone to know that they'd broken it
10:06 - um
10:07 - so until then um someone else frederick
10:09 - kaziki had been credited with the
10:11 - discovery he discovered it a bit later
10:13 - and it's him that the techniques
10:14 - actually named after
10:16 - unlike the simple substitution cipher
10:18 - you can't actually use frequency
10:20 - analysis if you've got a ciphertext
10:21 - encoder with this
10:23 - um and if if you were to do frequency
10:25 - analysis you'd probably see something
10:26 - with a fairly flat graph
10:28 - so all the letters would be providing
10:30 - the keys long enough
10:31 - you'll you'll find that the letters
10:32 - frequencies are fairly similar to each
10:34 - other and there's nothing that you can
10:35 - sort of pick out fairly easily
10:37 - however
10:40 - despite the fact you can't do frequency
10:41 - analysis because they're multiple
10:43 - encodings
10:44 - what you can do is you can start looking
10:46 - for repeated sequences of letters
10:49 - in the cipher text
10:50 - now
10:51 - what these repeated sequences sort of
10:53 - tell you is possibly
10:54 - that's where the key has repeated in the
10:57 - in the cipher text
11:00 - and so you can count the distance
11:02 - between these repetitions
11:04 - um and you'll sort of notice that that's
11:07 - corresponding to the same word being
11:08 - encoded and being being 12 letters apart
11:11 - so this suggests that learnt by key is a
11:14 - multiple of 12. or sorry 12 is a
11:16 - multiple of our key length so
11:19 - the keyword that possibly been used to
11:21 - encode this text could be 2 3 4 6 or
11:24 - even 12 characters long
11:27 - and then that absolutely helped us to
11:29 - narrow down what this the the key that
11:30 - was used to encode it might be
11:32 - so what you can then do
11:34 - is
11:35 - i mean i i'm cheating a bit because i
11:36 - know how long that is
11:38 - um i can take a guess that maybe the key
11:39 - is three letters long
11:41 - and i split the message into three
11:43 - groups
11:44 - taking the first letter the fourth
11:46 - letter etc into the first group
11:48 - the second letter fifth letter etcetera
11:50 - into the second group and the third
11:51 - letter and so on into the third group
11:54 - you can then perform frequency analysis
11:57 - on those
11:58 - those subgroups and it should produce a
12:00 - graph that looks similar to the one a
12:02 - few slides back
12:04 - once you've done that you can sort of
12:05 - take take the graph that you're looking
12:07 - at try and line up the largest letter
12:10 - with e
12:11 - and then that sort of helps you to
12:13 - to work out what the the keyword is at
12:15 - that position
12:17 - once you've actually done that
12:19 - you'll be able to recover the key and
12:20 - decode the message
12:23 - okay
12:24 - now
12:25 - um when i first get this talk i i put
12:27 - together this little cypher challenge
12:29 - a little bit more difficult in the
12:30 - beginning cipher but very very similar
12:32 - process so if anybody fancy's having a
12:34 - go at breaking one of these themselves
12:36 - um there's a link there
12:38 - i've got it at the end of this end of
12:39 - the talk so i'll put it back up if you
12:41 - don't manage to copy it down right now
12:45 - let's move on to a different cipher this
12:47 - one probably everyone in the room i
12:49 - would hope has heard of
12:51 - enigma
12:53 - it was about another hundred years after
12:55 - the veneer cipher that
12:57 - went by before
12:59 - the um
13:00 - the enigma cipher came around
13:02 - um world war ii saw several attempts to
13:05 - mechanize cryptography so move it from
13:08 - algorithms that you could perform on pen
13:09 - and paper to actually using machines
13:12 - to perform cryptographic operations
13:15 - obviously the most famous attempt was
13:16 - the germans enigma machine
13:18 - although during the war all the major
13:21 - powers the americans and the british
13:23 - were all using machines that worked in a
13:25 - fairly similar way
13:27 - um
13:28 - to to encode their
13:29 - their text i mean the americans and the
13:31 - british one was a little bit more secure
13:32 - than enigma um but same same sort of
13:35 - underlying principles
13:38 - so an enemy machine looked a bit like
13:40 - this
13:42 - made up of four parts a keyboard
13:46 - which
13:46 - was for sort of typing your message in
13:48 - you have a typist to type in
13:50 - um a set of rotors the back
13:54 - um
13:55 - these act each of these acted as their
13:56 - own substitution cipher
13:58 - um there were
14:00 - commonly three rotors in a machine but
14:02 - some of the machines featured up to as
14:04 - many as eight
14:05 - of these rotors that could be
14:07 - interchanged
14:08 - um the military machines that the german
14:10 - used
14:12 - had five different rotors which they
14:14 - could use in any any combination so they
14:15 - could use like voters one two three one
14:17 - day and
14:19 - three four five the next day
14:20 - um
14:22 - and later on throughout the war they
14:24 - expanded this to to a set with a total
14:26 - of eight rotors which provided a little
14:28 - bit more security
14:30 - and the final component this at the
14:32 - front here was a plug board
14:35 - now this switched around pairs of
14:37 - letters
14:38 - um with with wires
14:41 - and you could use up to 13 different
14:42 - swaps um but only usually about 10 of
14:45 - them were used this actually was one of
14:47 - the features that oops
14:49 - was uh gave the machine quite a lot of
14:52 - security was the ability to flip these
14:53 - letters um that's where quite a lot of
14:56 - security came from
14:58 - so this is sort of how it looks like
15:00 - inside it's a electrical machine
15:04 - and so when
15:06 - a typist presses a key on the on the
15:08 - front of an enigma machine
15:09 - an electric current completes the
15:11 - circuit which goes
15:12 - through the plug board
15:14 - through each one of the rotors and gets
15:16 - sort of like mangled up then the back of
15:18 - the machine there's a reflector which is
15:19 - literally just a load of wires that
15:21 - reconnect the
15:22 - the circuit
15:24 - back through each of the three rotors
15:26 - back through the plug board and finally
15:29 - it illuminates a lamp on the on the top
15:31 - of the top of the machine
15:33 - then the the um
15:35 - the radio operator would send that
15:36 - letter and then
15:39 - all the rotors would move around
15:41 - and when you press the next time it took
15:43 - a different path through the machine
15:45 - and came up with a different letter
15:48 - um obviously it stepped
15:50 - the first rotor one at a time and once
15:52 - it had gone all the way around then
15:53 - that's stepped over the next one once
15:55 - that had gone all the way around set the
15:56 - next one and so on and so forth that
15:58 - meant that each letter could be encoded
15:59 - in
16:00 - a vast different variety of different
16:02 - ways each time you use the same letter
16:07 - by changing the mappings this way it
16:09 - meant that the mapping of like the plain
16:11 - text and ciphertext was constantly
16:12 - changing um and it it makes it really
16:15 - difficult to do any sort of like
16:16 - frequency analysis or anything like the
16:18 - letters and and sort of had the um
16:20 - the the crips analysis at bletchley park
16:22 - stumped for quite a while on on how to
16:24 - actually
16:25 - analyze these these messages
16:28 - obviously the enigma is quite famous but
16:30 - one of the things it's famous for is for
16:33 - having been broken
16:35 - um
16:36 - a team of british cryptographers um
16:40 - at bletchley park led by alan shearing
16:42 - who's also quite a famous guy i've heard
16:45 - um
16:46 - so designed
16:47 - machines to help them break the
16:49 - mechanical ciphers
16:51 - um
16:52 - the breakthroughs that the team made
16:54 - weren't particularly based on weaknesses
16:56 - in the cipher and then
16:58 - the algorithm itself
17:00 - but mostly on sort of operational errors
17:02 - made by the germans
17:05 - so examples
17:06 - of those errors included choosing bad
17:08 - keys like aaa
17:10 - as a sort of initial setting for the
17:11 - rotors this made it fairly trivial to
17:14 - decode
17:16 - and having predictable message
17:18 - structures
17:19 - so for example the first message most of
17:21 - the german military units would send in
17:23 - the morning would be a weather report
17:25 - which would contain the german word for
17:26 - weather
17:28 - and
17:30 - this was a the weakness one of the
17:31 - weaknesses that um the device designed
17:34 - by alan turing sort of seized upon
17:36 - and it sort of
17:37 - looked for um
17:40 - the word wetter in in the decrypted text
17:43 - and then sort of like stepped through
17:45 - all the possible different
17:47 - combinations of rotors and and clipboard
17:50 - settings to try and find this
17:52 - um and they had
17:54 - uh full like rooms full of these
17:57 - machines that alan shearing and his team
17:59 - designed that whenever they got a
18:00 - message in first thing in the morning
18:02 - one of the machine operators would rush
18:03 - in put the message into the machine it
18:05 - were away for a couple of hours it'd
18:07 - find out the key
18:08 - and once because the germans only
18:09 - changed the keys once a day once they'd
18:11 - found the key for the day they could
18:12 - decrypt all the messages
18:14 - that the germans were sending
18:16 - for that day
18:18 - and obviously that did actually give the
18:20 - the british and their allies quite a big
18:22 - advantage in the war because they knew
18:23 - exactly what the germans were up to
18:25 - um so obviously this break was quite a
18:29 - a big thing
18:32 - so we're going to leave the um the
18:33 - historic ciphers there
18:36 - now um we've gone sort of through all
18:37 - the way up to sort of
18:39 - the beginning of the last century with
18:41 - the halfway through with those machines
18:44 - and we're going to take a look at some
18:45 - of the algorithms that are actually
18:46 - useful to us today
18:48 - for for storing data securely
18:50 - um
18:52 - modern-day cryptography
18:53 - as i said into the beginning can be
18:55 - broken down into
18:57 - several different problems that we need
18:58 - to be able to solve to communicate
18:59 - securely
19:01 - um the first one of those is is
19:03 - confidentiality
19:05 - we need to ensure that people other than
19:07 - the intended recipient can't read our
19:08 - messages
19:10 - um there's
19:11 - a wide variety of different algorithms
19:14 - which people have built for for doing
19:16 - this
19:17 - um but the the probably one you want to
19:19 - be using at these at the moment is as
19:21 - the advanced encryption standard
19:24 - most of these algorithms
19:26 - are symmetric
19:28 - that is
19:29 - they use the same key for both
19:30 - encryption and decryption
19:33 - there's two main classes within that
19:35 - stream ciphers which work on continuous
19:37 - streams of data and block ciphers which
19:40 - break the message up in separate blocks
19:41 - and encrypt each separately i'm going to
19:43 - show an example of each in a few minutes
19:47 - another thing that we need to solve is
19:49 - is key exchange
19:50 - obviously if i want to communicate with
19:52 - you
19:53 - securely we both need to have a key that
19:55 - we can we can use to encrypt messages
19:57 - um
19:58 - so
20:00 - one of the one of the ways that we um we
20:02 - do this is with
20:03 - asymmetric
20:04 - ciphers now these ciphers that use a
20:07 - different key for encrypting as they do
20:09 - for decrypting
20:10 - and then we can sort of use this
20:13 - you can give me the encryption key
20:15 - fairly safely i can use that to encrypt
20:17 - a message to you but i can't
20:19 - subsequently decrypt any messages that
20:21 - are encrypted with that key only you can
20:22 - with the the other part of that key
20:25 - um so that's quite an important
20:27 - important thing that we can do
20:29 - um another thing that we can do is
20:31 - verify the identity of a sender
20:34 - again it it works in a similar way to
20:36 - key exchange
20:37 - you can um sign a message using a a
20:40 - private key that you keep with keep to
20:42 - secret and you can publish a public key
20:44 - and you can say this is this is my
20:45 - public key
20:46 - and anyone when they receive a message
20:48 - from you can use that public key to
20:49 - verify that it was signed with your
20:51 - private key
20:53 - um it's known as a message signature and
20:55 - again i'm going to go into detail on
20:57 - this
20:57 - later on this section
21:00 - another another thing we need to do
21:02 - is authenticate a message make sure that
21:04 - it hasn't been tampered with
21:06 - um for this we use cryptographic hash
21:08 - functions generally such as sha256
21:12 - so when you can receive a message you
21:13 - can compute the message hash and compare
21:16 - it to one that's maybe been sent along
21:18 - with a message and and signed with the
21:20 - the private key of the sender if it
21:22 - doesn't match you can reject the message
21:23 - and say someone's messed with this
21:24 - tampered with it sending me again or or
21:27 - whatever
21:29 - obviously you need to combine that hash
21:30 - with a secret key of some form otherwise
21:32 - if someone tampered with it they could
21:33 - just recompute the hash
21:36 - um
21:38 - and a final thing that quite a lot of
21:39 - people don't maybe realize is a part of
21:41 - modern cryptography is the ability to
21:43 - generate random numbers
21:45 - so a large number of secure protocols
21:47 - rely on being able to generate random
21:49 - numbers
21:50 - that are actually random
21:52 - one example is with using a public key
21:55 - cryptography system you might generate a
21:57 - random key to use the symmetric cipher
21:59 - and encrypt that with the with the um
22:02 - public and private keys and send the
22:04 - whole lot along
22:06 - now if someone can predict the number
22:07 - that came out you're running a number
22:08 - generator they can guess what that key
22:10 - was and they can just forget about
22:12 - trying to break the algorithm they can
22:13 - just decrypt the message
22:15 - so
22:16 - being able to generate secure random
22:18 - numbers is really important
22:21 - okay so
22:22 - symmetric ciphers
22:29 - as i sort of previously mentioned
22:30 - there's two classes of symmetric cipher
22:33 - there's block and stream ciphers
22:36 - um all of these algorithms are really
22:38 - only useful for dealing with message
22:40 - confidentiality
22:42 - there's no no symmetrical algorithm that
22:43 - you can really use for key exchange at
22:45 - the moment
22:46 - and it still doesn't really solve that
22:48 - problem
22:49 - so i'm going to start by looking at
22:51 - stream ciphers
22:53 - a stream cipher works is
22:56 - it produces a constant stream of sort of
22:59 - pseudo-random output bytes
23:02 - um and you use the secret key that you
23:04 - you you're using to encrypt the message
23:06 - with as a sort of a seed to this
23:08 - generator
23:10 - um the produce bytes from the the
23:12 - generator then exod with your plain text
23:15 - to produce the cipher text and then you
23:16 - can send that along and the person on
23:18 - the other end
23:20 - can
23:20 - produce the same random pseudo-random
23:23 - stream of bytes and use that xord with
23:25 - the plain text do with the ciphertext to
23:27 - recover the plain text
23:29 - it's actually fairly similar to how
23:31 - enigma works in a way
23:34 - it's sort of stream cycle sort of
23:35 - evolved from the enigma machine
23:39 - there are several stream ciphers that we
23:41 - currently use today
23:43 - um probably the most well known is rc4
23:46 - which is used in wp and
23:48 - ssl um but i've chosen a slightly
23:51 - different one
23:53 - which is called a5 one
23:55 - now you've probably never heard of this
23:56 - algorithm but i can almost guarantee
23:58 - that everything i want to do in this
24:00 - room is using it
24:02 - because it's used to protect voice and
24:03 - sms data in mobile phones
24:06 - um
24:07 - this algorithm has actually been broken
24:08 - it's it's no longer considered secure um
24:11 - it was state of the art a few decades
24:13 - ago and now it's it's quite not
24:16 - um but it's an interesting one to look
24:17 - at as a stream side for example
24:21 - um how it sort of works is a bit like
24:23 - this diagram here
24:25 - so
24:27 - the um it's got a big state machine in
24:30 - the middle
24:31 - [Music]
24:32 - and it consists of three registers
24:35 - uh this
24:36 - with each with each of a different size
24:38 - and
24:40 - what it does is each time you want a new
24:43 - bit out of your your random number
24:45 - generator it
24:48 - takes the the top bit out of each of
24:50 - these registers exhaust them together
24:52 - and that's the the output bit that's
24:54 - produced
24:56 - um once it's done that
24:58 - each of these registers is shifted
25:01 - to the to the left
25:02 - and depending on this byte here
25:06 - so
25:07 - it's got these uh what what these called
25:09 - clocking bits
25:10 - and so it compares
25:12 - each one of the bits in the register
25:14 - and says okay
25:16 - we'll take the majority so if they're
25:17 - all zeros the majority is zero and any
25:20 - that match that majority bit are are
25:22 - clocked any that don't match or left so
25:25 - if you've got sort of say one zero one
25:28 - the the majority bit there is is one so
25:30 - any registers that match that the first
25:32 - and the third
25:33 - get clocked and move to the left one
25:36 - in order to generate a new byte onto the
25:38 - back here um it takes the bits that are
25:40 - called in blue exhales them together and
25:42 - produces a
25:44 - a new bit on the end
25:47 - um
25:48 - so take a look at more detail
25:50 - how it actually works when it clocks
25:53 - um this is the uppermost register from
25:55 - the previous diagram you can see it's
25:57 - got some some sort of
25:58 - numbers in there
26:00 - and we clock it once and everything
26:01 - shifts left
26:03 - x all these bits and put it back on the
26:05 - end
26:06 - next cycle we do the same thing xor it
26:09 - put it back on the end and this
26:10 - generates a a really long sequence of
26:12 - different bytes
26:13 - and obviously you've got three of these
26:15 - so you get quite a large
26:17 - sequence of random data coming out of it
26:20 - okay
26:22 - now um stream ciphers are
26:26 - quite useful but they do have a few
26:28 - things that you need to keep in mind
26:29 - when using them
26:31 - the first one is that keys must not be
26:33 - reused
26:34 - um because of the way that it combines
26:36 - the output of the cipher using xor
26:41 - it will always produce the same output
26:42 - bytes
26:43 - so if you
26:45 - produce if you encrypt two different
26:46 - messages with the same key
26:49 - somebody can actually use those two
26:50 - messages to start recovering parts of
26:52 - your output stream and therefore they
26:54 - can actually decrypt your your messages
26:58 - to guard against this a lot of string
27:00 - ciphers include
27:02 - what's known as an initialization vector
27:04 - or iv
27:05 - which is combined in some way with the
27:08 - with the secret key
27:10 - and then you sort of send that id along
27:13 - with your message as part of it and then
27:15 - someone uses the same algorithm to
27:16 - combine that key with your iv and then
27:18 - that makes sure you're always using a
27:20 - different key for each message
27:22 - um
27:23 - wpep is actually vulnerable because of
27:25 - this
27:27 - although they use an iv in the
27:29 - initialization of the
27:31 - rc4 algorithm the iv that they picked
27:34 - was too small
27:35 - which means that over some time if
27:37 - you're sending lots of wi-fi packets
27:38 - back and forth
27:40 - you'll eventually repeat not just the
27:42 - secret key but the the ivs will repeat
27:44 - that means that once once someone
27:45 - detects two messages using the same iv
27:48 - they can use those messages to
27:50 - decode the output stream
27:51 - and at that point they can they can sort
27:54 - of recover the the key for the network
27:56 - and connect your wi-fi network and sniff
27:58 - your traffic and things
27:59 - which is sort of why we've sort of
28:01 - phased out wp in in wi-fi these days
28:06 - um
28:07 - it's kind of easy for an attacker to
28:09 - modify a message
28:10 - so let's say you're downloading a html
28:12 - page for website and you're encoding it
28:15 - with um
28:16 - a stream cipher
28:18 - anyone who can sort of guess that maybe
28:20 - there's a javascript file in the header
28:22 - of that
28:23 - can actually compute a
28:25 - um
28:26 - an xor with what they think might be in
28:28 - the message and what they really want in
28:29 - the message and explore that into the
28:31 - cipher text
28:32 - and that will actually replace it in the
28:34 - cipher text and it'll decode to what
28:36 - they want it to rather than what was
28:37 - sent
28:40 - this means that when you're actually
28:41 - using the stream cipher you need to make
28:42 - sure you've got some sort of message
28:44 - authentication to prevent this tampering
28:46 - such as a
28:47 - message hash
28:51 - it's also
28:53 - it's not so much a security concern more
28:54 - of a practical one
28:56 - most stream ciphers require that you run
28:58 - them all the way through to the crypto
29:00 - message and you can't sort of
29:02 - arbitrarily seek into a stream cipher
29:05 - some of them have been designed to allow
29:06 - this but most do not
29:08 - um this means if you're say you've
29:11 - encrypted a huge 50 gig database backup
29:14 - using a stream cipher
29:15 - and
29:16 - you need to recover
29:18 - one table worth of data from that backup
29:21 - and you know that it's 20 gig away in
29:24 - you're still going to have to decrypt
29:25 - the first 20 gig to get to that table
29:27 - data
29:28 - um you can't just sort of seek into it
29:30 - and decrypt just the bit you need
29:33 - um so that's sort of something to be
29:35 - aware of
29:37 - uh next thing we look at uh
29:40 - not uh is the block cipher
29:43 - the key difference between a a block and
29:45 - a stream cipher
29:47 - is that um whereas the stream cipher
29:49 - produces
29:50 - basically pseudo random stream where you
29:52 - can use to encrypt a block cipher
29:55 - actually works on a block of your plain
29:56 - text directly and applies various
29:58 - different mathematical transformations
30:00 - to it
30:01 - now the the size of block works
30:04 - differently depending on the algorithm
30:06 - but it's usually much shorter than any
30:08 - message you might want to send
30:10 - um aes for example uses 128-bit blocks
30:14 - um older ciphers tend to use 64-bits
30:17 - um so that's that's obviously a lot
30:19 - shorter than any any message you're
30:20 - going to want to send so
30:23 - you need to break up your message into
30:24 - blocks and encrypt each one separately
30:27 - and that's where the name comes from a
30:28 - block cipher
30:31 - so obviously the probably most famous
30:33 - one you've heard of is as and that's
30:36 - kind of like the
30:37 - probably the one you'll be using for a
30:38 - lot of your day-to-day
30:40 - encryption needs
30:42 - um
30:43 - aes was a
30:45 - result of a cryptography competition to
30:47 - find a replacement for an order an order
30:50 - encryption standard the data encryption
30:52 - standard
30:53 - and it was eventually won by a slight
30:55 - variant of the ryan gel algorithm
30:57 - now you might know if you've been using
30:59 - the m-crypt extension that there are
31:01 - there is a different flavor of as that's
31:04 - just called rhine gel and if you use the
31:06 - wrong constants with encrypt you use
31:08 - that one instead
31:09 - which is not quite what you want
31:12 - a bit of a got you there fortunately
31:14 - it's been deprecated but if anyone's
31:16 - still using it something to look out for
31:19 - um so how aes works
31:21 - is
31:22 - it's got
31:24 - um
31:25 - so you start off with the message and
31:27 - you apply the aes algorithm to it
31:30 - um repeatedly
31:32 - for a few cycles um
31:34 - depending on the key length is depending
31:36 - on how many how many actual cycles you
31:38 - you run through of as
31:40 - um each round of an as consists of four
31:43 - distinct phases
31:45 - which is substitute bytes
31:48 - shift rows
31:49 - mixed columns and then it adds a portion
31:51 - of the
31:53 - of the secret key to the data and then
31:55 - it repeats the loop again
31:59 - so each one of those rounds is applied
32:02 - every time you you sort of loop through
32:03 - it
32:05 - look in a bit more detail the substitute
32:07 - bytes
32:08 - um it works on a block size of 128 bits
32:12 - and
32:13 - it's effectively got a
32:15 - substitution cipher with a fixed key
32:18 - um now
32:20 - the the key has actually been chosen to
32:22 - try and uh avoid a number of different
32:25 - algorithmic um and cryptographic
32:27 - techniques to provide defense against
32:29 - various
32:30 - various techniques that were used
32:32 - against the predecessor ds
32:34 - um so the the bits in the substitution
32:36 - table have been chosen specifically
32:39 - um and what happens basically is it just
32:41 - takes the the current byte in the state
32:44 - looks up
32:46 - um that byte in the substitution table
32:48 - and replaces that byte in your your
32:50 - current block with the byte from the
32:51 - substitution table
32:53 - um
32:55 - the next thing that happens is
32:57 - each each row in your in your sort of
32:59 - block is is shifted using a bit shift
33:02 - operation
33:03 - um and then you used to like rotate the
33:05 - first bite around
33:06 - at the end
33:07 - so so does that looks like that diagram
33:11 - uh the third step
33:13 - is it's a bit of a complicated um
33:15 - mathematical operation
33:17 - uh but it actually does a multiplication
33:20 - over each column
33:21 - um and it it does like to sort of like
33:23 - mix up the the data in a different way
33:26 - um
33:27 - for the final round of the cipher this
33:28 - steps actually skipped over
33:30 - so it doesn't um doesn't occur in the
33:32 - last round but it's every round other
33:34 - than that
33:35 - um and then finally it takes a
33:39 - bite from your key
33:40 - and exhales it with a byte in the block
33:43 - and then produces the final output
33:46 - um once you've gone through all those
33:48 - steps um a number of times i think it's
33:50 - 14 rounds for 128-bit key
33:53 - then you output a block of ciphertext
33:57 - um it's quite an efficient algorithm
33:58 - it's important in hardware and quite a
34:00 - lot of processes these days so it's very
34:02 - fast to compute
34:05 - and uh that's how it works
34:08 - now obviously with a block cipher you're
34:11 - going to want to encrypt more than 128
34:12 - bits at a time
34:14 - and so when we use a block cipher and a
34:17 - message that's longer than that we've
34:18 - got to split up into blocks
34:21 - however there are quite a lot of
34:22 - different ways in which you can
34:24 - utilize a block cipher
34:26 - and these are known as modes of
34:28 - operations
34:29 - so
34:30 - one
34:32 - mode is known as the electronic cookbook
34:35 - it's probably the one that you'd you'd
34:36 - sort of think up first
34:38 - is you literally encrypt a block of text
34:41 - and then the next one
34:42 - and the next one and just append them
34:44 - like that
34:45 - so you've got a plain text you've got a
34:47 - key you do your block cipher encryption
34:49 - and you get output block you do have
34:51 - next block next block and you just start
34:53 - pen them
34:54 - believe it or not this is a really bad
34:56 - mode which you shouldn't use
34:59 - although block cipher produces a really
35:01 - random output and it's really difficult
35:03 - to reverse that
35:05 - um any block
35:07 - any piece of plain text that's the same
35:10 - same 128 bits will come out as a
35:13 - ciphertext that's exactly the same
35:15 - this actually gives you the same
35:17 - problems as with a substitution cipher
35:19 - where someone can actually look at
35:20 - statistical patterns in your data
35:24 - obviously it's a bit more difficult but
35:27 - take a look at this penguin
35:28 - tux linux mascot
35:31 - um and that's tux encrypted using as in
35:35 - ecb mode
35:36 - you can quite clearly see that that tux
35:38 - is still there
35:40 - now if this was an image that maybe you
35:42 - you wanted not for people not to be able
35:43 - to see
35:44 - um have it having it like that probably
35:46 - wouldn't be your your desired
35:48 - um
35:50 - result
35:51 - so
35:52 - you should never really use ecb mode
35:54 - unless you just want to make cool pop
35:56 - art images like this that's that's
35:58 - legitimate use i guess
36:02 - so a bit of an improvement
36:04 - um the first sort of attempt to fix that
36:06 - sort of problem was called cipher block
36:09 - chaining
36:11 - how that sort of works is
36:14 - you take an initialization vector
36:15 - similar to um
36:17 - to a stream cipher and you feed that in
36:19 - for your first block
36:21 - and you export with your plain text pass
36:23 - it through a block cipher encryption
36:25 - and then you get your ciphertext
36:27 - for your next block you pass that
36:29 - ciphertext back in excel with the plain
36:31 - text and and pass it through and you do
36:33 - that all the way along this adds to sort
36:35 - of like a randomizer to your your plain
36:37 - text so even if you've got two blocks
36:38 - the same because this and this aren't
36:41 - going to be the same they're going to
36:42 - come out differently
36:45 - it's
36:46 - obviously a bit similar to a stream
36:47 - cipher in the fact that you need an
36:49 - initialization vector and you should not
36:51 - reuse those
36:53 - but
36:54 - that sort of half solves this
36:57 - the um the problems with ecb
37:00 - um
37:01 - another another mode
37:03 - that's being used is called ctr mode or
37:06 - counter mode this is quite a cool mode
37:10 - in the fact that it turns a block cipher
37:12 - into a stream cipher
37:14 - with a few advantages
37:16 - so
37:17 - it completely different from the
37:18 - previous two modes that we've looked at
37:20 - as we no longer directly encrypt our
37:23 - plain text
37:24 - what we do is we start off with a a
37:26 - nonce uh or an initialization vector
37:29 - again
37:30 - and we have a counter which we start
37:32 - zero zero zero zero
37:34 - and we encrypt that instead and explore
37:37 - it with our plain text which produces
37:39 - cipher text then for the next block you
37:41 - increment the counter encrypt that
37:43 - and explore it you keep on going until
37:45 - you've got enough
37:47 - bytes to encrypt your whole message now
37:50 - due to the random nature of the uh the
37:52 - output of a block cipher
37:54 - um it effectively turns this into a
37:56 - stream cipher
37:58 - now
37:59 - obviously
38:00 - with ctr mode you need to take the same
38:01 - precautions as with a stream cipher such
38:04 - as not reusing the um iv and things and
38:07 - ensuring that you've got a
38:09 - um
38:12 - sort of a message authentication to to
38:13 - make sure it's something tampered with
38:15 - um somewhere else that this gives you
38:17 - that stream cipher doesn't is you can
38:19 - actually seek into your encrypted text
38:22 - because if you want to get block 557 all
38:25 - you do is take your nonce increment the
38:27 - counter to 557
38:29 - pass it to the block cipher and you can
38:31 - decrypt
38:32 - into your
38:33 - into your encrypted data you can decrypt
38:35 - it and without having to decrypt
38:37 - everything up to that point
38:40 - um another mode which which sort of
38:43 - helps alleviate the issue that we had
38:46 - with um with ctr mode in the fact that
38:49 - it's a stream site without
38:50 - authentication is um glorious counter
38:53 - mode
38:54 - what this does is it combines
38:56 - the counter mode with um an
38:58 - authentication tag which helps verify
39:00 - that message hasn't been tampered with
39:02 - um how that works is
39:06 - first of all you've got here you've
39:07 - basically got the account you've got the
39:08 - counter mode going on up here as well
39:11 - but you also have
39:13 - a separate part of your key
39:15 - which is auth data here
39:17 - which goes to a multiplication function
39:19 - and then you start xoring it with each
39:21 - of your ciphertext bytes
39:23 - and you sort of chain on lots of
39:25 - different multiplications of your
39:26 - ciphertext and then finally
39:31 - add on the length of your
39:32 - your um your ciphertext and data
39:35 - and that produces you an authentication
39:38 - tag which when the person who you're
39:40 - sending the message to receives it
39:42 - they can verify that authentication tag
39:44 - before decrypting the message and make
39:45 - sure it hasn't been tampered with
39:48 - um that's sort of how that works
39:52 - so that's that's sort of covered off a
39:54 - lot of the symmetric ciphers um
39:57 - all those
39:58 - ciphers that we've looked at so far
39:59 - including even the historic ones use a
40:01 - single key for both encrypting and
40:03 - decrypting
40:05 - that leads to a really hard to solve
40:07 - problem which is key distribution
40:09 - imagine for a moment that you're an
40:11 - undercover agent alice
40:13 - is undercover um and in dpn mma
40:17 - operations
40:18 - and needs to get a secret message back
40:20 - to bob at hq
40:22 - to to send mission reports and and
40:24 - tell bob what the the
40:26 - evil overlord is up to
40:28 - um
40:30 - and they obviously need to do so without
40:32 - the
40:33 - the uh the agents of the enemy mallory
40:36 - and eve eavesdropping and modifying the
40:38 - messages
40:40 - um this is where the asymmetric ciphers
40:42 - actually comes in
40:43 - because they use different keys for
40:44 - encryption and decryption um we don't
40:46 - need to sort of pre-share keys so
40:49 - i can just keep on the encrypting
40:50 - message to you without having to worry
40:51 - about
40:53 - keeping my key secure and things like
40:54 - that
40:55 - and even if i send a message out and
40:57 - it's intercepted
40:58 - and the enemy capture it they won't be
41:00 - able to search my room and find the key
41:02 - that i use to encrypt it because it's a
41:04 - public key that can't decrypt again
41:07 - um so
41:10 - looking at public key cryptography um
41:14 - a quite a good good way of thinking
41:15 - about this is if you think about padlock
41:19 - so here's padlock okay
41:21 - now imagine that i i want to send a
41:23 - message to someone in the back of the
41:24 - room or they want to send one to me
41:26 - what i could do is i could give a metal
41:27 - box a nice nice sturdy metal box and i
41:30 - could write a bit of a message on a
41:31 - piece of paper
41:33 - and i could give them my padlock
41:35 - okay
41:36 - and they could they could attach this
41:37 - padlock to the box
41:39 - locking it
41:40 - and they could pass them a pass the box
41:42 - back from the back of the room past all
41:44 - you people who we don't really trust
41:46 - back to me and none of you unless you've
41:48 - got some bolt cutters and brute force
41:51 - are gonna be able to undo that padlock
41:53 - but as soon as it gets back to me i've
41:54 - got the i've got the private key i'm
41:56 - keeping over here i can unlock it
41:59 - and i can read the message
42:01 - that's kind of the same
42:02 - same idea that that public key
42:04 - cryptography uses
42:08 - well the first
42:09 - and
42:10 - oldest public key system is is rsa
42:14 - despite the huge amount of protein power
42:16 - improvements and things like that we've
42:17 - made since its invention
42:18 - um
42:19 - it's
42:20 - it's still quite a secure algorithm um
42:22 - it relies on a sort of mathematical
42:24 - problem
42:25 - which is quite easy to compute in one
42:28 - direction
42:29 - but it's really difficult to sort of
42:31 - reverse
42:33 - and how it sort of so if you've just set
42:36 - this mathematical problem it's really
42:37 - difficult to reverse but if you happen
42:39 - to know a secret that was used when
42:41 - constructing the problem it's really
42:43 - easy to reverse again
42:46 - we have actually come up with better
42:47 - public key algorithms since but only by
42:49 - the virtue of the fact they're actually
42:50 - more efficient to implement in code and
42:52 - they use less cpu cycles to run
42:55 - um they're not actually
42:57 - much greater in the level of security
42:58 - they provide
42:59 - it's just that you can use shorter keys
43:00 - with them
43:02 - so
43:03 - the mathematical problem that rsa is
43:05 - based on is
43:07 - exponential in modular arithmetic
43:11 - so the idea is that you can find three
43:13 - rather large numbers
43:15 - um
43:16 - e
43:17 - here d
43:19 - and
43:20 - a prime number n
43:22 - and such that when you
43:25 - take um e to
43:28 - take any number
43:29 - and raise it to the power of e
43:31 - and then raise it to the power of d
43:33 - it equals itself
43:35 - modulus
43:36 - your prime number n okay so it's sort of
43:39 - it's cyclic
43:41 - um now
43:43 - if you've got
43:44 - a message that's been encoded like this
43:47 - and you only have e
43:49 - it is really really difficult to figure
43:51 - out what d is mathematically
43:53 - however if you already know d
43:55 - you you can actually reverse it
43:57 - so you can make this number n and e
44:00 - publicly available and you can you can
44:01 - pose this mathematical problem to the
44:02 - world saving the knowledge that it's
44:05 - really really hard for them to solve it
44:08 - um and so in order to actually use this
44:11 - for crypto system
44:13 - what you can do is
44:15 - you've got my
44:16 - my uh public key which is enn and you
44:19 - can take the message that you want to
44:20 - send to me
44:21 - you can raise it to the power of e
44:23 - take its modulus by my prime number n
44:26 - and that becomes the cipher text you can
44:27 - send that to me
44:29 - say from the knowledge that
44:30 - only the person with d
44:33 - can
44:34 - do this
44:35 - mod multiplication here and reverse the
44:37 - process and turn it back into the plain
44:39 - text m
44:41 - um
44:42 - obviously a slight issue with this
44:44 - scheme is that the message m must be
44:47 - smaller than this this modulus to use um
44:51 - so
44:53 - usually what you will do with rsa and
44:55 - similar public key algorithms is that
44:57 - you'll generate a random string that you
44:59 - use for a symmetric cipher like aes
45:02 - and then you'll use rsa or
45:05 - another public key algorithm to encrypt
45:08 - just the key part of the the symmetric
45:11 - cipher and then you'll send the
45:12 - ciphertext from the symmetric cipher the
45:14 - encrypted key
45:16 - to your intended recipient they can then
45:18 - use their private key to recover the the
45:20 - random key and then they can decrypt a
45:22 - message it's a two-stage process
45:24 - um and
45:26 - and that sort of solves the key
45:27 - distribution problem
45:31 - another thing we need to solve is
45:33 - identification
45:35 - of um
45:36 - identity verification
45:38 - so
45:39 - although alice and bob can send messages
45:41 - to each other securely without eve being
45:43 - able to eavesdrop and recover those
45:46 - messages
45:47 - um
45:48 - how can they protect
45:50 - from the mischievous mallory who likes
45:52 - to tamper with messages and change them
45:56 - turns out you can actually use
45:58 - a similar thing with rsa
46:01 - um
46:02 - if i take
46:03 - a message
46:05 - say a hash of the ciphertext that i'm
46:07 - sending to you
46:08 - and i raise it to the power of my
46:10 - private key d
46:14 - i i can send that as a signature
46:16 - when bob back in the office
46:19 - receives that message
46:21 - he can raise it to the power of my
46:22 - public key
46:23 - and if it has been signed using my
46:25 - private key it will return back to the
46:27 - value of the hash he can then hash the
46:29 - message check it matches and then he
46:31 - knows that it was sent by alice
46:34 - obviously if it doesn't match
46:36 - then something's gone wrong and he knows
46:38 - that the message has been tampered with
46:39 - or didn't come from alice in the first
46:40 - place again in practice that that
46:43 - message must be short so the signature
46:45 - is usually a cryptographic hash of the
46:47 - message like shah256 or similar
46:52 - so
46:53 - i've covered a selection of of all the
46:55 - algorithms that are in use today that
46:57 - solve quite a lot of the problems in
46:58 - modern cryptography
47:00 - um so this last five minutes or so um
47:03 - we're going to look at how you'd
47:04 - actually go about implementing
47:05 - cryptography in in applications if
47:08 - that's what you need to do
47:11 - so the first bit of information bit of
47:13 - advice is don't
47:16 - um
47:17 - i hope that you've sort of got an idea
47:18 - from this talk just how
47:20 - how many things you have to sort of keep
47:21 - an eye on and how difficult it is to
47:24 - actually do these things securely
47:26 - so
47:27 - if you've got a need to encrypt data
47:29 - don't try and do it yourself as much as
47:31 - possible
47:33 - um
47:34 - it's very easy to introduce
47:35 - vulnerabilities into applications
47:37 - through things like side channels
47:39 - um
47:40 - someone measuring how even if you take
47:42 - aas which is a secure algorithm and
47:43 - implement it
47:45 - if you um don't take care of things like
47:47 - how long it takes to encrypt the data
47:50 - someone might be able to retrieve
47:51 - information about your key or your plain
47:52 - text just by measuring how long it
47:54 - actually takes to encrypt messages and
47:55 - things like that
47:57 - um so
47:58 - the best bit of advice is
48:01 - use an existing implementation
48:03 - okay
48:04 - everything i've gone over today is
48:06 - battle tested and and hardened and it's
48:08 - been poured over by cryptographers for
48:10 - at least a decade
48:11 - and there are well-known
48:13 - well-tested well-used implementations
48:16 - out there use one of those
48:18 - okay
48:19 - um most links distros for example allow
48:22 - you to encrypt hard drive partitions
48:24 - that's a good first starting point
48:26 - um all the major web servers have
48:28 - support for tls
48:30 - use ssl for your connections between
48:32 - between servers don't try and manually
48:34 - implement in your application some sort
48:35 - of encrypting send over http decrypt on
48:38 - the other side just use https
48:41 - it's well tested it's it's gonna work
48:44 - okay
48:46 - another option
48:47 - um if you've got like two to remote data
48:49 - centers you could use a vpn between the
48:50 - two or maybe an ssh tunnel again all of
48:53 - these protocols and algorithms have been
48:55 - well tested there's lots of people going
48:56 - over the source code all the time
48:58 - the patch and the security
48:59 - vulnerabilities and things like that
49:00 - you're benefiting from the knowledge of
49:02 - people who who do this all the time
49:05 - okay
49:07 - um
49:08 - if one of those situations doesn't fit
49:11 - your use case if you do actually need
49:14 - to implement some cryptography bring in
49:16 - an expert okay
49:18 - um
49:19 - bring in someone to audit your code and
49:21 - make sure you've not made any mistakes
49:23 - um
49:24 - it's it's not a
49:26 - cryptography isn't a skill that most
49:28 - developers are like really tip-top on
49:31 - so although you can probably implement
49:32 - it
49:33 - bring someone in an expert an outside
49:35 - consultancy
49:37 - and get them to just make sure you've
49:38 - done it right
49:39 - um
49:40 - it might seem expensive to bring someone
49:42 - in to do that but it's nothing compared
49:45 - to the costs if you become sort of like
49:47 - if you get hacked and you become the
49:48 - next like ashley madison or sony that
49:50 - sort of sort of get all that data spewed
49:53 - all over the internet
49:54 - um especially with the gdpr coming in
49:56 - now that's that can be quite costly if
49:59 - if you make a mistake with this stuff
50:01 - so bring an expert it'll save you money
50:04 - and worry in the long run
50:07 - um
50:08 - obviously there's a php conference so
50:11 - what do you need what do you what should
50:12 - you do if you actually need to encrypt
50:14 - and decrypt stuff in php
50:16 - um there's a lot of libraries out there
50:18 - i've i reviewed a lot of them um
50:21 - there's quite a few that default to
50:23 - using pop-up penguin mode
50:26 - and insecure other options
50:29 - and if you would just download it with
50:30 - composer and be like yep that's the
50:31 - library i'll use that
50:33 - you'll end up with a few problems like
50:35 - people being able to view your images or
50:37 - sort of like pop-up versions of them
50:41 - so
50:43 - top of my list of recommendations is a
50:45 - library
50:46 - that uh scott akuzuki has written which
50:50 - is halite
50:51 - highlights a wrapper around libsodium
50:55 - which is a library that's been written
50:57 - by cryptographers
50:58 - to limit the amount of choices that
51:00 - developers are given
51:01 - you've got one implementation of things
51:03 - and that's a secure implementation and
51:05 - that's the sort of design goal of lib
51:06 - sodium
51:09 - and and highlight just provides a high
51:11 - level in place for that which is really
51:13 - straightforward
51:15 - it looks a little bit like this
51:17 - that would be how you would encrypt
51:18 - something using
51:20 - halite the wrapper around lip sodium
51:23 - it's that easy and that will be secure
51:26 - okay
51:27 - um so if you need to do something
51:30 - that's your best option
51:32 - um lip sodium is in php 7.2
51:37 - um you can install the extension peckle
51:39 - um for sort of versions before 7.2
51:42 - if you're in an environment where you
51:43 - can't install it scott's also written a
51:46 - polyfill in php which you can actually
51:48 - include and it's got all the the same
51:50 - algorithms written in php
51:52 - um
51:54 - so
51:54 - you've got a fairly good range of
51:56 - options there if you if you want to use
51:58 - that
51:59 - if for some reason you
52:01 - you can't use lip sodium for whatever
52:03 - reason maybe you need uh compatibility
52:05 - with a legacy system or something like
52:06 - that
52:07 - um diffuse php encryption
52:10 - is um
52:12 - another
52:13 - good library that's implemented in php
52:16 - um it uses a lot more of the the
52:18 - older style algorithms aes and um
52:20 - and an rsa for its cryptography
52:23 - um
52:24 - and it tries to implement those in a
52:26 - secure way and it'll fall back to to
52:28 - like open ssl if you've got that
52:29 - installed and things like that so it'll
52:30 - still be quite performant
52:32 - um
52:33 - so that's that's another option it's got
52:35 - a fairly similar ipi to halite so it's
52:38 - pretty much
52:39 - diffuse encrypt and diffuse decrypt
52:42 - so it's easy to get right
52:46 - um so that's pretty much the end of
52:48 - close to the end of the talk so
52:50 - i've got a few links now for anybody
52:51 - who's interested in finding out more um
52:53 - there's there's a wealth of really
52:56 - interesting stuff on cryptography um one
52:58 - of the best ones if you're interested in
53:00 - the historic
53:01 - side of the talk is simon sings the code
53:03 - book he's got a few of the ones i went
53:05 - over and a few other ones
53:07 - and there's also some really interesting
53:08 - case studies on what happened when
53:09 - cryptography went wrong
53:11 - um it's a really good resource he's also
53:13 - got a website where you can actually try
53:14 - out some of these um ciphers and you can
53:16 - encode and decode messages and do things
53:19 - like that
53:21 - um
53:22 - another good resource if you're
53:24 - interested in modern cryptography is
53:26 - bruce schneier's site um bruce nye is a
53:29 - well-known cryptographer
53:31 - i worked for a lot of leading corp
53:32 - companies on security and things like
53:34 - that um he also created blowfish and and
53:36 - the be crypt hash function which you're
53:38 - hopefully using for your passwords
53:40 - um so if you do feel like starting
53:43 - messing around creating your own
53:44 - algorithms he's got a self-study course
53:46 - on his website which starts off showing
53:48 - you how to like with with increasing
53:50 - difficulty of algorithms you can have a
53:52 - go at breaking yourself
53:54 - um
53:55 - one of the things you know in order to
53:56 - become a good cryptographer you need to
53:58 - prove that you can break other
54:00 - algorithms
54:01 - that way any anything that you've done
54:03 - you you know that if you're really good
54:05 - at breaking algorithms and you can't
54:06 - break your algorithm it's pretty good
54:08 - but if you're just like someone who's
54:09 - just turned up and like yeah i've just
54:10 - invented this thing
54:12 - how how can we trust that that's any
54:13 - good well if you've got a proven track
54:15 - record of being able to break
54:16 - cryptography and you say it's good
54:18 - you can probably trust that so if you're
54:20 - interested in sort of to get into that
54:22 - side his course is pretty good
54:24 - um
54:25 - the final link there is a library called
54:27 - php crypt do not use this in production
54:30 - um absolutely not um but it includes a
54:33 - pure php implementation of quite a lot
54:35 - of the interesting ciphers so if you
54:37 - actually have a look at the code
54:38 - implementation of some of these
54:39 - including the historic ones i think it's
54:41 - got enigma in there and a few others
54:43 - um it's quite a good one just have a
54:44 - look at the source code and see how they
54:46 - they tick underneath
54:48 - um
54:48 - but yeah obviously none of those are
54:50 - suitable for anything other than sort of
54:52 - like your own personal interest in
54:55 - cryptography
54:57 - right um
54:58 - i hope everyone sort of learned
54:59 - something from this talk and found it
55:01 - interesting
55:02 - my my twitter handles give up already
55:05 - i've also got gitlab github with a few
55:07 - few projects and things like that on um
55:10 - interesting post on my blog if anyone's
55:12 - interested i i broke an algorithm and
55:14 - someone implemented themselves one of my
55:15 - blog posts is actually showing why why
55:17 - you shouldn't actually do these kind of
55:18 - things
55:20 - and finally there is a joined in link
55:23 - if if you want to rate this talk let me
55:25 - know if it's any good