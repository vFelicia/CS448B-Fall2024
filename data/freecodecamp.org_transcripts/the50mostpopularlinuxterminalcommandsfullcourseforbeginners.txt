00:00 - learn the 50 most popular linux commands
00:03 - from colt steel
00:04 - all these commands work on linux mac os
00:07 - and any other place you have a unix
00:08 - environment colt is an extremely popular
00:11 - instructor and for good reason he has a
00:13 - knack for teaching complex topics in a
00:16 - way that beginners can understand hey
00:18 - everyone my name is colt steele and
00:20 - today we are going to learn a ton about
00:22 - the command line and different linux
00:24 - commands i'm a developer well honestly
00:27 - more of a teacher who happens to write
00:29 - code
00:30 - i teach in-person web development i've
00:32 - run boot camps in san francisco i now do
00:34 - a lot of online teaching and i have a
00:36 - boot camp i created with springboard if
00:38 - you want to learn more you can find a
00:39 - link in the description and this
00:42 - is a picture of one of my cats i
00:43 - actually have to take her to the vet
00:45 - like in five minutes really her tail is
00:47 - just drooping down for no reason i was
00:49 - gonna take her sooner but you know i had
00:51 - to make this for you
00:53 - let's hope she survives before i say
00:55 - anything else i want to give a big
00:57 - thanks to flavio copez i think i
01:00 - actually only know him as flavio maybe
01:03 - it's pronounced copes but i'm pretty
01:04 - sure it's not anyway uh he generously
01:07 - allowed me to use his linux commands
01:10 - handbook there's a link in the
01:11 - description of course very detailed and
01:14 - thorough handbook
01:15 - if you're not familiar with his work he
01:16 - puts out handbooks and tutorials on all
01:18 - sorts of topics so this is just one of
01:21 - many different handbooks
01:23 - anyway he is allowing me to use his
01:24 - handbook along with some of the
01:26 - materials i've created to create this
01:28 - mutant super course on youtube
01:31 - so we are going to cover 50 actually i
01:33 - think it's a little more than 50
01:34 - commands
01:35 - that are useful obviously to varying
01:38 - degrees some of them you'll use every
01:39 - single day
01:40 - as a developer for example
01:43 - and then some of them
01:44 - you may never use except in an emergency
01:46 - situation once a year but i'm going to
01:48 - cover a bunch of them they're not really
01:50 - in a particular order especially towards
01:52 - the end of the course but at the
01:54 - beginning i ended up deciding that
01:56 - instead of just 50 random commands in
01:58 - any order i wanted to make something for
02:01 - uh anybody so if you're a beginner you
02:03 - can start at the beginning and we'll go
02:04 - through the basics navigation working
02:07 - with the basic commands and options and
02:09 - making folders and files and so on but
02:12 - then after about this point
02:14 - things really open up and you can jump
02:17 - around to whatever commands you'd like
02:19 - and of course if you're someone who
02:20 - already has some terminal experience
02:21 - some of these commands are familiar to
02:23 - you just hop around take a look at the
02:26 - description there are time stamps and
02:28 - just click on whatever command you're
02:30 - not really comfortable with or you've
02:32 - never heard of
02:33 - there's probably something here for you
02:35 - but if you're a beginner i definitely
02:36 - would recommend starting at the
02:37 - beginning so aside from these commands
02:40 - which there's a lot here and this is a
02:42 - pretty long video i also cover some
02:44 - concepts that are pretty important so
02:46 - the very basics things like why even
02:48 - learn this stuff if you're not a linux
02:50 - user you're on a mac you're on windows
02:52 - why do you need to know linux commands
02:55 - do you need to know them the answer is
02:57 - probably yes if you're trying to break
02:58 - into web development programming coding
03:01 - engineering any sort of techie industry
03:04 - then we'll talk about things like unix
03:06 - and gnu and linux and unix-like and true
03:09 - unix what is all that uh what is a shell
03:12 - what is bash z-shell
03:14 - kernel terminology stuff so that's all
03:17 - coming up of course there's time stamps
03:18 - if you want to skip around if you don't
03:20 - care about that stuff and then
03:21 - installation so if you're on a mac you
03:24 - don't really have to do anything if you
03:26 - already have linux installed you don't
03:27 - really have to do anything either
03:29 - and if you're on windows well we have to
03:31 - jump through some hoops the good news is
03:33 - fewer hoops than we had to jump through
03:35 - a couple months or years ago so i'm
03:37 - going to show you how to install
03:38 - something called windows subsystem for
03:40 - linux
03:41 - then we'll also talk about concepts like
03:43 - command structure and arguments and
03:45 - options working with man pages folder
03:48 - structure of linux redirecting standard
03:50 - output appending standard outputs tilde
03:52 - expansion history expansion path name
03:54 - expansion curly brace expansion
03:57 - and permissions so we're going to end
03:58 - with permission is a pretty big chunk
04:00 - honestly at the end of this course it's
04:02 - devoted to just these two commands and
04:04 - understanding how to read and manipulate
04:06 - permissions on linux so there's a lot
04:08 - here there's some introductory
04:10 - conceptual stuff in terminology
04:12 - installation and then we start from the
04:14 - basics so you could know nothing about
04:16 - the terminal never have entered a
04:17 - command in your life start at the
04:19 - beginning and don't skip around or if
04:21 - you feel confident or you know some of
04:23 - this stuff jump around use the time
04:25 - stamps they are there for you all right
04:27 - so let's start with a quick discussion
04:28 - around why this matters why should you
04:30 - learn these commands uh yes at times it
04:33 - might seem like you're you know doing
04:35 - stuff straight out of a 1980s hacker
04:37 - movie um and we're
04:39 - far more advanced and things have
04:41 - improved so much why do we still have to
04:42 - use text commands well there's a bunch
04:45 - of reasons including the fact that
04:48 - you can just do a lot more from the
04:49 - terminal using these commands we're
04:51 - going to learn you'll have more control
04:53 - greater access you can do things you
04:55 - just cannot do otherwise there's just no
04:57 - way around that if you want to start a
04:59 - server manage different processes
05:02 - interact with databases all sorts of
05:04 - things alter permissions you need to
05:06 - know terminal commands to do that
05:08 - another reason it's faster at least once
05:11 - you get past the basic hurdles you learn
05:13 - the commands you get used to them you
05:15 - can do things way faster we can make
05:18 - 10 000 files in a single line i can make
05:21 - 10 000 empty files all with different
05:22 - names doing that graphically with my
05:24 - mouse or file new save file new save
05:28 - would take hours now that's just a sort
05:30 - of far-fetched example but in general we
05:32 - can do things much faster the one
05:35 - problem is that when you're learning
05:36 - it's going to be much slower i kind of
05:38 - already hinted at this one but we can
05:40 - actually automate things we can speed up
05:42 - repetitive processes we can save
05:44 - ourselves a lot of time
05:46 - another reason it's available everywhere
05:48 - so if you learn these commands
05:51 - you'll be able to work on any linux
05:53 - distribution you'll be able to then
05:55 - switch over to a mac if needed and use
05:57 - the commands on a mac now on windows yes
05:59 - it's a little bit different so it's not
06:01 - technically available everywhere but
06:03 - these commands we're going to learn are
06:04 - pretty standard across any sort of
06:06 - developer software engineer career which
06:09 - leads me to the next point it's
06:11 - essentially a requirement if you want to
06:13 - be a web developer data scientist devops
06:15 - engineer sys admin security admin
06:17 - machine learning engineer ai engineer
06:19 - whatever
06:20 - any type of coding related career you
06:23 - are probably going to need to use the
06:24 - command line you will have tools that
06:27 - only exist on the command line that
06:29 - you'll need to be able to use so for a
06:31 - lot of people that's the only reason
06:33 - that really matters you just need it if
06:35 - you want to get a job it's just part of
06:37 - the expected skill set also a lot of
06:39 - cloud computing programs or services
06:42 - don't even have a graphical user
06:43 - interface you just have to do things via
06:45 - a command line and again high-paying
06:48 - jobs lots of careers lots of roles that
06:51 - you'll need to at least know the basics
06:53 - of working with terminal commands so the
06:55 - next topic i'd like to quickly discuss
06:57 - is a little bit of context around
06:59 - operating systems and why these commands
07:02 - will work on linux and on mac by default
07:05 - but they're not going to work on a
07:07 - windows machine at least not out of the
07:09 - box so uh there's quite a lot of
07:12 - complicated history uh and
07:14 - and uh drama
07:16 - around different operating systems
07:18 - things being open source versus closed
07:20 - source and competition
07:23 - and copying each other
07:24 - it's quite dramatic but the general gist
07:28 - that you need to understand is that over
07:30 - the years since the very early days of
07:32 - computing well maybe not the super
07:35 - earliest days but we're going back to
07:36 - the 70s here this is a timeline that
07:38 - shows
07:40 - a very detailed timeline that shows
07:42 - operating systems and how they're
07:43 - connected
07:44 - anyway in the 1970s there was something
07:46 - called unix you can see it here
07:49 - and just take a look at all of these
07:51 - lines this whole family of operating
07:53 - systems that it spawned
07:56 - so there's lots and lots of them
07:57 - everything in red here is considered in
07:59 - some way related uh or indebted to
08:03 - unix
08:05 - so that includes things like linux
08:08 - so in this course i'll be using ubuntu
08:10 - which you can see here it is a
08:11 - distribution of linux but there's many
08:13 - many others things like android chrome
08:16 - os but also other uh more common linux
08:19 - distributions like fedora or red hats
08:23 - anyway all this linux stuff is
08:26 - descendant from unix all the way back
08:29 - here in the 70s now we also will see
08:32 - somewhere in here all the different mac
08:34 - operating systems here we are
08:36 - so mac os x we've got ios the apple tv
08:40 - os audio os
08:42 - watch os all these different apple
08:44 - products all the apple operating systems
08:47 - also related to unix
08:50 - but then our good friend windows
08:52 - somewhere down here it's not an it's not
08:54 - even in the same red color
08:56 - just to show how it is completely
08:58 - different it is in green this world of
09:01 - windows so windows windows vista windows
09:04 - xp
09:05 - windows mobile windows phone
09:07 - xbox os all that stuff is over here it's
09:11 - just kind of on its own
09:13 - it is not related it's not
09:15 - you know a descendant of that original
09:17 - unix operating system from way back in
09:19 - the 70s now the reason this matters
09:22 - is that
09:23 - all of these guys in red up here
09:25 - they tend to share the same commands
09:28 - unix was this operating system developed
09:30 - in the mid 60s at bell labs really cool
09:32 - time lots of innovation going on
09:34 - uh but what matters to us today 50 plus
09:36 - years later is that lots of those
09:39 - innovations lots of those new ideas and
09:41 - the specific commands the actual
09:43 - interfaces the way a file system was
09:45 - structured all of that carries over
09:47 - today yes it's changed it's been
09:49 - expanded
09:51 - but it is present in all of those red
09:53 - descendants of unix unfortunately for
09:56 - our windows users those commands
09:59 - don't exist natively on windows
10:02 - windows has its own set of commands its
10:04 - own default shell its own way of doing
10:07 - things so i'm going to talk about how we
10:08 - can get these unix commands to work
10:11 - on windows but just so you understand
10:13 - why this is a problem in the first place
10:15 - it just has to do with the history there
10:17 - are so many of these os's over the years
10:19 - inspired by
10:20 - and descended from the original unix os
10:23 - including linux and mac os
10:25 - but not windows
10:28 - lonely windows over here alright so now
10:30 - we have a basic understanding of the
10:31 - fact that
10:32 - of today's operating systems there's
10:34 - really those two groups everything
10:35 - descended from microsoft and then kind
10:37 - of everything else that is in some form
10:39 - some way related to unix now that's a
10:42 - vast simplification
10:43 - but again we're just talking about
10:45 - popular operating systems so you know
10:47 - linux chrome mac os all these things
10:49 - come from unix
10:51 - now let's talk about linux and unix and
10:54 - all that stuff in a little bit more
10:55 - detail so that you understand what
10:57 - exactly linux is why it exists so this
11:00 - is a diagram from wikipedia
11:03 - that shows the history going back to
11:05 - 1969 early unix versions
11:08 - and how it spawned all the you know
11:10 - other
11:10 - operating systems that are connected to
11:12 - it
11:13 - now what you'll see
11:14 - is that there are three colors red is
11:17 - closed source or pink
11:19 - and that means the code is completely
11:20 - closed off you can't edit it you can't
11:23 - view it you're not allowed to even try
11:24 - to tweak it
11:26 - then we have open source which you may
11:28 - be familiar with that term the code is
11:30 - openly
11:32 - viewable you can change it tweak it make
11:34 - your own versions try things out
11:36 - and then there's in yellow this mixed
11:39 - shared source type of
11:41 - operating systems so what you'll see
11:43 - here is that early on unix and a lot of
11:46 - other operating systems in the early
11:48 - days were mixed or shared source but
11:50 - then there was a plethora of closed
11:52 - source operating systems uh that were
11:56 - very walled off and you were not allowed
11:58 - to do anything with that code you were
12:00 - not allowed to view edit tweak and so on
12:03 - and that led to the rise of something
12:04 - called the free software movement free
12:07 - in this context does not mean no money
12:10 - free
12:11 - beer it instead means free in the
12:13 - context of freedom free speech
12:16 - so this software movement was all about
12:19 - uh the the idea that you should be able
12:21 - to collaborate you should be able to
12:24 - edit code view source code run copy
12:27 - distribute study change and improve
12:28 - software should not be walled off
12:31 - and the leader of this movement was this
12:33 - guy named richard stallman so he began
12:35 - work on something that ended up being
12:37 - called gnu gnu
12:39 - that was his own free software
12:41 - alternative to unix so he wanted to make
12:44 - a full operating system that had
12:46 - everything that normally came with unix
12:48 - but it was going to be completely free
12:50 - again free meaning you could tweak it
12:52 - and edit it do whatever you want to it
12:54 - and see the source code now that's a
12:56 - huge undertaking creating an operating
12:58 - system
12:59 - and at the same time this other
13:01 - developer named linus torvalds or linus
13:04 - torvalds
13:05 - was working on something called a kernel
13:07 - and we'll talk about what that is in a
13:09 - moment
13:10 - but this kernel he was working on he
13:12 - called it linux and a kernel is a very
13:14 - complicated and critical part of an
13:16 - operating system it is the thing that
13:18 - basically sits between the hardware and
13:21 - the software and it facilitates the
13:22 - interactions between different pieces of
13:24 - software and then the actual the
13:26 - physical hardware of the computer
13:29 - so
13:30 - what happened is that richard stallman
13:32 - was working on the gnu project trying to
13:34 - build a full operating system well he
13:35 - didn't have a kernel but at the same
13:37 - time linus torvalds was working on a
13:39 - kernel and torvalds ended up merging his
13:42 - kernel with the existing
13:44 - new components from richard stallman to
13:46 - create this whole operating system just
13:48 - a quick note so i don't get any negative
13:50 - comments here
13:51 - there is a bit of controversy over the
13:53 - name of the resulting operating system a
13:56 - lot of people
13:57 - most people have heard of linux
14:00 - fewer people have heard of gnu the term
14:02 - linux
14:03 - often people use it to refer to the
14:05 - entire resulting system when in reality
14:08 - uh the linux kernel was just one piece
14:10 - that was added on to some existing
14:12 - components but what matters for us here
14:14 - if we go way back to this slide
14:18 - over here
14:19 - is that what we see is a bunch of closed
14:22 - source mix source
14:24 - operating systems all over here and then
14:27 - this thing called linux pops up right
14:29 - there around 1991 in green it's open
14:31 - source now there's not a direct line as
14:33 - you can see going back to any of these
14:36 - what are called true unix operating
14:38 - systems and the reason for that uh is
14:41 - yet another piece of history there is a
14:45 - global consortium called the open group
14:47 - they own the trademark for unix
14:49 - in order for you to call your operating
14:51 - system unix if you make an os and you
14:53 - want it to be certified you have to pay
14:55 - a lot of money you have to go through a
14:56 - bunch of testing you have to comply with
14:59 - a bunch of regulations and standards and
15:01 - it's a complicated process and there's
15:02 - money involved it's not very
15:05 - free free software so we have another
15:07 - term there's true unix you've been
15:10 - certified as a true unix operating
15:11 - system
15:12 - and then we have unix-like operating
15:14 - systems which are compatible with the
15:16 - unix standards they implement things
15:18 - correctly but they haven't been
15:19 - certified as actually true unix
15:22 - and this is often because of financial
15:24 - considerations or ethical objections to
15:26 - the existence of the idea of true unix
15:29 - so what we see on this slide here is
15:31 - linux enters the picture it is not
15:33 - considered true unix but rather it's
15:35 - considered unix-like
15:37 - remember that linux itself is just a
15:40 - kernel which is very very important it's
15:43 - again that piece of the operating system
15:45 - that connects the hardware to the
15:46 - software so that's what linux is really
15:48 - it's the kernel but when we talk about
15:50 - things like ubuntu what ubuntu is is a
15:53 - linux distribution it is one of many
15:56 - many distributions out there there's
15:58 - nearly a thousand last time i checked uh
16:00 - you may have heard of fedora slackware
16:02 - ubuntu that's what i'll be using
16:04 - and what each distribution is it's it's
16:06 - the linux kernel it's some gnu tools
16:09 - documentation a package manager a
16:11 - desktop environment a window management
16:12 - system a whole bunch of other things
16:14 - combined together to form a full
16:16 - operating system
16:18 - so to recap all of that
16:20 - there are tons and tons of operating
16:22 - systems on this chart you can see some
16:24 - are open source some are closed source
16:25 - some are mixed source uh some of them
16:27 - are considered true unix they've paid
16:29 - they've been certified by this
16:30 - foundation or this consortium to be true
16:33 - unix but then over here we have linux
16:36 - linux is fully open source and whether
16:38 - you call it linux or linux gnu or gnu
16:40 - linux
16:41 - it is a
16:43 - unix-like operating system that conforms
16:45 - to all these standards these operating
16:46 - systems do we can use the same commands
16:49 - things are structured the same way there
16:50 - are subtle differences but it doesn't
16:52 - really matter everything on this chart
16:55 - here they're all part of this greater
16:56 - unix family or unix inspired family now
16:59 - we have one last piece of terminology
17:01 - and history and all that stuff to get
17:03 - out of the way before we move on to
17:04 - actually running commands we need to
17:06 - talk about the term shell so you may
17:08 - have heard of this before
17:10 - if you're on windows you may have heard
17:11 - of powershell or you may have heard of
17:14 - bash or z shell or you maybe never have
17:17 - heard of them but there's this concept
17:19 - of something called a shell
17:21 - what the shell is is a very very
17:23 - important piece of software that is
17:25 - going to expose the operating system
17:27 - itself to human users or to other
17:29 - programs so it is the thing that takes
17:31 - our commands and hands them over to the
17:33 - operating system to actually perform and
17:35 - the term shell comes from the fact that
17:37 - it's the outer layer around the
17:39 - operating system like the shell around
17:41 - an oyster so there's this other term
17:43 - terminal way back in the day a terminal
17:45 - used to be an actual piece of hardware
17:47 - it would have a screen and it was a
17:49 - physical device with a keyboard you'd go
17:51 - over and you'd enter your commands into
17:52 - the terminal
17:54 - today terminal is just a piece of
17:56 - software it's an application there's
17:58 - many different terminal applications
18:00 - it's the place we go to type our
18:01 - commands when we hit enter there's some
18:03 - shell that we are using in that terminal
18:05 - window uh by default on ubuntu and most
18:09 - linux distributions that shell is called
18:11 - bash on macs these days the shell is
18:13 - called z shell zsh another very popular
18:17 - shell is fish there are many other
18:19 - shells out there though
18:21 - and again their job is to take commands
18:24 - that we provide
18:26 - or other applications humans or
18:27 - applications provide and then give them
18:29 - over to the operating system and make
18:30 - sense of it all so again i'll be using
18:33 - bash that's the default shell that comes
18:34 - with the boom 2 but if you're on a mac
18:37 - i'll talk about installation and you'll
18:38 - see that fortunately z shell is very
18:41 - very similar and the commands are still
18:42 - going to work so it's not a big deal at
18:44 - all but it's good to know that there are
18:46 - different shells
18:47 - and then the job of that shell is to
18:49 - take those commands and pass them over
18:51 - to the operating system and as i
18:52 - mentioned bash is the most popular shell
18:55 - out there uh especially on linux based
18:57 - systems uh it is the most common default
19:00 - shell
19:00 - and the name if you're wondering it
19:02 - comes from born again shell
19:05 - and it really doesn't matter but it's
19:07 - this reference to this guy steven bourne
19:09 - who created a different shell called sh
19:11 - a direct ancestor of bash so there's sh
19:14 - and then born again sh
19:17 - and again bash will run on pretty much
19:19 - every version of unix or unix-like
19:21 - systems so it does run on macs it runs
19:23 - on you know any linux distribution any
19:26 - of the unix operating systems that you
19:28 - can see on that massive chart next up
19:30 - let's talk about setup and installing
19:32 - things if needed so that you can run
19:33 - these commands
19:35 - so right now we're looking at a linux
19:37 - distribution this is ubuntu this is the
19:40 - linux distribution i'll be using
19:42 - throughout the course
19:43 - if you already have linux if you have
19:45 - some version of it some distribution
19:47 - just use that it's going to be very very
19:49 - similar all that you need to know is
19:51 - there's a
19:52 - built-in terminal application if i just
19:55 - search for terminal
19:57 - i'm going to be running my commands in
19:58 - here probably change the color
20:00 - and this is where i'll type my commands
20:02 - so if you are on a mac you do not need
20:05 - to go and install ubuntu and a virtual
20:08 - machine that's actually how i'm running
20:10 - this i'm still on my mac here but i'm
20:12 - running it in a virtual machine you can
20:14 - do that but
20:16 - unless you have a really good reason to
20:18 - i would just stick with what you know
20:19 - because the commands that i'm going to
20:21 - show you will work on a mac
20:23 - all right so this is just for users who
20:25 - already have ubuntu here's the terminal
20:27 - app you just search for it and we'll run
20:28 - our commands there
20:30 - now if you are a mac user
20:32 - remember it's part of this unix family
20:34 - unix-like
20:35 - operating systems all the commands i'm
20:37 - going to show you will work on the mac
20:39 - all you need to do is search for
20:40 - terminal
20:41 - and it will probably look a bit
20:43 - different than this but you will have a
20:45 - terminal where you can run the same
20:47 - commands i show you so over here on
20:49 - ubuntu when i show the psax ww command
20:54 - it works you don't need to run this by
20:56 - the way but over here on my mac same
20:58 - thing p s a x w w
21:01 - it also works and it will actually learn
21:04 - what this is but it gives me a bunch of
21:05 - stuff all right windows users it's your
21:08 - turn let's talk about installation and
21:10 - the steps we need to go through in order
21:11 - to run linux
21:13 - so remember the problem here is that on
21:15 - windows
21:16 - we just don't have access to the same
21:18 - commands they're implemented differently
21:20 - windows is not part of this unix family
21:22 - this unix like family of operating
21:25 - systems so this means that a lot of the
21:28 - commands you'll learn
21:29 - in this video and that developers use
21:31 - every single day
21:33 - are not going to work on windows or
21:34 - they'll work differently or they'll
21:36 - partially work now windows has its own
21:38 - set of commands and as you could live in
21:41 - that world exclusively it's just a
21:44 - different world so if you want to use a
21:47 - lot of the common developer tools and
21:48 - you know you're watching this video you
21:50 - probably already know what you want to
21:51 - do
21:52 - we need to get some way of running linux
21:54 - commands on windows the way that we do
21:57 - this is really two options there used to
21:59 - only be one
22:00 - we used to have to have a virtual
22:01 - machine it's a pain to install uh it's
22:04 - totally isolated from your actual
22:06 - windows
22:07 - operating system
22:08 - and it can be slow can have a lot of
22:10 - overhead
22:12 - now instead we have a really cool fancy
22:15 - option called wsl windows subsystem for
22:18 - linux this is actually put out by
22:20 - microsoft
22:21 - and it allows us to run a linux
22:23 - environment directly on windows or
22:26 - inside of windows so it's not isolated
22:28 - it's not a virtual machine it actually
22:30 - works directly inside of windows
22:32 - it's just a command line version of of
22:35 - linux to be clear so we're not going to
22:36 - have a separate desktop you're not going
22:38 - to have you know all the apps and stuff
22:40 - that i have on ubuntu but that's kind of
22:42 - the point you can still be a windows
22:44 - user and have linux commands from the
22:47 - command line
22:48 - so it's really really cool it's updated
22:51 - pretty frequently it's still under
22:52 - active development and the really good
22:55 - news is that it's a lot easier to
22:56 - install these days than it used to be
22:58 - you do need to make sure you have
23:00 - windows 10 version 2004 with build
23:02 - number 19041 or higher or windows 11 in
23:07 - order to use the simplified installation
23:09 - instructions otherwise uh you can follow
23:12 - i would recommend going to this webpage
23:14 - anyway
23:15 - docs.microsoft.com look for wsl
23:18 - because this does change but if you have
23:20 - an older version you can still install
23:22 - wsl you just have different instructions
23:24 - but if you have
23:26 - the appropriate build number or higher
23:28 - all we need to do is from the app called
23:30 - powershell which i have open right now
23:32 - you can just search powershell
23:35 - okay this opens up this terminal where i
23:37 - can you can see ps by the way i'm using
23:39 - powershell
23:41 - i can type commands in here and it tells
23:43 - me in that case i don't know what the
23:44 - heck you're talking about
23:46 - but the command we want to run is wsl
23:48 - dash dash install so let's try it wsl
23:53 - dash dash
23:54 - install
23:56 - the requested operation requires
23:58 - elevation so what this is telling me is
24:00 - that i need to have admin privileges or
24:03 - permissions to do that so why is that
24:05 - happening well i need to run powershell
24:08 - as an administrator so i'm going to
24:10 - search again for powershell powershell
24:13 - but i'm going to click on run as
24:14 - administrator here
24:17 - all right and that opens me up a new
24:18 - window it says administrator windows
24:20 - powershell and we try again wsl dash
24:23 - dash install
24:25 - whoops
24:28 - and it might take a little while
24:30 - so i'll be back when hopefully this
24:32 - finishes successfully
24:34 - and if not i guess he'll watch me debug
24:36 - it
24:40 - oh check it out already we can see it's
24:42 - downloading ubuntu so that's the default
24:45 - linux distribution it uses when i first
24:48 - installed wsl a year or two ago for a
24:51 - different course uh you actually had to
24:53 - go and download your linux distribution
24:55 - separately you had to go download wsl
24:58 - separately you had to then connect the
24:59 - two and point it to the particular
25:01 - installation and it was just a huge pain
25:03 - but now
25:04 - hopefully super easy take a look it says
25:07 - the requested operation is successful
25:08 - that's always good changes won't be
25:10 - effective until the system is rebooted
25:12 - so let's reboot
25:14 - okay so once that finishes up i
25:16 - restarted uh i now have actually when i
25:19 - restarted it automatically opened up
25:21 - ubuntu which is now installed it wasn't
25:23 - even a thing before
25:24 - now i have an app i can run called
25:26 - ubuntu it opens up right now at least
25:29 - this
25:30 - terminal that i can see here and it
25:32 - tells me you know i had to install for a
25:33 - few minutes
25:35 - and then it wants me to set up a default
25:37 - user account and this username that i
25:39 - set up does not have to match my windows
25:41 - username but whatever you do you know
25:43 - you want to remember what you put in
25:45 - here so this is going to be for our
25:47 - ubuntu part of this machine i'm going to
25:50 - make my username colt
25:52 - and then a password
25:53 - and you'll want to remember that
25:55 - password you're not going to see what
25:56 - you're typing i'll hit enter and then
25:58 - retype it again
26:01 - you can change that password later i'll
26:02 - actually show you a command you can use
26:04 - to change that password
26:05 - and there we are i now have linux i'm
26:08 - running ubuntu on my windows machine so
26:11 - the commands will learn things like pwd
26:14 - and who am i
26:16 - just to show a couple simple ones or
26:18 - p-s-a-x-w-w
26:20 - there are lots and lots of commands
26:22 - we're going to cover and they now will
26:24 - work these commands are running on
26:26 - windows now there is some additional
26:28 - setup you can go through
26:30 - if you go to the installation
26:31 - documentation they recommend on windows
26:35 - that you whoops this is the wrong page
26:36 - here they recommend that after you set
26:38 - up your linux user info which we just
26:40 - did
26:41 - that you can also install an app called
26:43 - windows terminal
26:45 - and windows terminal is uh remember a
26:47 - terminal is just an application that can
26:49 - run different shelves and
26:50 - it can sort of be a jack of all trades
26:52 - we can use windows terminal as our
26:54 - terminal it's just a more sort of fancy
26:57 - better features more customizable
26:59 - terminal application so you do not need
27:01 - to do this but if you want to
27:03 - you can install the windows terminal app
27:05 - and you can make it look all nice and
27:07 - pretty
27:08 - and run ubuntu from inside windows
27:10 - terminal rather than the default
27:13 - terminal that comes with ubuntu so one
27:15 - more time perfectly serviceable just to
27:17 - use this terminal but if you want to get
27:19 - windows terminal if you're serious about
27:21 - you know mastering all this stuff and
27:23 - working
27:24 - as a developer or some other you know
27:27 - you want to use the terminal day in and
27:28 - day out windows terminal is just the
27:31 - better option it has more features so
27:33 - i'm going to install it i'm going to
27:34 - download it just from windows website or
27:37 - microsoft's website now that it finished
27:40 - i'll click launch
27:41 - and remember a terminal is just
27:44 - like a piece of software that can
27:46 - connect or interact with different
27:48 - shells so right now it opened up with
27:50 - powershell which is not what we want to
27:52 - use in this course
27:54 - first of all let's see if i can just
27:55 - make this
27:56 - larger font for you there we go okay
27:59 - it's a little bit larger now so as you
28:01 - can see it's using powershell but i can
28:03 - click this little drop down arrow here
28:05 - and switch over to instead use ubuntu
28:08 - so now i'm in ubuntu you can see my
28:10 - prompt changes here it has my username
28:12 - in there
28:13 - you can customize the appearance and all
28:15 - of that so if we go to settings
28:18 - you know you can go down to ubuntu you
28:20 - can set up a different appearance font
28:22 - size
28:23 - but what you can also do is set the
28:25 - default profile to be ubuntu and if we
28:28 - save that
28:29 - it now means when i make a new window if
28:32 - i just do plus
28:33 - it is ubuntu you can see my little linux
28:35 - penguin that's the logo there and we're
28:38 - now up and running with windows terminal
28:39 - there's a lot you can do to customize it
28:41 - but that's not really the point of this
28:43 - course so now you have it run your
28:44 - commands here when you see me run them
28:46 - in ubuntu uh run them here okie dokie
28:49 - that should hopefully wrap up
28:50 - installation whether you are actually
28:52 - running linux like
28:54 - like i am right now ubuntu this is the
28:56 - desktop version i have the terminal open
28:58 - i will be running my commands right here
29:01 - but if you're not maybe you're using a
29:03 - mac
29:04 - so here's my mac i've got my terminal
29:06 - open right here i'll run commands inside
29:08 - the terminal application here they'll
29:09 - work just the same
29:11 - and then finally if you're on windows
29:13 - hopefully you installed wsl so here we
29:16 - are i'm running this is windows terminal
29:18 - i make sure i'm running ubuntu here
29:21 - i run my commands right here so
29:23 - whichever one you're on just make sure
29:24 - you know where you're going to be
29:25 - running those commands if you're on
29:27 - windows make sure it's not powershell
29:30 - because you'll run into problems we want
29:32 - to make sure we are running ubuntu so
29:34 - that our unix commands will work
29:36 - otherwise they won't
29:37 - yes by the way all three of these are on
29:39 - one computer right now i've got linux
29:41 - windows and my mac
29:44 - okay let's get started okay so now that
29:46 - we hopefully have everything installed
29:48 - correctly we can go ahead and get
29:49 - started now before we do the first thing
29:52 - i just want to make clear is that for
29:53 - the most part there's no order to the
29:55 - commands in this video it's a bunch of
29:57 - commands and they're useful and most of
29:59 - them don't really have to do with one
30:01 - another or depend on each other but
30:03 - early on right now i'm going to go
30:05 - through some of the very basic commands
30:07 - and there is a logical order to how i'm
30:09 - going to teach them all that is to say
30:11 - if you're a complete beginner stay right
30:13 - here and we'll go through the basics in
30:15 - order but if you have experience if you
30:16 - know the basics of ls and
30:19 - man and cd and pwd you may want to skip
30:22 - ahead so check out the time stamps in
30:24 - the description below and click on
30:26 - whatever command looks interesting or
30:28 - you'd like to learn more about but if
30:29 - you are new stick with me let's go ahead
30:31 - and get started all right so before we
30:34 - talk about commands let's talk about not
30:36 - commands in my prompt
30:38 - if i start typing really anything and i
30:41 - hit enter
30:42 - the shell is going to try and process
30:43 - that and figure out what command i'm
30:45 - referring to but i'm not referring to
30:47 - any valid command so i get a message
30:50 - that says command not found
30:52 - same thing on a mac
30:53 - type gibberish we get command not found
30:56 - same thing over here on my windows
30:58 - machine although i'm running linux on
31:00 - windows
31:01 - and i get command not found okay
31:04 - hopefully not that surprising
31:06 - so what we want to do is type commands
31:07 - that actually make sense that the
31:09 - computer can figure out what we're
31:11 - referring to and then run some
31:12 - corresponding program for us and the
31:14 - first really simple one i'm going to
31:16 - show you is maybe not that useful but
31:18 - it's just a good demonstration of a
31:20 - simple command it is who am i all one
31:23 - word no spaces
31:25 - who am i all lowercase it's going to
31:27 - print the username of the currently
31:29 - logged in user so maybe not something
31:31 - you need to do all the time
31:33 - you probably know who you're logged in
31:34 - as though there are uses for this
31:36 - especially in scripting
31:38 - if you write scripts later on but anyway
31:39 - if i just run it here who am i
31:43 - over here on my ubuntu installation i am
31:46 - logged in as colt that is the username i
31:49 - have
31:50 - here's my mac here on who am i my
31:52 - username is slightly different it's my
31:54 - full name called steel
31:56 - and i think on windows it's just
31:59 - cult as well
32:00 - all right so that's our first official
32:02 - command really really simple hopefully
32:04 - nice and straightforward right there's a
32:06 - difference between just typing gibberish
32:08 - and typing a command that is recognized
32:10 - but it is important to note you know who
32:12 - am i like this
32:15 - is not the same thing at all
32:17 - uh there's no
32:19 - real auto complete or spell check or
32:21 - anything like that uh the terminal is
32:23 - just gonna take what you what you give
32:25 - it and try and find that program so it
32:27 - can't find this program
32:29 - who am
32:30 - it only knows who am i
32:32 - okay so the next command we'll look at
32:34 - is called man
32:36 - the man command m-a-n is short for
32:39 - manual
32:40 - and that's exactly what it is it is a
32:42 - command that doesn't do anything to our
32:44 - system it's purely informative it tells
32:46 - us information or manual pages for
32:49 - commands
32:51 - as well as some other things not just
32:52 - commands but we're going to focus on the
32:54 - command side of things so anytime we
32:56 - have some new command like we just
32:58 - learned who am i we can actually run
33:01 - man
33:02 - followed by that command name to get a
33:04 - manual page entry for that command so if
33:07 - we need to learn more about who am i or
33:10 - any other command most likely you won't
33:12 - need to learn more about who am i
33:13 - because it's so simple
33:15 - but we can do just that we can run man
33:18 - followed by a command like who am i
33:21 - hit enter
33:22 - and our screen changes pretty
33:24 - drastically that prompt goes away i
33:26 - can't type commands anymore
33:28 - what we see here is a man page it tells
33:31 - us the name of the command prints the
33:33 - effective user id
33:35 - something called a synopsis will come
33:36 - back to this when we learn some other
33:38 - commands and then a description
33:40 - print the username associated with the
33:42 - current effective user id
33:44 - pretty straightforward there's not a
33:45 - whole lot here we can see who wrote the
33:47 - command
33:49 - and we can find a place to report bugs
33:51 - this is a very simple man page some
33:53 - commands have very long pages
33:56 - dozens and dozens of pages you would
33:57 - actually need to scroll through
33:59 - now important to note first of all to
34:01 - get out of here
34:03 - we need to type the letter q if you
34:04 - forget that you can find it down here
34:06 - but remember i am not at my prompt right
34:08 - now i can't type commands so i can't
34:10 - type who am i if i type things i start
34:13 - to see a whole bunch of other texts
34:15 - appear i'm actually looking at some help
34:18 - that tells me more about how this
34:21 - program works so it tells me you know
34:23 - you can exit by typing q or uppercase q
34:26 - or
34:26 - zz
34:28 - you can type h to display the help page
34:30 - that i'm looking at right now
34:32 - so that's what happened i typed who am i
34:34 - hit h but anyway i'm going to type q to
34:36 - get out of there uh now i'm back to the
34:38 - man page for who am i and i'll type q
34:40 - again so just one more time if i type
34:43 - man followed by some command
34:45 - if i want to get out of here type q and
34:48 - now i can type commands again
34:50 - so if i try and run man on its own
34:53 - it's going to tell me what manual page
34:54 - do you want this is a manual command i
34:56 - need to know what you want a manual for
34:59 - so we can actually do man man
35:01 - and that gives us the
35:03 - man page for the man command it's an
35:06 - interface to the system reference
35:07 - manuals there's a bunch here
35:10 - one thing i'll just point out quickly is
35:11 - that we can scroll by using the mouse
35:14 - that is one option but it's a lot easier
35:17 - to scroll one page at a time by hitting
35:19 - space
35:21 - there's a lot of text here and i can
35:22 - scroll down by hitting space
35:25 - rather than having i can also use the
35:26 - arrow keys by the way to go one line at
35:28 - a time up and down which is what i'm
35:30 - doing right now
35:31 - space to go down a page at a time q to
35:34 - get out of here all right so that's the
35:36 - man command
35:37 - nice and simple hopefully
35:39 - very useful especially when we have more
35:41 - complicated commands the next command is
35:43 - also nice and straightforward it is
35:45 - called clear
35:46 - c-l-e-a-r
35:48 - and this command will clear your
35:50 - terminal screen
35:52 - it is useful although i'll also show you
35:54 - a shortcut that you can use in place
35:56 - that's actually much shorter
35:58 - so c-l-e-a-r will clear the mess on your
36:01 - screen if you have a bunch of stuff here
36:03 - like i do uh c-l-e-a-r enter and it's
36:07 - gone
36:08 - so i'll just show another example of
36:10 - that over here
36:11 - this is on my mac let's do some more
36:14 - commands how about man clear let's just
36:16 - take a look at that
36:18 - here is the manual page for the clear
36:20 - command it clears the terminal screen so
36:23 - i'm going to hit q to get out of here so
36:26 - i have a bunch more stuff
36:28 - let's just pretend that's all valid
36:30 - commands i want to get rid of it clear
36:33 - all right nice and easy now let's take a
36:35 - look again at the man page for clear
36:38 - this is on ubuntu
36:41 - and i want to talk about this right here
36:43 - the synopsis
36:44 - so we see the name it's clear here's a
36:47 - little description it clears the
36:48 - terminal screen nice and easy
36:50 - now the synopsis is actually showing us
36:52 - the syntax the accepted options and
36:55 - values we can pass to the clear command
36:58 - so clear is a command that accepts an
37:00 - option we can see
37:02 - if you see anything in square brackets
37:04 - here it means it's optional
37:06 - so you can pass this in you can pass
37:08 - this
37:08 - uppercase v lowercase x now what does
37:11 - that mean
37:12 - well commands accept options that alter
37:14 - their behavior you can change how a
37:17 - command functions so if we scroll
37:19 - further down
37:20 - we can see under options a description
37:23 - of what these different options do
37:26 - now the one i want to talk about is dash
37:28 - x now i don't use this frequently but
37:30 - it's just a good intro to options here
37:32 - it says that it does not attempt to
37:34 - clear the terminals terminal's
37:35 - scrollback buffer
37:37 - using the extended e3 capability i have
37:39 - no idea what that part means but what
37:41 - this means overall is that when we clear
37:44 - with the dash x option
37:46 - it is not going to clear our scroll
37:48 - history so i'm going to get out of here
37:50 - and demonstrate this so i'm going to hit
37:51 - q
37:53 - and let's make some history in here
37:55 - hello there
37:57 - i
37:58 - love you okay none of those are valid
38:00 - commands
38:02 - i can scroll back and you know see those
38:04 - commands and if i type regular clear
38:08 - it's gone i can't scroll back that
38:10 - history is gone now if i recreate some
38:13 - of that hello there i
38:15 - love you a lot if i use clear but this
38:20 - time i provide dash x and that's our
38:23 - first example of an option uh there will
38:25 - be tons of commands we see that accept
38:27 - options and they drastically they can
38:29 - drastically change the behavior of a
38:30 - command i'm going to hit enter
38:33 - and it clears
38:34 - but i can scroll
38:36 - so i don't use that often honestly
38:39 - i'm not showing it to you because it's
38:40 - something you need to know i'm showing
38:42 - it to you because it's an intro to
38:44 - options
38:45 - now one more thing i mentioned there's a
38:46 - shortcut and i don't really type the
38:48 - clear command anyway
38:49 - the shortcut is ctrl l so if i have a
38:52 - bunch of stuff again i want to get rid
38:53 - of it
38:54 - ctrl l and it's gone so that's
38:57 - definitely easier than typing clear
38:59 - it also works over here on my mac it
39:01 - works on wsl just control l
39:05 - okay so that's the clear command nice
39:07 - and easy the next command is also nice
39:09 - and easy it is pwd
39:12 - it stands for print working directory
39:15 - and this is a command that just tells us
39:17 - our current location in a given terminal
39:19 - window
39:20 - so let's start with man pwd
39:23 - and it tells us pwd prints the name of
39:25 - your current slash working directory so
39:28 - just like when we have i'll open up my
39:30 - file explorer here with my graphical
39:32 - user interface using my mouse
39:35 - i have a current directory that i'm
39:37 - inside of i'm viewing right now my
39:39 - desktop as you can see it's selected
39:40 - there
39:41 - or i can view documents
39:44 - or i can view my home folder
39:46 - this would be my current working
39:48 - directory home
39:49 - in this window right here but in a
39:51 - terminal it's a little bit different let
39:53 - me get out of this man page here hit q
39:56 - if i type pwd
39:58 - it tells me in text where my location is
40:02 - so in this window i am on the desktop
40:04 - which is located in the cult folder
40:06 - instead of slash home
40:08 - over here this is a different terminal
40:11 - window it has a different location just
40:13 - like i can have multiple file picker
40:15 - windows here's another one this one's in
40:17 - my home directory and this one's in
40:19 - desktop same idea so i can have in this
40:23 - case pwd a terminal window that is in
40:26 - slash home slash cold slash bin and
40:28 - here's one more different window
40:31 - a much longer path this is the full path
40:33 - to get to my location
40:35 - now i haven't shown you how to move so
40:38 - you probably don't
40:39 - have something like this set up with
40:41 - these different windows
40:42 - by default you can actually configure
40:44 - the default location of a new terminal
40:46 - window for me when i make a new terminal
40:48 - window just click that button there you
40:50 - can also use a shortcut it defaults to
40:52 - the desktop at least on ubuntu over here
40:54 - on my mac when i make a new window it
40:56 - defaults to what is called my home
40:58 - directory slash users slash my username
41:01 - you can configure all of this but it
41:03 - doesn't really matter where you are at
41:04 - the moment all that matters that you can
41:06 - find it by typing pwd
41:09 - alright so the next command we're going
41:10 - to cover is called ls the ls command is
41:13 - short for list and we use it to do just
41:16 - that it will list the contents of a
41:18 - folder so we can see
41:20 - what is inside of a directory
41:22 - you know normally if you're using a
41:24 - graphical user interface you don't need
41:26 - a command you just can see the contents
41:28 - of a folder but in a terminal window
41:31 - that is not how things work at all we
41:33 - have to ask for a list of the contents
41:36 - so here i'm on my desktop
41:38 - as we can see i ran pwd it says slash
41:41 - desktop you can also see my prompt is
41:43 - displaying desktop there as well
41:46 - that is also something you can configure
41:48 - by default though on ubuntu it does show
41:50 - you your current location
41:52 - anyway if i actually look at my desktop
41:54 - i can see a bunch of stuff there
41:57 - and i can list it out using the ls
42:00 - command
42:01 - so if i run ls with nothing else just ls
42:04 - it's going to list the contents of
42:05 - whatever current directory i'm inside of
42:08 - in this window it's the desktop and here
42:10 - we go we get a bunch of text so we see
42:13 - things like you know my folders uh some
42:15 - of them are quite odd here i've got
42:17 - wildlife i've got uh i've got files like
42:20 - greatgatsby.txt
42:21 - so there's some different colors and
42:23 - folders for me our bolded
42:25 - files are not bolded and they're just
42:27 - showing up white but that's all
42:29 - configurable as well
42:31 - but this is showing me all the contents
42:32 - of my desktop if i try it somewhere else
42:35 - here i'm in this slash bin directory
42:37 - i'll type ls i see different contents
42:40 - uh here that's my desktop desktop
42:44 - all right well let's try it on my mac
42:45 - here this is my home directory
42:48 - um i see a bunch of other stuff right
42:50 - this is different i see folders for my
42:52 - courses i make my desktop my documents
42:56 - labs some random things that you need to
42:58 - get rid of like hello.js and
43:00 - orange.python
43:02 - those are my files and folders
43:04 - now we also can provide a folder that we
43:07 - want to look inside of we can provide a
43:09 - path to ls so instead of just looking at
43:12 - our current location i could peak
43:14 - somewhere else
43:15 - so for example
43:17 - right here
43:18 - let's see i'm on my desktop
43:20 - and we saw that there is a wildlife
43:23 - folder
43:24 - on my desktop i could ask what is inside
43:27 - of there by running ls
43:29 - wildlife and i can tab complete so i
43:31 - don't have to type the whole thing
43:33 - and hit enter
43:35 - and i have no idea why i have a wildlife
43:37 - folder that contains three
43:40 - text files called angela one and nico
43:42 - survey it doesn't sound like wildlife to
43:44 - me but okay i've got a meal diary folder
43:48 - let's take a look in there
43:51 - and it has nested folders inside
43:54 - so now we can even burrow further in if
43:57 - we wanted to from my current location on
43:59 - the desktop i could look and set a meal
44:02 - diary and look inside of friday
44:05 - by doing this
44:08 - ls meal diary slash
44:11 - fry
44:12 - and i'm using tab complete so i'm giving
44:14 - it a path a path that is beyond it's not
44:17 - just one folder name it's now two
44:20 - that i want it to peak inside of so peek
44:21 - inside of this
44:23 - and we have breakfast dinner and lunch
44:25 - so i can actually run this again and
44:28 - let's see what's inside of breakfast i
44:29 - don't know if there's anything in there
44:31 - i'm gonna recall the previous line by
44:33 - hitting the up arrow and then just add a
44:35 - b and hit tab
44:37 - yeah there's nothing in there no it's a
44:38 - bit of a letdown
44:40 - so that's one example of using ls where
44:42 - we provide a file or rather a folder
44:44 - path but we can provide a full what's
44:47 - called an absolute path to any location
44:50 - on our machine
44:51 - so this file breakfast or this folder is
44:54 - inside of friday is inside of meal diary
44:57 - which is nested in the desktop which is
44:59 - where i currently am
45:00 - right pwd i'm on the desktop but maybe i
45:04 - want to see what's inside of my
45:05 - documents folder and documents is not on
45:08 - my desktop
45:09 - well one option is to do this ls
45:12 - and then the full path to my documents
45:15 - which is slash home slash colt slash
45:18 - i think it's uppercase
45:20 - documents so i'm using tab completion
45:22 - again so i don't type that myself
45:24 - i don't know if there's much in there
45:26 - nope just a single file but we can see
45:29 - kenneth.txt
45:31 - now i could get there right by just
45:33 - opening the file picker going to
45:34 - documents yes i see it
45:37 - but there are some special things that
45:39 - we can do with the ls command in the
45:41 - terminal as well but just to recap what
45:43 - i showed there we can provide what's
45:45 - called a relative path so relative to
45:47 - our current location i could just say
45:49 - show me list the contents of meal diary
45:52 - but that only works if i'm on the
45:53 - desktop
45:54 - if i'm somewhere else i can't just
45:57 - reference meal diary i need to reference
45:59 - the full path
46:00 - and that's exactly what i did down here
46:02 - to get to documents the documents folder
46:04 - is not in my desktop so i can't do ls
46:07 - documents
46:08 - it's going to tell me i don't know what
46:09 - you're talking about that doesn't exist
46:10 - here on the desktop
46:12 - but if i provide the full path this is
46:15 - the unique location the absolute
46:17 - location of documents i can see it's not
46:20 - exciting but i can see there's one file
46:22 - all right so now let's talk about some
46:24 - of the options ls accepts so let's use
46:26 - that clear command or use ctrl l
46:29 - and then let's run man ls
46:32 - it tells us it does list directory
46:34 - contents
46:35 - and then it says that there's a bunch of
46:37 - different options and i'm going to
46:38 - scroll through them these are all the
46:40 - options
46:42 - a lot of them
46:43 - most of them i don't use
46:45 - doesn't mean they're not useful they're
46:47 - just there's a lot
46:49 - i want to highlight two that are very
46:50 - useful the first one is dash l
46:54 - so let's find it here
46:56 - dash l come on h i j k l
47:00 - doesn't tell us much but it says it will
47:02 - use a long listing format so this means
47:05 - i can take a look around with ls
47:08 - and rather than just getting the file or
47:10 - folder name i can instead add dash l
47:14 - and get a whole bunch of other
47:15 - information
47:17 - so there's a lot we're not going to go
47:18 - over here but there's file permissions
47:20 - there's the owner of the file
47:22 - there's the group owner there's file
47:24 - size information
47:26 - modification date the file name so a lot
47:29 - of stuff here
47:31 - for each individual file
47:33 - so that is dash l
47:35 - now another thing we'll take a look at
47:36 - another option i'm going to go back to
47:39 - man ls
47:40 - is dash a
47:42 - now dash a you can also do the longer
47:45 - form dash dash all
47:47 - all it says is that it does not ignore
47:49 - entries starting with a dot when i just
47:52 - type ls i don't see any files or folders
47:54 - that start with a dot
47:56 - ls dash a
47:58 - i now see quite a few
48:01 - dot bash a bunch of stuff
48:03 - dot profile dot less something dot
48:06 - pseudo something there's probably some
48:08 - different ones on your machine i'll just
48:09 - try another example here ls-a
48:11 - on my mac lots and lots of files that
48:14 - start with dot
48:15 - they don't show up if i do a regular ls
48:18 - which you can see right there
48:20 - nothing starts with a dot
48:22 - now we can combine options as well
48:24 - so if i want to and clear this screen i
48:27 - can do ls dash a
48:29 - to see all files including ones that are
48:31 - hidden dash l i want the long format
48:34 - that is one way of doing it but the much
48:36 - shorter and more common way is actually
48:38 - just using a single dash and put your
48:40 - options together so dash a l or dash l a
48:44 - i see the long format
48:46 - all the information for regular files
48:49 - and files and folders that start with a
48:51 - dot so we're getting both of those
48:53 - options uh taking effect at the same
48:55 - time
48:56 - so that's an intro to the ls command so
48:58 - we've seen how to find our current
49:01 - working directory where we are and list
49:03 - the contents of that directory now how
49:06 - do we move around how do we do the
49:08 - equivalent of what i'm doing right here
49:10 - in the file explorer
49:12 - double clicking on
49:14 - you know desktop and then going into
49:16 - this folder or going back how do i move
49:20 - around like i am right here
49:22 - well in the terminal the way that we do
49:24 - that is by using the cd command cd is
49:27 - short for change directory now the first
49:30 - thing you'll notice if you try and read
49:32 - the man page for cd
49:34 - it does not exist
49:36 - it just isn't there when i try it on my
49:38 - mac
49:39 - i see something but it is not a man page
49:42 - 4 cd if we look up here it's a man page
49:46 - for
49:47 - a bunch of commands tons and tons of
49:49 - commands including cd well what's going
49:52 - on here is that the cd command is
49:54 - actually implemented by the shell we
49:56 - don't need to dive into the specifics
49:57 - really at all just i want you to know
49:59 - that you're not going to find a super
50:01 - helpful man page for cd it's one of the
50:03 - few commands that we'll cover that does
50:05 - not have a man page however you can run
50:07 - help it's a different command
50:09 - it's like the shell's version of man
50:11 - help space cd
50:14 - and it's kind of annoying it just prints
50:16 - out text
50:17 - you don't enter that program where you
50:18 - can scroll nicely it just takes up a
50:21 - whole bunch of text but it does tell us
50:23 - it changes the shell working directory
50:26 - change the current directory
50:28 - there are some options we're not really
50:30 - going to use those however
50:32 - let's just see how it works so i'm going
50:34 - to clear my screen first of all remind
50:36 - you where i am in this window i am in my
50:39 - home
50:40 - cult folder
50:41 - if i type ls
50:43 - i see a bunch of other folders so let's
50:45 - say i want to move into one of those
50:47 - folders how about my desktop
50:50 - well the way that i do that is by
50:51 - writing cd
50:52 - and then specifying that path
50:55 - so i'm just going to do d e tab
50:58 - hit enter
50:59 - and you'll see my prompt changes
51:02 - if i type pwd you can see my location
51:04 - has changed to be home slash cult slash
51:07 - desktop
51:08 - before it was just home slash colt
51:10 - so i just jumped i just double clicked
51:13 - into that folder but i didn't click
51:15 - anything it was all done via the
51:16 - terminal
51:17 - so i type ls i'm on the desktop now
51:20 - let's go into the meal diary folder cd
51:23 - into meal diary
51:26 - all right and we're now in here
51:29 - i can cd into how about friday
51:34 - type ls or pwd you can see
51:37 - i'm now at this pretty long path
51:40 - if i type ls let's cd into
51:44 - breakfast
51:45 - so that's a really common thing ls and
51:47 - then immediately after cd you you use ls
51:50 - to look around and then cd
51:52 - to change directories into something
51:53 - that you just found
51:55 - so now i'm in this folder breakfast and
51:57 - i've hit a dead end there's no more
51:58 - folders to cd into
52:00 - uh how would i back out right normally
52:05 - if i did the exact same thing so on my
52:07 - desktop with the graphical user
52:08 - interface it was
52:10 - meal diary is that right
52:13 - if i can find that
52:14 - i double click friday breakfast
52:17 - okay how do i go somewhere else well i
52:20 - have a bunch of options i can hit the
52:21 - back button i can use these buttons up
52:24 - top to jump around
52:25 - but here
52:27 - how do i go back with the cd command
52:29 - well the answer is to use cd followed by
52:33 - dot dot
52:34 - so two dots is a special path that
52:36 - indicates or it refers to the parent
52:38 - directory
52:39 - so it's how i can back up one folder
52:42 - right now i'm in breakfast
52:45 - if i cd
52:46 - dot dot
52:49 - now i've gone back one level into friday
52:53 - pwd you can see i'm in friday type ls
52:56 - this is the contents of the friday
52:58 - directory
52:59 - so that's how i can go back one level i
53:01 - can go back further
53:04 - and repeat it
53:06 - and now i'm back on my desktop
53:08 - now i can also instead of just cding
53:11 - into one folder at a time one level at a
53:14 - time i can jump to any location on my
53:17 - machine as long as i have the full
53:19 - correct path
53:21 - so if i wanted to go back to
53:24 - where we just were which was this
53:26 - location here right desktop meal diary
53:29 - friday slash breakfast i could do that
53:31 - in one step cd
53:34 - and then meal diary slash friday i'm
53:37 - using tab slash breakfast
53:39 - so i don't have to do three separate cds
53:42 - i can jump as many levels as i want and
53:45 - the same actually goes for moving
53:46 - backwards
53:48 - i don't have to do cd dot dots enter cd
53:50 - dot dot enter uh if i want to move back
53:53 - multiple levels i can chain it together
53:56 - i can do this this is one option
53:58 - so it's a little clunky to do it this
54:00 - way but it does work
54:02 - so this is going to take me back one
54:04 - parent folder and then its parent folder
54:06 - and its parent folder
54:08 - and now i type pwd i'm back on the
54:11 - desktop
54:12 - i can also pass in absolute path to cd
54:15 - so everything we've done has been
54:17 - relative to our current location but if
54:19 - i want to go to my documents folder well
54:22 - it's not here it's not in the desktop i
54:24 - can't do cd documents if i try
54:27 - it doesn't know what documents folder
54:29 - i'm talking about it's only looking in
54:31 - my current location and there's nothing
54:33 - called documents on the desktop my
54:35 - documents folder is located at this path
54:38 - it is slash home slash cult slash
54:42 - documents
54:44 - and i can jump right there it doesn't
54:46 - matter where i am i can run that command
54:48 - anywhere
54:49 - and i'll be able to get to documents i'm
54:51 - now in documents
54:53 - one other note around cd and path names
54:56 - you'll see this tilde that refers it's a
54:59 - shorthand
55:00 - that is eventually expanded into your
55:02 - home directory now it's kind of
55:04 - confusing because this is called home
55:06 - but the home directory for each user is
55:09 - a directory with their username so for
55:12 - me it's colt
55:13 - so if i cd to tilde
55:16 - and i do pwd it takes me to slash home
55:18 - slash colt if you cd to tilde it will
55:21 - take you to whatever your usernames
55:23 - folder is and this folder is a very
55:25 - important place it has the desktop it
55:28 - has documents downloads a whole bunch of
55:30 - stuff you can put your own things in
55:31 - here too but even just if you do nothing
55:33 - it contains a lot of important folders
55:35 - and documents
55:36 - uh so that's kind of the basics of cd
55:39 - you can cd into a location that's
55:41 - relative to where you are like
55:43 - desktop
55:45 - i can do multiple levels at once i can
55:47 - back out with cd.dot
55:49 - we combine it often with ls take a look
55:52 - around where do i want to go let's go
55:54 - into
55:55 - wildlife cd wildlife
55:58 - okay i got some stuff in here
56:00 - and
56:01 - i'm not gonna do anything with it let's
56:03 - back out and i can also pass an absolute
56:06 - path at any point uh which is again a
56:08 - full path name not relative to our
56:11 - current location
56:12 - so that is the cd command so next up i
56:15 - want to talk a little bit more about
56:16 - folder structure
56:18 - and how things are organized if you
56:20 - noticed when i talked about absolute
56:21 - paths all absolute paths started with a
56:25 - forward slash and the reason for this is
56:27 - that the very very highest level
56:30 - directory on our machine is the slash
56:34 - directory also known as the root
56:36 - directory which is really confusing
56:39 - people call this root but there's also a
56:42 - directory called root r-o-o-t
56:45 - definitely confusing uh in the same way
56:47 - that people refer to uh you know my home
56:50 - directory
56:52 - colt if that's my username that would be
56:54 - colt's home directory but there's also a
56:56 - directory called home
56:58 - it's uh yeah it's not the most
56:59 - straightforward thing so the top level
57:01 - directory is slash we can actually go
57:04 - there if we wanted to
57:06 - from anywhere on my machine i can do cd
57:08 - slash
57:09 - and if i take a look around
57:10 - we've got a bunch of stuff that we
57:12 - normally don't mess with at least not as
57:14 - a typical day-to-day user
57:16 - if you start writing scripts if you
57:18 - start doing admin stuff absolutely there
57:21 - are changes you can make here but we can
57:23 - look around there's a bunch of different
57:24 - files or folders and things called uh
57:27 - sim links that we'll learn more about
57:29 - later on in this video
57:31 - um and that's kind of all i'm going to
57:33 - show in this directory because there's
57:35 - just so much here
57:37 - uh but what i want to mention is that
57:39 - your desktop your documents your music
57:42 - your whatever files and folders you make
57:45 - typically are going to live inside of
57:48 - the home directory
57:50 - inside of your particular username
57:53 - so for me my username is colt we can
57:55 - always find that out if i need to it's
57:57 - also just right here in my prompt cult
58:00 - so i can go into the home directory
58:04 - i'll cd into that
58:06 - if i take a look around every user on my
58:08 - machine has their own unique home folder
58:12 - so carrots cult elvis and kitty
58:15 - let's take a look at kitty's directory
58:18 - whoops not kits
58:20 - kitty
58:21 - and you can see we've got desktop
58:23 - download documents pictures and all the
58:25 - stuff that we would expect i'll back out
58:27 - again
58:28 - and then i'll go into
58:30 - colt and this is where we've been
58:32 - working
58:33 - now
58:34 - i just wanted to reiterate how this all
58:36 - works slash is the root it's the top
58:39 - level directory on our machine we cannot
58:41 - go higher than that if i try and go to
58:44 - slash and then
58:45 - back out
58:47 - i'm not going anywhere i'm just staying
58:49 - right there at slash
58:51 - now as i said every absolute path starts
58:54 - with a slash because an absolute path is
58:56 - the full location
58:58 - the unique full location to reference a
59:01 - particular file or folder so it always
59:04 - starts with a slash
59:05 - now another character that we've talked
59:07 - about briefly is the tilde here which
59:09 - refers to your individual home directory
59:13 - so if i cd to tilde
59:15 - i'm logged in as colt that will take me
59:18 - to
59:19 - slash home slash colt as you can see
59:23 - right here
59:24 - okay
59:25 - and that's all i really wanted to
59:27 - mention around folder structure of
59:28 - course there's a lot more there's all
59:30 - these folders there's dozens of folders
59:32 - here that we're not going to discuss
59:34 - everything we're doing lives inside of
59:36 - our particular username home folder so
59:39 - slash home slash lily slash home slash
59:42 - colt
59:43 - and then remember this difference
59:44 - between relative and absolute paths if i
59:47 - wanted to go
59:48 - let's see where am i right now
59:50 - i am in my home directory if i want to
59:52 - go on to my desktop from here i can just
59:55 - cd into desktop that is relative to my
59:58 - current location but as we talked about
60:01 - that only works if i am in a place where
60:04 - i can view the desktop it's it is in my
60:06 - current folder so basically the only
60:09 - place this would work is from my home
60:11 - directory right here
60:13 - but if i go to slash i'm not going to be
60:16 - able to just cd into desktop
60:19 - i can't auto complete there is no
60:21 - desktop right here
60:23 - so i need to use an absolute path and i
60:25 - could do the full long name cd slash
60:28 - home slash cold
60:30 - slash
60:31 - desktop like that
60:33 - or i can do the slightly shorter version
60:36 - use that tilde character which refers to
60:38 - my home directory slash desktop
60:41 - okay
60:42 - moving on the next command we'll cover
60:44 - has to do with making directories or
60:46 - making folders it is mkdir or make deer
60:51 - mcdurr
60:52 - however you want to pronounce it
60:54 - it is short for make directory
60:56 - and that's exactly what it does it's the
60:58 - command we use to make folders
61:00 - so the basic way we run it is make
61:02 - directory or make deer space and then
61:05 - some folder that we want it to create
61:06 - for us and it will create that folder so
61:10 - let's try it i'm going to cd just onto
61:12 - my desktop
61:15 - i'm going to clear control l
61:17 - and i'm going to make a new folder here
61:19 - i'm going to make a folder called
61:21 - greenhouse i have a new greenhouse
61:23 - actually and
61:25 - i need to manage the crops that i'm
61:28 - growing and starting seeds and bills and
61:31 - maintenance and time sheets for
61:33 - employees i don't know that's just
61:34 - that's the story i'm going with
61:36 - i'm going to make a folder called
61:37 - greenhouse on my desktop so i'm on the
61:39 - desktop right pwd there's no folder
61:42 - called greenhouse you can see it's
61:44 - alphabetical there's it goes from great
61:46 - gatsby grep exercise keys
61:48 - so if i run make directory
61:51 - and then greenhouse
61:53 - if that's the name of the folder i want
61:55 - it to make me i'll hit enter
61:57 - we don't see anything happen
61:58 - but if i type ls again
62:01 - we now have a folder called greenhouse
62:03 - and if i just move this out of the way
62:06 - you'll see on my desktop there's
62:08 - greenhouse it's totally empty it's an
62:10 - empty directory
62:11 - so i can cd into that folder
62:14 - and that's exactly what i'll do cd into
62:16 - greenhouse oops i hit enter too early
62:19 - green house there we go i use tab
62:22 - complete again
62:23 - and now i'm in here
62:25 - so we can also make multiple folders at
62:26 - once you just separate their names by
62:28 - spaces
62:30 - so i'm going to make
62:31 - a winter and summer directory inside of
62:34 - greenhouse make directory winter
62:37 - and summer
62:38 - so i can have you know different
62:39 - schedules for what i'm growing in summer
62:41 - and winter
62:43 - i'll type ls and we see those two
62:45 - folders were just created for me in my
62:47 - current location right that's all i
62:49 - specified was summer and winter i didn't
62:52 - say any fancy path
62:54 - but what i can do
62:55 - is actually provide
62:57 - if i wanted to make inside of summer i
62:59 - wanted to make a folder called
63:02 - how about you know seeds
63:04 - i could do make directory
63:07 - summer
63:08 - slash
63:09 - seeds
63:11 - so i'm inside of greenhouse but i'm not
63:13 - inside of summer
63:14 - so in other words i'm right here in this
63:17 - folder
63:18 - i'm not going to go into summer and then
63:20 - make a folder in two separate steps i'm
63:22 - doing it in one step i just provide a
63:24 - path
63:25 - make the seeds directory instead of
63:26 - summer i'll hit enter
63:29 - okay
63:30 - type ls i don't see it
63:32 - but if i do ls summer
63:35 - there we are i'm looking inside that
63:37 - summer directory
63:39 - there's my seeds folder
63:41 - okay
63:42 - now one last thing i'll show you there's
63:45 - an option that's pretty common which is
63:47 - dash p
63:48 - which allows us to make nested folders
63:51 - so why don't we just take a look at the
63:53 - man page man for make directory
63:56 - and we'll scroll down
63:58 - here's p
63:59 - or the long form dash dash parents
64:02 - it says no error if existing make parent
64:04 - directories as needed
64:06 - so let me show you what it means when it
64:08 - says no error
64:09 - so inside of the winter folder which
64:12 - i'll just point out here
64:14 - graphically i want to make a seeds
64:16 - folder and instead of seeds i want to
64:18 - make a
64:19 - lettuce folder
64:21 - so if i try and do that all at once i'm
64:23 - inside of greenhouse if i do make
64:25 - directory winter slash seeds let me just
64:28 - expand this window a bit here
64:32 - winter seeds slash
64:34 - did i say spinach no i said lettuce
64:36 - if i hit enter here
64:38 - i get an error it says can't create such
64:41 - directory it runs into a problem because
64:43 - it expects that winter slash seeds
64:47 - already exists and it thinks it just
64:49 - wants us or we just want it to make
64:50 - lettuce that's not the case i want it to
64:52 - make seeds and lettuce
64:54 - but seeds doesn't exist it freaks out
64:57 - but that's where the dash p option comes
64:59 - in so make directory dash p
65:02 - winter
65:03 - seeds
65:04 - slash lettuce we're now telling it make
65:07 - any of the needed parent directories
65:08 - along the way to make this lettuce
65:10 - directory
65:12 - we don't get an error and if i type ls
65:14 - here we don't see anything but if i do a
65:17 - lswinter
65:19 - we see seeds if i do ls winter seeds we
65:23 - see lettuce so it successfully made that
65:25 - nested
65:26 - directory and any necessary directories
65:29 - along the way
65:30 - so here's we go back winter
65:33 - it made me seeds and inside of that it
65:35 - made the lettuce so that's the dash p
65:38 - option and that's really all there is to
65:40 - make directory so mkdir followed by
65:43 - whatever directory you want it to make
65:44 - and some location for that directory
65:47 - often it's just your current location
65:49 - but you can provide a path a destination
65:52 - as well so if i wanted to make something
65:53 - all the way back in my home directory
65:56 - which again i can use tilde as a
65:59 - shortcut i could say make directory
66:01 - tilde slash
66:03 - blah blah i'm going to delete this once
66:05 - i learn how to delete folders
66:07 - i won't see anything here
66:09 - but if i go all the way back to my home
66:11 - directory
66:12 - there it is
66:13 - right there
66:14 - so we can provide a relative path an
66:16 - absolute path we just give it some
66:18 - destination to make a folder and it
66:20 - makes it for us that's make directory
66:22 - the next command we'll cover is touch so
66:24 - touch unlike most of the other commands
66:26 - doesn't really tell you a lot about what
66:28 - it does or its name doesn't indicate its
66:31 - most common use make directory makes a
66:33 - directory uh you know change directory
66:35 - changes directory touch is used most of
66:38 - the time at least to create files
66:41 - so there's no create file or make file
66:44 - it's just touch so uh we'll talk about
66:47 - where that name comes from in a moment
66:49 - but let's just try using it if we run
66:51 - touch and we provide it with a file name
66:53 - that doesn't yet exist it will make that
66:56 - file for us so let me go to my desktop i
66:59 - made a greenhouse folder
67:01 - deny and then summer and winter let's cd
67:03 - into summer
67:05 - cd into seeds and let's make some files
67:08 - here
67:09 - so let me clear my screen i'm going to
67:11 - make a file in here there's nothing at
67:13 - the moment i'm going to make a file
67:14 - called
67:15 - how about squash
67:17 - so squash i'm going to have a file full
67:19 - of different types of squash seeds i
67:21 - guess so if i just run squash as is
67:24 - that's totally fine
67:26 - squash if i type ls it made that file
67:29 - for me i'll just show it to you also
67:31 - visually if i go to my desktop
67:34 - i'll go to greenhouse if i can find it
67:37 - summer seeds here's my empty squash file
67:40 - i can open it it's completely empty
67:44 - okay so that's one option
67:46 - i can also provide
67:48 - an extension as i'm making a file so if
67:50 - i want to make a txt file i can do dot
67:52 - txt so let's make another one how about
67:56 - berries how about just melon
67:59 - another summer fruit
68:00 - dot txt
68:03 - and i now have a txt file called
68:05 - melon.txt
68:07 - now it's important to note that the
68:09 - extension you provide it does depend on
68:11 - the exact operating system you're
68:13 - running but the extension does not
68:14 - indicate
68:16 - it doesn't it's not what's used to
68:17 - determine the actual file type
68:20 - of a brand new file so these are all
68:22 - empty files i could make a pdf file if i
68:24 - wanted to touch
68:27 - apple.pdf
68:29 - it's not really summer but
68:31 - if i type ls we've got an apple.pdf
68:34 - but they're all just completely empty at
68:36 - this point if i look at any of these
68:38 - files they are just plain old empty
68:41 - files at the moment
68:42 - of course i can put stuff in them i can
68:44 - change that extension there's all sorts
68:45 - of things we can do so let's try another
68:48 - example i'm on my mac here
68:50 - i'm going to touch multiple files so in
68:53 - this directory it's called colors i have
68:55 - a colors.txt file i'm going to make a
68:58 - couple of new files let's go with red
69:01 - dots pdf
69:03 - and then a space orange dots
69:07 - let's see how about png and then yellow
69:10 - we'll do a different extension here how
69:12 - about
69:13 - an excel xls
69:15 - i type ls
69:16 - those files were created they're all
69:18 - completely empty
69:20 - now here is i'm on my mac this is finder
69:23 - the graphical
69:25 - user interface i've got red.pdf
69:28 - orange.png
69:29 - if i try and open one of these just with
69:31 - my mouse
69:33 - on a mac it does try and use preview it
69:36 - does think that it's a pdf and it says
69:38 - it's empty i don't know what to do with
69:39 - that
69:41 - if i try and do a pdf
69:43 - it does use a pdf reader or pdf viewer
69:47 - but again this is just on my mac if i go
69:49 - back to ubuntu here and i open up a pdf
69:53 - it just opens in a text editor if i open
69:56 - up if i make a png file touch what's
69:59 - another fruit how about barry.png
70:04 - if i try and open that
70:06 - oh it uses the text editor as well okay
70:09 - so it does vary from one system to the
70:10 - next
70:11 - but the point is we just make empty
70:13 - files with touch now let's talk about
70:16 - when we provide a name of a file that
70:17 - already exists
70:19 - so if i run touch barry again i can do
70:23 - that i can just hit the up arrow
70:25 - it's
70:26 - not going to seem like it does much it
70:28 - doesn't make me a second file with the
70:30 - same name that would be a problem what
70:32 - it does instead is that it actually is
70:34 - going to update the timestamp of the
70:37 - file
70:38 - so it touches it if we run man
70:42 - touch
70:43 - always a fun command to type out man
70:45 - touch
70:46 - uh it actually says its main purpose is
70:49 - change file timestamps update the access
70:52 - and modification time of each file that
70:53 - we provide
70:55 - so it says here secondarily a file
70:58 - argument that does not exist is created
71:00 - empty
71:01 - so that's why it's called touch rather
71:03 - than make full make file or create file
71:06 - or something its main purpose at least
71:08 - historically is to change the access and
71:10 - modification times of a file
71:12 - and then oh also if that file doesn't
71:14 - exist it will make it as an empty file
71:18 - so how do we know or how can we view the
71:20 - access and modification times if we
71:23 - remember ls-l that flag if we take a
71:26 - look at
71:27 - barry.png here
71:29 - right there
71:30 - october 15 1348 is the modification time
71:35 - that's ls dash l is the long listing
71:37 - format so 1348 let's see it's now 13.50
71:42 - so if i try and touch barry.png again
71:45 - and i do ls-l
71:47 - we now see it's showing october 15th
71:50 - 1350.
71:52 - so it does in fact update that
71:53 - modification time
71:55 - but most of the time 99 of the time that
71:57 - i use touch it's to make files uh and i
72:00 - can make a bunch of them at once as we
72:01 - saw just provide a bunch of file names
72:03 - separated by spaces and it will make
72:05 - them for you
72:06 - okay so we saw how to make files and
72:08 - make folders let's talk about destroying
72:11 - things so to delete a folder we can use
72:13 - the rmdir remove directory command rmdir
72:17 - followed by the name of a folder or a
72:19 - path to a folder that we want to delete
72:21 - or multiple separated by spaces however
72:24 - this will only work if the folder is
72:26 - empty
72:27 - so over here
72:29 - uh i've got
72:31 - i don't have any folders let's make a
72:32 - folder make directory uh delete me in
72:36 - all caps
72:37 - there it is to delete it one option is
72:39 - rmdir
72:41 - delete me i type ls and it's gone
72:45 - but if i back out
72:46 - and i try and delete
72:48 - the seeds folder which is not empty
72:51 - rmdir seeds
72:54 - we get an error failed to remove seeds
72:56 - directory is not empty
72:58 - and that's really all there is to rm
72:59 - deer it removes empty directories only
73:02 - empty directories we'll see another
73:04 - command we can use to remove directories
73:06 - that have stuff inside of them so next
73:08 - up we're going to talk about the rm
73:10 - command rm for remove let's take a look
73:14 - at the man page it says we can use it to
73:16 - remove files or directories
73:19 - so we saw how to use rm deer it only
73:22 - works to remove an empty directory i've
73:24 - got this seeds directory rmd or seeds
73:27 - no luck it's not empty alright
73:30 - so this is where the rm command comes in
73:32 - i'm going to show you how to use it to
73:34 - delete directories in just a moment but
73:36 - we're going to start by deleting files
73:38 - so i'm just going to make a couple files
73:39 - with touch
73:41 - uh how about cat dog carrot
73:44 - um blue
73:46 - all right so i have these four files now
73:49 - i can delete them using rm followed by
73:52 - let's do blue to start uh the name of a
73:55 - file
73:56 - and that's it it is gone now it's very
74:00 - important to note uh there is no
74:02 - intermediate recycling can or trash can
74:04 - or something some sort of bin we can go
74:06 - find all these files we've deleted they
74:09 - are just completely gone they're just
74:11 - vanished from our entire uh system
74:14 - so that can be uh a bit of a scary thing
74:17 - if you're not careful with what you're
74:19 - deleting so you definitely want to make
74:21 - sure you're only ramming things that you
74:23 - mean to rm but the flip side of that is
74:26 - that it's very
74:27 - fast powerful quick and easy to delete
74:29 - things uh just as long as it's not too
74:32 - easy and you slip up
74:34 - so we can delete multiple things
74:35 - multiple files if we just separate them
74:37 - with spaces of course like that carrot
74:40 - cat and dog are all gone
74:42 - so that's the basic use of rm
74:46 - i'll show you one more there's a couple
74:47 - of flags i want to talk about the first
74:49 - flag is dash v
74:51 - this is actually a trend there are many
74:53 - commands that support a dash
74:55 - v for verbose that option in the case of
74:59 - ram will give us some verbose output
75:01 - that that basically explains what it did
75:03 - if you notice here we run it we deleted
75:06 - three things but there's no feedback
75:08 - it's just silently deleting them
75:10 - we had to look to see are they gone well
75:13 - if we use dash v i'm just gonna remake
75:15 - my uh
75:17 - four files again
75:18 - if i use dash v so rm carrot cat dog
75:22 - dash v for verbose
75:24 - now it just tells me what it does each
75:26 - step of the way removed carrot removed
75:28 - cat removed dog
75:30 - pretty straightforward hopefully
75:32 - but the end result is exactly the same
75:34 - you do not need to have that of course
75:36 - it's just something you may want to use
75:38 - some people like to use it
75:40 - and like i said there are other commands
75:41 - like when we see copy cp and move mv
75:45 - we can use dash v for verbose output and
75:48 - it will tell us just copied this file i
75:51 - you know moved this file renamed this
75:54 - file removed okay
75:56 - so
75:57 - that's one flag dash v the next thing i
76:00 - want to talk about is using rm to delete
76:02 - a directory
76:04 - so we talked about rmd or does not work
76:06 - on seeds or any folder that is not empty
76:10 - so that must mean rm will work right
76:12 - let's rm seeds
76:14 - oh no cannot remove seeds is a directory
76:18 - but i thought the whole point was you
76:19 - know rm could delete a folder that has
76:21 - stuff in it
76:22 - yes that is the point uh but we have to
76:25 - use a flag
76:26 - and the flag we need to use is the r
76:29 - flag for recursive so if i do man rm
76:32 - again
76:33 - i'll scroll down
76:35 - a little bit further
76:36 - r so we can do lowercase r uppercase r
76:39 - or dash dash recursive if you really
76:41 - have a lot of time to spend
76:44 - and what this will do is it tells the rm
76:45 - command to remove directories and their
76:48 - contents so that could be other
76:50 - directories and further nested
76:51 - directories there could be hundreds of
76:53 - levels of directories nested down
76:55 - remove them all
76:57 - so here's how we would use it if i want
76:59 - to remove the seeds directory this is
77:01 - what it has inside remember
77:04 - it has four files
77:06 - and i want to remove that entire
77:08 - directory it's just
77:09 - rm-r seeds
77:13 - and once again there's no feedback i
77:15 - could have added dash v and it would
77:16 - tell us more but now it is completely
77:19 - gone
77:20 - that's it
77:21 - so i'm going to make a directory again
77:23 - we'll call this
77:24 - zoo
77:25 - let's cd into zoo i'm just going to
77:27 - touch some random let's see animals cat
77:30 - dog
77:31 - snake
77:33 - i don't know jaguar
77:35 - okay
77:36 - so uh i have that zoo directory now i'm
77:39 - going to back out again
77:41 - this time i'm going to delete it with
77:43 - rm-r
77:45 - but i'm also going to show you a new
77:46 - flag dash i
77:48 - for interactive and interactive
77:51 - is going to prompt us and ask us if we
77:54 - want to delete each file or not so if we
77:56 - do dash i here
77:58 - and then the folder which in this case
78:00 - is zoo
78:02 - now it's asking me do you want to
78:03 - descend into this directory zoo so do we
78:05 - want to go inside and see what's there
78:07 - i'm going to say y for yes or if i said
78:09 - no then we kind of end it all but i'll
78:11 - do y
78:12 - do i want to remove regular empty file
78:15 - snake
78:16 - yes
78:17 - cat y for yes
78:19 - let's keep jaguars i'm going to say no
78:22 - dog
78:23 - yes
78:24 - and now it's asking me do you want to
78:26 - remove the directory zoo uh i'm going to
78:29 - keep it
78:31 - so that interactive mode allows me to
78:33 - make decisions uh if you're deleting you
78:35 - know 10 000 files maybe not the best
78:37 - option but
78:38 - that is a flag we can use dash i to
78:41 - interactively decide what to delete and
78:43 - what to keep
78:44 - so now if i look at zoo
78:47 - it only has the jaguar file inside
78:51 - one more quick demo i want to show you
78:53 - i have a
78:54 - let's see where did i put that my
78:56 - desktop a directory called meals
78:59 - and inside of meals i made 52 folders
79:04 - one for each week of the year and inside
79:06 - of each week if i just pick one like
79:08 - week 35
79:10 - there is a folder for each day of the
79:12 - week and for each one of those days
79:15 - there are three files breakfast lunch
79:17 - and dinner dot txt so we've got three
79:20 - files for each day of the week for 52
79:23 - weeks of the year it's a lot of
79:24 - files and folders nested i'll show it to
79:27 - you here so this is the meals
79:30 - directory
79:31 - all these different weeks
79:33 - pick one
79:34 - pick another day all those files so
79:36 - there's a lot of stuff going on here and
79:38 - i just wanted to show you that i can
79:39 - delete the entire thing very easily and
79:42 - very quickly all those nested folders
79:44 - and files using rm so i'm going to cd
79:46 - back a couple levels
79:49 - one more and one more
79:52 - just to reiterate you know i don't need
79:54 - to do cd dot dot cd dot cd dot dot to go
79:57 - back three levels i could have done
80:01 - that right there
80:02 - or i could have just said take me to the
80:05 - desktop specifically
80:07 - so this would work from anywhere
80:10 - this cd dot dot cd dot dot cd dot dot
80:13 - only works if i'm three levels away you
80:15 - know three levels burrowed down from the
80:17 - desktop if that makes sense this will
80:20 - work from anywhere
80:21 - anyway
80:22 - i have this meals directory i'm going to
80:24 - remove it i need to do a dash r
80:26 - and i'm going to make it verbose so you
80:28 - can see exactly how many things it
80:31 - removes in a single go so this is just
80:33 - one command remember no recycling bin no
80:35 - trash can these files are gone so you
80:38 - obviously want to be careful but here we
80:39 - go rm dash r for recursive so we can
80:42 - delete a directory that has stuff in it
80:44 - and dash v for verbose
80:47 - and
80:48 - if i scroll up i'm going to be scrolling
80:50 - for a long time
80:51 - lots and lots of files and folders
80:53 - deleted in a split second so that's the
80:56 - rm command it also does work to remove
80:59 - empty directories
81:00 - so um in that sense you kind of never
81:03 - have to use rm deer i just show it as a
81:07 - quick you know command that you may
81:08 - encounter some people like it
81:11 - because
81:12 - you know that you're not going to be
81:14 - accidentally deleting stuff that has a
81:15 - bunch of contents inside of it but you
81:18 - could just use the rm command in general
81:20 - to delete files delete empty folders or
81:23 - delete folders full of a bunch of stuff
81:25 - as long as you use the dash r option all
81:28 - right so that is rm the next command
81:31 - i'll show you is one i use all the time
81:32 - on my mac it's called open
81:35 - and it will open a folder open a file
81:39 - outside of the terminal in the the sort
81:41 - of graphical world of our machine so if
81:44 - i make a bunch of files
81:47 - like uh
81:48 - i don't know how about purple i'll just
81:50 - make one dot txt if i now want to
81:53 - do something with that file i don't know
81:55 - i want to view it in finder well i could
81:58 - navigate to it and figure out where this
81:59 - is or i can do open
82:02 - i could do open dots that will open the
82:04 - current directory and here we go a
82:06 - finder window with that directory but i
82:09 - could also say open that particular file
82:12 - and it opens it up in the default
82:14 - application which is just a text editor
82:16 - on my mac
82:17 - but if i had some other file you know i
82:19 - can find an example here
82:21 - if i go to my desktop which i edited out
82:24 - i've navigated here i've got a file uh
82:26 - let's see
82:27 - i've got a pdf file if i open that
82:32 - it opens it up in my case using a pdf
82:34 - editor the
82:36 - default you know what it would open with
82:38 - if i double clicked anyway so that's the
82:40 - open
82:41 - command but it is mac specific so again
82:44 - i can do things like open dot to open
82:45 - the current directory i can see all my
82:47 - files and you know work with them here
82:49 - if i need to
82:50 - i can open a particular file and it's
82:53 - pretty smart
82:55 - but if i try this on ubuntu here
82:59 - i've got two directories here if i try
83:01 - and open that it's going to complain to
83:03 - me it can't do it it doesn't know that
83:05 - command
83:06 - now there is an alternative which is x d
83:08 - g dash open
83:11 - and uh there we go it opens up you know
83:13 - in this case this folder for me
83:15 - if i have a file just call it touch
83:18 - tomato.js
83:20 - if i do xdg dash it's a bit of a
83:23 - annoying one to type but
83:25 - open tomato
83:27 - it opens up the text editor and i can
83:30 - start working on this file
83:32 - now you may need to install it just to
83:34 - be clear i think if on wsl here if i try
83:37 - xdg open dot
83:39 - well i need a dash there
83:42 - it complains and it tells me i need to
83:44 - install it using this command so you can
83:47 - install that if you want
83:49 - but this is one of the main differences
83:50 - here open is a mac only command it might
83:53 - be one of the i think it's the only one
83:54 - we cover in this video that is different
83:57 - between mac and ubuntu or linux the next
83:59 - command we'll look at is mv for move
84:02 - this is how we can move files around
84:05 - it's also how we can rename files and
84:07 - that's going to be the first use case
84:09 - i'll show you if we run mv
84:11 - followed by an existing file and then a
84:14 - space and then a new file name
84:16 - what this will do is
84:18 - move pair
84:20 - turn it into new pair it will rename it
84:23 - so let's try an example here
84:25 - uh oh got a lot going on here why don't
84:27 - i make a new directory in here i'll just
84:29 - call this um commands
84:32 - i'll cd into there okay
84:34 - i'm gonna make a file in here and i'm
84:36 - gonna call this my journal
84:39 - but i spell it wrong like that
84:41 - and i wanna rename it i can use move let
84:45 - me just show you there it is i can use
84:47 - move and then the incorrect name
84:49 - journal.txt
84:51 - and then the new one
84:53 - just like that
84:54 - and again you may not get this verbose
84:56 - output that's just a setting i have but
84:59 - if we type ls we see journal.txt
85:03 - now if you do want that verbose output
85:05 - just for any of these commands
85:08 - like
85:09 - rm if i do m
85:11 - v i get the man page for mv
85:13 - there's an option in here
85:15 - further down
85:17 - dash v which explains what is being done
85:19 - so if you want to know exactly what's
85:21 - going on let's say i want to rename
85:24 - journal
85:26 - the correct version i want it to now be
85:28 - an uppercase j i don't know why
85:31 - if you add dash v
85:33 - which mine have by default you'll get
85:35 - that verbose output honestly i only put
85:37 - that in there when i'm teaching so
85:38 - people can see what's going on i don't
85:40 - really care to get that confirmation it
85:43 - yeah it's gonna work either way and we
85:45 - can see it's been renamed
85:47 - now we can also use move to change the
85:50 - location uh not just rename you know in
85:52 - the same directory but to move a file
85:55 - back a directory or into a completely
85:57 - different directory
85:58 - so let's find an example of that let's
86:00 - just make a directory here i'll call
86:02 - this one
86:05 - i don't know
86:06 - stuff and i realized shoot i really
86:09 - should have made that journal file
86:11 - inside of stuff
86:12 - well i can move it in there it's pretty
86:14 - easy i can just do move
86:17 - the thing i want to move and then
86:20 - the move command is smart enough to know
86:22 - that if the last parameter the last
86:24 - argument is a folder
86:26 - it will be the destination folder so i
86:28 - can move
86:29 - journal into stuff
86:32 - and if i type ls i don't see journal
86:34 - anymore if i look inside of stuff
86:37 - it's inside our journal is inside of
86:39 - stuff
86:41 - i can also do that to multiple files at
86:42 - once
86:43 - so if i touch
86:45 - i don't know about pi and
86:49 - cake and cookie
86:51 - sure i have these three files if i want
86:53 - to move them into stuff i can do mv cake
86:57 - cookie pie and then as long as stuff
87:00 - comes last it will be the destination
87:02 - folder
87:04 - and there we go they are moved into
87:07 - stuff
87:08 - now there's more you can do with move
87:10 - you can move folders around you can
87:12 - rename folders so if i want to rename
87:14 - stuff instead to be stuff in all caps
87:18 - move stuff to be stuff
87:22 - there we go i just renamed it
87:24 - um so yeah that's probably all i'll show
87:26 - you for move it's pretty powerful i use
87:28 - it all the time to move things around
87:30 - you know i could move this entire stuff
87:31 - directory onto the desktop if i wanted
87:34 - to
87:35 - i could do
87:36 - move
87:37 - stuff
87:38 - and then just have it go back
87:40 - one directory right now i'm on this
87:42 - commands folder i want it to go onto
87:43 - desktop
87:45 - it's not here anymore i'll cd back
87:48 - and here it is on my desktop somewhere
87:51 - there it is this is the one the
87:52 - uppercase stuff all right so let's move
87:55 - the next command i'll cover is cp which
87:57 - is for copy we can use this to copy a
88:00 - file or even copy folders
88:02 - so if i make some file
88:04 - i'm on my desktop here there's just too
88:06 - much stuff going on
88:08 - let's go back to my stuff directory
88:11 - okay so i've got this journal file
88:14 - if i want to make a new copy of it let's
88:16 - say for today's journal sure i'm going
88:19 - to copy it i can do cp
88:22 - the thing i'm copying which is journal
88:24 - and then the destination for the copy so
88:27 - if i wanted to be in the same folder
88:29 - then i don't need to do anything just
88:30 - provide a name so how about
88:32 - today's
88:34 - today journal or something like that
88:37 - and that makes me a copy
88:39 - so i have journal and i have
88:41 - todayjournal.txt
88:43 - now these are all empty
88:45 - so it's not that useful to show but
88:48 - if they had content inside of them
88:50 - like i'm on my mac here i have this
88:53 - linuxcommandhandbook.pdf
88:55 - if i want to make a copy of that cp
88:58 - linuxcommandshanbook.pdf
89:00 - and just give it a new name how about
89:04 - handbook
89:05 - dot pdf
89:07 - just like that
89:09 - if i type ls well there's gonna be a lot
89:10 - of stuff on here but there is a
89:13 - handbook.pdf file
89:15 - and if i open it up
89:17 - or just yeah i'll open it sure
89:20 - you'll see that it is a full copy so
89:23 - it's the entire linux handbook here all
89:25 - these commands we've been covering so it
89:27 - doesn't just copy empty files that's
89:29 - very important we can also copy entire
89:31 - directories so let's go back to ubuntu
89:34 - where are you here we are
89:36 - i've got this stuff directory why don't
89:39 - we copy the entire stuff directory
89:41 - so uh cp
89:43 - stuff
89:44 - and then i want to make a directory
89:46 - called stuff
89:47 - copy
89:48 - well if i try that
89:50 - we have a problem it says dash r not
89:53 - specified omitting directory stuff it's
89:55 - not going to copy this
89:57 - well if we take a look at the man page
89:59 - for cp
90:00 - it tells us if i scroll down there is a
90:03 - dash r option
90:05 - which just like with remove rm stands
90:07 - for recursive so if we want to copy the
90:10 - contents of a directory and any nested
90:12 - directories and their contents and so on
90:15 - we need dash r
90:17 - so let's replace this let's rerun it one
90:19 - more time cp dash r
90:22 - stuff
90:23 - stuff copy i have that dash v verbose on
90:27 - by default again you can turn that on if
90:30 - you want or you can just run it with
90:32 - dash v if you really want this output
90:34 - but here we can see it made a copy of
90:36 - the stuff folder
90:38 - and all of its contents so if we take a
90:40 - look here's my stuff copy
90:45 - and inside of it
90:47 - we have all of these files that have
90:48 - been copied as well
90:50 - so we can make copies like that i can
90:52 - also move as i'm creating a copy so if i
90:55 - want a copy of i don't know song of
90:57 - myself
90:58 - and i want it to go inside of
91:00 - stuff copy
91:02 - or instead of stop whatever let's go to
91:04 - my desktop
91:06 - i could do copy song is it capitalized
91:09 - yes it is song of myself long poem and
91:12 - uh let's actually put it
91:14 - uh sure let's put it inside of stuff so
91:16 - stuff slash and then i'm gonna call it s
91:19 - o song of my self sure psalms dot dxd
91:24 - all right so i'm gonna copy it but i'm
91:27 - also moving it at the same time because
91:29 - where i'm copying it to is a different
91:31 - destination
91:32 - i won't see psalms in here if i look in
91:35 - stuff
91:36 - cd into stuff
91:39 - nope where did i put it
91:41 - well wow i'm an idiot i put it inside of
91:44 - stuff with lowercase how confusing it's
91:47 - not in here it's going to be in this one
91:49 - so if i cd into lowercase stuff
91:53 - there it is
91:54 - soms.txt all right so it is there
91:57 - and that is a copy of that file so that
92:00 - is the cp command the next command we'll
92:02 - take a look at is called head so let's
92:04 - look at the man page for head it says
92:07 - that it outputs the first part of files
92:09 - head and tail
92:11 - are often used to refer in programming
92:13 - to
92:14 - two different ends of a structure in
92:16 - this case a file the head of a file is
92:18 - the beginning the tail would be the end
92:21 - so it's a really simple command it just
92:23 - prints out
92:24 - by default i think it is the first the
92:26 - first 10 lines of a file
92:29 - but we can actually specify an exact
92:31 - number using the dash n option but let
92:34 - me just show you uh so i've got this
92:36 - very long file
92:38 - in here which is song of myself.txt it's
92:41 - like hundreds of lines of long poem uh
92:44 - if i run head
92:46 - song of myself.txt
92:48 - it just outputs the first 10 lines
92:52 - now as we saw i can provide the dash n
92:54 - option followed by a number like 100
92:58 - and it prints the first 100 lines
93:01 - from the beginning of the file
93:03 - so there we go 100 lines and that's kind
93:05 - of all that there is to head
93:07 - now there's also a command called tail
93:10 - let's look at man tail
93:13 - and it unsurprisingly probably outputs
93:15 - the end of a file so by default it's the
93:18 - last 10 lines
93:20 - but we can also provide an exact number
93:22 - using dash n
93:24 - uh and there are some other options here
93:26 - as well but let's just start with that
93:28 - so i'm going to do
93:31 - tail
93:32 - song of myself.txt here are the last 10
93:36 - lines of song of myself
93:38 - but i can also say i want the last 20
93:40 - lines
93:41 - and there we are i get the last 20. now
93:44 - with tail i'm on my mac now
93:47 - there's one option that we don't have
93:48 - with head which is dash f where are you
93:52 - here we are
93:53 - dash f it says it causes tail to not
93:56 - stop when the end of file is reached but
93:58 - rather to wait for additional data to be
94:00 - appended to the input
94:02 - basically it's going to read the end of
94:05 - a file and print it out but then also
94:08 - keep printing out any new additions to
94:10 - the end of that file this can be useful
94:12 - for log files output files error logs
94:15 - things that are changing and you want to
94:16 - monitor them if i just do tail
94:19 - this is a on a mac at least this
94:21 - system.log file it doesn't matter
94:24 - really but it's a file that contains a
94:26 - bunch of stuff i honestly don't know
94:28 - what half of it is
94:29 - and if i don't have that dash f option
94:32 - it just stops this is the last thing
94:34 - printed out but if i add that dash f in
94:37 - there
94:38 - whoops i need to make sure i put dash f
94:40 - in there first
94:41 - now
94:42 - my prompt does not come back
94:44 - this file is being printed out the end
94:46 - of it is being printed out and if i do
94:49 - something that would add to that log
94:50 - file if i i may i make a new window like
94:53 - i just did i'll do it again
94:55 - you can see that that log file is
94:58 - changing content is being appended to it
95:00 - so i'm getting a live and as i close as
95:02 - well you can see things are changing i'm
95:04 - getting a live update as i make a new
95:06 - process or i kill a process
95:09 - from this system.log file
95:12 - whereas if i had just i can get out of
95:13 - here by the way ctrl c
95:15 - but if i had just done tail without dash
95:18 - f
95:20 - it's not live it just stops it shows me
95:22 - exactly what's at the end of that file
95:24 - right now but with dash f it keeps
95:26 - listening and keeps updating the output
95:29 - so that's tail so the next command i'm
95:31 - going to show you is one that i don't
95:33 - really use very much
95:34 - i'm showing it to you actually because
95:36 - it helps illustrate some other concept
95:38 - so the command i'm going to show you is
95:40 - called date it's really straightforward
95:42 - d-a-t-e
95:43 - and it just prints out the current date
95:46 - and time
95:47 - let's see i'm sure there's some other
95:49 - options and different things we can do
95:51 - we can specify how it should
95:54 - display the dates
95:56 - honestly we're not going to go into it
95:57 - because as i mentioned i don't use very
95:59 - much it can be useful though if you're
96:01 - writing a script
96:02 - and you need to get access to the
96:04 - current time or the current date day of
96:06 - the week that sort of thing
96:07 - anyway the reason i'm showing it to you
96:09 - is because i'm using it to illustrate
96:11 - something that is not a standalone
96:13 - command we're going to talk about
96:14 - something called redirection
96:16 - so this greater than sign right here
96:19 - we can use to perform something called
96:22 - redirecting standard output
96:24 - so the date command or really any of the
96:26 - commands we've seen if i do ls
96:29 - not la
96:30 - ls
96:31 - or i do date or pwd
96:35 - all of these
96:36 - generate output and that output by
96:38 - default shows up in our terminal right
96:40 - it's printed out as text here
96:43 - but we can actually redirect where that
96:45 - information goes uh by sending it to a
96:48 - file if we wanted to
96:50 - so i can take the current date
96:52 - and store the result instead of printing
96:55 - it out store it in a file and to do that
96:57 - i use the greater than sign again what
96:59 - we're doing here is redirecting standard
97:02 - output
97:03 - okay
97:04 - so let's make a file i'll show you we
97:07 - don't actually have to make a file first
97:08 - but i'm going to make an empty file i'll
97:10 - call it
97:11 - today.txt
97:12 - uh there it is today.txt all right so
97:16 - what i'm going to do next is redirect
97:18 - date
97:19 - so again the date command
97:21 - greater than sign
97:23 - today.txt and this tells the terminal
97:26 - run this command first but whatever
97:28 - output we get don't just print it out
97:30 - instead we're redirecting the output
97:32 - to this file
97:34 - okay
97:35 - and we don't see any output nothing is
97:38 - printed out
97:39 - if i type ls there we are we see today
97:41 - is still there
97:42 - now in a moment i'm going to show you a
97:44 - command we could use to read this file
97:46 - very easily but we do know head we've
97:48 - already seen that so i could do head
97:50 - today.txt
97:51 - and take a look we see that it contains
97:54 - that text
97:55 - so what do you think will happen if i
97:57 - recall this line
97:59 - and i run it again
98:01 - so take the current date whatever that
98:03 - is that output and send it over to this
98:05 - file
98:06 - the file looks like this right now
98:08 - right
98:09 - if i run it again we'll get a different
98:11 - time it's still friday the 15th of
98:13 - october
98:14 - but it's now for what 27. so this should
98:18 - change
98:19 - um but what you'll notice is that it
98:21 - actually ends up replacing the contents
98:24 - of that file so it's not added as a
98:27 - separate line right we don't have two
98:29 - dates in there now
98:30 - it ended up replacing the entire
98:32 - contents of the file so this is very
98:34 - important if i had a lot of stuff in
98:37 - there
98:37 - for example
98:39 - if i navigate back
98:41 - i have this uh let's see
98:44 - stuff directory lowercase stuff
98:47 - i have this song of myself.txt
98:50 - you do not need to follow along with
98:51 - this but this file contains a lot of
98:54 - text if i just look at the
98:56 - first 10 lines it's the entire text of
98:59 - that poem song of myself
99:00 - now if i try and redirect something in
99:02 - there i can take the output of pwd for
99:05 - example
99:06 - and redirect that
99:08 - into song of myself.txt
99:11 - now that is the only thing in that file
99:15 - the output of pwd
99:17 - so we have another option
99:19 - which is to use a different operation
99:22 - very similar we use two greater than
99:24 - signs and this allows us to redirect
99:26 - standard output while also appending to
99:29 - a file instead of overwriting the file
99:32 - entirely
99:33 - so if i just ran you know pwd
99:37 - and then two greater than signs
99:39 - into this file this is let's do it a
99:42 - couple times this is silly to do but if
99:44 - i take a look at that file
99:46 - it now contains what five different
99:49 - lines let's take the date and redirect
99:51 - it into there
99:53 - let's take uh who am i
99:56 - and redirect it into there
99:59 - okay now let's take a look at that file
100:01 - again
100:02 - and you'll see it contains the output of
100:04 - pwd five times the date and then who am
100:07 - i which in this case is colt let's do
100:10 - date one more time or a couple more
100:11 - times let's run head
100:14 - and you can see
100:15 - it did not overwrite the entire file it
100:17 - just appends onto the end
100:19 - so
100:20 - you know date i don't use very much at
100:22 - all redirection though both with a
100:25 - single greater than sign which
100:26 - overwrites a file and two greater than
100:29 - signs is really really common uh the
100:31 - last thing i'll mention is that you can
100:33 - do something like this date redirect
100:36 - into today.txt that file does not exist
100:39 - in this folder if i take a look there is
100:41 - no today
100:42 - but if i do
100:44 - date
100:45 - redirect into today.txt
100:47 - we now have a today file it made it for
100:51 - us so the file does not have to exist in
100:54 - order to uh you know redirect output to
100:56 - it uh it will make that file for us if
100:58 - it needs to
100:59 - all right so we can do it with the date
101:01 - command we can do it with really any
101:02 - command that generates output as we saw
101:05 - i mean i could do if i wanted to
101:07 - ls
101:09 - or ls-l that gives me a lot of text
101:12 - i could take that and then redirect that
101:14 - to a new file called you know
101:17 - contents how about that
101:20 - and
101:21 - if we take a look at contents we'll just
101:23 - use head for now this is what the first
101:25 - 10 lines are now there may be yeah i
101:27 - think there's some more that's missing
101:29 - but we're just doing the first 10
101:31 - and we can see what is inside that file
101:34 - so that's the basic concept of
101:35 - redirecting and then of course if we use
101:38 - 2
101:39 - greater than signs we are redirecting
101:42 - by appending to a file the output is
101:45 - appended to contents and now
101:47 - if we do head we'll probably need to
101:49 - specify you know i want
101:51 - how about just 40 lines of that file
101:54 - we can see all of this is in there
101:56 - all right so next up we have another
101:58 - command called cat c-a-t
102:01 - and let's start by just taking a look at
102:03 - the man page for cat
102:05 - the name cats comes from the fact that
102:07 - it concatenates files
102:09 - cat
102:11 - but the first use i'm going to show you
102:12 - is something slightly different on its
102:15 - own if we just run cat i'm just going to
102:17 - clear here
102:18 - cat and then a file name like i have
102:20 - this uh
102:21 - song of myself i actually don't think
102:22 - there's we we overwrote that didn't we
102:25 - but if i do cat and then a file name it
102:27 - just prints the contents of that file
102:29 - in this case to my standard output to
102:32 - the terminal
102:33 - if i have and we had that contents file
102:37 - that we just made cat
102:39 - contents
102:40 - it gives me the entire file so it
102:42 - doesn't like head gives us the first 10
102:44 - by default we can specify the first 20
102:47 - lines the first 30 lines tail gives us
102:49 - the last 10 the last 20. cat gives us
102:52 - the entire file
102:53 - so i've got this song of myself file
102:55 - very long if i cat
102:57 - song of myself it prints out the entire
103:00 - thing
103:01 - there's a lot here you know i'm
103:02 - scrolling for a very very long time
103:05 - all right so that is something we can do
103:08 - but that's yeah sometimes i'll use that
103:10 - if i want to just check on you know
103:11 - what's in that file i don't remember
103:12 - what's it look like we can do that
103:15 - but there's a lot more we can do with
103:17 - cat as well remember the name cat comes
103:19 - from concatenate
103:21 - so we can actually provide more than one
103:23 - file name and it will print the contents
103:26 - of both of those or three or four
103:28 - however many files it will print all
103:30 - their contents together so on my desktop
103:33 - i have
103:34 - quite a few messy files here i've got
103:35 - one called letters so i'm just going to
103:37 - cat letters
103:39 - all right it just contains letters and
103:41 - then i have this one called words i'm
103:43 - going to cat words
103:46 - and there we are okay so i can cut them
103:48 - individually or i can cut them together
103:51 - just by separating them with a space and
103:53 - now we end up with one output again not
103:56 - very exciting
103:57 - but two different files for red and then
104:00 - concatenated together in this output
104:03 - smushed together
104:05 - so that doesn't seem that useful but
104:06 - where it gets more exciting if
104:09 - exciting to stretch but where it gets
104:10 - more sometimes useful is that we can
104:12 - then redirect that output to another
104:15 - file so i could make one file that is a
104:17 - combination of two or three or four
104:19 - other files or it doesn't have to stop
104:21 - at four i just don't want to keep saying
104:23 - numbers
104:24 - but we can take multiple files
104:25 - concatenate them together and take that
104:27 - output and save it into another file so
104:31 - here's an example of that i have three
104:33 - different shopping lists one for the
104:36 - butcher we can just take a look at that
104:39 - i need ground pork ground beef sausage
104:41 - skirt steak i've got one for the feed
104:43 - store for my animals i need to get
104:45 - chicken scratch chicken feed oyster
104:47 - shells i've got one for groceries milk
104:49 - eggs butter onions tomatoes
104:51 - all right so i want a master list
104:54 - still contrived but you know i want one
104:56 - list that i can take with me so i can
104:58 - concatenate all of them butcher
105:01 - feed store groceries
105:03 - and then i will take that first we can
105:05 - just see what it looks like here's the
105:07 - concatenated output but instead of
105:09 - printing it let's redirect it into a
105:11 - file we'll call it
105:13 - everything if i can spell everything
105:17 - okay and now we have a new file called
105:20 - everything let's take a look at it
105:22 - it contains the results of those three
105:24 - other files being concatenated so that
105:26 - can be useful right we can take multiple
105:29 - things stuff them together and put it in
105:32 - another file but as we'll see later we
105:34 - can also actually take multiple things
105:36 - concatenate them and send them to other
105:39 - commands not just send them to a file so
105:41 - we'll cover that later on when we talk
105:43 - about piping one last thing with cat
105:45 - that i'll mention is that we can use the
105:47 - dash n option to get line numbers
105:50 - so maybe not that useful here but if i
105:53 - go back with that super long song of
105:55 - myself poem
105:56 - if i do cat dash n song of myself
106:00 - pretend this is a file with you know
106:01 - some code and there's a problem in here
106:03 - i can find
106:05 - that line number and then tell my
106:06 - co-worker hey it's on 1741.
106:09 - you would probably be in an editor but
106:11 - we'll also learn about some other
106:12 - commands like find and grep which allow
106:14 - us to search for things so we'll get
106:16 - there
106:17 - there are valid use cases for for
106:19 - wanting those line numbers to be
106:20 - available
106:21 - all right
106:22 - the next command we'll look at is called
106:24 - less
106:25 - l-e-s-s less
106:27 - is used to
106:28 - read the contents of files it gives us a
106:31 - nice interactive ui where we can scroll
106:34 - and it's just a lot easier to work with
106:36 - a file compared to looking at the
106:38 - contents that is printed out from cat so
106:41 - just as a reminder here i've got this
106:43 - super long file song of myself if i use
106:45 - cat
106:46 - it prints out the entire thing and i
106:49 - guess that's sometimes useful but in a
106:51 - super long file i've got a scroll
106:53 - forever yes i could use head or tail
106:55 - just to get you know the the very top or
106:58 - the very bottom of the file but this is
106:59 - a lot of scrolling
107:01 - so if i wanted to actually go through
107:02 - this and i wanted to read the entire
107:04 - poem or look at a massive log file from
107:07 - scratch all the way at the beginning i
107:09 - could use cat scroll to the beginning
107:11 - and now just use a terminal and scroll
107:13 - down but it's not that easy it's not a
107:15 - great interface but if i use less
107:18 - followed by the file name so any file
107:20 - name but a long one is ideal because
107:22 - you'll be able to see how useful it is
107:25 - less song of myself.txt
107:27 - now my screen changes it didn't just
107:30 - print out the entire text to my terminal
107:32 - window instead
107:34 - it opens up the less program where i see
107:37 - a page and then i can scroll down with
107:39 - arrow keys
107:41 - just like the man pages so if you
107:43 - remember with the man pages if we open
107:45 - up man some command
107:47 - our prompts goes away we're transported
107:50 - to a new world of man pages and we can
107:52 - scroll i can hit space to go one page at
107:54 - a time
107:56 - and there's quite a bit more we can do
107:58 - in less but first most importantly to
108:00 - get out of here
108:01 - cue just like the man pages so my my
108:05 - history my terminal is not cluttered
108:07 - with thousands of lines of text
108:09 - so that's one benefit but also of course
108:11 - i can read things and scroll up my own
108:13 - pace
108:14 - i can also do things like search so if i
108:16 - want to search in here my cursor is
108:18 - right here
108:19 - it's a little hard to see
108:21 - if i type a forward slash and then i
108:23 - type some phrase or something i'm
108:24 - looking for
108:26 - i don't know let's look for
108:28 - green i don't know if green is in here
108:30 - somewhere but let's see i'm going to
108:31 - type green and hit enter and there we go
108:34 - this is the first match the sniff of
108:36 - green leaves and dry leaves
108:38 - so that's one thing we can do by the way
108:40 - i mentioned you can scroll one page at a
108:42 - time down by hitting the space bar
108:44 - we can scroll up one page at a time by
108:46 - hitting b so b in space
108:50 - we can also use arrow keys up and down
108:52 - we can jump to the end of the file i
108:54 - believe by hitting g
108:56 - capital g yeah we need shift g it takes
108:59 - me to the very end of the file and then
109:01 - lowercase g takes me to the start so
109:03 - here's the very beginning
109:05 - uppercase g takes me to the end and as
109:07 - always q is how i can quit so this is
109:10 - great to work with long files
109:12 - it's just easier to navigate you can
109:14 - search for things
109:16 - unlike if you're just looking at an
109:17 - entire file using cats it's just all
109:20 - vomited on your screen all at once so
109:22 - that's less the next command we'll learn
109:24 - is called echo echo uh it's very simple
109:29 - it does one thing it takes whatever
109:32 - value whatever argument we pass it and
109:34 - it echoes it back it just prints it back
109:36 - it outputs it so that might not seem
109:39 - useful let's get out of here let's clear
109:41 - if i just echo hi
109:44 - well it just echoes high back to me it
109:47 - prints it out
109:48 - so yeah it is not that useful when you
109:51 - just run it like that
109:52 - but one really useful trick is to use
109:55 - echo with a piece of text and then
109:57 - redirect the output to a file
110:00 - so this is a great really fast way of
110:02 - making a new file that contains some
110:03 - little bit of text
110:05 - without even having to open up the file
110:07 - so if i needed to make some config file
110:09 - and it needs to contain
110:11 - i'm just making this up but it needs to
110:13 - contain something like
110:15 - you know username equals cult something
110:18 - like that it needs to have one line in
110:20 - that file
110:21 - well i could make an empty file i could
110:22 - open it up and then i could put this in
110:24 - there save it close the file or
110:27 - i can echo it and then redirect to a
110:30 - file that doesn't even exist yet
110:33 - so that file let's just call it config
110:36 - dots we'll just do txt
110:39 - so it's going to take this argument it's
110:42 - going to echo it back but instead of
110:44 - printing it to the terminal i'm
110:46 - redirecting it to a file that doesn't
110:47 - even exist it will make that file and
110:50 - put this piece of text in it so now
110:53 - we have a config file and if we use cat
110:55 - to look at it
110:57 - there we are it contains that line
110:59 - and i can also you know if i needed to
111:01 - add something to it
111:03 - i can do the same thing where i can
111:04 - append with two greater than signs so if
111:07 - i needed some other config in there i
111:09 - don't know how about
111:10 - key equals
111:12 - that
111:13 - that is now appended into our config
111:16 - file if we take a look
111:17 - there we are it has two lines of text in
111:19 - it so this is not how i would recommend
111:22 - editing files but if you need to make
111:23 - something quickly or just add a small
111:25 - thing to a file quickly this is a really
111:28 - great way of doing it echo some piece of
111:30 - text redirect it into a file so to
111:33 - summarize echo on its own some piece of
111:35 - text
111:36 - it echoes it back to you on the terminal
111:38 - it just prints it out
111:39 - but we can also redirect that and it's a
111:41 - great way to add some text to a file in
111:44 - like two seconds so the next command
111:46 - we'll cover is called wc it's short for
111:48 - word count and it does just that it
111:50 - counts the words in some input
111:53 - for now it's going to be a file but we
111:55 - can actually provide other inputs and it
111:57 - does more than just word count it
111:59 - actually will count the bytes and the
112:00 - lines so if you remember i have this
112:04 - very long song of myself file here
112:07 - i want to know how many lines are in it
112:09 - well if i run wc
112:11 - and then song of myself
112:13 - it tells me well there's three different
112:16 - values here the first one is a number of
112:18 - lines
112:19 - 1757 lines the next one is the number of
112:23 - words
112:24 - and then third this little chunk here uh
112:26 - that is the number of bytes and then the
112:29 - name of the file
112:30 - so if we look at the man page for wc
112:33 - you'll see that it tells us the order
112:35 - again how many lines how many words and
112:37 - how many bytes
112:38 - we can also say actually i just want the
112:40 - lines so we can use dash l or i just
112:43 - want the number of characters dash m
112:45 - or the number of words dash w
112:47 - so let's see how many
112:49 - uh let's see how many lines i don't want
112:51 - all that other stuff and we're gonna do
112:52 - wc-l
112:54 - song of myself.txt
112:56 - there we are i want to know how many uh
113:00 - how many words dash w
113:02 - song of myself we get fifteen thousand
113:04 - seven six seven
113:05 - okay
113:06 - so that's one way of using word count
113:09 - but i'm also introducing a new concept
113:11 - right now something called piping
113:13 - so we're directly passing right now a
113:15 - file to word count but with piping we
113:19 - can do something very different we can
113:21 - actually take the output of one command
113:23 - and pass it as the input to a second
113:25 - command
113:26 - so we saw how to take the output of some
113:29 - command like ls and redirect it to some
113:32 - file this is taking output
113:34 - and then putting it in a file
113:36 - but what i'm talking about is taking
113:38 - output of a command and passing it to a
113:40 - second command
113:42 - so what if i wanted to know how many
113:44 - files are in here so if i do ls-l
113:48 - this is a massive chunk of text right
113:51 - i can take this
113:53 - and i could i guess take it redirect it
113:55 - to a file and count the lines in that
113:57 - file
113:58 - or
113:59 - i can use piping so it's called piping
114:02 - because we use the pipe character
114:04 - located above the return key on the
114:06 - right side of my keyboard
114:07 - i take the first command ls-l
114:10 - and then instead of just printing out
114:11 - the output i want to pipe it to the word
114:14 - count command wc
114:17 - and take a look at that we see the
114:19 - number of lines new line characters
114:22 - number of uh
114:24 - geez words and the number of bytes
114:26 - uh so what we just did was take ls-l i
114:30 - could even do let's do al that will
114:32 - include hidden files if i have any here
114:35 - there's just two of them but we have 64
114:37 - lines now
114:38 - so that's just one quick example but we
114:41 - can also do things like combine two
114:44 - different files using cat and then pipe
114:47 - that to word count and word count is not
114:49 - the only command we can pipe to i'm just
114:50 - introducing that one first uh i could
114:53 - even do date
114:55 - pipe that to word count if i wanted to
114:57 - know how many bytes are in there or how
114:59 - many uh words it's one line
115:01 - i don't know if i'd really want to do
115:03 - that but we definitely can
115:05 - but i have a couple of let's go actually
115:08 - to
115:09 - my shopping once again
115:12 - and i have if you remember this butcher
115:15 - file
115:16 - and feed store well actually let's do
115:18 - groceries so i have butcher and
115:21 - groceries i want to know how many things
115:24 - i have to buy
115:26 - so i'm going to combine those two
115:28 - groceries and butcher with cat so cat
115:31 - groceries and butcher and remember on
115:34 - its own it just smushes them together
115:36 - and prints it out
115:38 - but i'm not going to redirect it to a
115:39 - file i'm going to pipe it to word count
115:43 - and there we go if i just want the lines
115:47 - that will tell me tell me how many items
115:49 - right one item per line and it says nine
115:52 - and that seems correct right one two
115:54 - three four five six seven eight nine
115:56 - different things that i have to buy
115:59 - all right so that's an intro to piping
116:01 - it will pop up again and again as i
116:03 - introduce some other commands that are
116:04 - really more useful when you pipe things
116:07 - to them
116:08 - one more thing i just i'll show quickly
116:10 - i can combine piping and redirection if
116:12 - for some reason i wanted to take this
116:14 - output
116:16 - and then redirect it to a file called
116:19 - number.txt i can do that so this will
116:22 - run first
116:23 - concatenate those two files
116:25 - and then we're taking that information
116:27 - and piping it to the word count command
116:29 - which is just going to give us a number
116:30 - of lines in this case nine and then
116:33 - instead of printing that out like we did
116:35 - here
116:36 - redirect it to a file called number.txt
116:39 - there it is number.txt and if we look
116:42 - inside
116:43 - well it just has the number nine so
116:45 - that's a quick intro to piping
116:47 - next up we'll see some other commands we
116:49 - can pipe to the next command we'll talk
116:51 - about is sort
116:52 - so sort does what it sounds like it
116:54 - sorts information we'll start by just
116:56 - sorting a text file
116:58 - so i have this
117:00 - why don't we start with our everything
117:02 - file so let's take a look at that
117:05 - okay so it has a bunch of different
117:06 - items
117:07 - and i'm going to sort them
117:10 - with sort everything.txt
117:13 - now this is not going to change the file
117:15 - itself this is simply sorting the output
117:19 - it's going to sort what it gets from
117:20 - this file it will read it in sort it and
117:23 - print out the sorted information but it
117:25 - does not store it in that file
117:27 - and you'll see we end up with an
117:29 - alphabetical sort by default so butter
117:32 - chicken feed chicken scratch eggs ground
117:34 - beef ground pork
117:36 - it is case sensitive so an uppercase s
117:39 - comes before a lowercase s
117:42 - and you can actually tell it to not be
117:44 - case sensitive i believe if we look at
117:46 - man sort
117:47 - there is an option in here for
117:50 - where is that ignore case dash f
117:52 - um but this is great this is you know
117:55 - sorting a file alphabetically but just
117:57 - to reiterate it is not changing that
118:00 - everything file
118:01 - it is unsorted
118:03 - now i could redirect of course so i can
118:05 - do this sort everything and then put it
118:07 - into a file called sorted everything
118:11 - and now if we look at that sorted
118:13 - everything file it is indeed sorted
118:16 - we also can tell it to sort numerically
118:19 - so if i had a file that had numbers in
118:21 - it okay i have a file called nums i've
118:24 - just created oop
118:26 - nums
118:27 - it just contains five numbers here if i
118:29 - try and just sort nums as is
118:32 - it doesn't do a numeric sort it does
118:35 - well it sort of does it compares you
118:37 - know the first digit of each and a two
118:40 - so these both have a two that means i
118:42 - guess they come before 54 because that
118:44 - starts with a five but it's not an
118:46 - actual numeric sort
118:48 - but we have the dash n option
118:52 - that will now sort things numerically
118:54 - and there are other sorts that we have
118:56 - at our disposal we can reverse things
118:58 - with the dash r option so let's do that
119:01 - dash n r you can see we now have 999
119:04 - first all the way down to the number two
119:07 - another option that can be useful has to
119:09 - do with duplicate values so why don't i
119:12 - echo
119:13 - 999
119:15 - and i'll append that into my nums file
119:18 - i'll do that a couple of times all right
119:20 - so now when i recall my sorts for nums
119:23 - there's a bunch of those 999s in there
119:26 - if i want to only get the unique values
119:30 - i can use the dash u option for unique
119:33 - so let's do dash n u
119:36 - and now i only get the unique numbers
119:38 - sorted
119:39 - alright so that sorts we can concatenate
119:42 - and pipe information to sort
119:44 - we can do all sorts of things right it
119:46 - doesn't have to be from a file so i'll
119:48 - just show one more example of that let's
119:50 - take the butcher file and the
119:52 - what's another file i have groceries
119:55 - okay and if i want to sort those two i
119:58 - can pipe that oops
120:01 - i don't know if you can hear my cat
120:02 - there
120:03 - i can pipe it to sort and there we are
120:05 - it sorts what it received as its input
120:07 - so it wasn't just one file we took one
120:10 - command cat that gets an output we pipe
120:13 - it over to sort
120:14 - so there we go
120:16 - i could also do things like if i wanted
120:18 - to know how many unique numbers
120:21 - are in this numbers file right nums
120:24 - i could sort nums
120:26 - but i only want the unique so dash u n
120:30 - sort whoops not sort
120:32 - nums
120:34 - and then let's imagine there was like
120:36 - hundreds of them instead of what five i
120:39 - could pipe that over to good old word
120:41 - count and ask for how many lines
120:43 - so take this nums file
120:45 - only sort the unique value sort them
120:47 - numerically but instead of printing the
120:49 - value or the output to the terminal pipe
120:52 - it over to word count where we count the
120:54 - number of lines and the grand total is
120:57 - 5. so this just is to show you that you
120:59 - know we can take sorts
121:01 - and pipe its output to something we can
121:03 - redirect its output to a file or we can
121:06 - take some other command like cats
121:09 - and concatenate two files and then pipe
121:12 - the output to sort
121:14 - so that's sort next up we'll talk about
121:17 - the unique un iq command now the unique
121:20 - command
121:22 - is generally at least when i use it used
121:24 - in conjunction with the sort command
121:27 - so unique
121:28 - is going to let's just take a look at
121:29 - the man page first
121:31 - it reports or omits repeated lines
121:34 - so anytime you have a data set or a file
121:36 - that contains repeated information on
121:38 - different lines and you're trying to
121:40 - either consolidate it or ignore repeated
121:42 - lines we can use the unique command
121:45 - so just show an example
121:48 - i have a
121:49 - file here that i've just made called
121:52 - fave flavors it was uh let's say we run
121:55 - an ice cream shop we asked our our
121:57 - customers what their favorite flavor of
121:59 - ice cream was
122:00 - and
122:01 - we got a bunch of different outputs
122:03 - right chocolate vanilla strawberry a
122:05 - bunch of vanilla's rocky road cookies
122:07 - and cream but there's a lot of
122:08 - duplicated values
122:10 - now if i just run unique on this command
122:13 - or on this file fave flavors
122:17 - well that's weird it really doesn't seem
122:19 - like it works because i see a lot of
122:21 - duplicated values it seems like if it
122:24 - only gives us unique values or you know
122:26 - it removes duplicates we shouldn't see
122:28 - cookies and cream twice we shouldn't see
122:29 - vanilla twice or way more than twice
122:32 - well what it does is it doesn't actually
122:34 - just remove
122:35 - all duplicated values instead
122:38 - it removes adjacent duplicated values
122:41 - and that might seem weird right
122:43 - so we've got strawberry let's take a
122:45 - look here chocolate vanilla strawberry
122:46 - and then two vanillas
122:48 - well if we look at the output from
122:49 - unique we have chocolate vanilla
122:51 - strawberry one vanilla
122:53 - down here we had strawberry three times
122:54 - in a row over here it shows up once in a
122:57 - row when we use unique
122:59 - so it is going to look at one line and
123:01 - then the line after it and if it's the
123:03 - same then it's only going to print out
123:06 - one of those
123:07 - so generally i use this in conjunction
123:09 - with sort
123:11 - so if i sort fave flavors and then pipe
123:14 - that to let me just remind you what that
123:16 - looks like
123:17 - it's alphabetical so now they're all
123:19 - chunked together right cooking cream
123:21 - rocky road strawberry it's all together
123:23 - and then i can pipe that to unique
123:26 - and now we just get the unique values
123:28 - because they were all in a row and the
123:31 - way that unique works is it's only going
123:32 - to take one uh anytime there's
123:34 - duplicates in a row
123:36 - but you might be thinking didn't we just
123:38 - see there's a dash u option
123:41 - and indeed there is a dash view option
123:43 - for sort it kind of makes this obsolete
123:45 - but there's additional behavior to the
123:48 - unique command that can make it useful
123:51 - for example if i do man unique there's
123:54 - an option which is dash d
123:56 - which will only print out the duplicates
123:59 - so i only want the duplicates uh let's
124:02 - try that let's do
124:04 - well unfortunately they're all going to
124:06 - be duplicates aren't they if i do this
124:08 - dash d every single one of these flavors
124:11 - appears more than once but if i echo how
124:14 - about mint
124:16 - into
124:17 - fave flavors
124:20 - and let's do one more flavor uh
124:22 - how about uh pistachio or
124:26 - um
124:27 - how about rainbow sherbet
124:32 - okay
124:33 - so now we have two values that are not
124:35 - unique
124:36 - so if i remove that dash d
124:38 - here is all of the sorted unique flavors
124:43 - so we see a list of them but with dash d
124:46 - now i only want the ones that are
124:48 - duplicated
124:50 - so we no longer have rainbow sherbet and
124:53 - uh mint
124:54 - side note i've always said sherbet my
124:56 - entire life but uh i don't know i was
124:59 - corrected on sherbet so now i'm
125:01 - self-conscious some guess i'm sticking
125:03 - with sherbet
125:04 - um
125:05 - so there's another option
125:07 - instead of dash d
125:08 - we can use the dash u option to display
125:12 - non-duplicate lines so the lines that
125:15 - only appear once
125:16 - dash u
125:18 - and now we can see oh these are the
125:20 - flavors that uh only one person liked in
125:22 - our case we've got mint and rainbow
125:24 - sherbet everything else is duplicated so
125:27 - we don't see it showing up
125:29 - and then an even fancier option is that
125:31 - we can get a count of how many times
125:33 - each line appears with dash c
125:36 - so why don't i do that here i'm going to
125:38 - do sort all the flavors dot txt or fave
125:41 - flavors and then pipe that to unique and
125:44 - then dash c will give me a count and we
125:47 - can see all right there's five
125:48 - chocolates six vanillas one rainbow
125:51 - sherbet and what's extra fun is that we
125:54 - can actually take the output instead of
125:56 - just printing it out i can re-sort that
125:59 - numerically if i wanted to get a ranked
126:02 - list because they all start with a
126:04 - number i can do dash or sort dash n
126:07 - so sort all the contents of that file
126:10 - alphabetically which groups them all
126:12 - together
126:12 - then take that output and pass it to
126:15 - unique which is going to weed out all
126:18 - duplicated lines that are adjacent and
126:20 - give us a count for how many times each
126:22 - one appears but instead of printing that
126:24 - out pipe that to the sort command again
126:26 - where we will sort by number at the
126:29 - beginning
126:30 - and then we could even reverse it with r
126:33 - and we can see the most popular flavor
126:35 - vanilla so boring all the way down to
126:38 - the least popular mint which is this is
126:39 - not accurate i think mint is actually
126:41 - quite popular but anyway
126:44 - that is using piping along with the
126:46 - unique commands kind of a lot to take in
126:48 - so if you just need to sort the unique
126:50 - values in a file you can do the dash u
126:52 - option but if you want a count of how
126:54 - many times uh different lines appear if
126:57 - you want to weed out
126:59 - duplicated values or you only want an
127:02 - output that contains the values that are
127:03 - duplicated you can use the unique
127:05 - command
127:06 - now if you remember when i introduced
127:08 - the echo command if you happen to be
127:10 - somebody watching this entire thing from
127:12 - start to finish uh you may recall at
127:14 - least when i introduced echo i talked
127:16 - about
127:17 - expansions and how
127:19 - later on i would cover this thing called
127:21 - expansions well that's what i want to
127:22 - talk about now
127:24 - what i'm about to show you is not
127:25 - specific to the echo command but we'll
127:27 - be using the echo command to help
127:28 - illustrate uh how these expansions work
127:32 - so when i say expansion what i mean is
127:34 - that there are special characters and
127:36 - special syntax that we can use with
127:38 - various commands that the shell will
127:40 - interpret and expand into some other
127:43 - value
127:44 - and probably the simplest example
127:47 - is actually something we've seen before
127:50 - the tilde
127:51 - tilde expansion
127:53 - if i just echo the character tilde tilde
127:56 - has a special meaning i'll zoom in a
127:58 - little bit as we've talked about it is a
128:00 - shortcut that refers to
128:02 - our home or my current user's home
128:04 - directory so here
128:06 - tilde is slash user slash cold steel now
128:09 - when we echo it what we're actually
128:12 - doing is asking the shell uh you know
128:14 - print out tilde but it's not the
128:16 - character tilde right if it's in quotes
128:19 - then we get the tilde printed out what
128:21 - it's doing instead is it's it's
128:23 - expanding that character it has a
128:25 - special meaning before it even runs the
128:28 - echo command it's going to replace that
128:30 - or expand it
128:32 - to be this and that's what it echoes out
128:34 - so when we do things like cd tilde
128:37 - again the shell steps in and says oh i
128:40 - know that let me expand that
128:42 - and it turns it into slash user slash
128:44 - cold steel
128:45 - and that is where we see d2 so icd to
128:48 - tilde it's the same end result
128:51 - all right so there's other types of
128:52 - expansion though including dollar sign
128:55 - environment variable expansions so in
128:57 - our shell there's a bunch of environment
128:59 - variables available
129:01 - some of the more common ones are things
129:03 - like dollar sign
129:05 - path
129:06 - in all caps if i echo that
129:09 - you'll see that it's been replaced with
129:12 - a very long yours may be much longer
129:14 - actually than this it's not too bad if i
129:16 - run it over here on
129:20 - ubuntu i think i have quite a long path
129:22 - here nah not too bad either
129:25 - so it takes this and it turns it into or
129:27 - it expands it to the value of that
129:30 - variable now if you don't know much
129:31 - about environment variables don't worry
129:32 - about it but here's one more example
129:35 - user that's an environment variable for
129:37 - the current username
129:39 - okay
129:40 - now a more useful thing
129:42 - is path name expansion
129:45 - so path name expansion allows me to use
129:47 - special syntax special characters
129:49 - to match different path names so we've
129:52 - actually seen this before we just
129:53 - haven't called it path name expansion
129:56 - i'm in a directory right now well i'm in
129:58 - my home directory aren't i so there's a
130:00 - whole bunch of stuff here
130:02 - different files and folders um why don't
130:04 - i do this over on ubuntu because i have
130:06 - some more files to work with okay
130:09 - so when i type
130:11 - echo i'm just going to use echo again
130:13 - because it's an easy way to see what the
130:16 - shell is doing for us so it's just going
130:18 - to print back the expanded version of
130:21 - the star character so if i wrap the star
130:24 - character in quotes
130:26 - that's what we actually get echoed back
130:28 - but if i don't have those quotes and i
130:30 - simply echo star
130:32 - what i see is a list of every path name
130:36 - in this current folder so every folder
130:39 - every file name like you know
130:41 - pokemon.txt word.txt
130:44 - and then different folders like cleanup
130:47 - and copies
130:49 - i'm just matching everything so the star
130:52 - means
130:53 - every path here
130:54 - but i can narrow it down and i can say
130:57 - star
130:58 - dot txt and we've seen this sort of
131:00 - thing before
131:02 - again this is going to then be replaced
131:04 - with matching paths so this was replaced
131:07 - with all of that
131:09 - now if i do star.txt it's only going to
131:12 - match something that starts with
131:14 - anything but ends in exactly dot txt
131:18 - okay and so here we are we see our
131:21 - matches that end with txt
131:24 - now echoing them may not be that useful
131:26 - but i can do things like ls-l
131:29 - star dot txt
131:31 - i want to print out long listing
131:34 - information about all text files in here
131:36 - and there we go i only see txt files and
131:40 - all their information so we also have
131:41 - another character we can use to match
131:43 - path names which is the dollar sign the
131:45 - dollar sign the uh question mark uh a
131:48 - question mark will match any single
131:51 - character
131:52 - so this would match any three characters
131:54 - in a row
131:55 - this would match any four characters in
131:57 - a row so let me show you an example if i
131:59 - echo
132:01 - and i'll do anything
132:02 - so a star matches anything and then a
132:05 - dots and then any two characters
132:09 - so this looks weird but it's saying
132:11 - anything that must then end with a dot
132:14 - and then exactly two characters i don't
132:17 - care what those characters are but two
132:18 - characters and oh we don't really match
132:21 - anything do we in this folder i guess we
132:24 - don't have any all right well let's try
132:26 - three characters
132:28 - and now we're just matching all our txt
132:30 - files and zip files
132:33 - it's not that exciting but just as an
132:35 - example if i were to touch app.py and
132:39 - you know app
132:40 - dot
132:42 - js and main.js
132:44 - all right
132:46 - and then i ran our original version here
132:48 - which is anything
132:50 - with a dots and then exactly two
132:52 - characters now we're matching those dot
132:54 - js and dot py extensions so i'm echoing
132:57 - them again that's not what we would
132:59 - normally do we might do something like
133:00 - ls or we could even do rm if i want to
133:04 - remove all those files this is kind of
133:07 - very
133:08 - dangerous and i don't know if i would
133:10 - recommend this but just as an example
133:12 - i could remove those files that have two
133:16 - character extensions that would be a
133:18 - very bizarre thing to want to do just
133:20 - all two character extensions but i can
133:22 - rm
133:24 - star dot question mark question mark so
133:26 - remove all files in here that end with
133:29 - two character extensions
133:31 - and i have it set up again automatically
133:33 - to ask me
133:34 - prompting me if i want to so
133:37 - i will say
133:38 - yes i'll remove all of them remove and
133:41 - remove
133:42 - all right so that's the basics of path
133:44 - name expansion
133:46 - next up we have some other types of
133:48 - expansion so we'll start by talking
133:50 - about curly brace expansion again i'll
133:53 - use echo
133:54 - when the shell encounters curly braces
133:57 - and i provide a comma separated list of
134:00 - values so i could do something like
134:03 - let's just do letters to start
134:05 - a b and c
134:08 - okay if i just echo a b and c it's not
134:10 - going to be very exciting but if i add
134:13 - something before or after
134:15 - let's do
134:16 - abc dot
134:19 - txt okay
134:21 - what this is going to do is create every
134:23 - combination of a followed by txt or dot
134:27 - txt and then b and then c
134:30 - and that's what we get a dot txt b dot
134:32 - txt and c dot txt
134:35 - so whatever these values are separated
134:37 - by commas
134:38 - i can create i can make files with them
134:41 - if i wanted to the shell is going to
134:43 - take this and expand it first so if i
134:45 - did something like touch
134:48 - and then how about um i did app dot
134:52 - and then in curly braces js
134:55 - html
134:56 - css and py if i wanted to do that
135:00 - i'll run it with echo first so you can
135:02 - see what it would make me
135:04 - app.js
135:05 - app.html app.css app.py and then if i
135:09 - wanted to actually create that
135:11 - i could use touch
135:13 - and that will make me all those files
135:16 - so now there's a bunch of stuff here why
135:18 - don't we narrow it down well only ls
135:21 - things that end in two
135:24 - characters or how about
135:26 - app dot
135:27 - and then
135:29 - question mark question mark question
135:30 - mark or how about a star all right and
135:33 - so we can see what we created
135:35 - we can also do numbers and provide
135:37 - ranges so if i echo
135:40 - 1.99
135:43 - this is going to be expanded to the
135:45 - numbers between integers between 1 and
135:47 - 99.
135:48 - so i could create a bunch of files
135:52 - how about
135:53 - day
135:55 - and then let's do one to 365 if i was
135:57 - keeping some sort of journal i'm not
135:59 - making files right now i'm just echoing
136:01 - it but the shell takes this it expands
136:04 - it into this massive list of different
136:06 - numbers or rather different
136:08 - names day 94 day 95 and so on and then
136:13 - i'm echoing it but i could just as
136:15 - easily touch or make directory and
136:18 - create 365 different directories in a
136:20 - single line now there are other types of
136:23 - expansion uh we're not going to spend
136:25 - time talking about them but basically
136:27 - the concept of expansion is that the
136:29 - shell intervenes before a command runs
136:32 - expands some smaller thing usually it's
136:34 - small into a larger piece of text and
136:37 - then passes that to some command and we
136:39 - can use that to our advantage to craft
136:41 - short commands that results in creating
136:44 - hundreds of files or deleting a whole
136:46 - bunch of stuff
136:47 - or just matching a bunch of things by
136:49 - defining a pattern like we saw
136:51 - if we want to match you know anything
136:54 - that how about starts with the letter f
136:56 - and then ends in anything else
136:59 - i'm just echoing it and this is just
137:01 - echoing the paths that match this
137:03 - pattern in my current directory
137:05 - but then i could delete them all if for
137:06 - some reason i didn't want them to start
137:08 - with an f i could delete them all
137:10 - or i could move them all i could copy
137:12 - them there's a whole bunch of things we
137:13 - can do next up we'll cover the diff
137:15 - command which we can use to find the
137:18 - differences between two different files
137:21 - if you've ever used git you probably
137:23 - have seen the get diff command
137:25 - we will actually see
137:27 - what it relies on behind the scenes to
137:29 - generate a diff but first let's make two
137:32 - files or at least one file that is
137:34 - slightly different than another
137:36 - so i have this ice cream flavor five you
137:40 - know fave flavors file i'm going to copy
137:42 - it
137:43 - so copy fave flavors and i'm going to
137:45 - make another file called fave flavors
137:49 - 2 dot txt it's not very original
137:52 - all right so now we have two of them
137:54 - and if i compare the two with diff at
137:57 - the moment
137:59 - they are identical
138:02 - there's no difference so let's change
138:05 - something in fave flavors two let's echo
138:08 - another thing in there how about
138:10 - what's another flavor well let's just do
138:12 - mint again
138:14 - and i'll append that
138:15 - not with a single greater than sign two
138:18 - i want to append to fave flavors
138:21 - two dot txt
138:23 - okay so now that exists at the end of
138:26 - that file
138:28 - just that one extra addition of mint
138:31 - so if i rerun my diff between those two
138:34 - files
138:35 - this is what it tells me
138:38 - 24a25
138:40 - mint now we could spend a lot of time
138:41 - talking about how this works
138:43 - but to read this change command here
138:45 - what it's telling us is that
138:47 - on the first file line 24
138:50 - on the second file line 25 was added
138:54 - so if we change the direction
138:56 - if we instead compared fave flavors to
138:59 - to flav fave flavors just on its own
139:03 - now the output says line 25 on the first
139:07 - file line 24 and the second file was i
139:10 - don't know if the d stands for deleted i
139:11 - believe
139:13 - so you know appended added deleted
139:17 - we can have multiple diffs too in a file
139:19 - just
139:20 - if i quickly change something in
139:23 - how about
139:25 - in fave flavors two so let's open that
139:27 - up i'm gonna change something on line
139:30 - three i'm gonna do strawberry
139:34 - and
139:35 - cream
139:36 - all right i'm going to save that file
139:39 - and close it
139:41 - now if i do my diff between fave
139:44 - flavors
139:46 - and fave flavors two
139:50 - we see we get two different diffs right
139:52 - two different things that were changed
139:53 - on line three of both files it was
139:56 - changed from strawberry to strawberry
139:59 - and cream
140:00 - and then line 24 of the first file line
140:02 - 25 of the second file we added mint
140:05 - anyway uh this is one way of using diff
140:08 - but what's probably more common uh and
140:11 - more useful is to see both files side by
140:13 - side with dash y so that's one option if
140:16 - we pass in dash y
140:18 - uh although in this case um way zoomed
140:20 - in it's kind of disastrous isn't it on
140:22 - this screen size because i've tried to
140:24 - make things readable
140:26 - but if my font were quite small you
140:28 - would see it side by side and then
140:30 - lastly we have the dash u option which
140:33 - is what git uses behind the scenes to
140:35 - display its own diffs
140:37 - and this just gives us a different
140:38 - output if we look at mandif again and we
140:41 - go down to dash u
140:43 - output the num lines of unified context
140:46 - so it gives us some context around each
140:48 - change so let's do that again
140:50 - instead of dash y dash u and what we see
140:53 - here are the files that we're comparing
140:55 - and then context is saying from line one
140:57 - to six we can see what was added or
141:00 - removed uh and then same thing here we
141:02 - can see what was added so this is maybe
141:04 - familiar if you use git and that's the
141:06 - basics of the diff command next up we'll
141:09 - talk about the find command so find
141:12 - helps you find files or folders matching
141:15 - some file pattern but there's quite a
141:17 - bit to it and we could have a 20 minute
141:20 - video at least devoted just to the find
141:22 - command so i'm going to just try and hit
141:24 - the highlights here
141:25 - the first thing you should know is that
141:27 - we can find
141:28 - files and folders by a bunch of
141:30 - different criteria we can find based off
141:32 - of let's open up the man page
141:34 - based off of the name of the file
141:37 - the modification time uh the file size
141:41 - the type if it's a file or a directory
141:44 - or a sim link
141:46 - there are probably many others that i'm
141:47 - forgetting at the moment
141:49 - and i'm just scrolling through the man
141:50 - page here it's quite long as you can see
141:53 - so again we're just going to hit the
141:55 - some of the highlights here okay so the
141:57 - first thing is if we want to find files
142:01 - or directories we need to provide a
142:03 - location to look inside of so find
142:07 - inside of in this case dot meaning the
142:10 - current folder or find in the desktop or
142:12 - find in my
142:14 - animals folder
142:15 - and then we provide some sort of
142:17 - criteria something to search against in
142:20 - this case dash name
142:23 - and then some sort of name that we want
142:26 - to find
142:27 - so i'm just going to search on my
142:29 - desktop i have a bunch of files
142:31 - but find will search recursively
142:34 - so if i do a find dot and nothing else
142:37 - just find dot
142:39 - it is going to find every single file
142:41 - nested somewhere inside my desktop
142:45 - so there's a lot of stuff going on here
142:47 - if i scroll i mean you can see they're
142:49 - all nested
142:50 - they're not actually on the desktop
142:52 - they're nested multiple levels deep
142:54 - uh we didn't specify any way of
142:56 - narrowing what we're looking for but now
142:58 - let's try let's find everything
143:01 - that has
143:02 - in its name and then instead of quotes
143:05 - uh let's search for anything that has
143:08 - hm
143:09 - how about the number
143:11 - seven in it
143:13 - anywhere on my desktop or any folders
143:15 - nested in the desktop or folders nested
143:17 - in those folders and so on
143:20 - really nothing
143:22 - why didn't we find anything aren't there
143:24 - at least there's one file here that has
143:26 - a 7 in its name
143:28 - and the answer here is that it's looking
143:30 - for an exact match a file that has and
143:34 - it is called seven if i made a file
143:37 - called seven right here
143:39 - and i reran it it would work we found
143:41 - that file but what i want to do is find
143:44 - any file on my desktop or nested
143:46 - somewhere on the desktop that has the
143:48 - number 7 in it
143:50 - so this is where the special wildcard
143:52 - characters
143:54 - of a star in our case will come in a
143:57 - star is just going to refer to anything
144:00 - and then a 7 and then anything else
144:03 - optionally before or after so if i do
144:06 - this
144:06 - we now get a bunch of matches a lot of
144:09 - pokemon that i have for a different
144:11 - video i made that have a seven in their
144:13 - name somewhere but i'm sure there's some
144:16 - non-pokemon here we go
144:18 - morning day 27
144:21 - nested very deep inside of this folder
144:24 - or here's you know file 257
144:27 - so we found files that contain seven in
144:30 - their name
144:31 - so if i wanted to find all files for a
144:33 - particular type like all python files
144:36 - dot py
144:37 - i would put a star which again means
144:40 - anything followed by
144:42 - dot p y
144:44 - and it looks like there's just one let's
144:46 - try a dot j s
144:49 - we've got a couple of js files
144:52 - nested in my desktop now remember
144:54 - dots is where i'm searching inside of
144:56 - and that's just my current location but
144:58 - i could instead say i want you to search
145:01 - only within the stuff folder
145:04 - if i can spell it correctly
145:06 - it's not going to find anything but
145:08 - maybe i'll find txt files
145:10 - and there we go we only find txt files
145:13 - inside of stuff
145:15 - so we can also find by type i can find
145:18 - directories or files or sim links so why
145:21 - don't i do a find
145:23 - on my desktop once again and all that i
145:25 - want here
145:27 - are
145:28 - any entries anything that it finds where
145:31 - type is d for directory now i forgot to
145:34 - specify where to search we'll search in
145:36 - our current directory and i get a list
145:39 - uh these are all directories there's a
145:40 - lot here
145:41 - but no files if you notice none of the
145:44 - actual files are present no dot txt or
145:47 - js or whatever it's just the directories
145:49 - if i did type f i only get the files as
145:53 - you can see here these are all of course
145:55 - they don't have extensions so you can't
145:57 - tell but you have to trust me they are
145:59 - all files
146:01 - for each pokemon in this case or
146:04 - whatever you're seeing printed out these
146:05 - are all files there are no directories
146:08 - that i've been found now there's
146:09 - directories referenced in the path to
146:11 - each file but that's not the same thing
146:14 - as the actual directories being returned
146:16 - as a result here
146:18 - so we can combine them too maybe i want
146:20 - to find directories only
146:22 - so i'm going to do dash type is d
146:25 - and name
146:28 - as uh i don't know how about uh an
146:30 - uppercase
146:32 - um uppercase e
146:35 - we'll see if we find anything that
146:37 - contains an uppercase e and we do so
146:39 - only directories somewhere on the
146:41 - desktop
146:42 - where in their name they have an
146:44 - uppercase e so here we go uppercase e
146:47 - uppercase these are all directories
146:49 - now i can also do a case insensitive
146:52 - version
146:53 - if i do i name for insensitive
146:57 - now i'm finding everything that has an e
146:59 - it doesn't actually matter if it's
147:00 - uppercase or lowercase so we see things
147:03 - like right there there's an e in that
147:05 - directory's name there's an uppercase e
147:07 - and a lowercase e
147:09 - okay
147:10 - we can also do fancy logical things like
147:12 - use the or operator so dash or so let's
147:16 - give it a shot let's find uh
147:19 - anything that has in its name so in our
147:21 - current location
147:23 - dash name it starts with the letter e so
147:27 - actually sure let's do e
147:29 - so e and then followed by anything now
147:32 - remember
147:34 - if we put a star there that means
147:36 - anything can come before the e but what
147:38 - i want is it must begin with the letter
147:40 - in this case uppercase e so we get a
147:43 - bunch of the e pokemon and there's some
147:45 - others edgar ethel elvis instead of the
147:48 - chickens directory
147:50 - now if i also wanted to say
147:52 - or name starts with
147:55 - how about
147:56 - f
147:57 - star
148:00 - and now i have fall
148:03 - fungus
148:05 - as well as espeon and you know files
148:09 - that and directories that start with an
148:10 - f or an e
148:12 - uppercase only because i didn't do i
148:15 - name
148:15 - so that's just a taste of using the or
148:17 - operator there's also a not operator
148:21 - we can do things like search by file
148:23 - size how many bytes
148:25 - how many megabytes
148:27 - greater than something so for example to
148:29 - find files that are larger than 100
148:31 - kilobytes but smaller than one megabyte
148:34 - we could run this right here
148:36 - so find where type is file f
148:39 - and size is plus 100k greater than 100k
148:44 - and size is minus
148:46 - one m one megabyte so let's try an
148:49 - example let's do uh find
148:52 - where type is file and size is greater
148:56 - than 100
148:58 - kilobytes
149:00 - and there we are
149:01 - we get a list of files that are greater
149:04 - than 100 kilobytes if i left that size
149:06 - off we get way way more files
149:10 - we can also do things around time so if
149:12 - we want to find files that were edited
149:14 - more than three days ago we would do
149:16 - dash m time which is modified time plus
149:20 - three and then we get to the last little
149:23 - bit that i'm going to mention around
149:24 - find
149:25 - which is this weird looking thing dash
149:28 - exec
149:29 - this is an option we can provide where
149:32 - we then specify a command that we want
149:35 - find to run on each found result
149:38 - so this example is going to find all
149:41 - files in the current directory right
149:42 - type is file
149:44 - and on each one it is going to cat that
149:47 - file out it prints its contents now i'm
149:50 - not going to run that because on my
149:51 - desktop i've got a million files that it
149:53 - will print out
149:54 - but let's talk about this quickly so
149:56 - dash exec
149:58 - is just the option saying hey i'm going
150:00 - to give you a command i want you to run
150:01 - with each match and then here's the
150:04 - command the entire command we're
150:06 - providing we do have to terminate it
150:08 - with this backslash and then a semicolon
150:11 - that is how the terminal knows where
150:13 - that command ends and then this the
150:15 - curly braces opening and closing is
150:18 - going to be replaced it's a placeholder
150:20 - it will be replaced with each found
150:22 - result
150:23 - so let's try an example let me recall
150:26 - this line where we found files that were
150:28 - larger than 100 kilobytes
150:31 - we could verify the size of files one
150:34 - way at least is with dash l ls l rather
150:37 - right and we can see the file size here
150:41 - and there's a lot of them
150:43 - there's a couple that are larger but
150:44 - most of them are pretty small
150:46 - dash l is going to give us that long
150:48 - listing so what i want to try is taking
150:51 - these files that we find that are larger
150:53 - than 100 100 kilobytes and then telling
150:56 - find to then call ls-l
151:01 - and then curly braces
151:02 - and then we need our backslash semicolon
151:06 - and
151:07 - of course
151:08 - my font is quite large here but what you
151:11 - can see is that for each one of those
151:12 - results if i just
151:14 - run find without dash exec these are the
151:17 - results right gg dot i think that's
151:19 - great gatsby.txt
151:21 - uh
151:22 - pokemon exercise nano exercise whatever
151:25 - these different files are they're all
151:27 - here but we actually executed ls-l with
151:31 - each one and we can see that file size
151:33 - is large much much larger than the other
151:36 - ones
151:37 - we could do something instead like if we
151:39 - wanted to cat each file out
151:43 - but again there's going to be
151:46 - quite a few
151:47 - things printed out so all files larger
151:49 - than 100 kilobytes
151:51 - dash exec means i want you to then run
151:53 - each match with cat
151:56 - curly braces just concatenate them all
151:58 - oh my goodness that's a lot of stuff
152:00 - that was just printed out a lot of it is
152:02 - kind of messed up but
152:04 - there we are that is the result of
152:07 - executing that cat command with every
152:10 - single one of the found files that
152:12 - matched with our find command
152:14 - all right so there's a lot more to find
152:15 - you can do some really powerful things
152:17 - but that's just a quick intro next up
152:19 - another command that could have its own
152:21 - video for 20 30 minutes at least
152:24 - grep there are many articles many
152:26 - tutorials that are quite long that exist
152:29 - solely to explain all the different
152:30 - options and various ways of using grep
152:33 - so what it does is it helps us find
152:36 - text inside of files so the find command
152:39 - helps us find files right based off of
152:42 - their file name or different attributes
152:44 - but it's not searching in the files
152:47 - grep will search inside of files
152:50 - so the simplest way to use it is to run
152:53 - grip and then tell it some string or
152:56 - some piece of text or something that
152:57 - we're trying to find
152:59 - and then a file to search inside of
153:02 - so let me show you an example here let's
153:04 - clear this screen all this craziness
153:06 - i have this song of myself file
153:10 - here i opened it in less there's a lot
153:12 - of stuff in here and i want to find
153:14 - every
153:16 - time this file i don't know mentions
153:18 - green in it so i can do grep
153:21 - green
153:22 - song of myself.txt
153:25 - and it prints out to me the matches
153:27 - right it highlights them in a different
153:29 - color
153:30 - of every time in this file the word
153:33 - green showed up
153:35 - so we've got green leaves green and
153:37 - violet dusky green pale green eggs
153:40 - quintillion's green
153:42 - there we go we can also ask grep to give
153:44 - us the line numbers with the dash n
153:47 - option so we'll add that in right there
153:49 - dash n
153:50 - and now i'm getting the line numbers so
153:52 - 32 is the first one all the way to line
153:55 - 1026
153:56 - i can also ask for some context if i use
153:59 - an uppercase c
154:01 - and then i provide an argument a number
154:04 - of lines i want in this case two that
154:06 - will give me two lines before and two
154:08 - lines after each match so let's try that
154:11 - c
154:12 - and then two
154:15 - and here we go
154:16 - so this is one match this is actually
154:18 - the last match on this line we have two
154:20 - lines before and two lines after
154:23 - uh here's another match right we have
154:25 - two lines after two lines before
154:28 - another option we can pass to grep is
154:30 - dash r
154:31 - which is for recursive uh and this is a
154:34 - bit different this will actually tell
154:36 - grep if i do grub dash r and then
154:38 - provide some pattern like
154:40 - chicken
154:41 - it's going to tell it to search
154:42 - recursively in my case right now just in
154:45 - the current directory and all nested
154:47 - subdirectories so instead of just
154:49 - looking inside of one file like
154:51 - hello.txt which doesn't exist
154:54 - now i can look inside of all files at
154:57 - least if i tell it a starting point i
154:59 - think the default is just dot
155:02 - okay so uh what we see here is a bunch
155:05 - of matches
155:06 - one from gg.txt or a couple a couple
155:09 - from sorted everything and everything
155:11 - feedstore.txt
155:13 - website.html
155:16 - greatgatsby.txt
155:18 - so these are all files that were nested
155:19 - somewhere in my desktop
155:22 - and they all contained chicken
155:24 - now uh it is important to note that it
155:26 - is case sensitive so if i did you know
155:28 - uppercase c no matches
155:31 - but i can make it case insensitive with
155:33 - dash i and now i get my matches again
155:36 - now what makes grep really powerful is
155:38 - that it can work with regular
155:39 - expressions which i'm not going to go
155:41 - over right now
155:42 - if you know about regular expressions
155:44 - you know the syntax you can provide
155:46 - regex patterns to grep to search against
155:50 - so you could find all matches of an
155:51 - email pattern or a phone number pattern
155:54 - and that sort of thing okay well i
155:56 - changed my mind i'm going to show a
155:57 - quick example i'm not going to explain
155:59 - any of it
156:00 - because regular expressions is its own
156:01 - crazy topic but what i'm doing here is
156:04 - using a pattern this is a regex that
156:06 - will match email addresses so i'm
156:09 - searching across recursively
156:11 - across in my case the home directory
156:14 - tilde
156:15 - for any matches
156:17 - to this email pattern
156:19 - alright so i didn't type this out myself
156:20 - just to be clear i found an email regex
156:22 - but i'm going to run it
156:24 - and
156:24 - you'll see a bunch of different emails
156:27 - that have been matched
156:28 - being at search.mozilla.org
156:30 - toolkit.mozilla.org
156:33 - toolkit at mozilla again
156:35 - firefox
156:37 - these are all coming from some uh
156:39 - documentation it looks like
156:41 - from firefox here's some other ones
156:45 - anyway the point is we can match these
156:47 - patterns across uh in a file or across
156:49 - our entire machine and there are tons of
156:52 - powerful regular expressions that you
156:53 - can write
156:55 - but we're not going to talk about how
156:56 - that works it's a whole separate topic
156:58 - anyway that's a quick intro to crap next
157:01 - up du disc utility
157:04 - i think that's what it stands for i
157:05 - guess i should verify
157:07 - that would be the logical thing it
157:08 - stands for
157:09 - uh well
157:11 - disk usage no i'm totally wrong i'm
157:13 - pretty sure it's disk usage anyway
157:16 - what we can do with du is find uh the
157:19 - sizes of files and directories on our
157:21 - machine
157:23 - so if i just run du in my current
157:25 - directory wherever i am
157:28 - it's going to give me an output of all
157:31 - the other directories in here and their
157:33 - sizes so you can see
157:35 - you know if i just pick one of these
157:36 - let's find something slightly larger
157:38 - here
157:39 - sure
157:40 - this
157:41 - tar demo folder is 32 kilobytes
157:46 - this wildlife folder is 16. this cleanup
157:49 - directory is 156 kilobytes and so on
157:52 - uh and then down at the very bottom i
157:54 - can see my actual current folder right
157:57 - here
157:57 - is dots is 36 megabytes i can provide a
158:03 - folder to look inside of instead of just
158:04 - my current directory i could say
158:07 - i want to know the pokemon exercise
158:12 - folder
158:13 - what's its size and it's uh let's see
158:15 - 24k
158:16 - we can tell it to give us a different
158:19 - format megabytes or gigabytes using dash
158:22 - g for gigs dash m for megabytes so let's
158:25 - do du
158:27 - we'll do everything here dash m for
158:29 - megabytes
158:30 - uh it's all just one maybe two if i do
158:33 - it on my mac here
158:35 - we may get some more stuff
158:38 - not a whole lot but some of this stuff
158:41 - here's something 410 megabytes here's
158:44 - something that's 25. now you may notice
158:46 - it's not actually giving me uh the unit
158:48 - it's just 1 or 0 or 10. if i use dash h
158:52 - which is for human readable it now is
158:55 - giving me a human readable size so 4k
158:59 - 24k but then also for some of these
159:01 - larger things
159:03 - we get you know gigs 5.7 gigs
159:06 - so this is what i use most of the time
159:08 - if i actually need to read something as
159:10 - a human dash h
159:12 - now here's kind of a nifty thing we can
159:14 - do if i want to find the largest
159:15 - directories on my desktop here i can do
159:18 - d u dash h for human readable
159:21 - okay
159:22 - and i can pipe that to the sort command
159:27 - now we're almost there it is sorting but
159:29 - the way that it's sorting is not exactly
159:31 - correct if you notice here
159:33 - it's doing a sort you know once again
159:35 - based off of the digits so it's saying
159:38 - you know 9.2 m
159:40 - megabytes is somehow smaller
159:43 - than 900 kilobytes
159:46 - so it's putting all the nines together
159:47 - that's
159:48 - that's a start but it's not actually
159:50 - sorting them so sort actually gives us
159:52 - an option if i go to man sort
159:55 - it gives us an option dash h
159:58 - oh where'd you go
160:00 - i lost it here it is human numeric sort
160:02 - so it sorts my numerical value but it
160:04 - takes into account prefix or suffixes
160:06 - like k or m or g
160:09 - so it's for human readable numbers so
160:12 - let's run this again we are going to get
160:14 - a human readable format from du of all
160:17 - the files on my desktop
160:19 - sort them
160:21 - with dash h to make it a human readable
160:23 - sort instead of the default sort
160:25 - and now
160:26 - if we go to the top we get our smallest
160:29 - files
160:30 - the kilobytes and down at the bottom we
160:32 - get our largest files and if i wanted to
160:34 - find the top 10
160:36 - largest files for example i could then
160:39 - pipe that to tail that would be one
160:42 - option and there we go i'm getting the
160:44 - 10 in this case because that's the
160:46 - default for tail
160:47 - largest or i could reverse
160:50 - with dash r
160:52 - and instead get the head which will be
160:54 - the same thing right
160:56 - i'm now getting the sort is in reverse
160:58 - order and i'm taking the first 10
161:00 - instead of the last 10. anyway that's an
161:02 - intro to the d u command the next
161:05 - command we'll see a nice and quick one
161:07 - is df not to be confused with du
161:10 - the du command showed us file sizes and
161:14 - folder sizes whereas the df command will
161:17 - tell us information about the mounted
161:19 - file systems how much space they take up
161:22 - and how much free space they have left
161:24 - so i'll just show you very quickly here
161:26 - if i run df with no arguments or options
161:30 - i'm going to see
161:32 - some output here yours will look
161:34 - different
161:35 - the file system so each individual file
161:37 - system
161:38 - and then the amount of size that it has
161:41 - been allocated how much it uses how much
161:44 - is available now this by default on
161:46 - ubuntu is in one kilobyte blocks it's
161:48 - not so easy to read if i switch
161:51 - over and use the dash h option for human
161:53 - readable
161:55 - now we get megabytes and kilobytes and
161:57 - gigs and that sort of thing
161:59 - okay
162:00 - so we can see things like
162:02 - here is this file system udev
162:05 - uh here's where it's mounted uh here's
162:08 - how large how much space it's been
162:10 - allocated and how much it's using
162:12 - uh i'll show you this on my mac as well
162:16 - so let's do that now i have to zoom out
162:19 - quite a bit just so that we can see the
162:21 - columns but what we'll see here is that
162:24 - some file system uh has been allocated
162:26 - up to
162:27 - 3.6 this is actually tip tebites
162:32 - uh not terabytes uh
162:34 - it's let's see it's a
162:36 - 1.1 times so 10 larger than a terabyte
162:41 - and it really doesn't matter the thing
162:43 - is i know this is a four terabyte
162:45 - computer uh the drive here so three
162:47 - point six terabytes makes sense anyway
162:50 - that's how much space it's been
162:51 - allocated but it's only using this file
162:54 - system at least is only using 10 gigs
162:56 - or you know here's another one this is
162:58 - my slash dev disk 1s2 blah blah blah
163:02 - blah
163:03 - and here's where it's mounted it's also
163:06 - has up to 3.6 tbytes to use but actually
163:11 - it's used 2.2 terabytes out of that
163:15 - anyway you may not really need to use
163:16 - this command but i'm just being
163:18 - comprehensive here one thing that can be
163:20 - nice though is
163:22 - if we pass a file or a folder as an
163:25 - argument to df it will tell us more
163:28 - information about the file system that
163:30 - particular file or folder lives on
163:32 - so if i wanted to know you know where's
163:34 - my desktop and how much space is that
163:37 - file system taking up i can do d let me
163:39 - just clear first i can do df h for human
163:42 - readable and then desktop
163:46 - and we can see this is the file system
163:48 - this is you know the capacity of that
163:49 - file system how much is available and so
163:52 - on
163:53 - so that's all there is to df uh and
163:55 - remember du tells us about the actual
163:58 - sizes of individual files and
164:00 - directories df tells us about i don't
164:03 - know if it's disk free
164:05 - or disk file systems or i don't know
164:07 - what the f stands for i was trying to
164:09 - look at the man pages and figure it out
164:10 - but think of it as disk free sure next
164:13 - up the history command now this one can
164:15 - be very useful especially if you have
164:17 - some long long commands you ran
164:20 - i don't know 20 or 500 commands ago and
164:24 - you want to rerun it and not have to
164:25 - type it yourself again or you don't know
164:27 - what it was that is what the history
164:29 - command helps us with so on its own if
164:31 - we just run history let's do it here on
164:34 - my
164:35 - linux machine so i'm going to run
164:37 - history here
164:39 - i'm going to get a bunch of lines as you
164:42 - can see
164:43 - there's a number next to each and then a
164:46 - command that i ran so we can see a
164:48 - history of all the commands that i've
164:50 - run so history was the most recent
164:52 - command before that i had man df and
164:54 - then d u dash m i had clear i had d u d
164:58 - u d u d u uh you know all these
165:00 - different commands um and let's say this
165:03 - is the command i want to rerun this is
165:05 - the grep that will search for regular
165:07 - expressions uh or sorry it searches for
165:09 - emails using an email regular expression
165:12 - across my entire machine
165:14 - i don't want to have to type this myself
165:16 - one option i guess it's just to copy and
165:18 - paste that definitely but there's also
165:20 - something called history expansion where
165:22 - if i have that number and your numbers
165:25 - are going to be different but if i have
165:26 - a number
165:27 - i can take it and simply run exclamation
165:30 - points and then that number 2064
165:34 - and now it's running that command again
165:36 - it's finding all these matching emails
165:37 - across my machine
165:40 - so
165:40 - just one more example oh geez i need to
165:42 - rerun history
165:45 - and if you prefer you can actually pipe
165:48 - this
165:48 - to less
165:50 - so that command less opens up a program
165:52 - where we can scroll a bit easier we can
165:55 - page through commands one at a time
165:57 - i can find some command like
165:59 - i'm sure this one here
166:02 - that finds
166:03 - things that start with the letter e or f
166:06 - so it's 20 40. i can exit less and just
166:09 - run exclamation point 2040 and now it
166:11 - finds me all the files and directories
166:13 - that have an e or an f uppercase as
166:16 - their first letter another thing you can
166:18 - do is actually combine
166:19 - grep with uh history if you're trying to
166:22 - find some commands you ran a long time
166:24 - ago you know as you probably just saw
166:27 - there's tons of commands here and
166:29 - somewhere in this massive list my
166:31 - history list
166:32 - there was a command i ran and i know
166:35 - that it included the word i don't know
166:37 - cookie but i'm not sure where it is and
166:39 - i want to rerun that well i can run
166:42 - history and then pipe that to grep
166:45 - remember pipe that pipe character allows
166:47 - us to take the output of one command and
166:49 - pass it as input to another so then i
166:51 - can search for
166:53 - cookie
166:55 - and there's quite a few actually
166:57 - surprisingly
166:58 - where there are commands so we're just
167:00 - searching through the text returned from
167:02 - history using grep we found a match five
167:05 - or what six seven different matches and
167:08 - if i want to run one of these i can take
167:10 - that number and exclamation point that
167:12 - number
167:13 - so 1686
167:15 - this is just going to make me a bunch of
167:16 - files so i even want to do that
167:18 - not really but i've already committed
167:21 - okay
167:22 - so you can see it made me those files i
167:24 - think it was cake and cookie and there's
167:26 - cookie
167:27 - cake is up here somewhere anyway that
167:29 - can be quite useful if you know
167:31 - somewhere in this massive history there
167:33 - was some command and it included some
167:35 - pattern or some some word and that's all
167:37 - you remember well you can use grep to
167:40 - search for it the next command we'll
167:41 - cover is ps
167:43 - so ps is a command that helps us inspect
167:46 - or view the process processes processes
167:50 - running on our computer
167:52 - so if we take a look at man ps
167:55 - process status is what it stands for i
167:58 - didn't actually know that i just always
168:00 - thought of process in my head anyway
168:02 - it's going to display information about
168:04 - currently running processes processes
168:07 - and by default if we just run ps i'm on
168:09 - my mac in this example with no other
168:12 - options or arguments it shows me a list
168:15 - of all the processes started uh by me
168:17 - the current user
168:19 - so uh what we see here we've got uh well
168:23 - first of all
168:24 - the process id we've got the time we've
168:26 - got the actual command
168:28 - you can see i've got a bunch of bash
168:30 - shells and uh and then really the only
168:32 - somewhat interesting thing i guess would
168:34 - be this python process i have uh i have
168:37 - a python server in a different tab that
168:39 - i've started but just to show an example
168:42 - i'm gonna start a node server in this
168:44 - tab i've got this app.js i'm going to
168:46 - run it with node here's my server it's
168:49 - running i started a new process
168:51 - now if i run ps again
168:53 - we see
168:54 - somewhere there we are that process
168:57 - right there
168:58 - okay so that is a process i started and
169:01 - we can see it right in this list it has
169:04 - an id
169:05 - and in a moment we'll also learn how we
169:07 - can kill a process where that id can
169:10 - come in handy
169:11 - but there's more to this command we can
169:13 - also view a list of processes initiated
169:15 - by anyone on our machine basically all
169:17 - the processes
169:19 - not just the ones that are user
169:21 - initiated by me
169:23 - so all
169:24 - processes to do that p s
169:28 - a x
169:30 - so this is a pretty common one v s a x
169:32 - we're going to see a lot more going on
169:34 - here
169:36 - so we still have you know that node
169:38 - server i started up we've got our bash
169:40 - instances and then a whole bunch of
169:42 - system stuff look at all these processes
169:45 - now you will see they get cut off here
169:48 - so if they don't wrap over to the next
169:50 - line i can't scroll it just gets cut off
169:53 - so there's a way around that
169:55 - it's a very weird option if we add on
169:57 - two w's a x w w
170:01 - now you'll see that they wrap around
170:04 - so i've got my short processes that i
170:06 - initiated here but then some of these
170:08 - are quite long
170:10 - like this google chrome helper renderer
170:12 - i mean it goes all the way down to what
170:14 - about there i think
170:16 - no actually here i mean that that's very
170:20 - long but it does wrap over instead of
170:22 - being cut off
170:23 - so something that can be very helpful is
170:25 - to combine grep with the ps command so
170:29 - that you can find some process and
170:31 - generally when you're trying to find a
170:33 - process at least when i'm trying to find
170:35 - something i actually might be trying to
170:37 - kill it which is again a command we'll
170:39 - learn shortly
170:41 - so there's this massive list and
170:43 - somewhere in here i do think i have
170:44 - visual studio code open but i don't know
170:46 - what its process id is
170:50 - that's this first column here i could
170:52 - search though so i can recall that
170:54 - command
170:55 - and then pipe it to grep and let's just
170:58 - look for visual to start
171:01 - alright well there's quite a few of
171:02 - those how about visual studio
171:04 - okay so here are all the matches for the
171:07 - visual studio code processes
171:10 - quite a few still wow all right didn't
171:13 - narrow it down all that much
171:15 - but here this is the one we'd probably
171:17 - want to kill the visual studio code.app
171:20 - now i wouldn't actually kill visual
171:22 - studio code this way you can just quit
171:23 - it or force quit it but when i cover
171:25 - kill just in a moment you'll see that
171:27 - there are some situations where you
171:29 - would need to do this you actually would
171:31 - need to find out the process id
171:33 - all right so that's a quick intro to ps
171:36 - there's a lot more to it
171:38 - as you can see there's some options we
171:40 - didn't really cover any of these
171:43 - you can filter processes by who they
171:46 - belong to or who started them you can
171:48 - change the display format you can add
171:50 - more information to be displayed anyway
171:53 - there's a lot more you can do but the
171:54 - basic concept is that it displays
171:56 - information about the processes running
171:59 - on your machine the next command we'll
172:01 - take a look at is top top
172:04 - i actually
172:06 - don't know what that stands for
172:09 - does it tell us not really it says
172:11 - display and update sorted information
172:13 - about processes i think
172:15 - it comes from the fact that it will show
172:17 - us the top
172:19 - most
172:20 - memory intensive processes or the top
172:23 - most cpu intensive processes
172:26 - so what it does if we just run top
172:29 - it's going to open up
172:30 - sort of a different screen we don't see
172:32 - our prompt anymore
172:33 - what we see now is a little dashboard
172:35 - that shows us information by default of
172:38 - the top
172:39 - that must be where it comes from the top
172:42 - most uh cpu intensive processes so you
172:45 - can see over here the command
172:48 - so i've got screenflow that's what i'm
172:49 - using to record this video
172:51 - i've got uh some core audio
172:55 - terminal the top
172:57 - command itself they each have a process
173:00 - id
173:01 - we can see a bunch of other information
173:03 - the memory that they're taking up
173:05 - the cpu percentage
173:07 - and we can also
173:08 - sort instead by memory so if i rerun
173:12 - this it's dash o
173:15 - m e m for memory
173:18 - and you'll see now this is highlighted
173:21 - and we can see they are sorted in order
173:24 - of how much memory these processes take
173:26 - up processes so chrome unsurprisingly is
173:29 - up top and then i've got uh
173:32 - these are i'm using parallels for my
173:34 - virtual machines i have windows running
173:37 - over here and then i've got uh linux
173:40 - running over here so that's what you see
173:42 - there
173:42 - i've got chrome again uh pdf editor
173:46 - the screenflow um anyway it doesn't
173:49 - really matter but what you'll see is
173:50 - different but we can sort things by the
173:53 - amount of memory they take up
173:54 - and we can see that process id which is
173:57 - useful when we want to kill something
173:59 - later on uh you need to reference that
174:02 - process id all right so that's top to
174:04 - get out of here type q
174:06 - that's the easiest way i think you can
174:07 - also get out with control c most likely
174:10 - yeah i just use q the next command we'll
174:13 - cover is kill k-i-l-l
174:16 - we use this command to kill programs but
174:19 - it's actually a little bit more
174:20 - complicated than that it's not just a
174:21 - matter of saying shut this thing down or
174:23 - kill it
174:25 - there are a whole bunch of different
174:27 - different types of signals that we can
174:29 - send when we run the kill program
174:31 - so there's actually a lot of different
174:33 - signals and it can be very overwhelming
174:35 - and confusing if you try and understand
174:36 - them all i'll just quickly show you here
174:39 - if we run the kill command with dash l
174:41 - it's not going to kill anything it
174:43 - instead will list the different signals
174:45 - that we can send
174:47 - so there's things uh actually to make
174:50 - this a bit easier why don't we pipe that
174:51 - to less so i can scroll through it all
174:54 - right so we've got things like
174:56 - sig int and sig il and sig kill sig bus
175:00 - sig term
175:02 - sig charm is actually a pretty common
175:04 - one it's terminate
175:06 - we've got say kill signal kill
175:10 - let's see there's a whole bunch of these
175:12 - the vast vast majority i've never ever
175:14 - had to use
175:15 - and they all are supposed to be
175:17 - different they are supposed to do
175:18 - different things
175:20 - but what's confusing is that it's
175:21 - actually up to the specific program that
175:24 - you're trying to kill it's up to that
175:25 - program source code to handle these
175:28 - different signals
175:29 - okay so let's talk about some of the
175:31 - most common signals
175:33 - and the basic syntax essentially the way
175:35 - that we kill something is by using the
175:37 - process id we saw how we can use
175:40 - commands like ps
175:41 - and top to find a process id
175:44 - and then we specify a signal so
175:47 - we can specify a signal using the long
175:50 - form a word
175:52 - so
175:53 - hup that's a common one means hang up
175:56 - we can send you know term to terminate
175:59 - that's the default but what i prefer to
176:01 - do and what a lot of people do is
176:02 - instead you can use a number so as we
176:05 - saw here there's a number corresponding
176:07 - to each one of these signals so if i go
176:09 - back
176:10 - as i said term is a common one the
176:12 - number there is 15.
176:14 - kill is nine so we could send that
176:17 - signal too all right so
176:20 - if you're wondering what does this all
176:21 - mean when would i use one versus the
176:23 - other the way that i think about it um
176:26 - is that in general i try and use 15
176:28 - first this is the gentlest way to quit
176:30 - something or to stop a process think
176:32 - about with the graphical user interface
176:34 - the different ways of of quitting or of
176:36 - shutting something down
176:38 - one option is to uh just quit your
176:41 - application and save your changes
176:43 - another is to quit and click don't save
176:46 - another option is to
176:48 - force quit the entire application
176:51 - another option is to
176:52 - unplug your computer these all are
176:54 - different ways of of quitting or
176:56 - shutting down a piece of software
176:59 - and that's kind of a silly version uh
177:02 - but the idea is that there are these
177:03 - different signals so 15 or sig term is a
177:06 - gentler way to quit
177:08 - it basically the idea is that your
177:10 - program that you're quitting or killing
177:13 - would have time to
177:15 - tie up any loose ends save any necessary
177:17 - state whereas on the complete other end
177:20 - of the spectrum we have nine which is
177:22 - what a lot of people use so a lot of the
177:24 - tutorials and docs you'll see just says
177:27 - to use nine which is the most brutal way
177:29 - of just shutting everything down and
177:31 - basically just force quitting a program
177:34 - and then there's a whole bunch of stuff
177:35 - in between but i like to try and start
177:37 - with 15 that allows things to shut down
177:39 - how they would normally and if that
177:42 - doesn't work then we use 9 which is just
177:44 - pulling the plug on the life support for
177:46 - that program all right so let's see how
177:48 - it works so just like a burgeoning
177:50 - serial killer we need to find our first
177:52 - thing to kill so fortunately i have a
177:55 - couple of node processes that i want to
177:57 - stop i want to kill
177:59 - if i do ps a here
178:02 - i have a server running uh two actual
178:04 - node servers uh here's the process id if
178:07 - we'll just take that first one and i
178:09 - wanna kill it so i'm gonna copy that id
178:11 - and it turns out that
178:13 - you know i can't stop this any other way
178:15 - normally you start a server and then you
178:16 - can stop it with control c or something
178:18 - but i've lost that window
178:20 - i don't have access to just type control
178:22 - c to quit the server so i need to kill
178:24 - it this way
178:25 - okay so i have the process id now the
178:28 - syntax is kill
178:30 - and then i can provide either a number
178:33 - like if i'm doing nine that is the
178:35 - brutal way of killing something that's
178:37 - the the just immediately kill
178:40 - we can provide the
178:43 - name
178:44 - kill or even the full name sig kill
178:47 - but i'm going to start with the default
178:49 - so if i just kill and then i put the
178:51 - process id in there this will send a
178:53 - term terminate signal that's the gentler
178:56 - way first that's the default so this is
178:58 - a gentle way that gives it time to close
179:00 - up shop and save its state if needed so
179:03 - if i try that i don't get any feedback
179:05 - and if i do psa again
179:08 - it's still there
179:09 - so it didn't seem like it worked just
179:12 - give it a couple of seconds sometimes we
179:14 - will just double check come back nope
179:16 - it's not working
179:18 - so now it's time for more aggressive
179:20 - action
179:21 - we're going to provide a signal and
179:22 - remember we can list all those signals
179:24 - if i do kill dash l
179:27 - this isn't that helpful to be honest uh
179:29 - it i mean it gives us a list but what
179:31 - does this mean
179:33 - what i generally stick with and by far
179:35 - the most common if you are gonna pass
179:36 - one through is nine but remember that's
179:39 - a brutal one nine is the kill signal and
179:42 - that's the one that just pulls the plug
179:45 - so we can pass that in
179:46 - kill let me just clear
179:49 - dash nine
179:50 - and why didn't i just show you it is
179:52 - here right there's that process
179:55 - kill dash nine and then the process id
179:59 - okay once again no feedback whatsoever
180:02 - psa and now it's gone now we just have
180:05 - this other node server running
180:07 - okay so that's the basics of the kill
180:09 - command i know it can be a little
180:10 - overwhelming
180:12 - but the idea is that you provide some
180:14 - signal and then a process id and that
180:16 - signal will be sent to some usually kill
180:19 - or terminate or do something
180:21 - to end that process next up in our
180:23 - killing arsenal is the kill all command
180:26 - so kill all
180:28 - is different from the kill command in
180:29 - that we actually can provide a name
180:32 - instead of a process id we can provide
180:34 - the name of a program that we want to
180:35 - kill
180:37 - and if we have multiple it will kill
180:38 - them all
180:39 - uh so if i happened just
180:43 - maybe happen to have multiple node
180:45 - servers running once again
180:47 - i actually just have them here so here's
180:49 - one
180:50 - and here's the other um
180:52 - i could just you know ctrl c and quit
180:54 - them nice and easy but let's just say i
180:56 - can't uh so i want to kill both of them
180:58 - instead of doing the process ids and all
181:00 - of this i can just do kill all and then
181:03 - provide a signal just like before with
181:05 - regular kill i can do kill or sig kill
181:08 - or nine and this is the most violent way
181:10 - of killing something
181:12 - kill all dash nine and then
181:14 - node so that is the name of the program
181:17 - i wanna kill
181:19 - once again no feedback unfortunately but
181:21 - let's see what happens
181:23 - well i don't see any node processes here
181:25 - and if i go to my terminal windows oh
181:28 - killed
181:28 - and killed
181:31 - so that is the basic use of the kill all
181:33 - command it doesn't require process id
181:35 - it's definitely less precise generally i
181:38 - use kill because i can isolate exactly
181:40 - what i want to kill but if i know
181:41 - there's multiple things or i just it's a
181:43 - pain to find the process id then you can
181:46 - use kill all next up we're going to talk
181:48 - about three commands that go together
181:50 - jobs
181:52 - j-o-b-s
181:53 - vg for background and fg for foreground
181:57 - so these three work in conjunction and
181:59 - they all have to do with running things
182:01 - in the background and well in the
182:02 - foreground
182:04 - so if we have some command or a program
182:06 - that happens to take a long time for
182:09 - example a command like this where i'm
182:10 - using find
182:12 - in the root directory so on the entire
182:13 - machine find all files that have changed
182:17 - in the last one day 24 hours
182:20 - so there's a lot of system files and a
182:22 - whole bunch of stuff it's going to take
182:23 - a long time if i just run it right now
182:26 - i'm going to get a bunch of permission
182:27 - issues but it's still running if you
182:29 - look down here
182:30 - it's going
182:32 - and it's going to take quite a while to
182:34 - check every single file on my machine
182:38 - so it's running in the foreground right
182:39 - now right meaning i can interact with it
182:42 - it's not well happening in the
182:44 - background um so i can stop it right if
182:47 - i do control c
182:48 - that just stops the whole thing
182:50 - um and there's actually something else i
182:53 - can do
182:54 - if i run control z what i can do is
182:56 - suspend it which kind of puts it in a
182:59 - state of uh well suspension it's not
183:01 - stopping it entirely forever it's not
183:03 - ending it it's pausing it so i'm gonna
183:06 - rerun that
183:07 - and by the way what i'm doing here is
183:09 - finding all those files and then putting
183:11 - it all eventually in a file called all
183:14 - changes or all maybe i should rename
183:16 - that to be all changed files or whatever
183:19 - we're not going to be using this to do
183:20 - anything i just am using it to
183:22 - illustrate that we can have these things
183:24 - that take forever
183:25 - so if i hit control z
183:27 - right now
183:29 - you'll see it says stops right here so
183:32 - this is slightly different than what
183:33 - happened earlier
183:35 - and now if i type the jobs command which
183:38 - is how we can check up on any jobs we
183:40 - have running
183:42 - we see this program
183:44 - is currently stopped
183:47 - okay so let's try doing something else
183:50 - what about uh the top command if you
183:52 - remember this it's going to show me all
183:54 - these different processes on my machine
183:57 - and how much memory and all the stuff
183:59 - they're taking up
184:01 - and i can use control z to stop this as
184:05 - well so ctrl c just gets me out of there
184:08 - if i do control z
184:11 - it actually stops that or pauses it and
184:14 - if i type the jobs command again now we
184:16 - have two jobs in here
184:18 - so two different jobs
184:20 - that are both control z they're both
184:22 - suspended
184:24 - now what i can do is selectively
184:27 - re-run or resume one or both of these
184:30 - jobs in the foreground like what we saw
184:32 - here is in the foreground
184:34 - or i can actually run them in the
184:36 - background so that they they keep going
184:39 - but i won't see all this text i won't
184:40 - see them in my terminal but they'll
184:42 - still be running
184:43 - so this jobs command is just how we
184:45 - check up on jobs see what their state is
184:47 - and they also have
184:49 - an id or a job number and that's
184:51 - important because when we want to
184:53 - selectively resume them we can use those
184:55 - numbers
184:56 - all right so the first command i'm going
184:58 - to show you after jobs is actually fg
185:01 - for foreground
185:02 - so if we run foreground and then we
185:04 - specify a number a job number
185:07 - that job will be resumed so if i want to
185:10 - resume the top command its number is 2.
185:14 - so if i do fg
185:16 - 2 there we go
185:19 - it is now running again and it's in the
185:21 - foreground
185:22 - so i could suspend it with ctrl z or i
185:25 - can just get out of here control c or q
185:28 - if i look at jobs now we just have this
185:31 - one job right this is my find program
185:35 - now i can resume this in the foreground
185:38 - by doing fg
185:39 - and then the number one
185:41 - or because it's the only job i could
185:42 - just type fg
185:44 - so i'm going to do that now
185:47 - and here we are it's resumed again in
185:49 - the foreground it's just going to take
185:50 - forever and maybe we'll get some
185:52 - permission denied stuff
185:54 - let's see if there's any text
185:56 - and if i grow tired of this i want it to
185:58 - run in the background i don't want to
186:00 - see all this taking up my terminal
186:02 - screen i want it in the background not
186:03 - the foreground i can suspend it
186:06 - and
186:07 - go back to jobs
186:09 - it's suspended
186:10 - i can resume it but instead of doing
186:12 - foreground one
186:14 - i can do background one whoops
186:17 - and that will resume it it will be
186:19 - running but i'm not gonna see it running
186:22 - so i'm gonna do that
186:24 - so it gives me a little message saying
186:25 - all right this is running and it's in
186:27 - the background and the way that we know
186:28 - it's in the background there's two ways
186:30 - one this ampersand means something is
186:32 - running in the background two if i type
186:34 - jobs
186:35 - it's telling me right here running
186:38 - so it is running but we don't see it
186:39 - running right we don't see all that text
186:42 - but by using the jobs command we can
186:43 - verify it is indeed running
186:45 - i could bring it back to the foreground
186:47 - if i wanted to you know foreground
186:49 - i don't have to specify one it's the
186:51 - only job and here it is it's in the
186:53 - foreground
186:55 - and that's really all that there is to
186:56 - this
186:58 - we can run things in the foreground in
186:59 - the background and we can use the jobs
187:01 - command to check up on them
187:03 - this is going to just take forever let's
187:05 - see if it ever finished i'm just going
187:07 - to quit or stop it uh let's look at our
187:10 - all changes file
187:13 - yep so it's got a lot of stuff in there
187:16 - and let me just prove this to you one
187:17 - more time that it does work so i'm going
187:18 - to remove that all changes file
187:21 - yep
187:22 - all right so now we no longer have that
187:23 - all changes file if you remember i said
187:26 - the ampersand is one way we can send a
187:27 - job to the background uh so here's
187:30 - another a very stupid program in this
187:33 - context uh sleep
187:35 - is uh just going to stop if i just run
187:38 - sleep five i'll just show you the man
187:39 - page this is a new command it just
187:42 - delays for a number of seconds so five
187:45 - seconds i won't do that long let's do uh
187:47 - sleep two seconds
187:49 - so you'll see nothing happens it's a
187:51 - delay for two seconds and then my prompt
187:53 - comes back so we can use this if we're
187:55 - writing a script or something where we
187:57 - need to stop to wait for
187:59 - uh data to come back or to wait for
188:03 - to make a user feel like something is
188:04 - taking longer than it actually is for
188:06 - better ui there's all these different
188:08 - uses but typically i don't run sleep
188:10 - unless i'm teaching it
188:13 - now i can run this in the background so
188:14 - let's do a long sleep like
188:16 - 50 seconds
188:18 - so if i ran this in the foreground again
188:20 - it's stupid to do this but if i did i'm
188:23 - waiting here for 50 seconds um and i
188:25 - can't do anything else so i'm going to
188:27 - control c and end that but if i run it
188:30 - in the background which i can do by just
188:32 - adding an ampersand so sleep for 50
188:34 - seconds in the background that's what
188:36 - the ampersand at the end means
188:38 - now i don't see that happening here if i
188:41 - look at jobs
188:42 - it is running though it is a job it's
188:45 - running in the background
188:46 - and then i could bring it back to the
188:47 - foreground if i wanted to just like that
188:50 - and now it's running in the foreground
188:52 - all right uh so i'm just gonna stop it
188:54 - anyway and if i go back to jobs now
188:56 - there's no jobs all right so that's kind
188:58 - of a lot of stuff around
189:01 - jobs and foreground and background
189:03 - let's just recap that so if you have a
189:05 - program you run a command put an
189:07 - ampersand at the end
189:08 - it's going to run in the background if
189:10 - we don't do that but we want it to run
189:12 - in the background i say after the fact
189:15 - let's rerun my find command this long
189:17 - find command i could run it
189:20 - and then
189:21 - suspend it
189:22 - and then decide i want that to run in
189:24 - the background so i could get the job id
189:27 - i happen to know there's only one job
189:29 - but i could get that id and now say go
189:31 - in the background one
189:33 - and now it's running in the background
189:35 - and it will take a while eventually it
189:37 - will complete
189:39 - it's still running as we can see here it
189:41 - has that ampersand it shows us it's
189:42 - happening in the background
189:45 - i don't know how long it's going to take
189:47 - quite a long time but eventually it will
189:49 - finish
189:50 - next up we're going to talk about
189:52 - compressing files
189:53 - we'll first talk about the gzip command
189:56 - which is used to compress files
189:59 - it uses an algorithm called gzip there
190:01 - are multiple different compression
190:03 - algorithms if we take a look at gzip on
190:06 - the man pages
190:08 - it the whole idea is that it reduces the
190:10 - size of files using
190:13 - lenthil ziv coding lz77
190:16 - so you know compressing is a very
190:18 - complicated um interesting but very
190:21 - complicated
190:22 - area of study and there are quite a few
190:23 - different algorithms
190:25 - but one of the most common on linux at
190:27 - least is gzip so the way that it works
190:30 - is that we have some file hopefully a
190:32 - larger file that we're trying to reduce
190:34 - the size of
190:35 - and we provide it to gzip however i
190:38 - would warn you it's not a huge deal but
190:40 - if you just run gzip with a file name it
190:43 - is going to take that original file
190:45 - compress it and replace the original
190:47 - file so you'll only have the compressed
190:49 - version that ends in gz
190:52 - that's just the extension that it gives
190:53 - it uh if you want to keep the original
190:56 - file you can do two different things
190:58 - this is a slightly clunkier way but the
191:00 - better option in my opinion is to use
191:02 - dash k
191:04 - i don't know if it stands for dash keep
191:05 - that's what i think in my head
191:07 - and that will keep the original file so
191:09 - let me just demonstrate this here i've
191:11 - got a somewhat large text file if i just
191:14 - uh cat it out it's a lot of stuff in
191:17 - there it's the result of running a find
191:19 - command and redirecting the output into
191:21 - this file okay so if i run gzip and i'll
191:24 - do dash k
191:25 - on that file
191:27 - we don't get any output which i'll show
191:29 - you how to correct in just a moment if
191:31 - you want some output but if i type ls
191:34 - we now have
191:35 - this file here all changes.txt so the
191:38 - same name but now it has an
191:41 - additional.gz.gzip extension
191:44 - if i do an ls-l
191:47 - we can see the file
191:48 - size difference but actually let's make
191:50 - it human readable with lh for human
191:52 - readable
191:54 - pretty significant
191:55 - reduction in size almost 2 megabytes
191:58 - down to 200 kilobytes
192:00 - now i'm going to remove that
192:02 - so remove all changes.txt
192:05 - and uh i'm going to just show one more
192:07 - oh no
192:09 - i removed the wrong thing
192:11 - well that's annoying all right
192:14 - it's gone i don't have that original
192:16 - file if you remember when i talked about
192:17 - remove
192:18 - when you remove it doesn't go to a
192:20 - temporary recycling bin it is gone but
192:23 - the good news is we do have the
192:25 - zipped file the gzip compressed version
192:28 - and i can unzip that to get my file back
192:31 - so we'll just jump ahead and talk about
192:33 - unzipping so the way that we can do that
192:36 - is to use the dash
192:38 - d option to decompress that is one way
192:42 - of doing it
192:43 - and then there's also a totally separate
192:45 - command called g unzip which you can use
192:49 - which is basically the exact same thing
192:51 - there's a couple more options but it
192:53 - will unzip a gzip compressed file in the
192:57 - same way that gzip dash d will unzip
193:01 - so let's start with uh well why don't we
193:03 - do g unzip
193:06 - all
193:07 - changes.txt.gz
193:08 - all right i type ls and there we are i
193:12 - now have the uncompressed if we do ls-l
193:16 - let's do lh
193:17 - 1.8 megabyte version
193:20 - okay
193:21 - so let me just show one more thing when
193:23 - we g-zip it again so i have that
193:25 - original i want to keep the original and
193:28 - if i add dash v for verbose it's going
193:31 - to give me information about
193:33 - how much space it reduced or how much it
193:35 - compressed the file
193:37 - all right so i'm going to do gzip dash
193:39 - kv and then
193:41 - my file is all changes.txt
193:44 - and it says it reduced it by almost 87
193:47 - if we do lh for ls
193:49 - we can see once again 1.8 m
193:52 - 232k so a lot smaller and then just one
193:57 - more time we can use g unzip
194:00 - or we can do gzip dash d
194:03 - for decompress
194:05 - on that file
194:07 - and it's going to ask me if i want to
194:08 - overwrite
194:09 - because what i'm doing here right i kept
194:12 - the original so i would be unzipping
194:15 - a new file with the exact same name do i
194:17 - want to replace it sure
194:19 - okay
194:20 - and now
194:22 - we're back to what we were at before
194:25 - it is well let's do h again 1.8
194:28 - megabytes so i unzipped
194:30 - and that's kind of all that there is to
194:31 - that one thing that's important to know
194:33 - about gzip is that it will only zip
194:36 - individual files so it won't you know it
194:38 - won't take 10 files and zip them
194:40 - together into a single compressed file
194:42 - we'll see how to do that with a
194:43 - different command
194:45 - but just to show you what happens if i
194:47 - make let's see i have this one file
194:49 - let's make another file whoops
194:51 - just with some very small text in there
194:54 - i'll call this one.txt
194:56 - and let's do it again actually for 2.txt
195:00 - okay so i now have three files in here
195:02 - if i do gzip and i'll do dash k if i
195:05 - want to keep the originals sure
195:08 - g g zip dash k and then
195:12 - we'll do v as well for verbose all
195:15 - changes and then a space
195:17 - one and two i can provide multiple files
195:21 - and it does compress them but it
195:23 - compresses them individually so we end
195:25 - up with
195:26 - three different gzip files
195:29 - okay so it did not combine them it just
195:32 - compressed multiple
195:33 - so that brings us to our next command
195:36 - tar tar tar is a command that we use to
195:40 - create an archive which is basically a
195:43 - grouping of a bunch of files potentially
195:44 - a bunch of files together into a single
195:47 - file and then we can go and compress
195:49 - that file so the name tar is short i
195:51 - think for tape archive an older
195:54 - relic of uh days gone by
195:57 - but anyway the way that it works is it's
195:59 - kind of complicated there's a lot of
196:01 - options the man page if i just go to
196:03 - mantar it's very long lots of options
196:07 - but i'm just going to show you some of
196:08 - the most basic things that you might
196:10 - want to do primarily taking a folder
196:12 - full of a bunch of files and combining
196:14 - them down into a archive and then
196:17 - compressing that so that we have a
196:19 - single file that is compressed that we
196:21 - can then unzip later and then expand
196:24 - back into a whole bunch of files
196:26 - okay so the syntax the basic syntax is
196:29 - to run tar
196:30 - and then a couple of options to create a
196:32 - new archive
196:34 - to smush files together
196:36 - we provide the different files we want
196:38 - to smush together separated by spaces
196:40 - we provide two options c for create and
196:44 - then f is it's the way we provide the
196:46 - file name that we want it to create so
196:49 - if we provide f we must provide the
196:51 - archive name unlike when we zip a single
196:54 - file it can you know gzip can just use
196:56 - the name of that file and append gz but
196:59 - here we're combining files together so
197:01 - we need to provide an end result name
197:04 - okay
197:05 - so i have
197:07 - a simple oops
197:09 - let me go into that folder a simple
197:11 - folder here
197:12 - ls-lh shows us we've got three files
197:16 - lots of text more text and song of
197:17 - myself.txt
197:19 - i'm going to combine the three of these
197:20 - into a new archive so the way that i do
197:22 - that is tar
197:24 - c for create f
197:27 - is the file option so i provide the file
197:29 - name for the archive i'm going to call
197:31 - it
197:31 - um
197:32 - i don't know archive okay
197:35 - and conventionally these end with dot
197:37 - tar as the extension
197:39 - and then we'll just provide the file so
197:41 - song of myself
197:43 - what was it lots of text more text and
197:46 - then i'll hit enter and this will create
197:48 - a new archive file as you can see right
197:50 - there
197:52 - and this does not mean it's compressed
197:54 - to be clear
197:55 - okay it's just a single file if you look
197:57 - at the file sizes 3.6 megabytes well we
198:00 - had 1.8 1.8 and then 85 kilobytes so we
198:03 - did not lose any size along the way this
198:06 - is not compressed but now i could go and
198:09 - compress this if i wanted to
198:11 - but before we do that let me show you
198:13 - how we can un-archive to extract files
198:16 - from an archive we use the dash x option
198:19 - for extract
198:20 - c was to create x is for extract
198:23 - and if we just do x f and then we need
198:26 - to provide the file name once again this
198:28 - would be the archive we just created
198:30 - this will unarchive it in our current
198:32 - folder but we can also move them so we
198:35 - can provide a directory a destination
198:37 - with dash c
198:39 - and before that we can actually just
198:41 - view what's in the file if we use the
198:44 - dash t option
198:46 - so i can just show you that
198:48 - why don't i move my archive somewhere
198:50 - else let's move um why don't i just make
198:53 - a new directory i'll just call this
198:56 - somewhere
198:57 - and then i'll move my archive into
198:59 - somewhere
199:00 - okay so let's cd into somewhere all
199:03 - right so now i can show that dash t
199:05 - option which we can use to view the
199:07 - files uh that are inside of this archive
199:10 - so we have this let's just say i
199:11 - downloaded it i don't know what's in it
199:13 - well i can do a tar
199:16 - t
199:16 - f archive
199:18 - there we go it says hey there's three
199:20 - files in here
199:22 - i don't have them they're not
199:24 - out of that archive they're still in
199:25 - there all combined down into a single
199:27 - file but i can then extract them i'll
199:30 - just do it in the current directory
199:32 - so to do that it is tar
199:34 - x f and then the archive
199:38 - now i have those three files as you can
199:40 - see here
199:42 - okay and then again i could provide a
199:43 - destination instead if i want to extract
199:45 - them somewhere else with dash uppercase
199:48 - c
199:49 - okay so still no compression the next
199:52 - step is to combine compression gzip is
199:55 - going to be our algorithm along with
199:57 - archiving with tar
199:59 - so we can do this separately just to be
200:01 - clear i could do
200:03 - if i uh just remove
200:06 - lots of text more text and song of
200:08 - myself
200:10 - yes yes yes okay
200:13 - so i have this empty directory except
200:15 - for the tar i can compress that tar as
200:18 - we saw with gzip so gzip and then i'll
200:21 - do dash k to keep the original file if i
200:24 - want to
200:24 - archive.tar
200:26 - and now i have the compressed version
200:30 - okay so it's only 502 kilobytes compared
200:33 - to 3.6 megabytes
200:35 - so let's delete the original tar so
200:37 - rmarchive.tar
200:41 - and now i just have the compressed
200:44 - archive so this is really you know a
200:46 - bunch of files combined down into a
200:48 - single archive then compressed this
200:50 - might be something we download or
200:51 - something we get from some mysterious
200:54 - source now i want to get it back to the
200:57 - original files that are inside of it so
200:59 - i need to uncompress and then i need to
201:01 - unarchive
201:03 - so to uncompress or decompress remember
201:06 - we use gzip
201:08 - and then dash d
201:10 - and then the name of the file
201:13 - so now i just have the regular archive
201:14 - it's much larger right 3.6 megabytes
201:18 - now i need to uh on archive so we need
201:22 - tar.
201:24 - x for extract
201:26 - f so we provide the file which is
201:28 - archive.tar
201:30 - and there we are we get our original
201:32 - stuff back out
201:34 - okay so we can do it in two different
201:36 - steps like we did there make the archive
201:38 - then compress and then uncompress go in
201:40 - the other direction uncompress and then
201:42 - unarchive or we can actually use just
201:45 - the tar command to do it all together
201:48 - the tar command
201:49 - has a special option z for gzip which
201:53 - will also compress and archive with that
201:55 - gzip algorithm at the same time
201:58 - so instead of two separate steps we can
201:59 - do it at once so i'll just show that
202:01 - real quick
202:02 - let's do the same thing
202:03 - let's remove my archive i have my three
202:06 - files i'm going to combine them together
202:09 - with tar
202:10 - i'm going to do create i'm going to zip
202:13 - with
202:14 - gzip and then i'm going to do f so i can
202:16 - provide the file name we'll call this
202:18 - bundle this time dot
202:21 - tar and then space the files i want
202:27 - okay
202:28 - and take a look at what we get
202:30 - i should have probably named it with a
202:32 - dot gz extension but if we look at the
202:35 - bundle.tar
202:37 - it is compressed it's much smaller so
202:39 - you don't have to have that extension
202:40 - but you want that there if somebody else
202:42 - sees it
202:43 - so they know you know this is a gzip
202:46 - file
202:47 - and you need to use g unzip
202:49 - to unzip it so if i want to remove these
202:52 - files so we just have the single archive
202:55 - or the bundle file
202:58 - okay
202:59 - there we are now to unzip it and
203:02 - unarchive i can just run our regular old
203:05 - tar
203:06 - x for extract f provide the file name
203:10 - i don't even have to tell it to use g
203:13 - unzip so let's try it there it is
203:15 - remember it looks like this 500
203:17 - kilobytes single file
203:19 - i'm going to do atar
203:21 - extract and the file name is bundle.tar
203:24 - and let's see what we get
203:26 - there we are we got the three files back
203:28 - out all right so we saw two ways of
203:30 - doing it first we can create a bundle or
203:33 - create a tarball and then compress that
203:36 - or we can do it all in one go if we have
203:38 - multiple files we want to combine and
203:41 - compress we can provide the dash z
203:43 - option as we saw here to create a gzip
203:47 - compressed file next up we'll talk about
203:49 - a fun command called nano n-a-n-o
203:52 - nano is actually a text editor you can
203:55 - run directly from your terminal now
203:57 - there are other text editors some that
203:58 - are quite a bit more powerful
204:00 - than nano
204:01 - but they are also quite a bit more
204:03 - complicated to learn and when you're
204:05 - starting out you can really mess things
204:06 - up so things like vim if you've ever
204:08 - heard of vim
204:10 - powerful but really tricky to learn when
204:13 - you're starting out and also could have
204:14 - its own hour long video there actually
204:16 - are courses on just using it so we're
204:18 - not going to go into that but nano is
204:21 - another editor that comes built in that
204:23 - we can use and the reason it's good to
204:25 - know one of these editors at least and
204:27 - there are others there's emacs and the
204:29 - reason it's good to know them is that
204:31 - you can directly very quickly change
204:33 - files or make modifications add things
204:35 - onto files
204:37 - without having to go through the whole
204:39 - process of opening up an external
204:40 - graphical editor you know you can do
204:42 - things quickly
204:44 - so i don't use something like nano as my
204:46 - main editor i like using vs code or
204:49 - something similar but it doesn't mean
204:51 - you shouldn't know how to use it now the
204:52 - basic usage is nano
204:54 - followed by some file name we want to
204:56 - edit
204:57 - so what do we have here i've got a song
204:59 - of myself
205:00 - txt
205:02 - i'm going to open that up with nano so
205:04 - this is a file we've been using quite a
205:06 - bit throughout the course and when i hit
205:08 - enter you'll see that my prompt goes
205:11 - away i'm now in an editor i can use the
205:14 - arrow keys to move and i can actually
205:16 - immediately start editing and this is
205:17 - different if you ever have encountered
205:20 - vim if you start typing
205:22 - you're not actually going to be editing
205:24 - things immediately there's all these
205:25 - different modes and you might be messing
205:27 - things up significantly but i can start
205:29 - typing so if i want you know i can say
205:31 - hello there
205:34 - and
205:35 - i can use my arrow keys left and right
205:36 - just like a regular cursor up and down
205:39 - um
205:40 - and let's just start with that i'll make
205:42 - a little change there
205:44 - all right so i've made this change
205:46 - now i want to save this
205:48 - this is probably the most important part
205:50 - of working with nano is down at the very
205:52 - bottom
205:53 - down here
205:54 - is kind of a little toolbar
205:57 - this is a list of shortcuts the
206:00 - different commands we can use inside of
206:01 - nano and one of the most important ones
206:04 - is
206:05 - this right here control x this is how we
206:07 - can exit
206:08 - so if i do control x right now
206:11 - first it's going to ask me before you go
206:13 - do you want to save or not
206:15 - i'll save that change so i'll hit y
206:18 - if i don't want to save it i'll type n
206:20 - and if i don't want to quit i can do
206:22 - control c
206:24 - okay so i'm going to hit y to save
206:27 - and then it's going to ask me well do
206:28 - you want to keep the same file name do
206:30 - you want to make a new file name uh you
206:32 - know save it somewhere else i'm just
206:34 - going to hit enter and keep the original
206:36 - file so i'm just saving a new version of
206:39 - song of myself instead of a copy
206:42 - all right
206:43 - so it's still there and how do i take a
206:45 - look at the beginning of the file i just
206:47 - want to see if it changed head song of
206:49 - myself
206:50 - there it is we did successfully make a
206:52 - change
206:53 - now there's more that we can do so i'm
206:55 - going to reopen that file
206:56 - in nano
206:58 - and a couple of things first of all if
207:01 - you notice on the right side here uh i'm
207:03 - getting a little angle bracket uh
207:05 - greater than sign that is telling us
207:07 - that there's more text
207:10 - so you can actually turn word wrapping
207:11 - on or line wrapping if you prefer for it
207:13 - to wrap over
207:15 - but i think the default is for it to
207:16 - just scroll as you see there
207:19 - we have different shortcuts
207:21 - down here so if we wanted to search for
207:25 - example
207:26 - to find something in this file i can do
207:28 - control w all right so control w and
207:31 - then i can provide something i want to
207:33 - look for so
207:34 - i want to change the word green in this
207:37 - file so i'm going to type green and i'll
207:39 - hit enter
207:41 - and
207:42 - my cursor shows up right there on the
207:44 - first match of green
207:46 - now i can keep searching again if i do
207:48 - ctrl w and hit enter again see it
207:51 - already remembers green
207:53 - it takes me to the next match so let's
207:55 - just make this all caps
207:58 - and very long green
208:01 - all right
208:02 - uh i'll save and as we saw previously
208:05 - one way of doing that is by quitting and
208:07 - it will prompt me do you want to save
208:09 - blah blah blah
208:10 - but if i don't want to quit and i just
208:12 - want to save my changes i actually do
208:14 - have ctrl s
208:15 - so i just did it it doesn't show up down
208:17 - here
208:18 - there's far more options that don't show
208:20 - up down here
208:21 - i'll show you how to view them in a
208:22 - moment but ctrl s does save to the
208:26 - current file right it's not making a new
208:27 - file name it doesn't give you an option
208:29 - do you want to save this somewhere else
208:31 - it just saves
208:33 - to the same name okay
208:35 - so if i type ctrl g right here
208:38 - get help
208:40 - i wish it was ctrl h ctrl g is harder to
208:42 - remember
208:43 - we get a whole manual here
208:46 - that explains how it works and then
208:48 - explains all the different shortcuts so
208:50 - there's quite a few things in here
208:52 - we saw ctrl w to search forward
208:56 - we can actually insert another file into
208:59 - this file or into this buffer with ctrl
209:01 - r
209:03 - we can cut and paste so this is one that
209:06 - you know you've probably noticed control
209:08 - c
209:08 - uh and control v for copy and paste
209:11 - don't really work in the terminal
209:13 - control c has its own meaning uh
209:15 - just like control z has its own meaning
209:18 - to suspend a job anyway uh we still can
209:22 - cut and paste the way that we can do it
209:24 - is with ctrl k to cut
209:27 - it actually stands for kill
209:29 - and then u
209:30 - to revive or to unkill i don't know what
209:33 - the u stands for
209:35 - and that will
209:36 - basically take whatever we've cut out
209:38 - and paste it so i can show you that
209:41 - there's options to configure a spell
209:43 - checker
209:44 - we can display line numbers we can go to
209:46 - a particular line number if we know what
209:48 - we want with uh where's that
209:51 - control underscore
209:53 - there's a bunch more stuff so you know
209:54 - this is not a course on nano but just so
209:57 - you know there's a lot to nano
209:59 - okay so to get out of here ctrl x is
210:02 - going to close the help screen
210:05 - now as i said i want to show you cutting
210:07 - and pasting so if i want to cut a line
210:11 - i guess maybe i'll just type a line
210:13 - first
210:14 - hi there
210:15 - cut me out of here please
210:18 - all right if i do ctrl k
210:21 - it's gone
210:22 - and then i can move it down somewhere
210:24 - maybe here and ctrl u
210:27 - it revives it and i keep hitting ctrl u
210:29 - there we go
210:31 - it's just like cut and paste uh if you
210:33 - do forget about that we can see
210:35 - shortcuts down here
210:37 - okay so i'm going to save control s we
210:40 - also can do control o to write out if i
210:43 - wanted to create a copy or a different
210:44 - file name i could type that here so
210:47 - maybe uh you know song of myself 2 dot
210:51 - txt and this is my version
210:54 - i'll hit enter do i want to save it
210:55 - under a different name sure
210:57 - and then i'll get out of here ctrl x
211:00 - one more thing i'll show you you can
211:01 - actually create a new file with nano so
211:04 - if i need to add some text into
211:06 - something
211:07 - a file that doesn't exist i don't have
211:08 - to make the empty file first then open
211:10 - it with nano i can just do nano new file
211:12 - dot txt
211:14 - and now i have an empty file i can type
211:15 - my stuff in here
211:16 - save and quit
211:18 - control s control x and there it is
211:21 - song of myself too from the previous
211:24 - nano and then uh new file.txt
211:28 - okay
211:28 - next up we have the alias command the
211:31 - alias command allows us to define our
211:33 - own aliases our own our own little short
211:36 - custom commands
211:37 - that we can then reuse later on so for
211:40 - example if we find ourselves doing you
211:43 - know ls
211:44 - remember just gives us this information
211:47 - ls-a
211:48 - gives us all including hidden files
211:50 - ls-la
211:52 - gives us listed long format information
211:54 - for all files
211:56 - if we find ourselves doing that a lot we
211:58 - could set up our own alias so that we
212:00 - don't have to type all of that and maybe
212:02 - just have la
212:03 - for example
212:05 - so if we wanted to do that i want la to
212:07 - actually be ls-la
212:10 - the way that we do that is by using the
212:12 - alias command
212:13 - so i'll show an example here i'm going
212:15 - to do alias
212:17 - and then
212:18 - let's just call this my i'm gonna do
212:21 - something really obvious first like uh
212:23 - my ls
212:25 - equals and then in quotes i'm gonna use
212:28 - single quotes there's a distinction here
212:30 - uh single quotes and then i'll do ls
212:33 - dash
212:34 - la just like that
212:37 - okay
212:38 - so if i type alias now
212:40 - i'm gonna see a list of all my aliases i
212:42 - actually have quite a few on here here's
212:44 - the one i just made
212:46 - already and if i try running it my
212:48 - ls there we go i have a new alias
212:52 - i could take something you know really
212:54 - long like if there's some find command
212:57 - that i use a lot
212:58 - let me just show an example here
213:00 - i think i have yeah like this one right
213:03 - here this finds some of the i think it's
213:05 - the top 10 uh most uh cpu intensive
213:09 - processes on my machine um honestly i
213:12 - never use it because i don't even
213:13 - remember this
213:14 - but if i run that it's a very long
213:17 - command relatively long
213:18 - i can alias it to something short so
213:20 - pscpu10
213:22 - and there we are i need to sort of zoom
213:25 - out my font size is too large for me to
213:27 - make sense of this here but that's all
213:28 - right i'm recording i need that large
213:30 - font size the alias we just defined is
213:32 - not permanent if i close this window or
213:35 - even just open another window
213:37 - my ls
213:39 - huh
213:40 - it's not working
213:42 - it doesn't know what the heck i'm
213:43 - talking about so when i just define an
213:45 - alias like bobo right here
213:49 - equals
213:50 - i don't know how about just sleep for 10
213:53 - seconds
213:54 - okay
213:56 - when i define that in my shell directly
213:58 - here
213:59 - it only exists in this exact instance
214:02 - right here
214:03 - it is not going to be created every time
214:06 - i open up a new terminal window or my
214:08 - computer restarts i lose it
214:10 - so if i want to make an alias last if i
214:12 - want to have it persist i need to put it
214:15 - in one of a couple different places
214:18 - it depends on what shell you're using if
214:20 - you're using bash if you're using z
214:21 - shell
214:22 - there are different configuration files
214:25 - now
214:26 - over here i'm using bash this is ubuntu
214:29 - the default shell is bash
214:31 - and if i go to my home directory it's
214:32 - actually where i am right now again home
214:35 - meaning my home folder not the folder
214:38 - actually called home it's confusing but
214:40 - my user's home folder colt um if i do ls
214:43 - dash a
214:44 - there are some of these special config
214:46 - files now there's actually on ubuntu
214:48 - there's one called bash aliases and that
214:50 - is a good place to put aliases however
214:53 - that is particular to some distributions
214:56 - of linux it is not something that you
214:58 - may not see it depending on what distro
215:00 - you're using
215:01 - so a safe place is going to be the bash
215:04 - rc file so it's hidden
215:09 - rc uh and i can open it up i'll use nano
215:11 - to edit it dot bash rc
215:14 - okay now i'm in nano i can scroll down
215:18 - and i can define my own aliases in here
215:21 - um so let's just i think i already have
215:24 - some here there we are
215:25 - uh so i'll just define some in here just
215:28 - as an example uh alias
215:30 - and i'm just going to write the exact
215:32 - same thing that i wrote earlier
215:34 - except i'm putting it in this file and
215:36 - what's special about this file is that
215:38 - when the shell loads up it will run this
215:40 - file and it will run these aliases first
215:43 - before i even have a chance to do
215:45 - anything else
215:46 - in other words it will know about all
215:48 - these aliases i define
215:50 - so um let's see what should we do in
215:52 - here i'll make it an alias called
215:55 - um count
215:57 - okay and count is going to echo
216:00 - and if you remember our expansion i'll
216:02 - just echo 1 to 99
216:05 - i don't know why we do this but sure we
216:07 - will
216:08 - uh and then i'm going to save this file
216:10 - so this is nano the easiest way is just
216:12 - control s
216:14 - and then i'm going to exit with control
216:15 - x
216:16 - okay
216:17 - so can i run counts no i can't run count
216:21 - just yet
216:22 - i could open up a new window and it will
216:24 - run that bash rc file and now if i try
216:27 - running count hey it works
216:29 - alternatively if i don't want to do that
216:31 - i can actually source the command is
216:33 - called source
216:34 - my bashrc file and now i can run count
216:37 - in this same window now if you're on a
216:40 - mac
216:41 - the default shell is z shell as we
216:43 - discussed earlier
216:44 - you could switch over to bash if you
216:46 - wanted to
216:48 - and just type bash and now i'm using
216:51 - bash and i can define my files
216:53 - or rather i can define my aliases
216:56 - inside of my let's do ls-a here
216:59 - lots of hidden files
217:01 - inside of my bash profile here
217:03 - that's where i could do it on a mac or
217:05 - more likely if you're using z shell
217:07 - which is the default shell
217:09 - the file we want to add our alias to is
217:12 - dot zshrc
217:15 - where are you z
217:17 - shrc right there
217:19 - so that is our configuration file for z
217:22 - shell so i can do nano dot z s h
217:25 - r c
217:27 - and scroll down i don't have to scroll
217:29 - down i can define my aliases anywhere in
217:31 - here but somewhere in here i can define
217:33 - an alias so let's do a different i don't
217:36 - know a different version of count
217:39 - these are how we write comments by the
217:41 - way
217:42 - so if you want to have a little note or
217:44 - you want to uh have something not take
217:46 - effect you can put a octathorp or a hash
217:48 - sign in front of it so alias let's call
217:51 - this one um hmm
217:53 - let's do
217:55 - uh i'll just do another
217:56 - i don't know count
217:59 - count again but this time on my mac
218:02 - count is going to be an echo
218:06 - about
218:08 - 1 to 365
218:11 - sure
218:13 - all right
218:14 - and that's it we could also define you
218:17 - know l a more useful and how about ll
218:21 - which will be ls dash l
218:24 - and how about uh
218:26 - we'll do l a
218:28 - will be ls
218:30 - dash l a
218:31 - so
218:32 - now
218:34 - and actually why don't i do one more why
218:36 - don't i alias rm
218:39 - to instead be rm dash
218:41 - verbose so it tells me when it deletes
218:44 - something so i have that over on my
218:46 - ubuntu
218:48 - over here which you may have noticed so
218:50 - let's just define those three alias or
218:52 - four we have count lla and rm i
218:55 - redefined the rm command to actually be
218:57 - rm-v so that dash verbose option is
219:00 - always there
219:01 - i'll save and exit
219:04 - yes i'll save okay so in a new window i
219:07 - can run my count command
219:09 - i have the ll command i have la which
219:12 - also does hidden files we can see my
219:15 - hidden files are showing up
219:16 - and then i did the rm command so let's
219:19 - just create a file called remove me
219:23 - and delete me
219:26 - now if i run rm on remove me and delete
219:30 - me
219:31 - oh well i
219:32 - i didn't fully expand delete and to
219:35 - delete me but still it shows me what it
219:37 - removed so let's try try one more time
219:39 - there let's rm delete
219:42 - me
219:43 - there we go and now it just tells me it
219:45 - gives me a bit of feedback as to what
219:46 - was deleted anyway that's the basics of
219:49 - using the alias command remember where
219:51 - you define those aliases first of all if
219:53 - you don't define them in a file one of
219:55 - these special files they will not
219:57 - persist which is fine sometimes you may
219:59 - not need them to but if you do define
220:01 - them and you want them to continue to
220:03 - exist every time you have a new terminal
220:05 - window make sure you put them in the
220:06 - appropriate file depending on whether
220:08 - you're in zs you're using z shell or
220:10 - bash or some other shell they all have
220:12 - their own config files and one last note
220:15 - about working with aliases and
220:16 - specifically with quotes there's a
220:18 - difference in uh bash between single
220:21 - quotes and double quotes
220:23 - when we have double quotes and we have a
220:25 - variable or some form of
220:28 - so remember there's this variable
220:29 - expansion where we have a dollar sign
220:31 - if i echo
220:33 - some dollar sign and then a variable
220:36 - like path
220:37 - or there's user
220:40 - the shell sees this and it expands that
220:42 - or it replaces it with the actual value
220:45 - for user cults and that is what is
220:48 - echoed out okay so if i defined an alias
220:51 - that i just wanted to i don't know how
220:53 - about
220:53 - well let's just use this example here
220:56 - that is going to ls the contents of our
220:58 - current directory if i do ls
221:01 - dollar sign pwd
221:03 - that's what both of these are
221:05 - one has double quotes one has single
221:06 - quotes the difference is that whenever
221:09 - we use double quotes that variable is
221:11 - going to be resolved the value will be
221:13 - set in stone at the the definition time
221:16 - when we actually run this originally
221:19 - so whatever that pwd value is originally
221:22 - it will always be that but if i use
221:25 - single quotes instead
221:27 - single quotes will be resolved or that
221:28 - variable will be resolved whenever we
221:31 - invoke this alias so this in other words
221:34 - will be dependent on when i run this
221:36 - it's not going to be the same thing
221:38 - every time
221:39 - versus this one here because i use
221:41 - double quotes it's always going to be
221:44 - whatever the value is i'll just show you
221:46 - here
221:47 - if i just paste this into my shell
221:48 - currently the value of pwd it's my
221:51 - current directory
221:53 - so if i do ls this
221:55 - it's printing the contents of my home
221:57 - directory but if i go somewhere else
221:59 - like my desktop and i rerun that
222:02 - it's still printing the contents of my
222:04 - home directory no matter where i am it
222:06 - doesn't matter that i'm on the desktop
222:07 - or if i go into uh
222:10 - i don't know this wildlife folder and i
222:13 - run ls this
222:14 - because i used double quotes when i
222:16 - defined that alias this was set in stone
222:19 - at that moment i defined it
222:22 - now if i instead did this so i'll copy
222:24 - that and i'll put this in here alias ls
222:27 - current
222:29 - it is exactly the same inside the quotes
222:32 - remember if i just echo pwd
222:35 - it's a variable and it's just the exact
222:38 - same thing i see if i type pwd but the
222:40 - difference now is that this is going to
222:42 - rerun every single time
222:44 - that i run ls current
222:47 - so if i go to my home directory and i
222:49 - run ls current
222:51 - it shows me the contents of my actual
222:53 - current directory uh it doesn't matter
222:55 - where i was when i defined this so
222:57 - that's an important distinction when we
222:59 - use double and single quotes next up we
223:01 - get to talk about one of my favorite
223:03 - commands it's not my favorite because i
223:04 - use it very much that'd probably have to
223:06 - be i don't know cd or ls or something
223:09 - like that you just can't get around
223:11 - using those all the time
223:12 - but this command x args i don't use very
223:15 - much at all but when i do use it it
223:16 - really comes in handy it's pretty nifty
223:18 - so here's the whole point of it
223:21 - x-args exists to take
223:24 - output from one command
223:26 - and turn it into arguments for a second
223:29 - command
223:30 - so we've seen how we can take
223:32 - something like well first i'll just show
223:34 - you this folder i have i've got some
223:36 - files
223:37 - player two three four five six all the
223:39 - way up to player nine or player ten
223:42 - um so we've seen how we can do things
223:44 - like take
223:46 - ls and then pass that to sort for
223:50 - example
223:51 - right and what's happening here is that
223:54 - the output of ls is being passed as the
223:56 - input to the sort command
223:59 - however when i say input i'm actually
224:01 - referring to something called standard
224:03 - input somewhat of a long explanation to
224:06 - really go into but the idea is that
224:09 - unlike other commands we've seen like
224:11 - when we touch and make files i'll make
224:13 - another file here player 11.txt
224:16 - and
224:17 - player12.txt
224:18 - these are arguments being passed to the
224:21 - touch command it's a list of values
224:23 - separated by spaces
224:25 - so when i run that we end up creating
224:27 - what two new files and they're in here
224:31 - but when we do ls
224:33 - pipe sort we are not passing arguments
224:36 - to sort and this is what's kind of
224:37 - confusing the sort command is set up to
224:40 - accept values
224:42 - through standard input and it's also set
224:45 - up to be able to sort things as
224:47 - arguments so if i provided a file like i
224:49 - have this file called dead players we'll
224:51 - talk about that in a moment it can sort
224:53 - the contents of that file as well so
224:55 - this is passing an argument versus this
224:59 - right here
225:00 - we're passing the output of ls to the
225:02 - standard input of sort
225:04 - anyway i say all of this because only
225:07 - certain commands are set up to work with
225:09 - pipes
225:10 - only certain commands like sort and
225:12 - there's a lot of other ones that will
225:14 - accept an input
225:15 - through standard input rather than
225:17 - through arguments but there are many
225:19 - that don't so for example
225:22 - touch is actually one i just showed you
225:24 - i can't take the output of one command
225:27 - and pass it to touch at least not
225:29 - without x args so let me show what i'm
225:32 - talking about i'm going to show you
225:34 - first what we can't do the problem that
225:36 - xrx solves
225:38 - so i have some files here
225:40 - player 1 through player 12 these
225:42 - represent players in some game
225:44 - and people die after each round of the
225:47 - game and we need to
225:48 - clear them out we need to get rid of the
225:50 - players that died
225:51 - so i have another file called dead
225:54 - players if i just cat it out here you
225:57 - can see it has the names or the files of
225:59 - the players who are dead so what i want
226:01 - to do is take this file whatever's in it
226:04 - and delete or remove those files from
226:07 - the actual folder
226:09 - now this could be you know hundreds and
226:11 - hundreds of dead players and we could
226:13 - have thousands i actually recorded this
226:15 - once where i did have thousands like
226:17 - when i say once i mean like 10 minutes
226:19 - ago i had thousands of players
226:21 - and then i removed half of them but i
226:23 - realized that the scale was too large
226:25 - you really couldn't tell how many were
226:27 - removed
226:28 - so i scaled it down we're dealing with
226:30 - 12 now and we're going to delete what
226:32 - five of them here
226:34 - so aside from me manually doing rm
226:37 - player one and so on the idea is that
226:39 - this could scale up we could have
226:41 - thousands of players and there's some
226:43 - some list we don't even know you know
226:45 - exactly what's in there but some list of
226:46 - dead players it could be hundreds what i
226:49 - want to do is take
226:51 - whatever's in that file and dynamically
226:54 - remove those files so whatever those
226:56 - names are
226:58 - what i can't do unfortunately is just
227:00 - read the file so
227:02 - we can cat it and then pipe it to rm
227:05 - that will not work
227:07 - because the rm command is one of those
227:09 - commands that is expecting a space
227:12 - separated list of arguments it is not
227:14 - expecting anything to be passed to its
227:16 - via standard input so that's what's
227:18 - happening here with this pipe it takes
227:20 - the output of cat and pipes it over to
227:23 - rm but ram is not set up to handle that
227:26 - so
227:27 - just complains it says hey you didn't
227:28 - pass anything in there's no argument so
227:31 - what do you want me to rm just like if i
227:33 - had run rm here
227:35 - this is where x args comes in the x arcs
227:38 - command will take or it will accept
227:40 - standard input which is what's coming in
227:42 - here from this pipe so cat the output is
227:45 - passed to the standard n of rm but rm
227:47 - doesn't want anything to do with it but
227:49 - if we instead do
227:50 - x args
227:53 - if i can spell it rm
227:55 - what it does is it's kind of like an
227:56 - adapter it will take that standard in
227:59 - and then turn it into
228:01 - a list of arguments that will work for
228:04 - rm
228:05 - so this is the syntax
228:07 - x args and then the command that you
228:10 - want x-args to provide the arguments to
228:13 - all right so we're going to take this
228:15 - list of dead players
228:16 - which when we cut that out it's
228:18 - basically going to take this and provide
228:21 - it to x-args x-args then says okay let
228:24 - me turn that into a list of arguments
228:25 - that will work for rm provide that to rm
228:28 - and now
228:29 - when i run it well
228:32 - we see we lost a lot of players they're
228:34 - now gone right i
228:36 - this could scale up again to be hundreds
228:38 - at one time
228:40 - we can take the contents this is a
228:41 - simple example take the contents of one
228:43 - file and then do something with those
228:46 - contents in this case we've removed
228:48 - files that have that had those names
228:50 - let's take a look at one more example uh
228:53 - what i want to do is run the find
228:55 - command
228:56 - just uh on my desktop in all nested
228:59 - folders and files uh to find how about
229:02 - files that are larger so size is plus
229:05 - one m so greater than one megabyte
229:07 - and this is what it finds for me okay
229:10 - but i want more information about these
229:12 - i actually want to then uh do ls dash l
229:16 - right so we get that long listing format
229:18 - but i want ls-l only for these files
229:21 - which is what seven or so files so um if
229:24 - i try and pipe it to ls dash l
229:28 - well surprise surprise ls is not set up
229:30 - to accept values through standard input
229:33 - which is what the pipe does
229:35 - it is expecting
229:36 - us to provide arguments sure after the
229:39 - fact so we could do you know files that
229:41 - end in txt
229:44 - but that has nothing to do with our find
229:46 - command i want to take the results of
229:48 - the find command and then pass those to
229:51 - ls-l in a format that it will accept
229:54 - so this is again where x-args comes in
229:57 - so this is the list of files that are
229:59 - greater than one megabyte and then i can
230:02 - do x-args oops
230:05 - and then ls dash l that's the command i
230:08 - want to run
230:09 - and here we are we now see let's
230:11 - actually do lh so i can get the human
230:13 - readable format for the sizes
230:15 - not very large files on here 1.8 1.8
230:18 - megabytes 1.2 1.2 but these are all the
230:22 - files that we found from that find
230:23 - command
230:24 - uh those values were then passed to xrx
230:27 - xox stepped in and turned it into a
230:30 - acceptable list of arguments that was
230:32 - then provided to ls-lh
230:35 - and that's how we see this output
230:37 - so there's actually quite a bit more to
230:39 - x-args i'm not going to go into here
230:42 - you can read the man pages
230:43 - it's pretty powerful the different ways
230:45 - you can construct
230:47 - the list of arguments the different
230:48 - separators and delimiters and you can
230:50 - have it replace different things for you
230:52 - along the way
230:54 - you can limit the number of arguments
230:56 - it's quite complicated but what i just
230:58 - showed you are some of the more common
231:00 - simple ways of using it and that's the
231:03 - core purpose of x-args is to take
231:05 - standard input and turn it into a list
231:07 - of arguments that other commands will
231:09 - accept all right so next up we're going
231:11 - to talk about the ln command which is
231:13 - used to create links ln link now when i
231:17 - say link it's not a hyperlink or you
231:19 - know something from a browser
231:21 - a link in linux is or it may be a new
231:24 - concept to you
231:25 - it's kind of similar to the idea of a
231:27 - shortcut your desktop shortcuts on a
231:29 - windows operating system
231:31 - where you have some applications that
231:33 - are installed somewhere else it is not
231:35 - on your desktop they are installed
231:36 - completely in a different area but you
231:39 - have access to start them up you can
231:41 - reference them through the icons on your
231:43 - desktop so there's a link
231:46 - those icons have a little picture of
231:47 - whatever adobe photoshop that icon on my
231:49 - desktop when i double click it
231:52 - it is linked it's referencing some
231:54 - actual program that it starts up
231:57 - so the concept is similar we can have a
231:59 - file that is linked that points to
232:01 - another file
232:03 - so there are two types of links
232:05 - hard links and soft links we'll start by
232:07 - covering hard links which actually are
232:08 - not used as frequently
232:10 - but the idea is when we create a hard
232:13 - link we are creating basically a file
232:16 - that will stay in sync with another file
232:18 - now we're not creating a copy we're not
232:20 - duplicating a file it's different they
232:23 - are pointing to the same thing the same
232:25 - exact file so they're not diverging
232:27 - they're not copies it's not like using
232:29 - the cp command that's important to
232:31 - understand so let me show you an example
232:33 - we'll start nice and simple i've got an
232:35 - empty folder
232:36 - i'm going to echo
232:38 - i am original into a file called
232:42 - original.txt
232:44 - all right so i just made this new file
232:46 - we can cat it out and it says i am
232:49 - original and that's the only file in
232:50 - here
232:51 - now the syntax to make a hard link is ln
232:54 - and then the original file which happens
232:56 - to be called original and then whatever
232:58 - our destination or not destination but
233:00 - whatever the name of the link file that
233:02 - we want to create is i'm going to call
233:03 - mine hardlink.txt
233:06 - so if i type ls we have two files now or
233:09 - what appears to be two files uh this
233:11 - hard link file
233:13 - if i cat it out
233:15 - says i am original it has the same
233:18 - contents remember though it is not a
233:20 - copy it is pointing to the same file as
233:23 - this right here
233:25 - so if i change original let's echo
233:28 - this is more
233:31 - stuff
233:32 - we'll append that into original
233:35 - so if we cat out original we see two
233:38 - lines now and if i cat out the hard link
233:41 - we also see two lines
233:43 - and this goes both directions because
233:46 - they're both referring to the exact same
233:48 - thing if i change hard link
233:51 - uh change from hard link
233:54 - and i echo that into the
233:56 - hard link file
233:59 - which is a hard link to that original
234:01 - file
234:02 - this is what it looks like now
234:04 - and if i cat the original
234:06 - it also has that change so they are two
234:09 - things two arrows pointing to that same
234:11 - file in memory and this means if i were
234:13 - to delete
234:15 - well first if i delete the hard link the
234:17 - original file is still there it's
234:18 - unchanged but if i delete the original
234:20 - file
234:21 - my hard link file will persist it is
234:24 - pointing to that same thing in memory
234:26 - and that's what's a little bit confusing
234:28 - here
234:29 - it is not pointing to the you know this
234:31 - name original.txt it's pointing it's
234:33 - called an inode it doesn't really matter
234:35 - but it's referring to
234:37 - the same thing in memory just two
234:39 - different names for it so if i remove
234:41 - original
234:43 - i'll remove it
234:44 - it's gone but our hard link file that is
234:47 - still there that hard link we created
234:49 - and it still has
234:51 - those contents inside so that's a hard
234:53 - link as i mentioned it's not as commonly
234:55 - used
234:56 - then we have soft links
234:59 - and soft links are different the first
235:01 - thing you should know
235:02 - is that to make one we use the dash s
235:05 - option if you just take a look at man ln
235:08 - and then scroll down
235:11 - somewhere on here here we are dash s for
235:14 - symbolic it will make a symbolic link
235:17 - soft link instead of a hard link so
235:20 - what i'm going to do here is remove my
235:21 - hard link
235:24 - and i'm going to create a new original
235:26 - file so we'll echo i am original again
235:29 - into
235:30 - original.txt
235:32 - oh i did dot tt but that's fine
235:34 - um just quick quiz how would i rename
235:36 - that
235:38 - without moving it anywhere
235:39 - easiest way is just move command
235:42 - original dot txt is the destination and
235:45 - there we go
235:46 - okay so i'm going to make a soft link
235:49 - and to do that it's ln
235:51 - s
235:52 - the file that i'm linking to and then
235:55 - the new soft link or the sim link
235:58 - symbolic link
235:59 - i'm going to just call simlink.txt
236:03 - okay
236:04 - so
236:05 - what i have now is a symbolic link or a
236:08 - soft link and if i type ls
236:10 - you'll see if you have colors enabled it
236:12 - really depends on the terminal you're
236:14 - using your operating system your shell
236:16 - but for most
236:17 - terminals it will probably be a
236:19 - difference and for me it's bolded
236:21 - and it is in a different color cyan
236:24 - it doesn't matter what color it is and
236:26 - even if there's no color difference it
236:28 - doesn't matter if we do ls-l
236:30 - we can see a difference as well if you
236:33 - notice here here's my original file
236:35 - here's the sim link file it has this
236:37 - little arrow pointing to that original
236:40 - file
236:41 - additionally over here we haven't really
236:43 - talked about permissions yet
236:44 - but there's a difference there's a dash
236:47 - here is the first digit and there's an l
236:49 - here as the first digit
236:51 - this tells us that it is a symbolic link
236:53 - it's a link
236:54 - anyway
236:56 - just like before
236:58 - if i change the original file
237:00 - let's do a echo
237:04 - change to original
237:08 - and then we will append that to the
237:10 - original file
237:11 - it now looks like this
237:13 - and if i echo or rather cat the simlink
237:17 - file
237:18 - it also prints out the exact same thing
237:21 - now what if i try and change this sim
237:23 - link file echo change to sim link
237:28 - and i append that to the sim link file
237:32 - all right let's see did that change the
237:33 - sim link
237:35 - and does that mean the original has
237:36 - changed
237:37 - yeah it goes both ways in this sense
237:40 - however where there's a big difference
237:41 - is if i delete the original file
237:44 - so i have both of them here right now if
237:46 - i remove original
237:48 - yes
237:51 - now we have this simlink.txt
237:54 - but it doesn't look very happy it's
237:56 - still there
237:57 - but it's showing up in red all of a
237:58 - sudden and if i try and cat the contents
238:02 - it says no such file or directory so
238:04 - it's this link that it's just pointing
238:06 - to something that doesn't even exist
238:07 - anymore
238:08 - so that's the main difference the
238:10 - symbolic link was pointing to
238:12 - original.txt and when original is gone
238:15 - that link is severed with a hard link
238:18 - a hard blank is pointing to don't think
238:20 - of it as pointing to the file itself but
238:22 - think of the hard link and original.txt
238:25 - as two different pointers to the same
238:27 - thing in memory
238:29 - so if i delete the original it's all
238:31 - right we still have the hard link it's
238:32 - pointing to that same thing in memory
238:34 - but here with a sim link i delete the
238:37 - original
238:38 - well now this sim link has nothing to
238:39 - link to and it still is there right we
238:42 - still see something show up but it's
238:44 - just completely dead inside now you
238:45 - might be wondering why would you ever do
238:48 - this why does it matter
238:50 - and this is one of the harder things to
238:51 - explain or to convince you of when
238:53 - you're a beginner and i honestly don't
238:55 - even use sim links all that much or any
238:57 - links
238:58 - although i end up working with people
239:00 - who do use them and so i you know need
239:02 - to be familiar and comfortable working
239:04 - with them it's pretty straightforward
239:06 - once you get used to just that dash s
239:08 - ln-s but let me show you an example um
239:12 - if you have python installed for me i
239:14 - have python i think it came
239:15 - pre-installed and ubuntu and i have a
239:17 - couple different versions i'm going to
239:19 - run an ls-l
239:21 - on this directory user bin
239:24 - and then
239:25 - python i'll come back to in a moment but
239:27 - user bin is where binaries are installed
239:29 - uh and so it's where python binaries
239:32 - will live by default uh and there's a
239:34 - lot in here so first of all if i just
239:36 - get rid of this python thing
239:38 - there's a lot of different programs in
239:40 - here
239:41 - uh one of which i'm just going to focus
239:43 - on for now is python
239:45 - so if i do an ls dash l user slash bin
239:47 - and then anything that starts with
239:49 - python maybe i'll even do python 3
239:51 - because i have python 2 and 3. what we
239:54 - see here let me clear everything else
239:56 - again and just focus on this
239:59 - what you'll see is that there's four
240:00 - matches
240:02 - there's
240:02 - user bin python 3.8
240:05 - 3-futurized
240:08 - 3-pasteurize
240:10 - and then
240:11 - there's this right here what is that
240:14 - that is a sim link
240:16 - and that sim link is just called python
240:19 - 3 but it's pointing to a specific
240:21 - version
240:22 - so when i run python3
240:25 - that's the command i'm running when i
240:27 - run that right here it's actually a sim
240:29 - link and it's referring right now to 3.8
240:32 - but this allows me to manage different
240:34 - versions i could then have 3.9 or
240:36 - three-point you know python versions
240:38 - that don't exist yet or older versions
240:40 - 3.5
240:42 - i can have them all installed and then
240:44 - whatever this sim link it's like a
240:46 - shortcut whatever python 3 is referring
240:48 - to is what version of python will run
240:51 - so i can manage i can have all those
240:53 - versions installed but only one that is
240:55 - actually run when i call python3 so one
240:58 - with this little shortcut
241:00 - and i run python3 and there we go it
241:02 - doesn't matter if you know python or not
241:04 - uh and it actually we have the same
241:06 - thing if i just do python star
241:08 - python 2
241:09 - i only have one version installed but i
241:12 - have a sim link and i don't set this up
241:14 - myself to be clear this was just done
241:15 - for me when i installed python
241:17 - but python2 simlink is referring to
241:20 - there's a little arrow
241:22 - python 2.7 but i could also have 2.8 and
241:24 - 2.5
241:26 - and then switch versions and when i
241:28 - switch versions python 2 will point to
241:31 - one of those versions
241:33 - so that's just a simple example but
241:35 - there are many ways you can use sim
241:37 - links for now though i just want you to
241:39 - understand that ln is a command and that
241:41 - there are two different types of links
241:42 - we can make we can make a hard link and
241:45 - a soft link also known as a sim or
241:47 - symbolic link all right the next couple
241:49 - of commands we'll learn have to do with
241:51 - users and permissions uh they're pretty
241:54 - important ones that may not come up all
241:57 - the time but when they do come up they
241:59 - are really really useful um so on linux
242:03 - we can have multiple users logged in at
242:05 - the same time um doesn't really happen
242:07 - for me i'm kind of just working on my
242:08 - own on this one machine and for most
242:11 - people
242:12 - i shouldn't say most but i imagine for a
242:15 - lot of you who are watching this video
242:17 - you may be the only person using your
242:19 - machine but it's important to understand
242:21 - that you can have multiple users all
242:24 - logged in simultaneously to your same
242:27 - machine it might be hard to do right you
242:30 - may not have the the
242:32 - multiple screens and keyboards and
242:34 - whatever needed to have different people
242:35 - logged in at the same time although it
242:37 - can also be accomplished virtually the
242:39 - point is it's possible
242:41 - there is a command called who
242:43 - not to be confused with who am i who am
242:45 - i tells us the
242:47 - username based on the current effective
242:49 - user id for me that's cold steel here on
242:52 - my mac
242:53 - who is going to tell us about the users
242:55 - who are logged in and like i said for me
242:57 - it's really just me
243:00 - uh but what we'll actually see if i type
243:02 - it on my mac
243:03 - is
243:04 - currently what five seven different uh
243:07 - well if you include this one eight but
243:09 - right here what we're seeing are seven
243:11 - different uh users it's the same user
243:13 - but they're
243:14 - each added here separately for each time
243:17 - i access or each time i log in via a
243:20 - terminal basically every terminal window
243:22 - counts as a user accessing
243:25 - so i have seven right now
243:27 - this is tty is it it's teletype i
243:30 - believe it's an old relic but
243:33 - anyway if i create a new terminal window
243:36 - just
243:37 - ignore it uh and then run who again we
243:40 - now see we've got a 4 which wasn't there
243:43 - before you may not see that but if i
243:46 - zoom way in
243:49 - it says last login on ttyso
243:53 - so um yep
243:54 - that's why we're seeing all of those
243:56 - there anyway not the most useful command
243:58 - certainly not right now
244:00 - and not for me because i'm the only user
244:02 - but if we're an administrator and we've
244:04 - got a whole bunch of people on a machine
244:06 - at once
244:07 - this could be pretty critical to know
244:09 - who is currently logged in
244:11 - next up we'll cover the su command which
244:14 - is short for switch user this command
244:16 - allows us to switch users to log in as
244:19 - someone else within a terminal show
244:22 - so you may have situations where you
244:24 - might need to do this
244:26 - maybe not it really depends on
244:28 - what you're working on and how your
244:30 - machine is set up
244:32 - but if you are an administrator for
244:34 - example and you need to do something on
244:36 - somebody else's account
244:37 - well all you need to do is run the su
244:40 - command followed by some username
244:43 - now i have a different user on this
244:45 - machine so remember i'm colt on this
244:48 - ubuntu uh distribution here right now
244:50 - that's who i'm logged in as but i have
244:53 - a user called elvis
244:55 - and when i do su elvis it asks me to
244:58 - enter elvis's password so i can't just
245:00 - switch users to be whoever i want
245:03 - without knowing passwords unless i'm a
245:06 - root user unless i have full permissions
245:09 - but i don't
245:10 - so
245:11 - i switch user to elvis i need to know
245:12 - elvis password and i
245:14 - think nope i'm pretty sure i just got it
245:17 - wrong
245:18 - i did this last night let's see
245:21 - there we go entered the correct password
245:24 - uh and you'll see my prompt changes now
245:27 - says elvis at my ubuntu and if i type
245:30 - who am i it now says your elvis
245:34 - but just to be very clear this is in one
245:36 - window
245:37 - over here
245:38 - i'm still cult so i haven't completely
245:41 - logged out and become elvis everywhere
245:43 - it's still
245:44 - my horribly messy desktop but i am elvis
245:48 - in this tab
245:49 - aside from what we see when i run who am
245:51 - i if i cd to my home directory
245:55 - well my home directory tilde if i do pwd
245:58 - is home slash elvis
246:01 - whereas over here i cd2 tilde and i do
246:04 - pwd
246:06 - home slash colt is my home directory
246:08 - so as elvis i can do things like
246:11 - well there's nothing in this home
246:13 - directory but i could make a file
246:15 - touch from
246:17 - elvis.txt
246:19 - and i have permission to do that
246:21 - but if i go
246:22 - back and i go into
246:24 - colts account or rather colt's home
246:27 - folder
246:29 - remember i'm logged in as elvis here not
246:32 - colt
246:32 - uh what happens if i try and make a file
246:34 - here called from
246:36 - elvis.txt
246:38 - i can't do that
246:39 - so i'm logged in as elvis but that
246:41 - doesn't mean i can do everything colt
246:43 - can do we have different permissions and
246:45 - that's something we're going to start to
246:47 - try and understand we'll walk through
246:49 - how permissions work
246:51 - but this is just a quick introduction to
246:52 - the concept that different users have
246:54 - different permissions they can do
246:56 - different things
246:57 - and if i went the other direction as
246:59 - colt
247:00 - you know i can make a folder or a file
247:02 - from colts here no problem
247:05 - but if i back out and i try and go into
247:08 - elvis's directory i can do that but if i
247:11 - try and make a file touch from colts.txt
247:15 - no luck i can't do that i don't have
247:16 - permission
247:18 - anyway uh that's the basic idea of using
247:21 - su you probably wouldn't do this just
247:24 - make a random folder or file in somebody
247:26 - else's home directory but if you do need
247:28 - to switch users that's how you do it you
247:30 - need to enter the password and then to
247:31 - get out of here i think you can type
247:33 - exit also you can just do control d or
247:36 - control c i believe
247:38 - now there's another option when we run
247:41 - su if i do man su
247:44 - there's this dash that we can provide
247:46 - and if you provide that dash let's see
247:47 - if i can find it here
247:49 - it will start the shell as a login shell
247:52 - with an environment similar to a real
247:54 - login this means it clears all the
247:56 - environment variables it initializes the
247:58 - environment variable's home shell user
248:00 - log name and path and it changes us over
248:02 - to the target user's home directory so
248:05 - remember when i logged in as elvis i was
248:09 - actually just in colt's home directory
248:11 - anyway it didn't take me to elvis's
248:13 - directory like a normal login would
248:16 - but if i instead do s u
248:19 - dash
248:20 - and then elvis i can also do dash l
248:23 - but it's so common that you can just do
248:25 - dash it's a very short option i'll type
248:28 - elvis password
248:30 - and it takes me right to elvis's home
248:33 - directory this acts as a real login
248:35 - shell and then to get out of here
248:37 - again i can type exits or it is control
248:40 - d i believe there we go
248:42 - okay so that is su to switch users next
248:46 - up we'll talk about the sudo command
248:48 - s-u-d-o
248:50 - which is short for super user do
248:53 - and the command allows us to
248:55 - run commands other commands as the root
248:58 - user or with elevated permissions
249:01 - so there's this concept of the root user
249:04 - a user in linux who
249:06 - basically has permission to do anything
249:10 - to
249:11 - create new users to change passwords to
249:13 - remove files and folders and we actually
249:16 - if i just run ls dash l here i'm logged
249:19 - in as colt
249:21 - what we see here in this third column is
249:23 - the owner of particular files and
249:26 - folders
249:27 - but if i keep backing out
249:30 - now we see you know my different users
249:32 - if i take a look at one of them like
249:34 - kitty
249:36 - kitty owns these files and folders in
249:39 - her his or her desktop
249:41 - or home folder rather but if i back out
249:43 - another level
249:45 - so here i am one more time
249:47 - now we see a bunch of these really
249:50 - important directories uh that i who owns
249:54 - who who owns you know the bin folder
249:57 - where i have things like
249:59 - if we just cdn there
250:02 - all our programs are installed
250:04 - who's in charge of that which user well
250:06 - if i type ls-l
250:08 - we see root all over the place the root
250:12 - user is in charge or not in charge the
250:15 - root user is the owner of these programs
250:17 - these files and folders uh and that's
250:20 - just one example of you know the
250:21 - significance of root root can do all
250:24 - sorts of things
250:25 - like i said a root user can change
250:27 - someone else's password but as colt's
250:29 - just a regular old user i can't do that
250:32 - now there's something very important to
250:33 - know on ubuntu at least in many linux
250:36 - distributions the root user account is
250:38 - actually locked it's not accessible you
250:41 - can't log into it there's no password
250:44 - i can't just log out and log back in as
250:47 - root if i go to log out
250:51 - we will see
250:53 - yes i'll log out
250:55 - we saw the text root all over the place
250:58 - in my terminal
250:59 - but there is no root account that i can
251:02 - actually log in as
251:04 - so why is this well it's just how ubuntu
251:07 - is set up
251:08 - it was a decision that was made
251:10 - rather than having a single root account
251:13 - with a single password that you can log
251:16 - in as instead
251:18 - individual users i have four here colt
251:20 - kitty carrot and elvis individual users
251:24 - uh may be able to run commands as the
251:27 - root user and that's where this pseudo
251:29 - command comes in
251:31 - so how does this work
251:33 - it's not like it's a free-for-all and
251:35 - every single user on a machine can run
251:37 - commands as the root user
251:39 - uh those permissions are are actually
251:41 - listed out in a particular file
251:44 - there's a lot that goes into it and
251:45 - managing those permissions but i'm just
251:47 - going to show you though
251:48 - is that when you create your initial
251:50 - user account so colt was my initial user
251:53 - account whoops
251:56 - i'm logged in now as colts and i'm
251:58 - looking at my settings i can see
252:00 - different users again none of them are
252:03 - called roots but some of them including
252:05 - colt which was the first account i made
252:07 - by default is an administrator so that
252:09 - means i can add and remove other users i
252:12 - can change settings for all users
252:14 - but that's not the same as being the
252:15 - root user
252:17 - and then some other users carrot elvis
252:20 - are not administrators kitty is an
252:22 - administrator when you make a new user
252:24 - you can decide that now that's just one
252:27 - basic
252:28 - difference or one basic
252:30 - toggle between permissions but we can
252:32 - get very detailed about who is allowed
252:34 - to do what but we're not going to go
252:36 - into that i just wanted to make it clear
252:37 - that this sudo command i'm about to show
252:39 - you is not carte blanche for every user
252:42 - to do everything so i'll demonstrate
252:44 - that
252:45 - okay so how do we use this sudo command
252:48 - the idea is that instead of using a
252:50 - single root password each user has their
252:53 - own password we enter that password it's
252:55 - going to prompt us for that password and
252:57 - then it's going to check do you even
252:59 - have permission to run this command as
253:02 - root so it doesn't turn us into the root
253:04 - user
253:05 - it doesn't give us permissions to do
253:06 - everything if we don't already have them
253:08 - it only allows us to do certain commands
253:11 - that we are specifically already
253:13 - permitted to do it's just an extra level
253:16 - of protection basically you have to type
253:18 - sudo you have to type your password so
253:20 - even if you have those permissions you
253:22 - can't just normally go around deleting
253:23 - everyone's stuff
253:25 - you need to run sudo in order to do that
253:27 - so if i wanted to
253:29 - edit some particular configuration file
253:32 - that affects everyone on a machine
253:35 - if i just tried to open it in nano i'm
253:37 - not going to be able to do that but if i
253:40 - try using sudo first i'll enter my
253:43 - password and it will check if i'm
253:44 - allowed to do that or not so let me show
253:46 - you uh let me get my terminal open
253:48 - so the file that we're going to look at
253:50 - is in slash etsy etc
253:54 - host that's the name of the file
253:56 - and if i just do an ls-l on it
253:59 - remember this is a high up directory it
254:01 - is not located in colt's user directory
254:04 - or any other user it's above
254:06 - and if i run ls-l we can see that the
254:09 - owner is the root user but again there
254:12 - is actually no way to log in as the root
254:14 - user in ubuntu
254:16 - so
254:17 - uh if i want to edit this file for some
254:19 - reason i could try running nano
254:23 - and it does open up i can actually read
254:25 - the contents but it tells me for you
254:27 - this file is unwritable
254:30 - so i can't make changes
254:32 - i'll get out of here but if i now prefix
254:35 - this with sudo
254:37 - super user do
254:39 - this so super user do this command it's
254:42 - first going to say enter your password
254:44 - for colts that's who i currently am and
254:46 - it's going to check if i have permission
254:49 - if i am granted those root permissions
254:52 - to edit this particular file
254:55 - so if i enter my password this is not
254:57 - the root password this is colt's
254:59 - password that i log in with
255:01 - and we see i actually am able to edit
255:04 - this file i'm not going to
255:06 - because i really don't want to but this
255:08 - is a file i can change now
255:10 - but if i go
255:11 - log in as a different user and remember
255:14 - we saw how to do this
255:15 - i can use su dash i have elvis as a user
255:18 - on this account
255:20 - i'll type elvis's password
255:23 - okay
255:24 - who am i i am elvis so if i try and run
255:27 - this nano etc
255:29 - hosts i also see hey you don't have
255:32 - permission to do that that's a file
255:34 - owned by root
255:36 - but if i try sudo
255:39 - just like i did as colt it now asks me
255:41 - for elvis's password so what is elvis's
255:44 - password well i'm not telling you
255:46 - but i know it i type it in
255:48 - and it tells me
255:49 - nope that's not going to work we checked
255:52 - elvis is not in the sudoers or sudoers
255:54 - file we're not going to really go into
255:56 - that but there's ways of managing who
255:58 - can do what it's more of an
255:59 - administrative process or a specialty
256:02 - that i'm just not going to go into here
256:04 - but it's important to note specific
256:06 - users can have different permissions who
256:09 - is allowed to do what as the root user
256:11 - and elvis doesn't have any
256:13 - so i can't edit that file as elvis but
256:16 - again if i switch back to being cult
256:18 - i'll just get out of here with exit
256:20 - and i run that sudo nano blah blah blah
256:24 - i already entered my password so it
256:26 - remembers it there just to be clear
256:28 - but you will need to enter your password
256:30 - when you run sudo your particular user's
256:33 - password now you've probably actually
256:35 - come across this before when it comes to
256:38 - installing software or installing new
256:40 - commands there's a command
256:42 - called tldr i don't have it installed
256:45 - and if i try typing it
256:48 - my shell is going to tell me i don't
256:49 - know what you're talking about but here
256:51 - are some things you could try installing
256:53 - so there's a command called apt install
256:56 - and then the package tldr
256:59 - but if i just run that without sudo
257:03 - i'm not allowed to do that
257:04 - because i'm installing something that
257:07 - is not even just specific to my user
257:09 - here it actually is specific or not
257:11 - specific it would apply to all users on
257:13 - my machine i'm actually installing a
257:15 - program a command that everyone can use
257:18 - so i can't just go around doing that i
257:20 - need to have permission so that's why we
257:22 - run sudo
257:23 - do i have permission to install this
257:25 - well i already entered my password again
257:28 - so it knows who i am and what
257:31 - permissions i have
257:32 - to do as root user i can install it so i
257:35 - will continue
257:37 - and it will take a little while to
257:38 - install
257:39 - the the point of this is not to show you
257:41 - how to install things by the way it's
257:42 - just to show you another situation where
257:45 - you would need to use sudo
257:46 - so anytime you're trying to make changes
257:48 - you run into a permission denied error
257:51 - you'll often be prompted to try it again
257:53 - with sudo first
257:55 - so sudo itself we prefix in front of
257:58 - other commands
257:59 - and then it will prompt us for our
258:00 - password and now i have this tl dr
258:03 - command just show it to you on the man
258:05 - page for it here we are anyway uh it
258:08 - really doesn't matter it was just about
258:09 - using sudo so it really depends on who
258:12 - you're logged in as and what permissions
258:14 - you specifically have been granted and
258:16 - that is something that can be tweaked it
258:18 - can be really
258:20 - down to a pretty granular level i
258:22 - haven't changed anything it's just that
258:24 - some users have administrator
258:26 - permissions on here some of them don't
258:28 - now not all linux distributions will
258:30 - have the root account locked so you
258:32 - can't log into it directly some of them
258:34 - you can but even then we still have
258:36 - access to the sudo command and we can
258:38 - grant specific users
258:40 - different privileges as root it's also
258:43 - you know on my mac i cannot run things
258:45 - with sudo and i often need to if i'm
258:47 - installing something that is system-wide
258:49 - same idea the next command will cover is
258:51 - the password command which is actually
258:53 - pass wd
258:55 - i guess those extra two letters are too
258:57 - long
258:58 - and this is the command we can use to
259:00 - change someone's password so there's two
259:02 - ways of using it you can change your own
259:03 - password by just typing passwd
259:07 - so i'm logged in as called i don't
259:08 - really i mean i guess i'll change my
259:10 - password then i'll change it back
259:11 - so it's going to ask me for my current
259:13 - password so i have to know that and then
259:16 - it asked me for my new password
259:18 - and let's do uh
259:20 - well i'm not gonna tell you and then i
259:21 - have to confirm it again
259:24 - okay i updated my password and you can
259:26 - just trust that it worked i mean
259:28 - i how would you really know i guess i'm
259:30 - not going to tell you what it was before
259:31 - or now although none of them are
259:33 - actually real passwords anyway but it
259:35 - did change and if i were to log out i
259:37 - would need to use that new password so
259:40 - i'm just going to change it back one
259:41 - more time current password whoops i
259:43 - messed up i'm gonna do that again so my
259:46 - current password i just changed it to
259:48 - my new one
259:52 - okay now i can also change someone
259:54 - else's password uh assuming i have root
259:56 - permissions uh so let's say i need to
259:59 - change elvis password he's forgotten it
260:01 - there's actually a lot you can do you
260:02 - can lock someone's password
260:05 - you can
260:06 - if we just go to man
260:07 - pass wd
260:10 - you can do things like
260:12 - expire an account's password which would
260:15 - force them to change their password next
260:17 - time they log in but it doesn't actually
260:18 - give them a new password you can make an
260:21 - empty password to disable a password for
260:23 - an account there's a lot here um i'm
260:25 - just going to show the basics so i want
260:27 - to change elvis password
260:29 - pass wd
260:31 - elvis
260:32 - well
260:33 - i can't do that right as colts i need to
260:35 - do it as the root user or i guess as
260:39 - elvis uh but as the root user is
260:41 - probably more likely right why would
260:43 - elvis need to change his password from
260:44 - my account uh so if i have permissions
260:47 - i'm the administrator remember on ubuntu
260:50 - i can't log in as root so this is the
260:52 - closest thing i'm an admin i have
260:53 - permission to do this but i have to use
260:56 - sudo
260:57 - so sudo password elvis is now going to
261:00 - ask me for my password not elvises it's
261:03 - going to ask me for mine and it's going
261:04 - to just verify are you even allowed to
261:06 - do that as colt
261:07 - okay
261:08 - now it's asking me for elvis's new
261:10 - password
261:11 - so i'm just going to change it to
261:14 - how about hacked
261:16 - okay and one more time
261:19 - and now i just changed elvis password
261:22 - i guess you know i could show it to you
261:24 - quickly if i do an su elvis
261:27 - if i try and use elvis's old password
261:29 - which was
261:30 - something involving the word taco it
261:33 - doesn't work but now if i log in as
261:35 - elvis using hacked
261:38 - it does work
261:39 - and then as elvis i could change my
261:41 - password again
261:43 - using password
261:44 - and i don't need any fancy permissions
261:46 - you can change your own password
261:48 - all right so that's the basic use of
261:50 - password it is past wd there is more to
261:53 - it as i said you can lock someone's
261:54 - password you can delete it uh you can
261:56 - expire it and force them to set a new
261:58 - one when they log in
262:00 - but again it comes down to you can
262:01 - change your own password or if you have
262:04 - permission as the root user
262:06 - you can use sudo in order to change
262:08 - somebody else's password the next
262:10 - command we'll cover is one of my
262:11 - favorites to say out loud chon or town
262:15 - change ownership
262:17 - this is the command we can use to change
262:19 - who owns a particular file or directory
262:23 - so let's talk about what that means to
262:24 - own a file or directory um on every file
262:28 - every directory let me just go home here
262:30 - i'm logged in as colt
262:32 - who am i
262:33 - um when we do ls-l
262:35 - we see a whole bunch of information
262:37 - we're going to talk more about what this
262:39 - is in just a little bit permissions
262:41 - and then this right here this third
262:43 - column
262:45 - is the owner of the entry so in this
262:47 - case the owner of this directory files
262:49 - exercise is me cold
262:52 - uh the owner of music is colt
262:56 - this is pretty normal to own all the
262:59 - stuff in your home directory
263:01 - but if i go to somebody else's directory
263:04 - if i have multiple users let's go to
263:06 - kitty's directory so this is her home
263:09 - directory
263:10 - kitty owns almost all of these files and
263:13 - folders and if i keep backing out
263:15 - further we've seen this before
263:18 - root
263:20 - the root user owns all of these
263:22 - directories and files
263:24 - so the chon command helps us change who
263:26 - owns those files and that's important to
263:29 - do because the owner of a file is
263:30 - allowed to
263:33 - change its permissions to delete it
263:35 - potentially to read or to write to that
263:37 - file
263:38 - it all has to do with what we see over
263:40 - here which we'll get into in just a
263:42 - little bit but for now i just want to
263:44 - show that we can change the owner
263:46 - and then we'll understand we'll try to
263:48 - understand its implications later on
263:50 - when we talk about another command all
263:51 - right so i'm going to go back home
263:54 - and
263:55 - the syntax to change the owner looks
263:58 - like this tone
263:59 - and then the owner that we want to
264:02 - add as the owner so a user
264:04 - and then the file that we're trying to
264:06 - change
264:08 - so um i'm going to go into elvis's
264:10 - directory
264:12 - or maybe
264:13 - it doesn't really matter here i'll go
264:14 - into kitties
264:15 - kitty
264:17 - all these files almost all of them
264:19 - are owned by kitty
264:21 - if i wanted to if i wanted to change the
264:24 - owner of how about kitty's music
264:28 - directory
264:29 - the syntax would be change owner chone
264:32 - and then me colt that's the user i'm
264:35 - trying to add as the owner and then
264:38 - after that
264:39 - music
264:41 - now there is a bit of a problem
264:43 - i can't just change somebody else's you
264:45 - know i can't just make myself the owner
264:47 - of somebody else's directory uh all over
264:49 - the place like that is something i have
264:51 - to have permission to do
264:52 - and we've recently learned that we can
264:55 - use the pseudo command to act as the
264:57 - root user
264:58 - so that is one option here is if i have
265:01 - root permissions i can change the owner
265:03 - of any files sudo
265:05 - tone cult music
265:07 - so it's going to ask me for my password
265:10 - and then i enter it and i don't see
265:12 - anything but that's a good sign
265:15 - that means that i did have permission to
265:16 - do that
265:17 - and now you can see cult is indeed the
265:20 - owner of this music directory
265:23 - now again we haven't really talked about
265:24 - what that means for me to be the owner
265:27 - but i'll just show you for example if i
265:29 - were to go into the desktop
265:34 - and try and create a file touch made by
265:36 - colt
265:38 - i don't have permission in that
265:39 - directory but if i go back out and i go
265:41 - into music
265:43 - if i touch a file touch made by colt
265:47 - i do have permission now because i am
265:49 - the owner
265:50 - as we saw i did ls-l
265:52 - i own that folder music one commonly
265:56 - used flag with chone is uppercase r
265:59 - which we can use to recursively change
266:01 - the ownership of all the files and
266:03 - subdirectories nested in a directory
266:07 - so i have this directory i just made
266:09 - called cat stuff
266:11 - and it has
266:13 - some files inside of it and then a
266:15 - nested directory with some other files
266:17 - and if i decide i want to make the owner
266:19 - of cat stuff kitty and this is all kind
266:22 - of silly and you probably won't just
266:24 - make a directory in your home folder and
266:26 - then make someone else the owner at
266:28 - least not frequently but just for demo
266:30 - purposes if i make kitty another user on
266:32 - my
266:34 - computer if i make her the owner
266:36 - i can do chone
266:38 - kitty
266:39 - and then i need the name of that
266:41 - directory which is cat stuff and i do
266:44 - need to use sudo
266:46 - even though it's my own folder that
266:47 - might seem weird like you should be able
266:49 - to change who owns your own stuff
266:51 - the way linux is set up that is not the
266:53 - case you still need to have root
266:54 - permissions
266:56 - now you can change the permissions
266:58 - attributes we'll talk about very very
267:00 - shortly uh if you are the owner um but
267:03 - you can't change the actual owner of a
267:05 - file unless you have root permissions
267:08 - and i already typed my password a couple
267:09 - minutes ago or seconds ago so i don't
267:11 - have to redo it
267:12 - and if i do ls-l we see
267:15 - where are you
267:17 - cat stuff kitty is the owner but if we
267:20 - cdn to cat stuff
267:22 - ls-l
267:24 - i cult still own all the files and the
267:26 - nested directory so to change that we
267:29 - can just rerun that line
267:31 - the tone line
267:33 - but we use the dash uppercase r to
267:36 - recursively change the ownership and now
267:38 - if i go back into cat stuff
267:41 - kitty is indeed the owner of all the
267:43 - nested contents if we go into toys same
267:45 - thing there kitty is the owner of those
267:47 - files
267:48 - okay
267:49 - now another thing you may notice when i
267:51 - run ls-l
267:53 - let me go to uh how about kitty's home
267:56 - folder
267:57 - so we'll go
267:59 - slash home slash kitty
268:02 - instead of here when i do ls-l on any it
268:05 - doesn't matter where but in this
268:06 - directory ls lsl i see a bunch of
268:08 - folders and files there's an owner that
268:10 - we talked about
268:11 - that is a single user who is the owner
268:15 - of that file
268:16 - but then
268:17 - why does it say kitty again or here it
268:20 - says pals forever what is this second
268:22 - thing
268:23 - this is known as the group owner this is
268:26 - a little confusing but every file on a
268:28 - linux system has an owner and it has a
268:31 - group that owns it and that group can
268:34 - have multiple people's people users who
268:37 - are members of that group and then the
268:38 - group can get its own set of permissions
268:41 - so this means that um you know i could
268:43 - be the owner of this file and i might be
268:45 - able to read write delete whatever i
268:47 - want and then
268:49 - members of the pals forever group might
268:52 - be able to read only but they're not
268:54 - able to edit this file they're not able
268:56 - to write to it
268:58 - so this allows us to have two different
269:00 - levels of permissions the owner can have
269:03 - some set of permissions what are they
269:05 - allowed to do and then members of the
269:07 - group that is an owner the group owner
269:10 - they also can have a separate set of
269:12 - permissions
269:14 - and it's all encoded in these weird
269:16 - little digits that rwx and dash is here
269:19 - we will talk about that very soon but
269:21 - what i want to show you right now is
269:22 - that we can just change the group that
269:24 - owns a file using chone now this is
269:27 - something you probably won't do very
269:28 - much and i'm not diving into groups and
269:30 - managing groups and creating new groups
269:32 - and changing members who belongs to a
269:34 - group that's all more admin stuff anyway
269:38 - not day-to-day user stuff at least in my
269:40 - experience and with my students
269:42 - but it's worth knowing that we can use
269:44 - the shown command to change the group
269:46 - owner
269:47 - so i have this group called pals forever
269:50 - i can actually there's a command called
269:52 - groups i can see all the groups that i
269:54 - the current user belongs to so here's
269:57 - all the groups we've got
269:59 - uh movie club
270:01 - pals forever let's say i want to change
270:04 - the group that owns music
270:06 - from kitty and this is also somewhat
270:09 - confusing by default the group
270:12 - is going to be a group with your
270:13 - username
270:14 - so it says kitty and kitty but this is
270:17 - the group owner this is the owner owner
270:20 - all right
270:21 - if i want to take this music directory
270:23 - and make
270:24 - pals forever the group owner the syntax
270:27 - looks like this
270:28 - where we have the owner name a colon and
270:31 - then the group that we want to add
270:34 - so here if i want to keep the owner as
270:36 - colt i need to do pseudo chone
270:40 - cult colon pals forever
270:44 - and then
270:45 - music is what i'm trying to change
270:48 - so this will be the owner and this is
270:49 - the group owner
270:52 - ls-l and if we look at music that group
270:55 - has changed
270:57 - now again the idea behind groups is that
270:59 - we could have 10 different users who are
271:01 - part of this group and they might be
271:03 - able to read this directory only
271:06 - but then the owner
271:07 - can read and write and execute and do
271:09 - everything
271:10 - so we can have these different levels so
271:12 - it's not just one person who's allowed
271:13 - to do things for the file we can
271:15 - selectively change these groups
271:17 - and add people to the groups but that
271:19 - again is a more advanced admin thing we
271:21 - don't really need to worry about
271:23 - all right so the next thing we're going
271:24 - to talk about
271:26 - is understanding when i do ls-l the very
271:29 - first chunk of really bizarre looking
271:31 - text these characters here we want to
271:34 - understand what these are what they mean
271:36 - because we're also going to learn a
271:38 - command that allows us to change these
271:40 - so what we're looking at right here
271:42 - is for every file every directory
271:44 - these are the permissions or the file
271:46 - attributes they
271:48 - detail what the owner is allowed to do
271:50 - can you read write or execute this file
271:53 - uh what the group members who are part
271:56 - of the group that owns this file can do
271:58 - read write and execute and what everyone
272:00 - else can do can
272:02 - the world at large any user read write
272:05 - or execute
272:06 - so there's a lot to break down there's
272:08 - actually 10 digits here not digits 10
272:10 - characters
272:12 - and the first character
272:13 - actually i'm using some of my slides
272:15 - i've made for a course on udemy if
272:17 - you're interested in a lot more of a
272:20 - deep dive into linux commands
272:22 - because this is just hard to explain
272:23 - without graphics or some visuals so
272:25 - anyway that first letter is either going
272:28 - to be a dash so not a letter that
272:31 - indicates that it's a file a plain old
272:33 - regular file id
272:35 - indicates a directory so we can see that
272:38 - already here's a file dot txt it has a
272:41 - dash
272:42 - that's the first character here's a
272:44 - folder or a directory it has a d
272:47 - and then for sim links i think if i just
272:50 - back out a little bit here
272:52 - they'll start with an l so here's a sim
272:54 - link here we can see we also have that
272:57 - arrow pointing to you know where the
272:59 - link is linking to
273:01 - and it starts with an l so that's the
273:03 - first thing
273:04 - that's kind of just a one-off then we
273:06 - have nine characters which is actually
273:10 - three sets of three
273:12 - the first group of three tells us the
273:14 - permissions for the owner of the file or
273:17 - directory
273:18 - the second group tells us the
273:20 - permissions for the group owner or for
273:22 - members in that group
273:25 - and then finally the third group
273:27 - tells us the permissions for everyone
273:29 - else the world at large any other user
273:31 - that's not the owner or that is not part
273:33 - of the group that owns the file or
273:35 - folder now within each group of three
273:38 - we'll just take the first one so for an
273:40 - owner those first three digits
273:42 - they tell us the read writes and execute
273:45 - permissions for this file can the owner
273:48 - read write or execute so those three
273:50 - characters in a very particular order
273:52 - the read permission is first then the
273:54 - right permission then the execute and
273:56 - then it starts over
273:57 - read write execute for the group owner
273:59 - or group members read write and execute
274:01 - for everyone else
274:03 - so what do these three permissions mean
274:05 - well
274:06 - if we have an r in that first spot right
274:09 - here there's an r here there's an r here
274:11 - there's an arm
274:12 - that means that the file can be read if
274:15 - it's a file or if it's a directory it
274:17 - means that the contents of that
274:18 - directory can be listed okay so here i
274:21 - have a single file i've created called
274:25 - onlycoltscanread.txt
274:28 - and we'll learn how you can change these
274:30 - permissions but i've already changed
274:31 - them the first thing we see here is a
274:33 - dash that means that it's a file
274:35 - then we have those first three digits
274:38 - which are the owner permissions now the
274:40 - owner is colt
274:41 - and there is an r present here which
274:43 - means that i have permission to read
274:46 - the owner whoever that is has permission
274:48 - to read the contents of this file and i
274:50 - can read it
274:51 - okay
274:53 - then we have the next three
274:55 - which is all just dashes which means
274:57 - none of those permissions are present so
274:59 - this is the group permissions anyone
275:01 - who's a member of this group well they
275:03 - don't have any permissions here and then
275:05 - everyone else
275:07 - they also don't have permissions so that
275:09 - r would be that character right there
275:11 - there is no r that means whenever we
275:13 - have a dash that the file is not
275:16 - readable
275:17 - or executable or writable depending on
275:20 - the location of where that dash is
275:22 - so here if there's a dash that means the
275:25 - owner couldn't read it but there is not
275:26 - a dash there's a r which means we do
275:29 - have read permissions so let me
275:30 - demonstrate this if i switch over i'm
275:32 - just going to log in as elvis
275:38 - if i can remember the password
275:40 - uh oh that's not it
275:42 - all right let's try that again
275:46 - oh wait i think i changed it to hacked
275:48 - didn't i i forgot about that
275:51 - there we go all right so i'm now elvis
275:54 - who am i
275:56 - if i do an ls-l well i'm not cult i'm
275:59 - not part of this group uh so i'm
276:02 - considered anyone else i don't have read
276:04 - permissions there's just a dash there if
276:07 - i try and cat the file out
276:09 - permission denied only colt can read
276:12 - that file or only the owner which
276:14 - happens to be colt
276:16 - okay
276:17 - so this pattern holds true for all of
276:20 - these permissions if there's a dash in
276:22 - any of these spots it means that that
276:25 - respective if it's the world the group
276:27 - the owner does not have that permission
276:30 - so here we can see the owner does not
276:32 - have execute permissions the group does
276:34 - not have execute permissions everyone
276:36 - else does not have write or execute
276:39 - permissions
276:40 - now what those mean we'll dive into but
276:42 - for reading as we saw
276:44 - if there's an r there that means the
276:46 - file can be read
276:47 - and if there's an r on a directory that
276:50 - means that we can list the contents of
276:51 - that directory
276:53 - so this is why
276:54 - as elvis
276:55 - i can do ls or ls-l or something on this
277:00 - directory
277:01 - it's actually going to zoom out further
277:03 - or move back one level
277:05 - if we look here
277:06 - this is each user's home folder so we've
277:09 - got carrot colts elvis and kitty
277:12 - each user has rwx that means read write
277:15 - and execute
277:16 - but then
277:17 - there's an r present for everyone else
277:20 - for that world right everyone can still
277:23 - read these directories
277:25 - that doesn't mean i can change them of
277:27 - course but this is why as elvis i can go
277:30 - into colts directories and and list ls-l
277:33 - i have that permission because i have
277:36 - that r attribute right there
277:38 - in that third set so remember
277:41 - first three
277:42 - that's going to be the owner
277:44 - members of the group
277:46 - and then everyone else
277:48 - and i currently
277:50 - and part of that everyone else i'm able
277:52 - to read the contents here but uh through
277:55 - some editing magic uh i did just change
277:58 - the permissions on the permissions
278:01 - directory here if you notice now there
278:03 - is no r present we'll learn how to
278:05 - change that in a bit uh on this third
278:08 - grouping which means that anyone who is
278:10 - not the owner or part of this group
278:12 - cannot read the contents of this
278:14 - directory now it is a directory so what
278:16 - does that mean remember the r character
278:19 - means that you can list the contents of
278:21 - a directory if it's a directory or you
278:23 - can read the contents of a file if it's
278:25 - a file
278:26 - well i'm elvis still if i try an ls that
278:29 - permissions folder
278:31 - i can't
278:32 - i can ls any of the others i can ls
278:34 - music i can ls desktop but when i try
278:38 - permissions
278:39 - i can't do that because once again
278:42 - we no longer have an r present there
278:45 - but if i switch back to being cold
278:47 - now i'm cold
278:49 - we can see
278:50 - i can
278:51 - ls permissions no problem
278:54 - because we have an r in that first
278:56 - grouping which is the owner's permission
278:58 - so i can read all right so that's our
279:01 - first
279:02 - type of permission read permission
279:04 - if there's an r present here here or
279:06 - here that means that either the owner
279:09 - members of the group or everyone else
279:11 - can read
279:12 - next we have this second slot which is
279:15 - for write permissions so a dash means no
279:18 - write permissions a w means write
279:20 - permissions
279:21 - so for a file that means that we can
279:23 - modify the file and for a directory this
279:26 - means that the contents can be modified
279:28 - you could change files you could make a
279:31 - new file for example you could rename
279:34 - but
279:34 - this actually only takes effect if the
279:36 - executable attribute is also set which
279:39 - is that third piece here so let's just
279:42 - focus on files so if we have a w present
279:45 - that means we can write to a file so
279:48 - here we have ilovekitty.txt
279:50 - the owner is cult
279:52 - there's a w there right here's that
279:54 - first group or i shouldn't say group but
279:56 - the first chunk
279:57 - 123 for the owner i can write to that
280:01 - file uh i can echo into it let's just do
280:03 - echo meow
280:05 - into i love
280:08 - no i need uppercase l
280:11 - no problem i'm cold i can do that if i
280:13 - cat it out
280:15 - we see it has meow
280:17 - but now if i switch back to being elvis
280:19 - put elvis's new hacked password in there
280:22 - i am elvis here
280:24 - if i as elvis try and add to that file
280:27 - if i try and open it with nano if i try
280:30 - and echo something into it
280:31 - well elvis is not cult so these
280:33 - permissions don't apply not part of that
280:35 - group parallels so these don't apply but
280:37 - it doesn't matter anyway because it's
280:39 - the same as the permissions for everyone
280:41 - else
280:42 - what we see here is that
280:44 - everyone has read permissions
280:46 - but no write permissions
280:49 - so i cannot write to that file
280:52 - if i try to echo
280:54 - um i don't know hi from elvis into i
280:59 - love kitty
281:01 - permission denied i cannot write to that
281:03 - file
281:04 - but i can print it out or read the
281:06 - contents because once again we have
281:09 - that r right there so i'm elvis that r
281:13 - applies to me i'm not the owner i'm not
281:15 - part of this group we have read but no
281:18 - write permissions and then what about
281:19 - this third slot here
281:21 - so that third slot is either going to be
281:23 - an x or a dash if it's a dash it means
281:28 - no execute or executable permissions
281:30 - if it's an x that means we do have
281:33 - executable permissions so what does that
281:35 - mean
281:36 - well it's easier to understand in the
281:38 - context of directories if we have a
281:41 - directory
281:42 - you'll see actually there's a lot of x's
281:44 - on directories by default everyone has x
281:48 - executable permissions on folders all
281:50 - that means is that we can cd into a
281:53 - directory
281:54 - so
281:55 - it doesn't matter who i am right now
281:57 - let's take a look at the wildlife
281:58 - directory
282:00 - there's an x present for the owner group
282:02 - members and for everyone else so i'm
282:04 - currently elvis i can cd into wildlife
282:07 - no problem
282:08 - i'm in there
282:09 - now if i behind the scenes get rid of
282:12 - that x i'll do it right now there we go
282:15 - there is no x there anymore we're about
282:17 - to see how to do that
282:19 - i'm going to go back to being elvis
282:22 - if i try and cd into wildlife now
282:26 - cd into wildlife
282:28 - permission denied
282:30 - we don't have an x there
282:32 - and for elvis that means he can't
282:34 - execute you cannot cd into that
282:36 - directory now members of the group
282:39 - parallels in this case anyone who's in
282:41 - that group can and then the owner cult
282:44 - can cd as well because that's the owners
282:47 - execute the group members execute and
282:49 - then everyone else is execute
282:51 - so normally you'll have x present all
282:54 - over the place for directories but i
282:55 - just removed it here to show you the
282:56 - consequences i'll go back to being cult
283:00 - and i can cd into wildlife no problem
283:03 - now it's a little trickier to explain
283:05 - what it means when we have a file
283:07 - for files that have an x present here
283:11 - so if i were to show you a couple of
283:13 - examples like this right here these
283:14 - permissions
283:16 - means that an owner has read write and
283:18 - execute permissions for this file no one
283:21 - else has any access whatsoever
283:23 - what does that x mean on a file
283:26 - it means that the file can be treated as
283:28 - a program and can be executed
283:31 - so if you write your own scripts you
283:33 - write your own programs and you want
283:34 - them to become
283:35 - executable you need to have that x there
283:39 - so we're not going to see that right now
283:40 - but i'll show you some examples of
283:42 - things that are executables if we cd
283:45 - back a couple of times
283:46 - we go into bin
283:48 - what we see here if i do an ls-l
283:51 - are lots of x is present but these are
283:54 - actually files so these are programs
283:57 - as you can see
283:59 - so there's a lot of programs here uh
284:01 - once again i'm in slash
284:03 - slash bin rather is my path name right
284:06 - now
284:07 - binaries this is where programs are
284:09 - stored
284:10 - so uh if you know here's touch for
284:13 - example that is a program that i can run
284:16 - obviously we use it all the time or if
284:18 - we find let's see is there another
284:20 - simple one in here here we go here is
284:23 - echo
284:24 - so our echo program that we run that
284:26 - command it's defined right here it's a
284:28 - file it has some code in there
284:30 - and as you see it's x x x that means we
284:34 - can execute it as a program we can
284:37 - actually run it okay so what i want to
284:39 - demonstrate is a little odd but there's
284:41 - a program called ncal it gives us a
284:43 - calendar
284:44 - uh i'm going to make it so i can't
284:46 - actually execute that and then i'm going
284:48 - to undo it but i'm not going to show you
284:49 - how just yet i'm just going to
284:51 - demonstrate so if i do an ls-l on ncal
284:54 - in slash bin here it is
284:56 - we see the owner which is root members
284:59 - of the group which is also root and
285:02 - everyone else has that x present that
285:04 - means anyone can execute this
285:06 - i'm going to change that so i just did
285:08 - that
285:09 - now i do ls
285:10 - dash l on ncal again this program
285:14 - no longer has an x right there it did
285:16 - just a moment ago
285:17 - now this means that only the owner which
285:20 - is root i'm not root only members of the
285:23 - group root which i'm not a member of
285:25 - can execute everyone else does not have
285:28 - that x there no executable permissions
285:31 - on this file
285:32 - so now if i try and run ncal
285:35 - oh
285:36 - permission denied i can't run that
285:38 - script i cannot use that command anymore
285:40 - because it's not executable
285:42 - so that x is very very important uh and
285:45 - you probably wouldn't go around removing
285:47 - those
285:48 - but just to show you what the
285:50 - significance is so to reiterate if
285:52 - there's an x present for a directory
285:54 - that means you can cd into it but for a
285:56 - file that means you can execute it so
285:59 - i'm going to undo that we're going to
286:00 - learn this command that i used to do it
286:02 - it's called chamod change mode
286:04 - but now if i run that ls-lncal
286:07 - i have that x back and now i can run
286:09 - ncal again
286:11 - okay
286:12 - so now we're going to learn how to use
286:14 - this command to change those permissions
286:16 - i just want to run through one more time
286:18 - what these three things mean well
286:20 - there's ten things i guess the first is
286:22 - a dash for a file a d for a directory an
286:25 - l for sim link and then we have three
286:27 - groups of three
286:28 - each of these groupings has three places
286:31 - the first is either an r or a dash and r
286:34 - means read permission is present dash
286:36 - means no read permission
286:38 - w write permission a dash means no right
286:40 - permission and then the final slot is
286:42 - for execute x means it's executable
286:46 - no x a dash means you don't have that
286:48 - permission so the first three read write
286:51 - execute are for the owner of the file or
286:52 - folder the second three are for members
286:55 - of the group that owns that file or
286:57 - folder and then the final three are for
286:59 - everyone else so what does this mean a
287:01 - little quiz here uh what do these this
287:04 - exact set of attributes mean first of
287:07 - all are we talking about directory file
287:09 - sim link
287:11 - answer for your moment or think about it
287:12 - for a moment answer out loud if you'd
287:14 - like we are looking at a file
287:17 - and we can see the owner whoever that is
287:20 - has full permissions read write and
287:22 - execute members of the group owner have
287:25 - read writes but no execute permissions
287:27 - and everyone else only has read
287:30 - permissions
287:31 - okay
287:32 - so now let's talk about how we actually
287:34 - change these how do we use this weird
287:37 - chamod to mode however you want to
287:39 - pronounce it command
287:41 - it first of all stands for change mode
287:44 - and it is the tool it's the command we
287:46 - use to alter those permissions and
287:49 - here's the basic syntax there's actually
287:51 - two main ways of using chamod of
287:54 - specifying the permissions
287:56 - and the first i'm going to show you is
287:57 - the easier one when you're starting out
287:59 - so we have the command
288:01 - chamod change mode
288:03 - and then the mode meaning how we want to
288:06 - change the permissions who are we
288:08 - changing permissions for what are we
288:10 - changing
288:11 - read write execute and are we adding or
288:13 - removing that permission and then
288:15 - finally the file that we're trying to
288:17 - change
288:19 - so
288:19 - this is where it gets a little tricky
288:21 - the first thing we specify is the who
288:24 - we have these different letters u g o
288:27 - and a
288:28 - so u is how we can change the the file
288:30 - permissions for the user which is the
288:32 - owner of the group it's a little
288:34 - confusing because o is actually for
288:35 - others anyway if we have u
288:38 - that means we're changing permission for
288:40 - the user g is for members of the group
288:42 - o is for others and a is for all of
288:45 - those
288:46 - then we have a minus sign a plus sign or
288:49 - an equal sign
288:50 - so a minus sign will remove a permission
288:52 - a plus sign we'll add a permission we'll
288:54 - come back to equals and then finally the
288:56 - permission that we're trying to change
288:58 - read writer x execute
289:01 - so let me just show an example to make
289:02 - it a little clearer here if we have g
289:05 - plus w
289:06 - what we're saying here is four members
289:08 - of the group
289:10 - add so plus
289:12 - the right permission
289:14 - so here's what it looked like before for
289:15 - group r dash dash after we run this it's
289:18 - now r
289:20 - w dash so we added that w there but only
289:25 - for the group
289:26 - here's another example
289:28 - here we have that right permission for
289:31 - uh owner and for group
289:33 - we have an a and that means all so
289:36 - everyone all three of these chunks
289:39 - minus remove the w the right permission
289:42 - so we go from having right here and a
289:45 - right here to now having no right
289:47 - permission no right permission and no
289:49 - write permission
289:51 - so let's show an example
289:53 - why don't i go back to my home directory
289:55 - as colt
289:57 - and
289:58 - let's see i've got this permissions
290:00 - folder inside of it i have only colt
290:03 - coltscanread.txt why don't i change it
290:06 - so that
290:07 - how about
290:08 - everyone so all of us can read the
290:11 - contents of this file
290:13 - so it's not going to have a great name
290:15 - anymore it will still be only colt can
290:17 - read but that's not going to be true
290:19 - so this is what it looks like at the
290:20 - moment i'm going to run chamod change
290:23 - mode
290:24 - and then i'm going to say everyone so a
290:26 - all
290:28 - i want to add the read permission
290:31 - so add the read permission for everyone
290:34 - and then the file
290:36 - ls-l
290:38 - we now see everybody has an r
290:40 - so this means as you know if i go back
290:42 - to being elvis
290:45 - i can read the contents of that file now
290:48 - whoops only
290:50 - why don't i see it here
290:52 - oh jeez because elvis does not have
290:55 - permission
290:57 - to
290:57 - do anything in this directory remember
290:59 - if we back out one level
291:02 - here we are this permissions directory
291:05 - we can see
291:06 - there is no read
291:08 - attribute present so elvis can even list
291:10 - the contents of that folder so why don't
291:13 - we add that r back in with what we know
291:16 - what i want to do is change mode and i'm
291:18 - going to switch back to being colt
291:20 - change mode
291:22 - and what i'm going to do is change it
291:23 - for other
291:25 - so that's what the o if i go back here
291:29 - o means the world or others anybody
291:32 - who's not the owner or part of the group
291:34 - so here's permissions here everyone
291:36 - already has an r
291:38 - group
291:39 - the actual owner but i want to add this
291:40 - r back in so i'm going to say for others
291:44 - plus r add the read attributes
291:47 - for the permissions
291:51 - folder oh i'm in the permissions folder
291:53 - oh come on
291:54 - i gotta back out
291:56 - okay let's try that again for others add
291:59 - the read permission to the permissions
292:01 - directory here it is right now i'm gonna
292:03 - hit enter ls-l
292:06 - and now what do we see on permissions
292:08 - there is an r present that means if i go
292:10 - back to being elvis
292:15 - i can now cd into permissions
292:18 - and finally i can read the contents of
292:21 - only colt can read because now we have
292:24 - permission to read both that file and
292:26 - the parent directory
292:28 - now go back to being colts
292:30 - and what i'm going to do next is show
292:33 - let's see how to revoke permission so we
292:34 - use the minus sign
292:36 - so i'll revoke let's go back to um
292:40 - well let's go back into permissions
292:43 - here's that one file i'm going to revoke
292:46 - the read permission for everyone except
292:49 - for me
292:50 - so i'm going to do that here so i'm
292:52 - going to do
292:53 - change mode why don't i revoke it for
292:55 - the group first to show that so i'm
292:57 - going to say
292:58 - group g
293:00 - minus
293:01 - r
293:02 - for the group members of the group
293:04 - remove or revoke the read permission on
293:06 - only cult can read
293:08 - and now you'll see there's no r present
293:10 - here
293:11 - i could do the same thing but remove it
293:14 - for
293:15 - others
293:16 - ls-l
293:18 - we can see it's now gone
293:20 - now i can also do multiple at once so if
293:22 - i did this o minus rwx this means others
293:27 - remove read write and execute
293:30 - permissions
293:31 - so if i want to add
293:32 - how about full permissions read write
293:34 - and execute for everyone i could do
293:38 - chamod
293:39 - and then for everyone all i want to add
293:43 - read write execute
293:45 - on only can read
293:47 - and there we are our wx our wx rwx
293:51 - so it's now executable it's showing up
293:53 - differently
293:54 - it isn't actually going to do anything
293:56 - if i execute it because
293:58 - well it's not a script just a text file
294:00 - but anyway that's kind of the basics if
294:03 - i wanted to remove execute permissions
294:05 - for everyone you know i could do jamaad
294:08 - all minus x
294:11 - and now we we have rw dash rw dash rw
294:15 - dash so that's a quick intro to using
294:18 - chamod with this syntax now there's
294:20 - actually another syntax that we can use
294:23 - that is quite a bit more
294:24 - intimidating when you're starting out
294:26 - and i'm just going to alert you to his
294:28 - existence we can use octal notation
294:31 - which is base eight for these three
294:33 - digits of binary
294:35 - correspond to a file mode so zero zero
294:38 - zero is going to be dash dash dash one
294:41 - one one is rwx one zero zero is r dash
294:45 - dash so that's the binary here but each
294:48 - one of those in base eight is a single
294:50 - digit zero through seven
294:52 - it can be a little complicated to
294:53 - understand but as you can see here if
294:56 - you saw chamod seven five five what that
294:59 - tells us is for that first chunk
295:02 - seven
295:03 - is one one one meaning rwx
295:06 - five is one oh one right it's binary uh
295:10 - three binary digits is a single octal
295:13 - digit anyway our r dash x is what we end
295:16 - up with there
295:17 - i know it's kind of confusing it really
295:20 - is trust me if i have to teach this uh
295:22 - but there are some modes that are more
295:24 - common and you'll get used to them if
295:25 - you encounter them but you can always
295:27 - use the longer sort of englishy syntax
295:31 - that looks like this you know with the
295:33 - letters and plus or minus
295:35 - rather than having to worry about base 8
295:38 - craziness
295:39 - but that is something you'll see
295:41 - now what about the equal sign
295:43 - i said i'd come back to this the equal
295:45 - sign
295:46 - is basically a way of saying in this
295:48 - example a equals r
295:50 - set for all
295:52 - set it to be
295:53 - only read permissions and nothing else
295:55 - so it it's going to reset every other
295:57 - value so let's see an example of this in
295:59 - action we just have this only can read
296:02 - file which is actually not accurate
296:05 - but if i do want to make let's say
296:08 - i want to
296:10 - i don't know
296:12 - i'm grasping at straws here uh i'll make
296:14 - it so everyone can read and only read so
296:17 - no write permissions no execute
296:20 - what i can do is jamaad everybody all
296:23 - now instead of doing plus read or minus
296:27 - w because minus w would subtract right
296:29 - except get rid of that get rid of that
296:32 - but if i do equals
296:34 - read what this says is that
296:38 - the only permissions that we're having
296:40 - ignore everything else and get rid of
296:41 - them is read for everyone for all
296:45 - so ls-l
296:46 - and there we go everyone can read
296:49 - but nothing else if i instead if i just
296:52 - did a equals
296:54 - i can also do multiple like rw
296:58 - or rwx that's a long way but i can give
297:00 - everybody permissions and then if i went
297:03 - back and re-ran this so that it's
297:05 - equals r
297:07 - again that means only read get rid of
297:10 - everything else so we'll go from rwx rwx
297:12 - rwx to instead
297:15 - rr and just dashes for the read and
297:18 - write permissions
297:20 - all right so i know this is a pretty
297:21 - complicated topic uh there's a lot to
297:24 - cha mod
297:25 - not to mention just pronouncing it
297:27 - oh i guess i did not show we can also
297:30 - change permissions for multiple who at
297:32 - whose at one time
297:34 - so if i wanted to
297:36 - add write permissions only for the owner
297:39 - and the group owner i could do this
297:41 - chamod
297:42 - so the owner is you the group owner is g
297:46 - and then plus w
297:48 - for right
297:49 - and now we can see the owner and the
297:52 - group owner has that w there so we can
297:54 - have multiple values on the left hand
297:56 - side of that whatever plus minus equals
298:00 - and then again we have the octal
298:01 - notation which you'll see um you know
298:04 - 777 means rwx for everyone full
298:07 - permissions uh and you can spend more
298:10 - time learning this if you really care
298:11 - about it it is something you'll see in
298:12 - the wild but for now all i care about is
298:15 - that you understand the basic concept of
298:17 - these permissions and all these
298:19 - different different letters here rwx and
298:22 - dashes what does that mean what is the
298:24 - significance
298:25 - and then remember if we go back we
298:28 - talked about the owner and how we can
298:30 - change a file's owner using tone
298:33 - we can also use it to change the group
298:35 - that owns a file
298:36 - and then we can change individual
298:38 - attributes using chamod change mode
298:41 - that's a lot
298:42 - well we made it to the end we covered a
298:45 - ton of different commands maybe it's a
298:47 - little bit overwhelming maybe you're a
298:48 - little tired of seeing all the scrolling
298:50 - text go by
298:52 - but remember the point of all this is
298:54 - not to memorize and just become an
298:56 - expert on every single command overnight
298:58 - what really matters is being able to put
298:59 - the different pieces together to use the
299:01 - correct command when you need it read
299:03 - the man pages figure out how something
299:05 - works change what options you're using
299:08 - and just kind of duct tape it together
299:10 - when needed obviously some of these
299:12 - commands become second nature
299:15 - lscd touch make directory rm that sort
299:18 - of thing
299:19 - you get pretty comfortable using
299:22 - different expansions and redirection and
299:24 - piping and combining different commands
299:26 - but then some of these more niche
299:27 - commands certainly i wouldn't expect you
299:30 - to just remember and and honestly in
299:32 - preparing this sort of course i always
299:34 - have to look at the man pages and remind
299:36 - myself of all the different options and
299:38 - how they work so thanks again for
299:40 - joining me and remember if you are
299:42 - interested in my bootcamp you can find
299:43 - the link in the description and lastly
299:46 - thanks again to flavio
299:49 - for the excellent handbook
299:51 - all right well it was nice uh i guess
299:53 - recording this in a dark room and
299:54 - editing it in an equally dark room
299:56 - uploading it to youtube
299:59 - and
300:00 - being alone in this whole process
300:02 - but honestly who needs friends or
300:05 - companionship
300:06 - when you have the most sensual command
300:10 - man touch
300:11 - that's really all i need okay i gotta go
300:14 - get my cat to the vet