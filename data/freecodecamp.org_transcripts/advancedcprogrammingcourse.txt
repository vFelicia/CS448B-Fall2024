00:00 - welcome to this Advanced Journey Through
00:02 - the depths of c-sharp this course is
00:05 - designed to elevate your programming
00:06 - proficiency delving into intricate
00:09 - aspects like delegates events generics
00:12 - async await tasks and Link plus you'll
00:15 - learnabout.net with detailed code
00:17 - examples and best practice guidelines
00:19 - you'll explore design patterns user
00:22 - actions queries operators c-sharp
00:24 - attributes and more and you'll learn all
00:27 - this from gavinlan Gavin is an
00:30 - experienced developer and free code Camp
00:32 - team member so let's get started
00:34 - learning Advanced C sharp hi and welcome
00:38 - I'm Gavin long
00:40 - I'm a full stack software engineer with
00:42 - over 20 years of experience
00:44 - some of the more abstract concepts of
00:45 - the c-sharp language or any high-level
00:47 - programming language can seem somewhat
00:50 - esoteric even to many experienced
00:52 - Developers
00:53 - so my goal with this Advanced c-sharp
00:55 - course was to explain these more
00:58 - advanced abstract Concepts in a simple
01:00 - and easy to understand way
01:02 - I hope you enjoyed this course and I
01:04 - hope you benefit from it
01:06 - so what sort of topics do I intend to
01:08 - cover in the c-sharp advanced course
01:10 - here are a few examples delegates events
01:13 - generics extension methods Lambda
01:15 - Expressions link asynchronous
01:17 - programming with async await attributes
01:20 - reflection and more
01:24 - so what makes these kinds of topics more
01:27 - advanced than those discussed in the
01:29 - c-sharp for beginners course where we
01:31 - covered basic concepts like methods
01:33 - classes arrays data types variables enum
01:36 - switch statements if statements Loops
01:38 - Etc
01:40 - if I had to pick one word that sums up
01:42 - the answer to that question that word
01:44 - would be the word abstract
01:47 - I found what I believe to be an
01:48 - appropriate definition for the word
01:50 - abstract that in my view best fits the
01:52 - programming context
01:54 - to consider apart from application or
01:57 - association with a particular instance
02:02 - this definition sort of reminds me of
02:04 - the ancient philosophical Theory or
02:07 - world view attributed to the great
02:09 - ancient Greek philosopher Plato
02:12 - the theory is known as the theory of
02:14 - forms or theory of ideas
02:16 - I'm not going to go into too much detail
02:18 - regarding the theory itself but
02:20 - basically the theory asserts that
02:22 - Ultimate Reality exists outside our
02:25 - temporal and spatial world
02:27 - for example the human form itself exists
02:29 - as a thing independently from the actual
02:32 - humans that exist in plural in our
02:34 - experience of our temporal and spatial
02:36 - Realm
02:38 - an even more simple example is that of
02:40 - the shape of a triangle if I ask you to
02:43 - draw a triangle and I was to also draw a
02:45 - triangle there would be subtle
02:46 - differences in our drawings but
02:48 - essentially we would both be able to
02:50 - recognize the three-sided triangle shape
02:52 - in both of our drawings
02:54 - they are forms that are Universal
03:06 - so in this sense the triangle shape
03:08 - itself can be seen as an abstract
03:10 - concept but instances of this shape can
03:13 - be found and recognized in our real
03:15 - world experiences
03:16 - so for example in terms of programming
03:19 - we have certain abstract Concepts that
03:21 - exist on their own as universally
03:23 - recognizable patterns
03:25 - these patterns can be implemented in our
03:27 - code to solve multiple real world
03:29 - problems it can be hugely advantageous
03:31 - to understand certain Advanced abstract
03:33 - Concepts that can then be appropriately
03:35 - applied in code to achieve better code
03:38 - reuse cleaner code extensibility
03:40 - flexibility of design easier maintenance
03:43 - of code separation of concerns
03:45 - enablement of effective unit testing and
03:47 - the provision for overall better
03:49 - performance and efficiency of our
03:51 - applications if there is one downside to
03:54 - the implementation of certain Advanced
03:56 - code patterns it is that to someone
03:58 - unfamiliar with these advanced concepts
04:00 - the code implementations of these
04:02 - advanced concepts can appear as somewhat
04:04 - esoteric for most people the more
04:07 - abstract a concept is the more time is
04:10 - needed to understand the abstract
04:11 - concept
04:12 - this I would say is the main difference
04:14 - between the concepts discussed and the
04:16 - c-sharp for beginners course and some of
04:18 - the concepts that we will cover in the
04:21 - c-sharp advanced course
04:23 - let's look at a basic code example
04:26 - so this is just a basic example that
04:28 - I'll go through fairly quickly it's not
04:31 - necessary to follow along with the
04:32 - example
04:33 - I will however make the code example
04:35 - available on GitHub please see a link to
04:37 - the appropriate repository Below in the
04:39 - description
04:40 - so let's create a c-sharp Project based
04:42 - on the.net core console application
04:44 - project template
04:49 - let's name the project School HR
04:52 - Administration
05:06 - let's create a class Library project
05:12 - and I'll name this HR Administration API
05:17 - foreign
05:22 - within the class Library project let's
05:25 - first delete the class that is there by
05:27 - default and then add an interface named
05:29 - I employee
05:40 - let's add four property definitions to
05:42 - the I employee interface ID as integer
05:46 - first name is string
05:48 - and this is an interface so we of course
05:50 - don't need these Public Access modifiers
05:52 - preceding our property definitions
05:55 - last name is string and salary as
05:58 - decimal
06:06 - let's add an abstract class and name it
06:08 - employee base
06:12 - let's make this employee base abstract
06:15 - class implement the I employee interface
06:25 - and let's make the salary property a
06:27 - virtual property
06:29 - so now we have the basis in our HR
06:31 - Administration API class Library project
06:34 - for a basic employee record
06:36 - so from within our school HR
06:38 - administration.net core console
06:40 - application let's make a reference to
06:42 - the hi Administration API class Library
06:44 - project let's create a class named
06:47 - teacher and let's make the teacher class
06:49 - inherit from the employee base abstract
06:51 - class
06:53 - let's ensure that our code includes a
06:55 - directive to the hi Administration API
06:57 - namespace
06:58 - let's create three other classes that
07:00 - inherit from the employee Base Class
07:04 - these classes represent some other staff
07:06 - roles within the school
07:08 - so head of Department Deputy Headmaster
07:12 - and Headmaster
07:14 - let's say there is a requirement to sum
07:16 - up the annual salaries including bonuses
07:18 - for these members of staff
07:21 - first let's create a method named seed
07:23 - data so the seed data method accepts a
07:26 - generic list which is strongly typed as
07:28 - I employee as an argument
07:44 - foreign
07:51 - five employee objects and add each of
07:54 - the objects to the employee's collection
07:57 - for the sake of this example I'm going
07:58 - to hard code the property values for
08:00 - these five employee records
08:27 - so let's say that a bonus is paid
08:29 - annually to each of these staff members
08:31 - and the amount is based on seniority
08:34 - so let's override the salary property
08:37 - and add an appropriate bonus for each of
08:39 - these employees
08:41 - let's say the teacher gets two percent
08:44 - the head of Department three percent
08:47 - the deputy Headmaster four percent
08:50 - and the Headmaster gets five percent
08:53 - so let's address the requirements to
08:55 - calculate the sum total of staff
08:58 - salaries including bonuses
09:00 - so to do this we can Implement a for
09:02 - each Loop in the main method that
09:04 - traverses the items in our employees
09:06 - list and sums up the salaries within the
09:08 - for each Loop using the plus equals
09:10 - operator
09:11 - we can then output the sum total of all
09:14 - staff annual salaries including bonuses
09:16 - to the console screen
09:43 - let's run the code
09:51 - great
09:57 - we can use more advanced code to achieve
09:59 - the same thing literally through writing
10:01 - one line of code instead of the multiple
10:04 - lines of code used to create the for
10:06 - each Loop and the mathematical operation
10:08 - performed within the for each Loop
10:11 - so let's include a directive at the top
10:13 - of our code to the system.link namespace
10:15 - by using the linked technology we are
10:18 - able to provide the same solution with
10:20 - one line of code like this
10:56 - let's run the code
11:02 - and we get the same result as before
11:05 - but our code is more concise and much
11:07 - cleaner
11:08 - so let's briefly look at some of the
11:10 - advanced c-sharp concepts that have been
11:12 - applied in this simple example
11:14 - my explanation at this point will be
11:16 - brief because each of these topics will
11:18 - be discussed in detail as the c-sharp
11:21 - advanced course progresses
11:23 - sum is an extension method provided in
11:26 - the system.link namespace
11:29 - let's see what happens if we comment out
11:31 - the system.link directive
11:34 - the c-sharp compiler immediately
11:35 - complains the system.link namespace
11:38 - contains many useful extension methods
11:41 - including the sum extension method
11:48 - a Lambda expression is passed into the
11:51 - sum method the sum parameter accepts a
11:54 - delegate argument where the delegate
11:56 - contains a type definition parameter I.E
11:59 - the I employee type
12:01 - and as you can see there are several
12:04 - overloads to the sum method where the
12:06 - output type of the delegate can vary
12:09 - so we are passing in a delegate that
12:11 - accepts an argument of type I employee
12:13 - and outputs a decimal value
12:16 - so because we are summing up the salary
12:18 - field and the salary field is of type
12:20 - decimal the delegate passed in in the
12:23 - form of Lambda expression has an output
12:25 - of type decimal
12:27 - notice the fun keyword is used to define
12:30 - the delegate type parameter
12:32 - also notice the angle brackets following
12:35 - the funk keyword
12:37 - and within the angle brackets the date
12:39 - type definitions are included
12:41 - this is an implementation of generics
12:44 - even in this really basic example a lot
12:47 - of complexity is abstracted away
12:49 - through the use of Technologies like
12:51 - link extension methods delegates Lambda
12:54 - expressions and generics
12:56 - I won't go into too much detail
12:58 - explaining these Technologies in this
12:59 - video because all of these technologies
13:01 - will be explored in detail in this
13:04 - course
13:06 - here is a brief definition of each of
13:08 - the Technologies we have just discussed
13:09 - link stands for language integrated
13:11 - query link enables the developer to
13:14 - write queries against strongly typed
13:16 - collections of objects by using language
13:19 - keywords and familiar operators
13:23 - extension methods enable the developer
13:25 - to add methods to existing types without
13:28 - creating a new derived type recompiling
13:30 - or otherwise modifying the original type
13:34 - a delegate is a type that represents
13:36 - references to methods with a particular
13:38 - parameter list and return type
13:45 - a Lambda expression is a shorter way of
13:47 - representing an anonymous method using
13:49 - special syntax
13:51 - the funk type provides a way to store
13:53 - Anonymous methods in a generalized and
13:55 - simple way
14:04 - generics introduced the concept of type
14:06 - parameters to the.net framework which
14:09 - make it possible to design classes and
14:11 - methods that defer the specification of
14:13 - one or more types until the classroom
14:15 - method is declared and instantiated by
14:18 - client code
14:20 - let's abstract the object instantiation
14:22 - process for an employee through the use
14:24 - of a factory class
14:27 - so we are going to implement the factory
14:28 - design pattern to implement this code
14:32 - let's first create an enum at the top of
14:35 - our code and name it employee type
14:38 - let's include the members of Staff
14:40 - employee roles within the context of a
14:42 - school in the enumerator list
14:46 - okay let's create a public static class
14:48 - named employee Factory within this class
14:50 - let's create a public static method
14:52 - named get employee instance that returns
14:55 - an object of the I employee type
14:58 - let's implement the code for this method
15:00 - which simply instantiates an appropriate
15:02 - object based on the type of the employee
15:05 - foreign
15:22 - let's write the code that Returns the
15:24 - employee object to the calling code
15:41 - right let's use our Factory class to
15:43 - construct our employee objects within
15:46 - our C data method
15:58 - foreign
16:05 - so we have now abstracted the
16:06 - construction of our employee objects
16:09 - let's run the code
16:15 - but now let's go one step further So
16:18 - within the HR admin API class Library
16:20 - project let's create a generic class
16:23 - named Factory pattern
16:25 - as discussed earlier to someone not
16:27 - familiar with generics this class may
16:29 - seem somewhat esoteric
16:38 - the method in this class named create
16:41 - instance instantiates an object
16:42 - generically even though the object is
16:45 - generically created generics enables the
16:47 - code to be strongly typed and therefore
16:49 - the code is checked at compile time
16:52 - so let's go back to the calling code in
16:55 - the school HR Administration project and
16:57 - in the employee Factory class let's
16:59 - update the code that instantiates our
17:01 - employee objects through the utilization
17:03 - of the generic Factory pattern class
17:07 - we have abstracted the object
17:09 - construction process even further so
17:11 - let's run the code
17:18 - great
17:19 - so before I conclude this video I want
17:22 - to highlight another reason why it is
17:24 - important to understand the more
17:25 - advanced concepts in C sharp these
17:28 - advanced concepts are commonly used in
17:31 - various.net Project Frameworks like for
17:33 - example asp.net MVC web API and xamarin
17:37 - if you are a game developer that uses
17:40 - the unity game engine knowing the more
17:42 - advanced concepts in c-sharp will also
17:44 - be hugely advantageous
17:47 - foreign
17:48 - code for each of these types of
17:51 - applications or games without having a
17:53 - deep knowledge of the advanced concepts
17:55 - that are built into the Frameworks or
17:57 - game engine themselves but having a
17:59 - knowledge of these Concepts is going to
18:01 - give you an advantage when building and
18:03 - maintaining your applications or games
18:06 - so for example behind the scenes as it
18:08 - were a reflection is used extensively in
18:10 - asp.net MVC
18:13 - for example when the control and action
18:15 - names are passed from the root
18:17 - reflection is used to find the
18:19 - corresponding method to invoke
18:22 - attributes are also used extensively to
18:24 - abstract aware complexities and
18:25 - facilitate the ReUse of common
18:27 - functionality asynchronous programming
18:30 - with async await is used here to
18:32 - increase performance
18:34 - and generics is also commonly featured
18:37 - with the Entity framework data access
18:39 - technology Lambda expressions and Link
18:41 - are commonly used
18:44 - Entity framework is commonly used in
18:46 - asp.net MVC applications and web API
18:49 - applications
18:51 - in the web API framework we see the same
18:53 - Technologies being applied
18:56 - note that dependency injection is a
18:58 - built-in feature in the asp.net core MVC
19:01 - and web API project Frameworks
19:04 - dependency injection will be explored in
19:06 - the c-sharp advanced course
19:10 - [Music]
19:12 - in the xamarin project we can see here
19:15 - the use of attributes and generics is
19:17 - being applied here in code
19:19 - in this game created with unity generics
19:21 - is commonly used attributes are also
19:24 - frequently applied
19:25 - and these are just a few examples of how
19:27 - these advanced concepts are applied in
19:30 - commonly used project Frameworks and the
19:32 - unity game engine
19:37 - [Music]
19:39 - summary what makes the concept in
19:42 - programming a more advanced concept the
19:44 - more abstract the concept the more
19:46 - difficult the concept is to understand
19:47 - for most people
19:49 - gaining an understanding of the more
19:51 - abstract advanced concepts can be
19:54 - applied to achieve better code reuse
19:56 - cleaner code extensibility flexibility
19:58 - of design ease of code maintenance
20:01 - separation of concerns the enablement of
20:03 - unit testing and the provision for
20:05 - overall better performance and
20:07 - efficiency of our applications
20:10 - the more advanced concepts are applied
20:12 - frequently in the various.net project
20:14 - Frameworks like for example sp.net MVC
20:18 - web API and xamarin understanding these
20:21 - advanced concepts will also be an
20:22 - advantage to game developers that create
20:24 - games using the unity game engine
20:28 - some of the advanced concepts that will
20:29 - be explored in detail in this Advanced
20:32 - c-sharp course will be for example
20:34 - delegates events generics extension
20:36 - methods Lambda Expressions link
20:38 - asynchronous programming with async
20:40 - await attributes reflection and more
20:46 - [Music]
20:50 - hi and welcome this video highlights the
20:54 - significance of the release of dotnet 5.
20:56 - [Music]
20:59 - I've included this content as part of
21:01 - the c-sharp advanced course because I
21:03 - feel that this.net upgrade is a game
21:05 - changer for net Developers
21:16 - this will not be a code Focus tutorial
21:19 - I feel that in order to put c-sharp in
21:22 - its correct context we must understand
21:24 - the underlying Plumbing as it were and
21:27 - how future.net upgrades will affect us
21:29 - as c-sharp Developers
21:32 - with the release of.net 5. I thought it
21:35 - would be prudent to cover how this will
21:37 - change the context of our c-sharp
21:39 - applications
21:43 - [Music]
21:52 - [Music]
21:58 - [Music]
22:00 - so.net 5 is expected to be released in
22:03 - November 2020. the first preview of.net
22:05 - 5 is expected to be available in the
22:08 - first half of 2020 and will be supported
22:10 - by Visual Studio 2019 and visual studio
22:13 - code
22:15 - here are some key features of dotnet 5.
22:18 - a single unified platform for everything
22:20 - including Windows Mac web mobile cloud
22:23 - iot gaming machine learning and data
22:27 - science
22:28 - managed by open source community and
22:31 - supported by Microsoft cross-platform
22:33 - with any device anywhere
22:36 - supports all major platform capabilities
22:38 - for net framework.net core and xamarin
22:42 - including Windows forms WPF uwp asp.net
22:47 - MVC Entity framework link and so on
22:51 - scalable fast and high performance
22:54 - smaller development and packages
22:57 - support for the most productive Ides and
23:00 - tools including Visual Studio vs code
23:03 - vs4 Mac and command line interface CLI
23:08 - okay let's go back in time to just
23:10 - before May 23 1995.
23:14 - so what is the significance of this date
23:18 - well this is the date that Java first
23:21 - appeared
23:22 - so what does the phrase close to the
23:24 - metal mean and what does it have to do
23:26 - with anything
23:28 - when programmers say a programming
23:30 - language or platform is close to the
23:32 - metal this means the developer is able
23:35 - to programmatically manage and operating
23:37 - system's memory
23:39 - so when Java came along in 1995 this was
23:42 - a huge deal compiled Java code ran
23:46 - within its own environment called the
23:48 - jvm
23:49 - jvm stands for Java virtual machine
24:01 - write once run anywhere and automatic
24:04 - memory management
24:06 - before.net framework was released by
24:09 - Microsoft on February the 13th 2002
24:12 - visual Basics 6 had been released in
24:14 - 1998. Visual Basic is a third generation
24:18 - event-driven programming language
24:19 - developed for Microsoft's component
24:22 - object model com
24:25 - the first version of Visual Basic was
24:27 - released in 1991.
24:29 - Visual Basic was not a fully
24:31 - object-oriented language and was event
24:33 - driven
24:35 - it was also tightly coupled with the
24:37 - Visual Basic IDE
24:38 - a framework was a massive upgrade from
24:41 - this
24:42 - and the.net framework common language
24:43 - runtime resembled the Java virtual
24:46 - machine in many ways
24:48 - automatic memory management was achieved
24:50 - for Windows platforms but right once ran
24:53 - anywhere had not yet been enabled
24:54 - through.net the dotnet framework could
24:57 - only run on Windows platforms
25:00 - so the top similarities between the.net
25:03 - framework CLR common language runtime
25:05 - and Java's jvm Java virtual machine
25:08 - include
25:09 - they are both virtual machines they both
25:12 - include garbage collection they both
25:14 - employ stack-based operations they both
25:16 - include runtime level security
25:19 - they both have methods for exception
25:21 - handling
25:23 - the.net framework provides developers
25:25 - with an abstraction that sits above the
25:28 - operating system a virtual machine I.E
25:30 - the common language runtime and a suite
25:32 - of apis I.E bcls or Base Class libraries
25:37 - the.net framework provides thousands of
25:39 - Base Class libraries that Aid the
25:41 - developer with common development tasks
25:43 - interoperability
25:45 - multiple.net languages for example
25:47 - vb.net F-sharp and of course c-sharp can
25:51 - be included and interact with each other
25:52 - in the same application this is possible
25:55 - because the higher level.net languages
25:57 - are first compiled into the Intermediate
26:00 - Language
26:01 - the Intermediate Language is then
26:03 - compiled at runtime into machine
26:05 - language through just-in-time
26:07 - compilation
26:09 - the.net framework also provides memory
26:11 - management security and exception
26:13 - handling
26:15 - .NET Framework although a massive
26:18 - Evolution from VB6 and com is not
26:20 - modular and is not cross-platform
26:23 - it has to be installed in its entirety
26:26 - and it can only run on a Windows
26:28 - platform
26:30 - the latest version of the.net framework
26:32 - is version 4.8
26:34 - this version was released on April 18
26:37 - 2019.
26:40 - so let's go back in time to the release
26:42 - of mono
26:43 - mono was first released on June the 30th
26:47 - 2004. it is a free and open source
26:50 - project to create an ecma standard
26:52 - compliant.net framework compatible
26:54 - software framework
26:56 - including a c-sharp compiler and a
26:59 - Common Language runtime
27:00 - originally created by Simeon it was
27:03 - later acquired by Novell and is now
27:06 - being led by xamarin a subsidiary of
27:09 - Microsoft and the.net Foundation
27:41 - so mono provided a.net runtime
27:43 - implementation which allowed c-sharp
27:46 - code to be compiled and implemented on
27:47 - multiple platforms
27:49 - dot net core's initial release was in
27:52 - June 2016. net core is a free and open
27:55 - source managed computer software
27:58 - framework
28:02 - it is a cross-platform successor to
28:04 - the.net framework
28:06 - .net core is similar to mono in that it
28:09 - enables cross-platform portability
28:11 - it is an open source and cross-platform
28:13 - framework
28:19 - .net core can be said to be a more agile
28:22 - version of.net framework because only
28:24 - the components required for a particular
28:26 - application need to be deployed to the
28:29 - Target computer
28:31 - net core has been optimized for the
28:33 - cloud and can also run inside a Docker
28:35 - container which makes it an ideal
28:37 - runtime environment for macro services
28:40 - the latest release of.net cores version
28:42 - 3.1 and was released on the 3rd of
28:45 - December 2019.
28:48 - so at this point we have.net framework
28:50 - mono and net core providing different
28:52 - implementations of.net
28:55 - so you can see how it could be difficult
28:57 - for Developers for example to be sure
28:59 - for particular.net Base Class Library
29:01 - component dependency would be supported
29:04 - across relevant.net implementations
29:07 - so in order to create uniformity across
29:09 - these implementations of.net Microsoft
29:11 - introduced the.net standard
29:14 - .net standard is a set of apis that
29:16 - all.net platforms have to implement
29:19 - [Music]
29:20 - it was introduced to unify the.net
29:23 - platforms and prevent future
29:24 - fragmentation
29:26 - for more comprehensive information on
29:28 - what is supported by the.net standard
29:30 - please check out this table that can be
29:33 - found at this URL
29:34 - dotnet standard was a great step forward
29:36 - in terms of providing uniformity
29:38 - across.net platforms
29:40 - but wouldn't it be great to have one
29:42 - framework to rule them all
29:48 - so why.net 5 and not.net core version 4.
29:52 - Microsoft is following the version
29:54 - progression of the.net framework where
29:57 - as mentioned earlier the latest release
29:59 - of the.net framework is version 4.8
30:02 - so this is why the next release of dot
30:04 - net is.net 5.
30:06 - it follows from the.net framework
30:07 - visioning rather than the net core
30:09 - versioning so what is the significance
30:12 - of dotnet 5.net 5 will be open source
30:15 - and you will be able to use it to Target
30:17 - Windows Mac OS iOS Android tvos watch OS
30:22 - and webassembly and more
30:25 - I recommend reading this blog from
30:27 - Richard Lander the program manager of
30:28 - the.net team this blog post was written
30:31 - on the 6th of May 2019 and can be found
30:34 - at this URL
30:36 - here are some significant quotes from
30:38 - the blog post
30:40 - from the Inception of the.net core
30:41 - project we've added around 50 000.net
30:44 - framework apis to the platform
30:49 - .net core 3.0 closes much of the
30:52 - remaining capability Gap with.net
30:54 - framework 4.8 enabling Windows forms WPF
30:58 - and Entity Framework 6.
31:01 - Net 5 Builds on this work
31:03 - taking.net core and the best of mono to
31:06 - create a single platform that you can
31:08 - use for all your modern.net code
31:10 - we intend to release.net 5 in November
31:13 - 2020 with the first preview available in
31:16 - the first half of 2020.
31:19 - it will be supported with future updates
31:22 - to visual studio 2019 visual studio for
31:25 - mac and visual studio code
31:28 - the blog post goes on to say the
31:30 - following everything you love about.net
31:32 - core will continue to exist open source
31:35 - and Community oriented on GitHub
31:37 - cross-platform implementation support
31:39 - for leveraging platform-specific
31:41 - capabilities such as Windows forms and
31:44 - WPF on Windows and the native bindings
31:47 - to each native platform from xamarin
31:50 - high performance side-by-side
31:52 - installation small project files SDK
31:55 - Style
31:56 - capable command line interface CLI
31:58 - Visual Studio visual studio for mac and
32:01 - visual studio code integration
32:04 - here's what will be new
32:06 - you will have more choice on runtime
32:08 - experiences
32:09 - Java interoperability will be available
32:12 - on all platforms Objective C and Swift
32:14 - interoperability will be supported on
32:17 - multiple operating systems
32:19 - core FX will be extended to support
32:22 - static compilation of.net ahead of time
32:24 - aot
32:26 - smaller Footprints and support for more
32:29 - operating systems
32:31 - we will ship.net core 3.0 this September
32:34 - referring to September last year
32:37 - 2019.net 5 in November 2020 and then we
32:41 - intend to ship a major version of.net
32:43 - once a year every November
32:46 - and note the depiction of the release
32:48 - schedule timeline in 2021.net 6
32:52 - 2022.net 7. so no more.net framework or
32:56 - net core but rather one unified open
32:59 - source cross-platform
33:00 - framework.net 5 is a welcome release
33:04 - so please let me know in the comments
33:05 - your thoughts on.net 5. I think the move
33:08 - to unify features from.net framework
33:10 - mono and Dot net core into one framework
33:13 - is a big step forward
33:17 - [Music]
33:21 - this video serves as an introduction to
33:24 - delegates and is the first part of a
33:26 - video series on this Advanced c-sharp
33:28 - topic
33:33 - thanks
33:37 - [Music]
33:38 - we'll look at a broad overview of
33:40 - delegates in this video so that we can
33:43 - understand delegates conceptually and
33:45 - we'll also create a very basic example
33:47 - of using delegates and code
33:49 - my aim is to explain these advanced
33:51 - concepts in a simple way
33:53 - so what are delegates
33:55 - a delegate can be described as a
33:57 - typesafe function pointer
33:59 - a variable defined as a delegate is a
34:02 - reference type variable that can hold a
34:04 - reference to a method in order for a
34:06 - delegate to reference a particular
34:07 - method the delegate must Define
34:08 - parameters with types that match the
34:11 - parameter types contained in the
34:12 - relevant method the delegate must also
34:14 - Define a return type that matches the
34:17 - return type of the relevant method
34:19 - when a developer instantiates a delegate
34:21 - the developer can associate its instance
34:24 - with any method with compatible
34:25 - parameters and return type
34:28 - the developer can invoke or call the
34:30 - method through the delegate instance
34:32 - note that variants can be used in
34:34 - delegates which means that the types
34:36 - defined for the parameter list and the
34:37 - return type of the delegate do not have
34:40 - to match exactly with the relevant
34:41 - methods parameter types and return type
34:44 - in this video we'll keep the example
34:46 - simple but we'll discuss variants in an
34:48 - upcoming video in the meantime if you
34:50 - wish to read about variants you can
34:52 - navigate to this URL this web page
34:54 - contains content on both covariance and
34:57 - contravariance
35:04 - in this video I'll introduce delegates
35:06 - through a basic example where a delegate
35:08 - can reference a static method and an
35:11 - instance method
35:12 - we'll also look at multicast delegates
35:14 - which allows the developer to invoke or
35:16 - call multiple methods through one
35:18 - delegate call we'll also look at how a
35:20 - delegate can be passed as a parameter to
35:22 - a method and subsequently called within
35:24 - that method
35:26 - in a later video on delegates we'll
35:27 - explore how delegates are used for
35:29 - asynchronous callbacks and event
35:31 - handling in c-sharp we'll learn how we
35:34 - can take advantage of different types of
35:36 - delegates like action func and predicate
35:38 - to facilitate callbacks and add
35:40 - flexibility to our code but let's first
35:42 - look at the basics in this introduction
35:44 - to delegates so a delegate can reference
35:47 - both static methods and instance methods
35:50 - let's first look at how a delegate can
35:51 - reference static methods let's say we
35:54 - want to encapsulate functionality that
35:56 - logs text and includes a date timestamp
35:58 - preceding the text
36:01 - in some situations we want to have the
36:03 - ability to log the text to the console
36:05 - screen and in other situations we want
36:07 - to have the ability to log the text to a
36:09 - text file
36:11 - so let's define a delegate that can
36:13 - reference a method that does not return
36:14 - a value and accepts one string argument
36:17 - so to do this we use the delegate
36:19 - keyword followed by the name of the
36:21 - delegate type we wish to Define let's
36:24 - name this delegate log Del
36:26 - so preceding the logdel delegate name we
36:29 - have included the void keyword this is
36:31 - because we want this delegate to
36:32 - reference a method that does not return
36:34 - a value then after the logdale delegate
36:37 - name we can include brackets and within
36:39 - the brackets a list of parameters
36:41 - so let's include one string parameter
36:43 - and name it text
36:45 - so this delegate can reference methods
36:47 - that contain one string parameter and do
36:49 - not return a value note that we have
36:51 - included our delegate definition within
36:53 - the program class which means this
36:55 - delegate type can be accessed from
36:57 - anywhere within the program class
36:59 - we could have included this delegate
37:01 - definition outside the program class and
37:03 - within the delegate basic example
37:05 - namespace if we wanted to extend the
37:07 - delegate's accessibility to anywhere
37:09 - within the delegate basic example
37:11 - namespace
37:13 - in this example we'll Define the
37:15 - delegate scope so that it is accessible
37:17 - from anywhere within the program class
37:18 - and not accessible from outside of the
37:20 - program class let's create a static
37:23 - method named log text to screen inside
37:25 - the program class
37:28 - this static method contains the void
37:30 - keyword which is used to indicate that
37:32 - the method does not return a value and
37:34 - contains one string parameter named text
37:37 - the functionality within this method is
37:39 - very basic we are simply writing the
37:42 - text arguments value to the screen with
37:44 - the date timestamp preceding the value
37:46 - stored in the text argument
37:49 - you can see that the delegate type we
37:51 - have just defined named logdel contains
37:54 - a definition for a method that does not
37:55 - return a value and contains one string
37:57 - parameter so the return type and
38:00 - parameter type defined in our delegate
38:02 - named logdel matches the return type and
38:05 - the parameter type in the log text to
38:07 - screen method signature
38:09 - let's go to our main method and Define a
38:11 - variable as the logdoll type
38:14 - we do this by entering the logdal
38:16 - delegate name followed by the variable
38:17 - we'll name logdel then the equals symbol
38:20 - followed by the new keyword to
38:22 - instantiate an object
38:24 - we must then follow the new keyword with
38:27 - the name of the log Del delegate type
38:29 - and then pass the name of the method
38:31 - that we want the logdel variable to
38:33 - reference into the logdoll types
38:35 - Constructor like this then to call the
38:37 - method now referenced by the logdel
38:39 - variable we can simply write the name of
38:42 - the variable that references the
38:43 - delegate and pass in the appropriate
38:45 - parameter to the delegate like you would
38:47 - if you were calling a method
38:49 - note you're also able to invoke
38:51 - delegates through the use of the
38:53 - delegate types invoke method like this
38:55 - but for this example let's call the
38:57 - delegate without using the invoke method
38:59 - okay so let's make this example slightly
39:01 - more interesting let's write code in the
39:03 - main method to prompt the user for the
39:05 - user's name and let's pass the user's
39:07 - input as an argument to the logdel
39:09 - delegate
39:12 - let's run the code
39:18 - and that works as expected
39:21 - so what happens if we decide to include
39:22 - the date time stamp as a parameter in
39:25 - the log text to screen methods method
39:27 - signature
39:28 - the c-sharp compiler automatically
39:30 - complains
39:31 - this is because the log text to screen
39:33 - method no longer conforms to the log
39:36 - dial delegate definition
39:38 - so let's change the logdel delegate
39:40 - definition to accommodate a parameter of
39:42 - the date time data type
39:58 - right let's run the code
40:07 - great
40:11 - so that gives us a basic idea of how
40:14 - delegates work
40:15 - let's change the code for the log text
40:17 - to screen method and the logdel delegate
40:20 - definition to how it was previously
40:23 - I.E let's remove the daytime stamp as a
40:26 - parameter for the logdel delegate
40:27 - definition
40:28 - and let's also remove the date time
40:30 - stamp parameter from the log text to
40:32 - screen method signature
40:35 - let's also update the log text to screen
40:37 - method implementation accordingly
40:40 - so let's say there is a requirement to
40:42 - log the text to a text file
40:45 - to implement this functionality we can
40:48 - simply create a method that doesn't
40:50 - return a value and contains a string
40:52 - parameter
40:55 - as we now know this will allow this
40:57 - method to be referenced by a variable
41:00 - defined as the log delt delegate
41:03 - so let's create a static method named
41:06 - log text to file
41:08 - that contains a string parameter and
41:10 - does not return a value
41:13 - let's Implement codelogic detail that
41:15 - writes the input from the user to a text
41:17 - file
41:41 - let's replace the log text to screen
41:44 - method name being passed into the
41:46 - logdoll delegate during the construction
41:47 - of the delegate object with the log text
41:50 - to file method name so our lockdown
41:53 - variable is now referencing the log text
41:55 - of file method so when the logdel
41:58 - delegate is called this should invoke
42:01 - the log text to file method
42:08 - let's see if the user's input has been
42:11 - written to the relevant text file
42:13 - right so let's navigate to where the log
42:15 - file should now have been created
42:17 - which is the same directory path from
42:19 - where our code is run
42:32 - and you can see that the user's input
42:34 - has been successfully written to the log
42:36 - file as expected
42:39 - so we have now proven that we can
42:40 - reference static methods and delegate
42:42 - defined variables let's now prove that
42:44 - delegates can also reference instance
42:46 - methods
42:48 - let's create a class named log
42:55 - let's move our static methods to the log
42:57 - class
42:59 - and let's remove the static keyword from
43:01 - their method signatures because we want
43:03 - to test that instance methods can be
43:06 - referenced from delegates
43:17 - let's go to the main method and create
43:19 - an instance of the log type
43:29 - let's then pass the instance method
43:31 - named log text to screen into the logdel
43:34 - delegate Constructor
43:39 - Let's test the code
43:47 - great the user's input is logged to the
43:50 - screen as expected
43:51 - and for good measure let's also test the
43:54 - log text to file instance method
44:06 - excellent
44:08 - we are also able to call both methods
44:10 - through one delegate call
44:12 - this can be done through the use of
44:13 - what's known as a multicast delegate
44:16 - by using a multicast delegate multiple
44:19 - objects can be assigned to one delegate
44:21 - instance by using the plus operator
44:25 - let's define two delegate variables as
44:27 - log Del on one line like this
44:31 - let's name the first delegate log text
44:32 - to screen Dell and the second delegate
44:34 - log text to file though
44:37 - let's instantiate the first delegate
44:39 - named log text to screen Dell and ensure
44:42 - that it references the instance method
44:44 - named log text to screen
44:47 - let's instantiate the second delegate
44:49 - named log text to file Dell and ensure
44:52 - that it references the instance method
44:54 - named log text to file
44:58 - let's create a multi-cost delegate named
45:00 - multi-log Dell and assign it a value
45:03 - which is a combination of both the log
45:05 - text to file Dell variable and the log
45:07 - text to screen dial variable
45:10 - note that these two delegate variables
45:12 - have been combined through the use of
45:14 - the plus operator
45:16 - we are now able to call the log text to
45:19 - screen method and the log text to file
45:21 - method through one call to the multi-log
45:24 - Dell delegate
45:25 - Let's test the code
45:30 - and the user's input along with the
45:32 - timestamp has been logged to the screen
45:33 - as expected
45:35 - let's see if the user's input has been
45:37 - logged to the relevant text file and it
45:39 - has great and lastly let's demonstrate
45:42 - how a delegate can be passed as an
45:44 - argument to a method then invoked by the
45:47 - method that receives the delegate
45:49 - argument
45:50 - let's create a static method in the
45:52 - program class named log text
45:54 - this method does not return a value and
45:56 - contains a parameter defined as the
45:58 - logdel delegate type and the log text
46:01 - method will simply serve as a wrapper
46:02 - function for calling the logdoll
46:04 - delegate which will be passed as an
46:06 - argument at runtime to the log text
46:08 - method
46:10 - let's go to the main method and pass the
46:12 - multi-log Dell delegate as an argument
46:14 - to the log text static method
46:19 - Let's test the code
46:24 - so it is logged the user's text to the
46:26 - screen as expected
46:28 - let's also check whether the text has
46:30 - been logged to our log file
46:32 - excellent
46:34 - so you could also pass the log text to
46:36 - screen dull object or the log text to
46:39 - file Dell object as an argument to the
46:42 - log text method
46:43 - so let's do this
46:45 - let's first pass the log text to screen
46:47 - Dell object into the log text method and
46:50 - run the code
46:53 - great
46:55 - and let's also Test passing in the log
46:57 - text to file Dell object to the log text
47:00 - delegate
47:03 - let's look at the appropriate text file
47:08 - excellent
47:11 - so you can see how delegates can be used
47:12 - to separate design from implementation
47:14 - detail and facilitate flexibility of
47:18 - design in our applications
47:21 - please let me know in the comments
47:22 - section whether you have used delegates
47:24 - before in your code if not hopefully you
47:26 - will feel confident that you can use
47:27 - them in the future
47:30 - I hope you have enjoyed this basic
47:31 - introduction to delegates in the next
47:34 - tutorial we'll dive deeper into
47:35 - delegates with a more detailed example
47:46 - [Music]
47:51 - hi and welcome this is the second part
47:55 - of a tutorial on delegates please note
47:57 - that this tutorial is going to be quite
47:58 - code intensive and I will be going
48:01 - through the code creation process fairly
48:03 - quickly
48:04 - if you are struggling to follow along my
48:06 - advice would be to download the code
48:07 - from GitHub and use this video as a
48:10 - guide
48:11 - a link to the relevant GitHub repository
48:13 - is available in the description
48:16 - the purpose of this video is to help you
48:18 - understand delegates and how they can be
48:21 - applied in code and also how certain
48:22 - code design principles should be adhered
48:25 - to in order to create reusable
48:27 - extensible clean and easy to maintain
48:29 - code
48:31 - basically we are going to build a club
48:32 - membership registration form and use
48:34 - delegates to implement field validation
48:36 - functionality
48:38 - the advantage of using delegates for
48:40 - this purpose is that these delegates can
48:42 - be reused to validate fields for other
48:45 - forms that we may wish to add to our
48:47 - application in the future
48:49 - this alludes to how delegates can
48:50 - facilitate extensibility of our design
48:53 - we are effectively going to decouple
48:55 - validation from any one particular form
48:59 - these delegates will be enabled to be
49:01 - reused to validate any appropriate
49:04 - fields for any form so we have
49:06 - highlighted two advantages that can be
49:08 - gained through the use of delegates code
49:10 - reuse adherence to the code principle of
49:13 - dry which is an acronym for don't repeat
49:14 - yourself and code design flexibility
49:19 - so in this example we'll build a basic
49:22 - application using c-sharp and the.net
49:24 - console project template we'll use
49:26 - sqlite to store the data entered into
49:28 - our user registration form we will then
49:30 - create a login form and write a code to
49:32 - authenticate the user by validating the
49:35 - user's login information against
49:36 - relevant data stored in a table in a
49:39 - sqlite database
49:42 - if you are not familiar with SQL Lite
49:44 - please navigate to this URL for more
49:46 - information
49:47 - you can also download a sqlite client
49:49 - application named sqlite browser from
49:52 - this location
49:54 - foreign
50:00 - [Music]
50:10 - basic code using Entity framework core
50:13 - for appropriate database interactions
50:15 - you may have noticed that I have used
50:17 - the.net core console project template
50:19 - for all my tutorials thus far
50:22 - there is a very good reason for this
50:24 - we could implement the code we are about
50:27 - to write using the asp.net MVC framework
50:31 - we can scaffold our code and leverage
50:33 - Technologies like specific attributes
50:35 - provided in.net to facilitate field
50:38 - validation
50:40 - separation of model views and
50:42 - controllers and functionality like
50:44 - dependency injection is inherently taken
50:46 - care of for us in the asp.net MVC
50:49 - framework
50:50 - please don't misunderstand me Frameworks
50:52 - like asp.net MPC facilitate rapid
50:55 - application development and I am a
50:57 - proponent of using such Frameworks
51:00 - the only problem is we run the risk of
51:03 - not fully understanding the underlying
51:05 - design and code principles that are
51:07 - abstracted away by such Frameworks
51:10 - we can easily and effectively develop
51:12 - web applications for example using
51:14 - Frameworks such as asp.net MVC without
51:17 - understanding the fundamental underlying
51:19 - principles that make such Frameworks so
51:22 - effective
51:24 - so because the.net core console project
51:26 - template doesn't spoon feed us as it
51:28 - were
51:29 - it can force us to think about
51:31 - fundamental design principles that
51:33 - facilitate for example code reuse
51:35 - separation of concerns the
51:37 - implementation of code design
51:38 - flexibility and dependency and version
51:40 - principle
51:42 - with all that said let's look at a
51:44 - bird's eye view of what our basic
51:46 - application will look like
51:48 - we'll start with the main.net core
51:50 - console project
51:51 - we'll then create a standard class
51:53 - Library project which will be referenced
51:55 - by our main.net core console project
51:57 - the.net standard class Library project
52:01 - will be named field validator API and
52:04 - will contain two classes one class will
52:06 - be named common field validator
52:08 - functions it will contain a number of
52:10 - delegates which will encapsulate
52:12 - functionality for common validation like
52:14 - for example required field validation
52:17 - string length validation pattern match
52:19 - validation field comparison validation
52:22 - and date validation
52:24 - the other class will be named common
52:26 - regular expression validation patterns
52:28 - this class will contain a number of
52:30 - common regular expression patterns that
52:33 - can be leveraged in our application for
52:35 - example a regular expression pattern
52:37 - used for validating an email address a
52:40 - pattern that can be used to validate UK
52:42 - postcodes
52:43 - a pattern that can be used to validate
52:45 - UK phone numbers
52:47 - and a pattern for validating strong
52:49 - passwords
52:51 - within the main project the.net core
52:53 - console project will create four folders
52:55 - a folder named data to store data
52:58 - related classes and interfaces a folder
53:00 - named field validators to store
53:02 - interfaces and classes relevant to field
53:04 - validation
53:06 - a folder named models to store our data
53:08 - structures in this application we are
53:11 - only going to implement one data
53:12 - structure which will be a class
53:14 - containing user registration related
53:16 - properties
53:20 - and lastly a folder named views this
53:23 - folder will contain one interface and
53:25 - classes relevant to the screens that
53:27 - will be presented to the user
53:29 - namely the user login view the user
53:32 - registration View and welcome view which
53:34 - is presented to the user
53:36 - once the user is authenticated through
53:38 - the use of the login view there's also a
53:41 - main view which will be instantiated and
53:43 - run from within the main method
53:45 - so this application serves as a simple
53:47 - example of how we can leverage delegates
53:50 - and design our applications to
53:52 - facilitate easy maintenance and
53:53 - flexibility of design we are also going
53:56 - to create three ancillary classes within
53:58 - the root of the.net core console
54:00 - application namely common output text
54:03 - where we can store and make available
54:05 - for example heading text common output
54:08 - format which we can use for changing the
54:10 - background and foreground color of our
54:13 - output text and lastly we'll create a
54:15 - class named Factory which will abstract
54:17 - away the construction of our main view
54:19 - object this will demonstrate a very
54:22 - basic example of the use of dependency
54:24 - injection and show an adherence to the
54:27 - last letter of solid I.E dependency
54:30 - inversion principle
54:33 - so let's get started first let's create
54:35 - a.net core console project where
54:38 - solution as always will be
54:39 - auto-generated to house our project
54:42 - let's name this project club membership
54:44 - application
54:46 - the theme of this application will be a
54:48 - user registering for a Cycling Club
54:52 - right so let's add a folder named models
54:55 - let's add a class to our models folder
54:57 - named user
54:59 - let's add properties to our user class
55:02 - these properties will store the values
55:04 - entered by the user during the
55:06 - registration process
55:07 - all of these properties must be public
55:09 - read write properties so they must have
55:12 - both Getters and setters
55:14 - so let's create ID as integer first name
55:18 - is string last name as string password
55:21 - is string note that the password field
55:23 - will be stored in the user's database
55:26 - table without first being encrypted
55:29 - I have not included any encryption code
55:31 - because encryption and decryption are
55:33 - beyond the scope of this tutorial
55:35 - date of birth as date time phone number
55:38 - as string address first line as string
55:41 - addressed second line as string
55:44 - address city as string and lastly
55:47 - postcode as string
55:50 - let's decorate the ID field with the
55:52 - database generate attribute and pass the
55:55 - enumerator list item value of database
55:58 - generated option.identity as an argument
56:01 - to the database generated attribute
56:04 - so this is what is known as a code first
56:06 - approach to developing an application
56:08 - that uses a database for data storage
56:11 - we first create a model which is
56:13 - implemented as a c-sharp class then we
56:16 - are able to run certain commands either
56:17 - through.net CLI or Visual Studio to
56:20 - generate the data structure in our
56:21 - database from the models created within
56:24 - our application
56:25 - in this application we are going to run
56:27 - the relevant database commands through
56:30 - Visual Studio
56:32 - note as an alternative we could use the
56:34 - database first approach which would
56:36 - involve creating the database schema in
56:38 - the database and then generating the
56:40 - models from the database schema using
56:42 - appropriate database commands
56:45 - we'll use the code first approach in
56:47 - this application
56:48 - so note that by decorating the ID field
56:50 - with the database generated attribute
56:52 - the way we have done here we are
56:55 - declaring that we wish to create the ID
56:57 - field as a primary key in the relevant
56:59 - database table and that this ID field
57:02 - must Auto increment each time a new row
57:05 - is added to the relevant database table
57:09 - so the next step is to install the
57:11 - relevant Entity framework core package
57:14 - the package we need for this application
57:16 - is Microsoft dot Entity framework core
57:18 - dot SQL Lite so let's browse for the
57:21 - relevant nuget package using the nuget
57:23 - package manager facility provided within
57:26 - Visual Studio
57:28 - and let's install the microsoft.ensity
57:30 - framework core dot sqlite package
57:56 - so the next step is to add a DB context
57:59 - class to our project
58:01 - let's first create a folder named data
58:04 - let's add a class to the data folder and
58:07 - name it club membership DB context
58:10 - so this class must inherit from The
58:12 - Entity Frameworks DB context based class
58:16 - DB context class resides in the
58:19 - microsoft.ensity framework core
58:20 - namespace
58:22 - so let's create a directive to this
58:24 - namespace in our club membership DB
58:26 - context class
58:28 - and now let's override the DB context
58:30 - based classes on configuring method
58:34 - within this method we can configure a
58:37 - connection to the sqlite database that
58:39 - we wish to create and access
58:42 - we are using the DB context option
58:44 - Builder object to configure our
58:46 - connection string the connection string
58:48 - here is very basic it contains a file
58:50 - path to our database file
58:53 - the database file will reside in the
58:56 - same location from where our code will
58:58 - run this is achieved by using the
59:01 - appdomain.currentdomain.base directory
59:03 - property to establish the path to our
59:05 - sqlite database file
59:08 - we are then passing the DB context
59:10 - options Builder object to the DB context
59:13 - class using a call to the base method
59:17 - the next step is to create a table
59:19 - database structure for our relevant
59:21 - model class
59:23 - so we only have one model class to worry
59:25 - about here I.E the user class
59:29 - so we use the entity Frameworks DB set
59:31 - generic type and pass the user type as a
59:35 - generic argument to the DB set type to
59:38 - establish the type of property that will
59:41 - contain a reference to the users table
59:42 - that will be generated in our sqlite
59:45 - database
59:47 - Entity framework will use this user's
59:49 - property to add data to the user's
59:52 - database table and retrieve data from
59:54 - the user's database table
59:56 - we could also use the user's property to
59:58 - update data within the user's database
60:00 - table but we won't need to implement
60:02 - database record updates in this
60:04 - application
60:06 - so before we run the update hyphen
60:09 - database command within visual Studio's
60:12 - package manager console facility we need
60:15 - to create what is known as a migration
60:18 - so we can use the add hyphen migration
60:20 - command for this purpose like this
60:33 - okay so why has that failed
60:36 - the reason is that we need to install
60:38 - the microsoft.entity framework.tools
60:41 - nuget package so let's do this
61:03 - let's try to create the migration again
61:21 - and this time it succeeds and there's
61:23 - the migration class created for us
61:26 - and you can see that the code in this
61:28 - class contains a method to create the
61:30 - user's table
61:32 - and it also creates a method to drop the
61:33 - user's table
61:37 - so in order to run the migration we can
61:39 - run the update hyphen database command
61:41 - like this
61:46 - okay great
61:49 - so let's see if our database has been
61:51 - created as expected
62:02 - and it has great
62:07 - let's open the database in the sqlite
62:10 - browser client facility to see if our
62:12 - users table has been created as expected
62:17 - and it has excellent
62:20 - so now let's create a project that will
62:22 - serve as an API providing reusable
62:25 - validation functionality
62:35 - let's remove the default class
62:44 - and let's create a class named common
62:46 - field validator functions
62:55 - let's make this class public and let's
62:58 - add five delegate definitions the first
63:00 - delegate definition defines a delegate
63:02 - type that can reference a method used
63:05 - for the purpose of ensuring that a form
63:07 - field is not left empty
63:10 - the second delegate that finds a
63:12 - delegate type that can reference a
63:14 - method used for constraining the
63:16 - character length of a text field to
63:18 - between a minimum and maximum value the
63:21 - third delegate definition defines a
63:23 - delegate type that can reference a
63:25 - method that validates the date
63:27 - the fourth delegate definition defines a
63:29 - delegate type that can reference a
63:31 - method that can be used for validating a
63:34 - text input field value against a regular
63:36 - expression pattern
63:38 - the fifth delegate definition defines a
63:41 - delegate type that can reference a
63:42 - method that validates the text field
63:45 - value against another text field value
63:48 - we'll use this delegate to store a
63:49 - method reference to a method that
63:51 - provides functionality for ensuring that
63:54 - the user re-enters the user's chosen
63:56 - password so that it matches the original
63:58 - entry for the password field during the
64:01 - registration process
64:04 - let's create private static member
64:06 - variables for each of these delegates
64:20 - let's create the method implementations
64:23 - for each of these delegates namely
64:25 - required field valid
64:32 - string field length valid
64:46 - date field valid
64:57 - field pattern valid
65:15 - and field comparison valid
65:24 - so to expose our delegate objects to
65:26 - calling code let's create a public
65:28 - static read-only property for each
65:30 - related delegate
65:32 - with each of these public properties we
65:34 - are creating a new delegate object of
65:37 - the appropriate delegate type and
65:38 - passing in the appropriate method name
65:40 - into the delegate types Constructor
65:45 - we are using a Singleton pattern to
65:47 - ensure that only one instance of each of
65:50 - these delegate objects can be created
66:07 - foreign
66:43 - so let's create a class and name it
66:45 - common regular expression validation
66:47 - patterns
66:49 - I've already sourced four common regular
66:51 - expression patterns from the following
66:53 - useful website that can be found at this
66:55 - URL
66:57 - I'll also include a link to this URL
66:59 - Below in the description
67:01 - I've copied the relevant regular
67:03 - Expressions to notepad I'll copy and
67:05 - paste these regular expression patterns
67:07 - from notepad into the common regular
67:09 - expression validation patterns class
67:14 - as stated earlier the code for this
67:16 - tutorial can be downloaded from GitHub
67:18 - please see a link to the appropriate
67:20 - repository Below in the description
67:23 - note that you are able to copy and paste
67:25 - these regular expression patterns into
67:27 - your code from the GitHub webpage at
67:29 - this URL a link to this webpage has been
67:33 - included Below in the description
67:39 - okay so let's create a directory named
67:41 - field validators this directory will
67:44 - contain field validator classes each
67:46 - validator class will correspond to a
67:49 - particular View
67:50 - we'll create the view classes in a bit
67:53 - let's first create an interface named I
67:56 - field validator
67:58 - let's make this a public interface
68:00 - So within the club membership
68:03 - application.fieldvalidators namespace
68:04 - let's create a delegate definition named
68:07 - field validator Dell
68:10 - this is a very important delegate as it
68:13 - can reference a method that validates
68:15 - fields for any form
68:17 - so for example we are going to reference
68:19 - a method to validate our user
68:22 - registration form Fields but say for
68:24 - example we needed to capture banking
68:26 - information we could create a custom
68:28 - validator class for this purpose
68:31 - and within a newly created banking form
68:33 - view class we could reference an
68:36 - appropriate validator object derived
68:38 - from the validator class and use this
68:40 - validator object to validate the banking
68:43 - related fields so we will be using this
68:46 - delegate definition to create a delegate
68:48 - that references a method for validating
68:51 - Fields presented to the user in our user
68:53 - registration view class
68:55 - so the parameters defined for this
68:57 - delegate are field index defined as an
69:00 - integer for the purpose of referencing a
69:02 - field value within an array of fields
69:05 - field value as string this parameter
69:09 - will be past the field value to be
69:11 - validated
69:13 - field array this is an array that will
69:16 - store all validated fields for a
69:18 - particular View
69:20 - and lastly a parameter named field
69:22 - invalid message
69:24 - and preceding this parameters definition
69:26 - is the out keyword
69:28 - which allows its value to be outputted
69:31 - to calling code so for field is invalid
69:34 - a relevant message created within the
69:36 - relevant referenced method can be
69:39 - outputted to the calling code
69:41 - which can then for example output the
69:43 - message to the user
69:46 - so let's create a method signature for a
69:49 - method named initialize validator
69:51 - delegates
69:52 - a method that implements code for this
69:55 - method definition can be used to
69:57 - initialize the validation delegates that
70:00 - will be used for a particular View
70:02 - then field array provides a definition
70:04 - for a read-only property that stores a
70:06 - reference to an array of field values
70:09 - and lastly validated Dell provides a
70:12 - definition for a read-only property that
70:14 - stores a delegate object that references
70:16 - a method responsible for validating the
70:18 - fields in a particular View
70:20 - let's create a class named field
70:22 - constants we are only going to store one
70:25 - enum in this class which will be used to
70:28 - index an array which contains field
70:30 - values for the user registration form
70:34 - using enum list item values to index our
70:37 - array instead of integer values makes
70:40 - our code more readable simply because at
70:42 - a glance we can see exactly where our
70:44 - field resides in the relevant array so
70:47 - let's create an enum named user
70:49 - registration field
70:50 - and let's create an enum list item value
70:53 - for each of the fields in our user
70:55 - registration form
71:04 - great
71:07 - so let's create a class that implements
71:09 - the I field validator interface
71:12 - so this class is named user registration
71:14 - validator
71:16 - let's define four constants at the top
71:18 - of the class these will be used a bit
71:20 - later to validate our first name and
71:22 - last name field lengths
71:32 - let's create a delegate that will be
71:34 - used to determine if an email address
71:37 - already exists in the system if an email
71:40 - address already exists the user's entry
71:43 - will be deemed as invalid
71:46 - let's create a private member variable
71:48 - of the field validator Dell type this
71:52 - delegate will store a reference to a
71:53 - method responsible for validating the
71:56 - user registration fields
71:58 - let's define a private member variable
72:00 - for each of our common validator
72:02 - delegates required valid Dell string
72:05 - length valid Dell
72:08 - date valid Dell patent match valid dull
72:10 - and compare field valid Dell
72:13 - let's create a private member variable
72:15 - to store the delegate object that will
72:17 - reference a method responsible for
72:19 - checking if a user email address input
72:22 - already exists in the system
72:24 - let's create a private member variable
72:26 - for storing an array of valid field
72:29 - values entered by the user
72:33 - and let's create a property named field
72:36 - array that will create a field array
72:38 - object if one has not yet been created
72:41 - note how we are using the length
72:43 - property of the enum.getvalues method to
72:46 - make appropriate space Provisions for
72:48 - our field array array
72:50 - each enum list item in our user
72:53 - registration field enum must have an
72:55 - index counterpart in the field array
72:58 - array
73:04 - yeah
73:06 - let's expose the validator Dell delegate
73:08 - through a public read-only property
73:11 - and one thing I've forgotten to do is
73:13 - indicate that this class implements the
73:15 - I field validator interface so let's do
73:18 - this
73:25 - and now let's initialize the appropriate
73:27 - validator delegates within the
73:30 - initialize validator delegates method
73:32 - here we are referencing the delegates
73:34 - already wired up to their appropriate
73:36 - methods created for us in the common
73:39 - field validator functions class which
73:42 - resides in the field validator API
73:44 - project
73:46 - foreign
73:51 - let's create a private method that will
73:54 - be responsible for validating each of
73:56 - the fields used to register a club
73:58 - member this method will be referenced by
74:00 - the field validator Dell delegate
74:03 - let's create the basic structure for the
74:06 - valid field method
74:18 - let's wire up the valid field method to
74:21 - the field validator Dell delegate within
74:23 - the initialize validator delegates
74:25 - method
74:27 - okay let's implement the code for the
74:29 - valid field method let's first convert
74:32 - the field index parameter to the user
74:35 - registration field enum for the purpose
74:37 - of creating more readable code
74:45 - so the first field we wish to validate
74:47 - is the email address field
74:50 - so let's write code to ensure that text
74:52 - has been entered into the email address
74:54 - field by calling the required valid Dell
74:57 - Delegate for this purpose
75:00 - so if the text has not been entered for
75:02 - this field we wish to Output an
75:04 - appropriate message
75:06 - to do this we can set the field and
75:07 - valid message parameter to an
75:09 - appropriate message
75:11 - note that the field and valid message
75:13 - parameter contains the out keyword in
75:15 - its definition which means its value can
75:18 - be outputted to the calling code
75:20 - so we also want to ensure that the
75:22 - user's email address input conforms to
75:25 - an appropriate regular expression
75:26 - pattern used for validating email
75:28 - addresses
75:29 - we can do this by using the pattern
75:32 - match validol delegate
75:34 - and if the user has entered an email
75:36 - address but it is not in a valid format
75:39 - we want to set the field invalid message
75:41 - output parameter to an appropriate
75:43 - message
75:49 - so for the first name field we must
75:51 - include validation so that the first
75:53 - name field can only contain a text value
75:56 - with a length that is between 2 and 100
75:58 - characters
76:04 - the last name field must also only
76:06 - contain a text value that has a
76:09 - character length between 2 and 100.
76:12 - foreign
76:26 - the password field must contain a value
76:29 - that conforms to the following rules it
76:32 - must contain at least one small case
76:34 - letter one capital letter one special
76:36 - character and must be between 6 to 10
76:39 - characters in length
76:42 - an appropriate regular expression
76:44 - pattern is used to validate the password
76:47 - the password compare field must contain
76:49 - a value
76:51 - and its text value must be an exact
76:53 - match to the password field
77:17 - date of birth must contain a value and
77:20 - be a valid date
77:36 - the phone number field must contain a
77:39 - value that conforms to a pattern defined
77:41 - for a valid UK phone number
78:11 - address first line must contain a value
78:13 - address second line must also contain a
78:16 - value
78:19 - and address City must also contain a
78:22 - value
78:23 - postcode must contain a value that
78:25 - conforms to a pattern defined for a
78:27 - valid UK postcode
78:33 - foreign
78:52 - and you can see that the method returns
78:54 - a Boolean expression if the field
78:56 - invalid message output parameter has not
78:59 - been set during the validation of a
79:01 - particular field
79:02 - this means that the field is valid and a
79:05 - Boolean value of true will be returned
79:08 - to the calling code
79:10 - however if the field and valid message
79:11 - output parameter has been set to one of
79:14 - the validation messages
79:16 - the field valid method returns false
79:18 - because the field value inputted by the
79:21 - user has been deemed to be invalid by
79:24 - our field valid method
79:27 - I know there is quite a lot of detail in
79:29 - that method please feel free to copy the
79:32 - code for this method which can be found
79:34 - at the GitHub webpage at this location
79:49 - okay so let's go back to the data folder
79:52 - let's add an interface named I register
79:55 - let's add a method definition named
79:57 - register that contains a string array
79:59 - parameter
80:02 - the method that implements code for this
80:04 - method definition will accept a string
80:06 - array argument which will contain valid
80:09 - field data inputted by the user and this
80:12 - field data will be saved to the users
80:14 - table in our sqlite database
80:18 - this method definition must also return
80:20 - a Boolean value
80:21 - then let's create a method definition
80:23 - for a method that will be referenced by
80:26 - a validation delegate the delegate will
80:29 - be executed in order to check if the
80:31 - email address entered by a user already
80:34 - exists in the database table named users
80:38 - this method definition provides a
80:40 - definition for a method that contains a
80:42 - string parameter and returns a Boolean
80:44 - value
80:46 - right let's create another interface and
80:48 - name this interface I login
80:50 - this interface defines one method
80:52 - definition for a method that accepts two
80:55 - string arguments and returns an object
80:57 - of type user
81:13 - let's add a class named register user
81:16 - and indicate that this class implements
81:18 - the I register interface
81:20 - so let's provide a code implementation
81:22 - for the register method let's
81:24 - instantiate a DB context object from the
81:27 - club membership DB context class with
81:29 - any using block
81:32 - let's create a user object and set its
81:35 - properties so we can save its values to
81:38 - the user's database table
81:45 - okay there's a problem here
81:48 - I forgot to include the email address
81:50 - field in the user model
81:52 - so what we need to do is first update
81:54 - the user model
82:08 - then we need to add a migration
82:21 - thank you
82:27 - and update the database
82:35 - let's use the SQL browser client
82:37 - application to see if our email address
82:40 - column has successfully been added to
82:42 - the user's database table
82:54 - and it has great
82:57 - let's add a directive to the club
82:58 - membership application dot field
83:00 - validators namespace at the top of the
83:03 - code so that we can access the user
83:05 - registration field enum
83:09 - and we can use the user registration
83:12 - field enum to index the field array
83:14 - passed into the register method
83:18 - using an enum for the index provides
83:21 - better readability of our code
83:24 - we must ensure that we cast the enum
83:27 - values to integer values when using
83:29 - these values to index items within the
83:32 - field array
83:34 - foreign
83:58 - once we have finished creating the user
84:00 - object we can save it to the users
84:02 - database table
84:06 - note that we simply pass the user object
84:09 - as an argument to the add method to add
84:12 - the data stored in the user object to
84:14 - the user's database table and to confirm
84:17 - our intention we must call the save
84:19 - changes method on the DB context object
84:22 - to save the data stored in the user
84:25 - object to the user's database table
84:30 - let's now Implement code for the email
84:32 - exists method
84:47 - foreign
84:52 - we can use the any extension method
84:54 - provided in the system.link namespace
84:58 - to check if the email address text value
85:00 - passed into the method already exists
85:03 - within the user's database table
85:06 - if it does this method will return true
85:08 - if it doesn't exist this method will
85:11 - return false
85:16 - and we can now go back to the user
85:18 - registration validator class and wire up
85:20 - the email exists method to the email
85:23 - exists Dell delegate
85:28 - first let's make sure that the register
85:30 - object derived from the register class
85:32 - that we just created is passed into the
85:35 - user registration validator classes
85:37 - Constructor
85:39 - then let's wire up the email exists
85:41 - method provided in the register class to
85:44 - the email exists delegate within the
85:46 - initialize validator delegates method
85:49 - we can then implement the appropriate
85:51 - validation code in the field valid
85:53 - method to check if the inputted email
85:56 - address already exists within the user's
85:59 - database table
86:03 - foreign
86:17 - classes let's create two ancillary
86:19 - classes
86:21 - let's first create a class named common
86:22 - output text
86:24 - let's create and Implement three
86:26 - read-only static properties
86:28 - one for returning the main application
86:30 - heading one for returning a heading for
86:33 - the user registration View and one for
86:35 - returning a heading for the user login
86:37 - View
86:39 - so let's create three corresponding
86:40 - methods that write these headings to the
86:42 - console screen write main heading
86:56 - right login heading
87:02 - and write registration heading
87:04 - let's create another class and let's
87:07 - name this class common output format
87:19 - let's create an enum named Font theme
87:22 - with three enamelist item values namely
87:25 - default danger and success
87:29 - let's create a method named change font
87:31 - color that contains a parameter of type
87:34 - font theme
87:35 - so if the font theme is equal to Danger
87:37 - let's make the output font color red
87:41 - and let's make the foreground font color
87:43 - white
87:44 - if the font theme is equal to success
87:46 - let's make the background color green
87:49 - let's make the foreground color white
87:52 - else if the font theme is equal to
87:54 - default let's reset our console screen
87:56 - to its default color settings
87:59 - right let's create our view classes
88:02 - let's create a folder named views
88:05 - within the views folder let's create an
88:07 - interface named I view
88:10 - let's make this a public interface
88:13 - let's create a method definition named
88:15 - run view which contains no parameters
88:18 - and does not return a value
88:21 - let's create a property definition of
88:23 - type I field validator note that each
88:26 - view can have zero or one field validate
88:28 - to objects associated with it
88:30 - if for example the relevant view does
88:33 - not contain input fields and therefore
88:34 - does not need a field validator class
88:36 - the appropriate property will be set to
88:39 - null
88:40 - so let's add a new class name to user
88:43 - registration view let's add two private
88:46 - member variables one of type I field
88:49 - validator the other of type I register
88:52 - let's indicate that this class
88:53 - implements the iview interface
88:56 - let's ensure that the Field validator
88:58 - property Returns the private member
89:00 - variables value which is of the same
89:03 - type
89:14 - thank you
89:16 - let's create a Constructor this
89:18 - Constructor contains two parameters one
89:20 - of type I register and the other of type
89:23 - I field validator
89:26 - let's appropriately assign our two
89:28 - private member variables the object
89:31 - values
89:32 - that will be injected into the user
89:34 - registration classes Constructor when
89:36 - the user registration class is
89:38 - instantiated into an object at runtime
89:42 - let's create a private method named get
89:44 - input from user
89:47 - this method contains two parameters one
89:49 - parameter of the user registration field
89:51 - enum type and the other of the string
89:54 - type
89:56 - foreign
89:57 - let's create a local string variable
89:59 - named field vowel this string variable
90:02 - will store the user's input
90:04 - let's create a do Loop
90:07 - the doolib's condition returns true if
90:09 - the user's input is deemed invalid by
90:12 - the field valid method
90:14 - so when the field valid method returns
90:17 - false within the while condition the
90:19 - while condition returns true which means
90:21 - the do Loop will perform a subsequent
90:23 - iteration
90:25 - the effect of this is an appropriate
90:27 - message will be outputted to the user
90:29 - instructing the user that the input just
90:32 - entered is invalid the user will then be
90:34 - prompted once again to enter a value for
90:36 - the relevant field
90:38 - so the user will be prompted for a
90:40 - particular Field's value until the
90:42 - user's input is deemed valid by the
90:44 - validation code
90:46 - let's write code within the do Loop to
90:48 - prompt the user for the user's input for
90:50 - the appropriate field
90:52 - let's assign the user's input to the
90:55 - field valve string variable
90:58 - in the field valid method let's call the
91:01 - validator Dell delegate and pass an
91:03 - appropriate arguments
91:05 - let's write code that will output text
91:08 - in an appropriate format when the user
91:11 - input is deemed as invalid
91:22 - let's write code in the run view method
91:24 - that will assign the user's input to a
91:27 - space within the field array array if
91:30 - the user's input is valid
92:39 - let's write a private method that will
92:41 - save the user's registration information
92:43 - to the user's database table in our
92:45 - sqlite database let's call the register
92:48 - user private method from the run view
92:51 - method
92:53 - okay so let's create the login View
92:57 - let's add a class to the Views folder
92:59 - named user login View
93:02 - let's write code to indicate that we
93:04 - want the user login view to implement
93:06 - the iview interface
93:09 - let's Auto generate the iview members
93:11 - that we must implement
93:15 - let's set the Field validator property
93:18 - to null because in this code example we
93:21 - are not going to include validation on
93:23 - the login fields
93:26 - we could add a custom validator class
93:28 - and Implement validation code for the
93:30 - fields of this login view if we chose to
93:33 - do so but in the interests of time let's
93:36 - omit this functionality
93:37 - let's create a Constructor that contains
93:39 - a parameter of type I login
93:42 - let's create a private member variable
93:44 - of the type I login
93:47 - let's assign the object argument that
93:49 - will be injected into the user login
93:51 - view classes constructed during the
93:54 - instantiation of the user login view
93:56 - class to this private member variable
94:00 - So within the run view method let's
94:02 - first write the application heading to
94:04 - the screen and let's then write the
94:06 - login heading to the screen so let's
94:08 - make sure we are writing the main
94:09 - heading to the screen within the run
94:11 - view method of the user registration
94:13 - view class
94:17 - let's go back to the user login view
94:19 - class
94:20 - let's write code to prompt the user for
94:22 - the user's email address let's assign
94:24 - the user's input to a local string
94:26 - variable
94:27 - let's write code to prompt the user for
94:29 - the user's password
94:31 - and let's assign the user's input to a
94:33 - local string variable let's call the
94:35 - login method on the underscore login
94:37 - user object and pass in the two local
94:40 - variables containing the user's input
94:42 - into the login method
94:45 - and this method returns a user object if
94:49 - the user is authenticated
94:51 - so we need to check if the user object
94:53 - is not null which means the login has
94:56 - been successful
94:57 - and we'll write a to-do comment for now
95:00 - to indicate that we wish to implement
95:02 - code here to run the welcome view when
95:05 - the login is successful
95:07 - we'll create the welcome view class in a
95:09 - bit then replace the to-do comment with
95:12 - the code to run the welcome view else if
95:15 - the login is not successful we'll simply
95:17 - clear the screen and output a message
95:19 - stating that the user's entered
95:21 - credentials do not match any of the
95:23 - system's records
95:28 - so let's create the welcome View
95:48 - in the run view method of the user
95:50 - welcome view class we are simply
95:52 - outputting a message welcoming the user
95:54 - to the Cycling Club
96:04 - and let's replace the to do comment in
96:07 - the run view method in the login view
96:09 - class with code that creates a user
96:12 - welcome view object that invokes the run
96:15 - view method which displays a welcoming
96:17 - message to the user on the console
96:18 - screen
96:21 - so let's create the main view class
96:33 - we'll set the field validator to null
96:36 - because this view doesn't have any
96:38 - fields that require validation let's
96:41 - Implement code in the run view method
96:44 - let's write the application heading to
96:45 - the console screen
96:47 - let's prompt the user to press either
96:49 - the L key to log in or the r key to
96:53 - register
96:54 - if the user presses the L key
96:57 - the user will be presented with the
96:59 - login screen
97:00 - if the user presses the r key the user
97:03 - will be presented with the registration
97:05 - screen
97:06 - so let's use the console.read key method
97:09 - to capture the user's key press
97:12 - let's create an if statement structure
97:14 - so that the appropriate functionality
97:16 - can be executed depending on which key
97:18 - the user presses and let's simply write
97:21 - goodbye to the screen when the user
97:23 - presses a key that isn't L or R let's
97:26 - create a Constructor that contains two
97:28 - parameters
97:33 - and let's create two corresponding
97:35 - member variables
97:36 - that will store the appropriate objects
97:38 - that will be passed into this
97:40 - Constructor at runtime
97:43 - let's create a private method that will
97:46 - run the user registration View
97:48 - let's implement the code for this method
97:50 - which simply invokes the run view method
97:52 - on the user registration view object
97:55 - which is of type I view
97:58 - and let's also write a private method
98:00 - that invokes the user login View
98:03 - let's go back to the if statement
98:05 - and if the user has pressed the r key we
98:09 - want to present the user registration
98:10 - View and once the user is successfully
98:13 - registered we want to present the user
98:15 - login View
98:16 - if the user presses the L key the user
98:19 - is presented with the login screen
98:22 - so now we want to abstract the creation
98:24 - of the main view object
98:27 - let's create a class named Factory
98:34 - let's make it a public static class
98:39 - let's create a public static method
98:41 - named get main view object that returns
98:43 - an object of the iview type
98:47 - let's create a login object this object
98:50 - will be used to authenticate the user
98:53 - but it looks like I forgot to implement
98:54 - the authentication logic
98:57 - so let's create a class within the data
98:59 - folder and name it log in user
99:02 - we are going to need two namespace
99:04 - directives in this class
99:06 - so let's create a namespace directive
99:08 - for the club membership dot models
99:09 - namespace and let's also create a
99:12 - namespace directive for the system.link
99:14 - namespace
99:16 - this class must implement the I login
99:18 - interface and let's Auto generate the
99:20 - members of the ilogin interface that
99:23 - must be implemented
99:24 - so the I login interface only contains
99:27 - one method a method named login
99:30 - it contains two parameters one is a
99:33 - string parameter for the user's email
99:35 - address and the other is a string
99:37 - parameter for the user's password
99:40 - and now we can simply write code that
99:42 - compares the user's email address and
99:44 - password with the records stored in the
99:46 - user's database table in our sqlite
99:48 - database if the user is registered with
99:51 - the application the first or default
99:53 - extension method returns a user object
99:56 - if the user is not registered with the
99:58 - application null is returned
100:07 - so let's go back to the factory class
100:09 - and finish creating code that abstracts
100:11 - the construction of the main view object
100:14 - so in order to create the main view
100:16 - object we must create an object derived
100:19 - from the user login view class and an
100:21 - object derived from the user
100:23 - registration view class
100:26 - in order to create an object derived
100:28 - from the user login view class we must
100:30 - first create an object of the I login
100:33 - type
100:34 - which will be injected into the
100:36 - Constructor of the user login view class
100:38 - when the user log in view class is
100:41 - instantiated as an object
100:43 - in order to create an object derived
100:45 - from the user registration view class we
100:47 - need to First create an object of type I
100:50 - register
100:52 - the user registration view classes
100:54 - Constructor also contains a parameter
100:56 - for a custom field validator object so
100:59 - let's create an object of Type R field
101:01 - validator that derives from the user
101:04 - registration validator class
101:06 - and in order to initialize the
101:08 - validation delegates we must first call
101:10 - the initialize validator delegates
101:12 - method on the object derived from the
101:15 - user registration validator class
101:19 - so we can now create an object derived
101:22 - from the user registration view class in
101:25 - order to create the object successfully
101:27 - we must inject an object derived from
101:29 - the register user class and an object
101:31 - derived from the user registration
101:32 - validator class into the user
101:35 - registration view classes Constructor we
101:38 - can now also create an object derived
101:40 - from the user login view class and
101:42 - inject an object derived from the login
101:44 - user class into the user login view
101:47 - classes Constructor
101:49 - we are now able to inject the object
101:51 - derived from the user registration view
101:54 - class and the object derived from the
101:57 - user login view class into the main view
102:00 - classes Constructor when constructing
102:02 - the object derived from the main view
102:04 - class
102:06 - then we can write code to return this
102:08 - object from the get main view object
102:10 - method so notice something very
102:12 - important that is going on here when we
102:14 - construct our objects
102:16 - all our classes Constructor parameters
102:19 - are not concrete types
102:22 - they are interface types
102:24 - we are adhering to the dependency
102:26 - inversion principle which is represented
102:29 - by the last letter of the solid acronym
102:32 - the dependency and version principle
102:34 - states that classes should never depend
102:36 - on concretions but rather should only
102:39 - depend on abstractions
102:41 - so in this method we have implemented
102:43 - very basic dependency injection
102:45 - functionality
102:46 - so when the main view object is created
102:49 - using the get main view object method an
102:51 - object derived from the user login view
102:53 - class and an object derived from the
102:55 - user registration view class is
102:58 - automatically injected into the main
103:00 - view classes Constructor the main view
103:02 - classes Constructor contains two
103:04 - parameters that are of the iview type
103:08 - the user registration view class
103:09 - implements the iview interface and the
103:12 - user login view class also implements
103:14 - the iview interface
103:16 - so now the way we have designed this
103:18 - application should allow for the calling
103:19 - client code to be rather simple
103:22 - so in the main method we can simply get
103:25 - an object derived from the main view
103:27 - class by calling the factory classes get
103:29 - main view object static method
103:33 - see how clean the client code is
103:36 - this is because we have abstracted away
103:38 - all the complexities of constructing an
103:40 - object derived from the main view class
103:44 - then all we need to do is invoke the
103:46 - object derived from the main view
103:47 - classes run view method to run this
103:50 - application
103:52 - and that is our application pretty much
103:54 - written
103:55 - but inevitably there will be bugs Let's
103:58 - test the code
104:06 - let's press the r key so that we are
104:08 - presented with the user registration
104:10 - view where we'll register a user's
104:12 - information
104:13 - so let's leave the email address field
104:16 - blank and press enter
104:18 - okay and the required field validation
104:20 - message should have been presented
104:22 - so why has this not worked
104:26 - okay so in the field valid method within
104:29 - the user registration view class I
104:31 - forgot to include a not operator in the
104:33 - if condition where the appropriate field
104:35 - validation delegate isn't worked to test
104:38 - if the users input is valid
104:41 - so we want to Output an appropriate
104:42 - message to the user when a field is
104:44 - deemed as invalid and subsequently
104:46 - prompt the user to try again
104:49 - Let's test the fix and this time step
104:51 - through the codes to make sure that the
104:53 - code is doing what we expected to do
104:55 - so let's once again leave the email
104:57 - field blank
105:03 - great and this time the code that
105:05 - outputs an appropriate invalid field
105:07 - message is run
105:09 - and what happens if we enter a valid
105:11 - field value on our second attempt at
105:13 - entering an email address
105:15 - but this time we enter an invalid email
105:18 - address format
105:31 - great that is working as expected and
105:33 - now let's enter a correct email address
105:43 - and we have another bug
105:45 - this email address has not been saved to
105:48 - the system so why is our application
105:50 - behaving is there a record with this
105:53 - email address already exists in the
105:55 - system right so this time it is because
105:57 - I included a not operator where I should
105:59 - not have done so let's remove the not
106:02 - operator because we want a message to be
106:04 - displayed when an email address already
106:06 - exists in the system
106:09 - Let's test the code again
106:24 - great that is working as expected
106:27 - so I don't like the formatting of the
106:29 - prompts at the moment I want the user to
106:31 - enter the user's information on the same
106:33 - line as the prompt text
106:36 - so let's make the appropriate fixes
106:38 - let's use the console.write method
106:40 - rather than the console.writeline method
106:42 - to prompt the user for the user's input
106:44 - and let's append a colon followed by a
106:47 - space to The Prompt text for each of the
106:50 - users can put prompts
107:04 - okay so let's test the code let's enter
107:07 - a valid email address
107:10 - let's enter a valid first name
107:13 - and let's enter an invalid last name and
107:16 - that is working as expected we have
107:18 - included validation code whereby the
107:21 - first name and last name fields must
107:23 - contain a character length between 2 and
107:26 - 100.
107:31 - this time let's enter a valid last name
107:34 - let's enter a valid password and for the
107:37 - field where we have to re-enter our
107:39 - password let's enter text that does not
107:41 - match the password we entered
107:43 - great so the comparison Fields
107:45 - validation functionality is working
107:48 - and this time let's re-enter our
107:49 - password correctly let's enter a valid
107:52 - date for the date of birth field
107:54 - let's make up an address for the first
107:56 - line of our address
107:58 - and let's leave the second line of our
108:00 - address blank
108:03 - great so our validation message is
108:05 - correctly advising that we must enter a
108:08 - second line of our address
108:11 - so on the second try let's enter a made
108:13 - up second line for our address let's
108:16 - enter a valid City
108:24 - and let's enter a postcode in a correct
108:27 - UK postcode format
108:29 - great so we have successfully registered
108:31 - Carl Smith as a member of the Cycling
108:33 - Club
108:34 - so let's press any key to continue to
108:37 - the login screen
108:38 - and let's enter our credentials
108:45 - hi Carl welcome to the Cycling Club
108:47 - great so we have successfully been
108:49 - authenticated
108:51 - but the welcome view should be displayed
108:53 - on its own screen so let's fix this
108:56 - in the run view method of the user
108:58 - welcome view class let's clear the
109:00 - console screen before displaying the
109:02 - welcome message
109:08 - so I've noticed that we are not being
109:10 - prompted for a phone number so let's
109:12 - navigate to the run view method in the
109:15 - user registration view class and ensure
109:17 - that the appropriate functionality for
109:19 - the phone number field is added
109:21 - okay let's test the code
109:23 - and we can use the made updates of Carl
109:25 - Smith again because I've removed the
109:28 - record we added earlier from the user's
109:30 - database table because an old value had
109:33 - been added into the phone number field
109:36 - so let's enter some made up but valid
109:38 - data into the user registration form
109:57 - and let's open our sqlite database named
109:59 - Club membershipdb.db in the sqlite
110:02 - browser client application
110:04 - we can do this by dragging and dropping
110:07 - the data file onto the sqlite browser
110:10 - applications user interface like this
110:13 - and we can now run a SQL query through
110:16 - the sqlite browser client application to
110:18 - check if the record for Carl Smith has
110:20 - been added to the users table
110:23 - and has the phone number been added
110:25 - correctly this time yes it has great
110:28 - let's enter another record Let's test
110:31 - that we are now not able to enter Carl
110:33 - Smith's email address into the email
110:35 - field
110:36 - great let's enter information for a
110:38 - made-up character named Ethel Jones
110:41 - and we can test some of the field
110:42 - validation functionality along the way
110:48 - [Music]
110:54 - okay let's log in as Ethel Jones
111:02 - excellent
111:06 - let's log in as Carl Smith
111:11 - great
111:35 - [Music]
111:40 - hi and welcome this tutorial is being
111:43 - created to help with your understanding
111:46 - of covariance and contravariance when
111:48 - using delegates in C sharp in the first
111:51 - part of this tutorial on delegates I've
111:53 - mentioned that the return type and
111:55 - parameter types of the method referenced
111:57 - by a delegate object must match the
112:00 - return type and parameter types defined
112:03 - in the relevant delegates definition but
112:05 - I also mentioned that the return type
112:07 - and parameter types of the relevant
112:09 - method definition don't have to match
112:11 - with the relevant return type and
112:13 - parameter types delegate definition
112:15 - exactly
112:16 - so what does this mean
112:19 - the c-sharp language allows for the
112:21 - developer to have a little bit of design
112:23 - flexibility when it comes to a
112:25 - delegate's compatibility with a method
112:29 - covariance and contravariance provide
112:32 - flexibility when matching a delegate
112:34 - definition with a method definition
112:37 - covariance permits a method to have a
112:40 - return type that is more derived than
112:42 - that defined and the relevant delegate
112:45 - if you are unfamiliar with what is meant
112:47 - for a class to be more derived or less
112:49 - derived than another class that is a
112:52 - member of the same inheritance hierarchy
112:54 - please check out two tutorials which
112:56 - were provided by this channel as part of
112:58 - a c-sharp for beginners course one on
113:01 - c-sharp inheritance and the other on
113:03 - c-sharp polymorphism
113:05 - a link to these tutorials can be
113:07 - accessed from the cards in the right
113:09 - hand corner of your screen and links to
113:11 - these tutorials have also been included
113:13 - Below in the description
113:15 - Contra variants permits a method that is
113:18 - parameter types that are less derived
113:20 - than those in the relevant delegates
113:22 - type
113:25 - if you haven't yet subscribed please
113:27 - consider subscribing and please ring the
113:29 - bell so that you can be notified of
113:30 - content on advanced c-sharp concepts and
113:34 - much more
113:41 - let's look at a code example where we
113:44 - can demonstrate how covariance works
113:45 - when using delegates in c-sharp
113:48 - this example demonstrates how a delegate
113:50 - object can reference a method that has a
113:53 - return type that is derived from the
113:55 - return type defined and the relevant
113:57 - delegates definition
114:00 - so I'm going to create two Factory
114:02 - methods by Factory method Amino method
114:05 - implemented for the abstraction of
114:07 - constructing a specific object and
114:10 - returning the relevant object to calling
114:12 - code
114:13 - the first method will return an object
114:15 - of type ice car
114:16 - which is a user-defined class that will
114:19 - create representing a blueprint for an
114:21 - object that can store information for an
114:23 - ice car
114:28 - the second method will return an object
114:30 - of type EV car which is another
114:33 - user-defined class that we'll create
114:35 - representing a blueprint for an object
114:37 - that can store information for an
114:40 - electric car
114:42 - both of these classes will inherit from
114:44 - a base abstract class named car
114:48 - we are going to create a delegate that
114:50 - defines a method definition that
114:52 - contains an ID parameter of type int and
114:55 - a name parameter of type string
114:58 - the delegate type will return the car
115:00 - type which is the base abstract class
115:03 - from which the class named ice car and a
115:06 - class named EV car will inherit
115:08 - this delegate type can be used to create
115:11 - an object that can store reference to a
115:14 - method that returns a type that is
115:16 - derived from the car base type this is
115:19 - at the heart of what covariances
115:21 - regarding delegates
115:23 - even though the return types of the
115:25 - delegate and the method it references
115:26 - are not an exact match because the
115:29 - return type of the delegate is the base
115:31 - class for the return type of the method
115:33 - the c-sharp compiler allows the delegate
115:36 - to reference the method
115:38 - let's create a.net core console
115:40 - application I'll name the project and
115:42 - solution covariance and contravariance
115:45 - delegate example
115:56 - let's create an abstract class named car
115:59 - let's add two auto-implemented
116:02 - properties to the car user-defined class
116:05 - one named ID of the integer data type
116:08 - and the other named name of the string
116:11 - dates type
116:12 - let's add a virtual method that doesn't
116:14 - contain any parameters and returns a
116:17 - value of type string let's name this
116:20 - method get car details
116:22 - this method is very basic and returns an
116:25 - interpolated string value containing the
116:28 - values for the ID and the name
116:30 - properties
116:31 - so let's create our first class that
116:33 - inherits from the car abstract class
116:35 - let's name this class ice car
116:39 - and we are going to keep this example
116:41 - very basic so that we can focus our
116:43 - attention on the topic of this tutorial
116:46 - namely applying covariance and
116:48 - contravariance when using delegates and
116:50 - C sharp
116:53 - so let's override the get card details
116:56 - method
116:57 - this method will simply return an
116:59 - interpolated string value which will
117:01 - contain a value returned from its base
117:04 - method counterpart followed by the text
117:06 - which will contain a hyphen followed by
117:08 - the text internal combustion engine ice
117:12 - and let's create a class that is very
117:14 - similar to the ice car class but this
117:17 - class will serve as a blueprint for
117:18 - objects that store information about an
117:22 - electric car so let's duplicate the ice
117:25 - car class and change it so that it is
117:28 - appropriate for our EV car class
117:31 - so this class is named EV car
117:33 - so the get card details method in the EV
117:36 - car class will return an interpolated
117:38 - string value containing a value returned
117:40 - by its base method counterpart which
117:43 - will contain the relevant car objects ID
117:45 - and name property values followed by the
117:48 - string literal hyphen Electric
117:52 - so now let's create a factory class
117:54 - let's name it car factory and let's make
117:57 - this class a static class
117:59 - and let's create a static method named
118:02 - return ice car that returns an object of
118:05 - type ice car
118:06 - this method contains two parameters one
118:09 - of type int and the other of type string
118:12 - and the code for this method simply
118:14 - returns an object derived from the ice
118:16 - car type to the calling code
118:19 - unless creates another method which is
118:21 - almost identical to the return ice car
118:23 - method the only difference being that
118:26 - instead of returning an object derived
118:28 - from the ice card type it returns an
118:31 - object derived from the EV car type
118:35 - so the question is can we reference
118:38 - either of these two methods from a
118:41 - delegate object where its delegate
118:43 - definition is an almost exact match of
118:46 - the return ice car method definition and
118:48 - the return EV car method definition the
118:51 - only difference being that the delegate
118:53 - will Define a method definition that
118:55 - Returns the car type
118:58 - I.E a less derived type
119:02 - so let's create a delegate named car
119:05 - factory Dell
119:06 - that defines a method definition that
119:09 - contains two parameters one of type int
119:11 - and the other of type string and returns
119:14 - a value of type car
119:17 - so in the main method let's define a
119:19 - delegate named car factory Dell and
119:22 - assign it the method name of return ice
119:25 - car
119:26 - the return ice car method returns an
119:29 - object of type ice car and the delegate
119:31 - definition Returns the car type
119:35 - notice that the c-sharp compiler is not
119:38 - complaining about this because the ice
119:41 - car type derives from the car type and
119:44 - covariance is allowed in C sharp so
119:47 - let's write code to execute the delegate
119:48 - and assignee object to a variable named
119:51 - ice car
119:52 - so we'll give this car object an ID of
119:55 - one and a name of Audi R8
120:04 - let's write code to write the type of
120:06 - the object to screen
120:08 - let's write code to execute the objects
120:10 - get card details method
120:13 - to retrieve the object's available
120:14 - information and write this information
120:17 - to the screen
120:19 - and let's use the same delegate type to
120:22 - reference the return EV car method
120:26 - the EV card type is derived from the car
120:29 - type
120:30 - so because covariance is permitted in
120:33 - the c-sharp language
120:35 - the return EV car method is deemed as
120:38 - compatible with the car factory Dell
120:40 - delegate
120:47 - let's run the code
120:53 - and we have successfully demonstrated
120:55 - how covariance can work when using
120:57 - delegates in c-sharp
121:08 - so let's demonstrate how contravariance
121:11 - can work when using delegates and C
121:13 - sharp
121:15 - so to demonstrate contravariance when
121:18 - using delegates and c-sharp we are going
121:21 - to create two delegates
121:22 - both delegates will be used to reference
121:25 - a method used for logging information
121:27 - about a car
121:29 - both delegate definitions will not
121:32 - return values the first delegate
121:34 - definition contains one parameter of the
121:37 - ice car type
121:39 - the second delegate's definition
121:40 - contains one parameter of the EV card
121:43 - type
121:44 - the key to relating this example to
121:46 - contravariance is that both of these
121:48 - delegates contain one parameter that
121:51 - inherits from a car type
121:53 - note the two delegate definitions
121:55 - contain a parameter that is more derived
121:58 - than the parameter contained in the
122:00 - method that these delegates will
122:02 - reference
122:03 - the method that both of these delegates
122:05 - will reference will contain one
122:07 - parameter of type car
122:09 - the method will not return a value
122:12 - so let's first remove the lines of code
122:14 - not needed in this example demonstrating
122:16 - how contravariance Works in C sharp when
122:19 - using delegates
122:21 - let's create the first delegate and
122:23 - we'll name it log ice car details Dell
122:27 - let's create the second delegate and
122:29 - we'll name it log EV card details Dell
122:33 - and now let's create the static method
122:35 - that will be referenced by both of these
122:37 - delegates
122:38 - we'll name this method log car details
122:42 - and notice how the parameter contained
122:44 - in its method definition is of type car
122:48 - note that the delegates that will
122:50 - reference this method will contain
122:51 - parameters that inherit from the car
122:54 - type
122:56 - so let's implement the code for this
122:58 - method
122:59 - the logic for this method is that if the
123:01 - type of object passed in as an argument
123:04 - to this method is of type ice car log
123:07 - the car's object type and information to
123:10 - a text file
123:12 - we'll use the
123:14 - appdomain.currentdomain.base directory
123:15 - property to establish the path of the
123:18 - relevant text file so that it is created
123:20 - in the same path from where our code
123:22 - will execute
123:34 - else if the type of object passed into
123:36 - the log car details method is of type EV
123:40 - car log the car's object type and
123:43 - information to the console screen
123:45 - else throw an argument exception
123:49 - so let's run code to reference the log
123:51 - card details method from our log ice car
123:54 - details Dell delegate
123:58 - let's write code to execute the log ice
124:00 - card details Dell delegate
124:03 - let's write code to reference the
124:05 - logcard details method from our log EV
124:07 - car details Dell delegate
124:09 - let's write code to execute the log EV
124:12 - card details Dell delegate
124:15 - notice that even though the parameter
124:16 - contained in the log ice car details
124:19 - Dell delegate definition is not an exact
124:22 - match of the parameter contained in the
124:24 - log car details method definition the
124:27 - c-sharp compiler does not complain when
124:29 - we write code where the log ice car
124:32 - details Dell delegate references the log
124:34 - car details method
124:36 - and the same is true when we write code
124:39 - where the log EV card details Dell
124:41 - delegate object references the log car
124:44 - details method
124:46 - this is because the parameter type
124:48 - contained in the log ice car details
124:50 - delegate definition inherits from the
124:53 - parameter type contained in the logcard
124:55 - details method definition
124:57 - and the parameter type contained in the
124:59 - log EV car details Dell delegate
125:01 - definition inherits from the parameter
125:04 - type contained in the logcard details
125:06 - method definition
125:08 - this example demonstrates contravariance
125:10 - when using delegates in C sharp where a
125:13 - delegates parameter may not match
125:15 - exactly with a parameter of a method
125:17 - that the relevant delegate object
125:19 - references but if the relevant parameter
125:21 - in the relevant method definition is
125:23 - part of the same inheritance hierarchy
125:25 - and is less derived than the relevant
125:28 - delegates parameter this is allowed
125:30 - because contravariance is permitted in
125:32 - the c-sharp language
125:34 - let's run the code
125:39 - and this is an expected result
125:49 - let's see if the EV car's information
125:50 - has been logged to the relevant text
125:52 - file
125:54 - [Music]
126:00 - [Music]
126:09 - great
126:10 - [Music]
126:12 - I hope you've enjoyed this tutorial on
126:13 - understanding covariance and
126:15 - contravariance when using delegates in C
126:17 - sharp
126:26 - this is the fourth part of a video
126:28 - series on delegates
126:30 - in this video we'll look at the funk
126:33 - action and predicate built-in generic
126:35 - delegates
126:38 - so before we dive into this topic we
126:40 - must have at least a basic understanding
126:42 - of generics
126:44 - generics is a topic that we'll explore
126:46 - in detail in upcoming videos but for now
126:49 - a basic understanding will suffice
126:52 - so what is generics in c-sharp version 2
126:55 - generics was introduced
126:57 - generics makes it possible to for
127:00 - example design classes methods and
127:01 - delegates that defer the specification
127:04 - of one or more types until the class
127:06 - method or delegate is declared and
127:08 - instantiated by client code
127:30 - use generic types to maximize code reuse
127:33 - type safety and performance
127:36 - a developer can create generic
127:38 - interfaces classes methods events and
127:40 - delegates
127:42 - in this video we'll look at three types
127:44 - of generic delegates that are provided
127:46 - in the c-sharp language namely Funk
127:48 - action and predicate all of these
127:51 - generic delegates are available in the
127:53 - system namespace
127:55 - let's look at an overview of each of
127:56 - these built-in generic delegates before
127:58 - we look at basic code examples
128:00 - demonstrating their implementation
128:03 - so let's first look at funk
128:06 - in this depiction we can see the basic
128:08 - structure for a funk delegate
128:10 - the T represents a placeholder where the
128:13 - developer can pass a type parameter in
128:15 - order to strongly type the parameter
128:17 - relevance to the encapsulated method at
128:20 - compile time
128:23 - in keyword in this context means that
128:26 - the parameter type is contravariant
128:29 - we are not going to be discussing
128:30 - covariance and contravariance in this
128:33 - video because these topics were
128:35 - discussed in detail in the previous
128:36 - tutorial
128:38 - foreign
128:49 - [Music]
128:52 - there are 17 Funk delegates available in
128:55 - the system namespace
128:57 - this funk Delegate for example can be
129:00 - used to encapsulate a method that
129:01 - contains no parameters and returns a
129:03 - value
129:05 - There are 16 more Funk delegates here is
129:07 - a fund delegate that contains one
129:09 - perimeter and returns a value here's
129:12 - another Funk delegate that contains two
129:14 - parameters and returns a value
129:23 - Funk delegate definitions always return
129:25 - a value the return type is always
129:28 - defined in the last type parameter and
129:30 - the available func delegates allow for 0
129:33 - to 16 parameter type definitions
129:36 - note that the last parameter declared in
129:38 - the funk generic delegate defines the
129:41 - type of The Returned value of the method
129:43 - that the func delegate encapsulates
129:46 - the out keyword in this context means
129:48 - that the return type is covariant
129:52 - the action generic delegates allow
129:54 - developer to encapsulate a method that
129:57 - can have 0 to 16 parameters and must not
129:59 - return a value
130:01 - the predicate's generic delegate
130:03 - encapsulates a method that contains one
130:05 - parameter and returns a value that must
130:08 - be of the Boolean data type a predicate
130:11 - delegate represents a method that
130:13 - defines a set of criteria and determines
130:15 - whether the specified object meets those
130:19 - criteria
130:20 - let's look at code examples using each
130:22 - of the built-in generic delegates I.E
130:25 - func action and predicate
130:27 - at the end of the tutorial we'll look at
130:29 - an example of using an extension method
130:31 - that takes a predicate as an argument
130:34 - let's start by looking at an example
130:36 - using the funk built-in generic delegate
130:39 - let's create a.net core console project
130:42 - I'll name this project and solution func
130:45 - action predicate examples
130:46 - [Music]
130:56 - thank you
130:59 - [Music]
131:03 - let's create a public class named math
131:05 - class
131:06 - and add one method named sum the sum
131:09 - method contains two parameters of the
131:11 - int data type and returns a value of the
131:14 - end data type
131:17 - this method simply Returns the integer
131:19 - result of the sum of two integer
131:21 - arguments passed into this method
131:24 - let's instantiate the math class in the
131:27 - main method let's use the generic
131:29 - built-in Funk delegates to encapsulate
131:32 - the sum method
131:35 - altar parameters passed into the funk
131:37 - delegate are of the in-states type
131:41 - the last type parameter represents the
131:43 - return type and the first two type
131:45 - parameters represent the methods
131:47 - parameters data types
131:49 - so as you can see through the use of
131:51 - generics we have made our Funk delegate
131:54 - compatible with the sum instance method
131:57 - we have strongly typed the funk delegate
131:59 - with the in-states type for the
132:02 - parameter types and the return type
132:05 - we can therefore use the func delegate
132:07 - to encapsulate the sum method
132:09 - let's write code to execute the delegate
132:12 - and then code to write the results to
132:14 - the screen
132:22 - Let's test the code
132:27 - great
132:31 - we can replace the sum method with an
132:34 - anonymous method using the delegate
132:36 - keyword like this
132:39 - an anonymous method is as the name
132:41 - suggests a method that does not have a
132:43 - name
132:49 - Let's test the code
132:51 - great
132:56 - we can further abstract the method by
132:58 - removing the delegate keyword the return
133:00 - keyword
133:02 - the curly brackets
133:04 - and the parameter type definitions
133:09 - so here we have now reduced the
133:11 - functionality of the sum method to a
133:13 - Lambda expression
133:15 - a Lambda expression is an anonymous
133:17 - function which as discussed is a defined
133:20 - function not bound to an identifier
133:23 - we previously created the same function
133:25 - using the delegate keyword a Lambda
133:27 - expression is a shorter way of
133:29 - representing an anonymous method
133:31 - Lambda Expressions were introduced in C
133:34 - sharp version 3 along with link
133:38 - for more information on link please
133:40 - navigate to this URL
133:43 - Let's test our code
133:47 - excellent
133:49 - to further understand the func generic
133:51 - built in delegates let's create our own
133:53 - imitations of a few of the built-in Funk
133:56 - delegates let's call our delegates funk
133:59 - 2.
134:11 - foreign
134:23 - keyword with func 2 in our code
134:29 - great
134:31 - but we don't need to do this because
134:33 - appropriate generic delegates are
134:35 - already available to us in the system
134:37 - namespace
134:38 - let's create a slightly more complex
134:40 - example where our delegate encapsulates
134:42 - a Lambda expression that performs the
134:45 - functionality of adding two operands of
134:47 - the float data type together then
134:49 - multiplies the result of this operation
134:52 - by a value that is of the int data type
134:57 - great
135:04 - let's create a more practical example
135:06 - where our Lambda expression adds a bonus
135:09 - to an employee's annual salary
135:22 - foreign
136:01 - so let's look at some examples using the
136:04 - action generic built-in delegate
136:07 - so in this example let's create a Lambda
136:09 - expression that accepts fields for an
136:12 - employee record as arguments and outputs
136:15 - the employee details to the console
136:17 - screen
136:19 - note that the action delegate is used to
136:22 - encapsulate a method that does not
136:24 - return a value
136:25 - so in this example we'll output three
136:28 - fields of an employee record to the
136:30 - console screen ID first name and last
136:32 - name
136:37 - foreign
136:50 - let's add an annual salary field
136:53 - so to do this we can use a different
136:55 - action delegate to accommodate this new
136:57 - field
136:58 - let's update the Lambda expression
137:00 - accordingly
137:15 - let's add a gender field which is of the
137:17 - Char dates type and the Boolean field
137:19 - representing whether an employee is a
137:21 - manager or not a manager
137:23 - so to achieve this we need to use a
137:26 - different action delegate that can
137:27 - accommodate the two new fields
137:35 - foreign
137:45 - foreign
138:01 - excellent
138:06 - so let's use an example where we'll use
138:08 - the predicate built in generic delegate
138:11 - let's first create an employee class
138:20 - let's create a generic list that will
138:22 - contain four objects of the employee
138:25 - data type
138:27 - let's add some employee objects that
138:29 - contain made up employee details to the
138:31 - employees list
138:36 - foreign
138:55 - foreign
139:01 - that will filter the employees list
139:04 - based on criteria that will be passed to
139:06 - the method in the form of a predicate
139:12 - so this method simply traverses the
139:14 - employees list if employee items within
139:17 - the list meet the criteria of the
139:19 - predicate passed into the method
139:21 - the relevant item is added to another
139:23 - list that is returned to the calling
139:25 - code once all the items in the original
139:28 - list passed into this method have been
139:30 - traversed and evaluated
139:35 - so let's call the filter employees
139:37 - method and pass in the employees list
139:39 - followed by the Lambda expression which
139:42 - is encapsulated by a predicate delegate
139:46 - let's say our Lambda expression in this
139:48 - example is used to return only mail
139:50 - employees
139:52 - let's write code to Traverse the list
139:55 - returned by the filter employees method
139:57 - and use the display employee Records
140:00 - action delegate which I have now renamed
140:02 - to display employee details just for
140:05 - better readability that we created in
140:07 - the previous example to write the
140:09 - relevant employee records to the console
140:12 - screen
140:15 - Let's test the code
140:21 - great
140:29 - let's alter the logic of our predicate
140:31 - so that we return only details for
140:34 - employees that earn less than 45 000 a
140:37 - year
140:44 - great
140:45 - let's alter our logic so that we only
140:48 - return employee details for employees
140:51 - that are managers
140:53 - great
140:55 - so we can abstract this code even
140:58 - further through the use of an extension
141:00 - method
141:01 - so let's create a public static class
141:03 - named extensions
141:07 - let's copy the filter employees method
141:09 - to our extensions static class
141:16 - let's make the filter employees method
141:18 - public and it must also be static then
141:21 - to finish making this method an
141:22 - extension method all we need to do is
141:25 - add the this keyword before the first
141:28 - parameter
141:29 - the first parameter is defined as a
141:31 - generic list that is strongly typed with
141:34 - the employee user defined type
141:36 - so the filter employee extension method
141:39 - should now automatically be available on
141:41 - generic lists that are strongly typed
141:43 - with the employee user-defined type in
141:47 - our main method
141:48 - if you are not clear on extension
141:50 - methods don't worry extension methods
141:52 - will be discussed in detail in upcoming
141:54 - tutorials
141:57 - basically three extension methods the
141:59 - developer can add methods to existing
142:02 - types without creating a new derived
142:04 - type recompiling or modifying the
142:07 - original type
142:09 - so let's see if we can access the filter
142:11 - employees method on the employees
142:13 - generic list and there it is
142:16 - it shows up in the intellisense as
142:19 - expected
142:20 - so we no longer need to pass the
142:22 - employees list to the filter employees
142:24 - method as a parameter and all we need to
142:27 - do is pass in the Lambda expression
142:31 - Let's test the code
142:32 - [Music]
142:33 - great
142:35 - the system.linknamespace contains a
142:38 - number of extension methods let's
142:40 - demonstrate how we can use an extension
142:42 - method which is available in the
142:44 - system.link namespace to achieve the
142:46 - same result
142:48 - link is beyond the scope of this
142:50 - tutorial we'll look at Link in detail in
142:52 - upcoming videos
142:53 - [Music]
142:55 - let's include a directive to the
142:57 - system.link namespace at the top of our
142:59 - code
143:00 - the where extension method is available
143:02 - on the generic I enumerable type
143:06 - the generic list type implements the
143:08 - innumerable generic interface so now
143:11 - that we have added the system.link
143:13 - directive the where extension method
143:15 - should now be available on the employees
143:18 - list object
143:20 - so let's replace the filter employees
143:22 - method with the where method
143:25 - the where method returns a value of type
143:27 - I innumerable so we must convert our
143:30 - result to a generic list using the to
143:33 - list explicit conversion method
143:36 - Let's test the code
143:37 - [Music]
143:42 - great
143:45 - so let's finish up by using the funk
143:47 - delegate that we created earlier to add
143:49 - a bonus to the employee annual salary
143:52 - fields of each of our employee objects
143:54 - stored in the employees list
143:58 - [Music]
144:07 - [Music]
144:09 - Let's test the code
144:12 - foreign
144:14 - excellent
144:15 - I hope you've enjoyed this tutorial on
144:17 - the three built-in generic delegates
144:19 - namely Funk action and predicate
144:32 - hi and welcome this is the fifth part of
144:34 - a video series on delegates
144:37 - this is also the final part of this
144:38 - video series on delegates but there are
144:41 - a lot more upcoming videos to be
144:43 - released as part of this Advanced
144:45 - c-sharp course
144:46 - in this video we'll look at how
144:48 - delegates can be used to encapsulate a
144:50 - callback method
144:52 - so what is a callback method basically
144:55 - callbacks are simple functions which are
144:57 - used to notify the calling instance when
145:00 - an asynchronous code block has been
145:02 - executed and the result is available
145:06 - so I found a great code example on a
145:08 - Microsoft docs webpage that uses a
145:11 - callback method encapsulated by a
145:13 - delegate to run code when asynchronous
145:15 - tasks have completed
145:18 - the code in this code sample performs a
145:20 - basic function of retrieving the IP
145:22 - addresses associated with user-inputted
145:25 - domain names using the.net built-in DNS
145:28 - static class
145:29 - for example if we input microsoft.com
145:32 - the DNS class behind the scenes as it
145:35 - were asynchronously looks up the IP
145:37 - addresses associated with the
145:40 - microsoft.com domain name
145:43 - I'm going to Simply copy this sample
145:45 - code demonstrating the use of a callback
145:47 - method interp.net core console
145:50 - application
145:51 - we can then demonstrate the code and go
145:53 - through the code step by step to
145:55 - understand how it works basically this
145:57 - code demonstrates using asynchronous
145:59 - methods available in the built-in DNS
146:02 - static class to retrieve domain name
146:05 - system information for user-specified
146:07 - domain names
146:09 - you can navigate to this URL to copy the
146:12 - relevant sample code as well as read
146:14 - more information about the sample code
146:17 - the link to this URL has also been
146:19 - included Below in the description
146:31 - so let's create a.net core console
146:33 - application
146:43 - let's name this project and solution DNS
146:46 - async callback sample code
146:57 - let's copy the code from the relevant
146:59 - web page and paste it into the project
147:02 - we have just created
147:04 - so to do this we can select all the code
147:06 - that has been Auto generated in our
147:09 - program.cs class file and paste the code
147:12 - currently copied to our clipboards over
147:15 - the selected code right so let's start
147:17 - by running the code
147:20 - so let's enter a few well-known domain
147:22 - names
147:23 - this code has been written so that we
147:25 - can press the enter key without entering
147:27 - anything at the input prompt as an
147:29 - indication that we are finished
147:31 - inputting our data so let's enter a few
147:33 - domain names
147:35 - so for the first entry let's enter
147:37 - google.com
147:39 - for the second entry let's enter
147:40 - microsoft.com
147:43 - and for the third entry let's enter
147:45 - yahoo.com
147:48 - right let's press the enter key without
147:50 - entering anything at the command prompt
147:52 - to indicate that we are finished
147:54 - inputting our data
147:56 - and then the output presented to the
147:58 - screen we can see three headings namely
148:00 - addresses for Google addresses for
148:02 - Microsoft and addresses for Yahoo
148:05 - under these headings are the IP
148:07 - addresses relevant to the domain names
148:09 - that we have entered
148:11 - if you're interested in reading more
148:12 - about what DNS IE domain name system is
148:15 - please navigate to this URL
148:23 - so let's go through the code to see how
148:25 - a delegate is used to encapsulate a
148:27 - method that is used as a callback method
148:30 - through the execution of the relevant
148:32 - delegate once relevant asynchronous
148:34 - tasks have been completed
148:37 - so the first line of code in the main
148:38 - method instantiates a delegate named
148:40 - async callback
148:42 - this delegate is built into.net and is
148:45 - provided specifically for the purpose of
148:47 - encapsulating callback methods that are
148:50 - used during asynchronous operations
148:52 - so I'm going to right click the delegate
148:54 - name in the visual studio code editor
148:56 - and click the context menu item named go
148:59 - to definition
149:02 - and here we are presented with the
149:04 - delegate definition of the async
149:06 - Callback delegate this delegate can
149:08 - encapsulate a method that doesn't return
149:10 - a value and contains one parameter of
149:13 - the I async result type
149:15 - and if we look at the I async result
149:17 - type this interface provides a standard
149:20 - definition for objects that are passed
149:22 - as an argument to the Callback method
149:25 - the relevant object that implements the
149:27 - I async result interface represents the
149:30 - status of an asynchronous operation
149:33 - you can see here the async state
149:36 - read-only property gets a user-defined
149:38 - object that qualifies or contains
149:41 - information about an asynchronous
149:43 - operation
149:45 - okay so let's go back to our code and
149:47 - you'll see that a method name is passed
149:49 - into the Constructor of the async
149:51 - Callback delegate in the code written
149:53 - for the purpose of instantiating an
149:55 - object derived from the async Callback
149:58 - delegate type
149:59 - so our callback method is named
150:01 - processdns information
150:04 - let's have a brief look at this method
150:06 - you can see its method signature
150:08 - conforms to the method definition
150:10 - defined in the async Callback delegate
150:14 - so we'll come back to this method in a
150:16 - bit for now let's go back to the code in
150:18 - the main method so next the code is
150:20 - prompting the user for domain names
150:23 - and you can see that for each entry the
150:25 - DNS dot begin get host entry method is
150:28 - fired
150:32 - DNS is a static class provided in.net
150:35 - and provides simple domain name
150:37 - resolution functionality
150:40 - the DNS dot begin get host entry method
150:43 - asynchronously Returns the Internet
150:45 - Protocol IP addresses for the specified
150:48 - host
150:50 - you can see that our delegate named
150:52 - callback that encapsulates our callback
150:54 - method named process DNS information is
150:57 - passed as an argument to the DNS dot
151:01 - begin get host entry method
151:03 - here the code essentially informs the
151:05 - DNS static class of the memory address
151:07 - of our designated callback method which
151:10 - is stored in the Callback delegate
151:12 - object
151:13 - note that above this line of code we
151:15 - have a line of code that increments an
151:17 - integer variable named request counter
151:22 - the number of asynchronous tasks is
151:24 - stored in the integer variable
151:30 - now the reason why this incrementation
151:31 - is done in an unusual way here whereby
151:34 - the.net built-in interlocked dot
151:37 - increment method is used for this
151:39 - purpose
151:40 - is because each time our asynchronous
151:43 - process is kicked off as it were by the
151:45 - DNS dot begin get host entry method a
151:48 - new thread is created and executed in
151:51 - parallel asynchronously to the main
151:53 - thread
151:56 - when each asynchronous process is
151:59 - finished processing
152:00 - the Callback method is executed on the
152:03 - main thread and if we go back to our
152:05 - callback method you can see that each
152:07 - time an asynchronous task completes the
152:11 - request counter variables value is
152:13 - decremented within the process DNS
152:15 - information callback method so because
152:18 - the timing of when this callback method
152:20 - will be called by potentially multiple
152:22 - threads is uncertain we must ensure that
152:26 - the request counter variable is updated
152:28 - in a thread-safe way multi-threading
152:31 - solves problems with throughput and
152:33 - responsiveness but in doing so it
152:36 - introduces new problems Deadlocks and
152:38 - race conditions
152:40 - for more information in this regard
152:42 - please navigate to this URL
152:57 - so the next line of code monitors the
152:59 - state of the value of the request
153:01 - counter variable
153:06 - when the request counter variable's
153:08 - value is zero we know that all
153:10 - asynchronous tasks have completed which
153:13 - means our output data is ready to be
153:15 - presented to the screen
153:17 - so this while loop ensures that if our
153:20 - asynchronous tasks have not yet
153:22 - completed that the subsequent lines of
153:24 - code responsible for outputting the
153:26 - results of the asynchronous tasks are
153:29 - only executed once the asynchronous
153:31 - tasks have completed
153:34 - so this while loop will continue
153:36 - processing and outputting Status
153:38 - information to the screen until the
153:40 - request counter variable has been
153:42 - decremented to xero within the Callback
153:44 - method I.E the process DNS information
153:46 - method so let's look at the process DNS
153:50 - information callback method and you can
153:52 - see the
153:53 - dns.get host entry method is called to
153:57 - return the result of an asynchronous
153:59 - task the dns.beginget host entry method
154:03 - and the dns.get host entry method
154:07 - are used for asynchronous processing
154:09 - the dns.get host entry method gets
154:12 - called from within the Callback method
154:15 - remember a reference to the Callback
154:17 - method was passed as an argument to the
154:20 - dns.beginget host entry method
154:23 - this was done by passing the async
154:25 - Callback delegate object stored in a
154:28 - variable named callback to the
154:30 - dns.beginget host entry method as an
154:33 - argument
154:34 - remember an async callback delegate
154:37 - object
154:38 - was coded to encapsulate the process DNS
154:41 - information method within the main
154:42 - method this object was then passed as an
154:45 - argument to the DNS dot begin get host
154:48 - entry method
154:50 - so the application knows that an
154:52 - asynchronous task has completed because
154:54 - at this stage the Callback method
154:56 - process DNS information method has been
154:59 - invoked So within the Callback method it
155:01 - is safe to call the dns.get host entry
155:05 - method to return the result of the
155:07 - asynchronous task to the calling code so
155:10 - the results here are stored in an
155:12 - arraylist member variable named host
155:14 - data the host data arraylist can be used
155:18 - to retrieve the relevant results
155:20 - and present the relevant results to the
155:23 - console screen and you can see the code
155:25 - here in the main method responsible for
155:27 - outputting the results of each
155:29 - asynchronous task to the console screen
155:31 - so the IP address is relevant to the
155:34 - domain names entered by the user are
155:36 - written to the console screen
155:43 - let's run the code and enter some domain
155:45 - names
156:05 - excellent
156:11 - note that the code we have just
156:13 - demonstrated here uses the asynchronous
156:16 - programming model APM pattern also
156:18 - called the I async result pattern which
156:21 - is the Legacy model that uses the I
156:24 - async result interface to provide
156:26 - asynchronous Behavior
156:28 - Microsoft recommends moving forward that
156:31 - we use the task-based asynchronous
156:33 - pattern tab for asynchronous programming
156:36 - which uses a single method to represent
156:39 - the initiation and completion of an
156:41 - asynchronous operation
156:43 - the async and await keywords in c-sharp
156:46 - add language support for the task-based
156:48 - asynchronous pattern
156:51 - we'll look at the task-based
156:52 - asynchronous pattern tab in detail in
156:55 - upcoming tutorials
156:57 - this video serves as a demonstration of
156:59 - how delegates can be used to encapsulate
157:01 - callback methods and also serves as a
157:04 - brief introduction to asynchronous
157:05 - programming
157:06 - we'll look at the recommended approach
157:08 - to asynchronous programming I.E the
157:10 - task-based asynchronous pattern tab in
157:13 - upcoming videos
157:16 - please navigate to this URL for more
157:18 - information on asynchronous programming
157:20 - patterns available in c-sharp
157:25 - summarize
157:27 - in this five part video series on
157:29 - delegates we discussed that a delegate
157:31 - is a reference type in c-sharp that
157:33 - references a method that contains a
157:35 - particular parameter list and return
157:37 - type we discussed that due to a concept
157:40 - called variance the delegate definition
157:42 - does not have to exactly match the
157:44 - parameter types or the return type of
157:47 - the method that it encapsulates
157:49 - contravariance means that a delegate for
157:51 - example can reference a method where a
157:53 - particular parameter in the delegates
157:55 - definition is more derived than the
157:57 - parameter counterpart contained within
158:00 - the method that it encapsulates
158:03 - covariance means that the return type in
158:06 - the delegates definition can be less
158:07 - derived than the return type of the
158:09 - method that it encapsulates
158:12 - we looked at three built-in generic
158:14 - delegates namely Funk action and
158:16 - predicate we looked at how these generic
158:18 - delegates can be used in code for better
158:21 - code reuse type safety and to improve
158:24 - performance we also briefly looked at
158:26 - Anonymous methods Lambda expressions and
158:29 - extension methods
158:31 - in this final video on delegates we
158:33 - looked at how a delegate can be used to
158:34 - encapsulate a callback method that can
158:37 - be called once an asynchronous task is
158:39 - completed
158:41 - we haven't looked at delegates in
158:43 - relation to events yet an upcoming
158:45 - tutorial on events will include how
158:47 - delegates are used in relation to events
158:49 - in C sharp I hope you have enjoyed this
158:52 - tutorial on asynchronous programming
158:54 - using delegates to encapsulate callback
158:56 - methods
158:57 - and I hope you've enjoyed this video
158:59 - series on delegates if you didn't fully
159:02 - understand all the concepts discussed in
159:03 - this video please don't worry the more
159:06 - you practice the more you'll understand
159:07 - and the more proficient you'll become as
159:09 - a software engineer learning to become a
159:11 - proficient software engineer is a
159:13 - marathon and not a Sprint I'd also like
159:15 - to add that I think it is more important
159:17 - to understand the concepts behind the
159:19 - code rather than the code itself
159:22 - [Music]
159:32 - hi and welcome
159:34 - this is the first part of a tutorial on
159:36 - c-sharp events
159:38 - in this video we'll look at the basics
159:40 - of c-sharp events by examining a piece
159:43 - of code taken from a Microsoft docs web
159:45 - page
159:46 - for more content on advanced c-sharp
159:48 - concepts like this and much more please
159:50 - consider subscribing and please ring the
159:52 - bell so that you'll be notified of
159:53 - future releases from this channel
159:56 - I usually use my Windows PC to record my
159:58 - demonstrations but I've decided to
160:00 - demonstrate this code example using
160:02 - visual studio 2019 Community Edition for
160:05 - Mac
160:06 - it doesn't ultimately matter which code
160:08 - editor you use if you want to follow
160:10 - along
160:11 - it makes no difference because this
160:13 - video is about the code more
160:15 - specifically about the basics of what
160:18 - events are and how they relate to
160:20 - delegates
160:21 - so I'm going to use Visual Studio 2019
160:24 - for Mac Community Edition to create
160:26 - a.net core console project
160:28 - you can name it what you like
160:31 - I'll name this project threshold reached
160:33 - event application
160:35 - I'm going to copy the code from the
160:37 - appropriate Microsoft docs web page and
160:39 - paste it over the code in the program.cs
160:41 - file like this
160:47 - code sample is available at this URL
160:51 - so the code here performs a very basic
160:53 - function
160:54 - it first generates a random integer
160:56 - value which can be any non-zero integer
160:59 - value where the maximum value is 10.
161:01 - the centage of value serves in this
161:03 - example as a threshold value
161:07 - the code then prompts the user to press
161:09 - the a key to increment an integer value
161:12 - by a value of 1.
161:16 - when the integer value has been
161:17 - incremented to the extent that it
161:19 - reaches the threshold value I.E the
161:22 - generated random integer value and event
161:24 - is raised and the calling code handles
161:26 - the raised event by outputting text
161:28 - stating that the threshold value has
161:31 - been reached
161:32 - the text also includes the date and time
161:34 - when the threshold value was reached by
161:37 - the value that the user is able to
161:38 - increment by pressing the a key
161:41 - so let's start by running the code and
161:43 - then we'll look at the code in order to
161:45 - see how an event and a delegate have
161:48 - been implemented in the code
161:50 - let's press the a key until the
161:52 - threshold is reached
161:57 - and the threshold has been reached so
161:59 - the event is raised and the event
162:00 - handler outputs appropriate text to the
162:03 - console screen
162:05 - so what exactly is an event in C sharp
162:08 - events are special kinds of multicast
162:11 - delegates that can only be invoked from
162:14 - within the class or struct where they
162:16 - are declared
162:17 - if other classes or structs subscribe to
162:20 - the event their event handler methods
162:22 - will be called when the class where the
162:24 - delegate has been declared raises the
162:26 - event
162:27 - [Music]
162:32 - events can be marked as public private
162:34 - protected internal protected internal or
162:38 - private protected these access modifiers
162:40 - Define how users of the class can access
162:43 - the event for more information on access
162:46 - modifiers please navigate to this URL
162:50 - events.net are based on the delegate
162:52 - model the delegate model follows the
162:54 - Observer design pattern
162:56 - which enables the subscriber to register
162:58 - with and receive notifications from a
163:00 - provider
163:02 - we'll discuss the Observer design
163:04 - pattern in an upcoming video
163:06 - an event sender pushes a notification
163:08 - that an event has happened and an event
163:10 - receiver receives the notification and
163:13 - defines a response to it an event is a
163:16 - message sent by an object to Signal the
163:18 - occurrence of an action delegates were
163:21 - explored in detail in the last tutorial
163:23 - the third part of this course links to
163:26 - the playlist on delegates have been
163:27 - included Below in the description you
163:30 - can also access this playlist through
163:31 - the card available in the top right hand
163:33 - corner of your screen
163:36 - let's recap what is a delegate a
163:39 - delegate is a type that holds a
163:41 - reference to a method a delegate is
163:43 - declared with a signature that shows the
163:45 - return type and parameters for the
163:47 - method it references
163:49 - and it can hold references only to
163:51 - methods that match its signature a
163:54 - delegate is thus equivalent to a type
163:56 - safe function pointer or a callback
163:59 - a delegate declaration is sufficient to
164:01 - define a delegate class
164:03 - right let's look at our code example to
164:05 - see how an event can be implemented in C
164:07 - sharp so an event can be fired through a
164:10 - user action for example button press or
164:13 - through the code logic itself in this
164:15 - example the event is raised through the
164:17 - code logic
164:18 - here we have a user-defined class named
164:21 - counter where an event is declared the
164:24 - name of the event is threshold reached
164:27 - let's look at how this event is defined
164:30 - so this event has a public access
164:32 - modifier
164:33 - and to Define an event we must use the
164:36 - event keyword then the event keyword is
164:39 - followed by a built-in c-sharp delegate
164:41 - named event handler delegates have many
164:44 - uses in.net in the context of events a
164:47 - delegate is an intermediary or
164:49 - pointer-like mechanism between the Event
164:51 - Source and the code that handles the
164:53 - event
164:55 - you associate a delegate with an event
164:57 - by including the delegate type in the
165:00 - event declaration
165:02 - let's select the event handler delegate
165:04 - name in the code editor
165:06 - let's right click and select the go to
165:08 - declaration menu option
165:11 - if you are using visual Studio for
165:13 - Windows this context menu item will be
165:15 - marked go to definition
165:17 - so here you can see the event handler
165:19 - delegate declaration that can be used to
165:22 - store reference to a method that
165:23 - contains a matching parameter list and
165:25 - return type to the event handlers
165:27 - parameter list and return type in the
165:29 - delegate definition
165:31 - this is a built-in delegate provided in
165:34 - the system namespace
165:36 - notice the T event args generic
165:38 - parameter there is another built-in
165:41 - event handler delegate of the same name
165:43 - also provided in the system namespace
165:46 - this particular delegate declaration
165:48 - looks like this
165:49 - the difference between this delegate and
165:52 - the one we are using
165:53 - is you are restricted to using the event
165:55 - args class to provide event data to the
165:58 - event handler method using this delegate
166:02 - notice that in the definition of the
166:04 - event-handed delegate that we are using
166:06 - we are able to provide a type parameter
166:08 - through generics
166:10 - this means we are not restricted to the
166:12 - use of the event args class to pass data
166:15 - to the event handler method and we can
166:17 - use a custom class for this purpose
166:21 - here you can see we are using the
166:22 - threshold reached event args custom
166:25 - class where data are about an event can
166:28 - be stored in two public properties
166:31 - namely threshold and time reached
166:35 - so this event handler delegate contains
166:37 - two parameters in its delegate
166:39 - definition
166:40 - the first parameters of type object
166:42 - which allows for the calling code event
166:44 - handler method to accept an argument
166:47 - that references an object instance
166:48 - derived from the class where the
166:50 - relevant event resides
166:53 - that this keyword can be used as a
166:56 - reference to the object that contains
166:58 - the event
166:59 - so that this keyword can be used to pass
167:02 - a reference of the sender object
167:04 - to the appropriate event handler method
167:07 - when the relevant event is raised
167:10 - the second parameter through generics
167:12 - allows the developer to define a type
167:14 - for this parameter
167:16 - the advantage of being able to use
167:18 - generics
167:19 - with this delegate is that we are able
167:22 - to create our own custom user-defined
167:24 - type that can contain the relevant event
167:26 - data which can be passed as an argument
167:29 - to an appropriate event handler method
167:31 - in the calling code
167:34 - so let's look at a basic overview of the
167:36 - counterclass I.E the user-defined type
167:38 - where our event is declared
167:42 - here we have two member variables both
167:44 - of the integer data type
167:46 - one to store the threshold value the
167:49 - other to store value that will be
167:50 - incremented by the user so the threshold
167:53 - value is passed through by the calling
167:55 - code through a parameterized Constructor
167:58 - when the calling code instantiates an
168:00 - object derived from the counter class
168:03 - the past in argument is then stored in
168:06 - the member variable named threshold
168:09 - let's look at the add method
168:11 - this method can be used to increment the
168:13 - member variable names total
168:16 - the value stored in the total member
168:18 - variable is then compared to the values
168:21 - stored
168:22 - in the threshold member variable
168:24 - if the value stored in the total
168:26 - variable
168:27 - which is incremented by the user reaches
168:30 - the value stored in the threshold
168:31 - variable and event is raised
168:38 - let's look at the code responsible for
168:41 - raising the relevant event
168:43 - firstly an object derived from the
168:46 - threshold reached event args class is
168:50 - instantiated the threshold reached event
168:52 - args used to define type is the custom
168:55 - type we have passed as a parameter to
168:58 - the event handler delegate
169:01 - an object instantiated from the
169:03 - threshold reached event args class can
169:06 - be used to store event information
169:09 - if you look at the threshold reached
169:11 - event args class you can see that it
169:13 - contains two properties one named
169:16 - threshold for storing the threshold
169:18 - value and the other named time reached
169:20 - when the user incremented value stored
169:22 - in the total member variable reached the
169:25 - value stored in the threshold member
169:27 - variable so these two properties are
169:29 - appropriately set on an object derived
169:32 - from the threshold reached event args
169:35 - class
169:36 - this object is then passed into a method
169:39 - named on threshold reached the on
169:42 - threshold reached method contains the
169:44 - logic for raising the appropriate event
169:47 - in this method code is first created
169:50 - where a variable named Handler is used
169:53 - for referencing the threshold reached
169:55 - event
169:56 - the next line of code is an if statement
169:59 - checking if the Handler variable
170:01 - contains a value
170:03 - if the Handler variable is null this
170:05 - means that calling code has not
170:07 - subscribed to the relevant event
170:10 - which means no appropriate method has
170:12 - been designated on the client calling
170:14 - code to handle the relevant event when
170:17 - the event is raised
170:18 - in a bit we'll look at how a calling
170:20 - client can subscribe to an event that
170:23 - resides in a particular class
170:25 - so if however calling client code has
170:27 - subscribed to the relevant event the
170:30 - Handler delegate is invoked
170:33 - this delegate will point to a method
170:34 - that has been defined in the calling
170:36 - client code
170:37 - the relevant method is designated to
170:39 - handle the relevant event at the point
170:42 - where the calling client subscribes to
170:44 - the relevant event
170:46 - so let's look at the calling client code
170:49 - let's go to the main method so the first
170:52 - line of code is instantiating an object
170:54 - derived from the counter class
170:56 - note that the random.next method is
170:59 - being used to pass a non-negative random
171:02 - integer that is less than the specified
171:05 - maximum which in this case is hard coded
171:07 - to a value of 10.
171:10 - so the randomly generated number is our
171:12 - threshold
171:13 - which will be stored in the relevant
171:15 - object derived from the counter class
171:19 - so the object derived from the
171:21 - counterclass is stored in a variable
171:23 - named C
171:25 - using the object referenced by the C
171:27 - variable we are now able to subscribe to
171:30 - the event named threshold reached which
171:32 - is declared in the counter class
171:35 - so the code here is assigned a method
171:37 - that resides in the program class to the
171:40 - threshold reached event we can do this
171:43 - because the method named C underscore
171:45 - threshold reached is compatible with the
171:47 - event handler delegate in other words
171:50 - the parameter list and the return type
171:52 - of the C threshold reached method
171:54 - definition matches the parameter list
171:56 - and return type of the event handler
171:59 - delegate definition
172:01 - the effect of this is that when the
172:03 - threshold reached event is raised from
172:05 - the add method within the counterclass
172:06 - the subscribed method in the calling
172:09 - code IE the C underscore threshold
172:12 - reached method will be invoked
172:15 - a reference to the relevant object
172:16 - derived from the counterclause or sender
172:18 - object is passed in to the C underscore
172:22 - threshold reached method as well as the
172:24 - object that stores the relevant event
172:26 - data in this case the object arrived
172:28 - from the threshold reached event args
172:31 - class
172:32 - note how in this example the event
172:34 - handler delegate is an abstraction
172:37 - that allows any calling client that
172:40 - contains a method with a method
172:42 - definition that matches the event
172:43 - handler delegate definition to handle
172:46 - what happens when the relevant event is
172:48 - raised
172:49 - this means the calling client is Loosely
172:52 - coupled with the class where the event
172:54 - is declared
172:56 - you see the calling code doesn't have to
172:58 - know anything about the class where the
173:00 - event is declared and the class where
173:02 - the event is declared doesn't need to
173:04 - know anything about the calling code
173:06 - the event handler delegate in this case
173:09 - is used to establish a loose coupling
173:11 - this is a key concept to understand when
173:14 - it comes to using events in C sharp how
173:16 - delegates can be used to create a loose
173:18 - coupling between components
173:21 - so let's watch this in action let's put
173:24 - a breakpoint in the code to a point
173:25 - where the value incremented by the user
173:28 - has reached the threshold value and the
173:30 - event is about to fire
173:32 - we can then see what happens when the
173:34 - threshold reached event is raised
173:36 - let's run the code
173:39 - and let's press the a key to increment
173:40 - the value that is compared to the
173:42 - threshold value until our breakpoint is
173:44 - hit which means the user incremented
173:46 - value matches the threshold value
173:50 - and there it is a breakpoint has been
173:52 - hit
174:01 - so a variable named Handler is set to
174:04 - the threshold reached event the code
174:06 - checks if their Handler variable is null
174:08 - if the Handler variable is not null this
174:11 - means the calling code has subscribed to
174:13 - the event
174:15 - so I'm going to put a break within the C
174:17 - underscore threshold reached method
174:20 - which is the designated method for
174:22 - handling the relevant event
174:24 - and when we step through the code the
174:27 - threshold reached event is raised the C
174:30 - underscore threshold reach method is
174:32 - invoked and the C underscore threshold
174:35 - reached method handles the event in the
174:37 - custom way that the method has been
174:39 - coded
174:42 - and if we look at the values associated
174:44 - with the two arguments passed into the C
174:46 - underscore threshold reached method we
174:49 - can see that this is an expected result
174:54 - we have the sender object which is the
174:56 - object from where the event was raised
174:58 - and we have an object derived from the
175:01 - threshold reached event args class where
175:03 - the relevant event data is stored
175:07 - and let's press F5 to run the code right
175:10 - through and you can see the expected
175:12 - output presented to the screen
175:15 - I hope you've enjoyed this video on the
175:17 - basics of events in c-sharp please
175:19 - consider subscribing for more content on
175:21 - advanced c-sharp concepts like this and
175:23 - much more
175:24 - and please ring the bell so that you can
175:26 - be notified of future content released
175:28 - by this channel
175:30 - if you feel you've gained value from
175:31 - viewing this video please consider
175:33 - hitting the like button and please feel
175:35 - free to share any of my videos with
175:37 - anyone you feel May benefit from their
175:39 - content a link to the Microsoft web page
175:41 - that contains the code example I have
175:43 - used in this video is available Below in
175:45 - the description
175:48 - [Music]
175:58 - thank you
176:00 - hi and welcome this video is the second
176:02 - part of a tutorial on events in C sharp
176:06 - in this video we'll create a practical
176:07 - example where multiple events exist in a
176:09 - class
176:10 - we'll look at using add and remove
176:12 - accesses to encapsulate the
176:14 - functionality that gets executed when
176:17 - client code or calling code subscribes
176:19 - or unsubscribes to the relevant events
176:22 - code within the add accessor is executed
176:25 - when the client code subscribes to the
176:27 - relevant event code within the remove
176:29 - accessor is executed when the client
176:31 - code unsubscribes to the relevant event
176:34 - we'll use the event handler list
176:36 - built-in c-sharp collection class to
176:38 - store the relevant delegates associated
176:41 - with the relevant events when the
176:43 - calling code subscribes
176:45 - the event handler list collection class
176:47 - is a built-in c-sharp collection class
176:50 - that can be found in the
176:52 - system.component model namespace and is
176:55 - a collection specially suited for
176:57 - storing delegates
176:58 - so here's the basic idea behind this
177:01 - code example a device could be any
177:03 - device contains a thermostat which
177:06 - contains a heat sensor as well as a
177:07 - cooling mechanism
177:09 - so we'll have a class to represent the
177:11 - device a class to represent the heat
177:13 - sensor and a class to represent the
177:16 - cooling mechanism each of these classes
177:18 - will Implement an appropriate interface
177:21 - so the heat sensor class will contain
177:23 - three events one event that gets fired
177:26 - when the temperature of the device
177:27 - reaches or goes above 27 degrees Celsius
177:30 - which is 80.6 degrees Fahrenheit
177:33 - this event Flags a warning alert a
177:36 - cooling mechanism is switched on to cool
177:37 - the device back down to an acceptable
177:39 - temperature we'll create another event
177:41 - that gets fired when the temperature of
177:43 - the device has reached or gone above 27
177:46 - degrees Celsius and then subsequently
177:48 - Falls below 27 degrees Celsius this
177:51 - event Flags an informational alert and
177:53 - the cooling mechanism is Switched Off
177:56 - and lastly we'll create an event that
177:58 - gets fired when the temperature reaches
178:00 - or goes above 75 degrees Celsius which
178:03 - is 167 degrees Fahrenheit
178:06 - this event Flags an emergency alert the
178:09 - device is shut down and Emergency
178:11 - Services Personnel are notified about
178:13 - the event
178:14 - foreign we discussed in the previous
178:17 - part of this tutorial that an event is
178:19 - raised either by the user's action for
178:21 - example the user clicks a button or the
178:24 - code logic itself in this example we are
178:27 - going to use codelogic to raise specific
178:29 - events
178:30 - for more content on advanced c-sharp
178:32 - concepts like this and much more please
178:34 - consider subscribing and please ring the
178:36 - bell so that you will be notified of
178:38 - future releases from this channel
178:41 - right let's get started
178:43 - let's create a.net core console app and
178:46 - let's name this project and solution
178:47 - thermostat Events app
178:49 - [Music]
178:57 - let's start by building a custom class
178:59 - to store our event information let's
179:01 - name this class temperature event args
179:04 - and let's make this class inherit from
179:06 - the c-sharp built-in event args class
179:10 - we want our custom class to store the
179:12 - current temperature
179:13 - so this will be the temperature at the
179:15 - time when an event is raised and we also
179:17 - want to store the date and time when the
179:19 - event was raised so let's create an auto
179:21 - implemented property named temperature
179:23 - and Define it as the double data type
179:26 - let's create another autoimplemented
179:28 - property named current date time and
179:30 - Define it as the date time date type
179:33 - next let's create an interface named I
179:35 - heat sensor
179:37 - and we'll include definitions for three
179:39 - events in the eye heat sensor interface
179:42 - all the events are associated with the
179:45 - built-in c-sharp delegate named event
179:46 - handler
179:48 - and here we can pass our custom class
179:50 - the one we have just created named
179:52 - temperature event args that will be used
179:54 - to store event information as a generic
179:57 - parameter to the event handler delegate
180:00 - so let's create a definition for an
180:02 - event that will be fired when the
180:04 - temperature reaches or exceeds a
180:06 - predefined emergency level
180:08 - let's create a definition for an event
180:10 - that will be fired when the temperature
180:11 - reaches or exceeds a predefined warning
180:14 - level and lastly let's define an event
180:16 - that will be fired when the temperature
180:18 - has reached or exceeded the warning
180:20 - level and subsequently Falls below the
180:22 - warning level
180:24 - so next let's create a heat tensor class
180:26 - to implement the eye heat sensor
180:28 - interface and we want to explicitly
180:31 - implement the events defined in our eye
180:33 - heat sensor interface for the heat
180:35 - sensor class
180:36 - so one way we can do this is hover our
180:39 - Mouse pointers over the red squiggly
180:41 - line under the eye heat sensor text then
180:44 - select show potential fixes and then
180:46 - select Implement interface explicitly
180:49 - and now you can see Visual Studio has
180:51 - created our event implementations with
180:53 - add and remove accesses
180:55 - note that these add and remove accesses
180:58 - are very similar to the get and set
181:00 - accesses that are implemented for
181:02 - c-sharp read write properties
181:04 - the add accesses will contain code that
181:07 - is fired when the client code subscribes
181:09 - to the relevant event the remove
181:11 - accesses will contain code that is fired
181:14 - when a client unsubscribes to the
181:16 - relevant event
181:17 - so we'll add code to the add and remove
181:19 - accesses in a bit
181:23 - so one thing I forgot to do was include
181:25 - a method definition for running the heat
181:27 - sensor
181:28 - let's include the appropriate method
181:30 - definition in the eye heat sensor
181:32 - interface
181:33 - and now you can see a red squiggly line
181:35 - under the eye heat sensor text in the
181:37 - class definition for the heat sensor
181:39 - class this is because we are not
181:41 - implementing all the members of the eye
181:44 - heat sensor interface
181:46 - so to fix this we can hover our Mouse
181:48 - pointers over the red squiggly line
181:49 - click show potential fixes and then
181:52 - click Implement interface and you can
181:54 - see that Visual Studio generates a
181:56 - method implementation for the method
181:58 - that we had not yet implemented for the
182:01 - eye heat sensor interface the Run heat
182:03 - sensor method
182:05 - we'll Implement code for the Run heat
182:07 - sensor method a bit later let's create
182:09 - two member variables at the top of the
182:11 - heat sensor class
182:13 - both defined as double
182:16 - the first member variable is named
182:17 - warning level and the second member
182:19 - variable is named emergency level
182:27 - these member variables will store values
182:30 - that serve as our triggers for when a
182:32 - relevant event should be raised for
182:34 - example if the temperature of the device
182:36 - rises above the emergency level the
182:38 - appropriate emergency event is raised so
182:41 - let's set these values within a
182:43 - parameterized Constructor
182:46 - so let's create a member variable named
182:48 - underscore has reached warning
182:50 - temperature and this is defined as the
182:52 - Boolean data type
182:53 - we'll see the significance of this
182:55 - member variable in a bit
182:59 - let's create another member variable
183:01 - which will reference a collection of
183:03 - delegates associated with the events
183:05 - implemented in this class we could use
183:08 - any of the appropriate collection
183:09 - classes in c-sharp for storing these
183:11 - delegate objects but we are going to use
183:13 - the built-in c-sharp event handler list
183:15 - class for this purpose
183:17 - so to use the event handler list class
183:20 - like this we must include a directive to
183:22 - the system dot component model namespace
183:24 - at the top of our code
183:27 - as mentioned earlier the event handler
183:29 - list class is a member of the system dot
183:32 - component model namespace we are going
183:34 - to use the event handler list classes
183:36 - add event handler method to add the
183:38 - appropriate delegates
183:40 - the add event handler method accepts a
183:43 - key value of type object for its first
183:45 - argument this object value serves as a
183:48 - unique key for accessing values in the
183:50 - collection
183:51 - and its second argument is a value of
183:54 - type delegate
183:55 - the event handler list collection class
183:57 - allows the developer to store delegates
183:59 - that can be accessed within the
184:01 - collection using a unique key
184:03 - we are also going to implement code
184:05 - using the remove event handler method to
184:07 - remove delegate objects from the
184:09 - relevant collection
184:11 - the method definition for the remove
184:12 - event handler method is the same as the
184:15 - method definition for the add event
184:16 - handler method definition
184:18 - please navigate to this URL for more
184:21 - information on the event handler list
184:23 - class
184:26 - so let's create three static read-only
184:28 - objects which will serve as key values
184:31 - that can be used to access the relevant
184:33 - delegates from within the event handler
184:35 - list collection let's create another
184:37 - private member variable which is an
184:39 - array of the double type named
184:41 - underscore temperature data so this
184:44 - array will Store Mock data to simulate
184:47 - data coming from the heat sensor at
184:49 - regular time periods so this data will
184:51 - be used to simulate the heat sensor
184:53 - outputting temperature data
184:55 - so let's create a method named seed data
184:58 - and populate the underscore temperature
185:00 - data array with data
185:11 - note that I'm deliberately including
185:13 - temperature data that is greater in
185:15 - value than 27 which will be used as our
185:18 - warning level
185:20 - and toward the end data that is greater
185:22 - in value than the emergency level which
185:25 - will be set to a value of 75.
185:28 - this is so we can raise our events
185:30 - appropriately when the heat sensor
185:33 - outputs our mock values
185:46 - okay so now let's implement the code for
185:48 - the add and remove accesses for the
185:50 - events that reside in the heat sensor
185:52 - class
185:53 - so in the add accesses all we want to do
185:56 - here is add the appropriate delegate to
185:59 - the event list Handler collection which
186:01 - is done at the point where the client
186:03 - code subscribes to the relevant event
186:05 - so in the remove accesses all we want to
186:08 - do is remove the appropriate delegate
186:10 - from the event list Handler collection
186:12 - and this is done at the point where the
186:14 - client code unsubscribes to the relevant
186:16 - event
186:17 - you can see we are using the appropriate
186:20 - key objects when adding the relevant
186:23 - delegates to the collection
186:25 - we are also able to use the appropriate
186:27 - key to remove the relevant delegate from
186:30 - our event list Handler collection
186:32 - so let's encapsulate functionality for
186:35 - raising the relevant events by creating
186:37 - three methods responsible for raising
186:39 - the relevant event for each of the
186:41 - events to find in the heat sensor class
186:44 - let's name the first method on
186:45 - temperature reaches warning level
186:48 - this method accepts one argument which
186:50 - is our custom type named temperature
186:53 - event args the temperature event args
186:55 - class is responsible for storing event
186:58 - data
187:00 - let's then write code to reference the
187:02 - relevant event using the underscore
187:04 - temperature reaches warning level key
187:06 - variable to reference the appropriate
187:08 - delegate within the underscore list
187:10 - event delegates object which is derived
187:13 - from the event handler list class
187:15 - when assigning the value stored in the
187:17 - underscore list event delegates
187:19 - collection object to the Handler
187:21 - variable we must type cost the delegates
187:23 - to the appropriate delegate type which
187:25 - is the event handler delegate that
187:27 - accepts the temperature event args type
187:30 - as a generic parameter
187:31 - then we need to see if indeed the client
187:33 - code has subscribed to the relevant
187:35 - event
187:37 - if the client code has subscribed then
187:39 - the Handler variable will not be null
187:41 - so if the Handler variable is not null
187:43 - we can raise the relevant event by
187:45 - executing the handle delegate object and
187:47 - passing in the appropriate arguments to
187:50 - the Handler delegate though this keyword
187:52 - is the first argument which references
187:54 - the current object which of course is an
187:56 - object of the heat sensor type
187:59 - the second argument contains relevant
188:01 - event information and is of the
188:03 - temperature event args custom type
188:06 - if you'll recall we made Provisions for
188:09 - storing the current temperature as well
188:11 - as the date and time of when the
188:13 - relevant event occurred and the
188:15 - temperature event args class right and
188:17 - we can now repeat the same basic pattern
188:19 - for the other two methods responsible
188:21 - for raising the other two events
188:23 - declared in the heat sensor class
188:27 - thank you
188:28 - so let's Implement a method to
188:29 - encapsulate raising the temperature
188:31 - Falls below warning level event handler
188:34 - event
188:36 - and let's Implement a method to
188:37 - encapsulate raising the temperature
188:39 - reaches emergency level event handler
188:41 - event
189:01 - and now let's Implement a private method
189:03 - named monitor temperature
189:06 - this method simulates the heat sensor
189:08 - outputting temperature information for
189:10 - the device being monitored
189:13 - so this method traverses the data stored
189:15 - in the underscore temperature data array
189:17 - which contains our mock temperature data
189:20 - let's write code to display the
189:22 - temperature to the console screen each
189:24 - time a temperature is read from the
189:27 - underscore temperature data array
189:40 - then we can create an else if letter
189:42 - whereby we can compare the temperature
189:45 - output to the warning level and the
189:47 - emergency level
189:48 - the emergency level has the highest
189:50 - value that will be evaluated so this is
189:52 - the first value that will be evaluated
190:00 - if the temperatures above the emergency
190:02 - level the emergency event is raised else
190:05 - if the temperature is above the warning
190:07 - level but below the emergency level the
190:10 - warning event is raised
190:22 - else if the temperature was above the
190:24 - warning level and subsequently Falls
190:26 - below the warning level we can raise the
190:29 - temperature Falls below warning level
190:30 - event
190:32 - note how we are using the underscore has
190:34 - reached warning level Boolean member
190:36 - variable to evaluate if the temperature
190:38 - Falls below warning level events should
190:40 - be raised
190:41 - the underscore has reached warning level
190:44 - variable
190:45 - must be set to True when the warning
190:47 - level reached event is raised so that
190:49 - the temperature Falls below warning
190:51 - level event can be raised when the
190:53 - temperature subsequently Falls below the
190:54 - warning level
190:56 - when the temperature subsequently Falls
190:58 - below the warning level we must set the
191:00 - underscore has reached warning level
191:02 - variable to false
191:04 - and for effect I'm going to introduce a
191:06 - one second delay between iterations of
191:09 - the underscore temperature data array
191:14 - as you can see I'm using the
191:17 - system.threading.thread.sleep method for
191:18 - this purpose
191:20 - I'm passing 1000 as an argument to this
191:22 - method
191:24 - this value denotes one thousand
191:26 - milliseconds which is one second
191:29 - and let's finish off the heat sensor
191:31 - class by implementing code for the Run
191:33 - heat sensor method
191:37 - so we'll simply write the text heat
191:38 - sensor is running to the screen to
191:40 - indicate that the heat sensor is running
191:43 - and then let's call the monitor
191:45 - temperature method
191:46 - okay so let's create the interface for
191:49 - the cooling mechanism class
191:51 - let's keep this really simple so this
191:54 - interface contains two method
191:55 - definitions one named on and the other
191:58 - named off as the names imply these
192:00 - methods represent the behaviors of
192:02 - switching the cooling mechanism on and
192:04 - off
192:05 - let's create a class named cooling
192:07 - mechanism
192:08 - and implements the eye cooling mechanism
192:10 - interface
192:12 - and each method will simply write
192:13 - appropriate text to the screen
192:26 - let's create an interface named I device
192:29 - this interface contains two method
192:31 - definitions one named run device
192:34 - the other named handle emergency
192:37 - we'll create the class that implements
192:39 - the I device interface in a bit but
192:41 - let's first create a class to represent
192:43 - the thermostat
192:45 - let's first create an interface named I
192:47 - thermostat
192:49 - this interface contains one method
192:51 - definition named run thermostat
192:54 - right let's create a class named
192:55 - thermostat that implements the Run
192:57 - thermostat method
193:03 - let's create a member variable of type I
193:06 - cooling mechanism
193:08 - let's create a member variable of type I
193:10 - heat sensor and let's create a member
193:12 - variable of type I device
193:15 - let's create two constants one to store
193:18 - the warning temperature level which is
193:20 - set to 27 degrees Celsius and want to
193:23 - store the emergency temperature level
193:25 - which is set to 75 degrees Celsius
193:28 - please note that these figures are
193:29 - arbitrary and serve only to help us with
193:31 - the code example
193:33 - let's create a parameterized Constructor
193:35 - that accepts an argument of the eye
193:37 - cooling mechanism type an argument of
193:40 - the eye heat sensor type and the idevice
193:43 - type we want the thermostat to have a
193:46 - reference to the device to which it is
193:48 - attached
193:49 - let's set the appropriate member
193:51 - variables to their counterpot arguments
193:53 - within the Constructor
193:55 - let's create a method where we'll wire
193:58 - up the events contained in the heat
193:59 - sensor class
194:01 - let's name this method wire up events to
194:04 - event handlers
194:06 - so let's use the heat sensor object
194:08 - passed into the thermostat class to wire
194:10 - up all of the appropriate events
194:13 - so to do this we can write
194:15 - underscoreheatsensor dot the event name
194:18 - which is in this case temperature
194:20 - reaches warning level event handler Then
194:23 - followed by the plus equals operator
194:25 - then we are able to press the Tab Key to
194:28 - Auto generate an appropriate method
194:30 - definition
194:31 - then we can rename the method if we
194:33 - choose and click the apply button to
194:35 - confirm the change
194:41 - so let's write code to wire up the
194:43 - remaining events
194:51 - so in the Run thermostat method let's
194:54 - add code to write that the thermostat is
194:56 - running
194:57 - let's call the wire up events to event
195:00 - Handler's private method
195:02 - and lastly let's call The Run heat
195:04 - sensor method on the underscore heat
195:06 - sensor object
195:08 - let's write code for each of the client
195:09 - event handlers
195:10 - so to handle the event for when the
195:13 - temperature reaches or exceeds the
195:15 - warning level let's first change the
195:17 - color of the font to dark yellow
195:20 - let's write warning alert the warning
195:23 - level is between warning level and
195:25 - emergency level to the console screen
195:27 - let's then write code to switch on the
195:30 - cooling mechanism
195:31 - then when the temperature subsequently
195:33 - Falls below the warning level we want
195:35 - the font to change to a blue color
195:38 - and let's write information alert
195:40 - temperature Falls below warning level
195:42 - warning level is between warning level
195:44 - and emergency level
195:46 - and then to handle the emergency event
195:48 - let's change the font to a red color
195:50 - let's output emergency alert emergency
195:53 - level is emergency level and above
195:56 - and this event is handled slightly
195:59 - differently to the other event handlers
196:01 - because we are calling the underscore
196:03 - device objects handle emergency method
196:06 - we are using the idevice interface to
196:08 - handle the emergency event and the
196:10 - device object's code which we'll soon
196:13 - implement
196:14 - and we must make sure that each font
196:16 - color is reset after each event is
196:19 - handled
196:20 - okay so now let's create a class to
196:22 - represent our device I.E the device that
196:25 - we are monitoring for temperature
196:26 - changes let's name it device and within
196:30 - the classes definition let's indicate
196:31 - that we wish to implement the idevice
196:34 - interface
196:35 - let's hover our Mouse pointers over the
196:37 - red squiggly line under the idevice text
196:41 - show potential fixes and then click
196:43 - Implement interface and visual studio
196:46 - Auto generates implementations for the
196:48 - members of the idevice interface for us
196:51 - so let's Implement code for the handle
196:53 - emergency method
196:56 - and we'll simply write out a basic
196:58 - Narrative of what should happen in the
197:00 - event of an emergency so let's write
197:03 - sending out notifications to Emergency
197:05 - Services Personnel to the console screen
197:08 - and then in the event of an emergency we
197:10 - also want to shut down the device
197:13 - so let's create a private method named
197:15 - shutdown device
197:17 - and this method simply outputs a
197:19 - narrative stating that the device is
197:21 - shutting down
197:22 - let's call the shutdown device private
197:24 - method from the handle emergency method
197:31 - let's Implement code for the Run device
197:32 - method
197:34 - so let's simply output that the device
197:36 - is running to the console screen
197:38 - then we want to construct our objects
197:40 - for our cooling mechanism heat sensor
197:42 - and thermostat components
197:45 - and we'll use their interface
197:47 - abstractions to Define each of their
197:49 - types
197:51 - and I've encountered a bit of a snag
197:52 - here when writing the code to construct
197:55 - the heat sensor object
197:59 - we have already created the constants
198:01 - for the warning level and emergency
198:02 - levels in the thermostat class I think
198:06 - these constants should rather be members
198:08 - of the device class and passed into the
198:10 - heat sensor class during the
198:11 - construction of the heat sensor object
198:15 - so let's create the two relevant
198:17 - constants in the device class and so
198:19 - that we can encapsulate the values of
198:21 - these constants and expose the values of
198:24 - these constants publicly let's create
198:26 - two corresponding read-only properties
198:28 - let's first create definitions for these
198:30 - read-only properties in the idevice
198:32 - interface
198:38 - and then let's implement the code for
198:40 - these properties in the device class
198:45 - and then within the thermostat class
198:46 - which has a reference to the relevant
198:49 - device object we can replace the
198:51 - references to the relevant constants
198:53 - that once resided in the thermostat
198:55 - class with references to the relevant
198:57 - read-only properties of the device
198:59 - object
199:01 - okay let's then write the code to run
199:04 - the device from our main method so let's
199:06 - write code to prompt the user to press
199:08 - any key to run the device
199:10 - then let's instantiate an object for the
199:12 - device
199:14 - then let's call the relevant object's
199:16 - run device method
199:17 - sorry I know I'm jumping around here a
199:19 - bit we still need to finish off the code
199:22 - for the Run device method let's finish
199:24 - creating the thermostat object
199:26 - then let's call the object's run
199:28 - thermostat method
199:40 - let's run the code
199:44 - foreign
199:49 - and you can see by the status output the
199:52 - device is running the thermostat is
199:53 - running and the heat sensor is running
199:55 - the temperature changes of the device
199:57 - can be seen with the output of each
199:59 - temperature to the console screen
200:02 - a warning event is raised when the
200:04 - temperature exceeds 27 degrees Celsius
200:06 - the cooling mechanism is then switched
200:09 - on but there's an issue because when the
200:11 - temperature subsequently Falls below 27
200:14 - degrees Celsius the relevance status is
200:17 - not being outputted to the screen
200:18 - instead the code is raising the warning
200:20 - event
200:21 - so let's investigate what is going on
200:23 - here
200:25 - and the issue was caused I think because
200:27 - of all the copying and pasting I forgot
200:30 - to change the call to the on temperature
200:31 - reaches warning level method to a call
200:34 - to the on temperature Falls below
200:36 - warning level method obviously a call to
200:39 - the on temperature reaches warning level
200:40 - method is inappropriate for the
200:42 - condition when the temperature has
200:44 - reached or is over the warning level and
200:47 - then subsequently Falls below the
200:48 - warning level so let's fix this issue
200:51 - and let's run the code
200:56 - foreign
201:09 - and that is a correct result we can see
201:12 - the cooling mechanism is turned on when
201:15 - the temperature of the device exceeds
201:17 - the warning level
201:18 - and when the temperature has been above
201:20 - the warning level and subsequently Falls
201:22 - below the warning level the correct
201:24 - event is raised the correct status is
201:27 - therefore outputted to the screen in a
201:28 - blue font and then the cooling mechanism
201:31 - is Switched Off
201:32 - and we can see that all the events are
201:34 - firing correctly and being handled
201:36 - correctly toward the end the emergency
201:38 - event is being handled correctly which
201:41 - is in line with the mock temperature
201:42 - data that we created for this example
201:44 - great
201:46 - I hope you have enjoyed this video on
201:48 - handling multiple events within a class
201:50 - using the add and remove accesses
201:54 - we also use the event handler list
201:56 - built-in c-sharp collection class to add
201:58 - and remove the relevant delegates for
202:01 - when a user subscribes or unsubscribes
202:03 - to an event
202:04 - me
202:05 - [Music]
202:20 - [Music]
202:29 - [Music]
202:41 - [Music]
202:48 - hi and welcome to the third part of this
202:50 - tutorial on c-sharp events
202:53 - we have discussed that events can be
202:55 - triggered either by code logic or
202:57 - through a user's actions for example
202:59 - clicking a button
203:00 - in the previous parts of this tutorial
203:02 - we focused on events triggered by code
203:05 - logic in this video we'll focus on
203:08 - events triggered through user actions
203:10 - [Music]
203:12 - so in most of the tutorials provided by
203:15 - this channel regarding C sharp the.net
203:17 - core console app project template has
203:20 - been used as a starting point for
203:22 - creating the relevant sample code
203:25 - this has been done deliberately so that
203:27 - we can focus on the language of C sharp
203:30 - and not be distracted by framework
203:31 - related Concepts
203:33 - in this video we'll do something a
203:35 - little bit different we'll create a very
203:37 - basic code example and we'll use the
203:40 - blank app universal windows project
203:42 - template to create the project
203:44 - responsible for the front-end
203:46 - functionality of our application
203:49 - so we are going to develop a basic
203:51 - application using the uwp or universal
203:54 - windows platform framework
203:56 - this is so that we can look at how user
203:58 - actions for example a button click can
204:01 - trigger events and how the relevant
204:03 - events can be handled appropriately in
204:05 - code
204:07 - in this video we'll show how a
204:09 - separation of concerns can be achieved
204:11 - whereby the front-end display
204:12 - functionality is Loosely coupled with
204:15 - the back end functionality so
204:17 - specifically we'll look at how events
204:18 - can be implemented to achieve this
204:21 - so one of the advantages that can be
204:23 - achieved by separating concerns is we
204:26 - can have one team that specializes in
204:28 - front-end design working on the look and
204:30 - feel of the application and the back-end
204:32 - functionality can be developed by a
204:34 - completely different team these two
204:36 - concerns can evolve independently from
204:38 - one another and in parallel to one
204:40 - another
204:41 - the integration of the relevant
204:43 - components at an appropriate time can
204:46 - become a relatively trivial task
204:49 - we are going to show how this loose
204:51 - coupling effect is achieved through the
204:53 - appropriate use of an event
204:57 - a design pattern that can be used to
204:59 - achieve this loose coupling of front-end
205:01 - and back end components is called mvvm
205:04 - which stands for model view view model
205:08 - for more content on advanced c-sharp
205:10 - concepts and much more please consider
205:12 - subscribing and please ring the bell so
205:14 - that you can be notified of future
205:15 - content released from this channel
205:18 - another advantage of implementing the
205:21 - mvvm design pattern to achieve this
205:23 - loose coupling of components is we are
205:25 - able to easily port for example the
205:27 - back-end functionality to other
205:29 - platforms
205:31 - let's say for example you have a
205:33 - particular app which is being
205:34 - distributed via the Microsoft store this
205:37 - app was written using the uwp framework
205:39 - let's say the app is selling really well
205:43 - marketing research tells us that there
205:45 - is a huge demand for this app to run on
205:48 - IOS and Android platforms
205:51 - time is a key factor in keeping the
205:53 - momentum of sales going for this
205:55 - application so we want this app to be
205:57 - appropriated for IOS and Android
206:00 - platforms as soon as possible so that
206:02 - the app can be distributed via Apple's
206:04 - app store for the iOS implementation of
206:07 - the app as well as Google Play for the
206:09 - Android implementation of the app
206:12 - so we know that we can use the xamarin
206:14 - technology to create a cross-platform
206:16 - app for IOS and Android devices
206:19 - so if we have designed our app
206:21 - appropriately using the mvvm design
206:23 - pattern
206:24 - the back end functionality that we have
206:26 - already created would not need to be
206:29 - recreated for the IOS and Android
206:31 - platforms
206:33 - please navigate to this URL for more
206:35 - information on xamarin
206:38 - a team specializing in Android and iOS
206:41 - front-end design could focus on the
206:43 - native front-end functionality for their
206:46 - respective platforms
206:47 - or the use of xamarin forms could also
206:50 - be utilized for the creation of the
206:51 - front-end design using xaml we'll
206:54 - discuss xaml in a bit
206:56 - the backend code already created for the
206:59 - uwp version of the app can be reused for
207:02 - the Android and iOS apps created using
207:06 - the xamarin technology
207:09 - for more information on xamarin forms
207:11 - please navigate to this URL
207:13 - the appropriate use of the mvvm design
207:16 - pattern could make the integration of
207:19 - the front-end functionality with the
207:21 - backend functionality a relatively
207:23 - trivial task
207:24 - the details of mvvm are beyond the scope
207:27 - of this tutorial please navigate to this
207:29 - URL for more detailed information about
207:32 - mvvm
207:34 - model view view model
207:39 - uwp stands for universal windows
207:42 - platform
207:43 - so a uwp application can run on any
207:46 - Windows device that runs Windows 10 or
207:49 - Windows versions greater than version
207:51 - 10. Windows 11 is due to be released on
207:54 - July the 29th 2020.
207:58 - these devices can include PC tablet Xbox
208:01 - hololens surface Hub and Internet of
208:05 - Things devices so we are not going to go
208:07 - into depth regarding the universal
208:09 - windows platform uwp demands an entire
208:12 - course on its own if you want to learn
208:14 - more about universal windows platform
208:16 - please navigate to this URL
208:19 - foreign
208:22 - [Music]
208:24 - but let's look at a very basic example
208:26 - of loosely coupling back-end
208:28 - functionality from front-end
208:30 - functionality using events on the
208:32 - universal windows platform
208:35 - so let's create a Project based on the
208:37 - blank app universal windows project
208:39 - template
208:54 - [Music]
208:56 - thank you
209:07 - let's name this project and solution
209:09 - employee uwp app
209:11 - so once we click the create button we
209:13 - are prompted with a dialog box where we
209:16 - are able to choose the minimum version
209:18 - and Target version that our uwp
209:20 - application will support
209:22 - so to Aid us with our decision let's
209:24 - click on the link labeled which version
209:27 - should I choose which is available in
209:29 - the bottom left hand corner of the
209:31 - relevant dialog box
209:33 - so we are presented with a web page and
209:36 - at the end of the first paragraph on the
209:38 - web page it states
209:39 - projects using.net standard 2.0 must
209:43 - have a minimum version of build
209:46 - 16299 or later
209:49 - so we are going to develop our backend
209:51 - functionality using.net standard 2.0 so
209:55 - let's choose version
209:57 - 16299 from the drop down list labeled
210:00 - minimum version
210:14 - right let's add a standard Library
210:16 - project to our solution
210:32 - and let's name it employee component
210:36 - this Library will contain our back-end
210:37 - functionality
210:39 - so firstly let's reference our employee
210:42 - component project from our uwp project
210:45 - so let's right click the references node
210:47 - within our uwp project and add a
210:50 - reference to the employee component
210:52 - project
210:53 - okay let's delete the class that has
210:55 - automatically been generated
210:57 - let's create a class that will serve as
211:00 - our view model and let's name this class
211:02 - employee view model
211:04 - as the name suggests a view model
211:06 - represents the data that will be
211:08 - displayed to the user
211:10 - let's make this class a public class
211:12 - let's write code so this class
211:14 - implements the I notify property changed
211:18 - interface
211:19 - we must include a directive to the
211:21 - system.component model namespace the I
211:24 - notify property changed interface is a
211:27 - member of the system.component model
211:29 - namespace
211:31 - so to do this we can hover our Mouse
211:32 - pointers over the red squiggly line
211:34 - click show potential fixes and then
211:36 - click using system.componentmodel
211:40 - this interface contains an event that is
211:42 - key to how we can achieve a loose
211:44 - coupling between the backend components
211:46 - and the uwp front-end component that
211:50 - will soon develop
211:52 - so to implement the I notify property
211:55 - changed interface let's hover our Mouse
211:57 - pointers over the I notify property
212:00 - change to text
212:02 - which has a red squiggly line under it
212:04 - and click show potential fixes and then
212:06 - let's click Implement interface note
212:09 - that a public event named property
212:11 - changed which is defined as the delegate
212:14 - type property changed event handler is
212:17 - generated for us
212:18 - this event will be raised to the front
212:20 - end code when a relevant property value
212:22 - in this class has changed
212:26 - this example is going to be simplistic
212:28 - so that we can focus on the Core
212:29 - Concepts of this video namely how events
212:32 - can be used to achieve a loose coupling
212:34 - between front end and back-end
212:36 - components
212:37 - so let's create a read write property
212:39 - named first name and let's create a
212:41 - private member variable named underscore
212:43 - first name
212:45 - let's encapsulate the underscore first
212:47 - name private member variable within the
212:50 - first name property
212:51 - and within the set accessor of the first
212:54 - name property let's include code to
212:56 - raise the property changed event
212:58 - so if the first name property is changed
213:01 - we want to raise the property changed
213:03 - event
213:04 - which will have the effect of notifying
213:07 - the front-end view presented to the user
213:09 - that the relevant field must be changed
213:11 - on the front-end display so that the
213:14 - change in value of the property is
213:16 - presented to the user
213:18 - and this is a key concept to understand
213:20 - when the view model is changed the event
213:23 - notifies the actual view presented to
213:25 - the user of the change and the change is
213:27 - then reflected in the view presented to
213:30 - the user
213:31 - so the view presented to the user is
213:34 - never directly changed for example by
213:35 - referencing an element of the view
213:37 - presented to the user the underlying
213:40 - view model which is part of the back end
213:42 - code is changed and this change is
213:44 - propagated to the view presented to the
213:47 - user through the implementation of the
213:49 - property changed event we'll demonstrate
213:52 - later on how the uwp front-end component
213:54 - subscribes to the property changed event
213:57 - to receive notifications when a relevant
214:00 - property value changes
214:02 - let's wrap the relevant functionality
214:04 - that raises the property changed event
214:06 - and a private method and let's name this
214:10 - method notify property changed
214:12 - notice that this method accepts a string
214:15 - argument which will contain the name of
214:17 - the property that is changed
214:27 - so now within the set accessor of the
214:31 - first name property let's write codes to
214:34 - call the notify property changed private
214:36 - method for when the first name property
214:38 - is changed
214:39 - and let's create auto implemented
214:42 - properties for the other employee fields
214:45 - ID last name annual salary gender and is
214:50 - manager
214:52 - let's create a class named employees
214:56 - we are going to be storing the employee
214:58 - view model objects in a generic
215:00 - collection type
215:02 - called an observable collection
215:04 - the observable collection type
215:06 - represents a dynamic data collection
215:08 - that provides notifications when items
215:11 - get added removed or when the whole list
215:13 - is refreshed
215:15 - for more information about the
215:17 - observable collection class please
215:19 - navigate to this URL
215:21 - so firstly let's include a directive to
215:23 - the
215:25 - system.collections.object model
215:26 - namespace
215:27 - the generic observable collection class
215:30 - is a member of this namespace
215:32 - this class will simply contain a method
215:34 - that returns a collection of employee
215:36 - records
215:38 - let's create a public method named get
215:40 - employees
215:42 - we want this method to return a
215:44 - collection of employee data so the get
215:47 - employees method returns an object of
215:49 - type observable collection the
215:51 - observable collection is a generic
215:53 - collection type and we are able to
215:55 - strongly type the collection with the
215:57 - employee view model type
215:59 - so let's include code within this method
216:02 - that creates a new observable collection
216:04 - object and assign the relevant object
216:06 - reference to a variable named employees
216:09 - let's write code to return the employees
216:11 - object
216:14 - and I have made up some employee data
216:16 - for our employee view model objects that
216:19 - we can add to the observable collection
216:21 - object we have named employees
216:24 - so to save time let's navigate to a
216:26 - GitHub repository where I have already
216:29 - uploaded the code for this tutorial
216:32 - so please navigate to this URL
216:35 - let's select the relevant code that adds
216:38 - the employee data to the employee's
216:40 - observable collection and appropriately
216:42 - paste it into our code editors
216:46 - we could have written code to retrieve
216:48 - this data from a data source like for
216:50 - example a SQL Server database but in the
216:53 - interests of keeping this code sample
216:55 - simple we are using mock data as a
216:58 - substitute
217:00 - the observable collection object
217:01 - represents a dynamic data collection
217:03 - that provides notifications when items
217:06 - get added removed or when the whole list
217:08 - is refreshed we are going to use our
217:11 - observable collection type which is
217:13 - strongly typed to store objects of type
217:15 - employee view model to bind our
217:18 - collection of employee view model
217:19 - objects to a list view that we'll create
217:22 - in our front-end design when we develop
217:24 - the uwp component
217:28 - okay so let's develop our uwp component
217:32 - so the user interface for a uwp
217:34 - application is created using a
217:36 - declarative markup language named xaml
217:40 - which stands for extensible application
217:41 - markup language
217:43 - we are not going to go into the details
217:45 - of xaml in this tutorial
217:47 - but she has a basic explanation of what
217:49 - xaml is in a uwp application xaml is
217:52 - used to define UI elements data bindings
217:55 - events and other features
217:59 - xaml elements map directly to Common
218:01 - Language runtime object instances while
218:04 - xaml attributes map to Common Language
218:06 - runtime properties and events on those
218:09 - objects
218:11 - for more information on xaml please
218:13 - navigate to the following URL
218:16 - so as mentioned earlier I have already
218:19 - uploaded the relevant code sample to
218:21 - GitHub
218:22 - in the interest of time let's copy the
218:25 - relevant xaml from GitHub and then we'll
218:27 - paste the xaml code over the xaml
218:29 - currently in the main page.xaml file
218:33 - right so let's navigate to this URL
218:35 - let's copy all the xaml code from this
218:37 - page to our clipboards
218:43 - foreign
218:54 - let's paste the xaml code in our
218:57 - clipboards over the xaml code currently
218:58 - in our main page.xaml file and if we
219:02 - look at the xaml code here you can see a
219:04 - blue squiggly line under the code where
219:07 - we are binding a list view data template
219:09 - elements to the employee view model type
219:12 - the reason for the blue squiggly line is
219:14 - because we need to compile the employee
219:17 - component so that our uwp project is
219:19 - referencing the relevant latest compiled
219:22 - assembly
219:23 - so let's compile the employee component
219:31 - and the blue Squiggy line goes away
219:33 - great
219:35 - and we can also see a design view
219:37 - rendering of our xaml code
219:40 - if we take another look at the xaml code
219:42 - you can see that the data binding
219:45 - functionality in the first name field
219:46 - includes a mode attribute which is set
219:49 - to the value of one way
219:51 - this is an important part of the
219:53 - functionality that allows changes to the
219:55 - first name property of our employee view
219:58 - model objects to be reflected in the
220:00 - relevant list view displayed to the user
220:03 - so in our code example here we are
220:05 - demonstrating one-way binding from The
220:07 - View model to the list view element of
220:10 - The View
220:11 - let's write the code and the code behind
220:13 - file named Main page.xaml.cs
220:17 - the code we are going to write here will
220:20 - enable the user to select an employee
220:21 - record from the list view that is
220:24 - created through the xaml code which will
220:26 - contain a collection of employee records
220:30 - the user will then be able to
220:32 - dynamically change the first name field
220:34 - for the selected employee record by
220:37 - typing the new first name value into a
220:39 - text box and clicking a button to
220:41 - confirm the change
220:45 - let's create a member variable named
220:47 - underscore employees OC which is of the
220:50 - observable collection generic collection
220:52 - type and is strongly typed with the
220:54 - employee view model type
221:12 - thank you
221:19 - let's create a public Field named change
221:22 - first name command
221:25 - this is a public field and is defined as
221:28 - the xaml UI command type for more
221:32 - information on the xaml UI command type
221:34 - please navigate to this URL
221:45 - let's write the code in the Constructor
221:47 - of the main page class
221:49 - let's create a new object of type
221:51 - employees
221:53 - so let's take a quick look at the xaml
221:55 - code
221:56 - and you can see here we have a list view
221:58 - named employee list
222:00 - and you can see that there is data
222:02 - binding markup to bind the fields in the
222:04 - list view named employee list to each of
222:07 - the fields to find in our employee view
222:10 - model type so let's go back to the main
222:13 - page.xaml.cs class and let's write code
222:16 - to bind the data stored in the
222:18 - underscore employees OC observable
222:20 - collection object to the employee list
222:23 - list View
222:25 - note that the item Source property in
222:27 - the employee list list view is set to
222:30 - the underscore employees OC observable
222:32 - collection
222:36 - so let's go back to the xaml code notice
222:39 - here we have a button named BTN change
222:42 - first name that contains an attribute
222:45 - named command
222:46 - and this code is binding the BTN change
222:48 - first name button to the public Field
222:51 - named change first name command
222:54 - that we defined as the xaml UI command
222:57 - type in the main page class
222:59 - also notice that the command parameter
223:02 - attribute includes code that binds to
223:04 - the employee list list view element
223:07 - so let's go back to the main
223:09 - page.xaml.cs class and let's create a
223:12 - new xaml UI command object for the
223:14 - change first name command public field
223:16 - and let's use the plus equals operator
223:19 - to subscribe to the execute request
223:21 - event on the change first name command
223:23 - xaml UI command object so after we have
223:26 - typed the plus equals operator we can
223:29 - press the Tab Key and a method with the
223:31 - appropriate method signature is
223:33 - generated for us
223:35 - so when the user clicks the button named
223:37 - BTN change first name the code in this
223:40 - method will be invoked
223:42 - so let's write the code for this method
223:45 - firstly let's write code to get a
223:47 - reference to the employee list list view
223:49 - object
223:51 - we can use the args.parameter property
223:54 - to get a reference to this object
223:57 - we must type cost this object to the
223:59 - list view type
224:00 - then let's write code to check if an
224:03 - item in the list view has been selected
224:05 - If an item has not been selected the
224:07 - selected index property will be negative
224:10 - one so if the selected index property is
224:13 - not negative one we can use the relevant
224:15 - list view object selected index property
224:17 - to index the underlying observable
224:19 - collection object and we want to set the
224:22 - relevant items employee first name field
224:24 - to whatever the user types in the
224:27 - relevant text box
224:29 - if we look at the relevant xaml mock-up
224:31 - code we can see that a text box element
224:34 - is included in our markup this text box
224:37 - can be used to rename a selected
224:39 - employee's first name field to whatever
224:41 - the user types in the relevant text box
224:44 - so let's run the code
224:57 - so the employee list view is not
224:59 - populating
225:00 - let's investigate why this is occurring
225:04 - okay so we haven't included the code to
225:06 - assign the relevant observable
225:08 - collection object named underscore
225:10 - employee OC
225:12 - with a value returned by the employees
225:15 - classes get employees method the get
225:17 - employees method populates the
225:19 - observable collection object with
225:21 - objects of the employee view model type
225:24 - and Returns the relevant observable
225:26 - collection object to the calling code so
225:28 - to fix the issue let's write the code to
225:31 - assign the underscore employee OC
225:33 - variable
225:34 - with a value returned by the
225:36 - employees.get employees method
225:39 - let's run the code again
225:46 - great
225:48 - that has resolved the issue we can see
225:51 - that our list view is populated with
225:53 - employee view model data okay so let's
225:55 - select the third record and in the text
225:58 - box here let's type Bob and then press
226:01 - the button that is wired up to our
226:03 - change first name command object
226:05 - and let's repeat the same process for
226:07 - some of the other employee records
226:14 - great
226:17 - we are now able to change the employee
226:19 - records first name field on the
226:21 - front-end display by updating the
226:23 - underlying observable collection
226:25 - note that the code is not updating the
226:27 - employee list listview object directly
226:30 - when the relevant underlying observable
226:32 - collection has changed an event notifies
226:35 - the employee list list view object of
226:37 - this change and the relevant changes are
226:39 - reflected on the front-end display
226:42 - if we look at the change first name
226:44 - command underscore execute request
226:46 - method that gets invoked when the BTN
226:49 - change first name button is clicked we
226:51 - can see that the underlying observable
226:53 - collection object is changed and the
226:55 - employee list object is not directly
226:57 - changed this highlights the decoupling
227:00 - of the uwp front-end component from the
227:03 - employee component which is responsible
227:05 - for data handling and business rules
227:08 - for example when the first name field
227:09 - was changed for the third employee
227:11 - record the property changed event which
227:14 - is a member of the I notify changed
227:16 - property interface was fired signaling
227:19 - to the front end that there has been a
227:22 - change to the first name field and the
227:24 - relevant employee view model object
227:26 - which must be reflected in the relevant
227:28 - list view front-end object
227:32 - and just for fun let's include code to
227:34 - make our application speak to the user
227:37 - so I've already prepared the code that
227:39 - will make our application talk to us in
227:42 - the relevant GitHub repository
227:48 - so let's navigate to this URL
227:51 - let's copy the speak async method to our
227:53 - clipboards and paste it into the main
227:57 - page.xaml.cs file
227:59 - this method includes an asynchronous
228:01 - method called to the synthesized text to
228:04 - stream async method
228:10 - in order to call the speak async method
228:12 - that we have just included within our
228:14 - code we must appropriately include the
228:16 - async and await keywords
228:25 - I'm also going to make a minor change in
228:27 - that I'm going to rename the underscore
228:29 - employee OC variable to underscore
228:32 - employees OC so that the code we have
228:35 - just created is consistent with the code
228:37 - in the relevant GitHub repository
228:39 - let's run the code
228:42 - foreign
229:02 - first name from Bill to Bob
229:11 - changing first name from Jamie to Dom
229:20 - changing first name from Sally to Debbie
229:24 - excellent
229:26 - so to summarize
229:28 - this code that we have just created
229:30 - shows how the I notify changed interface
229:33 - and the generic observable collection
229:35 - can be implemented to Loosely couple the
229:38 - front-end component from the relevant
229:40 - code within the backend component this
229:43 - loose coupling effect has many
229:45 - advantages which can include reuse of
229:48 - components across disparate platforms
229:50 - for example let's say we have an initial
229:52 - application written to run on multiple
229:54 - windows devices through the use of the
229:57 - appropriate uwp project template and
229:59 - then at a later stage we decide that we
230:02 - want this application to run on IOS and
230:04 - Android platforms
230:06 - the component responsible for the
230:09 - implementation of business rules and
230:10 - data handling written using the standard
230:12 - Library project template can be easily
230:15 - ported to run on the Android and iOS
230:18 - platforms without the need to change the
230:20 - relevant code
230:21 - we do not need to rewrite this code for
230:24 - the Android and iOS platforms
230:27 - separation of concerns allows separate
230:29 - teams to work independently from one
230:31 - another for example the front-end xaml
230:34 - experts or as the case may be the
230:36 - Android and iOS front-end developers
230:38 - could focus on the look and feel of the
230:40 - application and the user experience of
230:43 - the application while not having to
230:45 - worry about the details of the business
230:47 - rules and the database handling
230:48 - functionality a separate team that
230:51 - specializes in writing the business
230:52 - rules and database related functionality
230:55 - can focus on this concern without
230:57 - worrying about the implementation detail
230:59 - of the front-end design
231:01 - the front end and back-end functionality
231:04 - can evolve independently from one
231:05 - another and in parallel to one another
231:08 - the front-ended back-end components can
231:10 - then be seamlessly integrated with one
231:12 - another at an appropriate time
231:14 - I hope you have enjoyed this tutorial on
231:16 - events raised through user actions in
231:19 - the context of a uwp application uwp is
231:22 - a very powerful platform that can be
231:25 - used for creating Rich user interfaces
231:27 - that can run on multiple windows devices
231:30 - examples of related Windows specific
231:32 - Frameworks include WPF or Windows
231:35 - presentation foundation and win forms
231:38 - if you want to learn more about WPF
231:40 - please navigate to this URL
231:42 - and if you want to learn more about
231:44 - winforms please navigate to this URL for
231:47 - more content on advanced c-sharp
231:49 - concepts and much more please consider
231:51 - subscribing and please ring the bell so
231:53 - that you'll be notified of new releases
231:55 - from this channel
231:56 - if you feel you've gained value from
231:58 - viewing this video please hit the like
232:00 - button and please feel free to share any
232:02 - of the videos released from this Channel
232:04 - with anyone you feel May benefit from
232:06 - their content as always the code created
232:08 - in this video can be downloaded from
232:10 - GitHub a link to the relevant repository
232:12 - has been included Below in the
232:14 - description thank you and take care
232:18 - [Music]
232:28 - hi and welcome to the fourth part of
232:31 - this tutorial on c-sharp events
232:34 - this video is also part of a tutorial
232:37 - that serves as the fourth part of an
232:39 - advanced c-sharp course
232:41 - in this video we'll focus on the
232:44 - Observer design pattern
232:46 - this is a very powerful design pattern
232:48 - and is suitable for any scenario that
232:51 - requires push-based notifications
232:55 - the implementation of the Observer
232:57 - design pattern entails subscribers
232:59 - registering to receive notifications
233:01 - from a provider push notifications
233:04 - simply means that the notifications are
233:08 - sent pushed from a central point to the
233:11 - relevant subscribers
233:13 - the source of the push notifications is
233:15 - known as the provider also known as the
233:18 - observable
233:20 - observers register with the provider in
233:23 - other words subscribe to the provider
233:25 - and whenever a predefined condition
233:27 - event or state change occurs one of the
233:30 - observer's methods is called by the
233:32 - provider
233:33 - in this method call the provider can
233:36 - also provide current state information
233:38 - to observers
233:41 - so note that the observable can also be
233:43 - referred to as the provider and
233:45 - observers can also be referred to as
233:48 - subscribers
233:49 - so I'll be using these terms
233:50 - interchangeably throughout this tutorial
233:54 - for more content like this on advanced
233:56 - c-sharp concepts and much more please
233:57 - consider subscribing and please ring the
233:59 - bell so that you'll be notified of
234:01 - future releases from this channel
234:04 - in.net the implementation of the
234:06 - Observer design pattern can be achieved
234:08 - when the subscribers class or observers
234:10 - implement the genericsystem.i Observer
234:14 - generic interface and the provider class
234:16 - implements the system.observable generic
234:19 - interface the generic type represented
234:22 - here with the capital T represents the
234:25 - type which can be a user-defined type
234:27 - that encapsulates the notification
234:29 - information communicated from the
234:31 - provider to its subscribers through push
234:33 - notifications so the generic type
234:36 - represented by the capital letter T in
234:38 - the interface definitions of both the
234:40 - provider class and the subscriber
234:42 - classes is key to how loose coupling
234:44 - between provider and subscribers can be
234:47 - facilitated while still enabling rich
234:49 - and extensible data to be pushed from
234:52 - providers to subscribers
234:54 - the system.i observable and system.i
234:57 - observer built-in.net generic interfaces
235:00 - enable this pattern to be reused for
235:03 - multiple scenarios
235:04 - the generic type represented by the
235:07 - capital T allows for users to find types
235:10 - to serve as communication vehicles that
235:12 - can be extended without breaking the
235:14 - design of the relevant application
235:19 - so let's look at a quasi-real world
235:21 - example that can be used to explain the
235:23 - Observer design pattern and give us an
235:26 - idea of when it is appropriate to use
235:28 - this design pattern so we'll have to use
235:30 - our imaginations a bit to Picture This
235:33 - example
235:34 - let's say a particular company owns a
235:36 - building with an automated security
235:38 - system
235:39 - one of the functions of the security
235:41 - system is to identify external visitors
235:44 - arriving at the building for example to
235:46 - have a business meeting with one of the
235:48 - employees that work inside the building
235:51 - so the process first involves the
235:53 - external visitor registering to visit
235:55 - the relevant employee on a particular
235:57 - day
235:58 - let's say that before an external
236:00 - visitor arrives at the building for the
236:02 - relevant visit
236:04 - the external visitor must first register
236:06 - and during the registration process
236:08 - provide a clear photograph of the
236:11 - external visitors face as part of the
236:14 - registration process
236:16 - so when the external visitor arrives on
236:19 - the day of the visit and attempts to
236:21 - enter the building a camera first scans
236:23 - the external visitors face and
236:25 - subsequently sends the relevant
236:27 - pictorial facial information to a system
236:30 - whereby biometric artificial
236:32 - intelligence algorithms are applied to
236:35 - ascertain whether this particular visit
236:37 - can be authenticated I.E has this person
236:41 - registered and if so can this person be
236:44 - verified as the person the person claims
236:46 - to be
236:47 - so this is essentially an automated
236:49 - authentication process
236:51 - once the relevant visitor has been
236:54 - identified the visitors automatically
236:56 - given access to the building this
236:58 - triggers notifications to be sent to the
237:01 - building's security team and any
237:03 - internal staff members I.E employees of
237:06 - the company that owns the relevant
237:07 - building who have subscribed to receive
237:09 - notifications regarding the relevant
237:12 - actions of the external visitors the
237:15 - information that is sent to the
237:16 - subscribers I.E the notification data
237:19 - sent from the provider contains
237:21 - information about the relevant external
237:23 - visitor and the time the relevant
237:25 - external visitor gained access to the
237:27 - building and then subsequently once the
237:30 - visit is completed a notification is
237:32 - sent when the external visitor exits the
237:35 - building another notification will be
237:37 - sent to All subscribers from the
237:39 - provider when a predefined time is
237:42 - reached and all external visitors have
237:44 - exited the building for example the
237:46 - predefined time could be 6 pm which has
237:50 - been deemed the end of the Working Day
237:52 - for the relevant company the rule could
237:54 - be that after this time no external
237:56 - visitors can gain access to the relevant
237:58 - building in this example we'll refer to
238:01 - this time as the cut-off time
238:05 - okay so as I've said we need to use our
238:08 - imaginations of birch here because we
238:11 - are going to implement code for the
238:12 - scenario just described within a
238:15 - consoleapp.net core framework in other
238:18 - words the code will be highly simplified
238:20 - so that we can focus on understanding
238:22 - The Observer design pattern
238:25 - so the provider in this example will be
238:29 - the security surveillance system used to
238:31 - identify external visitors that have
238:33 - registered to visit a member of Staff
238:35 - within the relevant building on a
238:37 - particular day
238:39 - this example will contain two types of
238:41 - subscribers one of the types of
238:43 - subscribers that we will create will
238:45 - represent the security team they must be
238:48 - notified of all significant movements of
238:51 - external visitors for example entering
238:53 - and exiting the building
238:55 - the other type of subscriber will
238:57 - represent any individual internal staff
238:59 - member who has subscribed to receive
239:01 - relevant notifications regarding
239:03 - external visitors
239:05 - this employee would subscribe because a
239:07 - visitor must have a point of contact
239:09 - inside the building in order to
239:11 - successfully register as an external
239:13 - visitor
239:14 - when the external visitor is
239:16 - authenticated on the day of the visit a
239:18 - notification will be sent to the
239:20 - security team as well as any employee
239:23 - who is registered as the point of
239:25 - contact for the relevant external
239:27 - visitor
239:29 - okay let's look at an overview of the
239:31 - main classes that will be created for
239:33 - this example
239:35 - so here is a class that represents the
239:37 - observable this class will represent a
239:40 - central place where surveillance data is
239:42 - processed
239:43 - we'll create two classes that represent
239:46 - two types of Observer the first class
239:50 - represents an employee I.E a person that
239:53 - works inside the relevant building who
239:54 - wants to be notified when a particular
239:57 - external visitor enters the building
239:58 - this class is named employee notify the
240:02 - second class represents the security
240:04 - team who must be notified when any
240:07 - external visitor enters or exits the
240:10 - relevant building this class is named
240:12 - security notify we have a class here
240:15 - named external visitor which represents
240:17 - an outside visitor to the relevant
240:19 - building
240:21 - this class serves as a generic type
240:23 - argument to both the I observable
240:25 - generic interface implemented by the
240:28 - observable class as well as the generic
240:30 - arguments to the I Observer generic
240:33 - interface which is implemented by The
240:35 - Observer classes
240:37 - so this class allows data about the
240:40 - external visitor to be communicated from
240:42 - the observable object to its Observer
240:45 - objects when the relevant notifications
240:47 - are sent
240:50 - we have an eye employee interface and an
240:52 - employee class that implements the I
240:55 - employee interface
240:57 - the employee class provides a way to
240:59 - store details about an employee who
241:01 - works inside the relevant building this
241:04 - class represents the employee details of
241:06 - a person who serves as a point of
241:08 - contact for an external visitor
241:10 - an employee object is passed into the
241:13 - Constructor of the employee notify class
241:15 - during the instantiation of an object
241:18 - derived from the employee notify class
241:20 - so in summary here are our main classes
241:23 - employee notify and observer class
241:25 - security notify and observer class
241:29 - security surveillance hub
241:32 - the observable class I employee and
241:36 - interface defining and internal staff
241:38 - member record
241:39 - employee a class that implements the I
241:43 - employee interface so it represents an
241:45 - employee record
241:47 - external visitor a class representing
241:50 - the person that has registered to visit
241:52 - a member of staff that works inside the
241:55 - relevant building
241:56 - this class represents a person that must
241:58 - be authenticated on the day of the
242:01 - relevant visit
242:04 - let's look at the class that will serve
242:06 - as our observable class we'll name this
242:09 - class security surveillance hub
242:14 - this class represents a central location
242:16 - where surveillance system information is
242:19 - processed
242:20 - and will be responsible for notifying
242:22 - subscribers with the relevant
242:23 - information about an external visitor
242:26 - so notifications will be sent to the
242:28 - relevant observers when an external
242:30 - visitor enters the building and another
242:32 - notification will be sent to the
242:34 - relevant observers when an external
242:36 - visitor exits the building
242:39 - firstly let's answer the question how
242:41 - can we Implement a class so that it can
242:44 - be instantiated as an observable object
242:47 - the answer to that question is that a
242:49 - class that will be instantiated as an
242:52 - observable object must implement the eye
242:54 - observable generic interface the eye
242:57 - observable generic interface is a
242:59 - built-in.net interface that is a member
243:02 - of the system namespace
243:04 - the next question is what makes the
243:07 - observable interface a generic interface
243:09 - the I observable interface is generic
243:12 - because the calling code is able to pass
243:14 - a type as a generic argument to a class
243:17 - that implements the eye observable
243:18 - generic interface
243:21 - in our example the type that will pass
243:23 - as the relevant's generic type argument
243:25 - will be a user-defined type named
243:28 - external visitor
243:30 - as you may have guessed this class will
243:32 - represent an external visitor
243:35 - we'll discuss the external visitor class
243:37 - in more detail a bit later
243:39 - the I observable generic interface
243:41 - contains one method definition this
243:44 - method definition is for a method named
243:46 - subscribe the Subscribe method contains
243:49 - one parameter of a type that implements
243:51 - the I Observer generic interface so this
243:54 - parameter is defined as an observer type
243:58 - we'll discuss the I Observer generic
244:01 - interface a little bit later so the
244:03 - Subscribe method must be implemented by
244:06 - the type that implements the I
244:08 - observable generic interface
244:10 - the implementation of the Subscribe
244:12 - method must contain functionality that
244:15 - is executed when an observer subscribes
244:17 - to receive notifications from the
244:20 - relevant observable object
244:22 - so we've now looked at the essence of
244:24 - what we are trying to achieve here by
244:27 - implementing The Observer design pattern
244:29 - let's get started and create the code
244:31 - example let's create a Project based on
244:34 - the consoleapp.net core project template
244:55 - let's name this project and solution
244:57 - building surveillance system application
245:13 - so for our first class let's create a
245:16 - class that represents the external
245:17 - visitor
245:18 - this class represents the information
245:20 - about an external visitor that will be
245:23 - sent to the relevant subscribers when an
245:25 - external visitor enters the building and
245:27 - subsequently exits the building once the
245:30 - external visitor completes the external
245:31 - visitors visit
245:33 - so let's create a public class and name
245:36 - it external visitor let's create the
245:39 - properties for the external visitor
245:40 - class so let's create a property for ID
245:43 - defined as int first name defined as
245:46 - string last name defined as string
245:48 - company name defined as string job title
245:52 - defined as string entry date time
245:54 - defined as date time this property will
245:56 - store the date and time of when the
245:58 - relevant external visitor entered the
246:00 - building exit date time defined as date
246:03 - time this property will store the date
246:04 - and time of when the relevant external
246:07 - visitor exited the building
246:09 - and lastly an auto-implemented property
246:11 - named employee contact ID and let's
246:14 - define this property as int this
246:17 - property facilitates the storage of the
246:19 - ID of the internal employee I.E an
246:22 - employee who works within the building
246:24 - responsible for being the point of
246:26 - contact for an external visitor on the
246:29 - relevant day of the external visitors
246:31 - visit great and that is our external
246:33 - visitor class
246:35 - so let's create our observable class
246:38 - let's create a public class named
246:40 - security surveillance Hub as explained
246:43 - earlier this class serves as a metaphor
246:45 - for a central location where security
246:47 - related information is processed so for
246:50 - example an external visitor's face is
246:52 - scanned before gaining access to the
246:54 - building and this pictorial information
246:56 - is subsequently sent to the security
246:58 - surveillance Hub where the biometric
247:00 - information and the relevant image is
247:03 - compared against registered image
247:05 - information captured when the external
247:07 - visitor registered to visit the building
247:09 - so if the two pieces of information
247:11 - match the visitor is granted access to
247:14 - the building which will trigger
247:16 - notification information about the
247:18 - external visitor to be sent to the
247:20 - relevant Observers
247:22 - so as discussed earlier in order for
247:24 - this class to represent our observable
247:26 - it must implement the I observable
247:29 - generic interface
247:31 - so let's write the code to do this and
247:33 - let's pass in the external visitor type
247:35 - as our generic type argument what makes
247:38 - the eye observable interface a generic
247:40 - interface
247:42 - it is a generic interface because we are
247:44 - able to strongly type the I observable
247:46 - interface the capital T within less than
247:49 - and greater than symbols in the eye
247:51 - observable interface definition means
247:53 - that we are able to replace the T with
247:56 - our c-sharp type
247:58 - when this is done it means we have
248:00 - strongly typed our generic interface so
248:03 - let's strongly type the I observable
248:04 - interface with our external visitor
248:06 - class like this
248:09 - generics allows us to stipulate a
248:12 - particular type for the relevant type
248:14 - placeholder at compile time
248:17 - note that a capital t is commonly used
248:19 - to represent the generic type
248:21 - placeholder
248:23 - generic functionality can also be
248:25 - accomplished through the use of the.net
248:27 - system.object type as we know all types
248:30 - in c-sharp ultimately inherit from the
248:33 - system.object type
248:35 - so we are able to type cost a variable
248:37 - at runtime to any managed.net type the
248:41 - advantage of using generics for the same
248:43 - purpose is that we can achieve the same
248:46 - functionality but this is done at
248:48 - compile time
248:50 - this provides the advantage of compile
248:52 - time type checks ensuring type safety as
248:56 - well as results in Greater performance
248:58 - for our code because we are able to omit
249:01 - the need for runtime typecasting
249:03 - typecasting which is performed at
249:06 - runtime also carries the risk of
249:08 - incurring runtime errors
249:11 - please don't worry if you didn't
249:12 - understand this brief explanation of why
249:14 - generics is significant generics will be
249:17 - discussed in detail in upcoming
249:19 - tutorials so let's develop the security
249:21 - surveillance Hub class
249:24 - so you can see that there is a red
249:25 - squiggly line under the eye observable
249:27 - text and the class definition this is
249:30 - the c-sharp compiler letting us know
249:32 - that we have not yet implemented code
249:34 - for the member definitions of the I
249:36 - observable generic interface in the
249:39 - security surveillance Hub class
249:45 - so let's hover our Mouse pointers over
249:47 - the red squiggly line click show
249:48 - potential fixes and click Implement
249:51 - interface as you can see there is only
249:54 - one method definition in the I
249:56 - observable interface that we must
249:58 - Implement in the security surveillance
250:00 - Hub class this method is named subscribe
250:04 - notice how the Subscribe method
250:06 - definition contains a parameter of type
250:08 - I Observer and the I Observer parameter
250:11 - type definition is automatically
250:13 - strongly typed with the type definition
250:15 - with which we have already strongly
250:17 - typed the I observable interface
250:21 - so we have strongly typed the I
250:22 - observable interface with the external
250:24 - visitor type and this has propagated to
250:27 - the Subscribe method definition when we
250:30 - automatically generated the method
250:32 - definition that is contained in the I
250:34 - observable generic interface I.E the
250:37 - Subscribe method definition
250:39 - this is a key concept to understand when
250:41 - understanding how we are able to use the
250:43 - I observable and I observe a generic
250:46 - interfaces to implement the Observer
250:48 - design pattern
250:50 - the generic type gives us a means for
250:53 - creating a loose coupling between the
250:55 - observable component and the relevant
250:57 - Observer components
250:59 - the generic type both defined in the I
251:01 - observable and I Observer interfaces
251:04 - allows the developer to strongly type
251:07 - these two interfaces with a common type
251:09 - in this example we are strongly typing
251:12 - these two interfaces with the external
251:15 - visitor user-defined type
251:17 - this will become clearer as we develop
251:19 - this example application
251:22 - right let's implement the code for the
251:24 - security surveillance Hub class
251:27 - so let's create two member variables
251:29 - both of these member variables are of
251:31 - the generic list type
251:33 - let's define the first one and name it
251:36 - underscore external visitors
251:39 - as the name suggests this list will
251:42 - store a list of external visitors
251:44 - when an external visitor gains access to
251:47 - the building the external visitor is
251:49 - added to the underscore external
251:51 - visitors list
251:53 - and you can see that we are strongly
251:54 - typing the underscore external visitors
251:57 - list with the external visitor user
251:59 - defined type
252:02 - let's include a directive to the
252:05 - system.collections.generic namespace
252:07 - the second generic list we need to
252:09 - Define will store a list of observers so
252:12 - this list will contain objects that are
252:14 - derived from the I Observer generic type
252:17 - that is strongly typed with the external
252:19 - visitor user defined type
252:21 - let's name this generic list variable
252:23 - underscore Observers
252:27 - so when an observer subscribes to
252:29 - receive notifications from the
252:31 - observable
252:32 - the relevant Observer is added to the
252:34 - underscore observers list conversely if
252:37 - an observer unsubscribes the relevant
252:39 - Observer is removed from the underscore
252:41 - observers list
252:46 - so the Subscribe method will be the last
252:48 - method that we will Implement as
252:51 - discussed the Subscribe method has to be
252:53 - implemented because it is a member of
252:55 - the I observable generic interface which
252:57 - the security surveillance Hub class
252:59 - implements
253:01 - for now let's create a public method
253:03 - that gets called when an external
253:06 - visitor gains access to the building
253:07 - let's name this method confirm external
253:10 - visitor enters building
253:12 - this method's parameters contains
253:14 - relevant information associated with an
253:16 - external visitor namely ID defined as
253:19 - int first name defined as string last
253:22 - name defined as string company name
253:25 - defined as string job title defined as
253:28 - string entry date time defined as date
253:31 - time and employee contact ID defined as
253:35 - int then we can write the functionality
253:37 - to instantiate an external visitor
253:39 - object and set the properties of the
253:42 - object we have derived from the external
253:44 - visitor user defined type with the
253:46 - values that will be passed as arguments
253:49 - to the confirm external visitor enters
253:51 - building method
253:54 - then let's write the code to add the
253:56 - newly created external visitor object to
253:59 - the underscore external visitors list
254:03 - as mentioned the underscore observers
254:06 - list is populated with observers
254:07 - observers are of course objects that
254:09 - have subscribed to be notified when
254:11 - certain conditions are met for example
254:13 - an external visitor entering the
254:15 - building
254:17 - so this method represents an external
254:19 - visitor entering the building the
254:21 - visitor has been authenticated and is
254:23 - automatically given access to the
254:25 - building
254:26 - so let's use our imaginations and let's
254:28 - say that when an external visitor enters
254:31 - the building the framework in which our
254:33 - observable exists invokes the confirm
254:36 - external visitor enters building method
254:38 - the observable can Now notify all
254:40 - subscribers of this event as well as
254:43 - send the relevant data pertaining to the
254:45 - event to all the relevant subscribers
254:48 - in this particular example the relevant
254:50 - data is encapsulated with the external
254:53 - visitor object which is derived from the
254:55 - external visitor class
254:57 - remember the I Observer generic
255:00 - interface is strongly typed with the
255:02 - external visitor user defined type which
255:04 - makes it easy to send the data to the
255:07 - relevant Observer objects
255:09 - the relevant Observer objects are stored
255:11 - within the underscore observers list
255:14 - so in order to notify the relevant
255:16 - observers with the relevant data we can
255:19 - write code to Traverse the underscore
255:20 - observers list and call each Observer
255:23 - objects on next method note that when we
255:27 - call each Observer objects on next
255:29 - method we are passing the relevant
255:31 - external visitor object as an argument
255:33 - to the on next method this is how each
255:36 - Observer receives notification data
255:38 - whenever the relevant event occurs
255:42 - in this example the relevant event is an
255:44 - external visitor gaining access to the
255:46 - relevant building
255:48 - so how does the observable I.E and
255:50 - object derived from the current class we
255:53 - are creating know that an observer
255:55 - object implements a method named on next
255:58 - and even further to that how does the
256:00 - relevant observable object know that the
256:03 - on next method accepts an argument of
256:05 - type external visitor
256:07 - this is at the heart of how the Observer
256:09 - pattern Works in c-sharp each Observer
256:12 - object is derived from a class that
256:14 - implements the I Observer generic
256:16 - interface if we look at the definition
256:18 - for the I Observer interface we see
256:21 - three method definitions namely on next
256:24 - on error and on completed the on next
256:28 - method contains a parameter of a generic
256:30 - type
256:31 - so when we create an observer class a
256:33 - bit later we'll strongly type the I
256:35 - Observer interface that our class must
256:38 - Implement with the external visitor user
256:40 - defined type this action will mean that
256:43 - the on next method will be strongly
256:45 - typed with the external visitor
256:47 - user-defined type so the external
256:50 - visitor type becomes a common
256:51 - communication facility between the
256:54 - observable and the relevant Observers
256:57 - so the fact that we know that each
256:59 - Observer implements the I Observer
257:00 - generic interface means we know that
257:03 - each Observer object implements a method
257:05 - named on next
257:07 - the fact that the I Observer interface
257:09 - for each Observer class is strongly
257:11 - typed with the external visitor
257:13 - user-defined type means that we know the
257:16 - type of the argument that needs to be
257:18 - passed into the our next method
257:22 - the I Observer generic interface
257:24 - contains a definition for a method named
257:26 - on error this allows for the observable
257:29 - to notify relevant Observer objects if
257:32 - an exception occurs
257:34 - and also provides information about the
257:36 - exception through the built-in exception
257:39 - type
257:40 - we are not going to implement custom
257:42 - functionality for the on error method in
257:44 - this example each Observer object must
257:47 - however Implement code for the on error
257:50 - method because the definition for the
257:52 - method is contained within the I
257:54 - Observer generic interface
257:57 - the last method that we need to talk
257:59 - about is the uncompleted method
258:01 - so we will be implementing custom code
258:03 - for the uncompleted method in this
258:05 - example
258:07 - the uncompleted method does not contain
258:09 - any parameters the uncompleted method
258:12 - notifies The Observers that the
258:14 - observable has finished sending
258:16 - notifications so this method should be
258:19 - called for each Observer when a
258:22 - condition is met whereby no more
258:24 - notifications need to be sent to the
258:25 - relevant Observer objects in this
258:28 - example the uncompleted method will be
258:31 - called on all Observer objects within
258:33 - the underscore observers list when the
258:36 - relevant cutoff time has been reached on
258:39 - a particular day and all external
258:41 - visitors have exited the building the
258:43 - cutoff time could be for example
258:45 - designated as 6 pm
258:48 - there may be external visitors who
258:50 - exceed this time constraint due to for
258:52 - example a meeting that goes on for
258:54 - longer than expected or something of
258:56 - that nature so two conditions need to be
258:58 - met for the uncompleted method to be
259:01 - invoked a certain time in the day is
259:03 - reached for example 6 pm and all
259:05 - external visitors have exited the
259:07 - building
259:09 - so next let's Implement a method that is
259:12 - called when an external visitor exits
259:14 - the building
259:15 - so let's name this method confirm
259:17 - external visitor exits building
259:19 - this method is a public method that
259:21 - contains two parameters one parameter
259:24 - which is a value that serves as a unique
259:26 - identifier for an external visitor
259:29 - it is defined as the int data type
259:34 - the other parameter is named exit date
259:36 - time and as the name suggests this
259:38 - parameter denotes the date and time when
259:40 - an external visitor exits the building
259:43 - so firstly let's write code to find the
259:46 - external visitor within the underscore
259:48 - external visitors list
260:07 - foreign
260:13 - if the external visitor is not now I.E
260:16 - the external visitor is found within the
260:19 - underscore external visitors list let's
260:21 - write code to update the relevant
260:23 - external visitor objects exit date time
260:26 - property to the date and time when the
260:29 - external visitor exited the building
260:33 - let's then write code to Traverse the
260:35 - underscore observers list and call each
260:37 - observers on next method and pass an
260:41 - argument to the on next method of the
260:43 - relevant external visitor object to
260:45 - notify The Observers that a specific
260:48 - external visitor has exited the building
260:53 - so let's create another public method
260:55 - that will be called when the cut-off
260:57 - time is reached so by cut off time I
261:00 - mean this is a time after which external
261:03 - visitors are not allowed to enter the
261:05 - building so we need to use our
261:07 - imaginations for some of these methods
261:09 - because we are basically saying that
261:11 - this method is called when certain
261:13 - conditions are met in this case when a
261:16 - certain time in the day is reached just
261:18 - like for example when the external
261:20 - visitor enters the building the confirm
261:22 - external visitor enters building method
261:24 - is invoked or when the external visitor
261:26 - exits the building the confirm external
261:29 - visitor exits building method is invoked
261:34 - so let's create a public method that
261:36 - will be executed when the visitor cutoff
261:38 - time is reached let's name this method
261:41 - building entry cut off time reached
261:43 - so this method is called at a particular
261:46 - time but we only want to call each
261:48 - observer's on completed method if all
261:51 - external visitors have left the building
261:53 - the fact that the uncompleted method is
261:56 - called means that no further
261:58 - notifications will be sent from the
262:00 - observable object to the Observer
262:02 - objects for a particular day
262:05 - so we are going to use the Link
262:06 - Technology to check if any external
262:10 - visitor objects exist within the
262:12 - underscore external visitors list
262:16 - but first i'm going to extend the
262:18 - external visitor class to include a
262:20 - property named inbuilding this property
262:22 - is of type Boolean and we can set this
262:25 - property according to the external
262:27 - visitors current location
262:29 - so we want to set the inbuilding
262:30 - property value to True when we confirm
262:33 - external visitor enters building method
262:35 - is invoked conversely we want to set the
262:37 - inbuilding property value to false when
262:40 - a confirm external visitor exits
262:42 - building method is invoked
262:49 - so we can now use the inbuilding
262:51 - property value to check if there are
262:54 - still external visitors left inside the
262:56 - building after the cutoff time has been
262:58 - reached
262:59 - if you don't fully understand this code
263:01 - don't worry link will be discussed in
263:03 - detail in upcoming tutorials as part of
263:05 - the c-sharp advanced course
263:08 - if the count of external visitor objects
263:11 - within the underscore external visitors
263:13 - list that have their in-building
263:15 - property values set to True is equal to
263:17 - zero this means that the cut of time has
263:19 - been reached and all external visitors
263:22 - have exited the building so we can now
263:24 - call the uncompleted method on all the
263:27 - Observer objects that are currently in
263:30 - our underscore observers list
263:32 - by calling the uncompleted method on
263:34 - these Observer objects this is notifying
263:37 - the relevant observers that no further
263:39 - notifications will be sent
263:42 - okay let's implement the Subscribe
263:44 - method so notice that the Subscribe
263:46 - method contains a parameter of type I
263:49 - observable which is a generic interface
263:52 - the implementation of the I observable
263:54 - generic interface in this class I.E the
263:57 - security surveillance Hub class is
264:00 - strongly typed with the external visitor
264:02 - user defined type
264:04 - so this is automatically propagated
264:06 - through to the Subscribe method
264:07 - definition where the I Observer generic
264:10 - interface is also strongly typed with
264:12 - the external visitor user defined type
264:16 - note that when an observer object
264:18 - subscribes to the observable object The
264:20 - Observer object passes a reference to
264:23 - itself into the Subscribe method though
264:26 - this keyword can be used for the purpose
264:28 - of referencing an object derived from
264:30 - the class in which that this keyword is
264:32 - implemented we'll implement this code
264:34 - when we create the Observer classes in a
264:37 - bit
264:38 - for now let's implement the code for the
264:40 - Subscribe method
264:41 - and the code for this method is pretty
264:43 - simple we first check if the Observer
264:46 - object exists within the underscore
264:48 - observers collection if the Observer
264:51 - object does not exist within the
264:53 - underscore observers list this means
264:55 - that a new Observer object is
264:57 - subscribing so we can write code here to
265:00 - add the Observer object to the
265:02 - underscore observers list which means
265:04 - that the relevant Observer is now
265:06 - subscribed
265:08 - the subsequent lines of code reverse all
265:10 - the external visitor objects within the
265:12 - underscore external visitors list and
265:14 - notifies the new Observer object of the
265:17 - current information related to external
265:20 - visitors that exist within the
265:22 - underscore external visitors list
265:25 - now notice that the Subscribe method
265:27 - returns a type that must implement the
265:30 - built-in eye disposable interface
265:34 - so we are now going to create a class
265:36 - named unsubscriber and this class will
265:39 - implement the eye disposable interface
265:42 - as the name suggests the purpose of the
265:44 - unsubscriber class is to provide a
265:47 - facility for the Observer objects to
265:49 - unsubscribe to the observable object I.E
265:52 - to elect to no longer receive
265:54 - notifications from the relevant
265:56 - observable object the unsubscriber class
265:59 - implements the built-in I disposable
266:02 - interface which contains a definition
266:04 - for a method named dispose when an
266:07 - observer object calls the dispose method
266:09 - this action causes the relevant Observer
266:12 - object to unsubscribe from the relevant
266:15 - observable object
266:17 - so you can see that the Subscribe method
266:19 - in the observable class in this case the
266:22 - observable class is the class named
266:24 - security surveillance Hub allows for an
266:27 - observer object to subscribe to the
266:29 - relevant observable object
266:31 - the Subscribe method returns a reference
266:34 - to the relevant unsubscriber object
266:37 - which is derived from the class that we
266:39 - are about to create I.E the unsubscriber
266:42 - class
266:43 - that implements the eye disposable
266:45 - interface
266:48 - The Observer object can simply call the
266:51 - dispose method which is a member of the
266:53 - eye disposable interface to unsubscribe
266:56 - to the relevant observable object
266:59 - the built-in eye disposable interface is
267:01 - a member of the system namespace
267:04 - let's create the unsubscriber class
267:07 - as mentioned the unsubscriber class
267:10 - implements the eye disposable interface
267:12 - which contains a method definition for a
267:14 - method named dispose so let's create the
267:17 - class definition for the unsubscriber
267:19 - class
267:21 - let's indicate that we wish to implement
267:23 - the eye disposable interface
267:25 - let's ensure that we are implementing
267:27 - all the members of the I disposable
267:29 - interface the eye disposable interface
267:31 - contains one member a method named
267:33 - dispose
267:34 - let's create the Constructor you can see
267:37 - that this Constructor contains two
267:39 - parameters the first parameter is a list
267:41 - that contains Observer objects the
267:44 - second parameter is an observer object
267:47 - so the functionality for this class is
267:49 - literally just to remove the past in
267:52 - observer object from the relevant
267:54 - observers list
267:56 - so let's create two member variables
267:59 - these member variables will be
268:01 - appropriately assigned to the passed in
268:02 - arguments to the Constructor
268:04 - then the logic within the dispose method
268:06 - is simply to check if the relevant
268:08 - Observer object exists within the
268:10 - relevant observers list
268:12 - if it does remove the relevant Observer
268:15 - object from The Observers list
268:18 - the result of this action is that the
268:20 - relevant Observer is unsubscribed from
268:23 - the relevant observable object and will
268:25 - therefore no longer receive
268:27 - notifications from the observable object
268:30 - so let's go back to the Subscribe method
268:33 - in the security surveillance Hub class
268:36 - and let's return a new unsubscriber
268:39 - object derived from the user-defined
268:42 - type that we have just created
268:46 - note that the construction of the
268:48 - unsubscriber object entails passing a
268:51 - reference to the relevant Observer and a
268:54 - list of all observers currently
268:56 - subscribed
268:57 - okay so we have now written the code for
269:00 - the observable object the class that
269:02 - defines the observable object is the
269:04 - security surveillance Hub class
269:07 - so we can now create the classes that
269:10 - will represent our Observer objects
269:14 - we are going to create two classes which
269:16 - represent two types of Observer objects
269:20 - the first tab we'll create is a class
269:22 - named employee notify
269:24 - this class will represent an employee a
269:27 - staff member that works in the building
269:29 - that has been designated as the contact
269:32 - point for an external visitor
269:36 - so this employee wants to know when the
269:39 - relevant external visitor has entered
269:41 - the building so that the employee can
269:43 - welcome the relevant external visitor at
269:45 - the entrance of the building
269:48 - the second type or class will represent
269:50 - the security team
269:52 - which must receive details of the
269:55 - external visitor when the external
269:57 - visitor enters the building and later
270:00 - exits the building
270:03 - so let's first create code for the
270:05 - employee notify class
270:07 - this class is an observer so it must
270:09 - implement the generic I Observer
270:11 - interface
270:13 - we also need to strongly type the I
270:15 - Observer generic interface with the
270:17 - external visitor type
270:20 - so one way we can automatically generate
270:22 - the definitions for the members of the I
270:25 - Observer interface that we must
270:27 - Implement is to hover our Mouse pointers
270:29 - over the red squiggly line under the I
270:31 - Observer generic interface text within
270:34 - our class definition and click show
270:37 - potential fixes and then click Implement
270:39 - interface
270:41 - and visual studio automatically
270:42 - generates default implementations for
270:45 - three methods the method definitions for
270:48 - these three methods are members of the I
270:51 - Observer generic interface
270:54 - the red squiggly line disappears because
270:56 - we now have implementations for the
270:59 - members contained in the I Observer
271:01 - generic interface
271:03 - so in a bit we'll Implement more useful
271:06 - code for these methods
271:08 - before we create a Constructor for this
271:10 - class I want to create a definition for
271:12 - an employee record
271:14 - let's create an interface named I
271:16 - employee
271:17 - we'll keep the employee record really
271:19 - simple so let's create definitions for
271:22 - just four properties ID as int first
271:26 - name as string last name as string and
271:29 - job title as string let's create a class
271:32 - named employee that implements the I
271:34 - employee interface
271:42 - so let's go back to the employee notify
271:45 - class and create the Constructor for
271:47 - this class
271:49 - so when an object is Created from the
271:51 - employee class we want an employee
271:54 - object to be passed into the Constructor
271:56 - of the employee notify class
272:00 - so let's include a parameter of the I
272:02 - employee type within the Constructor
272:04 - definition
272:06 - we want to adhere to solid principles
272:08 - the last letter in the solid acronym is
272:12 - dependency inversion principle which
272:14 - states that classes should not depend on
272:17 - concrete implementations but should only
272:19 - depend on abstractions
272:22 - this is why the parameter within this
272:23 - Constructor is defined with an interface
272:26 - type rather than a class
272:28 - so we are defining this parameter of
272:31 - type I employee rather than of type
272:33 - employee
272:35 - very basically solid is an acronym
272:37 - representing a set of principles that
272:40 - are design principles that can be
272:41 - followed in order for a programmer to
272:43 - develop software that is easy to
272:45 - maintain and extend
272:47 - we'll discuss solid principles in detail
272:50 - in upcoming tutorials
272:52 - solid principles serve as a foundation
272:54 - for object-oriented design patterns like
272:57 - for example The Observer design pattern
273:02 - these design patterns can be implemented
273:05 - to solve problems that have been
273:07 - repeatedly identified in real world
273:09 - scenarios if you wish to read more about
273:11 - solid principles please navigate to this
273:14 - URL
273:23 - so let's create an appropriate member
273:25 - variable of the I employee type and
273:28 - within our Constructor let's assign the
273:30 - past and value to the member variable we
273:32 - have just created
273:34 - so let's Implement our code Logic for
273:37 - our on next method notice that the
273:39 - parameter contained within this method
273:41 - is of type external visitor when we
273:45 - automatically generated our default
273:46 - method implementations through Visual
273:49 - Studio the fact that we had strongly
273:51 - typed the I Observer interface with the
273:54 - external visitor uses defined type
273:56 - propagated through to the on next method
274:00 - so the purpose of the on next method is
274:03 - that it gets called by the observable
274:05 - object every time it is appropriate to
274:08 - send out notifications to the relevant
274:10 - Observers
274:12 - this is how the observable object is
274:14 - able to send out notifications to each
274:16 - of its subscribed Observer objects
274:18 - because the observable object knows that
274:21 - each Observer object implements the on
274:23 - next method
274:25 - so the observable object traverses all
274:28 - of its observers and calls the on next
274:30 - method on each of its Observer objects
274:33 - to send out the relevant notifications
274:35 - each Observer is able to handle the
274:38 - notification through its custom
274:40 - implementation of logic within its on
274:43 - next method
274:46 - so the code we are about to write gets
274:49 - called when the observable sends out its
274:51 - notifications
274:53 - in this case we want the designated
274:55 - employee contact to receive a
274:57 - notification when the relevant external
274:59 - visitor has gained access to the
275:01 - building
275:02 - so let's write the logic for this method
275:05 - firstly let's assign the past in
275:07 - argument of type external visitor to a
275:11 - local variable named external visitor
275:14 - let's create an if statement the
275:16 - condition for the if statement checks
275:18 - the external visitor objects employee
275:20 - contact ID property value against the ID
275:23 - property value of the employee object
275:26 - reference that is passed into the
275:28 - Constructor of this employee notify
275:31 - object if these two values match this
275:34 - means that the relevant employee is the
275:37 - registered point of contact for the
275:39 - external visitor referred to in this
275:42 - particular notification so we want to
275:44 - maintain an up-to-date local list of
275:47 - external visitors for this employee
275:49 - notify Observer object so let's define a
275:52 - member variable named underscore
275:53 - external visitors as a generic list that
275:57 - can store external visitor objects
276:00 - so let's write code to check if the
276:02 - external visitor object passed into the
276:04 - on next method exists within the
276:06 - underscore external visitors list we can
276:09 - do this by using link and checking if
276:12 - the ID of the external visitor object
276:14 - passed into the on next method matches
276:17 - any of the external visitor objects ID
276:20 - properties currently stored within the
276:23 - underscore external visitors list
276:26 - and we are assigning the result of the
276:28 - link expression to a local variable
276:30 - named external visitor list item
276:33 - so let's write a nested if statement
276:36 - where the if condition checks if the
276:38 - external visitor list item variable
276:39 - value is null
276:42 - if it is null the external visitor
276:44 - object does not exist in our local list
276:47 - containing external visitor objects so
276:49 - let's add this external visitor object
276:51 - to our list
276:53 - then the next line of code simply
276:55 - outputs a message to the relevant
276:57 - employee that the expected external
276:59 - visitor has entered the building and we
277:02 - can also include the external visitors
277:04 - details within the message
277:48 - thank you
277:59 - so if the else part of the nestative
278:01 - statement condition is true the external
278:03 - visitor has already visited and the
278:06 - notification must refer to the relevant
278:07 - external visitor exiting the building
278:21 - so the logic simply updates the
278:22 - inbuilding property of the relevant
278:24 - external visitor object within the
278:27 - underscore external visitors list to
278:29 - false
278:31 - the relevant external visitor list items
278:34 - exit date time property is also
278:36 - appropriately updated with relevant exit
278:39 - date Time Properties stored in the
278:40 - external visitor object passed in from
278:43 - the observable object to the on next
278:46 - method of this object so we have now
278:49 - implemented the logic for the on next
278:51 - method of the employee notify Observer
278:54 - class
279:06 - so in the interests of time we are not
279:09 - going to bother implementing code for
279:11 - the on error method we'll simply retain
279:13 - the default implementation generated by
279:15 - Visual Studio in this example but please
279:17 - note that this method provides a
279:19 - mechanism for observers to handle
279:22 - exceptions that may occur within the
279:24 - observable object
279:26 - so now we must implement the logic for
279:28 - the uncompleted method the purpose of
279:31 - this method is so that the observable
279:33 - object can notify the relevant Observer
279:35 - objects when no further notifications
279:37 - need to be sent
279:39 - in this example there is a rule that the
279:42 - observer's on completed methods will be
279:44 - called from the observable object when a
279:47 - cut-off time is reached for example
279:48 - perhaps 6 pm on a workday
279:51 - and all external visitors must have left
279:54 - the building
279:55 - so a few external visitors may still be
279:58 - in the building past 6 PM for example
280:00 - they may be in meetings that have gone
280:03 - on for longer than was first anticipated
280:06 - the uncompleted method on all relevant
280:09 - Observer objects will only be invoked
280:11 - from the observable object once all
280:14 - external visitors have left the building
280:15 - and the cutoff time has been reached
280:18 - let's say the cut of time means that no
280:20 - further external visitors are allowed to
280:22 - gain entry into the building on a
280:24 - particular work day after a predefined
280:26 - cut off time so if these conditions are
280:29 - met the observable can notify all
280:31 - observers through the observer's
280:33 - implementation of their uncompleted
280:35 - methods and this means that no further
280:37 - notifications will be sent at this point
280:40 - the relevant Observer objects will have
280:42 - a complete list of external visitor
280:44 - objects that visited the building during
280:46 - the course of the day
280:48 - the external visitor objects will
280:51 - contain relevant information like for
280:53 - example certain details about the
280:55 - external visitors as well as their entry
280:58 - and exit times to and from the building
281:00 - on the relevant day
281:03 - so the Observer at this point is able to
281:05 - create a final report relating to the
281:08 - external visitor data on a specific day
281:11 - so let's implement the code for the
281:13 - uncompleted method in the employee
281:15 - notify class let's say that the relevant
281:18 - employee is only interested in the
281:21 - details of those external visitors that
281:23 - were there to visit the employee during
281:26 - the course of that day
281:28 - so in the on next method we have only
281:30 - added the external visitors where the
281:32 - relevant employee was registered as the
281:35 - external visitors contact in the
281:37 - building
281:39 - so we can simply output the details of
281:41 - external visitors stored within the
281:43 - underscore external visitors list for
281:45 - the implementation of the on completed
281:48 - method
281:49 - so let's first write an appropriate
281:51 - heading to the console screen this
281:53 - heading will simply contain the employee
281:55 - name followed by the text daily visitors
281:58 - report
282:10 - let's write code to Traverse the
282:12 - underscore external visitors list
282:14 - let's set the inbuilding property to
282:17 - false because if this method is being
282:19 - invoked this means that all external
282:21 - visitors have left the building and we
282:23 - want to keep our local copy of the
282:25 - underscore external visitors list up to
282:27 - date
282:28 - let's then write the details of each
282:30 - relevant external visitor to the console
282:32 - screen
282:33 - this information serves as a final daily
282:35 - report for a specific employee and
282:38 - contains information about the external
282:39 - visitors that have visited the employee
282:41 - so this is a report and we want to space
282:44 - The Columns for each of the outputted
282:46 - fields evenly
282:48 - one way we can achieve this is by using
282:50 - the pad write method which is available
282:52 - on all string objects the pad write
282:55 - method accepts an integer value as an
282:59 - argument so if for example we wish for
283:01 - the ID field to always occupy six
283:03 - character spaces we can pass an argument
283:06 - of six to the pad write method so if for
283:09 - example the ID value only takes up one
283:11 - character space the pad write method
283:13 - will add the extra five character spaces
283:16 - which will be empty spaces or white
283:18 - spaces to the relevant field output we
283:21 - can actually achieve the same effect
283:22 - when outputting variable values using an
283:25 - interpolated string like this
283:30 - so using the interpolated string
283:32 - Technique we can achieve the same thing
283:34 - and use less code
284:07 - foreign
284:18 - and that is the implementation for the
284:21 - uncompleted method of the employee
284:23 - notify class
284:25 - so we also want to include a method that
284:27 - performs the action of subscribing to
284:30 - the observable
284:31 - in this case as we know the observable
284:33 - is represented by the surveillance
284:35 - system Hub class
284:37 - so let's create a method named subscribe
284:40 - that contains a parameter name to
284:42 - provider
284:44 - which is of the generic interface type I
284:47 - observable
284:48 - and is strongly typed with the external
284:50 - visitor user-defined type
284:54 - and to subscribe we can simply write
284:57 - provider.subscribe and pass a reference
284:59 - to the current object using the this
285:01 - keyword to the observables Subscribe
285:05 - method
285:06 - but remember that the observable
285:08 - subscribe method returns an object that
285:11 - implements the eye disposable interface
285:15 - so let's create a member variable of
285:17 - type I disposable
285:20 - let's name this member variable
285:22 - underscore cancellation
285:39 - so now we can create a method named
285:41 - unsubscribe
285:42 - the logic to unsubscribe The Observer is
285:45 - simply underscore cancellation dot
285:47 - dispose
285:49 - so as mentioned we also want to
285:52 - implement code for another type of
285:54 - Observer class
285:55 - so the class we'll create for this will
285:57 - be named security notify and as the name
286:00 - suggests this class denotes the security
286:02 - team that must receive a notification
286:04 - every time an external visitor enters
286:07 - the building
286:08 - and a notification when the external
286:11 - visitor later exits the building
286:15 - so let's include the I Observer generic
286:17 - interface that is strongly typed with
286:19 - the external visitor user defined type
286:21 - within our security notify class
286:24 - definition
286:26 - let's Auto generate the methods that we
286:28 - must Implement for the I Observer
286:30 - generic interface so let's hover our
286:33 - Mouse pointers over the red squiggly
286:34 - line click show potential fixes and then
286:37 - click Implement interface
286:39 - so the first method we need to implement
286:41 - is the on next method
286:43 - the logic here simply checks if the
286:46 - external visitor object already exists
286:48 - within the underscore external visitors
286:50 - list
286:51 - if it doesn't exist we add the external
286:54 - visitor object passed into the onnext
286:56 - method to the underscore external
286:58 - visitors list
287:01 - we then output notification text
287:04 - that is appropriate for the security
287:05 - related Observer to the console screen
287:44 - foreign
287:57 - visitor does already exist within the
288:00 - underscore external visitors list this
288:02 - means the relevant external visitor has
288:04 - just exited the building so we must
288:07 - update the relevant properties for this
288:09 - external visitor object list item
288:11 - appropriately
288:13 - so we update the inbuilding Boolean
288:15 - property to false and we also update the
288:18 - exit date time property with the date
288:20 - and time when the external visitor
288:22 - exited the building
288:25 - and then let's update the code to Output
288:28 - text to the security team that the
288:31 - relevant external visitor has now exited
288:33 - the building
288:38 - and we have just written the on next
288:40 - method
288:41 - so let's implement the code for the on
288:43 - completed method
288:46 - So within the uncompleted method we
288:48 - simply want to Output the details
288:50 - contained within the underscore external
288:52 - visitors list to the console screen and
288:55 - this serves as a report to the relevant
288:57 - security team conveying information
288:59 - about the entry and exit times of
289:02 - external visitors throughout the day
289:05 - so we can simply copy the implementation
289:08 - for the uncompleted method within the
289:10 - employee notify class to the uncompleted
289:13 - method within the security notify class
289:19 - and then manually change the heading to
289:21 - reflect that this is a daily report for
289:23 - the security team regarding external
289:25 - visitors so let's finish off this class
289:28 - by implementing our subscribe and
289:30 - unsubscribe methods so you may have
289:33 - noticed that we would actually be
289:34 - repeating the code for the Subscribe and
289:37 - unsubscribe methods across our Observer
289:39 - classes namely the employee notify and
289:42 - security notify classes
289:44 - so if we repeat the Subscribe and
289:47 - unsubscribe implementations here we are
289:49 - violating the principle of dry
289:51 - which is an acronym that stands for
289:53 - don't repeat yourself
289:55 - yeah we would be clearly repeating
289:57 - ourselves
289:58 - so let's refactor our code so that the
290:01 - Subscribe and unsubscribe methods are
290:03 - reusable across our Observer classes and
290:06 - are written in only one place
290:09 - to centralize the functionality for
290:11 - these methods let's create an abstract
290:13 - class named Observer
290:16 - let's make the Observer class implement
290:18 - the I Observer generic interface let's
290:21 - strongly type the interface with the
290:23 - external visitor class
290:26 - so the rule here is that we must
290:28 - implement the members of the I Observer
290:30 - generic interface in this case however
290:33 - we don't want to centralize the
290:34 - functionality for the on next on error
290:37 - and on completed methods defined in the
290:40 - I Observer generic interface
290:42 - we have different implementations for
290:45 - the on next and on completed methods for
290:48 - our two different Observer classes
290:51 - so what we can do is we can create
290:53 - abstract method definitions for the
290:56 - relevant methods within our Observer
290:59 - class
291:04 - we can consolidate two member variables
291:07 - within this abstract class I.E the
291:11 - underscore cancellation member variable
291:12 - and the underscore external visitors
291:15 - member variable
291:17 - the underscore cancellation member
291:19 - variable is of the I disposable type
291:23 - and is used for unsubscribing and
291:26 - observer object the underscore external
291:29 - visitors variable is of type generic
291:31 - list and is strongly typed with the
291:34 - external visitor type
291:36 - the underscore visitors list maintains a
291:39 - central local storage facility for the
291:42 - relevant Observer object of external
291:44 - visitor information
291:46 - we can then centralize the functionality
291:48 - for the Subscribe and unsubscribe
291:50 - methods so that these methods can be
291:53 - reused across both Observer classes
291:56 - as you may have guessed The Observer
291:58 - classes will inherit from this abstract
292:00 - class
292:17 - so we can now change the class
292:19 - definitions for our Observer classes
292:21 - namely the employee notify class and the
292:24 - security notify class to inherit from
292:27 - The Observer abstract class
292:30 - we then need to include the override
292:32 - keyword within the on next on error and
292:36 - on completed methods within our employee
292:39 - notify and our security notify classes
292:42 - which are of course classes that
292:44 - represent our Observers
292:46 - this is because we are no longer
292:47 - implementing the I Observer generic
292:49 - interface directly we need to override
292:52 - the abstract method definitions for
292:54 - these methods that have been defined in
292:56 - the Observer abstract class
293:18 - so before we Implement code in our main
293:21 - method and run the code let's create a
293:25 - basic class that will help us
293:26 - differentiate between the text that will
293:29 - be outputted by our two Observer classes
293:32 - namely the employee notify class and the
293:35 - security notify class
293:37 - so the obvious way that we can do this
293:39 - is by changing the color of the
293:41 - outputted text for each of these
293:43 - Observer classes so let's create a
293:46 - static class
293:49 - let's create a public enum and name it
293:52 - text output theme
293:55 - each list item value in this enum
293:57 - denotes an output theme
294:00 - so let's name the first enum list item
294:02 - security let's name the second enum list
294:05 - item employee
294:07 - let's name the third enormous item
294:09 - normal let's add a method to the static
294:12 - class
294:13 - let's name this method change output
294:16 - theme
294:17 - this method contains one parameter named
294:19 - text output theme and is defined as the
294:22 - enum we have just created I.E the enum
294:25 - named text output theme
294:27 - then the logic for the change output C
294:29 - method simply evaluates through an if
294:33 - else if block the value passed into this
294:35 - method
294:37 - so if the value passed into the change
294:39 - output theme method is the employee
294:41 - enormous item value let's write code to
294:44 - change the background color to dark
294:46 - magenta and the color of the text to
294:48 - White
294:50 - else if the value passed into the change
294:53 - output theme method is the security e
294:56 - number list item value
294:57 - let's change the background color to
294:59 - dark blue and the color of the text to
295:02 - Yellow
295:02 - else let's reset the state of the text
295:05 - color and the background color back to
295:07 - their default colors
295:10 - so let's go to the security notify class
295:13 - and we can now change the color theme
295:15 - for the output text colors in the on
295:18 - next method accordingly
295:20 - and once the relevant text has been
295:22 - outputted let's change the foregrounded
295:25 - background colors back to their default
295:27 - values
295:28 - and we can do this using our change
295:30 - output theme method like this
295:33 - let's go to the employee notify class
295:35 - and implement the same functionality but
295:38 - of course change the color theme to the
295:40 - appropriate color theme we have defined
295:42 - for the employee notify output text
295:59 - so now when we test our code we will be
296:01 - able to differentiate between the output
296:04 - coming from an object derived from the
296:06 - employee notify class and the output
296:09 - coming from an object derived from the
296:11 - security notify class okay so let's
296:14 - write some code in the main method to
296:16 - test our implementation of the Observer
296:18 - design pattern
296:20 - we have implemented code here for the
296:22 - purpose of understanding The Observer
296:24 - design pattern and to keep things simple
296:26 - and focused on the Observer design
296:28 - pattern itself we have used the
296:30 - consoleapp.net core project template to
296:33 - create the infrastructure or framework
296:35 - to house our code logic
296:38 - so before we write calling code in the
296:40 - main method to test our Observer design
296:42 - pattern it may be helpful to use our
296:44 - imaginations to picture a real world
296:46 - representation of this example
296:49 - so in the real world we would have three
296:51 - types of entities
296:52 - we have our two types of observers
296:54 - namely an employee who works within the
296:57 - building and the building's security
296:58 - team so the relevant Observer employees
297:01 - I.E the employees who have subscribed to
297:04 - receive notifications when an external
297:07 - visitor enters or exits the building may
297:10 - have apps running on a handheld device
297:12 - like tablets or smartphones
297:14 - that alert the employees when relevant
297:17 - external visitors enter or exit the
297:19 - building
297:21 - the security team may have various
297:23 - Personnel whose responsibility it is to
297:26 - monitor the entry and exit of external
297:28 - visitors
297:29 - so the relevant security Personnel may
297:32 - be notified through security related
297:34 - software where one of its components is
297:37 - subscribed to receive notifications when
297:40 - an external visitor enters or exits the
297:42 - building
297:43 - so the relevant security officer or
297:46 - officers may be sitting at a laptop or
297:48 - desktop monitoring the relevant
297:50 - notifications
297:52 - then we have the observable entity which
297:54 - could be a server that resides
297:56 - on-premises or in the cloud that is
298:00 - constantly receiving surveillance
298:01 - information from security cameras
298:04 - it provides facial recognition
298:06 - functionality and assesses whether a
298:08 - registered external visitor can be
298:10 - authenticated and therefore enter the
298:12 - building
298:13 - so in summary The Observers I.E
298:16 - employees within the building and a
298:18 - security team are subscribed to the
298:20 - observable and receive notifications
298:22 - from the observable once a certain
298:25 - condition is met in this case the
298:27 - condition is an authenticated external
298:30 - visitor entering or exiting the building
298:33 - with all this in mind let's Implement a
298:35 - few scenarios within our main method to
298:37 - test our implementation of the Observer
298:40 - design pattern
298:41 - so let's create an instance of our
298:43 - observable class
298:47 - let's create an instance of the Observer
298:50 - class named employee notify and pass an
298:52 - employee object as an argument to the
298:55 - employee Notifier Constructor
298:57 - so we can imagine that Bob Jones is
298:59 - carrying a handheld device that receives
299:02 - a notification when an external visitor
299:04 - that has registered Bob Jones as the
299:06 - external visitors point of contact
299:07 - arrives
299:09 - let's create another instance of the
299:11 - Observer class employee notify and pass
299:14 - a new employee object as an argument to
299:16 - the employee notify Constructor
299:19 - so it's essentially the same scenario as
299:21 - before but this time we can imagine that
299:24 - Dave Kendall is carrying a handheld
299:26 - device that receives a notification when
299:29 - an external visitor arrives that has
299:31 - registered Dave Kendall as the external
299:34 - visitors point of contact
299:37 - and these employees will also receive
299:39 - notifications once the relevant external
299:42 - visitor exits the building although they
299:44 - don't receive text output when the
299:46 - relevant external visitor exits the
299:48 - building the notification is received
299:50 - and the relevant employee notify
299:51 - external visitors object list containing
299:54 - the relevant external visitor object is
299:57 - updated with relevant information for
300:00 - example the time the relevant external
300:02 - visitor exited the building
300:04 - this information is relevant when the
300:06 - employee receives a report regarding
300:08 - external visitors
300:10 - when the relevant cutoff time is reached
300:13 - and all external visitors have exited
300:15 - the building
300:16 - and let's create the other type of
300:18 - Observer object which is represented by
300:21 - the security notify class
300:23 - this type represents a security team
300:26 - that must receive notifications whenever
300:28 - an external visitor enters the building
300:31 - and later exits the building
300:33 - all observers will also receive a report
300:36 - once a cut-off time is reached and all
300:38 - external visitors have left the building
300:41 - remember the cut-off time denotes a time
300:43 - after which no further external visitors
300:46 - are allowed to enter the building so for
300:48 - example this cutoff time could be 6 PM
300:51 - which could be deemed as the end of the
300:53 - Working Day for the relevant company
300:57 - so now we have three Observer objects
300:59 - which is comprised of two employees and
301:02 - the security team and we have a provider
301:04 - which can also be called the observable
301:07 - object which is the central location
301:09 - where security related data is processed
301:12 - so let's subscribe all of our Observer
301:15 - objects to receive notifications from
301:17 - the observable object
301:19 - so when we call the Subscribe method we
301:22 - must also pass a reference to the
301:24 - observable object
301:32 - so we can call the confirm external
301:34 - visitor enters building method to
301:36 - simulate an external visitor entering
301:38 - the building
301:40 - the arguments that we are passing to
301:42 - this method denote information about the
301:43 - external visitor the time the external
301:46 - visitor enters the building
301:53 - as well as the ID of the employee that
301:56 - serves as the contact point for the
301:58 - external visitor
302:00 - so let's call the confirm external
302:02 - visitor enters building method to
302:04 - simulate the entry of an external
302:06 - visitor named Andrew Jackson and then an
302:08 - external visitor named Jane Davidson
302:11 - note that the last argument passed into
302:13 - the confirm external visitor enters
302:15 - building method denotes the ID of the
302:18 - employee whom the external visitors have
302:21 - registered as their point of contact
302:24 - so the point of contact for Andrew
302:26 - Jackson is Bob Jones and the point of
302:28 - contact for Jane Davidson is Dave
302:30 - Kendall
302:32 - let's then call a method to simulate
302:34 - these two external visitors exiting the
302:37 - building
302:38 - we can do this by calling the confirm
302:40 - external visitor exits building method
302:42 - on the observable object once where the
302:45 - ID pertaining to the external visitor
302:47 - Andrew Jackson is passed into the method
302:49 - we can then call the method again but
302:52 - this time passing the ID of the external
302:54 - visitor Jane Davidson signifying that
302:57 - Jane Davidson has exited the building
302:59 - these two method calls to the confirm
303:01 - external visitor exits building method
303:04 - simulate these two external visitors
303:06 - exiting the building
303:08 - so let's say that Andrew Jackson exited
303:10 - the building two hours after entering
303:12 - the building and let's say that Jane
303:14 - Davidson exited the building three hours
303:16 - after entering the building
303:19 - lastly let's call the building entry
303:21 - cutoff time reached method on the
303:23 - observable object which denotes that the
303:26 - end of the working day has been reached
303:28 - we have referred to this term as the
303:31 - cutoff time throughout this tutorial if
303:33 - all external visitors have exited the
303:36 - building a report of external visitors
303:38 - is sent out to all the subscribed
303:41 - Observer objects
303:43 - on a technical level this is achieved
303:45 - through the observable object calling
303:47 - the uncompleted method on all relevant
303:49 - Observer objects
303:51 - we have structured the code in the main
303:53 - method so that all external visitors
303:55 - have left the building before the cutoff
303:58 - time so a full report should be sent to
304:01 - All Observers
304:02 - and this also means that no further
304:04 - notifications will be sent for that
304:06 - particular day
304:09 - so let's run the code
304:20 - okay so an error is flagged because the
304:23 - underscore observers variable is null
304:25 - and we have tried to call its contains
304:28 - method
304:29 - so I've realized I forgot to include a
304:32 - Constructor for the security
304:33 - surveillance Hub class
304:36 - where we should have instantiated an
304:38 - appropriate generic list object and
304:40 - assigned it to the underscore observer's
304:42 - member variable as well as instantiate
304:45 - an appropriate generic list object and
304:47 - assign it to the underscore external
304:49 - visitors variable
304:50 - so let's fix this issue and implement
304:52 - the appropriate Constructor code for the
304:55 - security surveillance Hub class
305:10 - okay
305:13 - let's try again let's run the code
305:15 - great
305:17 - and if we look at our output we can see
305:19 - that this is an expected result Bob
305:22 - Jones an employee is notified when
305:24 - Andrew Jackson an external visitor
305:26 - enters the building
305:28 - Dave Kendall an employee is notified
305:30 - when Jane Davidson an external visitor
305:33 - enters the building
305:34 - the security team is notified when both
305:37 - external visitors have entered and
305:39 - exited the building
305:40 - when the cutoff time is reached an
305:43 - appropriate report is sent to the
305:45 - employee Observer objects as well as the
305:48 - security Observer object
305:50 - the employee report contains information
305:52 - regarding external visitors where the
305:54 - employee served as the relevant external
305:56 - visitors point of contact
305:58 - the security Observer object is notified
306:01 - of the relevant activities and relevant
306:03 - details of all external visitors for the
306:05 - relevant day through a report tailored
306:08 - for the security team
306:10 - great so our Observer design pattern has
306:12 - been implemented correctly and is
306:14 - therefore working as expected though
306:16 - I've noticed that the date time output
306:18 - is not in the format I would prefer
306:21 - I want to include whether the time is AM
306:24 - or PM
306:25 - so we can do this by including TT within
306:28 - the date time formatting string passed
306:31 - to the relevant tostring methods
306:34 - this is not ideal because notice that we
306:36 - are having to change this format in
306:39 - several places in a professionally
306:41 - developed application it would be good
306:43 - practice to configure this format in one
306:46 - place
306:47 - for the purposes of this demonstration
306:48 - we'll update the date time string
306:51 - formatting in several places but let's
306:54 - be cognizant that this is not the best
306:56 - way to implement this formatting
306:58 - functionality
307:00 - let's run the code again
307:08 - great
307:09 - so let's simulate the scenario where the
307:12 - cut of time is reached
307:13 - so no further external visitors are
307:16 - allowed to enter the building past the
307:17 - cutoff time
307:19 - but there are still external visitors in
307:21 - the building
307:22 - so we can simulate this scenario by
307:25 - commenting out the line of code that
307:27 - simulates the external visitor Jane
307:29 - Davidson exiting the building
307:31 - so in this particular case Jane Davidson
307:33 - has not yet exited the building let's
307:36 - run the code
307:38 - and the output reflects this
307:40 - we see the correct output pertaining to
307:42 - the entry and exit of Andrew Jackson
307:46 - but we only see an output for Jane
307:48 - Davidson entering the building and not
307:50 - exiting the building this is an expected
307:53 - result
307:54 - note that we also do not see any of the
307:57 - reports outputted to The Observers
307:58 - because these reports are only sent when
308:01 - the cutoff time is reached and all
308:03 - external visitors have exited the
308:05 - building the code implementation for
308:07 - this is implemented in the building
308:09 - entry cut of time reached method
308:11 - contained within the observable class
308:14 - I.E the security surveillance Hub class
308:20 - in the building entry cut of time
308:22 - reached method the uncompleted methods
308:25 - of all relevant Observer objects is
308:27 - called but only if all external visitors
308:30 - have left the building and if we include
308:32 - the method called to the confirm
308:34 - external visitor exits building method
308:36 - for Jane Davidson
308:39 - but call the unsubscribe method on the
308:41 - employee notify object after this
308:44 - external visitor has entered the
308:46 - building but before the building entry
308:49 - cutoff time reached method is called so
308:51 - let's appropriately call the unsubscribe
308:54 - method on the Observer object pertaining
308:56 - to the employee Bob Jones
309:00 - let's run the code
309:04 - and you can see that Bob receives a
309:06 - notification when his external visitor
309:09 - enters the building but a report is not
309:11 - sent to Bob Jones when cutoff time is
309:14 - reached because he has unsubscribed
309:16 - before cutoff time is reached
309:18 - this is because if an observer
309:20 - unsubscribes The Observer will not
309:22 - receive any further notifications after
309:25 - the Observer has unsubscribed on a
309:27 - technical level when the Observer
309:29 - unsubscribes the code removes The
309:32 - Observer from the observer's list
309:33 - contained within the observable object
309:35 - and therefore that Observer is excluded
309:38 - from the list of observers that has
309:41 - traversed and sent notifications when
309:43 - certain predefined conditions are met
309:47 - I hope you have enjoyed this video on
309:49 - the Observer design pattern this
309:51 - completes the final video in a video
309:53 - series on c-sharp events and completes
309:56 - the fourth part of a course on Advanced
309:58 - C sharp
309:59 - so in this video series we looked at the
310:02 - basics of events in C sharp we
310:05 - demonstrated how we are able to
310:06 - subscribe to an event contained within
310:09 - another class and how we can designate a
310:11 - method to handle the event
310:14 - event handling code and c-sharp is
310:16 - implemented by using a delegate
310:19 - as an intermediary between the event and
310:22 - designated method that is called when
310:24 - the relevant event is raised
310:27 - we demonstrated the use of racing events
310:29 - through codelogic I.E when certain
310:32 - logical conditions are met in a class
310:34 - where the relevant event resides the
310:37 - event can be raised in order to invoke
310:39 - the methods that have been designated to
310:42 - handle the relevant event we
310:44 - demonstrated how we're not calling
310:46 - clients subscribes or unsubscribes to an
310:48 - event that this functionality can be
310:50 - encapsulated with an add and remove
310:52 - accesses
310:54 - which are similar in nature to the use
310:56 - of get and set accesses for properties
310:59 - we demonstrated how events can be raised
311:02 - through user actions for example a
311:05 - button click
311:06 - we use the uwp universal windows
311:09 - platform project framework as a
311:12 - foundation for this demonstration we
311:14 - briefly touched on how the mvvm model
311:17 - view view model design pattern is used
311:19 - to Loosely couple front-end
311:21 - functionality from business rules
311:23 - related functionality when implementing
311:25 - code for a uwp project in this regard we
311:28 - also discussed the advantages of
311:30 - separating concerns for example to allow
311:33 - for cleaner code to facilitate easier
311:36 - unit testing to facilitate better
311:38 - maintainability of code and to allow for
311:41 - separate teams to specialize in
311:43 - different aspects of a project
311:45 - so relevant aspects of the project can
311:48 - evolve independently and without
311:49 - adversely affecting one another
311:52 - lastly in this video we demonstrated an
311:55 - example where the implementation of the
311:58 - Observer design pattern was deemed as
312:00 - suitable because its core functionality
312:02 - involves pushing notifications out to
312:05 - multiple entities from a central point
312:07 - when certain conditions are met
312:11 - please consider subscribing for more
312:13 - content on advanced c-sharp concepts
312:15 - like this and much more and please ring
312:18 - the bell so that you can be notified
312:19 - when this channel releases new videos
312:22 - if you feel you've gained value from
312:24 - viewing this video please hit the like
312:26 - button it will be greatly appreciated
312:29 - please feel free to share any of the
312:30 - videos released from this Channel with
312:32 - anyone you feel May benefit from their
312:34 - content
312:35 - and please feel free to provide feedback
312:37 - about this video in the comments section
312:40 - as always the code can be downloaded
312:42 - from GitHub
312:44 - a link to the relevant GitHub repository
312:46 - has been included Below in the
312:48 - description
312:49 - [Music]
312:59 - hi and welcome to the first part of a
313:02 - tutorial on c-sharp generics
313:05 - tutorial is also the fifth part of a
313:08 - course on Advanced c-sharp topics
313:11 - this video will serve as a basic
313:13 - introduction to generics and c-sharp
313:15 - we'll first answer the question what is
313:18 - meant by generics we'll look at a basic
313:20 - example of implementing generics in
313:22 - c-sharp and the advantages associated
313:25 - with the use of generics and c-sharp so
313:28 - let's start with the question what is
313:30 - meant by generics in relation to the
313:33 - c-sharp programming language
313:35 - generics was introduced in c-sharp
313:37 - version 2 and enables developers to use
313:40 - type parameters and code
313:42 - this makes it possible to design classes
313:44 - and methods that defer the specification
313:47 - of one or more types until the classroom
313:50 - method is declared and instantiated by
313:52 - client code
313:54 - for example by using a generic type
313:56 - parameter T you can write a single class
313:59 - that other client code can use without
314:01 - incurring the cost or risk of runtime
314:04 - costs or boxing operations
314:07 - we'll discuss what is meant by boxing
314:09 - operations and runtime casting a bit
314:12 - later in this video
314:13 - generic classes and methods combine
314:16 - reusability type safety and efficiency
314:18 - in a way that their non-generic
314:20 - counterparts cannot
314:22 - generics are most frequently used with
314:24 - Collections and the methods that operate
314:26 - on them
314:27 - for more content like this on advanced
314:29 - c-sharp concepts and much more please
314:31 - consider subscribing and please ring the
314:33 - bell so that you'll be notified of
314:35 - future content released from this
314:37 - channel
314:37 - let's look at a simplistic example to
314:40 - help us understand generics and C sharp
314:43 - to help us understand generics as a
314:45 - whole we're going to look at a c-sharp
314:47 - collection type the arraylist versus a
314:50 - c-sharp generic collection type a
314:52 - generic list
314:54 - an arraylist provides the advantage of
314:57 - encapsulating the functionality of
314:58 - dynamically increasing the size of the
315:01 - list as more items are added to the
315:03 - arraylist in other words unlike with an
315:06 - array we do not have to Define an
315:08 - arraylist with a size
315:10 - it will dynamically handle its size as
315:13 - items are added to the arraylist
315:16 - the arraylist stores values as objects
315:19 - this involves implicitly boxing value
315:21 - type items when they are added to the
315:24 - arraylist
315:25 - unboxing these items is required when
315:28 - these items are retrieved from the
315:30 - arraylist we'll discuss boxing and
315:32 - unboxing in a bit
315:35 - so we are only using an arraylist in
315:37 - this example to highlight the benefits
315:39 - that replacing an arraylist with a
315:41 - generic list provides
315:42 - in doing so we can understand the
315:45 - overall benefits provided through the
315:47 - use of generics
315:49 - note that Microsoft has stated that
315:51 - Microsoft does not recommend using the
315:53 - arraylist for future development
315:55 - so we'll first use the arraylist
315:57 - collection in our example and later
316:00 - replace the arraylist collection with a
316:02 - generic list to highlight the benefits
316:04 - of generics
316:05 - let's create a console app.net core
316:08 - project
316:16 - I'm going to name my project generics
316:18 - basics
316:30 - let's create a class named salaries
316:35 - let's define a member variable as an
316:38 - arraylist
316:39 - the arraylist type is a member of the
316:41 - system.collections namespace so let's
316:43 - ensure that we include a directive to
316:46 - the system.collections namespace at the
316:48 - top of our code
316:53 - and let's create a Constructor
316:56 - within the Constructor let's populate
316:58 - our arraylist with data that denotes
317:00 - salaries
317:13 - let's create a public method named get
317:15 - salaries that simply Returns the
317:17 - arraylist that has been populated with
317:20 - the salary data
317:21 - so this method returns an object of the
317:24 - arraylist type to the client code
317:27 - so the code within our main method is
317:29 - our calling client code the code share
317:31 - will create an instance of the salaries
317:33 - class and then call the get salaries
317:35 - method and assign The Returned
317:37 - collection from the get salaries method
317:39 - to a local arraylist variable so let's
317:42 - write the code in the main method to do
317:43 - this
317:49 - let's say there is a requirement to add
317:51 - a bonus of two percent to the second
317:53 - item within the collection
317:55 - so let's write code to achieve this
317:58 - we know that the salaries collection
318:00 - contains floating Point numbers so let's
318:02 - assume that we can assign a member of
318:03 - the collection to a local variable
318:05 - defined as float
318:08 - so let's write the code for this
318:10 - okay great so this is good we have a red
318:12 - squiggly line under the code where we
318:15 - are assigning the second item of the
318:17 - relevant arraylist to a variable we have
318:19 - defined as float so a type in
318:22 - compatibility has been flagged by the
318:24 - c-sharp compiler if we hover our Mouse
318:27 - pointers over the red squiggly line we
318:29 - can see a message from the c-sharp
318:31 - compiler which is telling us that we
318:34 - cannot implicitly cast an object to a
318:37 - float but that an explicit conversion
318:39 - exists
318:41 - so let's write code to explicitly
318:43 - convert the relevant object value stored
318:46 - in the relevant arraylist to the float
318:48 - data tab like this
318:51 - great and the red squiggly line goes
318:53 - away and all seems well
319:06 - then we can finish off The Code by
319:08 - writing code to write the salary which
319:11 - now includes a bonus of two percent to
319:13 - the console screen
319:15 - let's run the code
319:30 - oh what is happening here we have
319:33 - received a runtime error specifically an
319:35 - invalid cost exception
319:38 - the exception message States unable to
319:40 - cast object of type system.double to
319:43 - system.single remember float is an alias
319:46 - for system.single
319:48 - so note that when we added the salaries
319:51 - to the arraylist within the Constructor
319:53 - of the salaries class we simply added
319:56 - literal values that our floating Point
319:57 - values we did not explicitly Express the
320:00 - type of the relevant literal values the
320:03 - type of floating Point literals are by
320:05 - default interpreted as the double date
320:07 - type we could have expressed the types
320:09 - for these literal values as float data
320:12 - types by adding an F after the relevant
320:15 - literal value like this but we did not
320:18 - do this
320:19 - so in the main method or in our client
320:21 - code we assumed that a value within the
320:24 - arraylist was of the float data type and
320:27 - this assumption resulted in a runtime
320:29 - error occurring
320:31 - in a bit we'll talk about how generics
320:33 - preemptively prevents such erroneous
320:36 - assumptions from causing runtime errors
320:39 - let's first discuss boxing and unboxing
320:43 - okay so an arraylist stores values that
320:46 - are automatically typed as the root
320:48 - c-sharp data type which is the
320:50 - system.object data type
320:53 - note that all.net data types ultimately
320:56 - inherit from the system.object data type
320:58 - when a value type in our case a numeric
321:01 - floating point value type is stored
321:03 - within an arraylist the value type is
321:06 - wrapped within an object type and stored
321:08 - in memory on the Heap this process is
321:11 - known as boxing
321:14 - what does boxing mean
321:16 - boxing is the process of converting a
321:18 - value type to the type object or to any
321:21 - interface type implemented by this value
321:23 - type so when the common language runtime
321:25 - boxes the value type it wraps the value
321:28 - inside a system.object instance and
321:31 - stores it on the managed Heap
321:33 - for more information on data types in
321:35 - c-sharp please access a video created by
321:38 - this channel by clicking on a card made
321:40 - available in the top right hand corner
321:42 - of your screen a link to this video has
321:45 - also been included Below in the
321:46 - description so when a value is retrieved
321:49 - from the arraylist as we are doing in
321:52 - the main method the value must first be
321:54 - unboxed
322:00 - unboxing extracts the value type from
322:03 - the object
322:04 - boxing is implicit unboxing is explicit
322:08 - the concept of boxing and unboxing
322:10 - underlies the c-sharp unified view of
322:13 - the type system in which a value of any
322:16 - type can be treated as an object
322:19 - so this highlights two disadvantages of
322:22 - using an arraylist where a generic list
322:24 - can be used instead and can be
322:27 - implemented whereby the values contained
322:28 - within the generic list can be strongly
322:31 - typed through generics at compile time
322:35 - firstly as we have proven writing code
322:38 - in this way can result in runtime errors
322:40 - because the values in an arraylist are
322:43 - not strongly typed at compile time
322:45 - secondly when a value type is stored
322:48 - within an arraylist the value type is
322:50 - automatically boxed and when a value
322:52 - type is retrieved from the arraylist the
322:55 - value must be explicitly unboxed this is
322:58 - done through explicit type casting
323:02 - this boxing and unboxing functionality
323:05 - carries with it a performance overhead
323:07 - boxing and unboxing can affect the
323:10 - performance of our applications
323:13 - using a generic list to strongly type
323:15 - the values stored within the relevant
323:18 - generic list has two distinct advantages
323:20 - one type safety the code is type checked
323:24 - at compile time which preempts runtime
323:27 - errors this makes typecasting at runtime
323:30 - not necessary which eliminates the
323:32 - potential for type-related runtime
323:33 - errors occurring
323:35 - number two enhanced performance
323:39 - unlike with an arraylist the overhead of
323:42 - boxing is not necessary when adding a
323:44 - value to a strongly typed generic list
323:46 - and the overhead of unboxing is not
323:48 - necessary when retrieving a value from
323:51 - the strongly typed generic list
323:53 - like an arraylist the generic list
323:55 - carries the advantage of being able to
323:57 - grow dynamically I.E it is not necessary
324:00 - to define the size of the collection
324:01 - when it is declared
324:04 - so with all that said let's Implement
324:06 - generics in our code
324:08 - to implement generics let's replace the
324:10 - arraylist within our salaries class with
324:13 - a strongly typed generic list the
324:15 - generic list is part of the
324:17 - system.collections.genericnamespace so
324:19 - let's ensure that we have a directive to
324:21 - this namespace at the top of our code
324:37 - thank you
325:04 - let's hover our Mouse pointers over the
325:06 - list type in our code
325:08 - so notice the T with an angle brackets
325:11 - this T serves as a placeholder for a
325:13 - data type the developer is able to pass
325:16 - a data type as an argument to the
325:18 - generic list in order to declare that
325:21 - only the type passed into the T
325:23 - parameter must be stored within the
325:26 - relevant generic list
325:28 - so we have passed in the float data type
325:30 - to our generic list notice how there is
325:33 - a red squiggly line under each of the
325:35 - floating Point values we are attempting
325:37 - to add to our strongly typed generic
325:40 - list the c-sharp compiler is insisting
325:43 - that we express these floating Point
325:44 - values as the float data type and we
325:47 - know we can do this by adding an F to
325:49 - the end of each of these values like
325:51 - this
325:53 - through the use of generics the c-sharp
325:56 - compiler checks our code at compile time
325:58 - which prevents the possibility of type
326:01 - related runtime errors
326:03 - so we are simply commenting out the code
326:05 - where we previously used the arraylist
326:07 - and in its place applying the relevant
326:10 - generic list code
326:12 - our list is now strongly typed with the
326:14 - float data type which means that our
326:16 - list can only store value types that are
326:19 - of the float data type
326:21 - this is the basics of generics
326:48 - let's run the code
326:53 - great
326:55 - I hope you have enjoyed this video which
326:56 - serves as an introduction to generics
326:58 - and C sharp in the second video we'll go
327:01 - further into generics and introduce
327:03 - Associated Concepts like for example
327:05 - constraints
327:07 - for more videos on advanced c-sharp
327:09 - concepts and much more please consider
327:10 - subscribing and please ring the bell so
327:13 - that you'll be notified of future
327:14 - content released from this channel
327:16 - if you feel you've gained value from
327:18 - viewing this video please hit the like
327:20 - button it'll be greatly appreciated
327:22 - please feel free to share any of the
327:24 - videos released from this Channel with
327:26 - anyone you feel May benefit from their
327:28 - content
327:29 - your comments are of course welcome
327:31 - the code created in this tutorial can be
327:33 - downloaded from GitHub please see a link
327:36 - to the relevant repository Below in the
327:37 - description
327:40 - [Music]
327:46 - hi and welcome
327:48 - this video is the second part of a video
327:50 - series on c-sharp generics
327:53 - this video is also the second part of
327:55 - the fifth tutorial in a course on
327:57 - Advanced c-sharp topics
327:59 - so in this video we'll create a class to
328:01 - encapsulate the bubble sort algorithm
328:04 - cost will be a generic class that can be
328:07 - implemented to sort an array that
328:09 - contains values of any managed c-sharp
328:12 - data type
328:13 - this will include user-defined types
328:17 - so in order to enable sorting
328:19 - user-defined types the relevant
328:21 - user-defined type must implement the eye
328:23 - comparable interface
328:25 - the generic class that will implement
328:27 - the bubble sort algorithm will contain a
328:29 - constraint as part of its class
328:31 - definition we'll discuss the
328:34 - significance of using constraints in the
328:36 - context of generics and c-sharp and
328:38 - we'll demonstrate the use of a
328:39 - constraint through the code example
328:42 - for more videos on advanced c-sharp
328:44 - concepts and much more please consider
328:46 - subscribing and please ring the bell so
328:48 - that you'll be notified of future
328:50 - content released from this channel
328:53 - firstly to highlight the advantage of
328:55 - using generics and c-sharp I'm going to
328:58 - implement the functionality for this
329:00 - example in a non-generic way
329:03 - we'll then modify the code to implement
329:05 - generics to create the equivalent
329:08 - functionality
329:10 - so let's get started
329:12 - let's create a.net core console
329:15 - application
329:24 - and let's name this project generic
329:27 - bubble sort application
329:29 - I'm not going to explain the details of
329:31 - the bubble sort algorithm in this
329:33 - tutorial
329:34 - there are many available online
329:36 - tutorials regarding the bubble sort
329:38 - algorithm
329:39 - if you'd like me to explain the details
329:41 - of the bubble sort algorithm please let
329:43 - me know in the comments section and I'll
329:45 - be happy to make a video on the details
329:47 - of how the bubble sort algorithm works
329:49 - very basically the bubble sort algorithm
329:52 - is a simple sorting algorithm that
329:55 - repeatedly steps through a collection of
329:57 - values Compares adjacent elements and
330:00 - swaps them if they are in the wrong
330:02 - order
330:03 - our implementation of the bubble sort
330:05 - algorithm will work for any array of any
330:08 - c-sharp value type string data type as
330:11 - well as any user-defined type that
330:13 - implements the eye comparable interface
330:17 - so let's create a class that
330:19 - encapsulates a method containing the
330:21 - bubble sort algorithm
330:23 - let's first create this class as a
330:25 - non-generic class so that we can later
330:28 - turn this class into a generic class and
330:30 - in doing so highlight the benefits of
330:32 - using generics in our c-sharp code
330:37 - so let's create a public class named
330:40 - sort array
330:41 - let's create a public method within the
330:43 - sort array class named bubble sort
330:46 - this method does not return a value and
330:49 - contains a parameter which is an array
330:51 - defined as the system.object type
330:54 - remember we are first implementing our
330:57 - code in a non-generic way
330:59 - we want to be able to sort an array of
331:01 - any built-in value type string type and
331:04 - even user-defined types
331:07 - we are using the object dates tab rather
331:09 - than generics to enable sorting arrays
331:11 - of varying data types we are able to
331:14 - achieve this because all managed data
331:16 - types in c-sharp ultimately inherit from
331:19 - the system.object data type for Value
331:22 - types boxing functionality can be
331:24 - applied to store value type values
331:26 - inside an object reference type
331:29 - for more information on boxing and
331:31 - unboxing please click the card in the
331:34 - top right hand corner of your screen to
331:36 - watch the first part of this tutorial on
331:39 - c-sharp generics
331:41 - a link to this video has also been
331:42 - included Below in the description
331:45 - so let's write the code for the bubble
331:47 - sort method firstly let's set a local
331:49 - variable of the integer dates type to
331:52 - the length of the array that will be
331:54 - sorted by our bubble sort code this is
331:57 - the array that will be passed into this
331:59 - method at runtime we are now going to
332:01 - create two for Loops an outer loop and
332:04 - an inner loop
332:06 - let's create the outer loop first so
332:08 - this Loop simply traverses all the
332:10 - elements of the array that will be
332:12 - passed into this method at runtime
332:15 - for every traversal of the outer loop
332:17 - the inner loop traverses all the
332:18 - elements of the array minus the current
332:21 - value of the outer Loops incremented
332:24 - value in this case an integer value
332:26 - stored and a local variable named I
332:29 - and of course we know that the minus one
332:31 - and both the outer and inner Loops is
332:34 - there because arrays and C sharp are
332:36 - zero based
332:38 - so now within the inner loop we can
332:40 - write the code that compares the current
332:43 - elements value I.E the value currently
332:45 - being traversed with the value of the
332:48 - adjacent element in the relevant array
332:51 - so we can get the adjacent element by
332:53 - adding 1 to the value stored in the J
332:56 - variable which is being incremented by
332:59 - the inner for Loop statement
333:04 - so notice the red squiggly line when we
333:07 - try to perform our comparison code using
333:09 - the greater than symbol
333:12 - this is because the object type does not
333:14 - support the use of this operator for
333:16 - comparing one object value to another
333:19 - so value types like for example intload
333:22 - long Etc and the string dates type
333:25 - implement the eye comparable interface
333:27 - so we should be able to use the compare
333:30 - to method to perform the comparison
333:32 - functionality we need for our bubble
333:34 - sort algorithm the compare two method
333:37 - definition is a member of the I
333:39 - comparable interface
333:41 - the system.object type does not
333:44 - implement the eye comparable interface
333:46 - so we need to perform a runtime casting
333:48 - operation in order to use the compare to
333:51 - Method this highlights the danger of
333:53 - using the object data type and code like
333:56 - this because we are assuming that the
333:59 - elements of the array passed into this
334:01 - method at runtime will implement the eye
334:03 - comparable interface so this code runs
334:06 - the risk of causing a runtime error and
334:09 - at the very least carries the
334:10 - performance overhead and could when the
334:12 - costing operation is performed at
334:14 - runtime
334:15 - so we can perform the casting operation
334:18 - like this
334:19 - the way that comparet2 method works is
334:22 - that the current value is compared to
334:24 - another value and if the current value
334:26 - is greater in value than the other value
334:28 - an integer value greater than zero is
334:31 - returned to the calling code if the
334:34 - values are equal an integer value of 0
334:36 - is returned from the compare to method
334:38 - to the calling code
334:40 - if the current value is less than the
334:42 - other value that it is being compared to
334:44 - the compared to Method returns an
334:46 - integer value less than zero to the
334:48 - calling code
334:50 - so with regards to the bubble sort
334:52 - algorithm if the compare to Method
334:54 - returns a value greater than zero this
334:57 - means that the current value is greater
334:59 - than the value it is being compared to
335:01 - and the two elements need to be swapped
335:04 - in terms of their positions in the array
335:07 - so let's write the code for this
335:10 - let's set a variable named temp to the
335:13 - value of the current item being
335:15 - traversed
335:16 - let's then set the value for the current
335:18 - item in the array to the value of the
335:21 - adjacent item in the array I.E the value
335:24 - that the current item is being compared
335:26 - to
335:29 - then let's set the adjacent items value
335:32 - in the array to the current items value
335:34 - in the array I.E the value that is
335:37 - stored in the temp variable
335:39 - so in effect we have simply swapped the
335:41 - positions of two adjacent values in the
335:44 - relevant array
335:45 - so in the interests of cleaner code
335:47 - let's encapsulate the swapping
335:49 - functionality and a private method named
335:51 - swap
336:01 - and that's it we have implemented our
336:04 - bubble sort algorithm
336:06 - so let's go to the main method and write
336:08 - code to test our sort array class
336:11 - let's create an array of integer values
336:13 - where the values are stored in no
336:15 - particular order
336:26 - let's write code to instantiate an
336:28 - object of the sort array type
336:31 - let's write code to invoke the bubble
336:33 - sort method and pass in the relevant
336:36 - array that we want sorted
336:41 - okay there's a red squiggly line under
336:43 - the past in Array argument to the bubble
336:46 - sort method in our code
336:48 - this is because we need to change our
336:50 - definition of the relevant integer array
336:52 - to an object array
336:54 - let's write the code to write the values
336:57 - stored in the relevant array to the
336:58 - console screen
337:05 - let's run the code
337:11 - great and we can see that the values
337:14 - have been appropriately sorted
337:16 - Let's test our bubble sort functionality
337:18 - for an array of strings
337:32 - let's run the code
337:37 - great
337:39 - and let's now test our bubble sort code
337:41 - for an array of a particular
337:42 - user-defined type let's create our
337:45 - user-defined type so let's create a
337:47 - class named employee
337:49 - this will be the user-defined type that
337:51 - we'll use for this example where our
337:53 - bubble sort code sorts an array of a
337:55 - particular user-defined type
337:57 - let's keep this class simple and give it
338:00 - two Auto implemented properties ID as
338:02 - int name as string
338:05 - let's go to the main method and create
338:07 - an array of employee objects
338:10 - I'm going to add made up data for each
338:12 - employee object and these employee
338:15 - objects are deliberately unordered
338:37 - foreign
338:55 - let's run the code
339:01 - and we are getting a runtime error this
339:04 - is because our bubble sort code relies
339:07 - on the compare to method to compare the
339:09 - relevant values in the relevant array
339:11 - this means that the object stored within
339:15 - the relevant array must implement the
339:16 - eye comparable interface
339:19 - this highlights one of the reasons why
339:21 - our code should Implement generics we'll
339:23 - implement the generic version of this
339:25 - code in a bit
339:26 - for now to fix the runtime error let's
339:29 - make the employee class implement the
339:31 - icomparable interface
339:33 - let's hover our Mouse pointers over the
339:36 - red squiggly line under eye comparable
339:38 - click show potential fixes then let's
339:41 - click Implement interface
339:45 - we can now see that Visual Studio has
339:48 - created a method named compare to
339:51 - so we must Implement code here that
339:54 - compares the current object's ID with
339:56 - the ID of the object passed into the
339:58 - compare to method
340:00 - so to get the current object we can
340:03 - simply use the this keyword
340:06 - the object that will compare our current
340:09 - object to is the object that will be
340:11 - passed into the parameter named object
340:13 - which is a parameter contained within
340:15 - the compare to method
340:17 - as you can see the relevant parameter
340:20 - named object is of type object so we
340:23 - need to type cost this object to
340:25 - employee notice that we need to perform
340:28 - a lot of runtime casting to make this
340:30 - code work this is not a good thing and
340:32 - we'll solve this problem in a bit using
340:34 - generics
340:35 - so we are going to sort the employee
340:38 - objects in the relevant array by their
340:41 - ID properties
340:42 - the ID property is of type integer
340:45 - integers and c-sharp implement the
340:47 - compare to Method so we can simply write
340:49 - code to return the result of the compare
340:51 - to method to the calling code like this
340:55 - so this code simply compares the ID of
340:58 - one employee object with the ID of
341:00 - another employee object and returns an
341:02 - appropriate value to the calling code as
341:05 - stated earlier a value greater than zero
341:08 - if the current employee object's ID is
341:11 - greater then the other employee object's
341:13 - ID
341:14 - 0 if they are equal in value and a value
341:17 - less than zero if the current employee
341:19 - object's ID is less then the employee
341:22 - object ID that the current employee
341:24 - object's ID is being compared to the
341:27 - string data type also implements the eye
341:28 - comparable interface so we could replace
341:31 - this code with similar code that
341:33 - compares the current employee object's
341:35 - name property with the other employee
341:37 - object's name property we'll test this a
341:40 - bit later
341:41 - I'm also going to override the tostring
341:43 - method in the employee class so that we
341:46 - can display the employee objects ID
341:47 - property followed by the employee
341:49 - object's name property when an employee
341:52 - item's values are written to the console
341:54 - screen
341:55 - so when we write an employee item to the
341:58 - console screen both the ID and the name
342:00 - properties of the relevant employee
342:02 - objects will be outputted to the screen
342:05 - so let's run the code
342:10 - okay so this is not the result we
342:12 - expected in order for our override of
342:15 - the tostring method to be executed we
342:18 - need to type cast the item we are
342:20 - writing to the screen
342:21 - to the employee type note the need for
342:25 - more bad type cost and code
342:28 - let's try again
342:31 - and now our code works as expected you
342:34 - can see that the employee objects within
342:36 - the array have been ordered by their ID
342:38 - properties as expected great
342:41 - so the sort array class now works for
342:44 - multiple data types
342:47 - we have achieved this functionality by
342:49 - using the system.object type
342:52 - this is because all managed data types
342:55 - in c-sharp ultimately inherit from the
342:57 - system.object type for more information
342:59 - on c-sharp data types please click the
343:02 - card made available in the top right
343:03 - hand corner of your screen to view a
343:06 - video on c-sharp data types
343:10 - so let's see how we can achieve the same
343:12 - functionality but through the use of
343:14 - generics
343:16 - we'll also see why it is more
343:18 - advantageous to use generics to avoid
343:20 - the performance penalties incurred by
343:22 - using the system.object type to achieve
343:24 - the desired functionality
343:27 - so through our use of generics we can
343:29 - also eliminate the risk of data type
343:31 - related runtime errors
343:33 - so let's change our sort array class
343:35 - into a generic class
343:37 - we can do this by adding a placeholder
343:40 - represented by a capital T with an angle
343:42 - brackets after the sort array class name
343:45 - and our class definition
343:47 - let's then replace all of our object
343:49 - type definitions with the placeholder
343:52 - data type represented by the capital T
343:54 - in our code
343:55 - in the main method we must add angle
343:58 - brackets after the sort array type when
344:00 - we instantiate an object of type sort
344:03 - array like this
344:04 - within the angle brackets we must
344:06 - include the relevant data type to
344:08 - strongly type the class
344:10 - in this case we are testing sorting an
344:13 - array of employee objects so we must
344:15 - include the employee data type within
344:17 - angle brackets
344:20 - we can now remove the costing operation
344:22 - from the code that writes the employee
344:24 - data to the console screen
344:25 - let's run the code
344:29 - great
344:31 - we are using generics now so let's
344:33 - remove the typecasting functionality
344:35 - where we are casting type object to type
344:38 - I comparable in the bubble sort method
344:41 - foreign
344:47 - squiggly line under the compare to
344:49 - Method call within the bubble sort
344:51 - method
344:52 - the red squiggly line is a result of the
344:55 - fact that we have not told the c-sharp
344:57 - compiler that type T implements the eye
345:00 - comparable interface which contains the
345:02 - compare to method so you'll notice when
345:05 - we add a DOT after an item referenced in
345:08 - our array the compare to method is not
345:10 - available in the intellisense drop-down
345:13 - list this is because visual studio and
345:15 - the c-sharp compiler has no way of
345:17 - knowing that type T implements the eye
345:20 - comparable interface
345:22 - so how can we declare that type T
345:24 - implements the eye comparable interface
345:27 - we can do this through the
345:28 - implementation of a constraint
345:30 - by adding a constraint we are
345:33 - constraining our T-Type parameter to a
345:35 - rule that any type passed as an argument
345:38 - to the T parameter must implement the I
345:41 - comparable interface
345:43 - so to add the desired constraint we can
345:45 - add the following code to our sort array
345:48 - class definition where space t colon I
345:52 - comparable
345:54 - so we have now implemented the desired
345:57 - constraint for our generic sort array
345:59 - class and the red squiggly line goes
346:01 - away
346:02 - and now if we add a DOT after our item
346:05 - referenced in the relevant array we can
346:08 - see the compare to method which is a
346:10 - member of the icon Parable interface and
346:12 - our intellisense drop down list
346:15 - so let's go to the main method
346:18 - let's first test our new generic version
346:21 - of the sort array class that now
346:22 - contains a constraint with an array of
346:25 - integers
346:27 - now that we are using generics to
346:29 - implement the sort array class we can
346:31 - use the int type to declare our array of
346:34 - integers rather than the object type
346:36 - so notice how we are passing in the end
346:39 - dates type between the angle brackets
346:40 - for the code that instantiates the sort
346:42 - array class
346:44 - we are now able to strongly type our
346:46 - sort array class
346:48 - Let's test the code
346:52 - great
346:53 - Let's test our string array so this time
346:56 - we must include the string data type
346:58 - within angle brackets when we
347:01 - instantiate the sort array class
347:10 - great
347:13 - and then let's test our code with our
347:16 - array containing values of the
347:18 - user-defined type employee
347:21 - but before we do this
347:23 - you'll notice that we currently need to
347:25 - perform a conversion operation within
347:28 - the compare to method of the employee
347:30 - class to convert the obj argument which
347:33 - is defined as object to an employee type
347:36 - we don't want this extra overhead caused
347:39 - by the costing operation at runtime so
347:41 - to solve this problem we can implement
347:43 - the generic version of the icomparable
347:45 - interface we can pass the employee data
347:49 - type as an argument to the generic
347:51 - version of the eye comparable interface
347:53 - like this
347:54 - so let's modify our code so that we are
347:58 - implementing the compare to Method
347:59 - contained within the generic version of
348:01 - the icomparable interface to do this
348:04 - let's first comment out our current
348:06 - compare to method
348:08 - let's then hover our Mouse pointers over
348:10 - the red squiggly line in our class
348:11 - definition
348:13 - click show potential fixes and then
348:15 - click Implement interface
348:17 - you'll notice that the new version of
348:20 - the compare to Method generated by
348:21 - Visual Studio contains a parameter that
348:25 - is strongly typed with the employee
348:27 - user-defined type
348:29 - so let's copy our old implementation of
348:31 - the compare to method and paste it into
348:33 - our new version of the compare to method
348:37 - we can now remove the casting operation
348:39 - from our new strongly typed version of
348:41 - the compare to method
348:43 - so now there is a red squiggly line
348:44 - under the employee type being passed as
348:47 - a data type argument to the sort array
348:49 - class in our main method
348:51 - this is because in our sort array class
348:53 - definition we have a constraint which
348:56 - enforces a rule at compile time that any
348:58 - type passed into the sort array class
349:00 - must implement the eye comparable
349:02 - interface our employee class is now
349:05 - implementing the generic version of the
349:07 - eye comparable interface so we need to
349:09 - modify our constraint and our sort array
349:12 - class definition to establish a rule
349:14 - that any data type passed to the
349:16 - relevant T data type parameter must
349:18 - implement the generic version of the
349:20 - icomparable interface so our constraint
349:24 - now pertains to any type that implements
349:26 - the generic I comparable interface
349:31 - following this modification our code
349:33 - will still work for the integer data
349:35 - type which is a value type and the
349:37 - string dates tab because both the int
349:40 - data type and the string data type
349:42 - implement the generic version of the eye
349:45 - comparable interface our sort array
349:47 - class will also work for any user's
349:49 - defined type like our employee type that
349:52 - appropriately implements the generic
349:54 - version of the eye comparable interface
349:58 - Let's test our code
350:04 - great
350:08 - so let's say we want to sort our
350:10 - employee objects by name to achieve this
350:12 - we can simply change the implementation
350:15 - of the compare to Method within the
350:17 - employee class like this
350:26 - Let's test the code
350:29 - great
350:31 - let's also test the code for an integer
350:33 - array
350:34 - foreign
350:43 - let's firstly select the int dates type
350:46 - in our code right click on it and then
350:49 - select go to definition you can see the
350:51 - in-states type implements the
350:53 - non-generic version of the eye
350:54 - comparable interface and also implements
350:57 - the generic version of the eye
350:59 - comparable interface
351:03 - let's run the code
351:07 - great let's also test the code for a
351:10 - string array
351:14 - great
351:30 - so we have written a generic class that
351:32 - can sort an array of any built-in value
351:35 - type string data type as well as any
351:37 - user-defined type that appropriately
351:39 - implements the eye comparable generic
351:42 - interface
351:43 - by using generics we eliminated the need
351:45 - for a lot of type conversion operations
351:47 - which would be performed at runtime and
351:50 - carries the risk of incurring runtime
351:51 - errors
351:52 - using generics can also enhance the
351:55 - performance of your application because
351:57 - the.net runtime no longer has the
351:59 - overhead of Performing these casting
352:01 - operations at runtime
352:03 - generics allows us to defer type
352:05 - specifications for a unit of code this
352:08 - allows us to strongly type a unit of
352:10 - code for example a class method or
352:12 - collection type at compile time this
352:15 - means generics inherently has the
352:17 - advantage of compile time data checks to
352:20 - prevent the possibility of type-related
352:22 - runtime errors occurring
352:24 - we use the constraint to indicate to the
352:26 - compiler that the generic type parameter
352:28 - represented by the capital T between
352:30 - angle brackets in our class definition
352:32 - must implement the generic I comparable
352:34 - interface this allowed Visual Studio to
352:37 - make available the compare to method on
352:40 - an object defined as T through
352:42 - intellisense and ensured that the
352:44 - compare to method is available on all
352:47 - relevant elements within the relevant
352:48 - array which are of type T at runtime
352:51 - so generics and the use of a constraint
352:54 - has been implemented so that we can
352:56 - Implement one pattern of logic in this
352:58 - case the bubble sort algorithm for any
353:00 - c-sharp built-in value type EG int long
353:03 - float double Etc the string dates type
353:06 - as well as any user-defined type that
353:09 - appropriately implements the generic I
353:11 - comparable interface
353:13 - I hope you've enjoyed this video on
353:15 - using generics with constraints in C
353:18 - sharp
353:19 - in the next video we'll delve deeper
353:21 - into generics
353:23 - for more videos on advanced c-sharp
353:25 - concepts and much more please consider
353:26 - subscribing and please ring the bell so
353:29 - that you'll be notified of future
353:30 - content released from this channel
353:32 - if you feel you've gained value from
353:34 - viewing this video please hit the like
353:36 - button it will be greatly appreciated
353:37 - please feel free to share any of the
353:40 - videos released from this Channel with
353:41 - anyone you feel May benefit from their
353:43 - content your comments are of course
353:45 - welcome the code created for this
353:47 - tutorial can be downloaded from GitHub
353:49 - please see a link to the relevant
353:51 - repository Below in the description
353:54 - [Music]
354:03 - hi and welcome this video is the third
354:06 - part of a video series on c-sharp
354:08 - generics
354:10 - this video is also part of a tutorial
354:12 - which is the fifth part of a course on
354:14 - advanced c-sharp concepts
354:17 - in this video we'll look at generic
354:19 - delegates and events in c-sharp we'll
354:22 - also look at other Concepts associated
354:24 - with c-sharp generics including the use
354:27 - of a generic c-sharp built-in data
354:29 - structure namely the queue data
354:31 - structure
354:32 - we'll explore these Concepts associated
354:35 - with generics through a practical
354:37 - example
354:39 - the theme I've chosen for this practical
354:41 - example is a warehouse management system
354:44 - for more videos on advanced c-sharp
354:46 - concepts and much more please consider
354:48 - subscribing and please ring the bell so
354:50 - that you'll be notified of future
354:51 - content released from this channel
354:53 - we need to use our imaginations a bit
354:55 - because the example will be highly
354:57 - simplified and expressed through a.net
355:00 - core console application
355:02 - so the code will provide the
355:03 - functionality of a real-time monitoring
355:05 - system for items entering a warehouse
355:07 - and subsequently being processed by
355:10 - processed I mean the item is placed in a
355:12 - predefined location within the warehouse
355:14 - for storage
355:16 - so an event is raised when an item
355:18 - enters the warehouse and an event is
355:20 - subsequently raised once the relevant
355:22 - item has reached its predefined location
355:24 - within the warehouse
355:26 - note that when I refer to an item I'm
355:29 - referring to a batch of units of a
355:30 - particular type so in our example the
355:34 - item can refer to a quantity of units a
355:37 - unit in this example will be a hardware
355:39 - related item for example a drill hammer
355:44 - ladder Etc
355:46 - so if we use our imaginations we can
355:49 - picture the scenario in the real world
355:51 - an item enters the warehouse and is
355:53 - scanned
355:54 - so let's say the item has a QR code
355:56 - attached to it
355:58 - that when scan provides necessary
356:00 - information about the item
356:04 - when the item is scanned an event is
356:06 - raised so for example a supervisor could
356:09 - be monitoring the relevant activities
356:11 - relating to the warehouse and when an
356:13 - event is raised the relevant information
356:16 - is displayed on a screen in real time
356:19 - so the supervisor could for example be
356:21 - monitoring these real-time events using
356:23 - a handheld device
356:24 - a desktop computer or a notebook
356:26 - computer the display could perhaps be a
356:29 - large screen TV that multiple employees
356:31 - can monitor
356:33 - the use of events decouples the
356:35 - component that raises the event which
356:37 - could for example be an on-site scanning
356:40 - facility from a component that receives
356:42 - the event notification which could for
356:44 - example be a handheld device used by a
356:47 - supervisor to monitor events either on
356:50 - site or even remotely if required so for
356:53 - example a box containing drills arrives
356:55 - to be stored at the warehouse
356:57 - the QR code attached to the relevant box
357:00 - that the drills are in is scanned the
357:03 - box is then transported to a predefined
357:06 - location in the warehouse to be stored
357:07 - so when the box is placed in its
357:10 - relevant location perhaps pressure pads
357:12 - at the location are used to detect that
357:14 - the box of drills has been processed
357:17 - when I say processed Amin has arrived at
357:19 - its designated location to be stored in
357:22 - the warehouse
357:23 - so when the relevant pressure pad
357:25 - detects that the relevant box has been
357:27 - placed in its designated location in the
357:29 - warehouse an event is raised
357:32 - and the relevant information about the
357:34 - event is sent to the calling code
357:36 - which will then display the relevant
357:38 - information about the event and the
357:40 - processed item to the supervisor's
357:43 - screen
357:44 - so this is a real-time monitoring system
357:46 - for a warehouse
357:48 - please note I have never actually worked
357:50 - in a warehouse and this example is
357:52 - purely from my imagination it's
357:54 - obviously always best when building a
357:56 - particular kind of application or system
357:58 - to consult with someone with the
358:00 - relevant domain knowledge this example
358:02 - only serves to help with the
358:04 - understanding of generic delegates and
358:06 - events
358:07 - right let's begin
358:09 - let's create a.net core console
358:11 - application
358:13 - [Music]
358:22 - and let's name this project hardware
358:24 - warehouse management system so this
358:27 - project will contain our calling client
358:29 - code
358:31 - we want this project to reference
358:32 - another component responsible for
358:34 - generic functionality associated with a
358:36 - warehouse
358:38 - so let's add a net standard Library
358:40 - project and let's name this project
358:42 - warehouse management system API
358:50 - let's create a reference to the
358:52 - warehouse management system API project
358:54 - from the hardware warehouse management
358:56 - system project
359:01 - so we'll start by building the generic
359:03 - functionality for our hardware warehouse
359:05 - management system by adding code to our
359:07 - warehouse management system API project
359:12 - so we have separated concerns here we
359:15 - have created two components one to
359:17 - handle the specific functionality of the
359:20 - hardware warehouse this functionality
359:22 - will be encapsulated in the hardware
359:24 - warehouse management system project
359:27 - the code in this component will focus on
359:29 - displaying the status and data about
359:31 - specific Hardware related items to a
359:34 - screen in real time as certain events
359:36 - are raised
359:37 - the other component is a generic
359:39 - component specifically created for
359:41 - handling the management of any warehouse
359:45 - this component is responsible for racing
359:47 - events associated with any warehouse to
359:49 - the calling client code
359:51 - when each event is raised from the
359:53 - warehouse management system API
359:55 - component to the hardware warehouse
359:57 - management system component the relevant
360:00 - data associated with the relevant event
360:02 - and item is displayed to the screen in
360:05 - real time to for example a supervisor so
360:09 - let's write the code for our example
360:11 - let's start by deleting the default
360:13 - class from our warehouse management
360:15 - system API project
360:17 - let's add a class named custom queue in
360:21 - the custom queue class we are going to
360:23 - wrap the functionality provided by the
360:25 - built-in c-sharp generic Q data
360:27 - structure
360:29 - we are going to customize the
360:31 - functionality of the queue by adding two
360:33 - events simply put one event will be
360:35 - raised when an item is added to the
360:37 - queue the other event will be raised
360:39 - when an item is removed from the queue
360:41 - as you may have guessed when an item is
360:44 - added to the queue this denotes an item
360:46 - for example a box containing drills
360:49 - entering the warehouse the second event
360:51 - denotes the event that will be raised
360:54 - for example once the relevant box
360:56 - containing the drills has been processed
360:58 - I.E has been placed in its specified
361:01 - location to be stored within the
361:03 - warehouse
361:05 - so let's make our custom Q class a
361:07 - generic class
361:11 - a generic class can contain more than
361:14 - one type parameter but we are only going
361:16 - to add one type parameter for this class
361:19 - so using the capital t is the generally
361:22 - accepted way to represent the
361:24 - placeholder for a type parameter and a
361:27 - generic type definition if there were
361:29 - two type parameters
361:31 - we could add a comma and then the
361:34 - capital letter U to represent a second
361:36 - type parameter this generic class will
361:39 - only contain one type parameter so let's
361:41 - remove the second type parameter
361:44 - so by adding t with an angle brackets
361:47 - following our class's name we have
361:49 - created our custom Q class as a generic
361:52 - class
361:53 - so let's create a private member
361:55 - variable of the inbuilt c-sharp Q
361:58 - generic collection type
362:00 - so let's define this member variable as
362:03 - the generic Q data type and let's name
362:06 - our variable underscore Q
362:09 - and you can see that a directive at the
362:11 - top of our code already exists to the
362:14 - system.collections.generic namespace the
362:16 - queue data type is a member of the
362:19 - system.collections.generic namespace
362:22 - let's create a parameterless Constructor
362:24 - for the custom queue class
362:26 - let's instantiate the underscore Q
362:28 - variable within our Constructor
362:30 - let's create a read-only property and
362:33 - Implement code that Returns the number
362:35 - of items currently stored in the
362:38 - underscore queue collection
362:46 - let's create the definitions for the
362:47 - public methods that will be included in
362:50 - the custom queue class
362:52 - we'll first add their definitions and
362:54 - then implement the code for each method
362:58 - let's create a method named add item
363:01 - that contains a parameter of type t
363:05 - this method will be called when an item
363:07 - is added to the custom queue
363:10 - let's create a method named get item
363:13 - this method will return an item stored
363:15 - within the queue to the calling code
363:18 - this method returns a value of type T
363:20 - and contains no parameters
363:23 - let's create a protected virtual method
363:26 - named On Cue changed this method will
363:29 - encapsulate the functionality for
363:31 - raising the events of this class
363:34 - it contains a parameter of a
363:36 - user-defined type that we need to create
363:39 - the value passed to this parameter will
363:42 - store information about the relevant
363:43 - event being raised from within this
363:46 - method
363:47 - so let's create a class definition for a
363:49 - class named Q event args this class will
363:52 - extend the functionality of the
363:54 - system.eventorg's built-in class so
363:57 - let's write code so that this class
363:59 - inherits from the system.event args
364:01 - built-in class
364:03 - let's add a read write autoimplemented
364:06 - property named message to the queue
364:08 - event args class
364:11 - the message property will return a
364:13 - string narrative which will include
364:15 - details about the item to which the
364:17 - event pertains as well as information
364:19 - about the event itself
364:40 - so the last method we need to create is
364:42 - a public method named get enumerator so
364:45 - this method returns a value of the
364:47 - generic I enumerator interface type to
364:50 - the calling code
364:52 - so let's implement the code for this
364:54 - method the implementation is one line of
364:57 - code which Returns the value returned
364:59 - from the underscore Q member variables
365:01 - Getty numerator method by implementing
365:04 - this get enumerator method on our custom
365:07 - queue class this will allow the calling
365:09 - code to Traverse the elements stored
365:12 - within the custom Q class collection
365:14 - using a for each Loop
365:16 - we'll demonstrate this at an appropriate
365:19 - time during the development of this
365:21 - example
365:22 - so let's create our delegate type
365:25 - which will be used to define an event in
365:27 - the custom queue class I.E the event
365:29 - that is raised when an item is added to
365:32 - the queue and also an event raised when
365:35 - an item is returned from the queue
365:37 - let's define our generic delegate type
365:40 - directly within the warehouse management
365:42 - system API namespace let's create a
365:45 - public delegate named Q event handler
365:47 - that does not return a value and
365:49 - contains two generic parameters
365:51 - the first parameter is of type t
365:54 - and the second parameter is of Type U
365:57 - this is a generic delegate that contains
365:59 - two type parameters
366:01 - so we must include the placeholder data
366:03 - types within angle brackets
366:08 - the capital letter T represents a
366:10 - placeholder for the first generic data
366:11 - type parameter and the capital letter U
366:14 - represents a placeholder for the second
366:16 - generic data type parameter
366:19 - so now we can define the definition for
366:21 - the event contained within our custom
366:23 - queue user-defined type
366:26 - so to do this we use the event keyword
366:29 - this is a public event to which we want
366:31 - our calling code to subscribe so we
366:34 - proceed the event keyword with the
366:35 - public access modifier then we follow
366:38 - the event keyword with the generic
366:40 - delegate type that we have just defined
366:41 - the generic Q event handler delegate and
366:45 - let's strongly type our generic delegate
366:48 - let's pass the custom Q generic
366:50 - user-defined type to the first generic
366:53 - data type parameter and let's pass the Q
366:55 - event args use the defined type to the
366:58 - second generic data type parameter let's
367:00 - name our event custom queue event
367:03 - so let's implement the code for the On-Q
367:05 - changed method this method centralizes
367:08 - the code for raising the custom queue
367:11 - event event
367:12 - so the first argument passed to this
367:14 - event
367:16 - is of the generic user-defined type
367:18 - named custom queue which is the class in
367:20 - which this method resides
367:23 - so to get the current object we can use
367:25 - the this keyword
367:28 - the second argument is the argument
367:29 - passed to this method's parameter and
367:32 - will contain information about the event
367:34 - and is of type Q event args so we pass
367:38 - the On Cue changed methods argument a as
367:42 - the second arguments to the custom queue
367:44 - event event
367:46 - so let's implement the code for the add
367:48 - item method
367:50 - firstly let's write code to add the item
367:52 - passed into the add item method to the
367:55 - underscore queue collection
367:57 - note that in order to add an item to the
368:00 - built-in C Sharp Q data structure we
368:02 - must use the NQ method
368:06 - so before we write the code to raise our
368:09 - custom queue event event which will be
368:11 - executed every time the relevant queue
368:13 - is changed let's look at the Q generic
368:16 - collection type in C sharp
368:20 - when we use the NQ method to add an item
368:23 - to a queue data structure in C sharp the
368:25 - underlying functionality of the Q
368:27 - collection type is adding the relevant
368:29 - item to the back of the queue as it were
368:32 - so later when we write the functionality
368:34 - to retrieve an item from the queue we'll
368:37 - use the DQ method the DQ method
368:40 - retrieves an item from the front of the
368:42 - queue
368:44 - the queue data structure works on a fifo
368:47 - basis fifo is an acronym for first in
368:51 - first out
368:52 - so the item in the queue that was the
368:55 - first item to be added to the queue when
368:57 - the NQ method was executed will be the
369:00 - first item to be retrieved from the
369:02 - queue when the DQ method is executed
369:05 - we'll use the DQ method when we
369:07 - implement the functionality for the get
369:09 - item method
369:11 - note that when the DQ method is executed
369:14 - to retrieve an item from the queue the
369:16 - first item added to the queue which will
369:18 - be the item at the front of the queue is
369:21 - removed from the queue which means the
369:23 - item that was added to the queue right
369:25 - after the item that was just retrieved
369:28 - from the queue takes the position
369:29 - previously occupied by the item just
369:32 - retrieved from the queue
369:35 - so the way the ordering of the Q data
369:37 - structure works is just like how a queue
369:40 - works in the real world for example
369:41 - consider people queuing to buy tickets
369:44 - to an event
369:45 - when a person joins the queue the person
369:47 - joins the Queue at the back of the queue
369:49 - the person at the front of the queue
369:51 - buys a ticket then leaves the queue
369:53 - making the person that was behind the
369:56 - person who has just left the queue now
369:59 - the person at the front of the queue
370:00 - this person can now buy a ticket and the
370:03 - cycle repeats
370:05 - so after the NQ method has been executed
370:08 - this means the relevant queue has
370:10 - changed so we want to raise an
370:11 - appropriate event to the calling client
370:13 - code to let the client code know that
370:16 - the relevant queue has changed
370:18 - when the event is raised we can pass two
370:21 - arguments to the calling client the
370:23 - first argument is the queue itself which
370:26 - is encapsulated in our custom Q generic
370:28 - class
370:29 - the second argument contains information
370:31 - about the event as well as information
370:33 - about the item that triggered the event
370:37 - this information is encapsulated in the
370:39 - queue event args user-defined type
370:44 - so let's write code to instantiate an
370:46 - object of type Q event args
370:49 - and we want to send information about
370:51 - the item being added to the queue
370:53 - through the message property which is a
370:56 - member of the Q event args class to the
370:59 - calling client code
371:01 - notice at the moment if we include a
371:04 - full stop after the item variable we
371:07 - don't get any properties in the
371:09 - intellisense drop down list in Visual
371:11 - Studio
371:12 - for example we don't get the ID name or
371:15 - type properties that could provide
371:17 - useful information to the calling client
371:19 - code about the item that triggered the
371:22 - relevant event
371:23 - so how can we solve this problem
371:26 - we can solve this problem by ensuring
371:28 - that items added to the queue Implement
371:31 - a specific interface
371:33 - then we can add a constraint to our
371:35 - generic custom queue class that enforces
371:38 - a rule that type T must implement the
371:41 - relevant interface
371:42 - so let's add an interface to our
371:45 - warehouse management system API project
371:48 - let's name this interface I entity
371:50 - primary properties
371:54 - foreign
371:59 - let's add three property definitions ID
372:03 - as integer name as string and type as
372:06 - string
372:07 - let's go back to the custom Q class
372:10 - and let's add a constraint to our custom
372:12 - queue class
372:14 - so we can add the constraint like this
372:17 - where space t colon I entity primary
372:21 - properties
372:23 - so we now know that any item added to
372:26 - the queue will implement the I entity
372:28 - primary properties interface which means
372:31 - the item will have an ID property a name
372:33 - property and a type property
372:38 - so because we have added this constraint
372:40 - we should now be able to see these
372:43 - properties if we add a DOT at the end of
372:45 - an object passed into the add item
372:48 - method as an argument
372:50 - so let's add a DOT at the end of the
372:52 - item variable and you can see the ID
372:55 - name and type properties in the
372:57 - intellisense drop down list
372:59 - this means we can include the
373:01 - information stored in these properties
373:03 - in our message to the calling client
373:05 - code
373:06 - so in the message property let's add a
373:09 - timestamp
373:13 - foreign
373:21 - so I'm going to add a new class named
373:23 - constants so that I can store a string
373:26 - constant that can be reused to represent
373:29 - a date time format for this project
373:54 - and let's include the formatting for the
373:56 - relevant date time stamp using our date
373:58 - time format constant
374:09 - followed by the relevant ID name and
374:12 - type property stored for the relevant
374:14 - item
374:15 - great but let's say we want to include
374:18 - additional information in our message to
374:21 - the calling client code
374:22 - we want to include the quantity of units
374:25 - that make up the item that has entered
374:27 - the warehouse remember items are
374:30 - composed of units we also want to
374:32 - include the value of each unit with the
374:35 - additional information
374:37 - for design reasons we don't want to
374:39 - include the quantity property and the
374:41 - unit value property in the I entity
374:44 - primary properties interface
374:46 - so let's add another interface to the
374:48 - warehouse management system API project
374:50 - and let's name this interface I entity
374:54 - additional properties
375:00 - let's add two properties to this
375:02 - interface
375:03 - quantity as int unit value as decimal
375:07 - let's go back to our custom queue class
375:10 - and let's add another constraint to the
375:12 - custom Q class definition
375:15 - to do this we can simply add a comma and
375:18 - then I entity additional properties to
375:21 - the custom Q class definition for
375:24 - now let's see if our new properties
375:26 - appear in the intellisense drop down
375:28 - when we add a DOT after the item
375:30 - variable which is of type t
375:35 - and there you can see our additional
375:36 - properties quantity and unit value
375:40 - so let's include the quantity property
375:42 - in our message
375:44 - the unit value property will be
375:46 - displayed to the user along with all the
375:48 - other properties in a tabular format
375:50 - every time the queue changes we'll see
375:53 - this when we develop the calling client
375:55 - code
375:57 - let's add the following narrative text
375:59 - literal to the message property has been
376:02 - added to the queue
376:21 - so let's implement the code for the get
376:23 - item method so let's first assign The
376:26 - Returned value from the relevant Q IE
376:29 - the value returned from the DQ method to
376:32 - a local variable of type t
376:34 - the DQ method also removes the item at
376:37 - the front of the queue
376:39 - so let's write the code that will notify
376:41 - the calling client that the queue has
376:43 - changed
376:45 - let's set the message property of the
376:47 - queue event args object in much the same
376:50 - way as we did in the add item method
376:54 - the difference is that this method
376:56 - denotes that the relevant item in the
376:57 - queue has been processed so let's
377:00 - reflect this in our narrative
377:02 - so let's add the literal text has been
377:04 - processed to our narrative
377:07 - so an item is removed from the queue
377:09 - once the item has been processed by
377:12 - processed we mean that the item has been
377:14 - placed in a designated location in the
377:16 - warehouse for storage
377:18 - the item is added to the queue
377:22 - when it first enters the warehouse then
377:24 - the item is scanned
377:26 - when the item is scanned the event and
377:29 - the add item method is raised
377:32 - when a predefined amount of items are in
377:35 - the queue the items in the queue are
377:37 - processed I.E each item is placed in a
377:40 - specific location in the warehouse to be
377:42 - stored
377:44 - each time an item is placed in its
377:47 - location for storage a pressure pad is
377:49 - activated at the relevant storage
377:51 - location which raises an event to notify
377:54 - the calling client code that the
377:56 - relevant item has been processed
378:01 - we have now implemented the code for the
378:03 - custom queue class and we have also
378:05 - completed the code for the warehouse
378:07 - management system API component
378:10 - let's implement the code for the calling
378:12 - client
378:13 - so in this example we have a warehouse
378:15 - used for storing Hardware related items
378:17 - when we refer to an item in the context
378:20 - of this example we mean a collection of
378:23 - a certain type of Hardware item
378:26 - so for example we are going to use four
378:29 - distinct item types drill hammer ladder
378:33 - and paintbrush
378:35 - so in this example an item could refer
378:37 - to a collection of drills a collection
378:39 - of hammers a collection of paint brushes
378:41 - or a collection of ladders
378:44 - so let's define an abstract class named
378:46 - Hardware item which must implement the
378:49 - interfaces we created in the warehouse
378:51 - management system API component namely
378:54 - the I entity primary properties and the
378:57 - I entity additional properties
378:59 - interfaces
379:01 - we have already created a reference from
379:04 - the hardware warehouse management system
379:06 - project
379:07 - to the warehouse management system API
379:09 - project but we must also ensure that we
379:13 - have included a directive at the top of
379:15 - our code to the warehouse management
379:17 - system API namespace
379:20 - so let's do this
379:25 - great
379:31 - let's create auto implemented properties
379:33 - for each property definition in the I
379:35 - entity primary properties and the int
379:38 - additional properties interfaces
379:48 - foreign
379:59 - classes representing a specific type of
380:02 - item that will be stored in the
380:04 - warehouse let's start with the drill
380:07 - so we must make the drill class inherit
380:10 - from the hardware item abstract class
380:13 - let's say we also wish to create more
380:15 - specific Properties or behaviors for the
380:18 - drill class we can do this by adding an
380:20 - interface to define specific Properties
380:22 - or behaviors relating to the drill class
380:25 - by creating an interface that the drill
380:27 - class must implement
380:29 - so let's create an interface named I
380:31 - drill
380:33 - for the sake of keeping our example
380:35 - simple let's just add one property
380:37 - definition for the ideal interface let's
380:40 - make it a string property and name it
380:42 - drill brand name
380:44 - so this property is only intended to
380:46 - acknowledge that we are able to extend
380:49 - each of the classes representing
380:51 - specific products in this example but we
380:54 - won't be using these properties further
380:55 - than this
380:57 - so let's ensure that the drill class
380:59 - implements the idrill interface
381:06 - let's implement the same design for our
381:08 - other items ladder
381:15 - paintbrush
381:28 - and Hammer
381:37 - great
381:40 - so let's go to our main method and
381:42 - simulate items entering the warehouse by
381:44 - adding items to a custom queue object
381:47 - let's instantiate an object of the
381:50 - generic custom Q class to find in the
381:52 - warehouse management system API
381:54 - component that our calling client code
381:56 - references
381:58 - let's strongly type our queue with the
382:01 - hardware item abstract class
382:03 - we do this because all items in our
382:05 - warehouse will inherit from the hardware
382:08 - item abstract class
382:11 - so the next step is to wire up a method
382:13 - to handle the event defined within the
382:16 - custom queue class this is an event that
382:19 - is raised whenever the relevant queue
382:21 - changes for example an item is added to
382:23 - the queue denoting a hardware item
382:25 - entering the warehouse or an item is
382:28 - removed from the queue denoting that the
382:30 - item has been processed I.E the item has
382:33 - been moved to a predefined location
382:35 - within the warehouse for storage
382:38 - so to wire up the relevant event we type
382:42 - the object reference custom queue add a
382:45 - DOT and then we can see the relevant
382:47 - event in the intellisense drop down list
382:49 - so let's select the event named custom
382:52 - queue event
382:54 - then we can type in the plus equals
382:56 - operator to establish a method that we
382:59 - want to execute when the relevant event
383:01 - is raised
383:02 - so we can Auto generate the relevant
383:04 - method through Visual Studio by pressing
383:07 - the Tab Key
383:10 - we can now implement the custom code we
383:12 - want to execute it every time the queue
383:14 - changes within the relevant method we
383:16 - have just generated
383:23 - so let's first write code to clear the
383:26 - screen
383:27 - so notice that the first argument passed
383:30 - to this method is an object of type
383:32 - custom Q it is named sender because the
383:35 - event that is fired resides in this
383:38 - class
383:39 - so the event notification is sent from
383:41 - the custom cue class when the relevant
383:44 - event is fired
383:45 - so the second argument is of type Q
383:48 - event args and encapsulates relevant
383:50 - information about the relevant event so
383:53 - let's write code to check if the sender
383:55 - object which is an object of type custom
383:57 - queue contains any items
384:00 - so to do this we can use an if statement
384:03 - to check the Q length property of the
384:06 - custom queue class
384:08 - so if the Q length property is greater
384:10 - than zero let's write the properties of
384:12 - the items stored within the queue to the
384:14 - console screen
384:16 - let's create a private method named
384:18 - write values in queue to screen that
384:21 - contains a parameter of type custom
384:24 - queue
384:25 - which is strongly typed with the
384:27 - abstract class Hardware item
384:31 - let's write a for each Loop to Traverse
384:33 - the items in the queue and write each
384:35 - item's properties to the console screen
384:38 - so these items will be written to the
384:40 - screen in a tabular format so I've made
384:42 - sure that each column is set to a
384:45 - specific length
384:59 - let's call this method from the custom
385:01 - queue underscore custom queue event
385:03 - method I.E the event handler method
385:07 - so let's go to the main method create 10
385:10 - Hardware items and add them to the
385:12 - custom queue
385:14 - I'm actually going to change the name of
385:15 - the variable we are using to reference
385:17 - the custom queue object
385:19 - to a more specific name
385:22 - let's change the name of this variable
385:24 - from Custom queue to Hardware item queue
385:27 - so I've already uploaded the code for
385:30 - this example to GitHub
385:31 - in the interests of time let's copy the
385:34 - code that adds Hardware item objects to
385:36 - the relevant queue
385:38 - from the code I have already uploaded to
385:40 - a GitHub repository so let's navigate to
385:43 - this web page
385:45 - from within our browsers and copy the
385:48 - relevant code
385:49 - foreign
385:57 - and then appropriately paste this code
385:59 - into the main method
386:01 - so this code which adds Hardware items
386:04 - to the custom queue simulates items
386:07 - entering the warehouse
386:10 - to give this example a more real world
386:12 - feeling
386:13 - to simulate that these items are
386:15 - entering the warehouse at random times
386:18 - I'm using the
386:20 - system.threading.thread.sleep method to
386:22 - add a time delay between the lines of
386:24 - code that add items to the queue
386:30 - so for example here we are delaying the
386:33 - main thread for 2 000 milliseconds which
386:36 - equates to a two second delay
386:39 - let's go back to the custom queue
386:41 - underscore custom queue event method and
386:43 - add an else part to the Top If statement
386:45 - so if the queue does not contain any
386:48 - items we want to Output status
386:51 - information to the user let's output the
386:54 - following text to the user when the
386:56 - queue does not contain any items
386:58 - status all items have been processed
387:06 - so let's run the code
387:16 - and you can see that each time an item
387:19 - is added to the queue an event is raised
387:21 - and our calling client code writes the
387:23 - details of the item to the console
387:25 - screen great
387:27 - so let's create the code for when items
387:30 - in the queue are processed
387:32 - for the sake of keeping this example
387:34 - simple let's say that when the queue
387:36 - contains five items we want the items in
387:39 - the queue to be processed
387:41 - so let's define a constant as an integer
387:44 - and let's name this constant batch size
387:47 - let's set this constant to a value of 5.
387:52 - so we can now write a nested if
387:54 - statement in our custom queue underscore
387:56 - customqueue event method that checks if
388:00 - the queue has five items in it if the
388:03 - queue has five items in it we want code
388:05 - to execute that simulates the processing
388:08 - of each of the items in the queue
388:13 - so let's write a private method named
388:15 - process items it contains one parameter
388:18 - of type custom queue that is strongly
388:20 - typed with the hardware item
388:22 - user-defined abstract type
388:25 - let's write code to Simply Traverse the
388:27 - items in the queue through the use of a
388:29 - while loop the condition of the while
388:32 - loop is that iterations of the loop must
388:34 - continue while the queue is not empty
388:37 - so we want to de-queue each of the items
388:40 - in the queue meaning that the item has
388:42 - been processed remember that when the
388:45 - get item method is called the DQ method
388:48 - on the underlying queue data structure
388:50 - is called which means the item at the
388:54 - front of the queue is removed from the
388:55 - queue let's add a three second delay
388:58 - before each item is removed from the
388:59 - queue to simulate that the item is being
389:02 - processed
389:05 - let's go to the custom queue underscore
389:07 - custom queue event method and write code
389:10 - to call the process items method
389:19 - let's run the code
389:28 - now you can see that when the queue is
389:31 - populated with five items the items are
389:34 - processed and each item is removed from
389:36 - the queue once the relevant item has
389:38 - been processed
389:47 - when the queue is empty the next five
389:49 - items are added to the queue and once
389:52 - five items have entered the queue the
389:54 - items are processed one by one until the
389:57 - queue is empty
390:01 - great
390:02 - so to further clarify to the user the
390:05 - status of each item in the queue let's
390:08 - write the message property of the event
390:10 - args object to the console screen
390:12 - this message property contains a
390:14 - narrative describing the relevant item
390:16 - and the event pertaining to the item
390:21 - let's run the code
390:24 - excellent the supervisor can see
390:26 - relevant information about the item as
390:28 - well as the event
390:30 - the supervisor can see status output for
390:33 - each item as it enters the warehouse and
390:36 - is processed
391:11 - the final thing to do is enhance the
391:14 - formatting of the output
391:16 - in the interests of time let's copy and
391:18 - paste relevant formatting functionality
391:20 - from GitHub
391:22 - so let's navigate to this location in
391:24 - our browsers
391:25 - and please feel free to copy my actions
391:27 - here
391:29 - let's copy the code situated between the
391:31 - two comments that have the text headings
391:34 - let's then paste the code into our code
391:37 - editors
391:39 - we can then write the code to call these
391:41 - output formatting related Methods at
391:44 - appropriate points within the custom
391:46 - queue underscore customque event method
391:54 - foreign
392:02 - let's run the code
392:07 - foreign
392:52 - thanks
392:55 - so lastly I'm going to put a few break
392:57 - points in the code to clarify the
392:59 - execution path of the code
393:12 - so in the calling client code when the
393:14 - code adds an item to the custom queue
393:16 - you can see the event that resides in
393:18 - the custom queue class in the warehouse
393:21 - management system API component is
393:23 - raised and the code in the calling
393:25 - client handles the event through a
393:27 - method that was designated to handle the
393:29 - event when the calling client code
393:31 - subscribed to the relevant event
393:34 - when the predefined batch size of five
393:37 - has been reached I.E when the custom
393:39 - queue contains five items each item is
393:42 - processed once an item has been
393:45 - processed it is removed from the queue
393:47 - the event is raised to the client and
393:50 - the client method that has been
393:52 - designated to handle the event is
393:54 - executed
393:55 - when the calling client subscribed to
393:58 - the event in the custom queue class a
394:01 - method that resides in the calling
394:02 - client code was designated to handle the
394:04 - event when the event is raised the
394:07 - relevant event handler method is
394:09 - executed in this event handler method we
394:12 - are writing status information to the
394:13 - screen so that this information is
394:16 - available to for example a supervisor in
394:19 - real time
394:20 - I hope you've enjoyed this video which
394:22 - demonstrates the use of the c-sharp
394:24 - generic built-in Q data type a generic
394:27 - class with constraints and the use of a
394:29 - generic delegate used to define an event
394:33 - for more videos on advanced c-sharp
394:34 - concepts and much more please consider
394:36 - subscribing
394:38 - and please ring the bell so that you'll
394:40 - be notified of future content released
394:41 - from this channel
394:43 - if you feel you have gained value from
394:45 - viewing this video please hit the like
394:46 - button it'll be greatly appreciated
394:48 - please feel free to share any of the
394:51 - videos released from this Channel with
394:52 - anyone you feel May benefit from their
394:54 - content
394:55 - your comments are of course always
394:57 - welcome
394:58 - the code created in this tutorial can be
395:00 - downloaded from GitHub please see a link
395:02 - to the relevant repository Below in the
395:04 - description
395:09 - [Music]
395:18 - hi and welcome
395:21 - this video is the fourth and final part
395:23 - in a video series on c-sharp generics
395:26 - [Music]
395:27 - shop generics video series is the fifth
395:30 - part of a course on advanced c-sharp
395:32 - concepts
395:33 - in this video we are going to first look
395:35 - at how in terms of generics the msil
395:38 - code or Microsoft Intermediate Language
395:40 - code is handled by the common language
395:43 - runtime under the hood as it were
395:46 - if you stick around till the end I'll
395:48 - show you how a utility that ships with
395:50 - Visual Studio for Windows named
395:53 - Intermediate Language disassembler can
395:55 - be used to disassemble an assembly
395:57 - whereby the msil code can be extracted
396:01 - from the.net assembly and inspected
396:04 - we'll then look at a basic code example
396:06 - whereby the factory design pattern is
396:08 - implemented and generic supplied to our
396:11 - Factory class so that this class can be
396:13 - reused to instantiate multiple types
396:16 - we'll apply multiple constraints to our
396:18 - Factory class to enforce design rules
396:20 - driven by the requirement for our code
396:22 - example
396:24 - for more videos on advanced c-sharp
396:26 - concepts and much more please consider
396:28 - subscribing and please ring the bell so
396:30 - that you'll be notified of future
396:31 - releases from this channel
396:34 - so let's briefly look at how generics in
396:37 - the msil code or Microsoft Intermediate
396:39 - Language code is handled by the common
396:41 - language runtime
396:43 - I'm not going to go into a lot of detail
396:45 - in this regard but please check out this
396:47 - Microsoft document for a more detailed
396:49 - description regarding how generics is
396:52 - handled by the.net runtime
396:54 - this document explains how generics is
396:57 - handled differently for Value types and
396:59 - reference types by the.net runtime
397:02 - let's look at a few excerpts from this
397:04 - document
397:06 - specialized generic types are created
397:09 - one time for each unique value type that
397:12 - is used as a parameter
397:14 - this means conversions are no longer
397:16 - necessary because each specialized
397:18 - generic class natively contains the
397:21 - value type
397:22 - generics Works somewhat differently for
397:25 - reference types the first time a generic
397:28 - type is constructed with any reference
397:30 - type the runtime creates a specialized
397:33 - generic type with object references
397:36 - substituted for the parameters in the
397:38 - msil
397:40 - then every time that a constructed type
397:43 - is instantiated with a reference type as
397:46 - its parameter regardless of what type it
397:49 - is the runtime reuses the previously
397:52 - created specialized version of the
397:54 - generic type
397:55 - this is possible because all references
397:58 - are the same size
398:01 - because the number of reference types
398:03 - can vary wildly from program to program
398:05 - the c-sharp implementation of generics
398:08 - greatly reduces the amount of Code by
398:11 - reducing to one the number of
398:13 - specialized classes created by the
398:16 - compiler
398:17 - for generic classes of reference types
398:20 - so two benefits are highlighted in this
398:22 - document with regards to value types and
398:24 - reference types in terms of generics
398:28 - conversions are no longer necessary
398:30 - because each specialized generic class
398:32 - natively contains the value type
398:34 - generics greatly reduces the amount of
398:36 - Code by reducing to 1 the number of
398:39 - specialized classes created by the
398:42 - compiler for generic classes of
398:44 - reference types
398:46 - my goal here was only to draw your
398:48 - attention to the extra information
398:49 - regarding how the.net runtime implements
398:52 - generics and c-sharp under the hood as
398:54 - it were
398:56 - please read this document to gain a
398:57 - better understanding in this regard
399:00 - so let's Implement our code example
399:02 - where we'll implement the factory design
399:04 - pattern and use generics so that the
399:07 - object instantiation code is abstracted
399:09 - and can be used to instantiate multiple
399:12 - types
399:13 - we'll use multiple constraints
399:15 - appropriate to our requirement so that
399:18 - special rules at compile time are
399:20 - enforced
399:22 - let's create a.net core console app and
399:25 - let's name it digital product inventory
399:27 - application
399:29 - so in this very basic example we're
399:32 - going to create classes for representing
399:34 - specific types of digital products
399:37 - we'll also create classes for
399:38 - encapsulating data associated with the
399:42 - various categories of digital products
399:44 - we are going to create a factory class
399:46 - used to abstract and centralize the
399:49 - construction of these different types
399:51 - into objects
399:53 - we'll then copy code from a GitHub
399:55 - repository and this code will serve as
399:57 - the calling client code
399:59 - this client code includes a link query
400:02 - used to compile a report containing
400:05 - digital product information and their
400:07 - Associated digital product category
400:09 - information
400:10 - code is also included to Output the
400:13 - results of this link query to the
400:15 - console screen
400:16 - this example is more about understanding
400:18 - the application of generics than
400:20 - understanding link
400:22 - please don't worry if you don't fully
400:23 - understand the link aspect of this
400:25 - tutorial link will be discussed in
400:27 - detail in upcoming tutorials
400:30 - so let's create our Factory class
400:33 - this tutorial is not about design
400:35 - patterns but the factory design pattern
400:37 - is used in this example as a device to
400:40 - show how generics and constraints can be
400:42 - implemented to abstract the construction
400:43 - of objects of varying types special
400:47 - rules will also be applied through the
400:49 - use of constraints
400:51 - let's name this class Factory pattern
400:55 - so this class contains two generic types
400:57 - so let's include the constraints for the
401:00 - type T parameter
401:02 - and our definition of the factory
401:04 - pattern class
401:05 - as we know from our previous tutorials
401:08 - constraints enforce compile time rules
401:10 - on our type parameters
401:13 - so this constraint is enforcing a
401:15 - compile time rule that type T must be a
401:18 - reference type denoted by the class
401:20 - constraint must inherit from Type U I.E
401:23 - the other generic type parameter and the
401:26 - type T argument must also contain a
401:29 - public parameterless Constructor
401:32 - this is denoted by the new constraint
401:36 - note that when the new constraint is
401:38 - used with other constraints the new
401:40 - constraint must be specified last
401:43 - in our code we are going to instantiate
401:45 - an object of type t
401:47 - note that a generic type cannot be
401:49 - instantiated if the new constraint is
401:52 - not specified for the type that must be
401:54 - instantiated we'll prove this in a bit
401:57 - so let's also add a constraint to our
401:59 - u-type parameter
402:01 - we can do this by including another
402:03 - where keyword followed by the relevant
402:06 - constraint or constraints for the U data
402:08 - type note that this class constraint for
402:11 - this example is in fact redundant for
402:13 - the U parameter and I will remove this
402:16 - from the relevant GitHub repository I'm
402:18 - applying this constraint at this point
402:20 - in the tutorial to show how we are able
402:22 - to apply constraints to multiple type
402:25 - parameters
402:26 - thank you
402:27 - so let's add a method to our class and
402:29 - name it get instance
402:31 - so the code Logic for this method is
402:34 - instantiating an object of type T which
402:36 - is derived from Type U the instantiated
402:39 - object is then returned to the calling
402:41 - code
402:43 - so now just to show you that we cannot
402:45 - instantiate an object of type T unless
402:48 - the new constraint has been
402:49 - appropriately applied to the relevant
402:51 - class definition let's comment out the
402:54 - new constraint and you can see that the
402:56 - c-sharp compiler immediately complains
402:59 - we must ensure that we have
403:01 - appropriately applied the new constraint
403:03 - in order to be able to create an
403:05 - instance of type T so let's now create
403:08 - an interface named I primary properties
403:11 - let's add two property definitions to
403:14 - our interface ID as int and title as
403:18 - string so now let's go back to the
403:20 - factory pattern class let's add a
403:22 - constraint to enforce a rule that Type U
403:25 - must implement the I primary properties
403:27 - interface
403:29 - so we can do this by adding a constraint
403:32 - like this
403:33 - remember the class constraint can be
403:35 - removed from the U type parameter
403:38 - the code will still work as expected
403:40 - with it there but for this example it is
403:43 - redundant
403:45 - so let's add an abstract class name to
403:47 - product base that implements the I
403:50 - primary properties interface
403:52 - let's implement the properties defined
403:54 - in the I primary properties interface as
403:57 - Auto implemented properties
403:59 - let's create an abstract class named
404:01 - category base that also implements the I
404:04 - primary properties interface
404:14 - let's extend the product based class by
404:17 - adding an auto implemented property
404:19 - named category ID
404:23 - the category ID property will be
404:26 - included within our link query to join
404:28 - the data stored in a list containing
404:30 - objects of type category base to
404:32 - relevant product objects stored in a
404:35 - list containing objects of type product
404:37 - base we'll look at the link query in a
404:40 - bit
404:41 - let's extend the category-based abstract
404:44 - class and add an autoimplemented
404:46 - property named description
404:50 - so let's create our category classes
405:10 - let's create our digital product classes
405:14 - so our category classes inherit from the
405:17 - category-based abstract class and our
405:19 - product classes inherit from the product
405:21 - base abstract class
405:23 - note that both the product-based
405:25 - abstract class and the category base
405:27 - abstract class both implement the I
405:30 - primary properties interface
405:33 - notice I am extending these classes with
405:35 - additional properties just for
405:37 - demonstration purposes these additional
405:40 - properties won't be used further than
405:42 - this in this example
405:44 - so I'm going to create a class named
405:45 - product view model and this class will
405:48 - be used as a template to centralize
405:50 - information from the product related
405:52 - classes with information from their
405:54 - relevant category related classes
405:58 - so we want our calling code which we'll
406:01 - copy from GitHub to create several
406:03 - product objects and related category
406:05 - objects then using link we'll return a
406:08 - collection of objects of type product
406:10 - view model to the calling code this
406:12 - collection will be the result of a join
406:15 - operation joining objects of type
406:17 - product base with the relevant objects
406:19 - of type category base
406:25 - link is not the focus of this tutorial
406:27 - but I thought I'd include the link
406:28 - functionality to make our example more
406:31 - interesting
406:32 - as stated earlier we'll discuss Link in
406:35 - detail in upcoming tutorials so don't
406:37 - worry if you don't understand the link
406:39 - related code so I've already uploaded
406:41 - the code for this example to GitHub
406:43 - so let's copy the code which will serve
406:46 - as our calling client code from the
406:48 - relevant GitHub repository which can be
406:50 - found at this location this URL has also
406:53 - been included Below in the description
406:55 - let's copy all the code from within the
406:58 - program class like this
407:07 - and let's select the main method within
407:09 - our program class and our code editors
407:11 - and paste the code we have copied from
407:14 - GitHub over the main method in our code
407:16 - editors like this
407:21 - and you can see that we have red
407:23 - squiggly lines under our code relating
407:25 - to our generic lists
407:27 - so to fix this let's add a directive to
407:30 - the
407:31 - system.collections.generic namespace
407:34 - and in our get products method where we
407:36 - are executing a link query we have a red
407:39 - squiggly line here
407:41 - so to fix this we need to add a
407:42 - directive to the system.link namespace
407:49 - great
407:51 - so let's look at the calling client code
407:53 - we have just copied from GitHub the add
407:56 - properties to product method
407:57 - encapsulates functionality to add values
408:00 - to the properties of an object of type
408:02 - product base
408:05 - the add properties to category method
408:07 - encapsulates functionality to add values
408:10 - to the properties of an object of type
408:12 - category base
408:15 - you can see that these methods are
408:17 - currently public methods but they don't
408:19 - need to be public so we can change these
408:21 - methods to private
408:22 - I'll update the relevant GitHub
408:24 - repository with this change
408:26 - you can see here that our link query is
408:29 - encapsulated in a method named get
408:31 - products
408:32 - the link query is selecting all product
408:34 - related objects in the products list and
408:37 - joining each product with its relevant
408:39 - category
408:41 - each product is joined to its relevant
408:44 - category through the category ID
408:46 - property
408:49 - the result of the link query is a
408:51 - collection of objects of type product
408:53 - view model which appropriately combines
408:55 - product information with relevant
408:57 - category information
409:00 - as stated earlier link will be discussed
409:02 - in detail in upcoming tutorials
409:05 - so let's look at the code in the main
409:07 - method
409:08 - so notice how the factory pattern
409:10 - generic class is being used to
409:13 - instantiate each object of type product
409:15 - base
409:17 - for example we are instantiating an
409:19 - object here which represents a digital
409:21 - book entitled The Old Man and the Sea we
409:25 - are instantiating an object here
409:27 - representing a movie entitled Shawshank
409:29 - Redemption
409:30 - the factory patent generic class is then
409:33 - reused to instantiate several objects of
409:36 - type category base
409:39 - for example we are instantiating an
409:41 - object representing the category with
409:43 - the title of movie here and we are
409:45 - instantiating an object representing the
409:47 - product category here with the title of
409:50 - music
409:52 - so the factory pattern class has been
409:54 - implemented to abstract the object
409:57 - creation functionality for this code
409:59 - example
410:00 - we have adapted the factory design
410:02 - pattern to our requirements by imposing
410:05 - rules on the instantiation process
410:07 - through the use of constraints
410:10 - so in the main method we are
410:12 - instantiating our product related
410:13 - objects appropriately adding values to
410:16 - the relevant object's properties then
410:18 - adding the objects to a list of product
410:21 - related objects
410:23 - we are doing the same thing for our
410:25 - category related objects
410:28 - we are then appropriately amalgamating
410:30 - information from the product related
410:32 - objects with relevant information from
410:34 - the category related objects into an
410:37 - object of type product view model
410:39 - through the use of a link query
410:43 - we are then looping through the items
410:45 - returned from the link query and writing
410:48 - each item's properties to the console
410:50 - screen
410:51 - so let's run the code
410:59 - great
411:04 - I want to draw your attention back to
411:07 - the constraints in our Factory pattern
411:09 - class
411:10 - note that we have implemented a
411:12 - constraint that the U argument must
411:14 - implement the I primary properties
411:16 - interface so if for example we were to
411:19 - comment out the code in our class
411:20 - definition for the category-based
411:22 - abstract class that indicates that this
411:24 - class implements the I primary
411:26 - properties interface look at how the
411:29 - c-sharp compiler responds
411:31 - note how the constraint imposes a rule
411:34 - at compile time that the U argument must
411:37 - implement the I primary properties
411:39 - interface
411:41 - for more detailed information on
411:42 - constraints please navigate to this URL
411:47 - so we were discussing earlier how
411:49 - the.net runtime handles generics based
411:51 - on the msil code
411:54 - we are able to examine the msil code for
411:58 - an assembly by using a utility like for
412:00 - example the IL disassembler utility
412:05 - so now if we wanted to look at the msil
412:07 - code for this project we can use this
412:10 - utility this utility ships with the
412:13 - visual Studio for Windows IDE
412:16 - so let's run our developer command
412:18 - prompt for visual studio
412:27 - let's make the directory where our
412:30 - Target assembly file resides our current
412:32 - directory
412:58 - we can then type the following command
413:03 - this command generates a file containing
413:05 - the msil code within the directory of
413:08 - the relevant assembly this is the msil
413:11 - code that resides within the target
413:14 - assembly created when we built our
413:17 - c-sharp project
413:19 - so now we can open the file we have just
413:21 - created in a text editor like notepad
413:24 - and look at the relevant msil code
413:41 - great
413:42 - for more detail on the IL disassembler
413:44 - please navigate to this URL
413:48 - all urls mentioned in this tutorial can
413:52 - be found Below in the description
413:55 - lastly if you are interested in reading
413:57 - about generics and reflection please
413:59 - navigate to this URL
414:01 - if you are interested in reading about
414:02 - generics and attributes please navigate
414:05 - to this URL reflection can be used to
414:08 - inspect generic types in c-sharp at
414:10 - runtime and this will be discussed in
414:12 - later videos created on c-sharp
414:14 - reflection
414:16 - generics used with attributes will be
414:18 - covered in future videos created on
414:20 - c-sharp attributes
414:23 - in this video series we discussed that
414:25 - generics was introduced in c-sharp
414:27 - version 2. we looked at why it is better
414:30 - to use the strongly typed generic list
414:32 - to store a collection of items rather
414:34 - than an arraylist for this purpose
414:37 - we discuss the benefits of generics
414:40 - generic classes and methods combine
414:42 - reusability type safety and efficiency
414:45 - in a way that their non-generic
414:47 - counterparts cannot
414:49 - we looked at how constraints can be
414:51 - applied to generic type parameters in
414:53 - order to enforce compiled time rules on
414:55 - generic type parameters
414:57 - we created a code example representing a
415:00 - warehouse management system in this
415:02 - example we used the built-in c-sharp
415:04 - generic Q collection type to store
415:07 - objects representing various Hardware
415:09 - items that enter the warehouse and are
415:11 - subsequently processed
415:13 - generic delegates and events were
415:15 - instrumental in this real-time
415:17 - monitoring system
415:19 - lastly in this video we briefly looked
415:21 - at how the msil code or Microsoft
415:25 - Intermediate Language code is used by
415:27 - the.net runtime to efficiently handle
415:29 - both value types and reference types in
415:32 - terms of generics
415:34 - we also implemented a generic version of
415:36 - the factory design pattern and a basic
415:39 - code example to demonstrate how the use
415:41 - of multiple constraints can be applied
415:43 - to generic types in order to enforce
415:45 - special requirement-driven compile time
415:48 - rules
415:50 - I hope you have enjoyed this video
415:51 - series on c-sharp generics for more
415:54 - videos on advanced c-sharp concepts and
415:57 - much more please consider subscribing
415:59 - and please ring the bell so that you'll
416:01 - be notified of future content released
416:03 - from this channel
416:05 - if you feel you have gained value from
416:07 - viewing this video please hit the like
416:08 - button it will be greatly appreciated
416:11 - please feel free to share any of the
416:13 - videos released from this Channel with
416:15 - anyone you feel May benefit from their
416:17 - content
416:18 - your comments are of course welcome
416:20 - the code created in this tutorial can be
416:22 - downloaded from GitHub please see a link
416:24 - to the relevant repository Below in the
416:26 - description
416:31 - [Music]
416:46 - hi and welcome this is the sixth
416:49 - tutorial in an advanced c-sharp course
416:51 - and this is the first part of a video
416:53 - series on asynchronous programming using
416:55 - the c-sharp programming language in this
416:58 - video we'll look at an overview of
417:00 - asynchronous programming in c-sharp with
417:02 - a particular emphasis on Microsoft's
417:04 - recommended approach to using
417:06 - asynchronous programming for new
417:08 - development
417:09 - Microsoft's recommended approach to
417:11 - including asynchronous behavior in new
417:13 - applications is to use the task-based
417:16 - asynchronous pattern tab
417:18 - the two Legacy methods for providing
417:20 - asynchronous Behavior are event-based
417:22 - asynchronous pattern EAP
417:24 - and asynchronous programming model APM
417:28 - the event-based asynchronous pattern
417:30 - will not be discussed in this video
417:31 - series
417:33 - but if you wish to learn more about this
417:35 - Legacy pattern please navigate to this
417:36 - URL
417:38 - we have already covered the asynchronous
417:40 - programming model APM and the advanced
417:42 - course in part 3.5 of this course we
417:45 - looked at using a callback method and a
417:48 - built-in delegate to implement
417:49 - asynchronous Behavior
417:51 - please navigate to this URL to view a
417:53 - video released on this channel that
417:55 - covers the asynchronous programming
417:56 - model APM
417:58 - as always all links mentioned in this
418:00 - video can be found Below in the
418:02 - description
418:03 - later on in this tutorial we'll look
418:05 - closer at how using the task-based
418:07 - asynchronous pattern can result in
418:09 - asynchronous behavior for our
418:11 - applications and ultimately ensure that
418:14 - our users have a smooth user experience
418:15 - when using our applications
418:19 - for more videos on Advanced t-sharp
418:21 - topics and much more please consider
418:22 - subscribing and please ring the bell so
418:24 - that you'll be notified for future
418:26 - videos released from this channel
418:32 - right so tab or task-based asynchronous
418:35 - pattern is the recommended design
418:37 - pattern for creating asynchronous
418:39 - behavior for new development c-sharp
418:41 - version 5 produced a simplified approach
418:44 - to asynchronous programming that
418:45 - leverages asynchronous support in
418:47 - the.net framework 4.5 and higher.net
418:51 - core and the windows runtime
418:54 - dotnet framework 4.5 or higher and net
418:56 - core contain many members that work with
418:59 - async and await
419:01 - these members can be identified by their
419:03 - names which contain an async suffix
419:07 - so what gave rise to the task-based
419:10 - asynchronous pattern
419:12 - we live in an age where our applications
419:14 - should not only run on desktop computers
419:17 - and notebook computers our applications
419:19 - in a lot of cases will also need to run
419:21 - on smaller devices for example handheld
419:24 - devices like tablets and mobile phones
419:27 - these smaller devices may not have the
419:30 - powerful resources that desktop
419:31 - computers and notebook computers have to
419:33 - handle resource intensive operations
419:36 - so an operation like for example
419:38 - downloading a large document from a
419:40 - remote server May ultimately result in
419:43 - poor performance of our applications a
419:45 - poor ux or user experience with our
419:49 - applications can cause user frustration
419:51 - and cause our users to take a dim view
419:53 - of our applications
419:57 - thank you
420:01 - implementing this pattern in our code
420:03 - can result in a smoother ux user
420:06 - experience
420:08 - the code is easy to implement and even
420:11 - though the code results in asynchronous
420:13 - Behavior the code can be written in a
420:15 - synchronous way we'll look at a code
420:17 - example to further elucidate this point
420:19 - in a bit
420:20 - the c-sharp compiler makes it very
420:23 - difficult for a developer to implement
420:24 - the task-based asynchronous pattern
420:26 - incorrectly for example in an IDE like
420:29 - Visual Studio red squiggly lines will
420:31 - appear in appropriate regions of code if
420:34 - the relevant asynchronous code has been
420:36 - written incorrectly
420:38 - messages will also be made available to
420:40 - the developer from the c-sharp compiler
420:43 - in Visual Studio to guide the developer
420:45 - on how to fix the incorrect code
420:47 - so how can long-running operations
420:49 - result in a poor user experience with
420:52 - our applications
420:54 - say for example a button is clicked and
420:57 - within the event handler method of the
420:59 - relevant button click event a long
421:01 - running operation is invoked if this
421:03 - operation were to be invoked
421:05 - synchronously the threat of execution on
421:07 - which the relevant time-consuming
421:09 - operation is running is blocked until
421:12 - this long-running operation has
421:14 - completed
421:15 - while the relevant thread is blocked the
421:17 - application is unresponsive meaning the
421:19 - user cannot perform other operations
421:21 - with the application until the
421:23 - long-running operation completes
421:25 - so this ultimately results in poor user
421:28 - experience with our application
421:30 - there are two kinds of blocking
421:32 - operations CPU bound operations and I O
421:35 - bound operations so let's look at CPU
421:38 - bound operations
421:39 - this occurs when an intensive
421:41 - computation needs to be carried out by
421:43 - the device's CPU
421:45 - for example you might have a game
421:47 - running and a single action from the
421:49 - user may cause multiple characters in
421:51 - the game to incur damages
421:53 - the calculations of these damages may be
421:55 - CPU intensive an operation like this if
421:59 - done synchronously can result in the UI
422:01 - to freeze or stutter
422:04 - running the calculations in parallel
422:06 - across multiple cores can alleviate this
422:08 - and make the UI or user interface
422:10 - perform smoothly and responsively so the
422:14 - developer could use the task.run method
422:16 - to run calculations in parallel to
422:18 - alleviate the effects that handling
422:20 - these computations synchronously could
422:22 - have on the user's experience
422:25 - other examples of applications that may
422:27 - need to run intensive CPU bound
422:29 - operations could be Financial or
422:31 - scientific applications
422:34 - so let's look at i o bound operations i
422:37 - o bound operations are performed when
422:39 - requesting data from a network accessing
422:41 - a database or reading and writing to a
422:44 - file system
422:45 - the blocking effect during an i o bound
422:48 - operation causes the CPU to wait for the
422:50 - relevant i o bound operation to complete
422:53 - so the CPU will need to wait basically
422:56 - light dormant while for example
422:58 - information is retrieved from an Azure
423:00 - SQL database that resides in the cloud
423:03 - once the information is retrieved and
423:06 - for example appears in local memory the
423:08 - information can then be processed by the
423:09 - CPU the CPU can only then continue
423:12 - processing other instructions while the
423:15 - i o bound operation is running the CPU
423:17 - is blocked from running any other
423:19 - operations performance will not be
423:21 - optimal for our applications when the
423:23 - code for these relatively long running
423:25 - operations are handled synchronously
423:29 - i o bound operations are the most common
423:31 - encountered blocking operations so we
423:34 - are going to focus on resolving the
423:35 - blocking effect of i o bound operations
423:37 - through the implementation of the
423:39 - task-based asynchronous pattern in this
423:42 - video
423:43 - note that generally speaking io-bound
423:45 - operations are far slower than CPU bound
423:48 - operations in business applications i o
423:51 - bound operations will be far more common
423:53 - operations that will be encountered and
423:56 - should be handled asynchronously and let
423:58 - me emphasize i o bound processing is far
424:01 - slower than CPU processing
424:04 - so let's look at a basic code example we
424:07 - won't implement this particular code in
424:09 - Visual Studio
424:10 - this code serves to give us a general
424:12 - idea of what the task-based asynchronous
424:15 - pattern looks like in c-sharp code and
424:17 - we'll also get an idea of how it works
424:18 - let's first look at the synchronous
424:20 - version of this code example we'll then
424:23 - modify the code so that it is
424:24 - implemented using the task-based
424:26 - asynchronous pattern so in this
424:28 - synchronous version of the code example
424:29 - we have a higher level button click
424:32 - event handler named button underscore
424:34 - click
424:35 - when the user clicks the button that
424:37 - invokes code within this event handler
424:39 - method a call to a method named get
424:41 - document content is made this method
424:44 - accepts an argument which is the name of
424:46 - the remote file that our code needs to
424:49 - retrieve and process so let's say that
424:51 - the path of the remote document is
424:52 - handled under the hood as it were
424:55 - a relatively long running operation is
424:57 - encapsulated within a method named get
425:00 - document content as string which is
425:02 - invoked within the get document content
425:04 - method the long-running operation in
425:07 - this case is downloading a document from
425:09 - a remote server after the long-running
425:11 - operation completes a string is returned
425:13 - from the get document content as string
425:16 - method containing the relevant document
425:19 - content
425:20 - a method named save document locally is
425:23 - then called
425:24 - which as the name suggests saves the
425:26 - content returned from the get document
425:28 - content as string method to a local file
425:31 - store as a new file
425:33 - the document content is then returned to
425:35 - the calling code from the get document
425:37 - content method
425:39 - once the get document content method
425:41 - completes and Returns the content to the
425:43 - button-click event handler method the
425:45 - content is subsequently displayed to the
425:47 - user this is denoted by a call to a
425:50 - method named display content
425:52 - so while the code is performing the
425:55 - relatively long-running operation
425:57 - executed by the get document content as
425:59 - string method the thread of execution on
426:02 - which this operation is running will be
426:04 - blocked leaving the CPU idle until the
426:07 - get document content as string method
426:09 - completes and returns a value
426:11 - so let's say that we are in luck and
426:14 - there is an asynchronous version of the
426:16 - get document content as string method
426:18 - available to us named get document
426:20 - content as string async
426:23 - note that this version of the method has
426:25 - the same name as the synchronous version
426:27 - with the exception of the async suffix
426:29 - added to the end of the method's name
426:32 - adding the async suffix to the end of an
426:35 - asynchronous method's name is a naming
426:37 - convention used for asynchronous methods
426:40 - that are part of the implementation of
426:42 - the task-based asynchronous pattern
426:48 - so the method we want to call is named
426:50 - get document content as string async
426:53 - so we need to use the await operator
426:55 - preceding the method called to the get
426:58 - document content as string async method
427:00 - like this
427:02 - this is telling the c-sharp compiler
427:04 - that we wish to call this method
427:05 - asynchronously
427:07 - if any of our method calls within the
427:09 - get document content method are
427:11 - awaitable
427:12 - as is now the case here
427:14 - where we are using the await operator we
427:18 - need to include the async modifier in
427:20 - the method signature of the method where
427:22 - one or more asynchronous method calls
427:24 - are invoked which as stated is denoted
427:28 - by the await operator preceding the
427:30 - relevant asynchronous method being
427:32 - called
427:34 - so let's include the async modifier in
427:37 - the method signature for the get
427:38 - document content method
427:40 - let's also adhere to the correct naming
427:43 - convention so let's rename the get
427:45 - document content method to get document
427:47 - content async like this
427:49 - the get document content async method
427:52 - will return a string value once the
427:54 - async method has completed but when it
427:56 - is first called and hasn't necessarily
427:58 - completed a generic task object will be
428:01 - returned
428:02 - I'll elaborate on what the task object
428:05 - and the generic task object is in a bit
428:08 - so we must include the relevant generic
428:11 - task type in the method signature of the
428:13 - get document content async method like
428:16 - this
428:17 - we are calling an asynchronous method
428:19 - from the button click event handler
428:20 - named button underscore click so we need
428:23 - to include the await operator preceding
428:26 - a call to the get document content async
428:29 - method like this
428:30 - we are now calling an awaitable method
428:32 - within the button underscore click event
428:34 - handler method so we need to include the
428:37 - async modifier within the method
428:39 - signature of the button underscore click
428:42 - event handler method like this
428:45 - we don't need to include a task type in
428:48 - the button underscore click event
428:49 - handler method signature because it is a
428:52 - high level event handler
428:54 - all asynchronous methods that are not
428:56 - high level event handlers like the
428:58 - button underscore click event handler
428:59 - will return a task object if the
429:02 - relevant method does not return a value
429:04 - or a generic task object if the relevant
429:07 - method does return a value as is the
429:09 - case with our get document content async
429:12 - method which returns a string so for
429:15 - example the get document content async
429:17 - method returns a string value once it
429:19 - has completed so to reflect that this
429:22 - method is an async method that returns a
429:24 - string value we include the generic task
429:26 - type in its method signature and this
429:29 - generic task type accepts the string
429:32 - data type as its argument
429:34 - so basically the new asynchronous
429:36 - implementation of this example code
429:38 - means that when asynchronous methods are
429:41 - called with the await operator the
429:43 - control is immediately returned to the
429:46 - calling code meaning that the thread of
429:48 - execution on which it is executed is
429:51 - free to process other operations while
429:54 - the asynchronous method is running
429:57 - so the CPU is not left idle while an i o
430:00 - bound operation is underway as is the
430:03 - case in this example where a file is
430:06 - retrieved from a remote server
430:09 - in this asynchronous implementation the
430:11 - CPU thread of execution on which the
430:13 - relevant relatively long running
430:15 - operation was invoked can be used to
430:18 - perform other operations while the
430:20 - remote file is being retrieved from the
430:22 - remote server
430:24 - in this case the UI thread is the thread
430:26 - of execution so if for example the user
430:29 - needed to execute a different button
430:31 - click event
430:33 - another operation could run concurrently
430:35 - to the long-running operation and vote
430:37 - by the get document content as string
430:40 - async method
430:41 - this means the user's experience with
430:44 - the application will not be negatively
430:46 - impacted by this relatively long-running
430:48 - operation
430:49 - the user experience is not adversely
430:51 - affected by the relatively long-running
430:53 - operation performed by the get document
430:56 - content as string async method
430:59 - so when the get document content has
431:01 - string async method is called a generic
431:04 - task object is returned immediately to
431:06 - the calling code
431:07 - the string value that is returned only
431:10 - once the get document content has string
431:12 - async method completes is returned at
431:15 - that point of execution in the code but
431:17 - at a later time
431:19 - while the relatively long operation
431:21 - invoked by the get document content as
431:23 - string async method is running other
431:25 - operations can be performed by the user
431:27 - without negatively impacting the user's
431:30 - experience with the relevant application
431:33 - basically the task object is a state
431:35 - machine if you'd like a comprehensive
431:38 - explanation of what a state machine is
431:40 - please navigate to this URL
431:43 - the task object encapsulates information
431:45 - about the asynchronous process
431:48 - and either delivers the final result
431:50 - back once the asynchronous method
431:53 - completes or throws an exception if an
431:55 - exception occurs within the asynchronous
431:57 - method so we can put traditional try
431:59 - catch code around the call to our
432:01 - asynchronous methods as if the methods
432:04 - were synchronous to handle exceptions
432:06 - that may occur in our asynchronous
432:08 - methods
432:10 - so when the awaitable method is executed
432:12 - a task object is immediately returned to
432:15 - the calling code the string value is
432:17 - only returned later once the awaitable
432:19 - method completes
432:20 - when the task object is returned the
432:23 - relevant thread of execution is then
432:25 - immediately released to the caller the
432:27 - thread of execution is not blocked while
432:30 - the asynchronous operation is running
432:32 - so the async method first Returns the
432:35 - task object in this case a generic task
432:38 - object that promises to return a string
432:41 - value at this point in the code once the
432:43 - operation performed within the relevant
432:45 - async method has completed
432:47 - this model is known as the promise model
432:50 - of asynchrony
432:52 - if you wish to read more about the
432:54 - promise model of asynchrony please
432:57 - navigate to this URL on the c-sharp side
433:00 - of things the c-sharp compiler
433:02 - transforms your code into a state
433:04 - machine that keeps track of things like
433:06 - yielding execution when an await is
433:09 - reached and resuming execution when a
433:12 - background job has finished
433:16 - the async modifier is doing two things
433:20 - number one it is a message to the
433:22 - c-sharp compiler that this method can
433:25 - use the await operator inside it the
433:28 - await operator designates the suspension
433:30 - points in the execution
433:33 - number two the method itself can be
433:35 - awaited by methods that are calling it
433:38 - the async modifier also is a message to
433:42 - the c-sharp compiler that the method can
433:44 - be called asynchronously using the await
433:47 - operator
433:48 - the await operator is telling the
433:51 - compiler that the execution of code
433:53 - cannot continue past this point until
433:55 - the awaited method has completed
433:59 - so in the meantime control returns to
434:01 - the caller of the method which is the UI
434:04 - thread in this case which allows for
434:06 - example the user to click other buttons
434:09 - while the incomplete asynchronous task
434:12 - is still running
434:14 - under the hood as it were when you
434:17 - compile your code through Visual Studio
434:19 - the c-sharp compiler rewrites your code
434:22 - into Intermediate Language splitting
434:24 - apart your async method calls into lots
434:27 - of callback methods
434:29 - so we as coders don't need to worry
434:32 - about the complexity of implementing
434:35 - callback methods ourselves
434:37 - with this explanation I'm admittedly in
434:39 - the interests of brevity glossing over a
434:42 - mass of complexity involved in making
434:44 - this asynchronous abstraction model work
434:48 - for more detail and a comprehensive
434:50 - diagram of how the underlying framework
434:52 - is handling the asynchronous code please
434:55 - navigate to this URL
434:58 - note that the line of code that includes
435:01 - the await operator is in fact doing two
435:04 - things
435:05 - it is returning a task object when it is
435:07 - first invoked and then later when the
435:10 - asynchronous operation completes it is
435:12 - returning the value returned by the
435:15 - relevant method in this case a string
435:17 - value
435:19 - so we can write the code like this to
435:21 - make this clearer we could first assign
435:23 - the task object returned by the relevant
435:25 - asynchronous method to a variable of
435:27 - type task this is done without the await
435:31 - operator
435:32 - we can then call the relevant task
435:33 - object with the await operator later in
435:36 - the code in this case the string value
435:38 - will be returned from the task object
435:41 - when the relevant operation completes
435:44 - in this particular example we can write
435:47 - what is achieved by two lines of code
435:48 - here in one line of code like this
435:52 - so let's put the code back to how we
435:54 - originally had it
435:57 - so let's create a code example
436:00 - we are going to create two.net projects
436:02 - one project will represent the calling
436:04 - client code I.E the code that will
436:06 - contain the user interface the other
436:08 - project will represent the server-side
436:11 - code
436:12 - the calling client will be implemented
436:14 - as a uwp project or universal windows
436:17 - platform project
436:18 - the server-side code will be implemented
436:21 - as a web API project
436:23 - this example is very basic we'll
436:25 - Implement a button click event handler
436:27 - on the user interface which will be
436:29 - included within the uwp project
436:32 - code within the relevant button click
436:34 - event handler will asynchronously call a
436:36 - method included within the web API
436:39 - server side component
436:41 - in the relevant web API action method
436:43 - we'll deliberately Implement a delay to
436:45 - represent a task that is relatively time
436:47 - consuming and should be awaited by our
436:50 - client code IE should be called
436:53 - asynchronously
436:55 - we'll Implement another button-click
436:57 - operation on the uwp projects user
436:59 - interface which will Implement code that
437:01 - runs a much faster local operation
437:05 - we'll run the code and demonstrate that
437:08 - when clicking the button that kicks off
437:09 - the time consuming operation implemented
437:11 - in the web API code that this does not
437:14 - impede the user's experience and the
437:16 - user is able to click the second button
437:18 - which carries out a much faster local
437:20 - operation
437:22 - perhaps the user can click this several
437:24 - times while the application is awaiting
437:26 - for the more time consuming operation
437:28 - carried out on the server side to
437:30 - complete and return a value to the
437:32 - calling client code
437:33 - will prove that the fast local
437:35 - operations can run concurrently while
437:37 - longer asynchronous operations are
437:39 - running in the background
437:41 - and because we have written the long
437:43 - running operation to run asynchronously
437:45 - that the user's experience is not
437:47 - adversely affected by running the
437:48 - relatively long operation
437:50 - so let's create a web API project
438:14 - and let's name this project test time
438:16 - consuming operation web API
438:33 - note that when the web API project is
438:36 - created a controller class is
438:38 - automatically included in the web API
438:40 - project
438:41 - this automatically included class is
438:43 - named weather forecast controller code
438:46 - within this controller simply outputs
438:49 - made up data representing a weather
438:51 - forecast we'll come back to this web API
438:53 - project in a bit and create our own
438:56 - controller class
439:00 - let's create a uwp project
439:10 - and let's name this project test client
439:13 - async uwp
439:41 - okay so let's go back to the web API
439:43 - project and let's create a web API
439:45 - controller class
439:49 - foreign
440:04 - and let's name this controller test long
440:07 - operation controller
440:10 - so the code in this method is faking a
440:12 - relatively long running operation that
440:15 - needs to be performed before returning a
440:17 - value to the client code
440:19 - the call to the server-side component's
440:21 - relevant action method will be handled
440:23 - through an HTTP get request from our uwp
440:26 - project
440:27 - we'll write the code for this in a bit
440:34 - please note that this tutorial is not
440:36 - about uwp or web API so I'm not going to
440:39 - go into detail explaining these two
440:41 - types of projects the focus is on
440:43 - writing code using the task-based
440:46 - asynchronous pattern in c-sharp to
440:48 - ensure that the user's experience is not
440:50 - adversely affected by long-running
440:52 - operations perhaps being run remotely
440:55 - through a web API call
440:57 - so note that we are not only going to
441:00 - use the task-based asynchronous pattern
441:02 - on the client side we are also using the
441:04 - task-based asynchronous pattern for this
441:07 - action method in the server-side code
441:09 - we have discussed how client-side UI
441:11 - synchronous code can negatively affect
441:13 - the user's experience and that
441:15 - implementing the task-based asynchronous
441:17 - pattern on the client side can make the
441:19 - user's experience much smoother
441:22 - the task-based asynchronous pattern can
441:24 - also be implemented for server-side
441:26 - components like for example a web API
441:28 - component or an asp.net MVC component
441:33 - this creates better performance on the
441:35 - server side which ultimately can affect
441:37 - client-side UI responsiveness
441:39 - on the server side it means for example
441:41 - that the thread of execution on which a
441:44 - relatively time-consuming method runs
441:46 - will not be blocked while the relevant
441:49 - time-consuming operation is performed
441:51 - and the relevant thread can handle other
441:53 - requests while the relatively time
441:55 - consuming operation is running
441:57 - in terms of the user's experience if a
442:00 - time-consuming operation blocks the
442:01 - threat of execution because of
442:03 - synchronous code this could tie up
442:06 - server-side resources causing a delay in
442:08 - performance on the server side and at
442:11 - worst could cause for example a client's
442:13 - HTTP request to time out
442:17 - so server-side synchronous code can also
442:20 - adversely affect the user's experience
442:24 - so in order to fake the long-running
442:26 - operation I'm simply going to create an
442:28 - await statement and use the task classes
442:31 - delay method to pause the method
442:34 - at this point for 5 000 milliseconds in
442:38 - other words it will cause a delay of 5
442:40 - Seconds
442:41 - once the five second delay representing
442:43 - our long operation is finished the code
442:46 - returns a string value so let's return
442:48 - the text web API long running operation
442:51 - completed to the calling client code
442:56 - so let's test the code
443:02 - and you can see that the output from the
443:04 - weather forecast controller code is
443:07 - written to the browser window
443:09 - let's change the URI in our browsers to
443:12 - point to the controller code that we
443:14 - have just created so let's make a get
443:16 - request to our test long operation
443:18 - controller
443:22 - great there is a clear delay of 5
443:24 - Seconds before the expected string
443:26 - results is written to our browser
443:28 - windows
443:29 - okay let's write the calling client code
443:32 - in our uwp project
443:36 - so we are going to drag two buttons onto
443:38 - the design surface from our list of xaml
443:40 - controls
443:42 - let's drag our first button onto the
443:45 - design surface
443:46 - foreign
443:53 - a bit
443:59 - let's name this button BTN local
444:02 - operation
444:03 - let's label this button local operation
444:06 - so let's zoom in a bit so we can have a
444:08 - clearer view of our button
444:21 - let's drag our second button onto the
444:25 - design surface
444:27 - so let's enlarge this button a bit
444:34 - let's name this button BTN web API call
444:37 - let's label this button web API call
444:52 - so let's drag a list view component onto
444:54 - our design surface
444:56 - you can see the list view is currently
444:58 - the same size as our design surface and
445:00 - is covering the whole design surface
445:04 - let's resize it so its contents will
445:06 - appear to the right of our buttons
445:12 - let's name our list view component lvw
445:15 - output
445:17 - you may have noticed that creating a
445:19 - beautiful design for our UI here is not
445:21 - a concern for this video
445:23 - but in the interests of Saving Time this
445:25 - design will be adequate for what we are
445:27 - demonstrating here
445:29 - it might be a good time to make the
445:31 - point that ux is not just about
445:33 - Aesthetics which of course is very
445:35 - important but it is also about
445:37 - performance
445:38 - we are focusing on how we can write
445:40 - asynchronous code to drastically improve
445:43 - the user's experience so let's go to the
445:46 - code behind our design surface and let's
445:48 - write a private method named add list
445:51 - item
445:53 - and here we are writing a piece of
445:54 - reusable code for adding a string value
445:57 - to our list view component
445:59 - within each of our two button click
446:01 - event handlers we want to add relevant
446:03 - string results to our list view
446:06 - component we'll write the code for the
446:08 - two button click event handlers in a bit
446:28 - let's create two integer member
446:30 - variables one named underscore local
446:32 - operation counter and the other named
446:34 - underscore web API operation counter
446:41 - let's write the code that executes when
446:44 - the button that performs the fast local
446:46 - operation is executed
446:48 - so we can Auto generate the method
446:50 - signature for the relevant button-click
446:52 - event handler method by double clicking
446:54 - on the relevant button on our design
446:57 - surface like this
446:59 - so when this button is clicked we want
447:01 - to increment the underscore local
447:03 - operation counter integer member
447:04 - variable by a value of 1. and append
447:07 - this integer value to the literal text
447:10 - fast local operation completed
447:13 - we are adding this string value to the
447:16 - list view component that we named lvw
447:18 - output through a call to a private
447:21 - method named add list item
447:24 - so let's implement the code to call the
447:26 - web API method that implements the long
447:28 - running operation and we want this code
447:31 - to fire when we click the button we have
447:33 - named BTN web API call
447:36 - so let's double click the relevant
447:38 - button on our design surface to Auto
447:40 - generate the relevant button click event
447:42 - handler method like this
447:45 - so the code share is a little bit more
447:46 - involved than the code that runs when
447:49 - the user clicks the button we have named
447:50 - BTN local operation
447:52 - let's first write the code to increment
447:54 - the underscore web API counter integer
447:56 - member variable by a value of 1. so we
448:00 - are going to use the HTTP client
448:01 - built-in class to make a HTTP get
448:04 - request to the relevant web API action
448:07 - method
448:08 - so let's instantiate a HTTP client
448:11 - object like this
448:13 - the HTTP class is a member of the
448:17 - system.net.http namespace
448:19 - so let's ensure we include the relevant
448:21 - directive
448:40 - let's use a HTTP response message object
448:44 - to encapsulate The Returned value
448:48 - returned from our web API components
448:50 - relevant action method
448:53 - so we need to run this line of code
448:54 - asynchronously which means we need to
448:57 - include the await operator before
448:59 - calling the get async method note the
449:02 - get async method has the async suffix so
449:06 - we know that this is an asynchronous
449:08 - method note the red squiggly line here
449:12 - because in order to run this code
449:13 - asynchronously we need to include the
449:16 - async modifier within our BTN web API
449:19 - call underscore click event handler
449:21 - methods method signature
449:24 - note that we don't need to return a task
449:27 - object from this button-click event
449:28 - handler method because this method is a
449:31 - high level event handler
449:33 - so we need to pass the URI of our web
449:36 - API action method to the get async
449:39 - method
449:39 - so that the relevant action method is
449:41 - invoked on the server when the user
449:44 - clicks the button named
449:46 - BTN web API call
449:48 - so let's run our web API component by
449:50 - running the relevant web API project
449:53 - so a get request is made to the weather
449:56 - forecast controller by default remember
449:58 - this code was Auto generated when we
450:00 - created our web API project
450:02 - let's change the URI within our browsers
450:05 - so that a get request is made to the get
450:09 - action method within our test long
450:11 - operation controller class let's refresh
450:14 - our browsers
450:15 - and note a five second delay before the
450:17 - expected result is written to the
450:19 - browser window
450:22 - so let's copy the URI that our browser
450:24 - is currently pointing to let's go to our
450:26 - uwp project and let's paste the URI here
450:29 - as a string argument to the HTTP
450:33 - client.getasync awaitable method
450:36 - let's call an awaitable method named
450:38 - read as string async to retrieve a
450:41 - Content returned from our call to the
450:43 - web API component
450:45 - then let's write code to add The
450:47 - Returned string to the list view
450:49 - component that we named lvw output
450:53 - we can do this through a call to our
450:55 - private method named add list item
451:00 - so let's move the code that increments
451:02 - the underscore web API counter variable
451:04 - to just above where we have added our
451:07 - string results to the list view
451:09 - component
451:10 - so we need to ensure that our web API
451:12 - project is first running before we run
451:14 - our uwp client code so let's do that
451:18 - let's run the uwp project so we can test
451:21 - the performance of our user interface
451:29 - let's first test that we are able to get
451:31 - a result back from our web API component
451:34 - so let's click the button labeled web
451:36 - API call
451:43 - great the result appears on the list
451:45 - view as expected
451:47 - the result is added to the list View and
451:49 - we can see it as output on the client
451:51 - side displayed within the list view
451:53 - component
451:54 - notice that there was a delay before the
451:57 - result appeared in the list view because
451:58 - we want this call to emulate awaiting a
452:01 - long-running operation now let's test
452:04 - that when we execute this long-running
452:06 - operation that the UI thread is not
452:08 - blocked the UI thread should not be
452:10 - blocked because we are making our get
452:12 - request to the web API component
452:14 - asynchronously
452:16 - so let's once again click the button to
452:18 - make our web API request
452:20 - and now let's click the other button
452:22 - several times to run our fast local
452:24 - operation several times
452:27 - great and you can see that the local
452:28 - task is running even while awaiting the
452:31 - result from our remote long running
452:33 - server-side operation
452:34 - the UI thread is not being blocked and
452:37 - our asynchronous code is working as
452:39 - expected
452:40 - you can see that when the asynchronous
452:42 - operation completes the appropriate
452:44 - result is added to the list view
452:46 - component
452:47 - and while we were waiting for the
452:49 - relatively long-running asynchronous
452:51 - operation to complete we were able to
452:53 - run several local fast operations so the
452:56 - fast local operations are running
452:58 - concurrently with the long-running
453:00 - asynchronous operation
453:02 - so let's make several requests to our
453:05 - web API component and let's also run our
453:07 - fast local operation concurrently
453:09 - several times
453:11 - great and you can see by the output
453:14 - appearing in our list view component
453:15 - that the user's experience is smooth the
453:18 - user's experience is not adversely
453:20 - affected when the long-running web API
453:22 - operation is executed the user is able
453:25 - to perform other operations using our
453:28 - application without the user's
453:29 - experience being impeded by other
453:31 - incomplete long-running operations this
453:34 - is why the task-based asynchronous
453:36 - pattern is so powerful
453:38 - this in my opinion is one of the reasons
453:40 - why the c-sharp language is so powerful
453:42 - because a lot of the complexity in
453:44 - making a long-running operation run
453:46 - asynchronously is hidden from the
453:48 - developer this complexity is abstracted
453:51 - the c-sharp language makes the inclusion
453:53 - of asynchronous behavior in our
453:55 - applications easy to implement
453:58 - please download the code for yourself
454:00 - and play around with the code so you can
454:02 - experience how the relevant asynchronous
454:04 - code results in a far smoother user
454:06 - experience than if the same code were
454:09 - implemented synchronously the links to
454:11 - the relevant GitHub repositories have
454:13 - been included Below in the description
454:16 - I hope you have enjoyed this video on
454:19 - using the task-based asynchronous
454:21 - pattern in our code to include
454:22 - asynchronous behavior in our
454:24 - applications
454:26 - in my opinion this is one of the most
454:27 - important Concepts in c-sharp
454:29 - programming in an age where smaller
454:31 - devices are used to perform relatively
454:34 - long-running operations we need to
454:36 - ensure that our users experience with
454:38 - our applications are not adversely
454:40 - affected by poor performance of our
454:42 - applications caused by synchronous code
454:44 - implementations of relatively
454:46 - long-running operations we can
454:48 - drastically improve the performance of
454:50 - our applications by running these
454:52 - relatively long-running operations
454:53 - asynchronously
454:55 - this is now easy to achieve using the
454:58 - c-sharp programming language
455:00 - please consider subscribing for more
455:02 - content on advanced c-sharp concepts and
455:04 - much more and please ring the bell so
455:06 - that you'll be notified of future
455:07 - content released from this channel
455:10 - if you feel you've gained value from
455:12 - viewing this video please hit the like
455:13 - button it will be greatly appreciated
455:15 - please feel free to share any of the
455:18 - videos released on this channel with
455:19 - anyone you feel May benefit from their
455:21 - content
455:22 - I of course love reading your comments
455:24 - so please feel free to share your
455:26 - thoughts with me in the comments section
455:28 - as always the code examples that were
455:30 - created in this video can be downloaded
455:32 - from GitHub a link to the relevant
455:34 - GitHub repositories can be found Below
455:37 - in the description
455:38 - thank you and take care
455:43 - [Music]
455:52 - [Music]
455:55 - hi and welcome to the second part of a
455:58 - tutorial on asynchronous programming
456:00 - using the c-sharp programming language
456:02 - this video is also the second part of
456:05 - the sixth tutorial in an advanced
456:08 - c-sharp course
456:10 - in the first part of this video series
456:12 - on asynchronous programming using
456:15 - c-sharp we specifically focused on the
456:17 - async modifier the await operator and
456:20 - the task object
456:21 - [Music]
456:23 - we discussed that there are essentially
456:25 - two CPU blocking operations that we may
456:28 - encounter When developing our
456:30 - applications namely i o bound operations
456:32 - and CPU bound operations these CPU
456:36 - blocking operations can result in poor
456:38 - performance of our applications and
456:40 - ultimately result in a poor user
456:42 - experience ux with our applications
456:46 - [Music]
456:48 - with the increased use of smaller
456:51 - devices that may not have the
456:52 - capabilities of say for example a
456:54 - notebook or desktop computer to handle
456:57 - resource intensive operations it is
456:59 - essential that we apply coding
457:00 - methodologies in our applications to
457:03 - ensure that the users are not negatively
457:05 - impacted by potentially resource
457:07 - intensive CPU bound or i o bound
457:10 - long-running operations
457:12 - the way c-sharp developers can solve
457:14 - these ux issues is through the
457:17 - implementation of asynchronous code
457:20 - the c-sharp programming language makes
457:22 - available several methodologies that can
457:25 - be implemented in our code to achieve
457:27 - asynchronous Behavior namely
457:29 - asynchronous programming model APM this
457:32 - was covered in part 3.5 of this Advanced
457:34 - c-sharp course event-based asynchronous
457:37 - pattern EAP and the task-based
457:40 - asynchronous pattern tab Microsoft's
457:43 - recommended approach to implementing
457:45 - asynchronous behavior in our c-sharp
457:47 - code is to use the task-based
457:49 - asynchronous pattern
457:52 - I recommend that you watch the first
457:54 - part of this video series before
457:56 - watching this video
457:58 - for more videos on advanced c-sharp
458:00 - concepts and much more please consider
458:01 - subscribing and please ring the bell so
458:04 - that you'll be notified of future
458:05 - content released from this channel
458:08 - so in the first part of this video
458:09 - series on asynchronous programming in
458:11 - c-sharp we focused on how to apply the
458:14 - task-based asynchronous pattern to
458:16 - handle the negative ux effects that can
458:19 - be caused by long-running i o bound
458:21 - operations in this video we'll focus on
458:25 - how to apply the task-based asynchronous
458:27 - pattern to handle the negative impact on
458:29 - the user's ux that can be caused by
458:32 - long-running CPU bound operations
458:35 - so let's start by briefly going over
458:37 - what is meant by i o bound operations
458:39 - and CPU bound operations
458:42 - io-bound tasks are delegated to the i o
458:45 - subsystem and while the relevant i o
458:47 - bound operation is handled the CPU
458:50 - thread on which the i o bound operation
458:52 - was invoked is blocked from running any
458:54 - other operations so while the relevant i
458:57 - o bound operation is running the CPU is
459:00 - idle
459:01 - all other operations are blocked from
459:03 - being processed by the CPU this can mean
459:06 - that if the relevant operation runs for
459:08 - a relatively long period of time that a
459:11 - delay in the user's interface or
459:12 - responsiveness can be noticed by the
459:14 - user
459:15 - this means the user's experience is
459:17 - negatively impacted by the relevant
459:19 - relatively long-running i o bound
459:21 - operation
459:23 - so the characteristic of non-cpu-bound
459:26 - processes is that they don't occupy the
459:28 - CPU when they are performing other
459:30 - operations like I O bound operations
459:33 - i o bound operations include tasks such
459:37 - as writing to your hard disk drive
459:39 - waiting for a response from the network
459:41 - or querying a database
459:44 - these operations cannot be sped up by
459:46 - fast local processing as performance is
459:49 - constrained by the i o subsystems
459:51 - hardware and performance
459:53 - the hardware drive's write speed will
459:55 - dictate how long something takes to be
459:57 - written the third-party server response
460:00 - time will determine how quickly you can
460:02 - process a request CPU bound means the
460:05 - limiting factor in a particular task or
460:08 - algorithm is doing calculations the only
460:12 - way to speed up the relevant CPU bound
460:14 - operation is increased CPU power
460:18 - adding more memory a faster i o for
460:21 - example will not help
460:26 - examples of CPU bound tasks are video
460:29 - audio content conversion compression
460:31 - algorithms
460:33 - search algorithms Graphics processing
460:35 - rendering games or videos heavy
460:38 - mathematical computations like
460:40 - calculating factorials matrix
460:42 - multiplication finding prime numbers
460:45 - Etc encryption decryption operations
460:49 - so basically tasks that require the CPU
460:52 - to perform computations
460:54 - so tasks that perform
460:56 - particularly intensive calculations may
461:00 - cause performance issues and ultimately
461:02 - ux issues when a user runs our
461:04 - applications
461:07 - the asynchronous handling of CPU bound
461:09 - operations are implemented differently
461:11 - than the way I O bound operations are
461:14 - implemented for a comprehensive
461:16 - explanation of how we can handle i o
461:19 - bound operations asynchronously in
461:21 - c-sharp code please view the first part
461:23 - of this video series
461:27 - in this video we'll focus on handling
461:29 - CPU bound operations asynchronously
461:33 - so let's look at a code example where
461:35 - we'll run a number of CPU bound
461:37 - operations in parallel to one another so
461:40 - let's look at a code example where we'll
461:42 - run a number of CPU bound operations in
461:45 - parallel to one another which as we'll
461:47 - demonstrate will result in an overall
461:49 - performance advantage over running the
461:52 - same CPU bound operations synchronously
461:55 - so let's create a console application
462:03 - and name it Financial trading platform
462:05 - application
462:06 - so the theme of this code example is a
462:09 - trading platform the user of this
462:10 - application can analyze stock market
462:12 - charts that will include technical
462:14 - indicators to help the user decide to
462:17 - open or close a position regarding a
462:19 - particular stock
462:23 - I'm going to drastically simplify this
462:25 - code example so that we can focus on the
462:28 - principles involved in running multiple
462:29 - computational operations asynchronously
462:32 - the technical indicator information that
462:35 - will be presented with the relevant
462:36 - stock chart will be calculated on the
462:39 - Fly
462:40 - so in this example the technical
462:42 - indicators that will be calculated on
462:44 - the Fly and presented to the user with
462:46 - the relevant stock chart or for example
462:48 - stochastics fast moving average slow
462:51 - moving average and Bollinger Bands
462:53 - I'm not going to go into detail
462:55 - regarding the meaning of these technical
462:56 - indicators basically they aid the trader
462:59 - in deciding whether a stock is
463:01 - overbought or oversold or whether it has
463:04 - growing price momentum or losing price
463:06 - momentum ultimately these technical
463:09 - indicators Aid the trader and the
463:11 - Trader's decision to buy or sell a
463:13 - quantity of a particular stock
463:15 - so for example the stochastics the fast
463:18 - moving average the slow moving average
463:20 - and the Bollinger Bands can all be
463:22 - calculated in parallel to one another
463:23 - these calculations can be coded to run
463:26 - concurrently rather than consecutively
463:30 - so let's create a public class named
463:32 - stock market technical analysis data
463:41 - let's create a Constructor in our new
463:44 - class
463:45 - just for the sake of making this example
463:47 - feel more authentic let's add three
463:50 - parameters to this Constructor
463:52 - we are going to keep this example very
463:54 - simple and these parameters will not
463:55 - actually be utilized
463:58 - the arguments passed into these
464:00 - parameters would be used as query
464:02 - criteria when getting the raw stock
464:04 - market data from a remote source
464:08 - so the first parameter is stock symbol
464:10 - AS string representing a particular
464:13 - stock that the user wishes to analyze
464:14 - for example Apple Amazon Tesla
464:18 - Anglo gold whatever it might be the
464:21 - second parameter represents the start
464:23 - date and is defined as date time the
464:26 - third parameter represents the end date
464:29 - and is also defined as date time
464:32 - so the date time arguments passed into
464:34 - the second and third parameters will
464:37 - represent time period criteria
464:38 - pertaining to the time period over which
464:41 - the relevant stock market data was
464:43 - captured
464:45 - in the interests of keeping this example
464:47 - simple and in the interests of time we
464:49 - are not going to include any code within
464:52 - this Constructor
464:53 - let's simply comment that code would go
464:56 - here for retrieving data from a remote
464:58 - server
465:01 - so let's use our imaginations and say
465:03 - that an i o bound asynchronous HTTP
465:05 - request is made to a web API component
465:09 - to download the relevant raw stock
465:11 - market data within this Constructor
465:14 - this data will be used to calculate
465:16 - relevant technical indicator information
465:18 - so that the user can glean meaningful
465:20 - information from the downloaded raw
465:22 - stock market related data
465:25 - so let's create a few methods the first
465:28 - four methods won't be all that
465:29 - computationally intensive the first four
465:32 - methods will be responsible for getting
465:34 - the daily opening closing high and low
465:37 - prices for the relevant stock
465:39 - we'll then include the more
465:41 - computationally intensive methods in
465:43 - this class I.E the methods used for
465:45 - calculating the relevant technical
465:47 - indicator information for example the
465:50 - stochastics fast moving average slow
465:52 - moving average
465:54 - Etc
465:55 - so the first method will be responsible
465:57 - for performing an operation to get the
465:59 - daily opening prices for the relevant
466:01 - stock from the raw data that is
466:04 - retrieved within the Constructor
466:06 - so this method is appropriately named
466:09 - get opening prices
466:11 - so The Returned values for all of these
466:14 - methods defined within this class will
466:16 - be an array of values of type decimal
466:19 - this method will return an array of
466:21 - decimal values representing the opening
466:24 - prices for the relevant stock
466:26 - so in each of the methods we'll create
466:28 - for this class we'll write the method's
466:31 - name and the thread ID representing the
466:33 - thread on which the method will run to
466:35 - the console screen
466:37 - we are going to run multiple methods in
466:39 - this class on multiple threads
466:40 - concurrently
466:49 - so let's write code to Output a
466:51 - narrative to the screen which will serve
466:54 - as a substitute for presenting the
466:55 - actual data that would be required in a
466:57 - real world application
467:08 - foreign
467:20 - to represent the duration of time the
467:22 - operation performed by the relevant
467:24 - method could take
467:26 - let's make the thread on which the
467:28 - method will run sleep for a specified
467:30 - amount of time so for this method which
467:33 - won't require much computation we'll
467:36 - make the threat of execution sleep for a
467:38 - thousand milliseconds which is one
467:40 - second
467:41 - and then let's just return an empty
467:43 - decimal array
467:45 - the data in this example is not
467:47 - important in this example we want to
467:49 - focus on the asynchronous principles
467:51 - rather than the real world trading
467:53 - platform example that this code
467:54 - represents
467:56 - okay and the other methods can be
467:57 - implemented in much the same way let's
468:00 - copy this method
468:02 - and let's paste it eight times
468:19 - then let's modify the code appropriately
468:21 - for each method
468:23 - so the next method is named get closing
468:26 - prices
468:27 - and is responsible for retrieving the
468:30 - daily closing prices of the relevant
468:32 - stock from the raw downloaded stock
468:35 - market data
468:37 - let's say it runs for a thousand
468:39 - milliseconds
468:40 - the next method is named get price highs
468:44 - this method is responsible for getting
468:46 - the daily highs for the relevant stock
468:48 - this operation also runs for a thousand
468:51 - milliseconds
468:53 - the next method is named get price lows
468:56 - this method is responsible for getting
468:58 - the daily lows for the relevant stock
469:00 - let's say this method runs for a
469:02 - thousand milliseconds so all of the
469:04 - methods that we have added so far run
469:06 - for a thousand milliseconds
469:09 - now we are getting to the methods that
469:11 - are more computationally intensive this
469:14 - method is named calculate stochastics
469:16 - this method is responsible for
469:18 - calculating technical indicator
469:20 - information to help a Trader decide
469:22 - whether a stock is overbought or
469:25 - oversold
469:26 - which ultimately AIDS the trader with
469:29 - the decision to buy or sell a quantity
469:32 - of a particular stock at the current
469:34 - stock price
469:35 - so let's say that this may be a
469:37 - particularly computationally intensive
469:39 - operation so let's say this operation
469:42 - takes 10 seconds to complete so let's
469:45 - pass in an argument of 10 000
469:47 - milliseconds to the thread.sleep method
469:52 - the next method is named calculate fast
469:54 - moving average
469:56 - let's say that this operation is also
469:58 - computationally intensive so let's put
470:00 - the relevant thread to sleep for six
470:02 - seconds
470:04 - the next method is named calculate slow
470:06 - moving average let's put the relevant
470:09 - thread to sleep for 7 Seconds
470:12 - the next method is named calculate upper
470:14 - bound Bollinger band
470:25 - the next method is named calculate lower
470:27 - bound Bollinger band
470:32 - let's put the relevant thread to sleep
470:35 - for 5 seconds
470:40 - let's put the thread on which this
470:43 - method runs to sleep for five seconds
470:46 - the Bollinger Bands can also be used by
470:48 - Traders to ascertain whether the
470:49 - relevant stock is overbought or oversold
470:51 - which ultimately AIDS the Trader's
470:54 - decision to buy or sell a quantity of
470:56 - the relevant stock
470:58 - so you can see that the last five
470:59 - methods in this class could potentially
471:01 - be computationally intensive as these
471:04 - methods perform the operations of
471:06 - calculating technical indicator
471:08 - information from potentially large
471:10 - amounts of raw stock market data
471:12 - so let's go to the main method where
471:15 - we'll write code to call the methods
471:17 - that we have just created in our stock
471:19 - market technical analysis data class
471:23 - so let's first route to the console
471:24 - screen that the main method is being
471:26 - called in this output to the screen
471:28 - let's include the ID of the thread on
471:31 - which the main method will run
471:33 - we can get the thread ID from the
471:35 - thread.current thread dot managed thread
471:38 - ID property and we also want to include
471:41 - the thread name which of course is the
471:42 - main method
471:44 - so let's first demonstrate running the
471:47 - first four methods in the stock market
471:49 - technical analysis data class
471:50 - synchronously
471:52 - so that we can later run these methods
471:54 - asynchronously and then compare the
471:56 - performance difference
471:59 - so let's instantiate a new object from
472:02 - our stock market technical analysis data
472:04 - user-defined type
472:07 - let's say we want to download raw stock
472:10 - market data relating to the fictional
472:13 - stock represented by the symbol of
472:16 - stkza for data captured between the
472:19 - dates first of January 2010 and 1st of
472:23 - January 2020 so we want the specified
472:26 - stock market data for a particular stock
472:28 - captured over a specified 10-year period
472:33 - let's write code to run these methods
472:35 - synchronously
472:37 - so let's call the get opening prices
472:39 - method
472:49 - then the get closing prices method
472:52 - then the get price highs method and
472:54 - lastly the get price lows method
472:57 - so in order to see how long it takes for
472:59 - all four methods to complete let's
473:01 - capture and store the current date time
473:04 - value captured before we call the
473:06 - relevant for methods
473:10 - then let's subtract the date time value
473:12 - captured before the four methods are run
473:15 - from the date time value captured after
473:18 - our four methods have completed
473:21 - we are doing this so that we can see how
473:24 - many seconds have elapsed between the
473:26 - time we started to run our four methods
473:28 - and the time the operations carried out
473:30 - within these methods completed
473:33 - so each of these methods have been coded
473:35 - to take one thousand milliseconds or one
473:38 - second to complete
473:39 - let's add a method that denotes adding
473:42 - the relevant data to the stock chart
473:43 - that will be displayed to the trader
473:47 - let's name this method display data on
473:49 - chart
473:50 - to keep things simple we can simply
473:52 - write a message to the screen
473:54 - representing that this method has
473:57 - displayed the chart with all the
473:58 - requested data including relevant
474:01 - technical indicator information to the
474:03 - trader
474:28 - so let's run the code
474:46 - and we can see from the results that all
474:49 - of these methods are running
474:50 - synchronously on the main thread
474:53 - the thread ID of all of these methods is
474:55 - one
474:57 - we can see that each method ran
474:59 - consecutively
475:01 - we can see this because each of the four
475:03 - methods ran for one second and a total
475:05 - of four seconds was taken for all four
475:08 - methods to complete
475:18 - so now let's run these methods
475:20 - asynchronously using the task.run method
475:36 - so let's create a generic list to store
475:39 - the generic tasks that accept an array
475:43 - of decimals as the generic argument
475:45 - remember each of our methods within the
475:48 - stock market technical analysis data
475:50 - class return an array of decimal values
475:53 - let's ensure that we include the
475:55 - relevant directives
475:58 - so we need to include the
476:00 - system.threading.tasks directive and we
476:02 - also need to include the
476:03 - system.collections.genericdirective
476:19 - to be explicit let's first create our
476:22 - generic task objects and appropriately
476:25 - encapsulate the four method calls
476:29 - and note that the generic argument for
476:31 - each of the generic task objects is an
476:34 - array of decimal values because each of
476:36 - the relevant methods that the task
476:38 - objects encapsulate returns an array of
476:40 - decimal values
476:50 - foreign
477:17 - thank you
477:19 - right let's write the code to add each
477:22 - of the methods encapsulated within the
477:24 - task objects to our list
477:40 - now we can use the task.weight all
477:43 - method to block the main thread until
477:45 - all the tasks have completed
477:48 - so all of our tasks will run in parallel
477:50 - on background threads and the main
477:52 - thread will be blocked by the
477:54 - task.weight all method until all four
477:57 - methods have completed
478:00 - for more information on the task.weight
478:02 - all method please navigate to this URL
478:07 - so we need to pass our list of tasks to
478:10 - the task.weight or method
478:13 - but the task.waitol method expects an
478:16 - array so let's use the two array method
478:19 - to explicitly cast our list of generic
478:22 - task objects to an array of generic task
478:25 - objects
478:26 - so at this point in the code I.E after
478:29 - the task.weight or method call we know
478:32 - that all of our tasks have completed so
478:35 - we can get the results of each of our
478:37 - tasks like this
478:50 - great let's run the code
479:01 - if we look at the output we can see that
479:04 - the threads on which each of these
479:05 - methods ran have different thread IDs
479:08 - behind the scenes our code has run these
479:11 - methods on different threads
479:14 - when we ran these methods synchronously
479:16 - these methods ran consecutively and ran
479:19 - on one thread the main thread so I've
479:22 - noticed there's a little problem with
479:23 - the text output it says one seconds and
479:27 - should say one second so let's add a
479:29 - ternary operator to our code so that
479:32 - when one second has elapsed our code
479:34 - outputs one second rather than one
479:36 - seconds
479:38 - foreign
479:51 - we only want to Output seconds if the
479:54 - time that is elapsed is greater than one
479:56 - second
479:58 - let's run the code to check our fix
480:02 - great
480:04 - so let's write code to run all nine
480:06 - methods synchronously and after this
480:09 - we'll run all nine of these same methods
480:11 - asynchronously so we'll now be running
480:14 - some of the more computationally
480:15 - intensive methods within our stock
480:17 - market technical analysis data class in
480:20 - this demonstration
480:29 - foreign
481:02 - let's run the code
481:10 - and you can see that there is a
481:13 - significant time lag when running this
481:15 - code synchronously before all our
481:17 - methods complete and output is presented
481:20 - to the screen
481:49 - yeah
481:51 - let's write the code to run our methods
481:53 - asynchronously using the task.run method
482:15 - foreign
482:54 - thank you
483:17 - right let's run the code
483:26 - you can see by the thread IDs outputted
483:28 - to the screen that our methods are not
483:30 - running on the main thread and are
483:32 - running concurrently on background
483:34 - threads
483:35 - so in this video we have covered the
483:37 - basics of running multiple CPU bound
483:39 - operations asynchronously in this video
483:42 - series on asynchronous programming in
483:44 - c-sharp we have covered the basics of
483:47 - how we can improve performance of our
483:49 - applications through asynchronous
483:51 - programming when encountering either of
483:53 - the two types of blocking operations
483:55 - namely i o bound operations and CPU
483:58 - bound operations in the next video we'll
484:01 - look at the best practices and caveats
484:03 - of which we must be cognizant when
484:06 - running i o bound and CPU bound
484:08 - operations asynchronously
484:11 - for more content like this and much more
484:13 - please consider subscribing and please
484:15 - ring the bell so that you'll be notified
484:17 - of future content released from this
484:19 - channel
484:22 - if you feel you've gained value from
484:23 - viewing this video please smash the like
484:25 - button it will be greatly appreciated
484:27 - please feel free to share any of the
484:30 - videos created by this Channel with
484:31 - anyone you feel May benefit from their
484:33 - content
484:35 - I love reading your comments so please
484:37 - feel free to share your thoughts with me
484:38 - in the comment section
484:40 - all code created in these videos can be
484:42 - downloaded from GitHub
484:43 - please see below in the description
484:45 - links to the appropriate GitHub
484:47 - repositories
484:49 - [Music]
484:55 - hi and welcome to the third part of a
484:58 - tutorial on asynchronous programming
485:00 - using the c-sharp programming language
485:03 - this video is also the third part of the
485:06 - sixth tutorial in an advanced c-sharp
485:09 - course
485:10 - in the first and second parts of this
485:13 - video series we looked at how to apply
485:15 - asynchronous code so as to alleviate the
485:18 - negative effects of blocking operations
485:20 - on an application's ux user experience
485:25 - certain long-running operations
485:26 - performed by our applications can be the
485:29 - source of poor performance of our
485:31 - applications
485:32 - for example long-running operations
485:34 - perform from WPF uwp or xamarin
485:38 - applications can cause the UI user
485:40 - interface to be periodically
485:42 - unresponsive
485:44 - this can be frustrating for the user of
485:46 - our applications
485:48 - the user will have a sub-optimal user
485:51 - experience
485:53 - C sharp provides us as developers with
485:56 - appropriate tools to handle these
485:58 - long-running operations asynchronously
486:00 - with relative ease
486:02 - so let's discuss the difference between
486:04 - i o bound operations and CPU bound
486:06 - operations and this will set us up for
486:09 - later when we create a code example to
486:11 - help us understand best practices when
486:13 - applying asynchronous code to handle i o
486:16 - bound or CPU bound operations
486:18 - so in this video series we have already
486:20 - discussed that the two kinds of CPU
486:23 - blocking operations are CPU bound
486:25 - operations and I O bound operations CPU
486:29 - bound operations operations that perform
486:31 - computations that need to be handled by
486:34 - the CPU for example mathematical
486:36 - operations encryption decryption
486:38 - operations Graphics related operations
486:41 - Financial calculations Etc basically
486:44 - computational operations
486:46 - i o bound operations or operations that
486:49 - are delegated to the i o subsystem to
486:52 - perform tasks such as writing to a hard
486:55 - disk drive engaging the i o subsystem to
486:58 - perform requests across the network file
487:00 - handling operations Etc
487:03 - we discussed that I O bound operations
487:05 - are more commonly encountered than CPU
487:08 - bound operations io-bound operations are
487:11 - also generally a lot slower than CPU
487:14 - bound operations
487:15 - so this video is about best practices
487:18 - when applying asynchronous code in our
487:20 - applications
487:22 - please view the first and second parts
487:24 - of this video series on asynchronous
487:26 - programming for a foundational
487:28 - understanding of i o bound operations
487:30 - and CPU bound operations in the context
487:32 - of asynchronous programming in c-sharp
487:36 - the recommended coding methodology
487:38 - provided by Microsoft in the c-sharp
487:41 - language to create asynchronous behavior
487:43 - in our applications is known as the
487:45 - task-based asynchronous pattern tap
487:49 - over the last two videos in this series
487:51 - we have discussed why we should
487:54 - Implement asynchronous code
487:56 - the simple answer is to improve the
487:58 - performance of our applications in this
488:00 - video Let's clarify the best practices
488:02 - when applying writing code to run the
488:05 - relevant code asynchronously
488:07 - let's start with i o bound operations as
488:10 - we have discussed io-bound operations
488:13 - refer to operations like for example
488:15 - file handling operations making requests
488:18 - across a network writing data to a
488:21 - database reading data from a database
488:23 - Etc
488:24 - operations that Engage The i o subsystem
488:28 - we can handle io-bound operations
488:30 - asynchronously both on the client side
488:33 - for example in WPF uwp winforms or
488:37 - xamarin applications we can also handle
488:40 - i o bound operations asynchronously on
488:42 - the server side and for example web API
488:45 - or asp.net MVC applications
488:48 - I have bound operations can be handled
488:50 - using async await
488:52 - in simple terms an asynchronous method
488:55 - that returns a task object can be
488:57 - preceded with the await operator which
488:59 - means we can run the operation
489:01 - asynchronously using async await
489:04 - so for example for a.net client
489:07 - application a button is clicked within
489:09 - the button-click event handler method an
489:11 - asynchronous method is invoked
489:14 - so the asynchronous method is invoked on
489:16 - the UI thread
489:17 - this means that immediately after the
489:19 - asynchronous method is invoked the UI
489:22 - thread is free to be utilized to process
489:24 - other operations
489:27 - the user interface UI does not freeze
489:30 - while the asynchronous method is running
489:32 - the user is able to for example click
489:35 - other buttons and invoke other
489:36 - operations that can be invoked on the UI
489:39 - thread
489:40 - when an asynchronous method is called to
489:43 - perform the relevant i o bound operation
489:46 - the task is immediately delegated to the
489:49 - i o subsystem
489:51 - and instead of blocking the CPU as would
489:54 - be the case if we were running the i o
489:56 - bound operation synchronously the async
489:59 - modifier and await operator instruct
490:01 - the.net runtime to ensure that the CPU
490:04 - is not blocked during the running of the
490:07 - i o bound operation
490:09 - this means that other operations can
490:11 - utilize the CPU even while the i o bound
490:13 - operation is running
490:16 - very briefly what is happening is that
490:19 - when the.net runtime encounters the
490:22 - await operator as discussed the thread
490:25 - on which the operation is invoked on the
490:28 - client this would be the UI thread for
490:29 - example is immediately released
490:33 - so at this time code in the relevant
490:34 - method is suspended I.E the lines of
490:38 - code that follow the line of code that
490:40 - contains the await operator and the
490:42 - relevant method will not be executed
490:44 - until the asynchronous i o bound
490:46 - operation completes
490:48 - while the asynchronous i o bound
490:50 - operation is running however the UI
490:52 - thread can be used to process other
490:54 - operations for example invoked from
490:57 - clicking another button on the UI
490:59 - But A promise is returned to the line of
491:02 - code containing the await operator is
491:04 - made
491:05 - so when the relevant asynchronous
491:07 - operation completes the dotnet runtime
491:09 - returns to the line of code containing
491:12 - the await operator returns a value if
491:15 - required and continues to execute the
491:18 - lines of code
491:19 - from that point in the relevant method
491:22 - so the key point of this explanation is
491:24 - that unlike for CPU bound operations i o
491:27 - bound operations generally don't require
491:29 - additional background threads in this
491:32 - example the.net runtime is delegating
491:34 - the i o bound operation to the i o
491:37 - subsystem and not to a new thread
491:39 - required from the thread pool
491:44 - so I think before we continue let's
491:46 - ensure that we have a clear
491:48 - understanding of what is meant by the
491:50 - following terms thread and thread pool
491:55 - let's start with the term thread
491:58 - a thread in computer science is short
492:00 - for a thread of execution
492:02 - threads are a way for a program to
492:04 - divide itself into two or more
492:06 - simultaneously or pseudo-simultaneously
492:09 - running tasks
492:11 - thread pool a thread pull is a group of
492:14 - pre-instantiated idle threads which
492:17 - stand ready to be given work so a thread
492:20 - pool is created so that threads are
492:22 - readily available to a program which
492:24 - means when a program requires a thread
492:27 - the program can acquire the thread from
492:30 - the thread pool rather than incur the
492:32 - overhead of instantiating a new thread
492:36 - so let's go back to the example
492:37 - demonstrated in the second part of this
492:40 - video series where the task.run method
492:42 - was used to run CPU bound operations
492:46 - we demonstrated how each method that was
492:49 - run through the implementation of the
492:51 - task.run method was run on its own
492:53 - dedicated background thread
492:56 - so each time the task.run method is
492:58 - invoked a new thread is taken from the
493:01 - thread pool and used to run the relevant
493:03 - CPU bound operation
493:06 - so this resulted in the methods that
493:08 - encapsulate the CPU bound operations
493:10 - running concurrently I.E asynchronously
493:13 - rather than running one after the other
493:15 - I.E synchronously
493:17 - if you haven't yet viewed the second
493:19 - part of this video series please view
493:21 - this video for a foundational
493:23 - understanding of running multiple CPU
493:25 - bound operations concurrently on
493:28 - multiple background threads
493:30 - so the key takeaway here is that when an
493:33 - i o bound operation is run using the
493:35 - async modifier and the await operator a
493:38 - background thread is not required to
493:40 - handle the operation the operation is
493:42 - delegated by the.net runtime to the i o
493:45 - subsystem
493:47 - when a CPU bound operation is run using
493:49 - the task.run method a background thread
493:52 - is used to run the operation in the
493:54 - background concurrently with the main
493:56 - thread of execution
493:59 - so now with a foundational understanding
494:01 - of the differences of how i o bound and
494:04 - CPU bound operations are handled
494:05 - asynchronously let's look at Best
494:08 - Practices regarding implementing each of
494:11 - these types of operations asynchronously
494:15 - so with running i o bound operations
494:16 - asynchronously
494:18 - there's less to be concerned about
494:20 - simply because of the way the i o bound
494:22 - operations are handled under the hood i
494:24 - o bound operations can be delegated to
494:26 - the i o subsystem and the need to use
494:29 - additional background threads is not
494:31 - necessary
494:32 - with running CPU bound operations
494:34 - asynchronously under the hood the.net
494:37 - runtime employs additional background
494:39 - threads to run the CPU bound operations
494:42 - this for example means that multiple
494:45 - tasks can run on the additional
494:47 - background threads concurrently
494:50 - there may be times where using multiple
494:52 - threads is undesirable and may not
494:54 - result in the desired performance
494:56 - benefit there are times when running
494:59 - multiple threads to perform tasks in
495:01 - parallel may result in an overall poorer
495:04 - performance
495:05 - an example of this is running CPU bound
495:08 - operations from within server-side code
495:11 - for example code implemented for asp.net
495:14 - MVC applications or code implemented for
495:17 - web API components
495:19 - we'll discuss why CPU bound operations
495:22 - should be run synchronously
495:24 - under these scenarios a bit later in
495:27 - this video
495:28 - so let's create a code example to help
495:31 - us understand best practices when
495:33 - confronted with issues relating to
495:35 - asynchronous programming in c-sharp
495:38 - the theme of this client application
495:39 - will be the same as the theme we used in
495:42 - the previous video in this series I.E a
495:45 - financial trading platform
495:47 - so in the last video we created a
495:50 - console application to get a general
495:51 - idea of running CPU bound operations
495:54 - in this video Let's create a new blank
495:58 - uwp project
496:00 - uwp stands for universal windows
496:02 - platform
496:15 - let's name this project Financial
496:18 - trading platform uwp
496:38 - thank you
496:56 - let's set up a basic UI user interface
496:59 - let's drag a button onto the designer
497:01 - surface
497:07 - let's enlarge this button a bit
497:11 - foreign
497:20 - TN fast local operation
497:29 - let's label this button fast local
497:32 - operation
497:38 - let's drag another button onto the
497:40 - designer's surface just below the button
497:43 - we have just added
497:54 - let's name this button BTN CPU bound
497:57 - operations let's label this button CPU
498:01 - bound operations
498:11 - and lastly let's drag a list view
498:13 - control onto the designer surface and
498:16 - position this control to the right of
498:19 - our buttons like this
498:21 - foreign
498:33 - let's name this list view control lvw
498:36 - output
498:47 - so before we add code directly to this
498:49 - file let's add another project to the
498:52 - solution
498:54 - we want our code to be reusable across
498:57 - both server-side and client-side
498:58 - projects so let's create a standard
499:01 - Library project to our solution
499:15 - and let's name this project stock market
499:18 - component
499:31 - let's add a reference to the stock
499:33 - market component standard Library
499:35 - project from our uwp client project
499:39 - foreign
499:48 - let's delete the class file that has
499:51 - been generated in our standard Library
499:53 - project
500:02 - and let's add a class named stock market
500:04 - data to our project
500:25 - let's add a method named get data async
500:28 - this method represents retrieving
500:30 - relevant stock market data from a server
500:32 - so it is an i o bound operation
500:36 - the method will return a string to the
500:38 - calling client code
500:40 - so let's include the async modifier in
500:43 - the method definition as well as a
500:45 - generic task type that accepts a string
500:47 - as the data type argument
500:50 - notice that we have included the async
500:52 - suffix in our method name
500:55 - this lets the developer know that this
500:57 - is code that should be called
500:59 - asynchronously
501:01 - so when the calling client code writes
501:03 - code to call this method the developer
501:05 - should include the await operator
501:06 - preceding the method call as well as
501:08 - include the async modifier in the method
501:11 - definition of the method where the
501:13 - relevant async call resides
501:19 - so in the interests of time we'll simply
501:22 - include placeholder code for this method
501:25 - so let's use the task.delay method to
501:28 - represent the time that the work could
501:30 - take to carry out our relevant i o bound
501:32 - task
501:33 - so let's say this process takes 5
501:36 - seconds so let's pass 5000 milliseconds
501:39 - to the task.delay method
501:42 - let's then simply return a string value
501:44 - representing the stock market data that
501:47 - has been retrieved from the remote
501:49 - server
501:51 - so let's simply return the literal text
501:53 - stock market data from this method
501:56 - we must also include the await operator
501:58 - preceding our call to the task.delay
502:01 - method
502:03 - let's add a new class and let's name
502:06 - this class stock market data analysis
502:19 - so let's add a Constructor that contains
502:22 - a parameter named data which will
502:24 - represent the downloaded stock market
502:26 - data
502:27 - for the purposes of this example we
502:30 - don't need to include any code within
502:32 - the Constructor
502:33 - so very much like the code example in
502:35 - the previous video of this video series
502:37 - let's include methods that calculate the
502:40 - technical indicators that the user of
502:43 - our application can use to Aid the
502:45 - user's decision to buy or sell a
502:47 - quantity of a particular stock
502:50 - the technical indicators that we'll
502:51 - refer to in this example will be the
502:54 - fast moving average the slow moving
502:56 - average stochastics and Bollinger Bands
502:59 - if you are not familiar with these terms
503:01 - don't worry the only thing that you need
503:03 - to know to follow along with this
503:05 - example is that calculating the data for
503:07 - these Financial trading related
503:09 - technical indicators are CPU intensive
503:11 - they are CPU bound operations this is
503:14 - why I've chosen these technical
503:16 - indicators for this example IE to serve
503:18 - as intensive long-running CPU bound
503:21 - operations
503:22 - so let's include a method to calculate
503:25 - the fast moving average
503:27 - so for these methods that represent CPU
503:29 - bound operations we can simply put the
503:32 - current thread to sleep for a specified
503:34 - amount of time representing the time
503:36 - that the relevant operation may take to
503:38 - complete
503:40 - so for this method let's put the thread
503:42 - to sleep for six seconds
503:44 - then for the purposes of this
503:46 - demonstration let's simply return the
503:48 - method name and the thread ID to the
503:50 - calling code
503:59 - foreign
504:32 - let's duplicate this method three times
504:34 - these additional three methods represent
504:37 - the calculation of other technical
504:39 - indicators
504:41 - so we can maintain the general structure
504:43 - of the methods that we have just created
504:45 - as they are and simply change the method
504:48 - names and the time durations that
504:50 - represent the time the method takes to
504:53 - complete
504:54 - please note that the time durations that
504:56 - are being specified here are completely
504:58 - arbitrary and have been chosen only for
505:00 - demonstration purposes
505:02 - so this method represents calculating
505:05 - the slow moving average
505:07 - let's name this method calculate slow
505:09 - moving average
505:11 - let's put the relevant thread to sleep
505:13 - for seven seconds
505:15 - this method represents calculating the
505:17 - stochastics
505:18 - let's name this method calculate
505:20 - stochastics let's put the relevant
505:22 - thread to sleep for 10 seconds
505:25 - this method represents calculating the
505:27 - Bollinger Bands
505:28 - let's name this method calculate
505:30 - Bollinger Bands
505:32 - let's put the relevant thread to sleep
505:34 - for five seconds
505:36 - great so let's say that we now have a
505:39 - reusable standard Library component for
505:41 - calculating stock market technical
505:43 - indicator information completed
505:46 - so just to confirm that we have already
505:48 - referenced this reusable component from
505:50 - our uwp client application
505:53 - great so let's add some code to add the
505:56 - output of our methods to our list view
505:59 - control that we named lvw output
506:02 - so let's create a private method named
506:05 - add list item
506:06 - so you're of course welcome to follow me
506:08 - as I create the code for this method or
506:11 - you can of course copy the code from
506:13 - GitHub a link to the relevant GitHub
506:15 - repository is available Below in the
506:18 - description
506:32 - great so let's include code within our
506:34 - button click event handlers
506:37 - to create a button click event handler
506:39 - definition we can simply go to our
506:42 - designer surface and double click on the
506:44 - relevant button like this
506:47 - so we are first going to create code for
506:49 - the fast local operation
507:14 - foreign
507:39 - so let's create the button click event
507:42 - handling method definition for the
507:44 - method that will execute our CPU bound
507:46 - operations
507:48 - these CPU bound operations are
507:51 - encapsulated within the methods in our
507:54 - stock market data analysis class that
507:56 - reside in our standard Library project
507:59 - let's ensure that we have a directive to
508:01 - the stock market component namespace
508:08 - so let's instantiate an object from our
508:12 - stock market data analysis class
508:14 - which resides in our stock market
508:16 - component standard Library project for
508:19 - now let's simply pass in the literal
508:21 - Text data to the Constructor of the
508:24 - stock market data analysis class to
508:26 - represent the raw stock market data
508:28 - downloaded from a remote server
508:33 - so let's write code first to run all of
508:37 - these CPU bound operations in parallel
508:39 - to one another in much the same way as
508:42 - we demonstrated in the code example in
508:44 - the previous part of this video series
508:46 - so firstly let's create a list of
508:49 - generic task objects
508:51 - that accept the string data type as
508:53 - their data type arguments
508:56 - so we know that the task.run method
508:59 - returns a task object or generic task
509:01 - object
509:02 - the methods we wish to call all return
509:04 - strings so each item in the relevant
509:07 - list must be strongly typed with a
509:09 - generic task object that accepts the
509:12 - string data type as an argument
509:15 - right so let's add the tasks we wish to
509:17 - run to our list like this
509:36 - then we can call the task.weight all
509:38 - method
509:40 - and in a bit I'll explain why the
509:42 - task.weight or method is not the best
509:44 - method to call in this context
509:47 - foreign the code following the
509:50 - task.weight all method we know that the
509:52 - relevant methods that have run
509:54 - asynchronously have completed so we can
509:57 - add The Returned values from our methods
510:00 - to our lvw output list view control
510:04 - let's write the code to do this
510:31 - right let's run the code
510:43 - so now when I press the button marked
510:46 - CPU bound operations notice that our UI
510:49 - is unresponsive when we try to perform
510:52 - any other operations
510:54 - so I'm attempting to click the button
510:56 - marked fast local operation the button
510:58 - cannot be clicked because the screen is
511:00 - frozen and therefore the output from
511:03 - this action is not presented to the
511:05 - screen in our list view component
511:08 - the UI is unresponsive when I click the
511:10 - button labeled fast local operation
511:12 - because the UI thread is blocked
511:15 - we have written our code to run a batch
511:17 - of methods asynchronously but we have
511:20 - also written code to block the UI thread
511:23 - while our CPU bound operations are
511:25 - running
511:26 - the weight all method blocks the UI
511:28 - thread until all the relevant tasks have
511:30 - completed
511:32 - so even though the CPU bound operations
511:34 - like for example calculate stochastics
511:36 - calculate fast moving average
511:39 - Etc or running in parallel to one
511:41 - another on background threads which will
511:43 - give us a performance Advantage the UI
511:46 - thread is being blocked while the CPU
511:48 - bound operations are running this is not
511:50 - ideal
511:52 - so we can solve this issue because we
511:55 - can in fact use the await operator when
511:58 - running a batch of CPU bound operations
512:00 - we can achieve this by using the when
512:03 - all method instead of using the UI
512:06 - blocking weight all method for running a
512:09 - batch of CPU bound operations on
512:11 - background threads
512:12 - so let's replace the weight all method
512:15 - with the when all method
512:17 - for more information on the when all
512:19 - method please navigate to this URL
512:23 - so please note that the weight all
512:25 - method does not return a task object or
512:27 - generic task object so this means we
512:30 - cannot call this method using async
512:32 - await
512:33 - the weight all method blocks the UI
512:35 - thread until the tasks within the
512:37 - relevant batch have completed the tasks
512:40 - will be run concurrently on separate
512:42 - background threads but the UI thread
512:44 - will be blocked while the tasks are
512:46 - running the when all method however does
512:49 - return a task object or generic task
512:51 - object this means we can call the when
512:54 - all method using async await which means
512:57 - that we can call the when or method to
512:59 - run our tasks concurrently without
513:01 - blocking the UI thread the UI will still
513:04 - be responsive even while we are running
513:07 - a batch of CPU bound operations when we
513:10 - are using the when all method
513:13 - so let's proceed our call to the win or
513:15 - method with the await operator like this
513:17 - we of course need to also include the
513:20 - async modifier in the relevant button
513:22 - click event handler method signature
513:24 - like this
513:31 - let's run the code
513:41 - let's click the button marked CPU bound
513:44 - operations
513:45 - and now when we run the code the UI
513:48 - thread is not blocked and we are able to
513:50 - perform the fast local operation while
513:52 - the CPU bound operations are running in
513:55 - the background
513:56 - we can perform other operations
513:58 - concurrently while the relevant CPU
514:00 - bound operations are running
514:02 - so the task.run method returns a task
514:05 - object or generic task object this means
514:08 - we can use the await operator when we
514:11 - call a CPU bound operation in this way
514:14 - so to prove this rather than calling a
514:16 - batch of CPU bound operations as we are
514:19 - doing here let's run just one of the CPU
514:21 - bound operations using the task.run
514:24 - method
514:25 - so let's run the calculate stochastics
514:27 - method using the task.run method
514:30 - so we can call this method on a
514:31 - background thread asynchronously like
514:33 - this
514:39 - let's run the code
514:40 - let's click the CPU bound operations
514:43 - button and you can see that while the
514:45 - calculate stochastics method is running
514:47 - we are able to click the fast local
514:50 - operation button the fast local
514:52 - operation button can run concurrently
514:54 - with the operation performed by the
514:56 - calculate stochastics method and as we
514:59 - have already proven we can also run a
515:01 - batch of CPU bound operations on
515:03 - background threads without blocking the
515:05 - UI thread using the when all method
515:09 - so let's change the code back to the way
515:11 - it was so that we can call a batch of
515:13 - CPU bound operations using task.run
515:16 - async await and win all
515:21 - then we could reuse this functionality
515:23 - because we have written our CPU bound
515:25 - operations
515:26 - in a reusable Library component
515:30 - this brings us to an important best
515:32 - practice when implementing asynchronous
515:34 - code for CPU bound operations
515:37 - the developer should never include the
515:39 - task.run method within reusable
515:41 - components
515:43 - always let the developer decide whether
515:46 - to run an operation synchronously or
515:48 - asynchronously so the consumer of the
515:51 - component should always have the choice
515:53 - to run an operation contained within for
515:55 - example a library component
515:57 - synchronously or asynchronously in our
516:00 - example we have chosen to run our
516:02 - operations encapsulated within the stock
516:04 - market data analysis component project
516:07 - asynchronously but we could have chosen
516:10 - to run them synchronously we have proven
516:12 - in our demonstration that running the
516:14 - CPU bound operations asynchronously
516:16 - gives us a huge performance Advantage we
516:19 - did however have the choice to run these
516:22 - operations synchronously or
516:23 - asynchronously because the operations
516:25 - are not implemented to run
516:27 - asynchronously within any of the methods
516:29 - of the component itself I.E we have not
516:32 - implemented the task.run method within
516:35 - the stock market data analysis component
516:38 - project
516:40 - so in the stock market data class we
516:43 - have written an i o bound operation
516:45 - that is responsible for downloading the
516:47 - raw stock market data from a remote
516:49 - server
516:50 - this is different to a CPU bound
516:52 - operation because it engages the i o
516:55 - subsystem and not the thread pool to
516:57 - acquire a background thread
516:59 - so let's write code to run this i o
517:02 - bound operation in order to download the
517:05 - relevant raw stock market Data before
517:07 - calculations are performed from the raw
517:10 - stock market data
517:11 - so we could invoke the i o bound method
517:14 - lazily like this
517:16 - so let's create a member variable named
517:18 - underscore data then within the relevant
517:21 - button click event handler we can check
517:23 - to see if the underscore data variable
517:25 - is null if it is null we can then run
517:28 - the i o bound operation if the
517:31 - underscore data variable is not null
517:33 - then it means we have the data and can
517:35 - pass it into the stock market data
517:38 - analysis classes Constructor when
517:40 - instantiating the relevant object
517:42 - it is best to include the task.run
517:45 - method close to the relevant event
517:47 - handler method as we have done here
517:50 - we have control over whether we want to
517:52 - run these operations using the task.run
517:55 - method on background threads or run them
517:57 - synchronously
517:58 - so calling the task.run method directly
518:01 - from the relevant event handler method
518:03 - like for example a button-click event
518:05 - handler is a best practice
518:08 - another best practice is that if the
518:10 - relevant methods code doesn't need to
518:13 - run on the original thread once the CPU
518:16 - bound operations have completed then we
518:18 - can in fact gain a bit of a performance
518:20 - boost by not returning to the main
518:22 - thread
518:24 - the rule of thumb here is don't run code
518:27 - on the main UI thread unless you have to
518:30 - so we can achieve this performance boost
518:32 - by using the configure await method
518:36 - so the when all method returns a task
518:38 - object which implements the configure
518:40 - await method this means we can call the
518:43 - configure await method like this
518:46 - notice we are passing in false as the
518:48 - parameter to this method we are saying
518:51 - that after the calculations are
518:53 - performed by the CPU bound operations
518:55 - don't return to the main thread
518:58 - so for example a context where this
519:00 - would be appropriate would be once the
519:03 - calculations are completed we want to
519:05 - save the calculated data to a file
519:08 - so in this scenario we don't want to
519:10 - display the data on for example a stock
519:13 - market chart we only want to save the
519:15 - data locally in this context there is no
519:18 - reason to return to the main thread
519:20 - however in a context where we need to
519:23 - display the information on a chart
519:25 - we of course would need to return to the
519:27 - main thread
519:28 - the last best practice I would like to
519:31 - include in this video
519:32 - is that we should avoid including the
519:34 - task.run method within methods
519:37 - implemented in server-side components if
519:39 - for example we implemented our trading
519:42 - platform calculation functionality as a
519:45 - software as a service application for
519:47 - the purpose of providing calculated
519:48 - technical indicator information to
519:50 - web-based client trading platforms we
519:53 - should not implement the CPU bound
519:55 - operations using the task.run method on
519:58 - the surface it may seem like this would
520:00 - give us a performance Advantage but in
520:02 - reality this puts an unnecessary strain
520:05 - on server resources and ultimately can
520:08 - adversely affect performance
520:10 - the reason for this is that with a
520:13 - server-side component say for example
520:15 - implemented as an asp.net web API
520:18 - component you may have thousands of HTTP
520:21 - requests coming in to the relevant web
520:23 - API component each HTTP request requires
520:28 - a thread from the server's thread pool
520:31 - if the code within the relevant
520:33 - server-side method is coded to run four
520:36 - operations asynchronously through the
520:38 - use of the task.run method then your web
520:40 - API component needs to acquire an
520:43 - additional four threads to carry out the
520:45 - instructions implemented in the relevant
520:48 - method
520:48 - this could cause an unacceptably high
520:51 - use of server resources which could
520:53 - adversely affect the overall performance
520:55 - of the relevant server and ultimately
520:57 - negatively impact the user's experience
521:00 - with the relevant application
521:03 - so the moral of this story is avoid
521:05 - running additional background threads on
521:07 - the server side rather run CPU bound
521:10 - operations synchronously on the server
521:12 - side you can still ensure that the
521:14 - client-side UI is responsive by calling
521:17 - the server side code using async await
521:19 - remember an HTTP request from the
521:23 - client's perspective is an i o bound
521:25 - operation
521:26 - note that running i o bound operations
521:28 - on the server is different to running
521:31 - CPU bound operations on the server an
521:33 - example would be downloading the raw
521:35 - stock market data from the server
521:37 - perhaps the server-side code simply
521:39 - retrieves the raw stock market data from
521:42 - a database before returning the relevant
521:44 - data to the client this i o bound
521:46 - operation can be written on the server
521:48 - using async await
521:51 - the i o bound code does not require
521:53 - additional threads and therefore
521:55 - additional server-side resources when a
521:58 - client request is made to run the method
522:00 - responsible for running the relevant i o
522:02 - bound operation on the server the thread
522:04 - used for processing the request can be
522:07 - released to handle other requests while
522:10 - the relevant i o bound operation is
522:12 - being performed
522:14 - CPU bound operations that are invoked
522:17 - using task.run will require additional
522:19 - threads which means additional server
522:22 - resources will be required
522:25 - in summary when it comes to best
522:27 - practices in terms of asynchronous
522:29 - programming in c-sharp know the nature
522:32 - of your asynchronous code ask the
522:35 - question is the operation CPU bound or i
522:37 - o bound and then apply the relevant
522:39 - asynchronous code appropriately
522:42 - avoid writing CPU bound operations
522:44 - within reusable Library components using
522:48 - the task.run method
522:49 - [Music]
522:51 - let the consumer of the library
522:52 - component choose whether to run the CPU
522:56 - bound operations synchronously or
522:58 - asynchronously
523:00 - methods that run i o bound operations
523:02 - asynchronously included within reusable
523:05 - Library components should include the
523:07 - async suffix as part of the relevant
523:10 - method's name
523:11 - this will let the consumer of your
523:13 - library know that the relevant method
523:15 - should be run asynchronously using async
523:18 - await
523:19 - on the client side run CPU bound
523:21 - operations close to the relevant UI
523:24 - event handler method for example use the
523:27 - task.run method directly within the
523:29 - relevant button click event handler
523:31 - method
523:32 - if for example a button-click event
523:34 - handler method needs to perform a CPU
523:36 - bound operation asynchronously on a
523:38 - background thread and subsequently code
523:41 - within that method does not require a
523:44 - return to the UI thread explicitly let
523:47 - the.net runtime know that it is
523:49 - unnecessary to return to the UI thread
523:52 - once the CPU bound operation has
523:54 - completed by appropriately calling the
523:57 - configure await method this can result
524:00 - in a performance boost
524:02 - avoid running CPU bound operations on
524:05 - the server side using the task.run
524:07 - method
524:10 - these operations require additional
524:13 - threads which can result in a strain on
524:15 - server-side resources and the issue will
524:18 - be compounded if the server is handling
524:20 - hundreds or thousands of HTTP requests
524:22 - running i o bound operations for example
524:25 - retrieving information from a web API
524:27 - component reading data from a database
524:30 - or routing data to a database on the
524:31 - server side using async await it's good
524:35 - practice because the main thread of
524:37 - execution is free to handle other client
524:39 - requests while the relevant i o bound
524:42 - operation is running
524:44 - so in this video we covered how to
524:46 - implement best practices in our code
524:48 - when running code asynchronously in C
524:51 - sharp
524:52 - for more content on advanced c-sharp
524:54 - concepts and much more please consider
524:56 - subscribing and please ring the bell so
524:59 - that you'll be notified of future videos
525:00 - released from this channel
525:02 - if you feel you've gained value from
525:04 - viewing this video please smash the like
525:06 - button it will be greatly appreciated
525:08 - please feel free to share any of the
525:10 - videos created by this Channel with
525:12 - anyone you feel May benefit from their
525:14 - content
525:16 - I love reading your comments so please
525:18 - feel free to share your thoughts with me
525:19 - in the comments section
525:21 - all code created in these videos can be
525:24 - downloaded from GitHub please see below
525:26 - in the description links to the
525:28 - appropriate GitHub repository
525:30 - [Music]
525:40 - hi and welcome to the fourth and final
525:43 - video in a video series on asynchronous
525:46 - programming in c sharp
525:48 - this video is also part of the sixth
525:50 - tutorial in an advanced c-sharp course
525:54 - this video is a continuation of the last
525:57 - three videos in this video series on
525:59 - asynchronous programming so please view
526:01 - each of the preceding videos in this
526:02 - video series before viewing this video
526:06 - [Music]
526:10 - in this video we are going to look at
526:13 - how to use a cancellation token Source
526:16 - object to explicitly cancel an
526:19 - asynchronous task or many asynchronous
526:21 - tasks encode before the relevant tasks
526:25 - or tasks have completed using one
526:28 - cancellation token Source object
526:31 - for more content on advanced c-sharp
526:33 - concepts and much more please consider
526:35 - subscribing and please ring the bell so
526:37 - that you'll be notified of future
526:39 - content released from this channel
526:42 - right so to gain an understanding of how
526:44 - we are able to implement code to cancel
526:46 - one asynchronous operation or multiple
526:48 - asynchronous operations using one
526:51 - cancellation token Source object let's
526:53 - look at a practical code example
526:56 - so I'm going to base this code example
526:58 - on an example included in the Microsoft
527:01 - Docs
527:02 - so please navigate to this URL
527:05 - a link to this URL has been included
527:07 - Below in the description you can see
527:09 - that this webpage is entitled cancel a
527:12 - list of tasks in Brackets C sharp
527:16 - so let's first look at the prerequisites
527:19 - section of this document
527:21 - I want to draw your attention to the
527:23 - first prerequisite so this tutorial
527:26 - requires the following dotnet 5 SDK
527:31 - I'm actually not going to install
527:33 - the.net 5 SDK on my windows platform at
527:36 - this time and we'll be creating this
527:39 - example using the.net core version 3.1
527:42 - runtime
527:43 - we are able to run this example using
527:45 - the.net core version 3.1 runtime but we
527:49 - will need to make a small modification
527:51 - to the code to get this working
527:53 - if you do decide to install the.net 5
527:57 - SDK
527:58 - know that the version available at the
528:00 - time of writing this tutorial is not yet
528:03 - the official release
528:05 - it is an RC release which stands for
528:08 - recommended candidate
528:10 - so if you install Net 5 SDK I recommend
528:13 - reading all Associated content that can
528:16 - be found at this URL
528:18 - that we can navigate to when we click
528:21 - the link here marked dot Net 5 or later
528:24 - SDK
528:26 - this content can guide us in for example
528:29 - which version of Visual Studio should be
528:33 - installed to support the current RC
528:35 - version of.net 5.
528:38 - I also recommend reading this blog post
528:40 - posted by Richard Lander this blog post
528:43 - can be found at this URL
528:45 - for a foundational understanding of.net
528:48 - 5 I recommend viewing a video created by
528:50 - this channel which can be found at this
528:52 - URL as always I have included all
528:55 - relevant links Below in the description
528:59 - I'll demonstrate how we are able to
529:01 - implement and run this code example so
529:05 - even if you decide not to install.net 5
529:07 - SDK at this time and your latest version
529:10 - of the.net runtime is.net core version
529:12 - 3.1 you're still able to follow along
529:15 - with the implementation of this example
529:18 - to enable running this code using
529:20 - the.net core 3.1 runtime
529:22 - we only need to apply one simple code
529:25 - modification we'll apply this
529:27 - modification when appropriate
529:30 - let's look at the first paragraph on
529:32 - this webpage in the first paragraph on
529:34 - this webpage it states you can cancel an
529:37 - asynchronous console application if you
529:39 - don't want to wait for it to finish by
529:42 - following the example in this topic you
529:44 - can add a cancellation to an application
529:46 - that downloads the contents of a list of
529:49 - websites
529:51 - you can cancel many tasks by associating
529:54 - the cancellation token Source instance
529:56 - with each task
529:59 - if you select the enter key you cancel
530:02 - all tasks that aren't yet complete
530:05 - so we are going to base our practical
530:07 - code example on the example here
530:08 - provided in this webpage in the
530:11 - Microsoft Docs
530:13 - however we are going to implement our
530:14 - code example as a uwp universal windows
530:18 - platform project
530:19 - instead of how it is implemented in this
530:22 - Microsoft example as a net core console
530:25 - application
530:26 - we are going to copy aspects of the code
530:29 - provided in the Microsoft code example
530:31 - over to our code editor in a
530:34 - step-by-step fashion so let's create a
530:37 - uwp project
530:41 - [Music]
530:57 - and let's name our project can cancel
530:59 - download async operations uwp
531:18 - let's set up a basic UI user interface
531:22 - so let's start by dragging a button onto
531:25 - our designer surface
531:33 - let's name this button BTN cancel
531:35 - download and let's label this button
531:37 - cancel download let's drag another
531:40 - button onto the designer surface just
531:42 - below the button we have just added
531:45 - let's name this button BTN download
531:48 - content let's label this button download
531:50 - content let's drag a list view control
531:53 - onto the designer surface
531:56 - and position it so that the contents of
531:58 - the list view control will appear to the
532:00 - right of our buttons
532:02 - let's name this list view control
532:04 - lvw output
532:07 - so let's access the main
532:10 - page.examl.cs file to add the relevant
532:13 - functionality for our UI
532:15 - firstly let's ensure that we include all
532:18 - the relevant using directives let's copy
532:21 - them from the relevant section of the
532:24 - relevant Microsoft web page and paste
532:26 - them into our code editor like this
532:58 - okay
533:00 - let's then copy and paste the relevant
533:02 - Fields like this
533:16 - these fields contain an object reference
533:19 - variable of type cancellation token
533:22 - source that will be used to cancel the
533:24 - relevant asynchronous tasks
533:26 - a collection of URLs of type I
533:29 - enumerable that will store the addresses
533:31 - of the web pages that will be downloaded
533:33 - by the relevant asynchronous operations
533:35 - and an object reference variable of type
533:38 - HTTP client that will handle
533:42 - the connection to the relevant web pages
533:44 - and also handle the download
533:47 - functionality so in our application
533:50 - these fields don't need to be static so
533:52 - let's remove the static keywords
534:02 - let's read the explanation provided
534:04 - under the relevant code fragment
534:05 - containing the fields we have just
534:07 - copied
534:09 - the cancellation token source is used to
534:13 - Signal a requested cancellation to a
534:16 - cancellation token
534:17 - the HTTP client exposes the ability to
534:21 - send HTTP requests and receive HTTP
534:25 - responses the S underscore URL list
534:28 - holds all the URLs that the application
534:31 - plans to process
534:33 - so the next section of the Microsoft web
534:36 - page
534:36 - there's an explanation of the code
534:39 - within the entry point of the
534:40 - application I.E the main method
534:44 - as discussed the Microsoft code example
534:47 - is based on the.net core console project
534:49 - template
534:51 - we are basing our application on the uwp
534:54 - universal windows platform project
534:56 - template so our code implementation will
534:59 - be slightly different
535:00 - so the main difference between our code
535:02 - and the Microsoft example is that the
535:05 - Microsoft example is implemented so that
535:07 - when a user presses the enter key this
535:10 - action will trigger the cancellation of
535:12 - the relevant operations I.E the
535:14 - operations responsible for downloading
535:16 - the contents of a collection of web
535:18 - pages
535:19 - the uwp project template makes our code
535:22 - implementation simpler because we can
535:24 - leverage a button-click event handler
535:26 - for this purpose
535:28 - so in this Microsoft example the tasks
535:31 - responsible for downloading the content
535:33 - and outputting the relevant information
535:35 - about the content are invoked through a
535:38 - call to the method named sum page sizes
535:41 - async the cancellation functionality is
535:44 - handled in the code above this method
535:46 - call
535:47 - the method is implemented through a
535:49 - Lambda expression here
535:51 - code is implemented here using the when
535:54 - any method the when any method basically
535:57 - accepts an array of task objects
536:00 - so the sum page sizes async method
536:03 - returns a task
536:05 - and the relevant Lambda expression
536:06 - responsible for the cancellation
536:08 - functionality is run using the task.run
536:12 - method which also returns a task object
536:15 - then an array containing a task object
536:18 - encapsulating the cancellation operation
536:20 - as discussed this is implemented as an
536:23 - asynchronous method in the form of a
536:25 - Lambda expression and the download
536:27 - operation which is implemented as a
536:29 - named method are passed into the when
536:32 - any method the task dot when any method
536:35 - will complete when any one of the
536:39 - operations passed within the relevant
536:41 - array argument completes
536:43 - this means that if the user presses the
536:45 - enter key before the download operation
536:47 - IE which is invoked by the call to the
536:50 - sum page sizes async method completes
536:53 - this will effectively cancel the
536:55 - asynchronous web page download
536:56 - operations and Associated functionality
536:59 - for example summing up the number of
537:01 - bytes downloaded Etc
537:03 - so we use the when all method in the
537:06 - previous video which allowed us to run a
537:09 - collection of tasks in parallel without
537:11 - blocking the main thread
537:13 - the when any method is similar but the
537:16 - differences that the when all method
537:18 - completes when all the relevant
537:20 - operations have completed
537:22 - the when any method completes when any
537:25 - one of the relevant operations have
537:27 - completed like the when all method the
537:30 - when any method does not block the main
537:32 - thread
537:34 - so this means that in the context of the
537:36 - Microsoft example here if the user
537:38 - presses the enter key before the
537:40 - operations invoked by the sum page sizes
537:43 - async method complete this will result
537:46 - in the downloading operations being
537:48 - canceled the cancellation operation will
537:51 - complete before the download operations
537:53 - complete resulting in the download
537:55 - operations being canceled
537:59 - so we are going to implement similar
538:01 - code within our example the differences
538:04 - that we'll Implement a cancellation
538:06 - button to enable the user to cancel the
538:08 - download operations by pressing the
538:10 - cancellation button rather than
538:12 - implementing code to allow the user to
538:14 - press the enter key for this purpose
538:16 - with our uwp project we have the benefit
538:19 - of a rich user interface
538:22 - so let's go to our code behind class I.E
538:25 - the
538:26 - mainpage.xaml.cis file
538:28 - and write a private method that will
538:30 - encapsulate the functionality to add a
538:32 - list item to our list view control I.E
538:35 - the control we have named lvw output
538:38 - we have already written a private method
538:40 - encapsulating this functionality in our
538:43 - previous example so let's navigate to
538:45 - the relevant GitHub repository and copy
538:48 - this private method this URL has been
538:50 - included Below in the description
538:53 - so here we can see the relevant method
538:55 - named add list item let's copy this
538:57 - method to our clipboards
539:07 - and appropriately paste this method
539:09 - within our main
539:11 - page.xaml.cs file
539:14 - so we can now write the codes to handle
539:16 - the button click events
539:18 - let's start with the download
539:20 - functionality first let's create two
539:22 - private methods that are responsible for
539:25 - downloading the relevant content
539:27 - calculating the size of the relevant
539:29 - content and outputting Status
539:31 - information to the user regarding the
539:33 - relevant downloaded content so in the
539:36 - Microsoft docs webpage let's look at the
539:38 - section entitled create the asynchronous
539:41 - some pages sizes method
539:44 - let's copy this method and appropriately
539:46 - paste the method within our
539:49 - mainpage.xaml.cs file
539:51 - in our example this method does not need
539:54 - to be static so let's remove the static
539:56 - keyword from the method definition of
539:59 - the sum page sizes async method and
540:01 - let's include the private access
540:03 - modifier within the sum page sizes async
540:06 - methods method definition
540:08 - the next thing we need to modify in our
540:10 - example for the sum page sizes async
540:13 - method is where the code writes text to
540:16 - the console screen our output will be
540:19 - added to the list view control that we
540:21 - named lvw output
540:23 - so let's replace the console.write
540:25 - methods with a call to our private
540:28 - method named add list item we can remove
540:31 - the backslash n character sequences from
540:34 - the relevant text because we don't need
540:36 - a line feed
540:37 - due to the fact that we are adding each
540:40 - item of text as its own item within the
540:43 - list view control let's read the brief
540:45 - description of this method provided
540:47 - within the relevant Microsoft web page
540:53 - the method starts by instantiating the
540:56 - starting of a stopwatch
540:59 - it then Loops through each URL
541:01 - in the S underscore URL list and calls
541:05 - process URL async
541:08 - with each iteration the S underscore CTS
541:12 - dot token is passed into the process URL
541:16 - async method and the code returns a
541:19 - generic task where T result is an
541:22 - integer So within the relevant Microsoft
541:25 - web page let's look at the section
541:27 - entitled add process method
541:31 - so the first line in this section reads
541:34 - adds the following process URL async
541:37 - method below the sum page sizes async
541:41 - method
541:42 - so let's copy the process URL async
541:45 - method to our clipboards like this and
541:48 - appropriately paste it within the main
541:50 - page.xaml dot CS file like this
541:54 - let's remove the static keyword from the
541:57 - process URL async methods method
542:00 - definition let's include the private
542:02 - access modifier within the process URL
542:06 - async methods method definition
542:08 - let's replace the console.write method
542:11 - with the add list item method like this
542:15 - and if you'll remember before we started
542:17 - implementing this example I spoke about
542:19 - one of the prerequisites for creating
542:22 - this code example the prerequisite being
542:25 - the installation of the.net 5 SDK
542:28 - so this is the only line of code that
542:30 - doesn't work if we do not have the.net 5
542:33 - SDK installed
542:36 - and if we are running this example using
542:38 - the.net core 3.1 runtime
542:41 - so if you're running this project using
542:44 - the.net core 3.1 runtime simply remove
542:47 - the argument named token from the line
542:50 - of code that calls the response.content
542:53 - dot read as byte array async method
542:57 - so let me just say that it is preferable
542:59 - to pass in the token argument to this
543:02 - method but if you don't wish to install
543:04 - the.net 5 SDK at this time we are still
543:08 - able to run The Code by removing the
543:11 - token argument
543:12 - this is not ideal but we are still able
543:15 - to gain an understanding of the
543:17 - cancellation token Source object and how
543:20 - we are able to cancel one or more
543:23 - asynchronous operations using one cancel
543:26 - token Source object
543:30 - let's read the explanation of this
543:32 - method in the relevant Microsoft web
543:34 - page
543:36 - for any given URL the method will use
543:40 - the client instance provided to get the
543:44 - response as a byte array
543:46 - the cancellation token instance is
543:48 - passed into the HTTP client dot get
543:52 - async and HTTP content dot read as byte
543:56 - array async methods
543:58 - the token is used to register for
544:00 - requested cancellation
544:03 - the length is returned after the URL and
544:06 - length is written to the console
544:09 - so obviously where it says the URL and
544:12 - length is written to the console in our
544:14 - example we are instead adding the
544:17 - relevant text to our list view control
544:20 - okay so let's implement the code for the
544:23 - button that invokes the download
544:24 - operations let's go to our designer
544:27 - surface and double click on the button
544:29 - labeled download content
544:33 - let's implement the code that calls the
544:35 - awaitable some page sizes async method
544:38 - to perform the downloading of the
544:40 - relevant content the calculation of the
544:43 - size of the content as well as the
544:45 - outputting of the relevant information
544:47 - about the content to our list view
544:49 - control
544:52 - so in order to call this method
544:54 - asynchronously we need to include the
544:56 - await operator we also need to include
544:59 - the async modifier within the method
545:01 - definition of the relevant button-click
545:03 - event handler
545:05 - let's implement the cancellation
545:06 - functionality
545:08 - let's go to our designer surface and
545:10 - double click on the button marked cancel
545:12 - download
545:13 - within the relevant button click event
545:15 - handler let's implement the cancellation
545:17 - functionality
545:19 - to add the operation we can simply call
545:22 - the cancel method on the relevant
545:24 - cancellation token Source object like
545:26 - this
545:33 - okay let's run the code
545:50 - firstly let's demonstrate what happens
545:52 - when we click the download content
545:54 - button
545:55 - so let's allow the operations to
545:58 - complete so we can see what happens when
546:00 - we don't cancel the operations
546:03 - we can see that the appropriate output
546:05 - is presented to us as each operation
546:08 - completes
546:09 - when the content for a particular web
546:11 - page has been downloaded the web page
546:14 - URL followed by the number of bytes
546:17 - downloaded is presented on our list view
546:19 - control
546:21 - and then once all the operations have
546:23 - completed we are presented with the
546:25 - total number of bytes downloaded as well
546:28 - as the time that has elapsed between the
546:30 - time when we started to download the
546:33 - content and the time that the relevant
546:35 - download operations completed great
546:44 - so let's run the code again
546:51 - let's click the download content button
546:55 - and we are presented with the relevant
546:57 - output in our list view control as
546:59 - expected
547:00 - right let's see what happens when we
547:03 - press the cancel button
547:06 - and a runtime error occurs
547:09 - so in order to handle the cancellation
547:11 - operation appropriately we need to
547:13 - handle a particular type of exception
547:15 - so when the cancel method is called
547:18 - while the asynchronous operations are
547:20 - running an exception of type task
547:22 - canceled exception is thrown so we can
547:26 - simply include our code that calls the
547:28 - sum page sizes async method within try
547:32 - catch code like this
547:34 - and handle the task canceled exception
547:37 - appropriately so we could access the
547:40 - throne exception object to access
547:42 - details about the exception but in this
547:45 - case we only want to Output status
547:47 - information to the user that the
547:49 - operations have been canceled
547:51 - so let's do this let's simply add the
547:53 - literal text download operations
547:55 - canceled
547:56 - so remember we are passing a token
547:59 - object as an argument to the get async
548:02 - method here in the process URL async
548:05 - method the process URL async method is
548:08 - called within a loop from within the sum
548:12 - page sizes async method this token
548:15 - object allows us to trigger a
548:17 - cancellation of all running asynchronous
548:20 - tasks that reference this token object
548:24 - when the cancel method is invoked on the
548:26 - relevant cancellation token Source
548:29 - object an exception of type task
548:31 - canceled exception is thrown
548:33 - and we can appropriately handle this
548:35 - exception in our code
548:37 - right let's run the code
548:42 - so let's click the download content
548:44 - button
548:45 - and we are presented with the relevant
548:47 - output as expected
548:49 - so let's see what happens when we cancel
548:51 - these operations
548:53 - and there we have it the task canceled
548:56 - exception is thrown when the cancel
548:58 - method on the cancellation token Source
549:01 - object is invoked and we are handling
549:03 - the throne exception in our custom way
549:06 - I.E in a way that suits our application
549:09 - so we can see the output text download
549:13 - operations canceled which is an expected
549:15 - result
549:16 - okay so we are also able to
549:18 - automatically cancel the operations
549:20 - after a predefined duration of time
549:24 - so let's say we wanted our download
549:25 - operations to be canceled if they
549:28 - haven't completed within a specific time
549:30 - duration
549:32 - the way we can do this is by calling the
549:34 - cancel after method on the relevant
549:36 - cancellation token Source object
549:39 - we can call this method before the
549:41 - relevant operations are invoked like
549:43 - this
549:44 - we need to pass in the duration of time
549:47 - in milliseconds to the cancel after
549:49 - method this number represents the time
549:52 - elapsed from the moment the relevant
549:54 - operations are invoked so let's specify
549:58 - 3500 milliseconds or three and a half
550:01 - seconds
550:05 - let's run the code
550:13 - and you can see that after three and a
550:15 - half seconds the relevant operations are
550:18 - automatically canceled
550:20 - so you can see how this functionality
550:22 - can be useful when we want to
550:24 - automatically cancel an operation or
550:27 - operations after a specified amount of
550:30 - time
550:31 - great
550:33 - for further information about
550:35 - asynchronous programming in c-sharp I
550:37 - recommend reading relevant content
550:39 - provided in the Microsoft Docs
550:43 - foreign
550:48 - so to summarize in this video series we
550:52 - looked at Microsoft's recommended
550:54 - approach for implementing code to run an
550:56 - operation or multiple operations
550:58 - asynchronously namely the task-based
551:01 - asynchronous pattern
551:03 - we discussed that running certain
551:05 - relatively long-running CPU blocking
551:07 - operations can adversely affect the
551:10 - performance of our applications
551:12 - to alleviate these negative effects on
551:15 - user experience ux we can run these
551:18 - relatively long-running CPU blocking
551:20 - operations asynchronously
551:23 - in order to implement the asynchronous
551:25 - code correctly we first need to know the
551:27 - nature of the operations that we wish to
551:31 - run asynchronously
551:32 - we need to first ask the question is the
551:35 - relevant operation a cpu-bound operation
551:38 - or is the relevant operation an i o
551:41 - bound operation
551:43 - in the first part of this video series
551:45 - we focused on running i o bound
551:47 - operations asynchronously using the
551:50 - async modifier the await operator and
551:53 - the task or generic task object
551:56 - in the second part of this video series
551:58 - we looked at running CPU bound
552:00 - operations asynchronously using the
552:03 - task.run method to run operations on
552:06 - background threads
552:08 - we also looked at the task.weight all
552:11 - method in the third part of this video
552:13 - series we looked at Best Practices when
552:16 - implementing operations in c-sharp to
552:18 - run asynchronously we also looked at the
552:21 - task dot when all method and how it
552:24 - differs from the task.weight all method
552:27 - in this video which is the final part of
552:29 - this video series we looked at how we
552:32 - can provide the user with the ability to
552:34 - cancel one or more running asynchronous
552:36 - operations
552:38 - before the relevant operations have
552:39 - completed using one cancellation token
552:42 - Source object we also demonstrated how
552:45 - we can automate the cancellation of
552:48 - running asynchronous operations after a
552:51 - specified amount of time by calling the
552:53 - cancel after method on the relevant
552:55 - cancellation token Source object
552:59 - I hope you have enjoyed the final video
553:01 - in this video series on asynchronous
553:04 - programming in c sharp the next Topic in
553:07 - this Advanced c-sharp course will be
553:09 - link language integrated query
553:12 - for more content on advanced c-sharp
553:14 - concepts and much more please consider
553:17 - subscribing and please ring the bell so
553:19 - that you'll be notified of future
553:20 - content released from this channel
553:24 - if you feel you've gained value from
553:25 - this video please hit the like button it
553:28 - will be greatly appreciated please feel
553:30 - free to share any videos released from
553:33 - this Channel with anyone you feel May
553:35 - benefit from their content I really
553:37 - enjoy reading your comments so please
553:38 - feel free to share your thoughts with me
553:40 - in the comment section as always the
553:42 - code in this tutorial can be downloaded
553:44 - from GitHub a link to the relevant
553:47 - GitHub repository has been included
553:49 - Below in the description
553:52 - foreign
553:55 - [Music]
554:02 - to the first part of a video series on
554:05 - link
554:06 - this video is also the first part of the
554:09 - seventh tutorial in an advanced c-sharp
554:11 - course later in this tutorial we'll look
554:14 - at a code example to help with our
554:16 - understanding of Link but let's first
554:18 - answer the question what is link
554:21 - link stands for language integrated
554:23 - query
554:24 - link is defined in the Microsoft docs as
554:27 - the name for a set of Technologies based
554:30 - on the integration of query capabilities
554:33 - directly into the c-sharp language
554:36 - link was originally released as a major
554:38 - part of NET Framework 3.5 in 2007
554:43 - here is a paragraph
554:45 - from the Microsoft docs which provides
554:48 - an excellent overview of what link is
554:51 - language integrated query link is the
554:54 - name for a set of Technologies based on
554:56 - the integration of query capabilities
554:58 - directly into the c-sharp language
555:00 - traditionally
555:03 - queries against data are expressed as
555:06 - simple strings without type checking at
555:09 - compile time or intellisense support
555:12 - furthermore you have to learn a
555:14 - different query language for each type
555:16 - of data source SQL databases
555:20 - XML documents various web services and
555:24 - so on
555:25 - with link a query is a first class
555:28 - language construct just like classes
555:30 - methods events
555:32 - you write queries against strongly typed
555:35 - collections of objects by using language
555:38 - keywords and familiar operators
555:41 - the link family of Technologies provides
555:44 - a consistent query experience for
555:47 - objects link to objects relational
555:50 - databases linked to SQL and XML link to
555:54 - XML
555:55 - note that you can write link queries in
555:58 - c-sharp for SQL Server databases XML
556:01 - documents ado.net datasets and any
556:04 - collection of objects that support the I
556:07 - enumerable interface or the generic I
556:09 - enumerable interface
556:12 - so for example you can perform link
556:13 - queries against collection types like an
556:16 - array generic list generic dictionary
556:19 - generic Q
556:20 - generic stack Etc
556:23 - basically any collection type that
556:25 - implements the I enumerable interface or
556:28 - the generic I enumerable interface
556:32 - link support is also provided by Third
556:35 - parties for many web services and other
556:37 - database implementations
556:40 - you can create custom providers using I
556:42 - queryable
556:44 - custom providers will not be discussed
556:46 - in detail in this video series
556:49 - if you would like to learn more about
556:51 - implementing your own custom provider
556:53 - please navigate to this URL
556:56 - in this video series we'll primarily
556:58 - focus on link to objects and link to
557:01 - entities
557:03 - link to entities provides language
557:05 - integrated query link support that
557:08 - enables developers to write queries
557:10 - Against The Entity framework conceptual
557:13 - model using either Visual Basic or
557:15 - visual c-sharp
557:17 - so Entity framework core is a modern
557:19 - object database mapper for net it
557:22 - supports link queries change tracking
557:25 - updates and schema migrations
557:29 - Entity framework core or EF core can be
557:32 - used to work with many databases
557:34 - including SQL databases on-premises and
557:37 - Azure sqlite MySQL postgres and Azure
557:42 - Cosmos DB
557:44 - in this video series we won't look at
557:47 - the link to data set or link to XML
557:49 - please navigate to this URL for more
557:51 - information on linked dataset and please
557:54 - navigate to this URL for more
557:56 - information on linked to XML
558:05 - to get started with link in this video
558:07 - we'll focus on link to objects so that
558:10 - we can first get a basic idea of what
558:12 - the implementation of Link looks like in
558:14 - code and how it can be used for querying
558:17 - c-sharp collections
558:20 - so in the spirit of cross-platform
558:22 - Development I've decided to demonstrate
558:24 - this code example on my Mac platform
558:27 - using visual studio 2019 for Mac
558:29 - Community Edition
558:31 - if you have a Mac platform and wish to
558:34 - follow along on your Mac and you don't
558:36 - yet have Visual Studio installed
558:39 - you are able to download and install
558:40 - Visual Studio Community Edition 2019
558:43 - free of charge from this location all
558:46 - links mentioned in this video are
558:48 - available Below in the description
558:52 - if you are using a Windows OS please
558:55 - don't let the fact that I'm using a Mac
558:57 - platform put you off following along
558:59 - with this tutorial in terms of the code
559:02 - example that we'll create in this video
559:04 - the coding experience using visual
559:07 - studio for Mac is almost exactly the
559:09 - same as the coding experience using
559:12 - visual Studio for Windows so this should
559:14 - not be a barrier for a learner to follow
559:16 - along with this demonstration
559:18 - if you haven't yet installed Visual
559:20 - Studio 2019 on your windows platform
559:23 - please view a video created by this
559:26 - channel which provides a guide to
559:28 - installing Visual Studio 2019 Community
559:30 - Edition free of charge
559:34 - so firstly let's create a.net core
559:36 - console application
559:50 - let's name this project the pretend
559:53 - company application
559:58 - before we write calling client code in
560:00 - the main method we are going to add two
560:03 - standard Library projects let's first
560:06 - add a standard Library project named TCP
560:08 - data
560:14 - let's then add another standard Library
560:16 - project named TCP extensions
560:32 - so let's now go to our project that we
560:35 - named TCP data let's delete the class
560:37 - that has been automatically generated
560:39 - for the TCP data project
560:46 - let's add a new class named employee
560:52 - let's add six Auto implemented
560:54 - properties to the employee class ID as
560:58 - int first name as string last name as
561:01 - string annual salary as decimal is
561:04 - manager as Boolean and lastly Department
561:07 - ID as int
561:14 - let's add another class to the TCP data
561:17 - project
561:18 - let's name this class Department
561:21 - let's add three Auto implemented
561:24 - properties to our department class
561:26 - ID as int short name as string and long
561:30 - name as string let's add a class named
561:33 - data to our TCP data project let's make
561:36 - this class a static class
561:39 - so let's add two public static methods
561:42 - to the data class
561:44 - let's first create a static method named
561:46 - get employees which returns a generic
561:49 - list strongly typed as employee let's
561:53 - ensure
561:54 - that we include the appropriate using
561:56 - directive for the use of generic list
561:58 - objects at the top of our code editor
562:02 - so let's include a using directive to
562:04 - the
562:06 - system.collections.generic namespace
562:07 - like this
562:19 - let's write the code to add some made up
562:22 - employee records to a generic list that
562:25 - is strongly typed with the user defined
562:27 - type employee
562:32 - foreign
563:56 - foreign let's write code to return the
564:00 - list of employee records to the calling
564:02 - client code
564:31 - let's add another static method and
564:33 - let's name this method get departments
564:40 - this method also returns a generic list
564:42 - object but this generic list object is
564:45 - strongly typed as Department
564:47 - let's write the codes to add some made
564:50 - up Department Records to a generic list
564:52 - that is strongly typed with the
564:54 - user-defined type Department
564:57 - foreign
565:17 - let's write code to return the list of
565:19 - Department Records to the calling client
565:22 - code
565:32 - so as you can see the get employees
565:34 - method returns a list of employee
565:36 - records and the get departments method
565:39 - returns a list of Department Records
565:43 - so in order to gain an understanding for
565:45 - how Link Works let's ensure that we
565:48 - properly understand two fundamental
565:50 - concepts I.E the concept of extension
565:53 - methods and the concept of Lambda
565:55 - expressions
565:56 - so let's go to our TCP extensions
565:59 - project
566:00 - let's delete the class that was
566:02 - auto-generated by Visual Studio when we
566:04 - created the project
566:06 - let's add a class named extension
566:09 - so in order for our extension method to
566:11 - work we must make the extension class a
566:14 - static class
566:16 - so we are going to add a method named
566:18 - filter
566:19 - the idea here is we want a way where we
566:22 - can extend the functionality of any
566:24 - generic list that is strongly typed with
566:27 - any c-sharp data type including
566:29 - user-defined types
566:30 - we can achieve this by creating our own
566:33 - extension method so for example if we
566:36 - want to filter employee records by
566:38 - criteria that we are able to specify
566:40 - through a Lambda expression on a generic
566:43 - list that is strongly typed as the
566:45 - employee
566:46 - we can do this through our filter
566:48 - extension method this will be
566:50 - demonstrated in the calling client code
566:52 - in a bit
566:54 - so how do we create our own custom
566:56 - extension method
566:58 - so I'll first create the method
567:00 - signature for the filter extension
567:01 - method
567:03 - first notice that our method like the
567:05 - class in which it resides must be static
567:09 - which is achieved by including the
567:11 - static keyword
567:13 - in the relevant extension methods method
567:15 - signature
567:16 - so if we look at the first parameter in
567:19 - the filter methods method signature we
567:21 - can see
567:22 - that we are using for this keyword
567:24 - preceding the data type of the first
567:27 - parameter which is a generic list of
567:30 - type t
567:31 - but this keyword in this context
567:33 - indicates to the compiler that the
567:35 - relevant method can be called on an
567:37 - object of the data type of the relevant
567:39 - parameter in this example that is a
567:42 - generic list which contains a type T
567:44 - placeholder as we know from the video
567:47 - series on c-sharp generics a developer
567:50 - is able to pass a data type argument to
567:52 - the parameter of type T which can be any
567:55 - c-sharp data type including user-defined
567:58 - types
568:00 - the data type specified will be chosen
568:03 - depending on the requirement that needs
568:04 - to be met by The Calling client code
568:07 - we'll demonstrate the consumption of
568:09 - client-side code for the filter
568:10 - extension method in a bit
568:14 - so let's look at the second parameter
568:16 - which is of the delegate type func for
568:19 - more information about the funk delegate
568:21 - type please view a video created by this
568:23 - channel on this topic a link to this
568:25 - video is available Below in the
568:27 - description
568:28 - the first data type parameter passed to
568:31 - the funk delegate type represents the
568:34 - first data type of the first parameter
568:35 - of the method referenced by the relevant
568:38 - argument passed into this parameter
568:41 - the last parameter in the funk delegate
568:43 - type definition is the return type of
568:46 - the method referenced by the argument
568:48 - passed into this parameter so the first
568:51 - parameter passed into the funk delegate
568:53 - is of type T and the second parameter is
568:55 - of type bull
568:57 - note that a predicate delegate type can
569:00 - be used to define method definitions for
569:02 - a method that returns a Boolean value
569:05 - so we could replace the func delegate
569:07 - type with a predicate delegate type
569:09 - let's use the funk delegate type but
569:12 - please note that we could also achieve
569:14 - the same end using the predicate
569:16 - delegate type
569:18 - and as you can see this method will
569:20 - return a list of objects of type t to
569:22 - the calling client code
569:25 - so let's complete the logic for this
569:27 - method let's implement the code for the
569:29 - filter method
569:32 - so basically we are looping through the
569:33 - list on which the filter extension
569:36 - method is invoked we are then adding its
569:38 - elements to a new generic list also of
569:41 - type T whether or not we add this list
569:44 - item is based on the Boolean value
569:47 - returned by a method reference passed
569:50 - into the second parameter of the filter
569:52 - method so the relevant method reference
569:54 - is stored in the argument passed to the
569:57 - parameter named funk
569:59 - as you can see the method that the
570:01 - variable named func references accepts
570:04 - an argument of type t
570:07 - so we are passing in each item stored in
570:10 - the calling clients list
570:12 - which is the generic list on which
570:14 - calling client code will invoke the
570:16 - filter extension method
570:18 - if the method that the func variable
570:20 - references returns true the items stored
570:23 - in the iterated list is added to a new
570:25 - list
570:27 - we then return the new list containing
570:29 - the filtered items to the calling client
570:31 - code
570:32 - so this effectively means that the
570:34 - calling client code is able to use our
570:37 - filter method to filter any generic list
570:39 - based on a method created in the calling
570:42 - client code this method created in the
570:44 - calling client code will contain the
570:46 - logic for filtering the relevant generic
570:49 - list
570:49 - a reference to this method will be
570:52 - passed into the second parameter of our
570:54 - filter extension method and must adhere
570:56 - to the method definition represented in
570:59 - the second parameter of the filter
571:00 - method I.E the definition represented in
571:04 - the func delegate type
571:06 - so we are now going to implement the
571:08 - calling client code and you'll see that
571:11 - the method passed into the second
571:12 - parameter of our filter method will be
571:15 - an anonymous method I.E a method that is
571:18 - not named this method will be expressed
571:20 - as a Lambda expression
571:23 - we'll now see how we are able to filter
571:26 - a generic list using our filter
571:28 - extension method through calling client
571:30 - code in the main method of our
571:32 - application
571:35 - right so let's go to the.net core
571:37 - console project and write the calling
571:39 - client code in our main method
571:44 - firstly let's reference our two standard
571:46 - Library projects from our.net core
571:48 - console project
571:51 - so let's right click the dependencies
571:53 - node in the.net core console project and
571:56 - tick TCP data as well as TCP extensions
572:01 - so let's test our filter extension
572:03 - method in a bit I'll further elucidate
572:07 - why it is important to understand
572:08 - extension methods and Lambda expressions
572:11 - with regards to link
572:13 - through the magic of how extension
572:15 - methods work in c-sharp we should be
572:18 - able to call the extension method on any
572:20 - generic list object
572:22 - so let's define a generic list that is
572:25 - strongly typed as the employee user
572:27 - defines type
572:29 - so we have a red squiggly line under our
572:31 - generic list type definition so to fix
572:34 - this we need to include a directive at
572:37 - the top of our code to the
572:39 - system.collections.generic namespace
572:42 - we can see that there is a red squiggly
572:44 - line under the code that strongly types
572:47 - our generic list as the user's defined
572:49 - type employee
572:51 - so to fix this let's include a directive
572:53 - at the top of our code to the TCP data
572:56 - namespace
572:57 - great
572:59 - so through the magic of extension
573:01 - methods we should see the filter method
573:03 - appear in the intellisense drop-down
573:05 - list when we add a DOT after the
573:08 - employee list variable
573:14 - okay so why are we not seeing the filter
573:17 - method appearing in our intellisense
573:19 - drop-down list
573:21 - the reason for this is because we
573:23 - haven't included a using directive to
573:26 - the appropriate namespace so let's
573:28 - include a using directive at the top of
573:30 - our code to the appropriate namespace IE
573:33 - TCP extensions
573:35 - so now if we add a DOT immediately after
573:38 - the employee list variable the magic of
573:41 - extension methods is revealed to us and
573:43 - we can see our filter method in the
573:46 - intellisense drop-down list
573:48 - so note that when we Open brackets to
573:51 - pass in appropriate arguments to the
573:53 - filter method we see that only one
573:55 - parameter is required this parameter was
573:58 - the second parameter we defined for this
574:01 - method so why is the first parameter in
574:04 - the filter method not listed when we
574:05 - open the brackets in this way
574:07 - well the answer to that question is this
574:10 - is how extension methods work
574:12 - the consumer of the code IE the calling
574:14 - client code does not need to pass in the
574:17 - first parameter this is automatically
574:19 - handled behind the scenes as it were
574:22 - by default the first parameter is the
574:25 - object on which the relevant extension
574:26 - method is invoked
574:28 - so in this case the list of employees
574:31 - stored in the employee list variable
574:34 - is passed into the filter method into
574:36 - this parameter automatically
574:39 - so if we look at the filter extension
574:41 - method we can see that this keyword
574:43 - precedes the definition of the first
574:46 - parameter
574:47 - that this keyword in this context
574:49 - is telling the c-sharp compiler that the
574:52 - argument passed into this parameter is
574:55 - the object on which the relevant
574:57 - extension method is invoked
575:00 - so we have access to the argument passed
575:03 - into the first parameter automatically
575:06 - okay so the second parameter
575:09 - accepts a delegate object that points to
575:12 - a method that needs to be created on the
575:15 - calling client so this method that we'll
575:17 - create essentially tells the filter
575:19 - method how we want our list filtered
575:23 - so we are able to Define this method and
575:26 - the calling client code through the use
575:27 - of a Lambda expression
575:30 - a Lambda expression is a concise way to
575:33 - represent an anonymous method if we look
575:35 - at the definition of the relevant
575:37 - delegate parameter we need to define a
575:40 - method that accepts an argument of type
575:43 - T and returns a Boolean value
575:46 - so the c-sharp compiler has enough
575:48 - information to infer that the intended
575:51 - type for type T is employee in this
575:54 - context we are calling the filter
575:56 - extension method on a strongly typed
575:58 - generic list the generic list is
576:01 - strongly typed with the employee user
576:03 - defined type
576:05 - so say we want to filter our employee
576:07 - list based on the value of each relevant
576:10 - employee items is manager property
576:13 - we want to filter the list where we only
576:16 - want to return those employee records
576:19 - where is manager is true
576:21 - so we want to return all the records
576:23 - from our list where the relevant
576:25 - employees are managers
576:29 - so to achieve this we can pass in this
576:32 - Lambda expression
576:34 - here we are telling the filter method
576:36 - how we want our list filtered
576:41 - let's write code to print the results to
576:43 - the console screen
577:08 - right let's run the code
577:20 - okay so we have no data
577:23 - ah we of course need to populate our
577:26 - employee list with data so let's assign
577:29 - the value returned from data.get
577:31 - employees to the employees list variable
577:46 - right let's run the code
577:51 - great and you can see that only the
577:54 - employee records where the relevant is
577:56 - manager property value is set to true or
577:59 - returned to the calling client code
578:00 - great
578:02 - and we can of course inject the converse
578:05 - of this logic into our filter method
578:07 - through the relevant Lambda expression
578:09 - like this
578:11 - so we are now saying we only want to
578:13 - bring back our employees who are not
578:15 - managers let's run the code
578:20 - great
578:28 - and for good measure let's modify our
578:31 - Lambda expression so that the filter
578:33 - method only returns employees that earn
578:36 - less than 50 000 a year
578:45 - great
578:46 - and because we have used generics for
578:48 - our filter method we can call the filter
578:50 - method on a list of various c-sharp
578:53 - types including user-defined types so
578:56 - let's prove this and call our filter
578:58 - extension method on a list of
579:00 - departments
579:02 - foreign
579:11 - let's filter the Departments based on
579:13 - the Department's short name so let's
579:16 - bring back the finance department and
579:18 - the human resources department
579:54 - great
579:59 - let's bring back only those departments
580:01 - with IDs greater than one
580:04 - so the point of this is to show you the
580:07 - flexibility that the combination of
580:09 - extension methods and Lambda Expressions
580:11 - create when writing the calling client
580:13 - code
580:15 - the combination of extension methods and
580:17 - Lambda Expressions not only provide this
580:19 - flexibility but at the same time ensure
580:22 - that the calling client code is clean
580:23 - and concise
580:26 - once we understand how extension methods
580:28 - and Lambda Expressions work they are
580:31 - incredibly powerful tools
580:33 - so how do extension methods and Lambda
580:36 - Expressions work in relation to the
580:38 - topic of this video link language
580:40 - integrated query
580:42 - extension methods and Lambda expressions
580:45 - are fundamental to how link is
580:47 - implemented in C sharp
580:49 - the innumerable class and the queryable
580:52 - class are two static classes that
580:54 - contain extension methods the enumerable
580:56 - class and the queryable class are both
580:58 - members of the system.link namespace
581:03 - so to gain access to the extension
581:05 - methods provided through link we can
581:07 - simply include a using directive to the
581:10 - system.link namespace
581:13 - without including a using directive to
581:16 - the system.link namespace you can see
581:18 - that we are not able to access the where
581:20 - extension method provided by link to
581:23 - perform our filtering operation on a
581:26 - collection that implements the I
581:27 - enumerable interface
581:30 - so let's include the system.link
581:32 - namespace
581:36 - we now have access to Links where
581:38 - extension method so we can now replace
581:41 - our custom filter extension method with
581:43 - the where link extension method like
581:45 - this
581:47 - we don't need to create our own filter
581:49 - extension methods to perform such
581:51 - queries on our data link has got us
581:53 - covered for this
582:07 - foreign
582:31 - link also provides us with a SQL like
582:34 - query syntax
582:35 - so for example if we wanted to produce a
582:38 - query result by joining selected fields
582:41 - from data selected from our collection
582:43 - of employee objects with selected fields
582:47 - or field in this case from data in our
582:50 - collection of Department objects we can
582:53 - use Link query syntax to perform our
582:55 - inner join operation on these two
582:57 - collections of data like this
583:01 - and the link query we want to include
583:03 - the department long name field so that
583:06 - we can have a descriptive name for our
583:09 - department in our results set rather
583:11 - than displaying a result that only
583:14 - contains the department ID which is
583:16 - available in the employee type so we can
583:19 - achieve this result by using the join
583:22 - clause in a link query to perform our
583:24 - inner join on our collection of employee
583:26 - objects with our collection of
583:28 - Department objects we have the
583:30 - department ID property in the employee
583:32 - type so we can join using this
583:35 - department ID property in the employee
583:37 - type to the ID property which is a
583:40 - member of the department type
583:42 - so say we were to write the equivalent
583:45 - query using transact SQL against the SQL
583:48 - Server database that contained an
583:51 - employee table with the same data schema
583:53 - as our employee type and a department
583:56 - table that contains the same schema as
583:59 - our department type the transact SQL
584:01 - query syntax would look something like
584:03 - this
584:04 - we are using an inner join to join data
584:07 - in an employee table with data in a
584:09 - department table
584:10 - we are able to make the join because the
584:13 - employee table contains the department
584:14 - ID
584:15 - which can be joined in our query the ID
584:18 - of the department table
584:21 - so you can see the similarities and
584:22 - syntax between the transact SQL syntax
584:25 - and the link query syntax
584:28 - the link query is dealing with objects
584:31 - encapsulating the employee and
584:33 - Department Records
584:34 - the employee list collection is like the
584:37 - employee table and the department list
584:39 - is like the department table in this
584:41 - particular context
584:43 - we have a select Clause a from clause
584:46 - and a join clause in the Syntax for both
584:49 - the link query and the transact SQL
584:52 - query however the from clause in the
584:54 - link query appears at the beginning of
584:57 - the query and the select clause in the
584:59 - link query appears at the end of the
585:01 - query
585:02 - so there are differences in The Ordering
585:04 - of the Clauses When comparing the syntax
585:06 - of the transact SQL query with the
585:09 - syntax of the relevant link query
585:12 - an advantage of link is that can be
585:14 - leveraged in our c-sharp code to query
585:17 - data in a standardized way
585:20 - that is independent from the format of
585:22 - the underlying data source the data
585:25 - source could be a mongodb database a
585:27 - sqlite database a SQL Server database
585:31 - Etc
585:32 - this will not affect the syntax of our
585:34 - link queries
585:37 - so the object layer provided by link can
585:40 - be used for abstracting our queries of
585:42 - the data from the underlying data source
585:46 - and by using link we also have the added
585:49 - advantage of compile time strong typing
585:52 - and the type checking provided by the
585:54 - c-sharp compiler
585:58 - let me draw your attention to the select
586:00 - clause
586:01 - we are able to return the data as an i
586:04 - enumerable collection of anonymous types
586:07 - we are assigning The Collection returned
586:10 - by the link query to a variable preceded
586:13 - by the VAR keyword
586:15 - beginning with c-sharp version 3
586:17 - variables that are declared at method
586:20 - scope can have an implicit type VAR
586:25 - through the use of the VAR keyword the
586:27 - c-sharp compiler is able to infer the
586:30 - types included in the collection
586:32 - returned from the query
586:34 - so we are able to return a collection of
586:37 - objects that are of an anonymous type
586:40 - that we have defined directly within the
586:43 - link query
586:45 - Anonymous types provide a convenient way
586:48 - to encapsulate a set of read-only
586:50 - properties into a single object without
586:52 - having to explicitly Define a type first
586:56 - you can see how the use of anonymous
586:58 - types can provide the developer with
587:00 - flexibility and convenience when
587:02 - constructing relatively complex queries
587:18 - foreign
587:28 - foreign
587:55 - note that Microsoft recommends using the
587:57 - query syntax where possible as opposed
588:00 - to using relevant extension methods for
588:02 - the same purpose this is because of the
588:04 - readability Advantage provided in the
588:07 - relevant query syntax
588:10 - there are however times
588:12 - where you'll need to use appropriate
588:14 - extension methods included within the
588:15 - link namespace because some
588:18 - functionality in link does not have a
588:20 - query syntax counterpart
588:22 - for example if we wanted to calculate
588:25 - the average salary for all employees we
588:28 - would need to use the average extension
588:30 - method like this
588:32 - the same applies if we wish to query for
588:35 - the highest salary from a list of
588:36 - employee records we would need to use
588:39 - the max extension method like this
588:41 - this functionality cannot be performed
588:44 - through the use of query syntax
588:47 - but where possible query syntax is
588:49 - preferable
588:50 - due to the code readability advantage
588:52 - that this syntax provides
588:55 - I hope you've enjoyed this video which
588:57 - provides an introduction to link
588:59 - this video was created to help with the
589:02 - understanding of the fundamentals of
589:03 - Link the advantages that link provides
589:05 - and how we are able to implement basic
589:07 - link queries in code
589:09 - link provides us with an integration of
589:12 - query capabilities directly into the
589:14 - c-sharp language it is a very powerful
589:17 - technology that decouples query logic
589:20 - from relevant types of underlying data
589:23 - formats link provides a layer of
589:25 - abstraction that provides the developer
589:27 - with easy to implement Syntax for
589:30 - querying collections of objects
589:33 - the relevant collection types must
589:35 - implement the I queryable or generic I
589:38 - queryable interface or the I enumerable
589:40 - or generic I.E numerable interface
589:43 - note that the I queryable interface
589:46 - inherits from the I enumerable interface
589:48 - and the generic I queryable interface
589:51 - inherits from both the I enumerable
589:53 - interface and the generic I enumerable
589:56 - interface
589:57 - a suite of extension methods and query
590:00 - syntax are made available to c-sharp
590:02 - developers which provide flexibility
590:04 - when constructing powerful readable
590:06 - queries against data encapsulated with
590:09 - an appropriate c-sharp collections
590:12 - this video is a basic introduction to
590:14 - leveraging link in the c-sharp language
590:16 - and the next tutorial we'll delve deeper
590:19 - into the subject matter
590:22 - [Music]
590:30 - hi and welcome to the second part of a
590:33 - video series on link
590:34 - this video is also the second part of
590:37 - the seventh tutorial in an advanced
590:39 - c-sharp course
590:40 - link stands for language integrated
590:43 - query in the first part of this video
590:45 - series we looked at an overview of Link
590:49 - we discussed that link is the name for a
590:51 - set of Technologies based on the
590:53 - integration of query capabilities
590:55 - directly into the c-sharp language
591:05 - in this video we'll demonstrate examples
591:09 - where we'll create link queries using
591:12 - method syntax and subsequently show how
591:15 - we can express the same link query using
591:17 - query syntax as discussed in the
591:20 - previous video in this series query
591:22 - syntax is recommended because the logic
591:25 - within the query syntax is easier to
591:27 - read
591:28 - in this video we'll look at code
591:30 - examples using the following link
591:32 - operators select where join and group
591:35 - join we'll discuss what is meant by
591:38 - Method chaining and demonstrate an
591:40 - example that makes use of method
591:42 - chaining in the context of a link query
591:45 - we'll look at what is meant by deferred
591:47 - execution of Link queries and what is
591:49 - meant by immediate execution of Link
591:52 - queries we'll discuss the inherent
591:54 - advantages of the third execution in the
591:57 - context of Link
591:59 - to further clarify our understanding of
592:01 - deferred execution we'll create a code
592:03 - example where we'll Implement deferred
592:06 - execution for our own custom extension
592:08 - method for an I enumerable type
592:11 - we'll demonstrate how the c-sharp yield
592:14 - keyword is implemented in the relevant
592:16 - code example as part of code to
592:20 - implement deferred execution
592:23 - at the end of the tutorial we'll look at
592:26 - the join operator and the group join
592:28 - operator
592:30 - we'll create code examples to help
592:31 - clarify our understanding of these two
592:34 - link operators
592:35 - in the first part of this video series
592:37 - we discussed that extension methods and
592:40 - Lambda expressions are fundamental to
592:42 - how Link Works
592:44 - we created our own extension method for
592:46 - filtering a generic list that can be
592:48 - strongly typed with any c-sharp type
592:51 - including user-defined types
592:54 - we then demonstrated how a Lambda
592:56 - expression can be created and calling
592:58 - client code which enables the calling
593:00 - client code to determine how the
593:02 - relevant list of data must be filtered
593:06 - the reason we created our own filter
593:08 - extension method was to help us
593:10 - understand the fundamentals of Link Link
593:12 - functionality is encapsulated in two
593:14 - static classes that are members of the
593:17 - system.link namespace these two static
593:20 - classes are named queryable and
593:22 - enumerable
593:24 - these classes mostly contain extension
593:26 - methods
593:33 - as with the previous video in this
593:34 - series I'm going to demonstrate the code
593:37 - examples in this video on my Mac
593:39 - platform if you are using a Windows
593:41 - platform the fact that I'm using visual
593:43 - studio for Mac should not be a barrier
593:45 - to follow along with these code examples
593:48 - the code creation process is almost
593:50 - exactly the same experience when
593:52 - compared to implementing the same code
593:53 - using visual Studio for Windows
593:57 - so let's create a net core console
594:00 - project
594:11 - let's name this project link examples
594:13 - underscore one
594:20 - so to save time let's copy data related
594:23 - code that we created in the previous
594:25 - video of this series from the
594:27 - appropriate GitHub repository
594:30 - so please navigate to this URL in your
594:32 - browser to access the relevant GitHub
594:34 - repository
594:36 - as always all urls referred to in these
594:39 - videos can be accessed through
594:41 - appropriate links included Below in the
594:43 - description
594:45 - so let's copy the data related
594:47 - functionality from this repository to
594:49 - the project we have just created
594:51 - so in your browser window click the
594:53 - directory icon labeled TCP data like
594:57 - this
594:58 - click the class icon labeled employee
595:01 - let's copy the code for the employee
595:04 - class from this page to our clipboards
595:06 - like this
595:15 - and simply paste the contents of the
595:18 - clipboard below the program class in our
595:20 - new project
595:22 - let's also copy the code for the
595:24 - Department class like this to our
595:26 - clipboards
595:31 - and paste the contents of our clipboards
595:34 - below the employee class within our new
595:36 - project
595:37 - let's then copy the code in the data
595:40 - class to our clipboards
595:52 - then paste the contents of our
595:55 - clipboards below the department class in
595:57 - our new project like this
595:59 - so we have some red Squiggy Lines within
596:01 - our data class
596:03 - to fix this let's include a directive to
596:05 - the system.collections dot generic
596:07 - namespace at the top of our code like
596:10 - this
596:11 - we are just creating throwaway code in
596:13 - this video to help us understand the
596:15 - relevant topics discussed in this video
596:17 - so we are not too concerned with code
596:19 - neatness in this video
596:23 - in our main method let's create a
596:25 - strongly typed generic list
596:27 - that is strongly typed with the employee
596:29 - user-defined type let's name our generic
596:32 - list variable employee list
596:35 - let's assign the value returned from the
596:37 - data.get employees method to the
596:40 - variable we have just named employee
596:42 - list
596:43 - this line of code will populate the
596:45 - employee list collection with made up
596:47 - data that was hard-coded in the data
596:50 - class in the previous video of this
596:52 - series
596:53 - let's define a generic list that is
596:56 - strongly typed with our department
596:58 - user-defined type let's name our
597:01 - variable for this list Department list
597:03 - let's assign the value returned from the
597:06 - data.get Departments method to the
597:09 - variable we have just named Department
597:10 - list
597:12 - this will populate the department list
597:14 - collection with made up data that was
597:16 - hard-coded in the data class in the
597:19 - previous video of this series
597:21 - so let's create a link query that makes
597:24 - use of the select link operator
597:27 - in order to use a link operator we of
597:30 - course need to include a using directive
597:32 - to the system.link namespace
597:35 - for this query we want to select
597:37 - everything from the data stored in our
597:39 - employee list collection
597:41 - we can do this by simply invoking the
597:43 - select method on the employee list
597:45 - object like this
597:47 - the select method is an extension method
597:50 - provided to us through link
597:53 - we can shape our data through the use of
597:55 - a Lambda expression like this
597:59 - we discussed Anonymous types in the
598:02 - previous video of this video series
598:05 - so the select operator returns an i
598:08 - enumerable collection of objects the
598:11 - Lambda expression passed into the select
598:13 - extension method provides an instruction
598:16 - on how we wish to shape each item of
598:19 - data within the returned I enumerable
598:21 - collection
598:23 - this is specifically expressed through
598:26 - this Anonymous type
598:29 - Anonymous types provide a convenient way
598:32 - to encapsulate a set of read-only
598:34 - properties into a single object without
598:37 - having to explicitly Define a type first
598:41 - you can see how the use of anonymous
598:43 - types can provide the developer with
598:45 - flexibility and convenience when
598:47 - constructing queries
598:50 - so here we are providing an instruction
598:52 - that we want each item of data in The
598:55 - Returned I enumerable collection to
598:57 - contain a full name property which is a
598:59 - concatenation of the first name and the
599:01 - last name properties of the relevant
599:03 - employee record and a property
599:05 - containing the employee's annual salary
599:09 - so let's write the code to Output the
599:11 - results of this query to the console
599:13 - screen
599:31 - let's see the code in action
599:38 - great
599:41 - so if we want to filter this data we can
599:44 - do this by chaining the where extension
599:46 - method to our select operator like this
599:51 - method chaining is a common Syntax for
599:53 - invoking multiple method calls in C
599:56 - sharp
599:57 - each method returns an object allowing
600:00 - calls to be changed together in a single
600:02 - statement without requiring variables to
600:06 - store the intermediate results
600:08 - so the select operation will return an
600:11 - innumerable collection object we can
600:13 - filter this returned inumerable
600:16 - collection within the same link query by
600:18 - chaining the where extension method to
600:20 - the select extension method
600:24 - the where extension method filters the
600:26 - data stored in the innumerable object
600:28 - returned from the select method
600:31 - through a Lambda expression passed to
600:33 - the where extension method the Lambda
600:36 - expression provides instructions to the
600:38 - where extension method on how the data
600:41 - must be filtered
600:42 - once the data has been filtered through
600:45 - the wear extension method and I
600:47 - enumerable collection of results is
600:50 - assigned to our results variable
600:52 - we are then traversing our results using
600:54 - a for each Loop and displaying each item
600:57 - in the I enumerable collection to the
600:58 - console screen
601:00 - we discussed the VAR keyword which
601:02 - allows for local implicit typing within
601:05 - methods in the previous video of this
601:07 - series please view the previous video in
601:10 - this series for more details
601:12 - so here we are implementing link
601:14 - explicitly using the extension methods
601:17 - provided by link we are using the select
601:20 - operator and the where operator in a
601:22 - link query
601:23 - implemented using method syntax
601:29 - let's run the code
601:31 - great we can execute the same
601:33 - functionality using query syntax
601:42 - so let's comment out the previous code
601:44 - and include a comment to label this code
601:46 - so that we are able to refer to this
601:48 - code later if need be
601:50 - so let's first implement the link query
601:52 - using query syntax without the where
601:55 - clause
601:59 - okay
602:21 - let's run the code
602:28 - great
602:29 - let's implement the link query
602:31 - implemented using query syntax and this
602:34 - time include the where Clause within the
602:36 - link query using query syntax
602:49 - let's run the code
602:54 - excellent and we get exactly the same
602:57 - result when compared to running the
602:59 - query that we implemented using method
603:01 - syntax
603:03 - but we have constructed our link code
603:04 - using link query syntax as opposed to
603:07 - using relevant extension methods the
603:10 - query syntax is more readable and we
603:12 - don't need to chain our extension
603:14 - methods as we did in the previous
603:16 - example where we changed the where
603:17 - extension method to the select extension
603:20 - method
603:21 - let's take a closer look at our query
603:24 - where we used method syntax versus the
603:27 - same query where we used query syntax
603:32 - note that standard query operators in
603:35 - our query syntax are converted into
603:37 - extension Methods at compile time
603:40 - so standard query operators are
603:43 - essentially the same as their
603:44 - counterpart extension methods
603:47 - Microsoft recommends using query syntax
603:50 - as opposed to directly implementing the
603:52 - relevant extension methods where
603:54 - possible
603:56 - as discussed this is due to the
603:58 - readability Advantage inherent in the
604:00 - query syntax
604:01 - there are times when you will need to
604:03 - use extension methods directly where
604:06 - equivalent query syntax is not available
604:10 - we looked at a few examples of this in
604:12 - the previous video of this series for
604:15 - example using aggregate functionality
604:17 - like for example finding the average Min
604:19 - or Max annual salary for a collection of
604:23 - employee records we would need to use
604:25 - the respective average Min or Max
604:27 - extension methods to calculate and
604:30 - return the relevant values
604:34 - the developer is able to execute link
604:36 - queries with deferred execution or
604:39 - immediate execution
604:42 - so let's first understand what is meant
604:44 - by deferred execution
604:46 - the third execution means that the
604:48 - evaluation of an expression is delayed
604:50 - until its value is required this
604:53 - improves performance because only
604:55 - necessary executions are carried out I.E
604:58 - at the point where the relevant value is
605:00 - required
605:02 - let's use our last query example to
605:04 - illustrate this point
605:05 - so when we first assign the value
605:07 - returned by our query to our results
605:10 - variable
605:11 - the query is not executed
605:14 - it is only when we Traverse the items in
605:16 - our results variable that the actual
605:18 - execution takes place I.E with each
605:21 - iteration of the for each Loop an
605:23 - execution is performed whereby the
605:26 - relevant item is evaluated and returned
605:28 - from the collection
605:31 - another advantage of deferred execution
605:33 - is that an update to the relevant data
605:36 - collection will immediately be reflected
605:38 - in the results
605:43 - so for example let's add a record to our
605:46 - employee collection
605:49 - note the salary for this new employee is
605:52 - above 50 000. so this employee should
605:54 - appear within our results
605:59 - let's run the code
606:11 - and you can see that this is proof that
606:13 - the results are evaluated within the for
606:15 - each Loop
606:17 - and the query itself is not executed at
606:20 - the line of code where the relevant
606:22 - query is located
606:24 - the execution of the query is deferred
606:26 - until the results are traversed within
606:28 - the relevant for each Loop
606:31 - to further understand the concept of
606:33 - deferred execution let's create a code
606:35 - example where we'll Implement deferred
606:37 - execution for our own custom extension
606:40 - method for an innumerable type that is
606:43 - strongly typed as the employee
606:45 - user-defined type
606:52 - foreign
606:59 - let's create a static class named
607:01 - innumerable collection extension methods
607:04 - let's create a static method within the
607:07 - static class that we have just created
607:08 - and let's name this method get high
607:11 - salaried employees
607:13 - we discussed extension methods in the
607:16 - previous video for this video series
607:18 - for more information on extension
607:20 - methods please access a link to this
607:22 - video as discussed a link to this video
607:25 - is available Below in the description
607:27 - so let's implement the code for the get
607:29 - high salaried employees extension method
607:32 - like this
607:51 - note the use of the yield keyword
607:54 - you can use a yield return statement to
607:57 - return each element one at a time
608:00 - the sequence returned from an iterator
608:03 - method can be consumed by using a for
608:06 - each statement or link query
608:09 - each iteration of the for each Loop
608:11 - calls the iterator method when a yield
608:14 - return statement is reached in the
608:17 - iterator method the relevant value in
608:20 - the I enumerable collection is returned
608:22 - and the current location in code is
608:25 - retained execution is restarted from
608:28 - that location the next time that the
608:31 - iterator function is called
608:36 - let's go to our main method
608:38 - and Implement a query that calls our
608:40 - extension method on the employee list
608:42 - collection
608:56 - let's copy and paste the code that we
608:58 - have already written to Traverse the
609:00 - results and output the relevant data
609:10 - and let's add another employee records
609:12 - to the employee list collection as we
609:14 - did before
609:40 - let's run the code
609:46 - and you can see that the new employee
609:48 - record is reflected in the results the
609:50 - results are kept up to date due to
609:52 - deferred execution
609:58 - note that the third execution
610:00 - reevaluates on each execution which is
610:03 - known as lazy evaluation
610:06 - the converse of deferred execution is
610:09 - immediate execution immediate execution
610:12 - means the relevant query is executed
610:14 - immediately
610:16 - to execute a query immediately we need
610:19 - to apply an appropriate two conversion
610:21 - method to the query
610:24 - so let's copy the previous code example
610:31 - let's uncomment the relevant code let's
610:34 - change this code so that the query
610:36 - executes immediately
610:38 - we can use the two list conversion
610:40 - method for this purpose
610:42 - we are using query syntax here so in
610:44 - order for us to use the to list
610:46 - conversion method we first need to wrap
610:49 - the relevant query in Brackets add a DOT
610:52 - and then the to list conversion method
610:56 - we are explicitly typecasting the I
610:59 - enumerable value returned from the query
611:02 - to the list type through the
611:04 - implementation of the to list conversion
611:07 - method we are also executing the query
611:09 - immediately
611:11 - let's uncomment the rest of the relevant
611:14 - code for this example
611:18 - and let's run the code
611:24 - you can see that the execution of our
611:27 - query is immediate because this time
611:29 - after we've added a new employee the
611:32 - query has not been evaluated again to
611:35 - include the new employee record in the
611:37 - results this is of course why the new
611:39 - employee does not appear within the
611:40 - results output to the screen
611:43 - this proves that our query has executed
611:45 - immediately at the line of code where
611:47 - the query is located
611:49 - and remember that query syntax does not
611:52 - support two operators so we need to wrap
611:55 - our query in Brackets as we have done
611:57 - here and call whichever two method is
612:00 - appropriate for example to list two
612:03 - array or two dictionary
612:06 - by calling the relevant to method in
612:09 - this case the two list method we are
612:11 - causing our query to execute immediately
612:13 - without the two conversion method the
612:16 - relevant query execution would be
612:18 - deferred until the relevant results are
612:20 - iterated
612:23 - so let's move on to the join operator
612:26 - and then we'll look at the group join
612:28 - operator and highlight the difference
612:30 - between these two join operations
612:33 - in the previous video in this series we
612:36 - looked at the join operator and
612:37 - discussed how we can perform an inner
612:40 - join on two inumerable collections using
612:43 - a link query
612:44 - so here we have two collections that we
612:47 - wish to join in this specific use case
612:49 - we need to include a descriptive
612:51 - Department name in our results displayed
612:54 - to the user we only have a department ID
612:57 - field in our employee type so in order
613:00 - to merge the properties from our
613:02 - employee type with the relevant property
613:05 - from our department type we need to join
613:07 - records of type Department that reside
613:10 - within our department list collection
613:12 - with records of type employee that
613:15 - reside within our employee list
613:16 - collection we can do this by matching
613:19 - the ID field in the department records
613:21 - that reside in the department list
613:23 - collection with the Department ID
613:25 - property of employee records that reside
613:27 - in the employee list collection
613:30 - we can do this through link by using the
613:33 - join operator
613:34 - later we'll demonstrate a join operation
613:37 - but using the group join operator we'll
613:40 - also discuss the differences between the
613:42 - join operator and the group join
613:44 - operator
613:45 - let's look at the relationship between
613:47 - the collection of Department Records
613:49 - with the collection of employee Records
613:52 - Department Records have a one-to-many
613:55 - relationship with employee records
613:59 - a specific Department can have many
614:01 - employees as members
614:03 - a specific employee cannot belong to
614:06 - more than one department at a point in
614:08 - time
614:10 - data collections can also have
614:12 - one-to-one relationships with one
614:13 - another or many too many relationships
614:16 - with one another so in this example we
614:18 - are going to look at how we can use Link
614:20 - to implement a join operation between
614:23 - two collections of records that have a
614:25 - one-to-many relationship with one
614:27 - another I.E one Department to many
614:29 - employees
614:31 - so let's Implement a query that joins
614:33 - the department list collection with the
614:35 - employee list collection where the ID
614:37 - property of the relevant objects of type
614:40 - Department match the department ID
614:42 - property of the relevant objects of type
614:45 - employee
614:46 - so the Syntax for this link query would
614:48 - look like this when we implement the
614:51 - join operation using method syntax
614:54 - so to join Department Records to
614:56 - appropriate employee records we can use
614:59 - the join extension method and invoke the
615:01 - extension method on the department list
615:03 - collection
615:05 - the first argument we need to pass into
615:07 - the join method is the collection on
615:09 - which we want to join the department
615:11 - list collection
615:12 - so we pass in the employee collection
615:15 - object here
615:17 - the second argument is the key from the
615:20 - outer collection the department list
615:21 - collection so the outer join key is the
615:25 - ID property that resides in the
615:26 - department type we can express this
615:29 - argument as a Lambda expression like
615:31 - this
615:32 - the third argument is the inner join key
615:35 - which is the department ID property
615:37 - which is a member of the employee type
615:39 - we can express this argument as a Lambda
615:42 - expression like this so we are joining
615:44 - on the ID property which is a member of
615:46 - the department type with the Department
615:48 - ID property which is a member of the
615:51 - employee type
615:54 - we can define an anonymous type where we
615:57 - are able to shape the data for each item
615:59 - in an i enumerable collection that we
616:02 - want returned from the relevant query
616:05 - here we are defining an anonymous type
616:07 - within our link query that includes the
616:09 - employee full name which is a
616:11 - concatenation of the employee's first
616:12 - name and last name the employee's annual
616:15 - salary as well as the relevant
616:17 - Department objects long name property
616:20 - the long name property will give us a
616:22 - descriptive Department name in our
616:24 - results
616:25 - we are including the department types
616:27 - long name property and the relevant
616:29 - Anonymous type this is the whole point
616:31 - of joining the department list
616:32 - collection with the employee collection
616:35 - so that we are able to include a
616:36 - descriptive Department name within our
616:38 - results we only have the department ID
616:41 - as a member of our employee type so if
616:43 - we only return to results from the
616:46 - employee list and wanted to include
616:48 - Department information we would be
616:50 - restricted to the department ID property
616:52 - which is an integer value and is
616:55 - unlikely to be meaningful to a user
617:01 - thank you
617:04 - let's run the code
617:09 - great
617:13 - but as discussed where it is possible to
617:15 - use Query syntax rather than method
617:18 - Syntax for our link queries
617:20 - we should use Query syntax because the
617:22 - logic expressed and the relevant query
617:24 - is far easier to read
617:27 - so let's write the same query using
617:29 - query syntax
618:23 - as you can see it is far easier to read
618:25 - and it is also similar to query
618:28 - languages with which we may already be
618:30 - familiar for example transact SQL let's
618:34 - Express what a similar query and
618:36 - transact SQL might look like
618:38 - so let's imagine that we have a table in
618:41 - a SQL Server database that could map to
618:43 - our employee type
618:45 - let's say this table has the same name
618:47 - as our employee type let's also imagine
618:50 - that we have a table in the same SQL
618:52 - Server database that contains a table
618:54 - schema that could map to our department
618:57 - type
618:58 - let's say this table has the same name
619:00 - as our department type
619:03 - so the transact SQL would look something
619:05 - like this
619:07 - you can see how the from Clause the join
619:10 - clause and the select Clause are
619:12 - implemented in both the link query
619:14 - syntax and the transact SQL syntax
619:17 - even though the link query contains the
619:20 - same Clauses in a different order to the
619:22 - comparative Clauses in the transact SQL
619:25 - query for someone who is familiar with
619:27 - transact SQL and not necessarily
619:29 - familiar with link query syntax this
619:31 - link query syntax at a glance should be
619:34 - fairly easy to understand
619:37 - so the point share is that link query
619:39 - syntax is similar to query syntax with
619:43 - which many of us will already be
619:44 - familiar so this makes the
619:46 - implementation of Link queries using
619:48 - query syntax more intuitive
619:51 - as discussed the link query syntax is
619:54 - also more readable than the equivalent
619:56 - link query implemented using method
619:58 - syntax so the key takeaway here is to
620:02 - use Link query syntax rather than method
620:04 - syntax where possible because it is more
620:07 - intuitive to implement and easier to
620:09 - read
620:10 - let's run the code
620:17 - great
620:20 - so let's look at the group join link
620:22 - operator and while we might want to use
620:24 - the group join operator in our link
620:26 - queries
620:28 - we have just performed an inner join
620:30 - using the join operator this query will
620:34 - only return those records based on the
620:36 - ID property of relevant objects of the
620:39 - department type in the department list
620:41 - collection matching with the Department
620:43 - ID property of relevant objects of the
620:45 - employee type in the employee list
620:47 - collection diagrammatically an inner
620:50 - join query can be represented like this
620:54 - what if we wanted to return through a
620:56 - link query all the Department Records in
620:58 - our department list collection and only
621:00 - employee records where the department ID
621:02 - property of employee objects and the
621:05 - employee list collection match the ID
621:07 - property of Department Records in the
621:09 - department list collection so if we were
621:12 - to write to the transact SQL version of
621:14 - this query it would look something like
621:16 - this
621:17 - we would use a left outer join to
621:19 - achieve the desired result
621:22 - this query would bring back all
621:24 - Department Records but only those
621:26 - employee records where the relevant
621:28 - employee records department ID values
621:30 - match the ID property of the relevant
621:33 - Department Records
621:35 - so diagrammatically we can represent a
621:38 - left outer join query like this
621:41 - so let's look at the diagram
621:42 - representing an inner join operation and
621:45 - compare the diagram to the diagram
621:47 - representing the left outer join
621:49 - operation
621:50 - so let's use our group join operator in
621:53 - a link query to return all Department
621:55 - Records from the Department list
621:57 - collection but only the employee records
622:00 - from the employee list collection with a
622:02 - department ID property that matches an
622:05 - ID property of a department record in
622:07 - the department list collection
622:09 - so here we are implementing our query
622:11 - using method syntax
622:14 - you can see the implementation of the
622:16 - group join operation using method syntax
622:19 - is very similar to The Way We
622:21 - implemented the join operation in the
622:23 - previous example
622:28 - foreign
622:53 - the code
622:55 - note the way we have structured our
622:57 - output is clearly different when
622:59 - outputting the results of our group join
623:01 - query when compared to the way we
623:03 - structured our output of the results of
623:06 - our join query but note that at the
623:08 - moment the same join between Department
623:10 - Records and employee records has
623:13 - occurred
623:14 - the reason for this is not because the
623:17 - group joined and the join operators
623:18 - perform the same type of join operation
623:21 - it is because currently each of the
623:23 - records in the employee list collection
623:25 - match with a department record in our
623:28 - department list collection
623:30 - let's change our data to highlight a key
623:33 - difference in the join operation and the
623:35 - group join operation
623:36 - let's do this by going to the code where
623:39 - we have hard-coded made up employee and
623:42 - Department Records and added these
623:44 - records to their respective collections
623:47 - let's ensure that the technology
623:49 - department which has an ID of three does
623:52 - not match with a department ID property
623:54 - of any of the employee objects in our
623:56 - employee list collection
623:58 - we only currently have one employee that
624:01 - is in the technology department
624:02 - according to our data let's change the
624:05 - relevant Department ID so that there are
624:07 - no employees that are members of the
624:10 - technology department so let's change
624:12 - this department ID property now no
624:15 - employees are members of the technology
624:17 - department according to our data
624:32 - let's run the code
624:38 - so you can see our technology department
624:41 - record is being returned along with all
624:44 - the other department records in the
624:46 - department list collection even though
624:48 - its ID property doesn't match the
624:51 - department ID property of any employee
624:53 - records stored in the employee list
624:55 - collection
624:57 - so simply put Department information for
625:00 - departments that contain employees are
625:03 - included in the query results and
625:05 - departments that don't contain any
625:08 - employees are also included in the query
625:10 - results
625:11 - in this example the technology
625:13 - department has returned even though it
625:15 - contains no matching employee records
625:18 - so here we have performed a left outer
625:20 - join query using links group join
625:23 - operator
625:25 - so let's rewrite this link query using
625:27 - query syntax
626:04 - you can see here that the group join
626:07 - extension method does not get explicitly
626:09 - called when we Implement our query using
626:13 - query syntax the into keyword is used
626:16 - within the query to create a group of
626:18 - employees for each department
626:21 - so as discussed link query syntax does
626:25 - not match exactly when comparing link
626:27 - query syntax to familiar query languages
626:30 - like transact SQL but in many ways it
626:34 - does resemble a language like transact
626:35 - SQL in this sense link query syntax is
626:39 - more intuitive to implement than method
626:41 - syntax when implementing link queries
626:45 - and just to labor the point as discussed
626:47 - it is also better to implement link
626:49 - query Syntax for our link queries then
626:52 - implementing method Syntax for the same
626:54 - purpose because of better readability
626:59 - let's run the code
627:03 - great and we get the exact same result
627:06 - as when we ran the same query that was
627:10 - implemented using method syntax
627:12 - now that we have changed the data so
627:15 - that the technology department does not
627:17 - match with any employee records let's
627:19 - run our join operation that we created
627:22 - earlier
627:35 - notice that the results of the join
627:37 - operation doesn't include the technology
627:39 - department this is because the join
627:42 - operation performs an inner join and
627:44 - with the group join operation we are
627:46 - able to perform a left outer join
627:48 - operation
627:49 - so let's comment out our join query and
627:52 - uncomment our group join query
628:01 - and for good measure let's run the code
628:03 - again
628:07 - and as you can see the technology
628:09 - department is now included in the
628:11 - results displayed to the screen even
628:13 - though the technology department does
628:16 - not have any matching employee records
628:18 - great
628:20 - so the left outer join operation returns
628:22 - all records from the outer left
628:24 - collection in the query but does not
628:27 - return records from the inner collection
628:30 - where the inner collection records do
628:32 - not match any of the outer collection
628:34 - records
628:36 - so if there were employee records in the
628:39 - employee list collection that did not
628:41 - match any of the Department Records in
628:43 - the department list collection these
628:45 - employees would not appear in the
628:47 - results outputted to the screen we can
628:49 - prove this let's change the department
628:51 - ID of this employee record where the
628:53 - first name property is Bob and the last
628:55 - name properties Jones
628:59 - we have changed the department ID
629:01 - property for this record to six and
629:04 - there's no matching Department record
629:08 - I.E no Department record has an ID of
629:10 - six let's run the code
629:20 - and you can see that the employee record
629:23 - with first name Bob and last name Jones
629:25 - does not appear within the results
629:29 - however even though the human resources
629:31 - department has no matching employee
629:33 - records it is still included in the
629:36 - results output to the screen great let's
629:39 - add Bob Jones back into the human
629:41 - resources department like this and let's
629:43 - run the code
629:48 - excellent
629:50 - so hopefully this made it clear how we
629:53 - are able through link to use the join
629:55 - operator to perform inner join queries
629:57 - between two object Collections and how
629:59 - we are also able to perform left outer
630:02 - join queries using the group join
630:04 - operator
630:08 - [Music]
630:18 - hi and welcome to the third part of a
630:21 - video series on the link technology
630:23 - using c-sharp this video is also part of
630:26 - the seventh tutorial in an advanced
630:28 - c-sharp course link was introduced with
630:31 - c-sharp version 3 which was released on
630:34 - the 19th of November 2007.
630:37 - link stands for language integrated
630:40 - query
630:47 - in this video we are going to focus on
630:49 - code examples that make use of several
630:52 - link operators
630:54 - the code examples demonstrated in this
630:56 - video will hopefully help us gain an
630:58 - understanding of a broad array of
631:00 - operators that are made available to us
631:02 - through link
631:04 - we'll learn how we can use these
631:06 - operators to query and transform data
631:09 - this quote from the Microsoft docs
631:11 - provides a basic definition of standard
631:14 - query operators and can be found at this
631:16 - URL
631:18 - standard query operators are the methods
631:21 - that form the link pattern most of these
631:24 - methods operate on sequences whereas
631:27 - sequence is an object whose type
631:29 - implements the generic I.E numerable
631:32 - interface or the generic I queryable
631:34 - interface
631:37 - a lot of the more frequently used query
631:39 - operators have dedicated c-sharp keyword
631:42 - syntax that enables them to be called as
631:45 - part of a query expression as discussed
631:49 - in the previous video in this video
631:50 - series it is advantageous to use Query
631:53 - syntax rather than method syntax where
631:56 - possible because query syntax is more
631:58 - readable note that query expression
632:00 - Clauses are translated into calls to
632:03 - query Methods at compile time
632:06 - for a useful tabular representation of
632:08 - standard query operators that have
632:10 - equivalent query expression Clauses
632:12 - please navigate to this URL we discussed
632:15 - what is meant by deferred execution and
632:18 - immediate execution in the previous part
632:20 - of this video series
632:22 - for a useful tabular classification of
632:24 - operators in terms of deferred execution
632:26 - or immediate execution please navigate
632:29 - to this URL
632:32 - for additional information on deferred
632:34 - execution versus immediate execution and
632:37 - Method syntax versus query syntax please
632:40 - View the second part of this video
632:42 - series
632:43 - so to gain an understanding of several
632:45 - useful link operators let's create a few
632:47 - code examples
632:50 - as with the previous video in this
632:52 - series I'll be demonstrating these code
632:55 - examples on my Mac platform using visual
632:57 - studio for Mac
632:59 - the code creation process for these code
633:01 - examples is almost exactly the same
633:03 - process as creating the equivalent code
633:06 - examples on a Windows platform using
633:08 - visual Studio for Windows
633:11 - the fact that I'm using visual studio
633:12 - for Mac should not be a barrier for a
633:15 - learner to follow along with the
633:16 - creation of these code examples
633:19 - let's start by creating a.net core
633:22 - console project
633:23 - we created a project in the previous
633:25 - video named link examples underscore one
633:28 - let's name this project link examples
633:30 - underscore 2.
633:32 - in order to save time let's copy data
633:34 - related classes that have already been
633:36 - created in the previous videos of this
633:38 - series and incorporate these classes
633:40 - into our new project these classes
633:43 - contain class definitions for an
633:45 - employee and a department record as well
633:48 - as code that adds several made up
633:49 - objects of type employee and Department
633:52 - to their respective collections
633:54 - as in the previous parts of this video
633:56 - series we can then use these collections
633:59 - of strongly typed objects in our link
634:01 - query examples
634:03 - so to copy the relevant code let's
634:06 - navigate to this URL IE to a GitHub
634:09 - repository that was created in the
634:11 - previous video
634:12 - let's click on the directory icon
634:14 - labeled link examples underscore one
634:16 - then let's click on the file icon
634:19 - labeled program.cs
634:22 - let's copy the employee class to our
634:24 - clipboards
634:34 - and paste the contents of our clipboards
634:37 - within the new project that we have just
634:40 - created
634:42 - let's copy the department class to our
634:44 - clipboards and paste the contents of our
634:47 - clipboards below the employee class
634:49 - within our new project
634:51 - lastly let's copy the data class to our
634:54 - clipboards
634:58 - and paste the contents of our clipboards
635:00 - below the department class within our
635:02 - project
635:03 - so in the previous video we looked at
635:05 - the following operators
635:07 - the select projection operator the where
635:10 - filter operator the join and group join
635:13 - join operators in this video we'll
635:16 - create code examples that implement the
635:18 - following operators
635:20 - we'll start by looking at the following
635:22 - sorting operators order by order by
635:25 - descending then by and then by
635:27 - descending
635:28 - we'll then look at these grouping
635:30 - operators Group by and to lookup
635:33 - we'll then look at these quantifier
635:35 - operators or any and contains
635:39 - we'll then look at the following
635:40 - filtering operator of type
635:43 - note that another example of a filtering
635:46 - operator is the where operator we have
635:49 - looked at the where filter operator in
635:51 - the previous parts of this video series
635:54 - lastly we'll look at the following
635:56 - element operators element at element at
635:59 - or default first first or default last
636:02 - last or default single and single or
636:06 - default
636:07 - we'll look at even more link operators
636:09 - and create code examples in the next
636:11 - video
636:14 - the next video will be the final video
636:16 - in this video series on link
636:19 - right let's get started so let's start
636:21 - by looking at the data related classes
636:23 - that we copied from GitHub we have the
636:26 - employee class which provides a
636:28 - definition for an employee record we
636:30 - have the department class which provides
636:32 - a definition for a department record we
636:35 - have the data class that contains code
636:37 - where lists of hard-coded made up
636:40 - employee and Department objects are
636:42 - added to their respective collections
636:44 - within their respective methods and
636:45 - returned from their respective methods
636:48 - in the previous video in this series we
636:50 - looked at join operators namely the join
636:53 - operator and the group join operator
636:55 - so in the context of join operations the
636:59 - department collection has a one-to-many
637:01 - relationship with the employee records
637:03 - in the employee collection
637:06 - this simply means that one or many
637:07 - employees can be members of a specific
637:10 - Department a specific employee can be a
637:13 - member of only one department at a point
637:15 - in time
637:17 - so let's go to our main method
637:20 - we can use the data dot get employees
637:23 - method to return a collection of made up
637:25 - employee records
637:27 - let's use this method to assign the
637:30 - relevant collection of employee records
637:33 - to a local variable named employee list
637:36 - the employee list variable is defined as
637:39 - a generic list that is strongly typed as
637:41 - employee
637:43 - so here we have red squiggly lines
637:45 - because we need to include a using
637:47 - directive to the
637:49 - system.collections.generic namespace
637:51 - let's use the data dot get departments
637:54 - method to return a collection of made-up
637:57 - Department Records that have a
637:59 - one-to-many relationship with the
638:01 - relevant collection of employee records
638:03 - and let's assign the relevant return
638:05 - collection of Department Records to a
638:08 - variable named Department list
638:10 - the department list variable is defined
638:13 - as a generic list that is strongly typed
638:15 - as Department
638:17 - so let's get into the creation of our
638:20 - examples
638:22 - sorting operators order by
638:25 - so let's create an example for the order
638:28 - by operator in this example we want to
638:31 - return all employee records from the
638:34 - employee list collection and order by
638:36 - Department ID
638:38 - to make things a little bit more
638:39 - interesting let's say we want to include
638:42 - the department name within our outputted
638:44 - results
638:45 - the problem here is that the department
638:47 - name does not exist in the employee type
638:50 - so we need to join the employee list
638:52 - collection to the department list
638:54 - collection so that we can include the
638:57 - department name in our results
638:59 - we can do this by using the join
639:01 - operator
639:03 - so let's write this query using method
639:05 - syntax so that we can see all the link
639:08 - extension methods used in the relevant
639:10 - query
639:12 - so we first need to make sure that we
639:15 - include a using directive to the
639:17 - system.link namespace
639:19 - this directive will give us access to
639:21 - the relevant link operators that we will
639:23 - be implementing in our code examples
639:26 - we know that the system.link namespace
639:28 - contains two static classes namely
639:31 - innumerable and queryable and these
639:34 - static classes mostly contain extension
639:36 - methods our link operators which are
639:38 - implemented in the form of extension
639:40 - methods are implemented within the
639:42 - enumerable and queryable static classes
639:46 - so this link query joins the employee
639:49 - list collection to the department list
639:51 - collection on the department ID property
639:53 - of each of the relevant employee records
639:56 - with the ID property of relevant
639:58 - Department Records
640:52 - foreign
640:58 - this query let's alter the data a bit
641:01 - let's make the employee record
641:03 - pertaining to Sarah Jameson a member of
641:05 - the technology department by changing
641:08 - the relevance Department ID property
641:10 - from two to three let's also change the
641:13 - department for the employee record
641:15 - pertaining to Jane Stevens to the
641:17 - technology department by changing the
641:19 - relevant Department ID from 2 to 3. this
641:23 - change to the data will make the effects
641:25 - of our sorting operators more apparent
641:27 - when we view our results
641:30 - so if we run the query first without the
641:33 - use of any order by operators note that
641:36 - the data appears to us in the same order
641:39 - as it was added to the employee list
641:43 - but now let's say there is a requirement
641:45 - to order our results by the department
641:47 - ID property in ascending order
641:50 - we can do this by chaining the order by
641:53 - extension method to the end of the query
641:55 - like this
641:56 - for more information on method chaining
641:58 - please view the previous video in this
642:01 - series
642:02 - so we can pass in a Lambda expression to
642:05 - the order by extension method to
642:06 - indicate that we wish to order the
642:08 - results by the department ID property
642:12 - let's run the code
642:15 - and you can see that the results are now
642:18 - ordered in ascending order by Department
642:19 - ID
642:21 - if we look at the code that added each
642:23 - department to the department collection
642:25 - we can see that the human resources
642:28 - department has an ID of one the finance
642:30 - department has an ID of two and the
642:32 - technology department has an ID of three
642:35 - our results have been ordered in
642:37 - ascending order based on the department
642:39 - ID property of the employee record
642:44 - so we can clearly see the effects of the
642:47 - order by operator on our results great
642:50 - if the requirement changed such that we
642:52 - needed to order our results by the
642:55 - department ID property in descending
642:57 - order we can chain the order by
642:59 - descending extension method instead of
643:01 - the order by extension method for this
643:03 - purpose
643:04 - our results are now ordered by
643:06 - Department ID in the reverse order when
643:08 - compared to the previous output great
643:12 - so let's say that we want to order our
643:15 - results by the department ID property in
643:18 - ascending order and then by the annual
643:20 - salary property also in ascending order
643:23 - so let's replace the order by descending
643:26 - extension method with the order by
643:27 - extension method in our results like
643:30 - this then let's chain the then buy
643:32 - extension method to the query like this
643:35 - we can then pass a Lambda expression to
643:38 - indicate that we wish to further order
643:40 - our results by the annual salary
643:42 - property the then by extension method
643:45 - will order the results produced by the
643:47 - order by sorting operator in ascending
643:49 - order
643:57 - great
643:59 - and if we want to order by the annual
644:01 - salary property in descending order we
644:04 - can replace the then buy extension
644:06 - method with the then by descending
644:08 - extension method for this purpose
644:15 - excellent
644:23 - foreign
644:35 - we can represent sorting operations
644:37 - within link queries that are represented
644:40 - using query syntax like this
645:01 - note the order by and descending
645:04 - keywords in the query syntax version of
645:06 - the relevant query
645:09 - we use the order by keyword within our
645:12 - query to order by our first specified
645:14 - property
645:16 - if we want to subsequently sort on other
645:18 - properties instead of chaining the then
645:20 - by extension method to our query and
645:23 - query syntax subsequent Properties by
645:26 - which we wish to sort are separated by
645:28 - commas
645:29 - the descending keyword can follow any of
645:32 - the properties that we wish to sort in
645:35 - descending order
645:36 - the default order is ascending order
646:35 - so let's look at the group by and to
646:37 - lookup grouping operators
646:40 - let's start with the group by operator
646:42 - so this operator is akin to the group by
646:45 - Clause we would apply in a transact SQL
646:48 - query
646:50 - so we can implement the group by
646:52 - operator using the group by extension
646:54 - method or the group and the buy keywords
646:57 - within query syntax to perform the same
647:00 - operation so let's say we wish to query
647:03 - the employee list collection
647:05 - and group our results by the department
647:08 - ID property
647:09 - the query using query syntax would look
647:12 - like this
647:14 - this query is simply grouping our
647:16 - results by the department ID property
647:24 - using method syntax this query would
647:26 - look like this
647:42 - in all of the link query examples using
647:45 - query syntax that we have looked at up
647:47 - till this point in this video series we
647:50 - have ended all our queries with a select
647:53 - operator
647:55 - notice that this query does not end with
647:57 - a select operator
647:59 - it is important to note that a link
648:01 - query implemented in query syntax must
648:04 - either end with a select operator or a
648:07 - grouping operator
648:09 - notice how this query does not end with
648:12 - a select operator but a grouping
648:14 - operation is being performed at the end
648:16 - of this query
648:18 - so we can Traverse the results of this
648:20 - grouping operation using nested for each
648:24 - Loops the outer loop traverses each
648:27 - group that has been created based on the
648:30 - department ID property the inner loop
648:33 - traverses the item members within each
648:35 - of the groups that have been created in
648:38 - our query based on the department ID
648:40 - property
648:46 - great
648:49 - we could also include the order by
648:51 - operator within our query like this
649:00 - let's run the code
649:05 - great
649:06 - we can implement the same query using
649:09 - methods syntax using the two lookup
649:11 - extension method like this
649:23 - great
649:29 - we can also include sorting
649:31 - functionality through the order by
649:33 - operator through the implementation of
649:36 - method chaining like this
649:57 - great
649:58 - note that the two lookup method performs
650:01 - the same operation as the group by
650:03 - operator the only difference is the
650:06 - execution of the group by operation is
650:08 - deferred whereas the execution of the
650:11 - two lookup operation is executed
650:13 - immediately
650:15 - we discussed deferred execution and
650:17 - immediate execution in the previous part
650:19 - of this video series for more
650:22 - information on deferred execution and
650:24 - immediate execution please View the
650:26 - second part of this video series the
650:28 - link to this video has been included
650:29 - Below in the description
650:31 - note that the results returned from a
650:34 - group by operation and a two lookup
650:36 - operation return a group contained in a
650:40 - special type of collection that
650:42 - implements an eye grouping generic
650:44 - interface
650:59 - so let's look at the all any and
651:02 - contains quantifier operators let's
651:05 - first look at the all and any operators
651:09 - let's create a variable named annual
651:12 - salary compare and assign it with a
651:14 - value of 20 000.
651:16 - let's Implement a block of code related
651:19 - to the all operator
651:52 - let's Implement a similar block of code
651:54 - related to the any operator
651:57 - so the all and any operators return a
652:00 - Boolean value
652:02 - the return value will equal true if the
652:05 - elements in the relevant collection
652:07 - satisfy a condition passed to the
652:09 - relevant method this condition can be
652:11 - passed in the form of a Lambda
652:13 - expression
652:18 - this query will return true if all
652:20 - employee records
652:22 - have annual salary property values that
652:24 - are greater than twenty thousand
652:38 - this query will return true if one or
652:41 - more employee records have an annual
652:43 - salary property value that is greater
652:45 - than twenty thousand
653:06 - let's run the code
653:08 - foreign
653:16 - this is an expected result
653:19 - let's change the annual salary compare
653:21 - variable to a hundred thousand
653:34 - great
653:37 - and let's change the annual salary
653:38 - compare variable to 40 000.
653:52 - so let's move on to the contains
653:55 - operator
653:56 - so we want to be able to assess whether
653:59 - an employee record exists within our
654:01 - collection of employee records the
654:04 - contains operator will return true if we
654:07 - pass in an object that is equal in value
654:09 - to an object within the relevant
654:12 - collection
654:13 - to understand how the contains operator
654:15 - Works let's create an employee record
654:17 - that we know matches an employee record
654:20 - within the employee list collection
654:22 - let's copy this record for the employee
654:25 - named Douglas Roberts that is a member
654:27 - of the relevant employee collection
654:36 - and paste it in our main method
654:40 - let's name the variable that stores a
654:42 - reference to the employee record we wish
654:44 - to find within the employee list
654:46 - collection search employee
654:49 - so how can we assess whether the
654:51 - employee record pertaining to Douglas
654:53 - Roberts exists within the employee list
654:56 - collection
654:57 - we can use the contains extension method
655:01 - we can simply pass the variable we named
655:03 - search employee to the contains
655:05 - extension method which we have invoked
655:07 - on our employee list collection object
655:11 - so the contains method returns true if
655:13 - the search employee object matches any
655:16 - of the objects within the employee list
655:18 - collection and false if the search
655:20 - employee object does not match with any
655:22 - of the objects stored within the
655:25 - employee list collection
655:27 - so let's write code to write an
655:29 - appropriate narrative to the screen
655:30 - based on the Boolean value returned by
655:34 - our query
655:43 - foreign
655:52 - let's run the code
655:59 - and this is not the result we expected
656:01 - because we literally copied and pasted
656:03 - the code representing one of the
656:05 - employee objects that has been added to
656:07 - the employee list collection from our
656:09 - data class to the main method as our
656:11 - search object so why is our output
656:13 - indicating that the search employee
656:15 - object does not match any of the objects
656:17 - stored within our employee list
656:19 - collection this result is unexpected
656:23 - the answer is that the compiler knows
656:25 - how to compare built-in c-sharp types
656:27 - like for example integer or bull the
656:30 - employee type is a user-defined type or
656:33 - custom type we need to tell the compiler
656:35 - how we wish to compare two objects of
656:37 - type employee to establish where the two
656:40 - employee objects are equal
656:42 - so we can do this by creating a class
656:44 - that implements the generic I equality
656:47 - comparer interface
656:50 - the eye equality compare interface is a
656:53 - member of the
656:54 - system.collections.generic namespace
656:57 - we have already included a using
656:59 - directive to this namespace within our
657:01 - code
657:02 - so let's create a class named employee
657:04 - comparer and let's indicate that we want
657:07 - the employee comparer class to implement
657:09 - the I equality compare a generic class
657:12 - that is strongly typed with the employee
657:14 - user-defined type
657:16 - so let's hover our Mouse pointers over
657:18 - the red squiggly line and create the
657:20 - stubs for the methods that we need to
657:22 - implement like this
657:26 - so two method stubs have been generated
657:28 - one named equals and the other named get
657:31 - hash code so the get hash code method is
657:34 - used for the purpose of uniquely
657:35 - identifying an object we can implement
657:38 - the code for the get hashed code method
657:40 - by returning the hash code of the ID
657:43 - property of the relevant employee object
657:45 - like this
657:46 - the equals method must be implemented in
657:49 - a way that establishes how we wish
657:51 - employee objects to be compared when
657:54 - determining whether two employee objects
657:56 - are of equal value
657:58 - so let's say that we are satisfied with
658:00 - comparing the relevant employee objects
658:02 - based on their ID first name and last
658:05 - name properties to establish equality
658:07 - between the relevant employee objects
658:11 - so we can achieve this with the
658:13 - following code
658:14 - if the relevant properties are equal
658:15 - return true else return false
658:19 - so we are already passing in the search
658:21 - employee object to the contains method
658:24 - let's also pass a newly instantiated
658:26 - object of type employee comparer to an
658:30 - overload version of the contains method
658:32 - like this
658:33 - and now we are telling the compiler how
658:35 - we want to compare our employees search
658:37 - object with the objects stored within
658:40 - the employee list collection
658:46 - let's run the code
658:51 - and this is an expected result the
658:54 - contains method now returns true as
658:57 - expected because our search record
658:58 - matches the employee record for Douglas
659:01 - Roberts within the collection on which
659:03 - we are performing our search great
659:07 - so now let's look at the of type filter
659:10 - operator so before we use the of type
659:12 - filter operator in our code examples
659:14 - let's create a method named get
659:16 - heterogeneous data collection
659:19 - heterogeneous in this context of course
659:21 - is referring to the storage of objects
659:24 - of multiple different data types within
659:27 - the same collection
659:28 - so we can store objects of multiple
659:30 - different data types in an arraylist
659:33 - note that Microsoft does not recommend
659:35 - using arraylists for new development it
659:38 - is far better to use strongly typed
659:40 - lists to store collections of data
659:43 - for more detail as to why strongly typed
659:45 - lists are recommended please view a
659:48 - video on generics created by this
659:50 - channel a link to this video has been
659:52 - included Below in the description
659:54 - so a use case where we could apply a
659:57 - link query on an arraylist could be
660:00 - perhaps we have a legacy piece of code
660:02 - that includes an arraylist containing
660:04 - objects of multiple types and we need to
660:07 - filter the relevant arraylist based on
660:09 - specific types
660:11 - we can achieve this using the of type
660:13 - link operator
660:15 - we'll look at how we can do this in a
660:16 - bit let's first add some made up data to
660:19 - an arraylist
660:20 - so the arraylist stores integers strings
660:23 - objects of the employee user defined
660:26 - type and objects of the department
660:28 - user-defined type
660:43 - excuse me
661:04 - let's go to our main method and write
661:06 - code to use the of type operator to
661:09 - query this arraylist based on specified
661:11 - data types
661:13 - let's query for all string values in our
661:15 - arraylist
661:39 - great
661:42 - so let's query all integer values in our
661:45 - array list
662:02 - great let's query for all objects of the
662:06 - employee user defines type
662:36 - great let's query for all objects of the
662:39 - department user defines type
663:01 - excellent
663:05 - so you can see how we can query an
663:07 - arraylist for objects of a specified
663:09 - type using generics and the of type
663:12 - Operator by passing in the relevant type
663:14 - between angle brackets like this
663:17 - this will return those objects within
663:19 - the arraylist that are of the specified
663:21 - type
663:28 - let's move on to the element operators
663:30 - let's look at the element at element at
663:33 - or default first first or default last
663:36 - last or default single and single or
663:39 - default element operators
663:41 - so let's first look at the element at
663:43 - operator
663:44 - so the element at operator is used for
663:47 - querying for an item in a collection
663:50 - that resides at a specified ordinal
663:52 - location within the relevant collection
663:55 - so we can pass an integer value
663:57 - representing the relevant elements
663:59 - location in the relevant collection into
664:01 - the element add method to return the
664:03 - desired items value from the relevant
664:06 - collection like this
664:21 - great and our query has returned the
664:23 - value for the relevant element
664:28 - foreign
664:35 - but what happens if we pass in a value
664:37 - representing a position in the relevant
664:39 - collection where an element does not
664:41 - exist so let's try this let's pass in a
664:43 - value of 8.
664:56 - right so it is important to note that no
664:59 - item exists within the relevant
665:01 - collection at ordinal position 8. so in
665:04 - this case an argument out of range
665:06 - exception is thrown
665:09 - this brings us to an important point
665:11 - about the difference between the element
665:13 - at and the element at or default method
665:17 - if we replace the element at method with
665:19 - the element at or default method and we
665:22 - query the relevant collection for an
665:24 - item at a position where the desired
665:26 - item does not exist within the relevant
665:28 - collection the element at or default
665:30 - method does not throw an exception
665:33 - but rather Returns the default value for
665:36 - the desired items relevant data type
665:40 - let's briefly discuss what we mean by
665:43 - default value for a particular data type
665:45 - the c-sharp language Associates default
665:48 - values for c-sharp data types so if for
665:51 - example we are querying a collection of
665:53 - integers using the element at or default
665:56 - method for a value that did not exist at
665:59 - the specified location in the relevant
666:01 - collection the element at or default
666:04 - method would return the default value
666:06 - for the integer data type which is a
666:08 - value of zero
666:11 - the integer value of 0 is the default
666:13 - value for the integer data type in C
666:16 - sharp if however we are querying a
666:18 - collection containing a reference type
666:20 - object like an object of our
666:23 - user-defined type employee the default
666:25 - value returned by the element at or
666:28 - default method would be null null is the
666:31 - default value for reference type data
666:33 - types like user-defined types or the
666:35 - string data type
666:37 - for more detail regarding default values
666:39 - in c-sharp please navigate to this URL
666:44 - so let's use the element at or default
666:46 - method to query the relevant collection
666:48 - of employees for a value at position 8.
666:52 - I.E where no employee object is present
666:55 - within the relevant collection
666:56 - we can then write code to check if the
666:59 - returned value is null
667:09 - and you can see that an exception is not
667:11 - thrown and no results are outputted to
667:14 - the screen which is an expected result
667:16 - because the query returned a null value
667:32 - let's pass in a value of 2
667:40 - foreign
667:58 - and then one
668:04 - and in both cases the appropriate result
668:06 - is outputted to the screen
668:08 - so let's write code to Output an
668:10 - appropriate narrative to the user based
668:13 - on the value returned from the element
668:14 - at or default method
668:20 - so let's pass in a value of 12.
668:30 - the output indicating that the return
668:32 - value is null I.E the employee object
668:35 - does not exist in the collection as
668:37 - output to the screen this is an expected
668:39 - result great
668:42 - so the first operator Returns the first
668:44 - element in a collection if no condition
668:47 - is specified we have the option of
668:50 - passing a condition to the first method
668:52 - or we can leave the brackets following
668:55 - the first method empty if we do not
668:57 - specify a condition the query will
668:59 - return the first element in the relevant
669:01 - collection if a condition is specified
669:04 - the first operator will return the first
669:06 - element in the collection that satisfies
669:09 - the specified condition we can specify a
669:13 - condition in the form of a Lambda
669:14 - expression right to prove this let's
669:17 - first create a strongly typed list of
669:19 - integer values
669:20 - foreign
669:30 - this collection using the first operator
669:33 - and don't provide a condition passed as
669:35 - an argument to the first method
669:37 - the query Returns the first item in the
669:39 - collection as expected
669:42 - so let's pass a condition in the form of
669:44 - a Lambda expression to the first
669:46 - extension method
669:47 - so this condition is simply querying the
669:49 - collection for the first even number in
669:52 - the collection
669:53 - let's run the code
669:57 - great
670:01 - but now what happens if we alter the
670:03 - collection of values so that no value
670:06 - satisfies the condition I.E no even
670:08 - numbers exist within the relevant
670:10 - collection
670:18 - an invalid operation exception is thrown
670:21 - so if we don't want an exception to be
670:23 - thrown we can replace the first operator
670:25 - with the first or default operator
670:29 - as you may have guessed where no items
670:32 - in the relevant collection satisfy the
670:34 - relevant condition this method will not
670:36 - throw an exception but will rather
670:38 - return the default value of the relevant
670:40 - data type
670:42 - we know that the default value for the
670:44 - integer dates type is zero
670:47 - let's write code to Output an
670:49 - appropriate narrative to the screen if
670:51 - the relevant condition is not satisfied
670:58 - let's run the code
671:04 - and this is an expected result
671:07 - so let's include an element in the
671:09 - relevant list that does satisfy the
671:10 - condition
671:15 - excellent
671:18 - so the last and last or default
671:20 - operators work in much the same way as
671:22 - the first and the first or default
671:24 - operators the only difference is that
671:26 - the last item in the collection is
671:28 - returned where no condition is specified
671:35 - the last item that satisfies a specified
671:38 - condition and the collection is returned
671:40 - when a condition is specified
671:45 - the last method will throw an exception
671:47 - if an appropriate element is not present
671:50 - within the relevant list
672:02 - we can use the last or default method
672:04 - rather than the last method to return
672:06 - the default value for the relevant data
672:09 - type in the case where an appropriate
672:11 - element in the relevant collection is
672:13 - not present
672:25 - great so let's move on to the single and
672:28 - single or default element operators
672:31 - the single operator Returns the only
672:33 - element in a collection or one element
672:35 - that satisfies a specified condition
672:37 - from a collection
672:39 - we have the option of passing a
672:41 - condition into the single method through
672:43 - the use of a method overload or we can
672:45 - leave the brackets following the single
672:48 - method empty which means we have chosen
672:50 - not to pass in a condition into the
672:52 - single method
672:54 - if we choose not to pass in a condition
672:56 - into the single method and there's more
672:58 - than one element or zero elements in the
673:00 - collection and invalid operation
673:02 - exception will be thrown if however
673:05 - there is only a single element in the
673:07 - collection the value for this element
673:09 - will be returned by the query
673:13 - if we do choose to pass in a condition
673:15 - and zero or more than one element
673:17 - satisfies the condition an invalid
673:19 - operation exception will be thrown
673:22 - if we pass in a condition to the single
673:24 - method and only a single element
673:26 - satisfies the condition the value for
673:29 - this single element will be returned
673:31 - from the relevant single operation
673:34 - let's apply the single operator to a
673:36 - collection of employees
673:38 - let's first modify the data for our list
673:41 - of employees so that only one employee
673:43 - element exists within the relevant
673:46 - employee collection
673:51 - foreign
674:01 - let's write code using the single
674:03 - operator to query the relevant employee
674:06 - list
674:07 - foreign
674:12 - this is an expected result
674:18 - let's now include the employees that we
674:20 - just commented out back within the
674:22 - relevant employee list
674:30 - let's run the code
674:37 - and an invalid operation exception is
674:40 - thrown as expected this is because more
674:42 - than one employee resides in the list
674:45 - if there is only one item in the
674:48 - relevant collection the value for this
674:49 - item is returned
674:51 - if there are zero items or more than one
674:54 - item in the collection and the condition
674:56 - is not specified for the single operator
674:58 - and invalid operation exception is
675:01 - thrown
675:03 - so let's test the single method and this
675:06 - time specify a condition where one item
675:08 - within the relevant collection satisfies
675:11 - the specified condition
675:21 - great
675:22 - let's specify a condition where more
675:25 - than one item in the relevant collection
675:26 - satisfies the specified condition
675:35 - as you can see an invalid operation
675:37 - exception is thrown
675:40 - so let's test the same scenario I.E more
675:44 - than one element in the relevant
675:45 - collection satisfies the specified
675:47 - condition but this time let's use the
675:50 - single or default method
675:52 - that's interesting
675:54 - so note where more than one element
675:57 - satisfies the specified condition when
676:00 - the single or default method is applied
676:02 - and the relevant query an invalid
676:05 - operation exception is thrown just like
676:08 - when the single method is applied to
676:09 - perform the same operation
676:12 - so we can use the single or default
676:14 - method instead of the single method if
676:16 - we don't want an exception to be thrown
676:18 - under the scenario where no elements
676:21 - exist within the collection the default
676:24 - value for the data type will instead be
676:26 - returned by the query
676:28 - if a condition is specified for the
676:31 - single or default method and no elements
676:33 - satisfy the condition the same result
676:35 - will be produced I.E the default value
676:39 - for the data type of the elements stored
676:41 - in the collection will be returned by
676:44 - the query
676:46 - if a single item is present within the
676:48 - relevant collection and the single or
676:50 - default method is applied to perform a
676:52 - query against the relevant collection
676:54 - the single elements value that exists
676:56 - within the relevant collection will be
676:58 - returned by the query
677:01 - [Music]
677:10 - hi and welcome to the fourth and final
677:13 - part in this video series on the link
677:16 - technology using C sharp this video is
677:19 - also part of the seventh tutorial in an
677:21 - advanced c-sharp course
677:23 - this video is a continuation of the
677:25 - previous three videos in this video
677:27 - series on link so I recommend viewing
677:29 - the previous three videos in this video
677:32 - series before viewing this video
677:36 - in the previous video in this series we
677:39 - looked at code examples where certain
677:41 - link operators were implemented to query
677:43 - and transform data this video is a
677:46 - continuation of the previous video in
677:48 - this series where we'll create code
677:50 - examples using some of the other link
677:53 - operators to gain a broader
677:54 - understanding of what can be
677:56 - accomplished using the Link Technology
677:58 - in c-sharp so in the previous videos in
678:01 - this series we have created code
678:02 - examples using the following link
678:04 - operators
678:06 - the Sorting operators order by order by
678:09 - descending then buy and then by
678:11 - descending the grouping operators Group
678:14 - by and to lookup The quantifier
678:17 - Operators all any and contains
678:21 - the filter operators of type and where
678:24 - the element operators element at element
678:27 - at or default first first or default
678:31 - last last or default single and single
678:34 - or default the join operators join and
678:38 - group join
678:39 - we have already looked at the select
678:41 - projection operator and we'll also look
678:43 - at the select operator in this video and
678:46 - in addition to this we'll also look at
678:48 - the select many projection operator
678:52 - so in this video we'll look at the
678:54 - following link operators
678:56 - the equality operator sequence equal
678:59 - the concatenation operator concat
679:03 - the set operators distinct except
679:06 - intersect and Union
679:09 - the generation operators the fault of
679:12 - empty empty range and repeat operators
679:16 - the aggregate operators aggregate
679:19 - average count sum and Max
679:22 - the petitioning operators skip skip
679:25 - while take and take while
679:29 - the conversion operators to list two
679:31 - dictionary and two array
679:33 - and lastly the projection operators
679:36 - select and select many
679:39 - we'll also look at the following
679:41 - keywords that are useful when used in
679:43 - queries implemented in query syntax
679:46 - namely the let and into keywords
679:51 - we have looked at the select projection
679:52 - operator already in previous videos but
679:55 - we'll look at this operator again in
679:57 - this video as well as look at the select
679:59 - many projection operator we'll then be
680:01 - able to gain an understanding of the
680:03 - difference between the select and the
680:05 - select many projection operators
680:08 - as in the previous videos I'll be
680:10 - demonstrating the code examples on my
680:12 - Mac platform if you are using a Windows
680:15 - platform to follow along the experience
680:17 - of creating these code examples will be
680:19 - almost exactly the same so the fact that
680:22 - I'm using visual studio for Mac should
680:24 - not be a barrier for a learner using
680:26 - visual Studio for Windows to follow
680:28 - along with the creation of these code
680:30 - examples okay so let's create a.net core
680:34 - console project
680:37 - thank you
681:00 - so the official release of.net 5 has now
681:03 - been released so I'll be running this
681:06 - project using the new.net5.net runtime
681:10 - for more information on the significance
681:12 - of the.net 5 runtime please View the
681:14 - second part of this Advanced c-sharp
681:17 - course I've included a link to this
681:19 - video Below in the description
681:21 - the project we created in the last video
681:23 - was named link examples underscore 2.
681:26 - let's name this project link examples
681:28 - underscore 3.
681:43 - so as we did in the previous video let's
681:46 - navigate to this URL where we can access
681:49 - code on GitHub for the project that was
681:51 - created in the previous video of this
681:54 - series
681:55 - here we can copy the data related code
681:57 - that we created in our previous project
682:00 - so that we can reuse these data related
682:03 - classes in this project
682:06 - let's click the directory icon labeled
682:08 - link examples underscore 2.
682:11 - let's then click the file icon labeled
682:13 - program.cs
682:16 - let's copy the class named employee
682:20 - and paste the contents of our clipboards
682:22 - to our new project
682:25 - let's do the same for the Department
682:26 - class
682:32 - and the data class
682:36 - okay so we won't be using the get
682:38 - heterogeneous data collection method
682:40 - that resides in the data class in this
682:42 - video so let's delete this method
682:45 - let's refresh our memories about the
682:47 - classes we have just copied and pasted
682:49 - from GitHub the employee class contains
682:53 - a definition for an employee record
682:55 - the department class contains a
682:57 - definition for a department record
683:00 - the data class contains hard-coded made
683:02 - up data for employee records and
683:05 - Department Records the employee records
683:07 - are stored in a generic list strongly
683:09 - typed as employee the Department Records
683:12 - are stored in a generic list that is
683:14 - strongly typed as Department
683:17 - we can access the data stored in the
683:19 - employee list collection from calling
683:21 - client code in this case this will be
683:24 - the main method by calling the static
683:26 - method named get employees we can access
683:29 - the data stored in the department list
683:31 - collection by calling the static method
683:34 - named get departments note that the data
683:37 - class in which these methods reside is a
683:39 - static class
683:41 - let's navigate to the main method and
683:43 - before we create our example code let's
683:46 - add the appropriate using directives
683:49 - first let's add a using directive to the
683:53 - system.collections.generic namespace
683:55 - the generic list type is a member of
683:58 - this namespace
684:00 - let's also add a using directive to the
684:02 - system.link namespace once we have added
684:05 - our system.link using directive we can
684:08 - access our link operators on collection
684:10 - types that implement the I enumerable
684:13 - interface so for example list types
684:16 - implement the I enumerable generic
684:19 - interface so we are able to access
684:21 - extension methods stored within the
684:23 - innumerable static class which is a
684:25 - member of the system.link namespace by
684:28 - including a using directive to the
684:30 - system dot link namespace
684:32 - the queryable static class also includes
684:35 - link extension methods and is a member
684:37 - of the system.link namespace for more
684:40 - information on how extension methods
684:41 - work in c-sharp please view the first
684:43 - video in this video series a link to
684:46 - this video has been included Below in
684:49 - the description
684:50 - before we get started creating our code
684:52 - examples I want to draw your attention
684:54 - to what might be an issue for visual
684:57 - studio for Mac users when we run our
684:59 - code interactively through Visual Studio
685:01 - for Mac by default the output may appear
685:04 - in the terminal console window within
685:07 - visual studio for Mac like this
685:10 - this is absolutely fine for testing code
685:12 - but you may prefer to present the output
685:15 - externally I.E in a terminal console
685:18 - window outside of visual studio for Mac
685:22 - if you'd prefer to present your output
685:24 - externally I.E outside of visual studio
685:26 - for Mac please navigate to visual studio
685:29 - format preferences then Under The
685:31 - Heading marked other select the item
685:34 - labeled terminal
685:36 - in the right pane of the relevant dialog
685:39 - box ensure that the enable integrated
685:41 - terminal checkbox is unchecked
685:46 - this is obviously not a functional issue
685:48 - it really comes down to personal
685:49 - preference
685:53 - let's define a generic list variable
685:55 - named employee list that is strongly
685:57 - typed as employee and let's assign the
686:00 - collection of employee records returned
686:02 - by the data dot get employees static
686:05 - method to the employee list variable
686:08 - let's define a generic list variable
686:10 - named Department list that is strongly
686:13 - typed as department and let's assign the
686:16 - collection of Department Records
686:17 - returned by the data.get department
686:20 - static method to the department list
686:22 - variable okay so we are now ready to
686:25 - query and transform data using link
686:28 - so let's start with the equality
686:30 - operator sequence equal
686:33 - so the use case here is we want to
686:35 - compare two lists of data and we want to
686:38 - know if these two lists contain elements
686:40 - of equal value and each element in each
686:42 - of the relevant lists are stored in the
686:45 - same order if each item in each list
686:48 - matches in terms of value and order the
686:50 - sequence equal method will return true
686:52 - if any of the items in each of the
686:55 - relevant lists does not match in terms
686:57 - of value and order the sequence equal
686:59 - method returns false let's create a
687:02 - generic list named integer list one
687:06 - that are strongly typed as integer let's
687:09 - copy and paste this line of code to the
687:12 - next line let's change the name of the
687:15 - second list to integer list 2.
687:28 - let's run the code
687:33 - and the sequence equal method returns
687:35 - true because the values and sequence of
687:37 - elements in integer list 1 is identical
687:40 - to the values and sequence of elements
687:42 - in integer list 2.
687:45 - let's change the order of the items in
687:48 - integer list two so this sequence of
687:50 - values is not equal to the sequence of
687:52 - values stored in the list named integer
687:55 - list one
687:57 - let's run the code and this is an
688:00 - expected result
688:02 - let's change integer list to once again
688:04 - for good measure
688:10 - and this is an expected result great
688:13 - so let's change the data in integer list
688:15 - 2 so that the order and values in the
688:19 - lists are equal
688:21 - and now the result is true which is an
688:24 - expected result
688:26 - that was pretty straightforward I.E
688:28 - comparing two sequences of values of a
688:31 - primitive data type IE the integer data
688:34 - tab but what if we want to test this
688:36 - type of equality between two lists that
688:39 - are strongly typed with a complex type
688:42 - like for example our employee uses
688:44 - defined type
688:46 - so let's Define a variable named
688:48 - employee list compare as a generic list
688:50 - type that is strongly typed as employee
688:53 - and let's assign The Collection returned
688:56 - from the data dot get employee's static
688:59 - method to our employee list compare
689:01 - variable
689:03 - let's run a sequence equal operation and
689:05 - compare the values stored within our
689:07 - employee list compare collection with
689:09 - the values stored within the employee
689:12 - list collection
689:13 - so one would expect the result of the
689:16 - sequence equal operation to return true
689:18 - because both collections contain exactly
689:21 - the same data let's see what happens
689:30 - oh and false is returned
689:33 - the reason why false is returned is
689:36 - because we need to tell the compiler how
689:38 - to establish equality between objects of
689:42 - the relevant complex type IE in this
689:44 - case the employee type so we achieved
689:47 - this in the previous video in this
689:48 - series by implementing the built-in I
689:51 - equality comparer generic interface so
689:55 - let's copy the relevant code for this
689:56 - that we implemented in the previous
689:58 - video in the series
690:00 - let's navigate to the GitHub repository
690:02 - at this URL that contains the code we
690:06 - created in the previous video in this
690:08 - series
690:10 - let's copy the class named employee
690:13 - comparer to our clipboards
690:15 - and paste the contents of our clipboards
690:17 - to our projects like this
690:22 - we have red squiggly lines so let's fix
690:24 - this by bringing in the appropriate
690:26 - using directive so here we have
690:28 - implemented a class named employee
690:30 - comparer that implements the generic I
690:32 - equality compare interface that is
690:34 - strongly typed as employee
690:37 - this gives us a way of telling the
690:39 - compiler how we want objects
690:42 - in our lists of type employee to be
690:44 - compared when determining equality
690:47 - between the relevant objects
690:50 - so we are explicitly doing this here in
690:53 - the equals method where we are comparing
690:55 - the ID first name and last name
690:57 - properties between two employee objects
691:01 - we are returning true if the relevant
691:03 - properties of the relevant two objects
691:05 - are equal and false is returned if any
691:08 - of the relevant properties of our two
691:10 - objects are not equal
691:12 - within the get hash code method we are
691:14 - returning the hash code of the ID
691:17 - property of the relevant employee
691:19 - objects for more information on hash
691:21 - codes please navigate to this URL
691:26 - so now let's go to our main method and
691:28 - we can pass in a new instance of the
691:31 - employee comparer class to an overloaded
691:34 - version of the sequence equal method
691:36 - this object will tell the compiler
691:38 - explicitly how we want our employee
691:41 - objects to be compared
691:43 - let's run the code
691:48 - and now the sequence SQL operator works
691:50 - as expected so note that we need to tell
691:53 - the compiler how we want objects that
691:55 - are defined as complex types to be
691:58 - compared when determining equality
692:00 - between the relevant objects
692:02 - we can do this by creating a class that
692:05 - appropriately implements the I equality
692:08 - comparer generic interface great
692:11 - let's move on to the concatenation
692:13 - operator named concat
692:16 - we can use the concat operator to append
692:18 - one collection of data to another
692:20 - collection of data
692:22 - so let's see the concat operator in
692:25 - action let's create a collection of
692:27 - integer values
692:32 - let's then create another collection of
692:34 - integer values
692:40 - let's append the second collection of
692:42 - integer values with the first collection
692:45 - of integer values using the concat
692:47 - operator
692:48 - let's write code to Output the results
692:51 - of this concatenation operation to the
692:53 - screen
692:54 - let's run the code
693:00 - great
693:02 - let's do another example but this time
693:05 - let's append a collection that contains
693:07 - a collection of objects of a complex
693:09 - type to another collection of objects of
693:12 - the same complex type the complex type
693:14 - we'll use in this example will be our
693:17 - employee user defined type once again we
693:21 - can use the concat operator to achieve
693:23 - what we want here
693:38 - let's run the code
693:44 - great
693:45 - let's move on to the aggregate operators
693:49 - let's first look at the aggregate
693:52 - operator
693:53 - using the aggregate operator we can
693:55 - perform a custom operation on values
693:57 - within a collection
693:59 - let's say we have a requirement where we
694:01 - need to provide a total for the annual
694:03 - salaries of our employee records
694:06 - we also need to include the addition of
694:08 - an appropriate annual salary bonus in
694:11 - the final result let's say a manager
694:14 - gets a bonus of four percent and
694:16 - employees that aren't managers get a
694:18 - bonus of two percent so let's say we
694:21 - have a use case where we need a result
694:22 - that is a total of all employee annual
694:25 - salaries which must include each
694:28 - employee's bonus
694:30 - we can take this added complexity into
694:32 - account when totaling up our employee
694:35 - annual salaries through the use of the
694:37 - aggregate operator
694:41 - so the first argument is the seed value
694:45 - so let's provide zero for this argument
694:48 - using this argument we are initializing
694:51 - the value that will be returned by our
694:53 - aggregate operator
694:55 - the next argument is of a delegate type
694:58 - where we can include the logic for our
695:01 - aggregation functionality in the form of
695:03 - a Lambda expression so as you can see in
695:05 - our Logic for the relevant Lambda
695:07 - expression argument we are checking to
695:09 - see if the relevant employee is a
695:11 - manager whereby we need to add a bonus
695:14 - of four percent to the relevant
695:16 - employees annual salary if the employee
695:19 - is not a manager we need to add a bonus
695:21 - of two percent to the relevant employees
695:23 - annual salary
695:25 - we can then include the appropriate
695:27 - bonus amount in our calculation so we
695:30 - are adding up all employee annual
695:32 - salaries which includes each employee's
695:35 - appropriate bonus
695:37 - let's run the code
695:42 - great
695:49 - say we want to Output a comma delimited
695:52 - string from our employee list collection
695:55 - each delimited item containing the
695:58 - employee full name a dash then the
696:01 - employee annual salary each annual
696:03 - salary must include the appropriate
696:05 - bonus
696:06 - we also want to include a label
696:08 - preceding the comma delimited string
696:12 - we can achieve this using the aggregate
696:14 - operator like this
696:17 - the first argument is the label where an
696:20 - appropriate value could be something
696:22 - like employee annual salaries including
696:24 - bonus
696:26 - then the logic of our aggregation
696:28 - functionality
696:29 - can be expressed in a Lambda expression
696:32 - for the second argument like this
696:35 - we can apply the same logic to include
696:37 - appropriate bonuses from our previous
696:39 - example
697:07 - let's run the code
697:11 - great but we have a slight issue where a
697:14 - comma is presented at the end of our
697:16 - string
697:18 - we don't want this comma in our final
697:21 - result
697:22 - we can express this by passing a Lambda
697:24 - expression as our third argument to an
697:27 - overloaded version of the aggregate
697:28 - operator
697:30 - this argument allows us to perform a
697:32 - final operation on the results produced
697:35 - by the Lambda expression passed in as
697:37 - the second argument
697:39 - we first need to include another data
697:42 - type argument with an angle brackets
697:44 - following the aggregate method to
697:46 - declare the data type of the final
697:48 - output I.E provided by the Lambda
697:50 - expression we are passing in to the last
697:52 - parameter of this overloaded version of
697:55 - the aggregate method
697:58 - in the Lambda expression passed in as
698:00 - our final argument we are using the
698:02 - substring method to remove two
698:04 - characters from the end of the result
698:07 - which means a comma and a space will be
698:10 - removed
698:15 - this result is what we want excellent
698:19 - so let's move on to the average
698:21 - aggregate operator
698:23 - so to find the average annual salary for
698:25 - a list of employees we can apply this
698:28 - code
698:42 - great if we want to find the average
698:45 - salary for all employees in the
698:47 - technology department we can use method
698:49 - chaining and the where operator to
698:52 - achieve this like this
699:03 - great
699:05 - for more information on method chaining
699:07 - please View the second part of this
699:10 - video series
699:12 - let's move on to the count aggregate
699:14 - operator
699:15 - so if we want to know how many employee
699:18 - records we have in our collection of
699:19 - employee records we can apply the count
699:21 - operator like this
699:25 - great
699:26 - if we want to know how many employees or
699:29 - members of the technology department we
699:31 - can pass in a condition as an argument
699:33 - to the count operator
699:35 - the condition that is passed in as an
699:38 - argument to the count method can be
699:40 - expressed in the form of a Lambda
699:41 - expression
699:44 - great
699:45 - let's move on to the sum aggregate
699:48 - operator so let's keep this simple we
699:51 - just want the sum total of all annual
699:54 - salaries of all employee records stored
699:57 - in our employee list collection we can
700:00 - apply the sum operator to achieve this
700:04 - great
700:05 - let's move on to the max aggregate
700:08 - operator
700:09 - so if we want to return the highest
700:11 - annual salary property of all employee
700:14 - records stored in our employee list
700:16 - collection we can apply the max
700:18 - aggregate operator in a link query like
700:21 - this
700:23 - great
700:24 - let's move on to the generation
700:26 - operators namely default of empty empty
700:30 - range and repeat
700:33 - let's first look at the default fmt
700:36 - operator
700:37 - so we can use the default if empty
700:39 - operator to return a new I enumerable
700:42 - collection that when for example we
700:44 - apply the element at method on the new
700:46 - collection to check if the new
700:48 - collection is empty the operation will
700:50 - return the default value for the
700:52 - relevant type used to strongly type the
700:55 - relevant collection
700:58 - a query using for example the element at
701:01 - method against a collection returned
701:04 - from a default of empty operation will
701:06 - not throw an exception if the collection
701:08 - is empty the default value of the type
701:12 - with which the relevant collection is
701:14 - strongly typed will instead be returned
701:16 - for more information on default values
701:19 - for C sharp dates types please navigate
701:21 - to this URL
701:23 - we'll see later how we can pass in a
701:26 - value to the default of empty method to
701:29 - specify our own default value that we'd
701:32 - prefer to be returned when for example
701:34 - the element at method is used to check
701:36 - if the relevant collection is empty
701:38 - rather than the default c-sharp value
701:41 - for the relevant data type
701:43 - let's look at an example using the
701:45 - default fmt method
701:47 - so let's create an empty list of integer
701:50 - values let's perform a default fmt
701:53 - operation on this collection of integer
701:56 - values and assign The Returned
701:57 - collection to a new collection of
701:59 - integer values let's use the element at
702:02 - operator and pass in 0 to the element at
702:04 - method to check if the collection is
702:06 - empty
702:13 - you can see that the element at operator
702:16 - Returns the default value for the
702:18 - integer data type which is zero this is
702:20 - an expected result let's create another
702:23 - example but this time let's use the
702:25 - employee data type to strongly type our
702:27 - collections as discussed the default
702:30 - value for a reference type in c-sharp is
702:33 - null
702:33 - but as discussed we can pass in a
702:36 - default value that we would prefer to be
702:38 - returned by for example the element at
702:41 - operator when the relevant collection is
702:43 - empty
702:44 - so let's person an employee object where
702:48 - the ID property of the relevant employee
702:50 - object is set to zero
702:53 - null is not returned as would be the
702:55 - case if we hadn't passed in a value to
702:58 - the default fmt method because we have
703:00 - specified our own default value where
703:03 - the ID property of the default employee
703:05 - object is zero
703:15 - great
703:18 - similarly we could have set the default
703:21 - value for our integer collection example
703:24 - by for example passing in 999 999 to the
703:29 - default if empty method instead of
703:32 - returning the default c-sharp value for
703:34 - an integer which is 0
703:37 - 99999 is returned this is an expected
703:40 - result excellent
703:43 - right let's look at the empty method
703:47 - so we can use the empty method to
703:49 - generate a new empty collection
703:53 - so for example we want to create a new
703:55 - innumerable generic collection of
703:57 - employee records we can do this by using
704:00 - the empty operator like this
704:03 - note the empty method is not an
704:05 - extension method of innumerable or I
704:08 - queryable like other link methods it is
704:10 - a static method included in the
704:13 - enumerable static class
704:15 - so for example we could instantiate a
704:18 - new empty generic list strongly typed
704:20 - with the employee user defined type
704:22 - through the use of the empty method
704:25 - we can then chain the two list
704:27 - conversion operator to this operation
704:30 - and return an empty generic list we are
704:33 - using the two list operator to convert
704:35 - an i enumerable generic collection that
704:37 - is strongly typed with the employee data
704:39 - type to a generic list that is strongly
704:42 - typed as employee
704:44 - so for good measure let's add a new
704:46 - employee item to our new list that we
704:49 - have generated through the use of the
704:50 - empty method and the use of the two list
704:53 - conversion operator
704:55 - let's write code to write the items or
704:58 - in this case one item stored in our new
705:00 - list to the screen
705:08 - great
705:10 - let's move on to the range generation
705:12 - operator
705:14 - we can use the range operator to return
705:16 - a collection of values that are within a
705:19 - specified range so let's clarify this
705:21 - with an example
705:23 - we want to return a range of integer
705:25 - values in a collection where the first
705:27 - item in the range has a value of 25 and
705:30 - each subsequent item is incremented by a
705:32 - value of 1 until there are a total of 20
705:36 - values in the relevant collection
705:39 - we can achieve this by using the range
705:42 - method like this
705:43 - in this example the first argument
705:45 - specified is 25.
705:47 - this is the value of the first element
705:49 - and the second argument specifies the
705:52 - number of elements to include in the
705:54 - relevant generated collection
705:56 - when each item is added to the
705:59 - collection It Is incremented by a value
706:01 - of one so the second item will be 26 the
706:04 - third item will be 27 the fourth item
706:07 - will be 28 and so on
706:08 - let's run the code
706:11 - great so using the range operator we
706:14 - have generated a collection of integer
706:16 - values that fall within a specified
706:18 - range excellent
706:20 - let's say we want to generate a
706:21 - collection of a specified amount of
706:24 - elements where a value for each element
706:26 - in the collection is repeated
706:28 - we can use the repeat operator for this
706:30 - purpose like this
706:51 - great
706:52 - let's move on to the set operators
706:54 - namely distinct except intersect and
706:58 - Union
706:59 - let's start with distinct
707:02 - so let's say we have a strongly typed
707:03 - generic list that contains a list of
707:06 - integer values some of which are
707:08 - repeating values we want to perform a
707:11 - query against this list of integer
707:13 - values where we only want distinct
707:15 - values returned
707:17 - we can achieve this by applying the
707:19 - distinct operator to our query like this
707:39 - great
707:40 - let's say that we have two collection of
707:43 - a specific type and we want to return
707:45 - elements with values in our first
707:47 - collection that are not equal to any of
707:50 - the values of the elements in our second
707:52 - collection we can achieve this by using
707:54 - the accept operator let's look at an
707:57 - example of using the accept operator
707:59 - applied to two collections of integer
708:02 - values
708:26 - so one and two are returned in our
708:29 - results collection because these values
708:31 - exist in our first collection and don't
708:33 - exist in the second collection
708:35 - the values 3 and 4 exist in our first
708:38 - collection and also exist in our second
708:41 - collection
708:42 - the values five and six exist in our
708:45 - second collection and even though these
708:46 - items don't exist in our first
708:48 - collection
708:49 - the accept operator does not return
708:52 - these items as part of the results
708:54 - collection because in this example the
708:57 - accept operator returns values that
709:00 - exist in the first collection and don't
709:02 - exist in the second collection
709:04 - let's try an example using complex types
709:07 - let's use our employee type
709:10 - let's create a generic list strongly
709:12 - typed as employee
709:14 - let's copy data
709:17 - that we know will exist within our
709:19 - employee list collection and add these
709:21 - items to the list we have named employee
709:24 - list 2. let's add some additional items
709:27 - to the employee list to collection
709:49 - let's then call the accept method on the
709:52 - employee list collection and pass in the
709:54 - employee list 2 collection as an
709:56 - argument to the accept method then let's
709:59 - assign the results of this operation to
710:01 - an implicitly typed variable named
710:04 - results
710:05 - we have of course used the VAR keyword
710:07 - to implicitly type our results variable
710:10 - let's write code to Traverse the results
710:12 - and output the results to the screen
710:39 - let's run the code and see what happens
710:42 - and this result is not expected the
710:45 - output contains all items within the
710:48 - employee list collection
710:49 - I would have expected that the items
710:51 - that were copied from the data class and
710:54 - added to the employee list 2 collection
710:56 - as well as the other items that we added
710:59 - to the employee list collection would be
711:01 - excluded from the results
711:04 - the reason for the unexpected results is
711:07 - because we have not told the compiler
711:09 - how to compare employee objects when
711:11 - determining if one employee object is
711:14 - equal to another employee object
711:16 - so how can we let the compiler know how
711:19 - we want one employee to be compared to
711:21 - another employee within our collections
711:23 - when determining equality between the
711:26 - two relevant objects
711:28 - you may have guessed already how we can
711:30 - achieve this we first need to create a
711:32 - class that implements the eye equality
711:34 - comparer generic interface
711:37 - we can then write code to establish how
711:39 - one employee object should be compared
711:41 - to another employee object when
711:43 - determining equality between the
711:45 - relevant objects
711:47 - we have already included the code for
711:49 - this which we applied when we created
711:52 - code to perform a sequence equal
711:54 - operation on two lists that were
711:56 - strongly typed as an employee so we have
711:59 - our class named employee comparer that
712:01 - implements the IE quality comparer
712:03 - generic interface
712:05 - so we can reuse this class for our
712:07 - example that performs an accept
712:09 - operation on two generic lists that are
712:12 - strongly typed as employee
712:15 - so all we need to do is create a new
712:18 - object of type employee comparer and
712:20 - pass this object into an overloaded
712:23 - version of the accept method like this
712:27 - let's run the code
712:31 - great
712:33 - this is now an expected result let's
712:36 - move on to the intersect operator
712:40 - so we can use the intersect set operator
712:42 - to return a collection containing only
712:45 - those items that exist in the employee
712:48 - list collection that are equal to the
712:50 - items that exist within the employee
712:52 - list 2 collection
712:53 - and now that we know we are comparing
712:55 - elements in two collections that are
712:57 - strongly typed with the employee complex
713:00 - type we need to pass in a new object of
713:03 - the employee comparer type I.E a type
713:05 - that appropriately implements the
713:07 - generic IE quality comparer interface
713:10 - this tells the compiler how to compare
713:12 - two objects of type employee when
713:14 - determining if the relevant employee
713:16 - objects are equal let's run the code
713:25 - and this is an expected result great
713:29 - let's move on to the union operator the
713:32 - union extension method requires two
713:34 - Collections and returns a new collection
713:36 - that includes distinct elements from
713:39 - both the collections
713:41 - we can again use the same data we have
713:44 - used in the previous two examples to
713:47 - test the union operator right let's
713:49 - write the code for this you will notice
713:51 - we are also passing in an object of type
713:53 - employee comparer to the union method
713:57 - Let's test the code
714:02 - great
714:03 - so let's see what happens in this
714:05 - example when we don't pass in an object
714:07 - of type employee comparer to the union
714:10 - method
714:14 - you can see that duplicate records are
714:16 - included in the results as a consequence
714:18 - of not passing in an object derived from
714:21 - a class that appropriately implements
714:23 - the generic IE quality comparer
714:25 - interface and of course we know we have
714:27 - already created such a class so let's
714:29 - ensure that we pass in our object of
714:31 - type employee comparer to the union
714:33 - method so that only distinct employee
714:36 - objects are included within our results
714:39 - excellent
714:41 - so let's move on to the partitioning
714:43 - operators these partitioning operators
714:45 - include the skip skip while take and
714:48 - take while operators
714:50 - let's first look at the skip operator
714:52 - use the skip operator to skip over a
714:55 - given number of elements in a sequence
714:57 - and then return the remainder
715:00 - so let's query our employee list
715:02 - collection using the skip operator
715:05 - let's skip over two of the elements
715:07 - stored in our employee list collection
715:09 - and return the remainder of the elements
715:12 - using the skip operator
715:19 - great this is an expected result
715:22 - let's look at the skip wow operator
715:24 - using the skip while operator bypasses
715:27 - elements in a sequence as long as a
715:30 - specified condition is true and then
715:32 - Returns the remaining elements
715:35 - let's see this operator in action
715:38 - so the condition here is Skip elements
715:41 - in our sequence of employee objects in
715:43 - the employee list collection while the
715:45 - relevant employee object's annual
715:47 - salaries are above 50 000.
715:57 - great this is an expected result
716:02 - just to make things a little bit more
716:04 - clear on how this operator Works let's
716:06 - add a new employee record to the
716:08 - employee list collection this employee
716:11 - record has an annual salary of one
716:13 - hundred thousand which of course is
716:15 - above fifty thousand
716:21 - let's run the code
716:25 - and you can see that while the condition
716:27 - is true the items in the relevant
716:29 - collection are skipped I.E will not be
716:32 - returned from the query however all
716:34 - subsequent elements in the sequence will
716:37 - be returned once the condition returns
716:39 - false
716:40 - even though the last element in the
716:42 - relevant sequence has an annual salary
716:44 - property greater than fifty thousand it
716:47 - is still returned because the third
716:49 - element in the sequence caused the
716:51 - condition to return false
716:54 - the fact that the last element has an
716:56 - annual salary above 50 000 and therefore
716:59 - causes the condition to be true doesn't
717:01 - mean that the last item will be returned
717:04 - by our query note that once the
717:07 - condition returns false all items from
717:09 - that point will be returned from our
717:12 - query
717:13 - right let's move on to the take
717:15 - partition operator
717:17 - the take operator is used to return a
717:20 - specified number of contiguous elements
717:22 - from the start of a sequence
717:24 - let's see this operator in action
717:37 - this is an expected result great
717:41 - the first two elements in the relevant
717:43 - sequence of elements in our employee
717:46 - list collection are returned by our
717:48 - query
717:49 - so let's move on to the take while
717:51 - partitioning operator
717:53 - the take while operator returns elements
717:55 - from a sequence as long as a specified
717:58 - condition is true and then skips the
718:00 - remaining elements
718:03 - so let's use the same condition that we
718:05 - used in the skip while operator example
718:08 - so here we are using the take while
718:10 - operator to return elements from the
718:13 - relevant sequence that have an annual
718:15 - salary above 50 000. so the first two
718:19 - elements in the sequence are returned by
718:20 - our query
718:22 - as soon as the third element is
718:23 - evaluated and the condition returns
718:25 - false the elements from that point
718:28 - onwards in the relevant sequence will
718:30 - not be returned by our query
718:33 - so for example the fact that the fifth
718:36 - element in the employee list collection
718:38 - has an annual salary property that is
718:40 - greater than 50 000 is irrelevant
718:42 - because when the third element causes
718:45 - the condition to return false and in
718:47 - terms of the take while operator this
718:49 - means that from that point onwards the
718:52 - rest of the elements and the relevance
718:53 - sequence will not be returned by our
718:56 - query great
718:58 - let's look at the conversion operators
719:00 - to list two dictionary and two array
719:04 - so let's look at the two list conversion
719:07 - operator a query written and query
719:09 - syntax will return an i enumerable
719:12 - collection containing the results of the
719:14 - query what if we need our results to be
719:17 - returned as a generic list
719:19 - we can achieve this using the two list
719:22 - conversion operator
719:24 - let's create an example to clarify this
719:26 - point
719:28 - so for this example let's query our
719:30 - employee list collection for employee
719:33 - records that have an annual salary
719:35 - property greater than 50 000 using query
719:38 - syntax
719:40 - note the red squiggly lines here
719:42 - this is because we are attempting to
719:45 - assign an inumerable collection to a
719:48 - variable of type generic list
719:51 - the compiler is telling us that we have
719:54 - created a type mismatch
719:57 - so we can use the two list operator to
719:59 - convert the I enumerable collection
720:00 - returned by our query to a generic list
720:03 - by wrapping the relevant query in
720:06 - Brackets adding a DOT after the last
720:09 - bracket and applying the two list
720:11 - operator like this so now you can see
720:13 - the red squiggly lines disappear because
720:16 - we have removed the type mismatch
720:19 - let's run the code
720:29 - excellent
720:30 - as discussed earlier in this video
720:32 - series wherever a two conversion
720:35 - operator is applied to a query as we
720:37 - have done here
720:38 - this causes the query to execute
720:40 - immediately I.E query execution is not
720:44 - deferred it is executed immediately
720:48 - so if we want to convert an innumerable
720:51 - collection returned from a query to a
720:54 - dictionary object
720:55 - we can apply the two dictionary operator
720:58 - to the query let's create an example to
721:01 - clarify what is meant by this
721:03 - so as in the previous example here we
721:06 - have a standard query written in query
721:09 - syntax to query our employee list
721:11 - collection for all elements where the
721:13 - relevant elements have annual salary
721:15 - properties that have values greater than
721:18 - fifty thousand so this is a basic query
721:21 - that will return an i enumerable
721:23 - collection
721:25 - but what if we want to return a
721:28 - collection where each element has a
721:30 - unique key associated with the relevant
721:32 - element
721:33 - we can do this by converting the query
721:35 - result to a dictionary generic
721:38 - collection type
721:40 - so let's alter our code so that the
721:42 - innumerable collection returned by our
721:45 - query is converted into a generic
721:47 - dictionary collection So within angle
721:50 - brackets after two dictionary we need to
721:52 - pass in two data types the first data
721:56 - type declares the data type of the
721:58 - values stored in the dictionary
722:00 - the second data type declares the data
722:02 - type of the key that will be used to
722:05 - uniquely identify each element in the
722:07 - collection so the First Dates type is of
722:10 - type employee and the second data type
722:12 - is of type int note that we want each
722:15 - element to be keyed on the employee ID
722:19 - property
722:20 - we can express this by passing in an
722:23 - appropriate Lambda expression to the two
722:25 - dictionary method like this
722:28 - so let's Traverse the key values stored
722:31 - in our dictionary object using a for
722:33 - each Loop
722:34 - note how we are able to use the key
722:36 - values to retrieve the values of each
722:39 - element stored in the dictionary
722:42 - we are doing this by passing in the
722:44 - relevant key within square brackets to
722:47 - the dictionary object
722:50 - here we are outputting the key as well
722:52 - as each employee's first name and last
722:54 - name to the screen
723:06 - and as you can see we have each
723:08 - employee's ID which we have designated
723:11 - as our key value followed by the
723:14 - corresponding employees first name and
723:16 - last name properties excellent
723:19 - we have successfully converted a query
723:21 - result from an innumerable collection to
723:25 - a dictionary object
723:27 - as discussed when we call any of the two
723:30 - conversion operators on a query result
723:32 - this causes our query to execute
723:35 - immediately for more information on
723:37 - deferred execution versus immediate
723:39 - execution please View the second part of
723:42 - this video series
723:45 - for good measure let's also create a
723:48 - result using the two array conversion
723:50 - method
723:51 - so if we try to assign the results of
723:54 - this query to a variable defined as an
723:57 - array of employees the compiler
723:59 - complains of a type mismatch the query
724:02 - result is returned as an innumerable
724:05 - collection and not an array of employee
724:07 - objects
724:09 - to remove the tap mismatch we can apply
724:11 - the two array method like this
724:27 - great
724:29 - so let's discuss the let and the intu
724:31 - Clauses that can be applied when using
724:34 - query syntax to represent a link query
724:38 - let's look at the Microsoft docs for an
724:41 - overview of the let Clause this overview
724:44 - of the let Clause can be found at this
724:46 - URL
724:48 - in a query expression
724:50 - it is sometimes useful to store the
724:53 - result of a sub-expression in order to
724:57 - use it in subsequent clauses
725:00 - you can do this with the let keyword
725:04 - which creates a new Range variable and
725:07 - initializes it with the result of the
725:10 - expression you supply
725:13 - once initialized with a value the range
725:16 - variable cannot be used to store another
725:19 - value
725:20 - however if the range variable holds a
725:23 - queryable type it can be queried
725:28 - so let's look at a basic example using
725:30 - the let keyword in a link query
725:33 - let's say we wish to query our employees
725:36 - based on employee initials now we don't
725:40 - have an initials property for an
725:41 - employee record but within our query
725:44 - using the let keyword we can extract the
725:47 - initials from each employee records
725:49 - first name and last name properties and
725:51 - assign the result
725:53 - of this extraction process to a variable
725:56 - named initials directly within our query
725:59 - using the lit keyword this allows us to
726:03 - use the initials variable in our where
726:05 - Clause as well as reuse the initials
726:07 - variable within our select clause
726:11 - through the use of the let Clause we can
726:14 - also apply a condition and based on the
726:17 - evaluation of that condition store a
726:20 - value in a variable that can be used
726:22 - later in the query like for example
726:25 - within aware clause
726:28 - here we have a condition where we need
726:30 - to add an appropriate bonus to the
726:32 - annual salary property based on whether
726:35 - the employee is a manager or not a
726:37 - manager if the employee is a manager we
726:40 - need to add a bonus of four percent to
726:41 - the relevant employee records annual
726:43 - salary property
726:45 - if the employee is not a manager we need
726:47 - to add a bonus of two percent to the
726:49 - relevant employee records annual salary
726:51 - property we can store the relevant
726:54 - annual salary plus bonus value for each
726:56 - employee record by assigning the value
726:58 - returned by a ternary operator to a
727:01 - variable we have named this variable
727:03 - annual salary plus bonus the let clause
727:06 - in this example enables us to reuse the
727:09 - annual salary plus bonus variable both
727:11 - within the where clause and the select
727:13 - Clause later in the query
728:05 - let's run the code
728:16 - excellent
728:18 - let's look at the into keyword
728:21 - we can use the into keyword in a link
728:23 - query to collate data within a group and
728:26 - then after this operation we are able to
728:28 - perform a filter operation within the
728:31 - same query if required on the grouped
728:34 - data through the use of aware clause
728:37 - so for example let's use a link query to
728:40 - First create a group of high earning
728:42 - employees based on a condition let's say
728:46 - that the employee must earn above 50 000
728:48 - to fit into the relevant group we can
728:51 - use the where Clause at this point in
728:53 - the query to appropriately filter the
728:55 - relevant employee records and the into
728:58 - keyword to put the filtered data into
729:01 - the relevant group of high earning
729:03 - employees
729:05 - so we can use the into keyword to group
729:07 - The High earning employees into a group
729:09 - named High earners let's say we then
729:12 - want to further filter this group of
729:14 - high earning employees by management
729:17 - status
729:18 - so we only want these employee records
729:21 - where the is manager property is set to
729:23 - true return from our query
729:26 - we want to know which of those High
729:28 - earning employees are managers
729:31 - so we can use another where Clause
729:33 - within our query to filter the high
729:35 - earner group based on the relevant
729:37 - condition
729:38 - we have used a where Clause earlier in
729:40 - our query to create the group of high
729:42 - earning employees
729:44 - then once the group is created through
729:46 - the use of the into keyword we can
729:49 - further filter the group of high earning
729:51 - employees based on each employee records
729:54 - is manager property
729:56 - so we are able to include another where
729:58 - clause in our query to filter the
730:00 - grouped data let's run the code
730:08 - great
730:09 - so lastly let's look at the select and
730:12 - the select many projection operators
730:15 - in this video series we have already
730:17 - looked at the select projection operator
730:19 - so the focus in this example is on the
730:23 - select many operator
730:25 - we want to know how it differs from the
730:27 - select operator and in what
730:29 - circumstances we may wish to apply the
730:31 - select many operator in a link query
730:34 - let's navigate to a Microsoft docs
730:36 - webpage to see what the Microsoft docs
730:39 - say about these two projection operators
730:43 - projection refers to the operation of
730:46 - transforming an object into a new form
730:49 - that often consists only of those
730:52 - properties that will be subsequently
730:54 - used
730:55 - by using projection we can construct a
730:59 - new type that is built from each object
731:02 - you can project a property and perform a
731:05 - mathematical function on it you can also
731:07 - project the original object without
731:10 - changing it
731:11 - select projects values that are based on
731:15 - a transform function
731:17 - select many projects sequences or values
731:21 - that are based on a transform function
731:23 - and then flattens them into one sequence
731:27 - to understand the difference between the
731:30 - select many operator and the select
731:32 - operator let's modify our department
731:34 - class so that it includes a property
731:36 - that stores a collection of employees
731:39 - we have already discussed that
731:41 - Department Records have a one-to-many
731:43 - relationship with employee records so
731:46 - each department object will now store a
731:49 - collection of related employee records
731:52 - let's also alter the get Department's
731:55 - static method that resides in the data
731:57 - static class so that the get
731:59 - Department's static method accepts an
732:02 - argument containing a collection of
732:04 - employee objects
732:06 - then for each department object added to
732:08 - the department list collection within
732:10 - the get Department static method let's
732:12 - include a query to return an appropriate
732:15 - collection of employees I.E those
732:17 - employee records that have a department
732:19 - ID property matching the ID property of
732:23 - the relevant Department object
732:38 - so let's go to the main method and pass
732:40 - in the collection of employees to the
732:42 - get Department method so now the get
732:45 - departments method will return a
732:46 - collection where each department
732:48 - contains a related collection of
732:51 - employee records
732:54 - so now what if we want to query the
732:56 - department list collection for all
732:59 - employees we can achieve this using the
733:02 - select operator but when traversing the
733:04 - results of the select operation we will
733:07 - need to use an outer and an inner for
733:09 - each Loop like this
733:11 - in this scenario the select many
733:14 - operator is better to use for this
733:17 - purpose the select many operator is
733:19 - better in this case because we can use
733:22 - one for each Loop to Traverse the
733:24 - results of our query
733:26 - unlike where we needed to use an
733:29 - additional nested for each Loop to
733:31 - Traverse the results of our query
733:33 - where we used the select operator
733:38 - behind the scenes as it were the select
733:40 - many operator appropriately flattens the
733:42 - results
733:43 - and this means we don't need to use a
733:46 - nested for each Loop to Traverse the
733:48 - results of our query
733:49 - we are able to use one for each Loop for
733:52 - this purpose
734:13 - excellent
734:15 - so we have covered a lot of ground in
734:18 - this video series on link operators I
734:20 - would encourage you to practice using
734:22 - these operators to become proficient in
734:24 - writing link queries this is a very
734:26 - powerful technology and it's used with
734:29 - Entity framework to perform database
734:31 - queries in modern.net applications
734:34 - Entity framework is now the recommended
734:36 - technology to use a.net for implementing
734:39 - database related functionality in.net
734:42 - applications if we navigate to this
734:44 - Microsoft docs webpage we can see this
734:47 - paragraph that states Entity framework
734:50 - core is a modern object-based mapper for
734:53 - net it supports link queries change
734:57 - tracking updates and schema migrations
735:00 - EF core works with many databases
735:03 - including SQL database on-premises and
735:06 - Azure sqlite MySQL postgres and Azure
735:11 - Cosmos DB
735:13 - this makes link a very important
735:15 - technology to learn for net Developers
735:18 - link enables developers to write one set
735:21 - of code that can be applied to handle
735:23 - data related functionality for multiple
735:25 - different data sources in link
735:27 - expression trees are used to represent
735:30 - structured queries that Target sources
735:33 - of data that implement the generic I
735:37 - queryable interface
735:39 - if you would like to delve deeper into
735:41 - expression trees please navigate to this
735:44 - URL
735:46 - so let's summarize what we have learned
735:48 - in our four part series on using the
735:50 - Link Technology in C sharp in the first
735:54 - part of this video series we created our
735:56 - own extension method to filter data we
735:59 - also demonstrated how a Lambda
736:01 - expression can be used to express a
736:03 - condition that can be passed into our
736:05 - extension method to filter the data and
736:08 - return the filtered results from a query
736:10 - the reason we created the filter
736:13 - extension method is because link is
736:15 - mostly made up of extension methods
736:17 - stored in two static classes namely a
736:20 - static class named enumerable and a
736:23 - static class named queryable
736:25 - we are able to access the extension
736:27 - methods Within These static classes by
736:30 - including a using directive to the
736:32 - system.link namespace the enumerable and
736:36 - queryable classes are both members of
736:38 - the system.link namespace
736:41 - in the second part of this series we
736:43 - demonstrated examples using the select
736:46 - where join and group join operators we
736:49 - also discussed the difference between
736:51 - when a query is executed with deferred
736:54 - execution or immediate execution we
736:57 - discussed how a link query is executed
736:59 - with deferred execution but we can make
737:02 - the link query execute immediately by
737:05 - applying a two conversion operator to
737:08 - the query for example two list two
737:11 - dictionary or two array
737:14 - in the third video in this series we
737:16 - demonstrated code examples using the
737:18 - following link operators
737:21 - sorting operators order by order by
737:24 - descending then buy and then by
737:26 - descending grouping operators group buy
737:29 - and to lookup
737:31 - quantifier operators or any and contains
737:35 - filter operators of type and where
737:39 - element operators element at element at
737:42 - or default first first or default last
737:46 - last or default single and single or
737:49 - default
737:54 - in the fourth and final video in this
737:56 - series we demonstrated code examples
737:58 - using the following link operators the
738:01 - equality operator sequence equal
738:04 - the concatenation operator concat
738:08 - the set operators distinct accept
738:11 - intersect and Union
738:13 - the generation operators
738:16 - default if empty empty range and repeat
738:20 - operators
738:21 - the aggregate operators aggregate
738:24 - average count sum and Max
738:28 - the partitioning operators skip skip
738:31 - while take and take while
738:35 - the conversion operators to list two
738:38 - dictionary and two array
738:41 - projection operators
738:43 - select and select many
738:46 - in this video we also looked at code
738:49 - examples using the let and the N2
738:51 - keywords
738:52 - I hope you have enjoyed this video
738:54 - series on using the Link Technology in
738:56 - c-sharp
738:58 - [Music]
739:08 - hi and welcome to the eighth part of
739:11 - this Advanced c-sharp course
739:13 - in this video we'll focus on the use of
739:16 - attributes and c-sharp for more content
739:19 - on advanced c-sharp concepts and much
739:21 - more please consider subscribing and
739:23 - please ring the bell so that you'll be
739:24 - notified of future content if you like
739:27 - this video at any point please consider
739:29 - giving it a thumbs up it will be greatly
739:31 - appreciated
739:32 - so let's discuss attributes attributes
739:36 - allow the developer to add metadata in a
739:38 - declarative way to program elements and
739:40 - code for example classes methods
739:42 - properties parameters Etc
739:45 - a declared attribute is instantiated
739:47 - into an object at runtime and at compile
739:50 - time we can declare attributes against
739:52 - program elements to provide additional
739:54 - metadata to relevant program elements
739:57 - the developer is also able to declare
740:00 - Global attributes against assemblies and
740:03 - a doing so add or modify metadata about
740:05 - the relevant assembly
740:08 - so the developer can use attributes to
740:11 - add or modify metadata about a
740:14 - particular program element or the
740:16 - assembly itself
740:18 - in this video we'll also briefly look at
740:20 - reflection reflection is a technology
740:23 - that we can use to read the metadata
740:25 - provided through the use of attributes
740:27 - at runtime we are then able to for
740:30 - example Implement codelogic based on the
740:32 - metadata provided through the use of
740:34 - attributes we'll look at how we can do
740:36 - this later in this video
740:39 - there are two broad categories for
740:40 - attributes predefined attributes and
740:43 - custom attributes
740:44 - predefined attributes are built into the
740:47 - baseclass libraries and net in this
740:50 - video we'll look at two main types of
740:52 - predefined attributes Global predefined
740:54 - attributes and general predefined
740:56 - attributes Global attributes like for
740:58 - example assembly version attribute and
741:00 - assembly description attribute
741:02 - facilitate adding and modifying metadata
741:04 - for an assembly General attributes lack
741:07 - for example conditional attribute
741:09 - obsolete attribute and attribute usage
741:12 - can be applied to appropriate program
741:14 - elements
741:17 - we'll start by implementing a code
741:19 - example using the assembly version
741:22 - attribute and assembly description
741:24 - attribute which are Global attributes
741:26 - we'll use reflection to read the
741:28 - relevant assembly metadata and output
741:31 - the assembly metadata to the console
741:33 - screen
741:34 - we'll then Implement a code example
741:36 - using the following General attributes
741:38 - conditional attribute obsolete attribute
741:41 - and attribute usage
741:43 - the attribute usage attribute will be
741:45 - declared on our own custom attributes
741:48 - that will create a bit later in this
741:50 - video
741:51 - we'll use custom attributes and
741:53 - reflection to implement field validation
741:55 - functionality we'll demonstrate how
741:57 - custom attributes can be created by
742:00 - creating classes that inherit from the
742:02 - built-in system.attribute class later in
742:05 - this video we are going to create custom
742:07 - attributes as part of validation logic
742:10 - that imitates how the asp.net MVC
742:13 - framework provides flexibility to
742:15 - developers through the use of reusable
742:18 - validation related attributes
742:20 - this video sets us up well for the next
742:23 - video provided by this channel which
742:25 - will be a demonstration of creating a
742:27 - basic asp.net MVC application on.net 5.
742:32 - right let's create our code examples so
742:35 - that we can gain an understanding of
742:37 - attributes in C sharp let's create a.net
742:40 - core console application project
742:43 - let's name this project attributes
742:46 - examples
742:50 - let's ensure that we are using.net 5 for
742:53 - this project
742:54 - if you haven't yet installeds.net5
742:57 - please see a link below in the
742:59 - description where you are able to
743:00 - download the.net5 SDK
743:03 - note that you'll mostly be able to
743:05 - follow along even using earlier
743:07 - versionsoft.net but it is advisable to
743:09 - download.net 5 to follow along with this
743:11 - tutorial and future tutorials
743:14 - one of my core aims is to keep these
743:17 - tutorials right up to date
743:19 - please view a video created for this
743:21 - Channel about the significance of the
743:23 - release of.net 5. a link to this video
743:26 - can be found Below in the description
743:29 - so let's say that we wish to declare the
743:31 - assembly version Global attributes in
743:33 - our code
743:34 - we are able to do this by declaring This
743:36 - Global attribute between the namespace
743:39 - Declaration and the using directives
743:43 - okay so why can't I see the assembly
743:45 - version attribute in the intellisense
743:46 - drop down
743:48 - the reason is that the assembly version
743:51 - attribute is part of the
743:52 - system.reflection namespace
743:55 - so let's add a using directive to the
743:57 - system.reflection namespace
743:59 - and now we are able to see the assembly
744:01 - version attribute along with other
744:03 - Global attributes in the intellisense
744:05 - drop down list and we can now declare
744:07 - the global attribute against our
744:09 - assembly like this
744:11 - so here we are attempting to set our
744:13 - attribute version number to
744:16 - 2.0.1 through the Declaration of the
744:18 - assembly version Global attribute
744:22 - great so let's see what happens when we
744:24 - attempt to compile the code
744:27 - so we have a compile time error let's
744:30 - look at our error list to take a look at
744:32 - the details of this error
744:35 - the description of the error is
744:37 - duplicate
744:39 - system.reflection.assembly version
744:40 - attribute attribute
744:42 - so let's double click on the error item
744:44 - in our list that is causing the compile
744:46 - time error to occur
744:49 - okay so a new file is open and we can
744:52 - see a red squiggly line under the
744:54 - offending code
744:55 - it is a file that has a name that
744:58 - contains the assembly name followed by
744:59 - the suffix dot assembly info and we are
745:02 - able to find this file within our
745:05 - projects directory structure
745:07 - and if we look at the comments within
745:09 - this file it is clear that this file has
745:11 - been auto-generated
745:14 - it's in fact being Auto generated by Ms
745:16 - build
745:17 - let's navigate to this URL to read a bit
745:20 - about Ms build
745:23 - the Microsoft build engine is a platform
745:25 - for building applications this engine
745:27 - which is also known as Ms build provides
745:30 - an XML schema for a project file that
745:33 - controls how the build platform
745:35 - processes and builds software Visual
745:38 - Studio uses Ms build but Ms build
745:41 - doesn't depend on Visual Studio
745:43 - by invoking msbill.exe on your project
745:46 - or solution file you can orchestrate and
745:49 - build products in environments where
745:51 - Visual Studio isn't installed
745:53 - Visual Studio uses Ms build to load and
745:56 - build managed projects the project files
745:59 - in visual
746:04 - studio.csproge.vbproj.vcx project and
746:06 - others contain Ms build XML code that
746:08 - executes when you build a project by
746:11 - using the IDE Visual Studio Projects
746:14 - import all the necessary settings and
746:16 - build processes to do typical
746:18 - development work
746:20 - but you can extend or modify them from
746:23 - within Visual Studio or by using an XML
746:26 - editor
746:27 - so the basic point I'm trying to make
746:29 - here is that many of these Global
746:32 - attributes will be automatically
746:33 - declared in the assembly info file when
746:36 - compiling your code using the visual
746:38 - studio IDE
746:40 - you can gain access to some of these
746:42 - Global attributes through the visual
746:44 - studio IDE
746:46 - if you try to declare a global attribute
746:48 - as I have attempted to here you may get
746:52 - a compile time error because Ms build
746:54 - has automatically declared the global
746:56 - attribute in the assembly info file
746:59 - as we have seen this results in the
747:02 - duplication of the relevant Global
747:04 - attribute declaration which ultimately
747:06 - results in a compile time error
747:08 - occurring
747:09 - you are able to declare certain Global
747:11 - attributes and the way we tried to
747:13 - declare the assembly version attribute
747:15 - for example let's declare the assembly
747:18 - description attribute
747:20 - let's comment out the assembly version
747:22 - attribute declaration let's add our own
747:25 - assembly description metadata to our
747:27 - assembly through a declaration of the
747:29 - assembly description Global attribute
747:31 - let's pass a value of my assembly
747:34 - description to the Constructor of the
747:36 - assembly description attribute
747:38 - note that depending on how the relevant
747:40 - attribute has been written when the
747:42 - developer declares an attribute the
747:44 - developer is able to provide custom
747:46 - metadata to the relevant attribute
747:48 - through the attributes exposed public
747:50 - Properties or the relevant attributes
747:52 - Constructor parameters
747:58 - so we know that the purpose of
748:00 - attributes is so that we can add or
748:02 - modify metadata against certain program
748:04 - elements or even against the assembly
748:06 - itself note that attributes on their own
748:09 - do not change application Behavior
748:13 - the metadata provided through attribute
748:15 - declarations can be read at runtime
748:17 - through the use of reflection relevant
748:20 - metadata can then be evaluated by our
748:22 - code and appropriate code logic can be
748:24 - invoked based on the declared metadata
748:28 - so this is how the Microsoft docs
748:30 - describes reflection reflection provides
748:33 - objects of type type that describe
748:36 - assemblies modules and types you can use
748:39 - reflection to dynamically create an
748:41 - instance of a type bind the types to an
748:44 - existing object or get the type from an
748:47 - existing object and invoke its methods
748:49 - or access its fields and properties
748:53 - if you are using attributes in your code
748:55 - reflection enables you to access them
748:58 - right so let's use reflection to access
749:01 - and read certain metadata that has been
749:03 - added through the use of global
749:05 - attributes
749:07 - so we need a using directive to the
749:09 - system.reflection namespace which has
749:12 - already been included in our code
749:14 - so let's write some code in our main
749:16 - method
749:18 - let's get a reference to the current
749:19 - assembly
749:20 - we can do this by getting a reference to
749:23 - the program classes type and then
749:25 - assigning its assembly property value to
749:27 - a variable
749:28 - we have named our variable this SM
749:31 - referring to the current assembly we can
749:34 - then get the relevant assembly Name by
749:36 - using the assembly reference stored in
749:39 - the this assemb variable and calling its
749:41 - get name method
749:44 - and we can access the assembly's version
749:46 - information through that version
749:48 - property
749:50 - now we want to read the assembly's
749:52 - description which should be the
749:54 - description that we included when we
749:56 - declared the assembly description Global
749:58 - attribute
750:00 - to get a reference to the assembly
750:02 - description attribute we can call the
750:04 - get custom attributes method under this
750:06 - the same object and pass in the type of
750:09 - the attribute of interest to us
750:12 - note that we are using the type of
750:14 - method to get a reference to the object
750:16 - type of the relevant attribute remember
750:19 - attributes and C sharp are objects at
750:22 - runtime
750:24 - an object instantiated from the assembly
750:26 - description attribute class should be
750:28 - the first item in our object array
750:32 - we can use the as operator to cast the
750:35 - object to the assembly description
750:37 - attribute type
750:39 - if the casting operation fails now will
750:42 - be returned if the operation succeeds an
750:44 - object of the assembly description
750:46 - attribute type is returned
750:48 - let's write code to write out the
750:51 - metadata information about the current
750:53 - assembly that we have been able to
750:55 - retrieve through reflection to the
750:57 - console screen
751:28 - let's run the code
751:38 - great
751:43 - so we have looked at examples of global
751:46 - predefined attributes let's look at some
751:48 - general predefined attributes let's
751:50 - start with the conditional attribute
751:53 - let's first add a new standard Library
751:55 - project to our solution
752:13 - and let's name our project logging
752:15 - component
752:19 - let's remove the automatically created
752:21 - class named class 1 and add a new class
752:24 - named logging to our new project
752:37 - let's add a public static method to the
752:39 - login class named log to screen
752:42 - it contains one parameter named MSG and
752:46 - is defined as a string the code for this
752:49 - method simply outputs the value
752:50 - referenced by the MSG argument to the
752:53 - console screen let's declare the
752:56 - conditional attribute against the log to
752:58 - screen program element we have a red
753:00 - squiggly line because the conditional
753:02 - attribute as a member of the
753:04 - system.diagnostics namespace
753:07 - so let's add a using directive to the
753:09 - system.diagnostics namespace
753:12 - and now let's pass in an argument into
753:14 - the Constructor of our conditional
753:16 - attribute let's pass in the text log
753:18 - underscore info so what does log
753:22 - underscore info mean
753:24 - log underscore info is a piece of text
753:26 - that I've made up this text represents a
753:29 - symbol in our code we can use the Define
753:32 - preprocessor directive and include the
753:34 - log underscore info symbol in our code
753:37 - if the log underscore info symbol is
753:40 - defined using the preprocessor defined
753:42 - directive within a file containing
753:45 - method calls to the log to screen method
753:47 - the code within the log to screen method
753:49 - will be executed at runtime however if
753:52 - the predefined processor directive is
753:54 - not used to define the log underscore
753:56 - info symbol in the file where the log to
753:59 - screen method is called its code will
754:01 - not be executed at runtime because we
754:04 - have used the conditional attribute to
754:06 - declare to the compiler that we would
754:08 - like this Behavior to occur regarding
754:10 - the log to screen program element so
754:13 - the combination of the conditional
754:16 - attribute and the use of the Define
754:18 - preprocessor directive can act like a
754:21 - switching mechanism I.E using this
754:23 - mechanism we are able to switch certain
754:25 - code on or off this is especially useful
754:28 - for debugging purposes
754:30 - if this is not clear don't worry we will
754:33 - demonstrate what is meant here through a
754:34 - code example
754:36 - we are able to Define our log underscore
754:38 - info symbol through the use of a
754:41 - preprocessor directive
754:43 - we are going to use the Define
754:44 - preprocessor director for this purpose
754:47 - preprocessor identifiers are used to
754:50 - help in conditional compilation
754:52 - if we navigate to this URL
754:55 - we can see some of the preprocessor
754:57 - directives available in c-sharp
755:00 - for more information on pre-processor
755:02 - directives please use this section of
755:04 - the Microsoft docs as your guide so here
755:07 - we have the hash Define preprocessor
755:10 - directive that we can use to define a
755:12 - symbol in our code
755:13 - so let's see how we can use a particular
755:16 - preprocessor directive in conjunction
755:18 - with the conditional attribute to
755:20 - conditionally output information to the
755:22 - console Screen through our log to screen
755:24 - method we must add our appropriate
755:27 - pre-processor directive code right at
755:30 - the top of our program.cs file in our
755:33 - code editors like this to implement the
755:35 - desired functionality
755:38 - you can see we have the Define
755:39 - preprocessor identifier in this line of
755:42 - code as well as the log underscore info
755:45 - symbol that we made up and passed as
755:48 - text to our conditional attribute which
755:51 - was declared against the log to screen
755:53 - program elements
756:10 - let's include a using directive to our
756:13 - login component namespace
756:15 - in our main method let's make a call to
756:17 - the logging.log to screen method and
756:20 - pass in the following text as an
756:22 - argument to the MSG parameter this code
756:25 - is testing logging functionality
756:31 - let's run the code
756:39 - and as expected the appropriate text is
756:42 - written to the console screen
756:43 - so now let's see what happens when we
756:45 - comment out the relevant preprocessor
756:47 - directive code and run the code again
756:57 - and you can see that nothing has been
756:59 - outputted to the console screen using
757:01 - our pre-processor directive we can
757:04 - switch the execution of the code against
757:06 - which the relevant conditional attribute
757:08 - is applied on and off at compile time
757:12 - this functionality can be very useful
757:14 - for debugging purposes
757:16 - so let's say we have a change to our
757:18 - login component where we want all
757:20 - logging to be done to a text file rather
757:23 - than to the console screen and we want
757:25 - the consumers of our code to use the
757:27 - method that logs the information to a
757:29 - text file rather than to the console
757:31 - screen so how can we let the consumers
757:34 - know to use the log to file method
757:36 - rather than the log to screen method
757:39 - we can simply declare the obsolete
757:41 - predefined General attribute against the
757:44 - log to screen method
757:46 - let's create a public static method
757:48 - named log to file
757:49 - in the interest of time rather than
757:52 - writing the code to actually log the
757:54 - value passed into this method to a file
757:56 - let's just write code to Output the
757:58 - value to the console screen and pretend
758:00 - that it's method logs relevant text to a
758:03 - text file
758:04 - okay so let's declare the obsolete
758:06 - attribute against the log to screen
758:08 - method and let's pass a meaningful
758:10 - message to the Constructor of the
758:12 - obsolete attribute
758:14 - so we want any calling code that is
758:16 - currently using the log to screen method
758:18 - to receive the following warning message
758:21 - the log to screen method has now been
758:23 - deprecated please use the log to file
758:26 - method instead
758:32 - so now if we go to our main method we
758:35 - can immediately see a green squiggly
758:37 - line under the code that is calling the
758:39 - log to screen method
758:42 - and if we hover our Mouse pointers over
758:44 - the green squiggly line we can see that
758:47 - the text that we passed as an argument
758:49 - to the obsolete attribute is presented
758:51 - to us
758:53 - and note that if we want to force the
758:55 - user of our code to not use the log to
758:58 - screen method at all
759:00 - we can set a second parameter in the
759:02 - obsolete attribute to true
759:05 - if this value is set to True an error is
759:07 - flagged when a user attempts to use the
759:10 - deprecated method I.E the log to screen
759:13 - method
759:13 - now you can see that the green squiggly
759:15 - line has turned into a red squiggly line
759:18 - meaning that we no longer just receive a
759:21 - warning message we are receiving an
759:23 - error message
759:25 - this means we won't be able to compile
759:27 - the code
759:51 - the last predefined attribute that I
759:53 - wish to discuss is the attribute usage
759:55 - attribute
759:59 - we are going to create our own custom
760:01 - attributes and use reflection to read
760:03 - the relevant metadata added to relevant
760:05 - program elements through our custom
760:07 - attributes so reflection and attributes
760:10 - will be implemented to provide
760:11 - flexibility to developers using our
760:13 - custom attributes to declare how
760:15 - relevant Fields should be validated
760:19 - this code is going to be very similar to
760:21 - the code that the asp.net MVC framework
760:25 - implements for field validation
760:27 - in asp.net MVC we can declare certain
760:31 - validation related attributes against
760:33 - relevant program elements and the MVC
760:35 - framework automatically handles
760:37 - validation of relevant fields for us
760:39 - behind the scenes as it were
760:41 - in this code example however we are
760:44 - going to create the custom attributes
760:46 - used for declaring how we want relevant
760:48 - Fields validated and we will also write
760:51 - code using reflection to read the
760:53 - attribute data declared against relevant
760:55 - program elements in this case the
760:57 - program elements will be properties
761:00 - we will also write the validation code
761:02 - related to each of our custom attributes
761:05 - okay so let's add a new standard Library
761:07 - project to our solution
761:11 - let's name this project validation
761:13 - component
761:18 - let's delete the class that was
761:19 - automatically created by Visual Studio
761:24 - let's create a new folder named custom
761:26 - attributes
761:29 - let's add our first custom attribute
761:31 - class to the custom attributes folder
761:33 - let's right click the custom attributes
761:35 - folder and add a new class let's name
761:37 - this class required attribute note that
761:40 - we must include the attribute suffix and
761:42 - the class name of our custom attribute
761:45 - however when we declare our custom
761:47 - attribute you'll see that in the
761:50 - Declaration we can omit the attribute
761:52 - suffix from the attribute name
761:55 - we are however allowed to include the
761:57 - attribute suffix in our attribute
761:58 - declaration but functionally this is
762:01 - unnecessary we'll demonstrate this a bit
762:03 - later
762:04 - the code for this attribute is very
762:06 - simple
762:07 - let's create a public auto implemented
762:09 - property of type string named error
762:12 - message
762:14 - let's add code to a parameter-less
762:16 - Constructor whereby the error message
762:18 - property is set to a default value so
762:21 - let's say we want to default error
762:22 - message of you cannot leave field and
762:25 - then in curly brackets we have a zero
762:27 - followed by the word empty
762:30 - so the zero and curly brackets allows
762:33 - the relevant field name to be inserted
762:36 - into the message at a later time
762:38 - this is achieved through the use of
762:40 - composite formatting if you are not
762:43 - familiar with composite formatting
762:44 - regarding string values please view a
762:47 - tutorial created for this channel on C
762:49 - sharp strings a link to this tutorial
762:52 - has been provided Below in the
762:54 - description
762:56 - right let's create a parameterized
762:58 - Constructor
762:59 - this will allow the developer to pass in
763:02 - a custom error message when declaring
763:04 - the required attribute against the
763:06 - relevant program element
763:08 - the Declaration of the required
763:09 - attribute will be demonstrated a bit
763:11 - later
763:12 - in order for our class to be recognized
763:15 - as a custom attribute we must ensure
763:18 - that our class inherits from the
763:20 - built-in system.attribute class
763:23 - a custom attribute must inherit from the
763:26 - system.attribute class
763:28 - either directly as we are doing here or
763:31 - indirectly for example if our class
763:33 - inherited from another use a defined
763:35 - class that inherits from the system dot
763:38 - attribute built-in class
763:40 - so now all that is left to do is apply
763:42 - the predefined attribute usage attribute
763:44 - against our required attribute class
763:49 - like with the obsolete predefined
763:51 - attribute the attribute usage predefined
763:53 - attribute is a member of the system
763:55 - namespace
763:56 - basically the attribute usage predefined
763:59 - attribute allows us to provide metadata
764:01 - to the compiler that will tell the
764:04 - compiler which elements are allowed to
764:06 - have our predefined attribute declared
764:08 - against them
764:10 - so we can apply rules or constraints
764:12 - through the use of the attribute usage
764:15 - predefined attribute against our custom
764:17 - attribute at the class level
764:20 - this is an example of declaring an
764:22 - attribute against a class
764:24 - so in the first argument passed into the
764:27 - attribute usage attribute we can declare
764:29 - which program elements are allowed to be
764:31 - decorated with our custom attribute
764:34 - so if we have decided that we only want
764:37 - our custom attribute to be declared on
764:39 - the following program elements Fields
764:41 - parameters and properties we can declare
764:45 - this by passing in this code to the
764:47 - first parameter of the attribute usage
764:49 - attributes Constructor like this
764:52 - so here we are declaring which Target
764:54 - program elements are able to be
764:56 - decorated with our required custom
764:58 - attribute
765:00 - we can optionally set a property of type
765:02 - Boolean named allow multiple through our
765:06 - declaration if we set the allow multiple
765:09 - property to true this means multiple
765:11 - instances of our custom attribute can be
765:14 - declared against a single program
765:15 - element
765:17 - we only want one instance of our custom
765:20 - attribute to be declared against a
765:22 - single program element so let's set the
765:24 - allow multiple property to false
765:27 - we also have a property named inherited
765:30 - that we can optionally set through this
765:32 - declaration
765:34 - setting this property determines whether
765:36 - the relevant custom attribute is
765:38 - inherited by a derived class in this
765:41 - example we won't set this property
765:45 - and that's it we have now created our
765:48 - required custom attribute
765:54 - so let's create our next custom
765:56 - attribute let's add a new class file to
765:59 - our custom attributes folder and let's
766:01 - name this class string length attribute
766:04 - let's add three public auto implemented
766:07 - properties to our string length
766:08 - attribute class
766:09 - max length for the storage of an integer
766:12 - value denoting the maximum number of
766:14 - characters that a user can enter for a
766:16 - field related to a property against
766:18 - which the string length attribute has
766:20 - been declared
766:22 - error message for the storage of a
766:24 - string value denoting the message
766:26 - outputted to the user when the user has
766:29 - entered an invalid value into a field
766:31 - related to a property against which the
766:34 - string length attribute has been
766:36 - declared
766:37 - men length for the storage of an integer
766:40 - value denoting the minimum number of
766:42 - characters that a user can enter for a
766:44 - field related to a property against
766:46 - twitch the string length attribute has
766:49 - been declared
766:51 - so let's create a private method named
766:53 - set properties that we can reuse for
766:56 - setting our public properties this
766:58 - method will be called from a number of
767:00 - Constructor overloads that we'll
767:02 - Implement in a bit for this class
767:04 - this method does not return a value and
767:06 - contains three parameters that correlate
767:09 - to the public properties that we have
767:11 - already created
767:12 - the first parameter is max length which
767:15 - is defined as int
767:17 - second parameter is error message
767:19 - defined as string
767:35 - the third parameter has been length
767:37 - defined as a nullable integer
767:40 - the question mark symbol following the
767:43 - int keyword denotes that this parameter
767:45 - is nullable
767:48 - so it is a nullable value type parameter
767:51 - because it's defined as an integer which
767:54 - is of course a value type
767:56 - let's also make our Min length parameter
767:58 - optional we can do this in C sharp by
768:01 - simply assigning the relevant parameter
768:03 - a default value within the method
768:05 - definition like this
768:08 - so if a value is not passed into this
768:10 - parameter by default the Min length
768:13 - argument will have a value of null
768:15 - before we move on with our example let's
768:18 - go to the Microsoft dots specifically to
768:21 - this location to read a bit about
768:23 - nullable value types a nullable value
768:26 - type T question mark represents all
768:29 - values of its underlying value type T
768:31 - and in addition of null value for
768:35 - example you can assign any of the
768:37 - following three values to a bull
768:39 - question mark variable true false or
768:43 - null
768:44 - an underlying value type T cannot be a
768:47 - nullable value type itself
768:50 - very basically a null value means that a
768:52 - value for the relevant variable has not
768:54 - been set
768:56 - adding a question mark at the end of the
768:58 - value type definition for a variable or
769:01 - a parameter means we have the option of
769:04 - storing a null value in the relevant
769:06 - variable or parameter
769:10 - note that optional parameters must be
769:12 - included at the end of the parameter
769:15 - list in the relevant methods method
769:17 - signature
769:19 - okay so let's implement the logic for
769:21 - the set properties private method so
769:24 - firstly let's check to see if the error
769:26 - message argument contains an empty
769:28 - string if it does we want to set a
769:31 - default error message value
769:33 - in order for our error message to
769:35 - contain appropriate text depending on
769:38 - whether the Min length value is set
769:40 - we can create a nested if statement so
769:43 - if the Min length value is null let's
769:46 - appropriately set our default error
769:48 - message
769:58 - if the Min length value is not now let's
770:01 - include appropriate text relating to the
770:03 - Min length value within our default
770:06 - error message
770:28 - so if the developer does not pass in an
770:30 - error message when declaring the string
770:32 - length attribute against an appropriate
770:34 - program element a default error message
770:36 - will be used
770:38 - for the scenario where an error message
770:40 - value is set when the relevant attribute
770:42 - is declared against a program element
770:44 - the error message provided must be
770:47 - assigned to the error message public
770:49 - property of the attribute
770:51 - then let's set the max length property
770:53 - this is a property value that the
770:56 - developer must pass in when declaring
770:58 - the string length attribute against an
771:00 - appropriate program element
771:02 - less than assign the appropriate value
771:04 - to the Min length property
771:07 - so let's use a ternary operator to check
771:09 - if the Min length argument is null IE
771:12 - has not been set by the developer
771:14 - declaring the string length attribute
771:16 - against an appropriate program element
771:19 - if the Min length argument is null let's
771:22 - assign 0 to the Min length property if
771:24 - the Min length argument contains a value
771:26 - let's assign the value to the Min length
771:29 - property
771:30 - so let's create our Constructor
771:32 - overloads firstly let's create a
771:34 - Constructor that contains just the max
771:36 - length parameter
771:38 - then within our Constructor let's call
771:40 - our private set properties method to
771:43 - assign values to the appropriate public
771:45 - properties of the string length
771:47 - attribute class
771:48 - okay I also want to make the error
771:51 - message parameter in the set properties
771:53 - method and optional parameter
771:55 - we can do this by simply assigning
771:57 - default value to the error message
771:59 - parameter like this note that the
772:02 - parameter after the error message
772:03 - parameter in our parameter list is also
772:07 - the last parameter in the parameter list
772:09 - and is optional so it is perfectly legal
772:13 - to make our error message parameter
772:14 - optional remember the optional
772:17 - parameters must be included at the end
772:19 - of the relevant parameter list
772:24 - let's create Constructor overload that
772:26 - contains the max length parameter and
772:28 - the error message parameter
772:30 - then let's use our private set
772:32 - properties method to assign values to
772:35 - the appropriate public properties of the
772:36 - string length attribute class
772:39 - let's create a Constructor overload that
772:41 - contains the max length parameter and
772:43 - the Min length parameter
772:45 - let's use our private set properties
772:47 - method to assign values to the
772:49 - appropriate public properties of the
772:51 - string length attribute class
772:54 - note how we are passing in a value to
772:56 - the Min length optional parameter of the
772:58 - set properties method we need to be
773:00 - specific as to what parameter is being
773:03 - passed an argument here
773:05 - because in this case we are not passing
773:08 - in an argument to the error message
773:10 - parameter
773:12 - the fact that the error message
773:13 - parameter and the Min length parameter
773:16 - are both optional means in cases like
773:18 - this
773:19 - we have to make it clear which parameter
773:21 - we want to pass our arguments to
773:24 - let's create one more Constructor
773:26 - overload this Constructor overload
773:28 - contains the max length parameter the
773:31 - error message parameter and the Min
773:33 - length parameter
773:35 - let's use our private set properties
773:37 - method one more time to assign values to
773:41 - the appropriate public properties of the
773:43 - string length attribute class
773:48 - let's ensure that we include the code
773:50 - whereby our class inherits from the
773:52 - system.attribute built-in class
773:56 - so now let's declare the attribute usage
773:58 - predefined attribute against our string
774:00 - length attribute class so we can copy
774:03 - the attribute usage declaration from our
774:05 - required attribute class and
774:07 - appropriately paste it in to declare the
774:09 - attribute usage attribute against our
774:12 - string length attribute class
774:20 - great so we have now completed two
774:22 - custom attributes the required attribute
774:25 - custom attribute and the string length
774:27 - custom attribute let's create one more
774:30 - custom attribute this attribute will be
774:32 - responsible for indicating when declared
774:34 - against a program element that the input
774:36 - Fields value related to the relevant
774:38 - program element should match a specified
774:41 - regular expression pattern
774:44 - so regular expressions are great for
774:46 - defining patterns that an input field
774:49 - value must match for field types that
774:52 - must be constrained to a particular
774:54 - format like for example postcodes phone
774:58 - numbers credit card numbers email
775:00 - addresses Etc
775:04 - so the validation code for Fields like
775:06 - this will be simple
775:08 - if the relevant input field value
775:10 - matches the specified regular expression
775:12 - pattern the user's input is deemed as
775:15 - valid if however the input field value
775:17 - does not match the specified regular
775:20 - expression pattern the user's input is
775:22 - deemed as invalid
775:24 - we can implement the validation logic
775:26 - related to our custom attributes once we
775:29 - have completed the code for this final
775:31 - custom attribute
775:34 - so let's add a class to our custom
775:36 - attributes folder and let's name this
775:38 - class regular expression attribute
775:58 - let's create two public autoimplemented
776:01 - properties the first property named
776:03 - error message is of the string data type
776:06 - the second property named pattern is
776:09 - also of the string data type the pattern
776:11 - property denotes the regular expression
776:14 - pattern that must be supplied by the
776:16 - developer when the regular expression
776:18 - custom attribute is declared against an
776:21 - appropriate program element let's create
776:23 - two Constructor overloads the first
776:26 - Constructor overload contains one
776:28 - parameter named pattern
776:30 - the developer is able to pass an
776:32 - appropriate regular expression pattern
776:34 - argument to this parameter when
776:37 - declaring the regular expression custom
776:39 - attribute against an appropriate program
776:41 - element
776:43 - the error message argument is not passed
776:46 - into this Constructor but we can provide
776:48 - a default error message in this
776:50 - Constructor and assign it to the error
776:53 - message property
777:15 - let's create a Constructor overload this
777:18 - Constructor contains two parameters one
777:20 - denoting the regular expression pattern
777:22 - and the other denoting the error message
777:26 - so this Constructor allows the developer
777:28 - to pass in a regular expression pattern
777:30 - argument as well as a custom error
777:32 - message to a declaration when declaring
777:36 - this attribute against a program element
777:41 - so all we need to do within the
777:43 - Constructor is assign the public
777:45 - property members of this class with the
777:47 - appropriate values passed into the
777:49 - relevant Constructor as arguments
777:53 - let's ensure that we include the code
777:55 - whereby our class inherits from the
777:57 - system.attribute built-in class
778:00 - the last step is to appropriately
778:03 - declare the attribute usage predefined
778:05 - attribute against the regular expression
778:07 - attribute class this declaration will be
778:10 - the same declaration applied against our
778:12 - other two custom attribute classes
778:15 - so let's copy the appropriate
778:17 - declaration from one of our other custom
778:19 - attribute classes and appropriately
778:21 - paste the contents of our clipboards
778:23 - into our regular expression attribute
778:25 - plus file
778:30 - so now we have created three custom
778:32 - attributes implemented in three separate
778:35 - files
778:37 - the first custom attribute we created is
778:39 - named required attribute
778:43 - when this attribute is declared against
778:44 - an appropriate program element this
778:47 - means that the associated input field
778:49 - must not be left empty if it is left
778:52 - empty the field value is deemed as
778:55 - invalid
778:56 - the second custom attribute we created
778:59 - is named string length attribute when
779:01 - this attribute is declared against an
779:03 - appropriate program element this means
779:05 - the associated input field must contain
779:08 - a character length that falls within the
779:10 - boundaries defined by a specified
779:12 - minimum value and a specified maximum
779:15 - value
779:16 - the third custom attribute we created is
779:18 - named regular expression attribute when
779:21 - this attribute is declared against an
779:23 - appropriate program element
779:25 - this means that the associated input
779:27 - field must contain a value that matches
779:30 - a specified regular expression pattern
779:32 - so through the Declaration of one or
779:34 - more of our custom attributes a
779:36 - developer can express how a certain
779:38 - input field should be validated
779:41 - without the logic to implement the
779:43 - validation rules however these
779:45 - attributes are useless these custom
779:47 - attributes perform no functionality
779:49 - other than to add metadata to relevant
779:51 - program elements
779:53 - so the next step is to write the
779:55 - validation code we must write the
779:57 - validation logic that correlates with
779:59 - each of our custom attributes
780:02 - through the use of reflection we'll be
780:04 - able to read the metadata added to the
780:07 - relevant program elements through the
780:09 - use of our custom attributes
780:11 - the use of our custom attributes is for
780:13 - the purpose of declaring how validation
780:15 - logic is related with relevant program
780:18 - Elements which are also related to
780:20 - relevant input fields
780:22 - so let's write the relevant validation
780:24 - logic
780:25 - so to do this let's first add a new
780:28 - class named validation directly to the
780:30 - project node
780:31 - so we want this class to be separate
780:33 - from our custom attribute classes
780:36 - we are going to implement our own
780:38 - validation code in this class so we
780:40 - first want to create the validation
780:42 - logic that corresponds to each of our
780:44 - custom attributes the required attribute
780:46 - the string length attribute and the
780:48 - regular expression attribute let's
780:51 - encapsulate this functionality within
780:53 - three private methods
780:54 - let's first implement the validation
780:56 - logic that corresponds to the required
780:58 - attribute
781:01 - so let's create a private static method
781:03 - named field required is valid that
781:06 - returns a Boolean value
781:08 - this method contains one parameter let's
781:11 - name this parameter entered value and
781:13 - Define it as a string the logic for this
781:16 - method is basic
781:17 - if the entered value passed into this
781:19 - method as an argument is not null or
781:22 - empty return true because this means the
781:25 - user has entered a value which makes the
781:27 - input field entry valid if the code that
781:31 - returns true is not executed this means
781:33 - the entered value is invalid and false
781:36 - must be returned to the calling code
781:38 - let's implement the validation logic
781:40 - that corresponds to the string length
781:42 - attribute
781:44 - the method signature for this method is
781:46 - the same as the field required is valid
781:48 - method except we need to also pass in a
781:51 - field of type string length attributes
781:53 - to this method in addition to the
781:55 - parameter representing the entered value
781:59 - this is so that we can access the Min
782:01 - length and max length public properties
782:03 - that we implemented for the string
782:05 - length attribute class
782:07 - the values stored in these two
782:09 - properties are integral to the
782:11 - validation logic performed against
782:12 - relevant inputted values
782:17 - let's name this method field string
782:19 - length is valid
782:21 - so to implement the validation code
782:23 - let's Implement an if statement where
782:25 - the condition evaluates the entered
782:27 - value argument to see if its character
782:30 - length is greater than or equal to the
782:32 - Min length property and is less than or
782:35 - equal to the max length property
782:39 - if the character length of the entered
782:41 - value argument Falls within the range
782:43 - defined by the Min length and back
782:46 - length property values the entered value
782:49 - is valid so we can return true to the
782:51 - calling code if however the character
782:53 - length of the entered value does not
782:55 - fall within the specified range we must
782:58 - return false because the entered value
783:00 - is not valid
783:02 - so let's now implement the validation
783:05 - private method that corresponds to the
783:08 - regular expression attribute so the
783:10 - method signature is almost the same as
783:13 - the field string length is valid methods
783:15 - method signature let's appropriately
783:17 - name this method field pattern match is
783:20 - valid
783:22 - instead of including a parameter of type
783:25 - string length attribute let's include a
783:27 - parameter of type regular expression
783:29 - attribute
783:30 - this is so that we can access the public
783:32 - property named pattern which is a member
783:35 - of the regular expression attribute
783:37 - class
783:38 - for pattern property will contain the
783:41 - regular expression pattern against which
783:43 - we need to validate the entered value
783:47 - so let's use the reg X class to perform
783:49 - our validation logic
783:51 - this class is a member of the system.txt
783:54 - dot regularexpressions namespace so
783:56 - let's include an appropriate using
783:58 - directive
784:14 - the reg X class contains a public static
784:17 - method named is match we can use this
784:20 - method to validate the entered value
784:22 - against the relevant regular expression
784:25 - pattern
784:27 - if the is match method returns true this
784:29 - means the entered value is valid so we
784:32 - must return true to the calling code
784:34 - if however the is match method returns
784:36 - false this means the entered value is
784:39 - not valid and we must return false to
784:41 - the calling code
784:44 - okay so we have now implemented the
784:46 - validation logic that corresponds to our
784:49 - custom attributes
784:50 - let's create a public static method
784:52 - named property value is valid that
784:55 - returns a Boolean value
784:58 - this method is responsible for calling
785:01 - relevant validation code
785:03 - that is relevant to a specific program
785:05 - element and a user inputted value
785:08 - the validation code executed is
785:11 - determined by the custom attributes that
785:13 - have been declared against the relevant
785:15 - program element
785:17 - in the interests of keeping this code
785:19 - simple the code will only be relevant to
785:22 - a program element that is a property
785:25 - so the first item in the parameter list
785:27 - for the property value is valid method
785:29 - is a parameter of type type
785:33 - this parameter represents the type that
785:35 - contains properties against which our
785:39 - custom attributes may have been declared
785:42 - for example a user-defined type
785:44 - representing an employee record the next
785:47 - parameter represents the value that a
785:49 - user enters I.E an input field which is
785:53 - correlated to a particular property and
785:56 - needs to be validated by our code this
785:59 - parameter is appropriately named entered
786:02 - value
786:04 - the next parameter represents the
786:06 - program element which will be a property
786:08 - in this case that is a member of the
786:10 - type represented in the first parameter
786:14 - so for example the program element could
786:16 - be the first name property which is a
786:19 - member of a user-defined type named
786:21 - employee
786:23 - the last parameter for this method
786:25 - represents the error message that will
786:27 - be displayed to the user if the user's
786:29 - input is deemed as invalid
786:31 - we want to Output the error message
786:33 - value so let's include the out keyword
786:36 - in the relevant parameter definition
786:39 - let's implement the logic for this
786:40 - method
786:41 - firstly let's get a reference to the
786:44 - relevant program element
786:45 - so the program element in this example
786:47 - will be the property on which one or
786:49 - more of our custom attributes has been
786:51 - declared
786:53 - so for example if we are validating the
786:56 - first name property on the employee
786:58 - user-defined type the element name
787:00 - argument will contain the literal text
787:03 - first name which is the name of the
787:05 - first name property
787:07 - to get a reference to the user-defined
787:09 - type in this case employee the calling
787:12 - code would pass in type of employee
787:15 - this means we can use reflection to
787:17 - inspect the relevant program element to
787:19 - ascertain which custom attributes have
787:22 - been declared against the relevant
787:24 - program element using reflection we can
787:28 - then ascertain how we should validate
787:30 - the relevant entered value
787:33 - so let's write code to get a reference
787:35 - to the relevant program element which in
787:38 - this case will be a property reflection
787:41 - can be used to get relevant information
787:42 - about a program element
787:45 - we want to know in our code what custom
787:47 - attributes have been declared against
787:49 - the relevant program element
787:52 - so we can use the property info type
787:54 - which is a member of the
787:55 - system.reflection namespace to gain
787:58 - access to the property information that
788:00 - we need
788:03 - we must include a using directive to the
788:06 - system.reflection namespace
788:08 - let's Define a variable named prop as
788:10 - the property info type and let's assign
788:12 - a value returned from a call to a method
788:15 - named get property which is invoked on
788:17 - the type argument passed into the T
788:20 - parameter of this method
788:22 - note that we need to pass the element
788:24 - name argument to the get property method
788:27 - the element name argument will store a
788:30 - reference to the name of the relevant
788:31 - property
788:34 - we now have a reference to the relevant
788:36 - property information we can use the get
788:38 - custom attributes method to return a
788:40 - collection of custom attributes that
788:42 - have been declared against the relevant
788:44 - property
788:45 - we can assign The Returned value to an
788:47 - array of type attribute
788:50 - the get custom attributes method is
788:52 - returning a collection of type I
788:54 - enumerable and I want to store a
788:57 - reference to the relevant custom
788:58 - attribute objects in an array so let's
789:02 - use links to array extension method to
789:05 - convert the I enumerable collection into
789:08 - an array
789:15 - let's initialize the error message
789:17 - output parameter to an empty string
789:20 - let's write code to perform a for each
789:22 - Loop and loop through each attribute
789:24 - object declared against the relevant
789:26 - program element
789:28 - then within the for each Loop let's
789:30 - Implement a switch statement and use
789:32 - pattern matching code to get a reference
789:34 - to the relevant custom attribute objects
789:36 - so that we can perform appropriate
789:38 - validation on the entered value
789:41 - so the switch statement evaluates the
789:44 - type of each relevant attribute object
789:46 - using pattern matching
789:49 - using pattern matching we are able to
789:52 - get a reference to the attribute objects
789:53 - that have been declared against the
789:55 - relevant program element
789:57 - this is the magic of pattern matching in
789:59 - action pattern matching was introduced
790:01 - in c-sharp version 7. it allows the
790:04 - developer to write code to assess
790:06 - whether an object type matches the
790:08 - object type specified in a case
790:10 - statement
790:11 - if there is a match a reference to the
790:14 - relevant object is made available on the
790:16 - same line of the code as the case
790:18 - statement
790:19 - so here we have case required attribute
790:23 - if the object referenced by the att-r
790:26 - variable is of type required attribute
790:29 - the ra variable is assigned the value
790:32 - referenced by the att-r variable
790:37 - we are then able to use the ra variable
790:39 - in our validation code that resides
790:42 - within the relevant case block
790:44 - so we can call the appropriate private
790:47 - method for validating required fields
790:49 - that we implemented earlier to validate
790:51 - the relevant user entered value
790:54 - if the entered value is deemed as
790:56 - invalid we can output an error message
790:59 - to the user through the error message
791:01 - output parameter which has been
791:03 - appropriately marked with the out
791:05 - keyword meaning we can output a value
791:07 - through this parameter to calling client
791:10 - code
791:11 - if the relevant user input fails
791:13 - validation we need the property value is
791:16 - valid method to return false
791:20 - so let's include the other case
791:22 - statements pertaining to the other two
791:23 - custom attributes
791:26 - so let's implement the case block for
791:28 - the string length custom attribute
792:00 - and lastly let's implement the case
792:02 - block for the regular expression custom
792:04 - attribute
792:48 - great
792:51 - let's write the calling client code
792:54 - let's go to the.net core console project
792:56 - let's start by creating classes that can
792:59 - represent data models the first model
793:01 - will be a class that represents an
793:03 - employee record
793:05 - so let's create a new folder and name it
793:07 - models
793:14 - let's add a new class named employee to
793:17 - the models folder
793:19 - this class contains six autoimplemented
793:21 - properties ID as int first name as
793:25 - string last name as string phone number
793:27 - as string email address says string and
793:30 - postcode as string great
793:32 - so we are now going to appropriately
793:34 - declare our custom attributes against
793:37 - the properties we have just added to the
793:39 - employee class
793:41 - these attribute declarations will
793:43 - indicate to our validation code how the
793:45 - input values associated with the
793:48 - employee classes relevant properties
793:50 - should be validated
793:59 - let's include an appropriate using
794:01 - directive at the top of our code to the
794:03 - validation component dot custom
794:05 - attributes namespace
794:08 - so let's apply the required attribute to
794:10 - the ID program element notice how when
794:13 - we declare our custom attributes we
794:15 - don't need to include the attribute
794:17 - suffix
794:19 - so even though the class representing
794:21 - the required attribute is named required
794:23 - attribute when we declare the attribute
794:26 - against the relevant program element we
794:28 - can omit the attribute suffix
794:32 - so in this case we can declare the
794:34 - attribute using the name required
794:41 - let's declare the string length
794:43 - attribute against the first name
794:45 - property
794:47 - let's pass appropriate values to the
794:49 - Constructor of the string length
794:51 - attribute
794:52 - so let's say the maximum character
794:53 - length for the first name input field
794:55 - should be 15.
794:59 - our next argument is the error message
795:01 - we wish to Output to the user if the
795:03 - user enters an invalid value for the
795:05 - first name field
795:06 - for the last parameter let's say the
795:09 - user must enter a value for the first
795:11 - name field that has at least two
795:13 - characters
795:22 - let's declare the required attribute
795:24 - against the first name property
795:30 - so we can copy and paste the custom
795:32 - attributes declared against the first
795:34 - name property to the last name property
795:37 - now the phone number property will
795:39 - include the same attributes and settings
795:41 - applied against the first name and last
795:43 - name properties
795:45 - but we also want to validate the phone
795:47 - number against a regular expression
795:49 - pattern that can be used to validate UK
795:53 - phone numbers
795:56 - so let's navigate to this URL
795:59 - I find this website very useful for
796:01 - finding regular expression patterns
796:05 - let's do a search for UK phone numbers
796:08 - let's copy an appropriate pattern from
796:10 - our search results
796:12 - we can then appropriately pass this
796:14 - pattern as an argument to our regular
796:17 - expression custom attribute
796:19 - so let's appropriately paste our pattern
796:21 - into our code
796:23 - note that we may need to include the ad
796:26 - symbol preceding the string references
796:28 - of the regular expression patterns
796:33 - this is because the pattern may include
796:34 - backslash characters which need to be
796:37 - escaped because the backslash character
796:39 - is used by C sharp within strings for
796:43 - escape sequences for example the
796:45 - backslash n escape sequence denotes a
796:47 - new line within a string the backslash T
796:50 - escape sequence denotes a horizontal tab
796:53 - character within a string Etc
796:55 - so by including the at symbol preceding
796:58 - the string we are indicating that any
797:00 - backslash character should be
797:02 - interpreted as a literal backslash
797:04 - character and not as part of an escape
797:06 - sequence
797:08 - so let's apply the custom attributes for
797:10 - the email address property
797:19 - let's find an appropriate regular
797:22 - expression pattern
797:25 - and appropriately paste it into our code
797:41 - let's do the same for the postcode
797:42 - address let's say we need the postcode
797:45 - to be a valid UK postcode
798:03 - great
798:05 - so now let's build a basic front end so
798:08 - that we can test our validation code
798:10 - let's write a reusable private method
798:13 - that contains logic to prompt the user
798:15 - for a relevant field value
798:18 - we need this code to run within an
798:20 - infinite Loop which we can Implement
798:22 - using a do Loop
798:24 - once the user enters a valid value the
798:27 - code will break out of the infinite Loop
798:29 - the get input method returns true once
798:32 - the user has inputted valid data for the
798:34 - relevant input field
798:35 - we can use the out keyword to make the
798:38 - last field and output parameter where we
798:40 - can pass the valid data to the calling
798:43 - code
798:45 - foreign
800:28 - let's go to the main method and
800:30 - implement the calling code let's
800:32 - instantiate an object of type employee
800:34 - let's ensure that we have a using
800:37 - directive to the attributes
800:39 - examples.models namespace
800:41 - because of course the employee class is
800:44 - a member of this namespace
800:47 - let's create three local string
800:49 - variables amp ID first name and postcode
800:54 - we need to get a reference to the
800:56 - employee classes type we can do this
800:58 - using the type of method like this
801:01 - let's write codes to handle the user
801:04 - input for the employees ID
801:07 - so once the user has entered a valid
801:09 - value for this field
801:11 - the valid data can be assigned to the ID
801:13 - property the ID property of the employee
801:16 - type is an integer value so let's write
801:18 - code to convert the relevant string
801:20 - value to an integer value
801:28 - let's write code to handle the user
801:30 - input for the employee's first name
801:33 - field
801:40 - once the user has entered a valid value
801:42 - for this field the inputted value can be
801:45 - assigned to the first name property
801:49 - let's write code to handle the user
801:51 - input for the employee's postcode
802:01 - so let's write code so that once the
802:04 - user has entered valid information for
802:06 - the relevant Fields a message stating
802:08 - that the user has now entered valid data
802:11 - for the relevant employee is outputted
802:13 - to the console screen
802:45 - great let's test the code
802:59 - so if we press the enter key without
803:01 - entering an employee ID
803:03 - we get an expected output
803:06 - an appropriate error message is
803:08 - outputted to the console screen
803:10 - let's enter a valid ID
803:13 - great so if we leave the first name
803:15 - field blank and press the enter key
803:18 - we get an appropriate error message
803:20 - output to the console screen
803:22 - if we enter just one character for the
803:24 - first name field
803:25 - the string length validation code deems
803:28 - our input as invalid and an appropriate
803:30 - error message is output to the console
803:32 - screen
803:34 - so now if we enter a value for our first
803:36 - name field that contains a character
803:39 - length that falls within the character
803:40 - length range which is between 2 and 15.
803:44 - this input is deemed as valid
803:46 - if we leave the postcode field blank we
803:49 - are presented with an appropriate error
803:51 - message
803:53 - let's enter a valid UK postcode
803:59 - great
804:01 - just to demonstrate that we are able to
804:03 - reuse our custom attributes on other
804:05 - user-defined types let's create another
804:08 - model
804:09 - let's create a class to represent a
804:11 - department record
804:33 - let's apply some of our custom
804:34 - attributes
804:54 - let's go to our main method and test our
804:57 - code
804:58 - in the interests of time we'll only
805:00 - include the department short name field
805:03 - in our test here
806:03 - excellent
806:06 - so let's use a predefined attribute that
806:08 - already exists in a.net library
806:11 - so the attribute I want to use is named
806:13 - Json ignore
806:15 - so we want to add functionality to
806:17 - Output our employee object to the
806:19 - console screen in Json format
806:21 - using the Json ignore attribute we can
806:24 - choose which fields to exclude from our
806:27 - employee object Json output
806:29 - let's declare the Json ignore attribute
806:32 - against the phone number property and
806:34 - the postcode property
806:49 - let's go to our main method and write
806:51 - the code to serialize the employee
806:53 - object in Json format
807:15 - let's run the code
807:33 - and you can see that the Json output
807:35 - does not include the phone number and
807:37 - the postcode Fields great
807:41 - let's comment out the Json ignore
807:43 - attribute declarations so that we can
807:45 - include all of our property values for
807:48 - the relevant employee object in our Json
807:50 - formatted output
807:57 - okay so I accidentally inputted Bob's
808:00 - surname which is Jones for the postcode
808:03 - field and I've noticed that there is a
808:05 - bug in our code the error message format
808:08 - outputted to the screen isn't correct
808:11 - the validation was run correctly I.E
808:13 - clearly Jones is not a valid postcode
808:15 - but the error message itself is
808:18 - incorrect the xero wrapped in curly
808:20 - brackets in the appropriate code should
808:23 - serve as a placeholder for the property
808:24 - name of the property against twitch the
808:27 - relevant attribute has been declared
808:30 - the one wrapped in curly brackets should
808:33 - serve as a placeholder for the regular
808:34 - expression pattern specified for the
808:37 - purpose of validating that a postcode
808:39 - entered by the user is in a correct UK
808:42 - postcode format
808:44 - so I can see what is causing this issue
808:46 - we need to remove the dollar symbol
808:49 - preceding the error message specified in
808:51 - this Constructor
808:53 - we want to use composite string
808:55 - formatting and not string interpolation
808:57 - for this string value
809:00 - for details on composite formatting
809:02 - versus string interpolation please view
809:04 - a video on c-sharp strings created by
809:07 - this channel a link to this tutorial is
809:09 - available Below in the description
809:12 - so let's repeat the input that we
809:14 - specified in the previous test
809:22 - great the validation code is correct
809:26 - and the outputted error message is also
809:29 - correct
809:51 - okay but in our outputted Json text here
809:55 - the postcode field is null so it looks
809:59 - like we have another bug here
810:01 - all right so when I copied and pasted
810:04 - the code here I forgot to change the
810:06 - relevant code so that the postcode
810:08 - property is set to the user's input
810:11 - okay
810:13 - let's correct this
810:18 - and let's test the code again
810:47 - excellent
810:52 - we looked at how attributes are used in
810:54 - code to add metadata to program elements
810:57 - like classes methods properties Etc and
811:00 - reflection can be used to read the
811:03 - metadata added through the use of the
811:04 - attributes at runtime
811:07 - we discussed that there are two broad
811:09 - categories in c-sharp for attributes
811:11 - namely predefined attributes which are
811:13 - built into the.net Base Class libraries
811:16 - and custom attributes which allow the
811:18 - developer to implement the developer's
811:20 - own attributes by creating a class that
811:23 - inherits from the system dot attribute
811:26 - built-in class either directly or
811:28 - indirectly
811:30 - we created code examples using
811:32 - predefined Global attributes namely
811:34 - assembly version attribute and assembly
811:37 - description attribute
811:39 - this demonstrated how Global attributes
811:41 - can be used to add and modify metadata
811:44 - at the assembly scope
811:48 - we created code examples using
811:50 - predefined general attributes namely
811:52 - conditional attribute obsolete attribute
811:55 - and attribute usage attribute this
811:58 - demonstrated how we can add and modify
812:00 - metadata for program elements
812:03 - we then created our own custom
812:05 - attributes as part of codelogic used for
812:09 - the purpose of field validation
812:11 - the use of reflection was also employed
812:14 - as part of this code logic this code
812:17 - implementation imitates how the asp.net
812:20 - MVC framework uses attributes for field
812:23 - validation
812:25 - I hope you've enjoyed this video on
812:27 - using attributes in c-sharp in the next
812:30 - part of this course we'll create a basic
812:32 - asp.net MVC application where we'll use
812:36 - Technologies like attributes link and
812:38 - Entity framework along with front-end
812:40 - Technologies like HTML bootstrap CSS and
812:45 - more please consider subscribing for
812:47 - more content on Advanced c-sharp topics
812:49 - and much more and please ring the bell
812:51 - so that you'll be notified of future
812:52 - content
812:53 - if you liked this video please give it a
812:55 - thumbs up it'll be greatly appreciated
812:58 - please feel free to share this video
813:00 - with anyone you feel May benefit from
813:01 - its content
813:03 - I really enjoy reading your comments so
813:05 - please feel free to engage with me in
813:06 - the comments section
813:08 - as always the code created for this
813:10 - video can be downloaded from GitHub
813:13 - a link to the relevant GitHub repository
813:15 - is available Below in the description
813:17 - [Music]
813:20 - foreign
813:21 - [Music]
813:30 - [Music]
813:34 - hi and welcome to the ninth and final
813:36 - part of this Vance c-sharp course
813:40 - I was going to end the advanced c-sharp
813:42 - course with an example of creating an
813:45 - asp.net MVC web application using
813:47 - c-sharp the more I delved into writing
813:50 - the tutorial on asp.net MVC the more I
813:54 - realized that asp.net MVC at least
813:57 - demands its own video series so I'm
814:01 - currently working on a video series
814:03 - where we'll build an asp.net MPC web
814:06 - application using C sharp I'll bring
814:10 - these videos to you as soon as I can as
814:13 - I had originally intended I'm going to
814:15 - finish the advanced c-sharp course
814:17 - focusing on the topic of c-sharp
814:19 - reflection
814:21 - so let's get into it
814:23 - let's first gain a basic understanding
814:25 - of reflection and then we'll write a
814:27 - code example using the reflection
814:29 - technology and C sharp
814:31 - so what is reflection reflection
814:35 - provides objects of type type
814:38 - that describe assemblies modules and
814:41 - types
814:42 - you can use reflection to dynamically
814:45 - create an instance of a type bind the
814:48 - type to an existing object or get the
814:50 - type from an existing object and invoke
814:52 - its methods or access its fields and
814:55 - properties if you are using attributes
814:58 - in your code reflection enables you to
815:01 - access them
815:02 - for Content like this and much more
815:04 - please consider subscribing and please
815:06 - ring the bell so that you'll be notified
815:08 - of future content if you like this video
815:10 - at any point please give it a thumbs up
815:12 - it will be greatly appreciated
815:15 - in the eighth part of this Advanced
815:17 - c-sharp course on c-sharp attributes we
815:20 - use the reflection technology to read
815:22 - metadata provided through the use of our
815:24 - own custom attributes from relevant
815:26 - program elements when I say program
815:29 - elements I'm referring to classes
815:30 - methods Fields properties Etc
815:33 - so reflection allows the developer to
815:36 - access metadata within.net assemblies at
815:39 - runtime.net assemblies are
815:41 - self-describing entities which means the
815:43 - metadata data about the relevant
815:45 - assemblies reside within the assembly
815:47 - itself so at runtime we are able to load
815:50 - a Target assembly and read its metadata
815:53 - using reflection
815:55 - using reflection we are able to for
815:58 - example instantiate objects from classes
816:01 - that reside within the target assembly
816:03 - and invoke the relevant objects methods
816:05 - or get and set the relevant objects
816:08 - property values
816:10 - so in this video we are going to create
816:12 - a code example that will serve as a test
816:15 - harness
816:16 - we are going to create code that loads a
816:19 - Target assembly and displays a list of
816:22 - relevant classes that reside within the
816:25 - target's assembly
816:26 - we can then select an item in the
816:28 - relevant list that represents a class
816:30 - and test the functionality within each
816:33 - of the classes methods
816:36 - the important thing to note here is that
816:38 - in this example we will not reference
816:41 - the target assembly from within the
816:43 - project that contains our calling client
816:45 - code
816:46 - we are using reflection to late bind to
816:49 - the classes that reside within the
816:52 - target assembly
816:53 - so that we can instantiate objects and
816:56 - test the object's functionality at
816:58 - runtime
817:00 - note that when I refer to the Target
817:02 - assembly I am referring to the assembly
817:05 - that contains the functionality we wish
817:07 - to test through our test harness
817:10 - we will be using what is known as late
817:12 - binding to test the methods that reside
817:15 - within the relevant classes contained
817:17 - within the target assembly so what is
817:21 - late binding
817:23 - when we reference an assembly from a
817:25 - project through for example visual
817:27 - studio and subsequently write code to
817:30 - instantiate an object from a class that
817:33 - resides within the referenced assembly
817:35 - this is known as early binding when we
817:38 - reference an assembly like this the
817:40 - compiler has information about the
817:42 - target assembly at compile time
817:45 - light binding occurs when we don't set a
817:48 - reference to a Target assembly at
817:49 - compile time and we instantiate an
817:52 - object from a class that resides within
817:54 - the target assembly at run time
817:57 - the obvious disadvantage to late binding
818:00 - is that late binding is prone to runtime
818:02 - errors when early binding is employed
818:05 - the compiler has relevant knowledge for
818:08 - example relevant type information about
818:10 - the target assembly's constituents at
818:13 - compile time so compile time errors can
818:16 - be flagged and corrected at compile time
818:19 - potential errors are averted at compile
818:22 - time and therefore certain runtime
818:24 - errors are avoided with late binding
818:26 - reflection can be employed to gain
818:29 - necessary information about the target
818:31 - assembly itself and its constituents at
818:34 - runtime
818:35 - so let's create our test harness code
818:37 - example where we'll use late binding to
818:40 - test the functionality that resides
818:41 - within a Target assembly
818:44 - let's create a.net core console
818:46 - application named test harness
819:11 - let's creates.net standard Library
819:13 - project named utility functions
819:28 - the utility functions project will be
819:30 - compiled into our Target assembly
819:34 - now it is important to note that I have
819:36 - included the utility functions project
819:38 - which of course when compiled is
819:40 - compiled into a.net assembly in the same
819:42 - solution as the.net core console project
819:45 - where we'll write our calling client
819:46 - code this is important to note because
819:49 - we are not going to explicitly reference
819:51 - the utility functions assembly from
819:53 - the.net core console project so if we
819:56 - were to early bind to the utility
819:58 - functions assembly we would reference
820:00 - our utility functions project like this
820:07 - but let's cancel this dialog box because
820:10 - we are going to load the utility
820:12 - functions assembly at runtime using
820:14 - reflection
820:15 - we are not going to set a reference to
820:17 - it at compile time we want to late bind
820:20 - to the utility functions assembly at
820:22 - runtime
820:24 - this is obviously just a mark example
820:26 - and not a real world application but you
820:29 - can see how we could put a number of
820:31 - assemblies within a directory Traverse
820:34 - the assemblies within the relevant
820:35 - directory and automate the testing of
820:38 - functionality within the target
820:40 - assemblies at runtime we would not have
820:43 - to reference any of these assemblies
820:45 - within our test harness project because
820:47 - using reflection we can access all the
820:50 - information we need for each assembly
820:52 - and test the functionality within the
820:55 - assemblies so the advantage of this
820:57 - loose coupling of our test harness
820:59 - application with the assemblies that we
821:01 - are testing is that we don't need to
821:04 - early bind to the assemblies that
821:05 - compile time we can simply put an
821:08 - assembly or assemblies in an appropriate
821:10 - directory and our test harness
821:12 - application can learn about the assembly
821:14 - or assemblies at runtime by accessing
821:18 - the relevant assembly's metadata at
821:20 - runtime through reflection
821:24 - but we will simplify this example and
821:26 - focus on classes within a particular
821:29 - namespace within one target assembly our
821:32 - Target assembly in this case will be the
821:35 - utility functions assembly if this
821:37 - doesn't make sense to you at the moment
821:39 - please bear with me and this will become
821:41 - clearer as we progress with creating
821:44 - this code example
821:46 - let's include basic functionality within
821:48 - our utility functions project once
821:51 - completed this project will be compiled
821:54 - into an assembly which will serve as our
821:56 - Target assembly I.E the assembly against
821:58 - which will perform our reflection
822:00 - functionality
822:02 - through the use of reflection we'll be
822:04 - able to read relevant information about
822:06 - the assembly instantiate objects from
822:09 - its classes and test its methods
822:12 - so let's write the code for the utility
822:14 - functions assembly let's start by
822:17 - deleting the class that was
822:18 - auto-generated by Visual Studio
822:22 - let's add a class named basic utility
822:24 - functions
822:36 - within the basic utility functions class
822:38 - let's create four very simple methods
822:41 - let's create a method named write
822:43 - welcome message the right welcome
822:45 - message method contains no parameters
822:47 - and returns a welcome message as a
822:50 - string
822:55 - let's write a method named integer plus
822:58 - integer the integer plus integer method
823:00 - contains two integer parameters and
823:03 - returns an integer value
823:04 - The Returned integer value will be the
823:07 - mathematical result of the first integer
823:09 - argument plus the second integer
823:12 - argument
823:13 - we can appropriately name our parameters
823:15 - operand 1 and operand 2 respectively
823:19 - let's write a method named concat three
823:21 - strings this method contains three
823:24 - string parameters and returns a string
823:27 - value
823:28 - The Returned string is a concatenation
823:30 - of the arguments
823:32 - passed into the concat three strings
823:34 - method
823:36 - the order in which the string arguments
823:38 - are concatenated is the order in which
823:40 - their corresponding parameters appear in
823:43 - the relevant parameter list from left to
823:46 - right
823:47 - let's write a method named get string
823:49 - length it contains one string parameter
823:52 - this method returns an integer value
823:55 - the character length of the string
823:57 - argument passed into the get string
823:59 - length method
824:01 - and that's it that is our very basic
824:03 - basic utility functions class completed
824:07 - let's create another basic class let's
824:09 - name this class basic math functions
824:22 - let's create two really simple methods
824:24 - in this class
824:26 - let's create a method named divide
824:28 - operation which contains two parameters
824:30 - of type double this method returns a
824:32 - value of type double that is the result
824:35 - of a divide mathematical operation in
824:37 - this method the second argument is
824:39 - divided into the first argument and the
824:42 - result of the Divide operation is
824:44 - returned to the calling code
824:46 - let's create a method named multiply
824:48 - operation
824:49 - which contains two parameters of type
824:51 - double this method returns a value of
824:54 - type double that is the result of a
824:56 - multiplication mathematical operation
824:58 - where the first number argument is
825:00 - multiplied by the second number argument
825:03 - the return value will be the product
825:05 - which of course is the result of the
825:07 - multiplication of the first number
825:09 - argument
825:10 - by the second number argument
825:13 - okay so we now have two classes in our
825:16 - utility functions project
825:18 - so now we want to be able to decorate
825:21 - certain program elements with a custom
825:23 - attribute that we can use to provide
825:25 - additional information to the calling
825:28 - code about the relevant program elements
825:30 - in this case the program elements will
825:33 - be classes and methods
825:36 - let's create a custom attribute named
825:39 - information attribute for more
825:41 - information on custom attributes please
825:43 - view the previous part of this course
825:45 - which is a tutorial entitled c-sharp
825:48 - attributes I have included a link to the
825:50 - relevant video Below in the description
825:53 - so in order to create a custom attribute
825:56 - the relevant class must inherit from the
825:59 - system.attribute built-in class
826:03 - let's keep this class really basic so
826:06 - let's add one Auto implemented property
826:08 - named description this property will
826:10 - enable us to provide a custom
826:12 - description about a program element that
826:15 - we'll decorate with our information
826:17 - attribute custom attribute we want to
826:20 - constrain our information attribute
826:22 - custom attribute to the decoration of
826:25 - only class and Method program elements
826:27 - so we can do this by decorating our
826:30 - information attribute custom attribute
826:32 - class with the attribute usage built-in
826:34 - attribute we can then pass the following
826:37 - bitwise operation to the Constructor of
826:39 - the attribute usage built-in attribute
826:42 - so let's pass
826:44 - attributetargets.class or attribute
826:46 - targets.method to the Constructor of the
826:49 - attribute usage built-in attribute so
826:52 - this means that only classes and methods
826:55 - can be decorated without information
826:56 - attribute custom attribute
827:00 - so next let's apply our custom attribute
827:02 - to the relevant classes and methods
827:04 - let's go to the basic utility functions
827:07 - class and let's decorate the class
827:08 - itself and its methods with the
827:11 - information attribute custom attribute
827:13 - so let's set the description property
827:15 - for our custom attribute declared
827:17 - against the basic utility functions
827:19 - class to this class contains basic
827:22 - utility methods
827:28 - let's set the description property for
827:30 - our custom attribute declared against
827:31 - the right welcome message method to this
827:34 - method returns a welcome message
827:36 - let's set the description property for
827:39 - our custom attribute declared against
827:41 - the integer plus integer method to this
827:43 - method Returns the sum of two integer
827:46 - operands
827:47 - let's set the description property of
827:50 - our custom attribute declared against
827:51 - the concat three strings method to this
827:54 - method concatenates three strings in the
827:57 - same order as they appear in the
827:59 - parameter list from left to right
828:03 - let's set the description property for
828:05 - our custom attribute declared against
828:07 - the get string length method to this
828:10 - method Returns the character length of a
828:12 - string argument
828:15 - so let's move on to our basic math
828:17 - functions class let's decorate the basic
828:20 - math functions class with our
828:22 - information attribute custom attribute
828:24 - like this so here the description
828:26 - property is set to this class contains
828:28 - basic math functionality let's decorate
828:32 - The Divide operation method with our
828:34 - custom attribute where the attributes
828:36 - description property is set to this
828:39 - method divides the first number by the
828:42 - second number and returns a result of
828:44 - this divide operation
828:46 - and lastly let's decorate the multiply
828:48 - operation method with our custom
828:50 - attribute and set its description
828:52 - property to this method multiplies the
828:55 - first number
828:56 - by the second number and returns a
828:58 - result of this multiplication operation
829:01 - so we have included in the metadata for
829:04 - our utility functions assembly very
829:07 - basic descriptions about method and
829:09 - class program elements through the use
829:12 - of our information attribute custom
829:14 - attribute
829:15 - now let's write the calling client code
829:18 - so in the calling client code we want to
829:21 - provide functionality that targets a
829:23 - particular namespace within the target
829:25 - assembly in this case our Target
829:27 - assembly will be the utility functions
829:30 - assembly
829:31 - and reads all the relevant information
829:33 - about the assembly's classes and methods
829:35 - that are members of the relevant
829:37 - namespace
829:39 - we'll create functionality where the
829:41 - user can choose a class from a list of
829:43 - classes that reside within the relevant
829:46 - namespace once the user has chosen the
829:49 - class that the user wishes to test the
829:51 - user can then choose a method from a
829:54 - list of methods that are members of the
829:56 - relevant class the user can then select
829:58 - from a list of methods the method that
830:00 - the user wishes to test once the user
830:03 - has chosen the method that the user
830:05 - wishes to test the user is prompted for
830:07 - values for each of the parameters
830:10 - contained within the relevant methods
830:12 - method definition
830:13 - once the user has provided values for
830:16 - all the relevant parameters our code
830:18 - will invoke the method and the result
830:20 - returned by the method is displayed to
830:23 - the console screen
830:24 - so you can see that this test harness
830:27 - application can be used to test
830:29 - functionality within an assembly note
830:32 - that you can extend the code that we are
830:35 - about to write to Traverse a number of
830:37 - assemblies within a directory and
830:39 - automatically test particular
830:40 - functionality within the assemblies
830:43 - so you could write your own automated
830:46 - test facility based on the code we are
830:49 - about to write
830:50 - for the purposes of this tutorial
830:52 - however the code will be simplified
830:56 - so let's write the code for our test
830:58 - harness project which is our.net core
831:00 - console project
831:01 - the first thing to do is within our
831:03 - calling client code is include a using
831:05 - directive to the system.reflection
831:07 - namespace like this so that we can make
831:10 - use of reflection in our application
831:13 - so let's start writing our code in the
831:16 - main method
831:17 - let's first create two local string
831:19 - constants the first constant stores the
831:22 - target assembly file name utility
831:24 - functions.dll the second constant stores
831:28 - the Target namespace that contains the
831:30 - classes that the user will be able to
831:33 - test through our test harness
831:35 - application so the namespace is utility
831:37 - functions
831:39 - let's write the code that will load the
831:41 - target assembly at runtime
831:43 - so we are using the assembly.load method
831:46 - to do this
831:47 - but we may need to replace this with the
831:49 - assembly.load file method when we test
831:52 - and debug the code later in the tutorial
831:54 - we'll know which method needs to be
831:56 - employed here either the load or load
831:59 - file method so we'll leave it as load at
832:02 - this point
832:05 - we pass in the path of where the target
832:07 - assembly will be in order to load the
832:09 - target assembly into memory
832:12 - so later in this tutorial just before we
832:15 - test our code for the sake of Simplicity
832:17 - we'll copy the target assembly into the
832:19 - same directory as where the assembly for
832:22 - this project will reside so let's write
832:24 - code here to point to the path of the
832:26 - target assembly which will be the
832:28 - current directory the same directory as
832:31 - where the test harness assembly will
832:33 - reside
832:35 - let's use the path.combine method to
832:38 - combine a path with the name of the file
832:41 - the path class resides in the system.io
832:44 - namespace so let's include a using
832:46 - directive to the system dot IO namespace
832:50 - so we are able to get the current path
832:52 - from the appdomain.current domain dot
832:55 - base directory property
832:57 - this is the directory where the assembly
832:59 - that we are currently working on will
833:02 - reside
833:03 - let's pass this value as the first
833:05 - argument to the path.combine method
833:08 - then let's pass the name of our Target
833:10 - assembly which is utility
833:13 - functions.dll as the second argument
833:16 - into the path.conbind method
833:20 - the return value from the assembly.load
833:22 - method will be the object of type
833:25 - assembly so let's assign a variable of
833:27 - type assembly the value returned from
833:30 - the assembly.load method
833:32 - so we have now got a reference in memory
833:34 - to our Target assembly
833:37 - let's write code to get a list of
833:39 - classes from the target namespace within
833:41 - our Target assembly
833:42 - so the namespace within our Target
833:45 - assembly is named utility functions
833:47 - so let's use Link to get a list of types
833:50 - or classes from within the utility
833:52 - functions namespace
833:55 - let's ensure that we have a using
833:56 - directive to the system.link namespace
834:00 - so we can use the assembly objects get
834:03 - types method to return a collection of
834:05 - classes that reside within the target
834:07 - assembly
834:08 - we can use the where method to filter
834:12 - on the assemblies utility functions
834:14 - namespace like this
834:18 - let's assign The Returned result to a
834:21 - generic list that is strongly typed as
834:23 - system.type
834:38 - then let's convert the innumerable
834:40 - collection returned by the link query to
834:42 - a list and we can do this by using the
834:45 - to list conversion method like this
835:20 - let's write a method that encapsulates
835:22 - writing a prompt to the user
835:25 - let's write code to display a message
835:27 - prompting the user for input to the
835:30 - console screen
835:31 - as you can see we are prompting the user
835:34 - to press a number key to indicate to the
835:36 - application which class the user wishes
835:38 - to test
835:40 - so it is better to encapsulate this
835:42 - prompting functionality in a method that
835:45 - we can reuse for this purpose throughout
835:47 - the creation of this application
835:49 - this method encapsulates the
835:51 - functionality of displaying text to
835:53 - prompt the user for input to the console
835:56 - screen
835:58 - so next we want to write code to display
836:00 - a list of classes to the console screen
836:02 - so that the user can select a class that
836:04 - the user wishes to test
836:06 - so we can simply write code that
836:08 - traverses the items stored in the
836:10 - classes list
836:12 - which contains the result of our link
836:14 - query and output the relevant class
836:16 - names to the console screen in
836:19 - sequential order
836:21 - so let's do this
836:26 - in our list of classes each class name
836:29 - is preceded by a number which will allow
836:31 - the user to press a number key to select
836:33 - the class that the user wishes to test
836:36 - let's write the code where the user can
836:38 - press a number to select a class from
836:40 - the classes list
836:48 - let's use a switch statement to return
836:50 - the relevant item from the list
837:11 - so now we want to create an object
837:13 - instance from the user's chosen class or
837:16 - type we can use the activator.create
837:19 - instance method to do this
837:21 - and here we are writing code to late
837:23 - bind to a class within the target
837:26 - assembly we can assign The Returned
837:29 - object from the activator.create
837:31 - instance method to a variable of type
837:34 - object
837:35 - you can see that when we like bind like
837:37 - this we do not have the benefits of type
837:40 - safety so code like this is prone to
837:43 - runtime errors this highlights a
837:45 - disadvantage of late binding like this
837:47 - in code
837:49 - so because at compile time we don't know
837:52 - the type that will be returned at
837:54 - runtime by the activator.create instance
837:57 - method we need to use a variable of type
837:59 - object to reference The Returned value
838:03 - so we have now written the code enabling
838:06 - the user of our application to choose a
838:08 - class from a list of classes by pressing
838:11 - a number key associated with the
838:13 - relevant class
838:15 - once the user has chosen a class the
838:17 - user will be presented with a list of
838:19 - relevant methods
838:21 - let's write code to clear the screen
838:23 - once the user has chosen the class from
838:26 - the list of classes
838:29 - let's write a method where we can
838:31 - encapsulate code to Output a heading to
838:33 - the console screen on the screen that
838:35 - displays a list of methods belonging to
838:37 - the class that the user has selected we
838:41 - want to include a heading at the top of
838:43 - the screen containing the class name
838:45 - that the user has chosen let's go to the
838:48 - main method and write the code to Output
838:49 - the relevant heading to the console
838:51 - screen
838:58 - let's write code to prompt the user to
839:01 - choose from a list of relevant methods
839:04 - we now want to write code to Output a
839:06 - list of relevant methods to the console
839:08 - screen
839:09 - so logically the code to present the
839:11 - user with a list of methods is exactly
839:13 - the same as the code that presents the
839:15 - user with a list of classes
839:17 - so we have an opportunity here to
839:19 - refactor our code by creating a reusable
839:22 - method that encapsulates functionality
839:25 - to Output a list of both classes and
839:27 - methods
839:29 - so this will be one block of code that
839:32 - can output a list for both classes and
839:34 - methods
839:36 - in this method we need to account for
839:38 - the difference between the type
839:39 - representing a class and the type
839:41 - representing a method in this context
839:44 - classes are of type system.type and
839:47 - methods are of type method info
839:50 - so to solve this problem we can apply
839:53 - generics
839:54 - let's create a method named display
839:57 - program element list let's include the T
840:00 - placeholder between greater than and
840:02 - less than symbols to indicate that this
840:05 - is a generic method
840:07 - let's base the code for this method on
840:09 - the code that we have already written in
840:11 - the main method to Output a list of
840:13 - classes
840:14 - you can see that we are writing this
840:16 - code in a more generic style because
840:18 - this code will output the items of a
840:21 - generic list that is strongly typed as
840:24 - system.type and a generic list that is
840:26 - strongly typed as method info
840:35 - great
840:37 - so let's replace the code in the main
840:39 - method that outputs a list of classes
840:42 - with a call to our display
840:44 - program element list method
840:49 - the type that represents a class in
840:52 - terms of reflection is system.type
840:55 - we have another opportunity to refactor
840:57 - our code because the code to return an
841:00 - object of type system.type from our list
841:03 - of classes or types logically is the
841:06 - same as the code to return an item of
841:09 - type method info from a list of methods
841:12 - so let's write code to encapsulate this
841:14 - functionality in a method named return
841:16 - program element reference from list
841:21 - so we need to include generic
841:23 - functionality within the method
841:24 - definition of the return program element
841:26 - referenced from list method we also need
841:29 - to return a value of type T from this
841:32 - method
841:40 - and we can copy the code for this method
841:42 - from our main method and paste it into
841:44 - our return program element reference
841:46 - from list method
842:09 - so let's replace the code in our main
842:11 - method that enables the user to choose
842:13 - from a list of classes with a call to
842:16 - the return program element reference
842:18 - from list method
842:42 - so let's call the get methods method on
842:45 - the type Choice object which represents
842:47 - the class that the user has chosen from
842:50 - the relevant list and assign The
842:52 - Returned value to a generic list
842:55 - that is strongly typed as method info
842:58 - note that a generic list that is
843:00 - strongly typed as system.type is used to
843:03 - store references to classes or types and
843:07 - a generic list that is strongly typed as
843:09 - method info is used to store a list of
843:12 - methods
843:14 - we can now reuse the display program
843:16 - element list method
843:18 - in our main method to display a list of
843:21 - methods
843:22 - we can pass in the method info type to
843:25 - the relevant type parameter but we don't
843:27 - actually need to do this here because
843:29 - the compiler has enough information to
843:32 - determine the type
843:34 - let's call the return program element
843:36 - reference from list method which will
843:39 - enable the user to choose a method from
843:41 - a list of methods displayed to the
843:43 - console screen
843:44 - let's write an if statement to check if
843:47 - the method info object returned from the
843:49 - return program element reference from
843:51 - list method is not null
843:54 - let's write code to clear the screen
843:56 - let's write code to Output a heading
843:58 - containing the class name and the method
844:00 - name of the class n method that the user
844:02 - has chosen to test
844:05 - so the next step is to prompt the user
844:08 - to provide a value for each parameter of
844:10 - the relevant method
844:12 - so we are able to get a list of
844:14 - parameters from the relevant method by
844:16 - implementing the method info objects get
844:18 - parameters method like this
844:21 - and we can assign The Returned result to
844:23 - an array of type parameter info
844:26 - the next step is to invoke the method
844:29 - chosen by the user and pass in the
844:31 - relevant parameter values that will be
844:34 - provided by the user's input I.E if the
844:37 - relevant method contains any parameters
844:40 - if the relevant method does not contain
844:42 - any parameters the method can be invoked
844:45 - without any arguments passed to it
844:48 - so let's encapsulate the functionality
844:50 - for this in a method named get result
844:54 - in order to execute the functionality
844:56 - for the get result method we need the
844:58 - relevance class instance object the
845:01 - relevant method info object and the
845:03 - array containing the relevant array of
845:06 - parameter info objects
845:08 - so in the get results method definition
845:10 - let's include a parameter of type object
845:13 - to accommodate the class instance let's
845:16 - include a parameter of type method info
845:18 - to accommodate the relevant method to be
845:20 - executed and let's include a parameter
845:23 - that accommodates an array of type
845:25 - parameter info so the invocation of our
845:29 - method is going to be different in terms
845:30 - of code implementation when the method
845:33 - that is invoked requires a number of
845:34 - arguments to when the method requires no
845:37 - arguments passed to it I.E the relevant
845:40 - methods method definition contains no
845:42 - parameters
845:43 - so let's create an if statement that
845:45 - checks to see if the parameter's
845:47 - argument contains any items if it does
845:50 - not contain any items we can call the
845:53 - method info objects invoke method and
845:55 - pass null into the second argument
845:59 - the first argument must be passed an
846:02 - argument that references the appropriate
846:04 - class instance
846:06 - this class instance or object contains
846:08 - the method that we are invoking here
846:10 - through this line of code the else part
846:13 - of the if statement invokes a method
846:15 - that does contain parameters so we must
846:18 - write code to prompt the user for a
846:21 - value for each parameter
846:23 - so let's create a method that allows for
846:25 - an argument which will contain an array
846:27 - of parameter info objects to be passed
846:30 - to it
846:31 - so let's name this method return
846:33 - parameter value input as object array
846:36 - let's create a one-dimensional array
846:38 - named param values and provision the
846:41 - array to hold a number of items equal to
846:44 - the number of items stored in the array
846:46 - passed into this method I.E the array of
846:49 - type parameter info
846:52 - let's create a counter variable named
846:54 - item count
846:55 - and initialize it to a value of zero
846:58 - let's create a for each Loop to Loop
847:01 - through each item in the parameters
847:03 - array let's write codes to prompt the
847:06 - user to enter a parameter value
847:09 - so let's say that we know that the
847:10 - parameter type can only be one of the
847:12 - following string int or double
847:15 - so let's write an if statement to check
847:18 - the type of the relevant parameter if
847:20 - the parameter is a string
847:22 - then no type conversion of the
847:24 - console.redline method value is
847:26 - necessary because this method returns a
847:29 - string
847:31 - so we can then write code to assign the
847:33 - user's inputs to the relevant position
847:35 - in the parameter values array
847:38 - so the code for when the relevant
847:40 - parameters of type int or double is
847:42 - slightly different we must include an
847:44 - explicit type conversion from string
847:46 - returned by the console.readline method
847:49 - to the relevant type before assigning
847:52 - the inputted value to the appropriate
847:55 - position in the param values array we
847:58 - must increment the item count variable
848:00 - by 1 for each iteration of the loop
848:04 - in the location in our code editors
848:06 - where the loop has exited
848:08 - we can write the code to return the
848:10 - param values array to the calling code
848:15 - great
848:17 - so let's go back to the get result
848:18 - method and call the return parameter
848:21 - value input as object array method
848:28 - then we can write codes to invoke the
848:30 - relevant method and pass in an array
848:33 - argument containing the user's input for
848:35 - each parameter as the second argument to
848:37 - the method.invoke method like this
848:41 - as stated earlier the first argument
848:43 - passed to the invoke method is the
848:45 - relevant instantiated object
848:47 - instantiated from the class that the
848:49 - user has chosen to test
848:52 - to finish this method off let's write
848:54 - the code to return the result returned
848:56 - by the relevant method to the calling
848:58 - code
848:59 - let's then go to the main method and
849:01 - call the get result method let's write
849:03 - the code to display The Returned result
849:05 - from the get result method to the
849:07 - console screen
849:30 - great
849:46 - before we test the code let's compile
849:48 - our two projects
850:01 - let's find the targets assembly
850:12 - and let's copy the assembly to our
850:15 - clipboards
850:20 - then let's go to the directory of our
850:22 - test harness project
850:32 - and paste the target assembly into this
850:35 - directory
850:36 - Let's test our code
850:46 - okay so we have a little bug here so I
850:49 - suspect this is because we need to use
850:51 - the load file method instead of the load
850:53 - method so let's change the code
850:55 - accordingly
850:56 - let's run the code again
851:03 - great we can see our class is displayed
851:05 - in a list
851:06 - but our information attribute custom
851:08 - attribute class is also present in the
851:11 - list and this is not desirable
851:14 - we don't have any methods in the
851:16 - information attribute custom attribute
851:18 - class to test
851:20 - so if we select one of the classes that
851:24 - we wish to test like for example the
851:26 - basic utility functions class we are
851:28 - presented with a list of methods which
851:31 - is great there are some methods listed
851:33 - here that we are not interested in
851:35 - testing like for example the equals
851:37 - method or get hash code method these
851:40 - methods belong to the object class which
851:42 - as we know is ultimately the base class
851:44 - for all types in C sharp so we only want
851:48 - to test the methods that perform
851:49 - functions directly related to the class
851:51 - we have selected in this case the basic
851:54 - utility functions class
851:57 - we'll modify the code to filter out
851:59 - undesirable code elements in a bit for
852:01 - now let's continue with our test let's
852:04 - select the integer plus integer method
852:08 - oh we should be receiving a prompt to
852:10 - enter a value for each of the parameters
852:12 - contained within the integer plus
852:14 - integer method
852:16 - so we have another bug to fix
852:19 - so here's where we need to fix the bug I
852:21 - forgot to include the prompt text in the
852:24 - return parameter value input as object
852:27 - array method
852:28 - so let's include a prompt for each
852:30 - parameter item
852:33 - foreign
852:39 - Let's test the code again
852:45 - let's select the basic utility functions
852:48 - class from our list of classes
852:50 - let's select the integer plus integer
852:52 - method
852:53 - so we are now prompted to enter a value
852:56 - for the first parameter great
852:58 - so let's do that let's enter five
853:02 - we are then prompted to provide a value
853:03 - for the second parameter let's enter a
853:06 - value of 6 for this parameter
853:09 - once we press the enter key the correct
853:11 - result of 11 is presented to us great
853:15 - so except for the fact that certain
853:17 - program elements that we have no desire
853:19 - to test
853:20 - are appearing in our lists the basic
853:23 - functionality of our test harness is
853:25 - working as expected so let's write the
853:28 - code to filter out those unwanted
853:30 - program elements
853:32 - we are going to use the information
853:33 - attribute custom attribute for this
853:35 - purpose
853:36 - let's say that we only want those
853:38 - program elements that are decorated with
853:40 - our information attribute custom
853:42 - attribute to appear in our lists of
853:44 - program elements to test
853:46 - so let's write a method that checks the
853:49 - CFA program elements iea class or a
853:51 - method is decorated with the information
853:53 - attribute custom attribute if the
853:56 - program element is decorated with the
853:58 - information attribute custom attribute
854:00 - we want to include the relevant program
854:02 - element in our list of program elements
854:04 - to test
854:05 - if however the program element is not
854:07 - decorated with the information attribute
854:10 - custom attribute we must exclude the
854:12 - relevant program element from our list
854:14 - of program elements to test
854:17 - so let's write a private static method
854:19 - named has information attribute
854:22 - and let's include one parameter within
854:25 - its method definition this parameter
854:27 - will represent the program element that
854:29 - we need to check so we need the has
854:31 - information attribute method to check if
854:33 - the information attribute custom
854:35 - attribute has been declared against the
854:38 - relevant program element in the context
854:40 - of the requirement of this application
854:42 - the program element can either be a
854:44 - class or a method
854:46 - so the parameter must be of a type that
854:49 - can accept a class or a method as an
854:51 - argument in this particular case those
854:53 - types will either be of type system.type
854:56 - or of type method info we could include
855:00 - two methods named has information
855:01 - attribute and differentiate their method
855:04 - definition where each method definition
855:06 - contains a parameter of a different type
855:09 - one version of the has information
855:11 - attribute method can contain a parameter
855:13 - of type system.type and the other
855:16 - version of the method can contain a
855:18 - parameter of type method info
855:21 - so we could use method overloading to
855:24 - perform the desired check for if a
855:26 - custom attribute has been declared
855:28 - against a program element I.E either a
855:31 - method or a class however we can achieve
855:33 - what we want with only one version of
855:35 - the has information attribute method
855:37 - because the system.type and Method info
855:40 - types both inherit from a common class
855:43 - the member info class if we right click
855:47 - the text in our code editors
855:48 - representing the type class and select
855:50 - go to definition we can see that the
855:53 - type class inherits from the member info
855:55 - class if we do the same thing against
855:58 - the method info class we can see that
856:00 - the method info class also inherits from
856:03 - the member info class
856:05 - if we look at the member info class
856:07 - definition we can see that it contains a
856:09 - method named get custom attributes and
856:12 - this is the method we need to use to
856:14 - check if the relevant program element is
856:16 - decorated with the information attribute
856:19 - custom attribute
856:21 - so the point is we don't need to
856:23 - overload the has information attribute
856:25 - method we can simply Define the
856:27 - parameter for the has information
856:29 - attribute method as member info in one
856:32 - method
856:33 - this will mean we can pass both types of
856:36 - arguments to the has information method
856:38 - I.E an argument of type system.type
856:41 - a class program element or an argument
856:44 - of type method info
856:47 - a method program element
856:49 - so let's look at the code for the has
856:50 - information attribute method we have
856:53 - created a local string constant to store
856:55 - the name of the type of our information
856:57 - attribute custom attribute so this name
857:00 - includes the namespace of where the
857:01 - information attribute custom attribute
857:03 - resides a full stop and the attribute
857:06 - class name
857:08 - we have written code to Loop through all
857:10 - the custom attributes that may be
857:12 - declared against the program element
857:14 - type passed into this method
857:16 - as you can see we are able to call the
857:19 - get custom attributes method for both
857:20 - class and Method program elements in our
857:23 - method because the system.type class
857:25 - which represents class program elements
857:27 - and the method info class which
857:29 - represents method program elements both
857:32 - inherit from the member info class which
857:35 - contains the get custom attributes
857:36 - method within our for each Loop we first
857:39 - get the type of the current attribute
857:42 - so we have written type attrib equals
857:44 - attrib the current attribute object dot
857:47 - get type
857:49 - we then check to see if the name of the
857:52 - type attribute is equal to the
857:54 - information attribute custom attributes
857:56 - name if it is this means that the
857:59 - information attribute custom attribute
858:01 - has been declared against the program
858:02 - element type passed as an argument to
858:05 - this method so we can return true to the
858:08 - calling code
858:09 - if all attributes have been traversed
858:11 - and none of the attributes match our
858:14 - information attribute custom attribute
858:16 - this means that the program element
858:18 - passed as an argument to the method does
858:21 - not have our information attribute
858:22 - custom attribute declared against it so
858:25 - we must return false
858:27 - so this method can be used in our
858:30 - calling code to filter out program
858:31 - elements based on whether or not
858:34 - the relevant program element is
858:36 - decorated with the information attribute
858:38 - custom attribute so how can we use our
858:41 - method for this purpose in our main
858:43 - method the answer is we could modify the
858:46 - relevant link queries to include our has
858:49 - information attribute method
858:52 - and we can include our has information
858:54 - attribute method in the relevant where
858:57 - filters
858:58 - so let's first modify the link query for
859:01 - returning a list of class program
859:02 - elements we can simply include a call to
859:05 - our has information attribute method in
859:08 - the where filter method like this
859:22 - to filter out methods that aren't
859:23 - decorated with the information attribute
859:26 - custom attribute we can modify the
859:28 - appropriate link query like this
859:48 - Let's test our code
859:54 - excellent
859:55 - you can see that only those classes in
859:58 - our Target assembly that are decorated
860:01 - with the information attribute custom
860:02 - attribute appear in the relevant list
860:05 - if we select the basic math functions
860:08 - class from our list of classes we can
860:10 - see that its methods that are not
860:12 - decorated with the information attribute
860:14 - custom attribute have been filtered out
860:16 - of the relevant list
860:23 - great
860:24 - let's also include functionality to
860:26 - appropriately outputs to the console
860:28 - screen the description property value of
860:31 - the information attribute custom
860:32 - attribute for our relevant program
860:34 - elements in terms of the user's
860:36 - experience this functionality will
860:39 - provide additional information about the
860:40 - classes and methods that the user wishes
860:43 - to test
860:45 - so let's write a private static method
860:47 - named return information custom
860:49 - attribute description
860:51 - this method returns a string and
860:53 - contains a parameter of type member info
860:57 - remember both the system.type class and
861:00 - the method info class inherit from the
861:02 - member info class so this method can be
861:05 - reused for both class and Method program
861:08 - elements
861:09 - we want to read the description property
861:11 - so let's create a local string constant
861:13 - that references the text description
861:17 - let's create a for each Loop that Loops
861:19 - through the custom attributes that may
861:21 - have been declared against the relevant
861:23 - program element
861:25 - which in this case will either be a
861:27 - method or a class
861:28 - So within the loop let's reference the
861:30 - attribute type like this
861:33 - we can then apply an if statement to
861:35 - check if the current attribute is the
861:38 - information custom attribute okay so
861:40 - let's refactor our code here so that the
861:43 - target information attribute type
861:44 - constant can be accessed from both this
861:47 - method and the has information attribute
861:50 - method
862:06 - if the current attribute is the
862:09 - information custom attribute then let's
862:11 - access its description property
862:14 - we can do this using reflection like
862:16 - this
862:44 - so we are attempting to check if the
862:47 - property info object is not null but the
862:49 - compiler is complaining
862:51 - this is because the project is currently
862:53 - built on.net core version 3.1
862:57 - checking for nulls like this is only
863:00 - allowed in a later version of C sharp so
863:03 - I'm going to change the version
863:05 - of.net.net5 for this project
863:24 - great and you can see now that this line
863:27 - of code is Now supported
863:29 - I.E using the is not null line of code
863:33 - but I'm going to use the old way of
863:35 - checking for nulls anyway just in case
863:37 - the followers of this tutorial are using
863:40 - an older version of.net for their
863:43 - projects
864:04 - so we have now written the code to read
864:06 - the description property from objects
864:08 - derived from the relevant information
864:10 - custom attributes that have been
864:12 - declared against relevant class and
864:14 - Method program elements
864:17 - so let's write the code to appropriately
864:19 - output the program element descriptions
864:22 - declared through the use of our
864:24 - information attribute custom attribute
864:25 - to the console screen
864:28 - let's create a method named display
864:30 - element description for this purpose
864:34 - this method only needs one parameter
864:36 - which will be the text we wish to Output
864:38 - to the console screen
864:41 - let's write code to check if the
864:43 - argument passed to this method is not
864:45 - null if it is not null
864:47 - let's write its value to the console
864:49 - screen using a different background and
864:51 - foreground color to the default console
864:53 - screen colors so that the text stands
864:56 - out
864:57 - then let's use the console.resetc color
865:00 - method to reset the color back to the
865:02 - default console foreground and
865:04 - background colors
865:06 - let's go to the main method and use the
865:08 - display element description method to
865:10 - Output the relevant program element
865:12 - descriptions to the console screen
865:15 - so we can pass the result of the return
865:17 - information custom attribute description
865:19 - method into the display element
865:22 - description method on one line like this
865:26 - this code will display our custom
865:28 - descriptions of the program elements
865:31 - that the user wishes to test
865:40 - Let's test the code
865:46 - okay so we are getting a bug and this is
865:49 - because the load file method cannot find
865:51 - the target assembly
865:53 - the reason for this is because when we
865:56 - changed our version of.net for the test
865:59 - harness project a new directory for
866:01 - dotnet 5 was created this directory
866:04 - contains the assembly for the test
866:06 - harness project
866:08 - but it doesn't of course contain the
866:10 - target assembly
866:17 - so let's copy the most recently built
866:19 - utility functions assembly
866:27 - to the net 5.0 directory
866:38 - let's run the code again
866:43 - and you can see that our custom elements
866:46 - are displayed and we are able to test
866:48 - the functionality of methods and classes
866:50 - that reside within our Target assembly
866:55 - we have used the reflection technology
866:57 - to accomplish this
867:07 - you can also see that additional
867:09 - information about the relevant program
867:11 - elements is outputted to the console
867:13 - screen
867:14 - this was made possible through the use
867:16 - of our information attribute custom
867:18 - attribute excellent
867:21 - to finish off the application let's add
867:23 - code to enhance the user's experience
867:26 - as you may have noticed once the user
867:29 - has tested a method the application
867:31 - automatically ends we currently have no
867:33 - way of navigating back to the first
867:35 - screen where we are presented with a
867:37 - list of classes that we may wish to test
867:40 - we want the user to have the option of
867:42 - returning to the list of classes so that
867:45 - the user can carry on testing other
867:46 - classes and methods
867:49 - so we can do this by putting the
867:50 - relevant code within an infinite Loop
868:15 - once the user has tested a particular
868:18 - method the user can either press let's
868:20 - say the spacebar key to end the
868:22 - application or any other key to return
868:25 - to the screen that contains a list of
868:27 - classes
868:57 - Let's test the code
869:39 - foreign
870:02 - excellent
870:12 - so the last thing I'd like to bring to
870:14 - your attention is the technology
870:16 - encapsulated in the
870:18 - system.reflection.emit namespace using
870:21 - this technology a developer is able to
870:22 - generate code dynamically
870:24 - so the developer is able to generate
870:27 - Dynamic methods or even Dynamic
870:29 - assemblies on the Fly the user could for
870:32 - example generate Intermediate Language
870:34 - code on the Fly based on user input
870:37 - so because of functionality like this
870:39 - you can see how incredibly powerful the
870:42 - c-sharp language is I recommend
870:44 - navigating to this location to read more
870:46 - about this powerful aspect of reflection
870:50 - I hope you've enjoyed this tutorial on
870:52 - c-sharp reflection we have now come to
870:54 - the end of this Advanced c-sharp course
870:57 - if you've got this far congratulations
871:00 - this channel now provides two complete
871:02 - in-depth courses on features of the
871:05 - c-sharp language a beginner's course and
871:07 - an advanced course the next series of
871:10 - videos will focus on the asp.net MVC
871:13 - framework
871:15 - where we'll build an application in
871:17 - c-sharp using the asp.net MVC framework
871:20 - on.net 5. during this time I will also
871:24 - produce other videos relating to c-sharp
871:26 - and other Technologies
871:28 - so let's end this video by summarizing
871:30 - what we have learned about c-sharp
871:32 - reflection
871:33 - reflection provides objects of type type
871:36 - that describe assemblies modules and
871:39 - types
871:41 - you can use reflection to dynamically
871:43 - create an instance of a type bind the
871:46 - type to an existing object or get the
871:49 - type from an existing object and invoke
871:51 - its methods or access its fields and
871:54 - properties
871:55 - if you are using attributes in your code
871:57 - reflection enables you to access them
872:01 - we demonstrated using reflection to
872:03 - create an application that can serve as
872:05 - a test harness
872:07 - the test harness allows the user to add
872:09 - a target's assembly to the same
872:11 - directory where the test harness
872:13 - application resides and choose a class
872:16 - that the user wishes to test from a list
872:18 - of classes that belongs to a specific
872:20 - namespace that resides within the target
872:23 - assembly
872:24 - when the user selects a specific class
872:27 - from the class list that class is
872:30 - instantiated into an object through the
872:32 - use of late binding
872:34 - this is how the test harness is able to
872:36 - test the functionality within a Target
872:38 - assembly without referencing the target
872:41 - assembly at compile time
872:44 - in the test harness application
872:46 - reflection is employed to instantiate
872:49 - the relevant class into an object
872:51 - when an assembly is referenced by a
872:54 - project at compile time this is known as
872:57 - early binding with early binding the
872:59 - compiler has relevant information about
873:02 - the types within the target assembly at
873:05 - compile time
873:06 - late binding is used when the compiler
873:08 - does not have compile time knowledge of
873:11 - the target assembly
873:13 - so a technology like reflection is used
873:15 - to access the relevant information about
873:17 - the assembly which allows for late
873:19 - binding to occur at runtime
873:23 - it was noted that late binding has the
873:25 - disadvantage of being prone to runtime
873:27 - errors
873:28 - when early binding is employed a
873:30 - specific type can be instantiated into
873:33 - an object using the new operator and we
873:36 - have the advantage of compile time type
873:39 - safety
873:40 - we do not have the advantage of compile
873:42 - time type safety when late binding is
873:45 - employed in code and the
873:47 - activator.create instance method is used
873:49 - to instantiate an object from a type
873:53 - lastly we briefly discussed the
873:55 - technology encapsulated within the
873:58 - system.reflection dot emit namespace
874:01 - functionality for generating
874:02 - Intermediate Language code or IL code
874:05 - dynamically resides within the
874:08 - system.reflection.emit namespace
874:11 - a developer can use the functionality
874:13 - within the
874:14 - system.reflection.emit namespace to
874:16 - create code for dynamically generating
874:18 - methods and even assemblies at runtime
874:25 - for Content like this and much more
874:27 - please consider subscribing and please
874:30 - ring the bell so that you'll be notified
874:31 - of future content if you like this video
874:34 - please give it a thumbs up it will be
874:36 - greatly appreciated please feel free to
874:39 - share this video with anyone you feel
874:40 - May benefit from its content
874:43 - I really enjoy reading your comments so
874:45 - please feel free to engage with me in
874:47 - the comments section
874:49 - the code created in this tutorial can be
874:51 - downloaded from GitHub a link to the
874:53 - relevant GitHub repository has been
874:55 - included Below in the description thank
874:58 - you and take care
875:03 - let's go back in time to the end of
875:05 - February 2002 with the first release of
875:07 - the.net framework this is when c-sharp
875:10 - was first released it is a new fully
875:12 - object oriented general purpose
875:14 - programming language
875:15 - Visual Basic through its donut Evolution
875:17 - has been upgraded from a largely
875:19 - event-based language tightly coupled
875:21 - with the visual Basics 6 IDE to a new
875:23 - object-oriented version of itself called
875:25 - visualbasic.net a managed version of C
875:27 - plus could also run within the.net
875:29 - sphere new languages like F sharp which
875:32 - was first released in 2005 could also
875:34 - run within the.net environment these
875:37 - languages are all interoperable which
875:38 - essentially means for example a c-sharp
875:40 - application can consume a.net component
875:43 - written in Visual Basic or an
875:45 - application written in Visual Basic can
875:46 - consume a component written in C sharp
875:49 - what makes this possible is the common
875:51 - Intermediate Language or Cil all
875:54 - high-level.net programming languages
875:55 - like c-sharp Visual Basic C plus plus
875:58 - Etc
875:59 - are first compiled into the common
876:01 - Intermediate Language before further
876:03 - compilation into machine Language by the
876:05 - common language runtime
876:07 - all code that runs within the.net
876:09 - runtime is considered managed code
876:14 - the.net runtime also makes available a
876:16 - number of libraries that can be
876:18 - leveraged by our custom.net code
876:20 - this is essentially done through a
876:22 - library of files called the framework
876:24 - class libraries or the abbreviation of
876:26 - this fcl
876:27 - which provide generic functionality for
876:29 - our applications to consume the common
876:31 - language runtime or CLR can be described
876:34 - as the.net virtual machine and provides
876:36 - services like just-in-time compilation
876:38 - memory management security and exception
876:41 - handling it is important to note that
876:44 - the.net framework will only run on
876:46 - appropriate Windows operating systems
876:47 - and must be installed in its entirety on
876:50 - the target computer there have been many
876:52 - versions of the.net framework released
876:54 - since its Inception and they are able to
876:55 - run side by side on the same computer
876:58 - the latest version of the.net framework
877:00 - at the time of writing this tutorial
877:01 - is.net framework version 4.7 let's go
877:05 - back in time again to June 2016 when the
877:08 - first stable version of the.net core
877:10 - runtime was released
877:13 - it can be described as a cross-platform
877:15 - or agile modularized lightweight version
877:17 - of the.net framework it supports
877:19 - appropriate standards so that multiple
877:21 - languages can run and be managed within
877:23 - the.net runtime and also provides
877:25 - language interoperability
877:27 - core language compiles into the common
877:30 - Intermediate Language or Cil
877:32 - net core provides some of the standard
877:35 - framework class libraries which can be
877:37 - called The Core FX and can be described
877:39 - as a partial Fork of the framework class
877:41 - libraries
877:42 - dotnet calls virtual machine can be
877:44 - referred to as core CLR or core common
877:46 - language runtime and it provides
877:49 - services like improve just-in-time
877:51 - compilation memory management security
877:53 - and exception handling
877:57 - unlike the.net framework.net core can
877:59 - run on Mac OS Linux as well as Windows
878:03 - dotnet core also provides a modular
878:05 - framework so that only the modules that
878:07 - your application uses are shipped with
878:09 - your application an important difference
878:11 - between.net core and the.net framework
878:13 - is that you no longer need the
878:15 - entire.net framework installed on the
878:17 - target computer but only those
878:19 - components of the.net runtime that your
878:21 - application needs
878:23 - this is why.net core is often referred
878:25 - to as a more agile version of the.net
878:27 - framework.net core is open source
878:29 - software which makes things like the bug
878:31 - fix release process more efficient
878:33 - it is optimized for the cloud
878:42 - it is designed for high performance
878:44 - provides a great base for microservice
878:47 - architecture
878:48 - [Music]
878:52 - it is designed to be highly scalable
878:57 - dot net core is definitely a significant
879:00 - evolution of the.net runtime but it must
879:02 - be noted that it does not replace
879:04 - the.net framework please see in the
879:06 - description below a URL for a Microsoft
879:08 - docs webpage containing recommendations
879:10 - for when to use the.net framework and
879:12 - when to use.net core as the.net runtime
879:14 - for your server applications net 6
879:16 - completes the unification of the
879:18 - platform and adds new capabilities for
879:21 - building web native and hybrid apps for
879:23 - Linux Windows Mac IOS and Android with a
879:27 - single code base this video is an
879:30 - overview of what to expect with the
879:32 - release of net 6 which is due to be
879:34 - released on the 9th of November of this
879:36 - year 2021
879:39 - for Content like this and much more
879:40 - please consider subscribing and please
879:42 - ring the bell so that you'll be notified
879:44 - of future content please feel free to
879:46 - share this video with anyone you feel
879:48 - May gain value from its content
879:51 - before I give a brief summary of what
879:53 - new features and improvements to expect
879:55 - with the release of.net 6. I'd like to
879:58 - present you with a brief summary of my
880:00 - personal experiences as a developer with
880:03 - the technological innovations that have
880:05 - been made over the years
880:07 - I remember working as a young developer
880:09 - in the late 90s on Enterprise web
880:11 - applications
880:12 - when I look back I'm proud of what we
880:14 - were able to achieve using what is now
880:16 - known as classic ASP or classic active
880:19 - server Pages classic ASP was introduced
880:22 - as Microsoft's first server-side
880:24 - scripting technology for creating web
880:27 - applications
880:28 - the ASP files were coded in vbscript
880:31 - I remember we wrote our business logic
880:33 - in Visual Basic and compiled our code
880:36 - into com components
880:38 - we then installed our com components in
880:40 - an environment known as MTS Microsoft
880:43 - transaction server
880:45 - the Microsoft component object model com
880:48 - and Microsoft transaction server MTS
880:51 - later evolved into com Plus
880:53 - using active server Pages our code was
880:56 - written in vbscript
880:57 - and we would call our com components
881:00 - from our active server pages
881:02 - com plus handles many of the resource
881:04 - management tasks that previously needed
881:07 - to be programmed by the developer such
881:09 - as thread allocation and security
881:12 - active server Pages allowed a developer
881:15 - to implement codelogic using vbscript
881:17 - and output HTML client-side JavaScript
881:21 - and CSS code to the client's browser
881:24 - so back then we typically created our
881:27 - applications using a three-tier
881:28 - architecture classic ASP contained code
881:32 - and logic to Output HTML code JavaScript
881:34 - and CSS to the client's browser com
881:37 - components that contained business rules
881:39 - ran and MTS later known as complex SQL
881:42 - server was used for our backend storage
881:44 - facility
881:52 - [Music]
881:57 - in the early 2000s I moved to London my
882:00 - move to London coincided with the first
882:02 - release of c-sharp and net
882:05 - net was a gigantic step forward for
882:07 - Microsoft Technologies
882:14 - Visual Basic 6 was the last version of
882:16 - Visual Basic before the dramatic change
882:18 - that was to follow in the form
882:21 - of.net.net was a complete rethink Visual
882:24 - Basic was still offered as a language
882:26 - but instead of being limited to being a
882:28 - largely event-based language tightly
882:31 - coupled with the Visual Basic 6 IDE was
882:34 - now known as visualbasic.net and is a
882:37 - fully object-oriented programming
882:39 - language the first version of.net was
882:41 - named.net framework programs written
882:44 - in.net framework executed in a software
882:46 - environment in contrast to a hardware
882:49 - environment the software environment is
882:52 - named The Common Language runtime CLR
882:55 - a number of class libraries called the
882:58 - framework class libraries are built
883:00 - into.net framework and are available to
883:02 - be consumed by.net applications
883:06 - developers can produce their software by
883:08 - combining their source code with.net
883:11 - framework class libraries so.net
883:13 - framework provides a library of classes
883:15 - that can be leveraged from our
883:17 - applications
883:23 - net applications run in an environment
883:26 - known as the common language runtime or
883:28 - CLR which can be described as the.net
883:32 - virtual machine and provides services
883:34 - like just-in-time compilation memory
883:36 - management security and exception
883:39 - handling
883:40 - so.net framework provided developers
883:42 - with a sophisticated environment that
883:45 - would revolutionize the developers
883:46 - experience in the early 2000s I was now
883:49 - working on web applications using a.net
883:52 - version of active server Pages known as
883:54 - asp.net
883:56 - and I was able to write my code using a
883:59 - new fully object-oriented programming
884:01 - language known as C sharp
884:04 - so in the early 2000s the introduction
884:06 - of.net was a massive leap forward.net
884:09 - framework was interoperable meaning you
884:11 - could write code in any language that
884:13 - supported the common type system so we
884:15 - could write our applications using for
884:17 - example c-sharp visual Basics C plus
884:20 - Etc
884:21 - this was great but NET Framework could
884:23 - only run on Windows platforms and
884:25 - required a monolithic installation
884:28 - NET Framework does not run on Linux or
884:31 - Mac OS
884:32 - mono was released on June the 30th 2004.
884:37 - mono is a free open source
884:39 - implementation of microsoft's.net
884:41 - framework based on the ecma standards
884:44 - for c-sharp and the common language
884:45 - runtime mono was a version of.net that
884:49 - could run on multiple platforms mono can
884:51 - run on Windows Mac OS and Linux
884:54 - on June the 27 2016 the first version
884:58 - of.net core was released
885:01 - .net core is the.net successor to.net
885:04 - framework
885:06 - .net core is primarily developed by
885:08 - Microsoft employees
885:10 - by way of the.net foundation
885:12 - and released under the MIT license
885:16 - .net core supports the use of nuget
885:18 - packages.net core can be described as a
885:21 - lightweight modular cross-platform and
885:23 - more agile version of.net framework
885:26 - to prevent future fragmentation of.net
885:29 - implementations.net standard was
885:31 - introduced
885:32 - the motivation behind.net standard was
885:34 - to establish greater uniformity in
885:37 - the.net ecosystem
885:39 - net standard is a formal specification
885:41 - of net apis that are available on
885:44 - multiple.net implementations
885:46 - the specification is maintained by.net
885:49 - implementers specifically Microsoft
885:51 - includes.net framework.net core and mono
885:54 - and
885:55 - unity.net 5 was a significant release
885:58 - of.net and was released on the 10th of
886:00 - November 2020.
886:02 - Net 5 is the first release of a version
886:05 - of.net that attempts to unify all
886:08 - features of all versionsoft.net under
886:10 - one implementation of.net
886:12 - the idea behind this vision of.net is to
886:15 - have one.net moving forward
886:18 - that can Target Windows Linux Mac OS iOS
886:20 - Android TV OS watch OS and webassembly
886:24 - and more
886:25 - dotnet 5 is the future of.net core and
886:28 - is almost a complete reimagine of the
886:30 - old.net framework in fact Net 5 is the
886:34 - first major update since the 2016
886:37 - release of.net core
886:39 - dotnet 5 was a direct Evolution from.net
886:42 - core 3.1
886:45 - and the reason why it was called.net5
886:47 - and not.net4 is because the last release
886:50 - of.net framework was version 4.8 which
886:53 - was released on July the 25th 2019.
886:57 - both.net core and framework were
887:00 - maintained in parallel allowing you to
887:02 - choose between one or the other you
887:04 - could leverage.net standard to make
887:06 - shared libraries between the two the
887:08 - release of.net 5 meant that.net
887:11 - framework will be deprecated this means
887:14 - you can only use.net framework as long
887:17 - as your operating systems for example
887:19 - Windows Server 2019 will support it
887:23 - so.net 5 was the first step forward to
887:26 - unified.net
887:28 - and finally we get to the release of.net
887:30 - 6. the main significant aspect of net 6
887:33 - is the fact that it delivers the final
887:36 - parts of the.net unification plan that
887:38 - started with dotnet 5. here is a brief
887:42 - overview of the new features and
887:44 - improvements that we can expect with the
887:46 - release of.net 6.
887:49 - C sharp version 10.
887:51 - the significance of version 10 of
887:53 - c-sharp and future versions of c-sharp
887:56 - that are to be released in line with
887:58 - each new version of.net is that the
888:00 - developer can write less code with the
888:03 - evolution of c-sharp there's a strong
888:05 - focus on simplification much of the
888:08 - boilerplate code that needed to be
888:10 - written when using previous versions of
888:11 - c-sharp do not need to be written when
888:14 - using c-sharp version 10 so this
888:16 - improves the clarity and simplification
888:18 - of a developer's code and potentially
888:21 - increases productivity allowing the
888:23 - developer to focus more on application
888:26 - business logic
888:28 - net multi-platform app UI for Native
888:31 - mobile and desktop apps
888:34 - dotnet multi-platform app UI or net Maui
888:37 - is an evolution of xamarin it allows the
888:40 - developer to create applications for
888:42 - multiple different types of platforms
888:44 - using a single code base you can write
888:47 - one project that can be compiled into an
888:49 - application that runs on Android devices
888:51 - iOS devices Windows desktops Windows
888:55 - devices as well as Mac OS
888:58 - so one code base written in for example
889:01 - C sharp that can leverage native
889:03 - capabilities on multiple heterogeneous
889:06 - devices
889:07 - Blazer desktop web apps with Native
889:10 - device capabilities
889:12 - so one advantage of this is that if
889:14 - you're a web developer and don't want to
889:16 - learn xaml to implement your front-end
889:18 - code as you would When developing an
889:21 - application using for example WPF uwp or
889:24 - xamarin forms
889:26 - you can use HTML5 CSS bootstrap and
889:29 - JavaScript I.E the web Technologies with
889:32 - which you are already familiar to create
889:34 - desktop applications through Blazer
889:37 - desktop web apps you will still be able
889:39 - to leverage native device functionality
889:41 - and not worry about learning new
889:43 - technologies to leverage these native
889:45 - functionalities
889:48 - minimal web apis for cloud native apps
889:51 - this is a great feature that allows a
889:53 - developer to be up and coding for
889:55 - example a simple macro service a lot
889:58 - quicker than if the developer were to
890:00 - code that microservice using a typical
890:03 - web API that implements the MVC
890:05 - architecture
890:06 - there is far less ceremony involved in
890:09 - getting started
890:11 - more device targets including Apple M1
890:15 - .net 6 will support single file
890:17 - deployments for windows with up to 50
890:19 - smaller file size dotnet 6 supports
890:23 - ahead of time compilation
890:25 - productivity enhancements like part
890:27 - reload
890:28 - if for example you've developed angular
890:30 - applications with node you may be
890:33 - familiar with the hot reload feature
890:34 - this feature is now coming to net
890:37 - developers this means improved
890:39 - productivity simply because there's less
890:41 - need to stop and start the running of
890:43 - our code during the development of our
890:46 - applications
890:47 - continued performance improvements in
890:49 - runtime and builds time
890:51 - EF core performance is now 70 better on
890:55 - the tech and power benchmark
890:57 - so that was a brief overview of what you
891:00 - can expect with the release of.net 6.
891:04 - hi and welcome I'm Gavin long in this
891:07 - video we are going to look at some of
891:08 - the great features and improvements that
891:10 - are due to be released with net 7. we'll
891:13 - cover these aspects thematically for
891:16 - more details of what to expect with the
891:17 - release of.net 7. I've included relevant
891:20 - links Below in the description of this
891:22 - video
891:23 - this video will give you a broad
891:25 - overview of some of the improvements and
891:28 - new features that stand out to me that
891:31 - will be included in the official release
891:32 - of Net 7 which is due to be released in
891:35 - November of this year 2022 since the
891:39 - release of.net 5 on November the 10th
891:42 - 2020 Microsoft committed to a new
891:45 - release of.net in November of each year
891:48 - moving forward
891:50 - so.net 6 was released on the 8th of
891:53 - November 2021 and in November of this
891:56 - year we are expecting the release of net
891:58 - 7.
891:59 - Net 5 was what's known as a current
892:02 - release and net 6 was what's known as a
892:06 - long-term support release LTS release
892:10 - note that there is no quality difference
892:12 - between long-term support releases LTS
892:15 - releases and current releases the only
892:18 - difference is the length of support LTS
892:21 - releases get free support and patches
892:24 - for three years current releases get
892:27 - free support and patches for 18 months
892:30 - at the time of creating this video the
892:33 - latest preview release of.net 7 is
892:35 - preview 6. I've included links Below in
892:38 - the description to blog posts that
892:40 - contain details of each of the preview
892:43 - releases of.net 7. the official release
892:45 - of.net 7 will be a current release which
892:48 - means it will be supported for 18 months
892:51 - the release of dotnet 8 due to be
892:53 - released in November 2023 will be a
892:57 - long-term support release which means it
892:59 - will be supported for three years
893:01 - preview releases are typically not
893:03 - supported but they are offered for
893:05 - public testing ahead of the final
893:08 - release a preview or release candidate
893:10 - release are supported through Microsoft
893:12 - developer support only if they're
893:15 - specifically designated go live
893:19 - a brief history of.net this channel has
893:22 - released several videos on the history
893:24 - of.net the first video I released on.net
893:28 - is a video on the difference between.net
893:30 - framework and net core I've since
893:32 - released a video on the.net 5 release
893:35 - and a video on the.net 6 release in each
893:39 - video I've provided foundational content
893:41 - on the evolution of.net please see a
893:44 - link to a playlist Below in the
893:45 - description to view the videos released
893:48 - by this channel on the progression
893:50 - of.net so in this video I'll give a
893:53 - brief overview of the history of.net
893:55 - before we look at the new features due
893:57 - to be released in.net 7 and also the
894:00 - improvements and optimizations that are
894:02 - due to be released in.net 7.
894:05 - NET Framework was released February the
894:08 - 13th 2002 at the time it was a
894:12 - revolutionary release for Microsoft as
894:15 - it fundamentally changed the environment
894:17 - in which Microsoft applications run
894:20 - dot net applications run on what can be
894:23 - described as a virtual machine similar
894:25 - to how Java applications run on the jvm
894:28 - Java virtual machine the virtual machine
894:31 - provided in the.net framework is known
894:33 - as the CLR common language
894:36 - runtime.net framework however can only
894:39 - run on Windows platforms and requires an
894:42 - installation of all the Base Class
894:44 - libraries shipped with the.net
894:47 - framework.net core was released on the
894:49 - 27th of June 2016. it is a free open
894:53 - source managed computer software
894:54 - framework that is cross-platform it can
894:57 - run on Windows Linux and Mac OS
895:00 - operating systems only the Base Class
895:03 - libraries that are needed by an
895:05 - application need to be shipped with that
895:07 - application so it is a more agile
895:10 - version of.net when compared to the.net
895:12 - framework
895:14 - so.net framework and net core is being
895:17 - supported concurrently this resulted in
895:20 - the fragmentation of.net to alleviate
895:23 - this fragmentation the.net standard was
895:26 - introduced the first steps to
895:29 - properlyunify.net under one umbrella as
895:32 - it were came with the release of.net 5
895:35 - on November the 10th 2020 the release
895:38 - of.net 6 came approximately one year
895:41 - later on the 8th of November 2021 which
895:45 - shipped with many great enhancements but
895:47 - most
895:48 - significantly.net 6 further cemented the
895:51 - unification of.net
895:54 - so.net 6 is Unified free open source
895:57 - software that is cross-platform and
895:59 - agile
896:00 - it is an extremely versatile framework
896:03 - in terms of the types of applications
896:05 - that can run on.net and the performance
896:07 - of.net has been optimized for the cloud
896:10 - it is also versatile in terms of the
896:13 - number of platforms on which it can run
896:15 - dotnet 6 is supported on multiple
896:17 - operating systems Windows Linux Mac OS
896:20 - Android iOS tvos including Mac OS
896:24 - silicon and windows arm 64.
896:28 - so what is coming
896:31 - with.net7.net Maui there is significant
896:33 - investment in.net Maui for net 7.net
896:37 - multi-platform app ui.net Maui is a
896:41 - cross-platform framework for creating
896:42 - native mobile and desktop apps with
896:46 - c-sharp and xaml using.net Maui you can
896:49 - develop apps that can run on Android iOS
896:52 - Mac OS and windows from a single shared
896:56 - codebase.net Maui is open source and is
896:59 - the evolution of xamarin forms
897:02 - with the release of.net 7 you can expect
897:05 - performance improvements and better
897:07 - tooling in.net Maui
897:10 - Cloud native and containers
897:14 - Cloud native Computing is an approach in
897:16 - software development
897:18 - that utilizes cloud computing to build
897:21 - and run scalable applications in modern
897:24 - dynamic environments such as public
897:26 - private and hybrid clouds
897:29 - so common Technologies used in building
897:31 - Cloud native applications are for
897:33 - example Docker containers a set of
897:35 - platform as a service products that use
897:38 - OS level virtualization to deliver
897:40 - software in packages called containers
897:43 - kubernetes
897:45 - an open source container orchestration
897:47 - system for automating software
897:49 - development scaling and management and
897:53 - micro Services a collection of loosely
897:55 - coupled services that run inside Docker
897:58 - containers
897:59 - there'll be a broad set of investments
898:02 - in Cloud native and containers in.net 7.
898:05 - in terms of for example simplifying
898:07 - authentication Improvement of
898:10 - performance in terms of startup
898:12 - performance and runtime performance and
898:15 - better integration with containers
898:18 - there's also investment in better
898:20 - alignment with the Orleans technology
898:23 - Orleans is a cross-platform framework
898:25 - for building robust scalable distributed
898:28 - applications Orleans scales with a
898:31 - single on-premises server to globally
898:34 - distributed highly available
898:35 - applications in the cloud
898:38 - audience uses the virtual actor model
898:40 - where grains serve as the fundamental
898:43 - building blocks of Orleans applications
898:45 - grains are entities comprising
898:47 - user-defined identity behavior and state
898:51 - so with Net 7 there will be investment
898:54 - in better alignment of all yields
898:56 - with.net modernizing existing.net
899:00 - applications
899:01 - with.net 7 there is investment to make
899:04 - it easier to upgrade older.net
899:07 - applications to modern.net applications
899:09 - for example You may wish to upgrade an
899:12 - old asp.net MVC application to an
899:15 - asp.net core MVC application for Net 7
899:18 - Microsoft is making investments into its
899:22 - Upgrade Assistant to make these types of
899:24 - upgrades easier the Upgrade Assistant
899:26 - can for example change code written for
899:29 - older.net environments to be appropriate
899:31 - for modern.net environments it will also
899:35 - be made easier to upgrade applications
899:37 - in sections rather than upgrading the
899:40 - entire application at once
899:42 - they are framework Investments for
899:44 - application modernization and net 7.
899:47 - abstractions will be provided that for
899:50 - example allow the sharing of parts of
899:52 - the asp.net side of the application with
899:55 - parts of the asp.net core side of the
899:58 - application so the upgrade can be done
900:01 - in an incremental fashion rather than
900:03 - all at once which may not be a practical
900:06 - solution
900:07 - dotnet 6 contained many performance
900:09 - improvements Investments are being made
900:12 - in Net 7 to make.net even faster and
900:15 - more efficient
900:17 - asp.net core
900:19 - HTTP 3 will become part of the.net
900:23 - framework in.net 7. HTTP 3 is a new
900:27 - standard in development that will affect
900:29 - how web browsers and servers communicate
900:32 - unlike previous versions which relied on
900:35 - the well-established TCP HTTP 3 uses
900:39 - q-u-i-c a multiplexed transport protocol
900:42 - built on UDP
900:45 - HTTP 3 includes significant upgrades for
900:48 - user experience including performance
900:51 - reliability and security minimal API
900:54 - minimal apis are architected to create
900:57 - HTTP apis with minimal dependencies they
901:02 - are ideal for microservices and apps
901:05 - that want to include only the minimum
901:07 - files features and dependencies in
901:10 - asp.net core minimal apis provide
901:13 - developers with the advantage of less
901:15 - ceremony when setting up web API
901:18 - applications they are lightweight
901:21 - minimal apis hook into asp.net course
901:24 - hosting and routing capabilities and
901:26 - allow you to build fully functioning
901:28 - apis with just a few lines of code
901:31 - in.net 7 minimal API will be more
901:34 - consistent in terms of what can be
901:36 - achieved when compared to web apis that
901:39 - use the traditional MVC design pattern
901:42 - one new feature in.net7 is providing a
901:46 - way to group minimal apis together with
901:48 - a common root prefix so that they
901:51 - represent one part of the API space as
901:53 - it were a developer can take the apis
901:55 - and put them in different files so that
901:58 - it is more manageable from a project and
902:00 - code management perspective
902:03 - currently you can apply action filters
902:05 - to controllers in a web API component
902:08 - the ability to implement such code for
902:10 - cross-catching concerns will now be
902:12 - available for minimal apis the concept
902:15 - of endpoint filters will be available in
902:17 - Net 7 to apply the same cross-cutting
902:20 - functionality that for example action
902:23 - filters provide for controllers
902:26 - grpc
902:28 - grpc was created by Google to speed up
902:31 - data transmission between micro services
902:33 - and other systems that need to interact
902:36 - with each other
902:38 - with.net 7 there is investment in grpc
902:41 - Json transcoding the feature allows grpc
902:45 - services to be called like restful HTTP
902:49 - apis with Json requests and responses so
902:53 - for example this will make it easy for
902:55 - JavaScript code running within a browser
902:58 - to call a grpc service
903:01 - signal R signal R is a free and open
903:04 - source software library for Microsoft
903:07 - asp.net that allows server code to send
903:11 - asynchronous notifications to
903:13 - client-side web applications signalr was
903:16 - built for high performance and is one of
903:18 - the fastest real-time Frameworks around
903:21 - in.net 7 there will be support for
903:24 - strongly typed clients and returning
903:26 - results from client invocations a new
903:29 - client Source generator for Signal R
903:31 - will be included the signalr client
903:34 - Source generator generates strongly
903:36 - typed sending and receiving code based
903:39 - on interfaces that the developer can
903:41 - Define
903:43 - Net 7 will come with various
903:45 - improvements to the Razer compiler to
903:47 - improve performance resilience and to
903:49 - facilitate improved tooling
903:52 - Blazer
903:54 - broad improvements will be made to
903:56 - blazer for example mixed mode aot ahead
904:00 - of time compilation will allow for
904:03 - certain assemblies to be ahead of time
904:05 - compiled rather than the entire
904:07 - application needing to be ahead of time
904:10 - compiled when ahead of time compilation
904:12 - is implemented this makes the overall
904:15 - size of the application to be downloaded
904:17 - to the browser much larger so although
904:20 - runtime speeds are increased for the
904:23 - application the file size is much larger
904:26 - enabling mixed mode means that parts of
904:29 - the application can be optimized for
904:31 - Speed
904:32 - those parts of the application that
904:34 - require greater speed can be ahead of
904:36 - time compiled leaving the rest of the
904:38 - application to be interpreted so speed
904:41 - can be increased where it counts and a
904:43 - balance is maintained between less size
904:46 - of the application and the benefit of
904:48 - speed optimizations
904:50 - most browsers are now capable of
904:52 - facilitating multi-threading so.net 7
904:55 - will take advantage of this and will
904:57 - provide multi-threading to Blazer
904:59 - webassembly applications web crypto
905:02 - simply means that cryptographic
905:04 - functionality available in browsers can
905:06 - be leveraged from Blazer applications
905:09 - with the release of.net 7 there will be
905:12 - enhancements in hot reload support
905:15 - data binding improvements more flexible
905:18 - pre-rendering pre-rendering razor files
905:21 - into HTML allows passing of static files
905:24 - which for example makes SEO search
905:27 - engine optimization effective and Blazer
905:29 - applications more control over the life
905:32 - cycle of Blazer server circuits improved
905:35 - support for micro front ends micro front
905:39 - ends are a new pattern where web
905:42 - application uis front-ends are composed
905:45 - from semi-independent fragments that can
905:48 - be built by several teams using
905:50 - different Technologies support for
905:53 - custom elements is an exciting feature
905:56 - where you can shrink wrap as it were a
905:58 - Blazer component in a standard custom
906:00 - HTML element this means you could reuse
906:03 - the relevant custom element created in a
906:06 - Blazer application within for example an
906:09 - angular or a react application so that's
906:12 - a super exciting feature
906:17 - mvc.net will include improvements made
906:20 - to endpoint routing link generation and
906:23 - parameter binding
906:25 - Orleans
906:26 - the asp.net core and Orleans teams are
906:30 - investigating ways to further align and
906:33 - integrate The Orleans distributed
906:34 - programming model with asp.net core
906:37 - Alliance 4 will ship alongside.net and
906:41 - focuses on Simplicity maintainability
906:43 - and performance including human readable
906:46 - stream identities and a new optimized
906:49 - version tolerant serializer
906:54 - this video provides a brief overview of
906:56 - some of the features and improvements to
906:58 - expect with the next official release
907:00 - of.net
907:02 - which is due to be released in November
907:04 - of this year.net 7 will be a current
907:07 - release meaning it will be supported
907:09 - free of charge for 18 months and will
907:12 - contain many great new features many
907:14 - performance and optimization
907:16 - improvements
907:18 - with this new release of.net and the
907:20 - commitment to release a new version
907:22 - of.net every year moving forward makes
907:25 - it a great time to be a.net developer
907:28 - if you like this video please give it a
907:30 - thumbs up and please feel free to share
907:32 - this video with anyone you feel May
907:34 - benefit from its content for Content
907:36 - like this and much more please consider
907:38 - subscribing and please ring the bell so
907:41 - as to be notified when new content is
907:43 - released
907:45 - I really enjoy reading your comments so
907:47 - please feel free to leave a comment
907:48 - below in the description
907:50 - I hope you've enjoyed this video thank
907:53 - you and take care