00:00 - [Music]
00:08 - hello and welcome in this video we are
00:10 - going to talk about a sync await feature
00:12 - in javascript first of all we'll go
00:15 - through brief history of async
00:17 - programming in javascript we'll see how
00:19 - it evolved over time we'll quickly take
00:22 - a look at the callbacks promises
00:25 - generators and finally a sync away so
00:27 - let's get started okay so i already
00:29 - mentioned this but this is a history of
00:32 - async programming javascript so it all
00:34 - started back with callbacks in the past
00:37 - and then we were able to use promises
00:40 - which was a major like shift from
00:42 - callbacks and then we're also able to
00:45 - use generators now i didn't use
00:47 - generators much i pretty much like
00:49 - skipped over them so i went straight
00:51 - from promises to a sync weight but
00:53 - generators are in between those two
00:56 - stages and finally like right now in the
00:58 - present time we have access to this
01:01 - honestly like amazing feature that is
01:03 - called async wait so what i want to do
01:05 - next is i want to present to you a piece
01:07 - of code and then i want to show you the
01:09 - same piece of code in say callbacks
01:11 - promises and async in the way for the
01:14 - generators i honestly wouldn't want to
01:16 - show that because i personally don't
01:18 - have a lot of experience using
01:19 - generators so i don't want to show you
01:22 - something that maybe i badly written so
01:24 - i'm going to skip over the generators so
01:27 - um let me show you that and here it is
01:29 - so this is the callback exam now i
01:31 - really didn't want to create like the
01:33 - most complex callback example ever but
01:36 - trust me that like this isn't the worst
01:39 - that you can see
01:41 - it can get much much much more uglier
01:43 - than this is right now so what we have
01:45 - here is a function that is supposed to
01:48 - be and endpoint handler so for example
01:51 - let's say you you were building some
01:52 - sort of a website and this handle over
01:55 - here will receive requests from the
01:58 - client for example the browser sending
02:00 - requests to the server and this response
02:02 - object is what you can use to actually
02:05 - write back something to the client for
02:07 - example to the user browsing your
02:09 - website so now what we have in this
02:11 - example is
02:12 - we are talking with a database and let's
02:15 - say we have a table or say a collection
02:17 - of users and we want to find a
02:19 - particular user that will be sent to us
02:23 - via this request so we want to call this
02:25 - function user.find by id and simply pass
02:29 - this requested user id property but now
02:31 - this function is async 1. we don't know
02:34 - how many milliseconds it is going to
02:37 - actually run for so we need to do this
02:40 - in async manner because otherwise we're
02:42 - going to block the code and given that
02:45 - javascript is single threaded language
02:48 - that wouldn't really work so now we we
02:51 - call this function and what we do then
02:53 - is we actually pass it as a second
02:56 - argument a totally different function
02:58 - that will get called
03:00 - once this
03:01 - operation finishes so we say here like
03:05 - okay you go on database and try to find
03:08 - me this particular user and when you do
03:11 - that then and only then you call this
03:14 - function that we passed over here and
03:16 - pretty much like everything starting at
03:18 - this line over here and ending over here
03:22 - is the function that we passed to that
03:25 - function over there now what this allows
03:27 - us to do is say after this
03:30 - same the next line over here we can
03:32 - maybe do something like console.log and
03:35 - whatever we do inside that console.log
03:37 - once this entire code gets executed will
03:40 - be printed out before we see any of
03:43 - these because this isn't done
03:45 - instantaneously but anyway you can see
03:47 - how it looks like and when you pass a
03:49 - callback function so this function over
03:50 - here is called the callback function
03:52 - that's the reason why this pattern of
03:55 - programming is called callbacks after
03:57 - all and when you provide a callback
03:59 - function you should always provide error
04:02 - as a first argument so then we can
04:04 - easily check if there is an error by
04:06 - first doing that and only if there is no
04:10 - error then we can move on and do
04:12 - something else so in this example if
04:13 - there were any errors we would simply
04:15 - respond back to the client pretty much
04:18 - forwarding that error to the client now
04:21 - you see that we have this other
04:23 - argument called user and what's going to
04:26 - happen is this function over here user
04:28 - defined by id in case there are no
04:31 - errors and in case it is able to find
04:34 - that particular user it will send that
04:38 - user to this callback function and it
04:40 - will be stored in this variable called
04:42 - user so now we have access to this user
04:46 - in this callback function from here to
04:49 - here by referencing this user variable
04:53 - so now what we want to do is that user
04:55 - variable is going to have a property
04:57 - called tasks id and pretty much in the
04:59 - same manner let's say that we want to
05:01 - get access to those tasks so we again
05:04 - like query the database for those tasks
05:07 - given by that id so we do pretty much
05:09 - the same thing and then again we supply
05:12 - the callback function again with uh
05:14 - error as a first argument and now tasks
05:17 - as a second argument and then we again
05:19 - simply check and if there were any
05:21 - errors we simply want to respond back to
05:23 - the client with those errors
05:25 - and if that wasn't the case we want to
05:27 - do something with those tasks
05:29 - instead so what we'd want to do is for
05:32 - example like imagine that that tasks had
05:34 - a property called completed that is a
05:37 - boolean type and we simply want to
05:40 - change that to b to true so now once we
05:44 - so now once we actually modified
05:46 - that row or document
05:49 - in our database we don't want to save
05:51 - those tasks and saving the tasks is
05:55 - again async operation because it is not
05:58 - done instantaneously so we again need to
06:01 - provide a callback function to it and
06:03 - this time we don't want to see to
06:06 - receive any returned value from it
06:08 - instead we just want to make sure that
06:10 - that operation was successful so then we
06:13 - simply check whether the error was there
06:15 - and if so we again respond to the client
06:18 - with such error but otherwise we simply
06:20 - respond back to the clients with the
06:23 - message of tasks completed
06:25 - okay so hopefully like this will make
06:26 - sense and you're able to understand like
06:29 - the flow and you're also able to
06:32 - understand like why is there a need for
06:34 - these callback functions and now let's
06:37 - take a look how all of these like the
06:40 - the exact same code is handled when it
06:42 - comes to the promises and this is a
06:44 - promises example and one thing you can
06:47 - spot straight away is like how how much
06:50 - clearer and cleaner this code actually
06:53 - is
06:54 - so this time what we're doing is giving
06:56 - that user that find by id is again the
06:58 - same function and it is again async
07:01 - function we simply call it and we pass
07:05 - whatever argument we actually want
07:07 - but then instead of supplying a callback
07:10 - function to this line over here what we
07:13 - then do is we take on the dot then
07:16 - function and then there we actually
07:19 - supply you can think of it like callback
07:21 - function what will happen once this
07:25 - operation is completed so you can pretty
07:27 - much read it like this like user.find by
07:30 - id requested user id like
07:32 - started this process and then once it's
07:36 - actually completed
07:37 - only then do you do whatever the code is
07:41 - over here so when that's done
07:44 - we can then get a handle on that user
07:46 - subject and then we can do something now
07:49 - here we are going to start another async
07:51 - function called tasks.find by id
07:54 - so we pretty much just returned it
07:56 - and then what happens is we can just
07:59 - attach on like another then
08:02 - to this piece over here and then this
08:04 - part over here will only get executed
08:07 - once this
08:09 - async operation inside of here is
08:11 - actually completed and now in the same
08:13 - manner we can do these lines of codes
08:16 - over here and then task.save is yet
08:19 - another async operation so we want to
08:22 - return that as well and then we supply
08:25 - another function that should be executed
08:28 - once this is done and now we don't need
08:31 - any parameters here so we just respond
08:34 - back to the client saying tasks
08:36 - completed now you might be surprised how
08:38 - we didn't do any error handling so far
08:42 - so what's going on is using promises you
08:46 - can actually call dot catch at the end
08:49 - which will catch all the errors for you
08:52 - and then we simply want to respond back
08:54 - to the client with such errors if that
08:56 - was the case so as you can see it's much
08:58 - clearer because one uh error handling
09:01 - doesn't need to happen all the time we
09:04 - can just like have a
09:06 - specialized piece of code that is going
09:08 - to handle errors no matter where they
09:10 - actually happened
09:12 - and to um as you can see we don't have
09:15 - that nesting pattern that gets really
09:18 - hard to read that is called um callback
09:20 - hell and sometimes it is referred to
09:24 - like christmas tree shape because as you
09:26 - can see it goes kinda like this and then
09:28 - the opposite so it is definitely like a
09:31 - much neater way to write async code in
09:34 - javascript now let's take a look at the
09:37 - same example using the async weight and
09:40 - here it is as you can see it's much much
09:42 - much much more clearer than what we've
09:45 - been able to see previously it almost
09:47 - looks like a sync and blocking code but
09:51 - fortunately it isn't so what's going on
09:53 - here is whenever you want to write a
09:56 - async await function you need to write
09:58 - this keyword async before the function
10:01 - keywords and once you do that you
10:04 - actually have ability to use this await
10:07 - keyword inside of that function
10:09 - that is declared to be a async function
10:12 - async await is actually all promises
10:16 - under the hood so like if you really
10:18 - want to get a deep
10:22 - and detailed understanding of async
10:25 - await feature it's best if you learn
10:27 - promises first but i'll do my best to at
10:30 - least explain you what's going on over
10:32 - here so first thing you can notice is we
10:34 - have this try catch construct and that
10:37 - is how you're able to handle errors in
10:41 - async weights functions so this sketch
10:44 - piece over here is similar to the catch
10:46 - piece we have seen over at the promises
10:49 - example we do all of our error handling
10:52 - inside of here and inside of our try
10:56 - block over here what we do is next we
10:59 - call this user defined by id and again
11:02 - we pass the
11:03 - parameters that we wanted but now we
11:06 - actually uh write this await keyword in
11:09 - front of it which will actually tell
11:11 - this function that this operation over
11:14 - here is a sync operation and it's not
11:17 - going to happen instantaneously so this
11:20 - pretty much
11:21 - awaits this function to be resolved
11:25 - and then it stores the result of it in
11:28 - the variable that we assign on the left
11:31 - and now
11:32 - this next line
11:34 - tasks equals away task with find by id
11:37 - will only execute after the user
11:40 - equals of eight users defined by id gets
11:43 - resolved so you can almost like read it
11:46 - like a sync blocking code so next we
11:49 - wait for the tasks and then we supply
11:52 - this user the tasks id as an argument
11:55 - and then we get those tasks and then we
11:57 - can simply like task that completed
11:59 - equals true like modify the tasks and we
12:02 - can also save the tasks and you can see
12:04 - because all these three operations are
12:06 - async we need to put this await keyword
12:09 - in front and then we can simply respond
12:11 - that send to the client back message
12:13 - saying task completed now if error
12:16 - happened
12:17 - during any of those three operations the
12:19 - execution flow will jump straight to
12:21 - this sketch block over here and it will
12:24 - respond back to the client with such
12:26 - error so i hope that now you can
12:29 - appreciate the
12:31 - abilities that asynchroid feature
12:33 - actually gives us
12:35 - as we do our
12:37 - daily javascript async programming so
12:40 - what i want to do next is i don't want
12:42 - to stop here but instead i want to go
12:45 - with you through a bunch of async await
12:47 - examples in which i could show you the
12:50 - sequential flow the parallel flow i also
12:53 - want to show you like all the loops and
12:56 - iterations that you can do with async
12:58 - awaits i'm going to show you some common
13:01 - gotchas that
13:02 - you might be
13:04 - unaware of at this moment and all in all
13:07 - i just want to like go through a bunch
13:10 - of examples
13:11 - so that you feel confident in your
13:13 - ability to start using this async await
13:16 - feature today okay so now let's do like
13:19 - a bunch of examples so that you can see
13:22 - all the ins and outs of using async
13:25 - weight in your code so what i've done is
13:28 - i've made like three different folders
13:30 - over here first we have a sequential
13:33 - then we have parallel and then we have
13:35 - loops so those are three topics that we
13:38 - want to go through and in each of these
13:41 - these topics
13:42 - we have like for the sequential we have
13:44 - like a naive approach then i'm going to
13:47 - demonstrate like an issue that happens
13:49 - with it and then i'll also propose a
13:52 - solution and that's the same with the
13:54 - parallel
13:56 - and then for the loops i'm just going to
13:58 - like go over like the different types of
14:01 - iterations that you can go with using a
14:03 - sync away and explain like what you can
14:06 - do and what you can't do so let's get
14:08 - started with the sequential project
14:11 - example and let's go in this naive
14:13 - approach so we have two files that we
14:16 - care about we have a main.js and we have
14:18 - a processes.js so if you open main.js
14:22 - file you see that we simply get a handle
14:25 - on those two processes
14:27 - that we actually have inside of that
14:29 - process file and the whole idea about
14:33 - this small project is that we have two
14:35 - processes that are async and that we
14:38 - want to run them sequentially so now
14:40 - like in that example that i've shown you
14:42 - in the slides we have this function main
14:46 - that gets called over here and then we
14:49 - attach this async keyword in front of
14:51 - this function keyword and then we do all
14:54 - sort of things inside of here so what we
14:56 - do is we await for those two processes
15:01 - and then what we want to do is we want
15:03 - to store their values in these two
15:06 - variables over here and then simply when
15:09 - all of this is done
15:10 - we want to use the console.log to
15:13 - actually print out to the terminal the
15:15 - value states we got from those two
15:18 - processes
15:19 - and then these consulate logins simply
15:21 - for like formatting purposes
15:24 - and we also call this console.time and
15:27 - console.time end functions which will
15:29 - tell us how long the
15:32 - the function has been running for in
15:34 - milliseconds and if there are any errors
15:36 - we simply constantly error them again to
15:39 - our terminal over here so now let's take
15:42 - a look in this process.js file and see
15:44 - what's in there so over here we just
15:47 - export uh two functions that are also
15:50 - async ones and in them we simply like
15:54 - output that process
15:56 - has started
15:57 - we again use time and time end to show
16:01 - to the terminal how long this particular
16:03 - function has been running for and
16:05 - likewise for this second one and then we
16:08 - we kind of fake this operation by simply
16:12 - waiting
16:13 - 5 000 milliseconds and for this weight
16:17 - function i'm actually using um set
16:20 - timeout but because settimeout is
16:23 - expecting a callback we're actually
16:25 - using this promisify function from the
16:28 - util package in node.js which will
16:31 - actually turn the set timeout into a
16:33 - promise based function that we can use
16:36 - inside of our async code so remember
16:39 - like the async is pretty much like
16:41 - promises with uh a different interface
16:44 - that we can interact with so we we can't
16:47 - really use callback functions inside of
16:51 - our async function
16:53 - all of that needs to be promises that's
16:55 - the reason behind this and i didn't tell
16:58 - this before but i'm using node for this
17:00 - because it's much easier for me to using
17:03 - all sort of
17:05 - things like these that are already built
17:07 - in
17:07 - but you can of course
17:09 - learn a single weight and use it for
17:11 - like everything that you do inside of
17:13 - javascript be it backend be it front-end
17:16 - your choice so hopefully like this is
17:20 - this is making sense like this is really
17:23 - a
17:24 - simple fake made up example and when
17:28 - both those processes are finished we
17:30 - simply return some value for example
17:32 - process 0 1 is going to return this
17:35 - process 0 1 dash value string and
17:39 - process 0 2 is going to return this
17:41 - value instead so now let's actually run
17:43 - this and see what's happening
17:46 - so i'm going to use my terminal let me
17:48 - just bring it up a bit and then i'm
17:50 - going to navigate to that directory and
17:53 - that subdirectory and then i'm going to
17:56 - execute node and then main.js as entry
17:59 - point
18:01 - so as you can see process01 started and
18:03 - it is taking some time
18:05 - and then it says process zero one ended
18:07 - and it took
18:09 - roughly five thousand milliseconds then
18:12 - the process zero two started and then
18:14 - the process zero two ended and that one
18:17 - took three thousand milliseconds and
18:19 - then we seeded processor one returned
18:22 - back to us this value and likewise for
18:25 - the second process and then we can see
18:27 - that the total running time for this
18:29 - entire example is eight thousand and so
18:33 - milliseconds
18:34 - and that makes sense because when you
18:37 - take a look here this one takes five
18:39 - thousand milliseconds roughly and these
18:41 - three thousand so that totally adds up
18:44 - so that's all good and as you can see uh
18:47 - it seems like it's working but you might
18:50 - have noticed that i didn't use try catch
18:53 - blocks inside of these two functions
18:56 - and that is kinda okay because if this
19:00 - or this function returns an error it
19:03 - will simply bubble up to this main
19:06 - function and then we are able to catch
19:08 - it inside of here
19:10 - so that's that's good but we'll see like
19:13 - what bad can happen in doing so in our
19:16 - next example and now i'll navigate to
19:18 - our second example and show you the
19:20 - changes so if i open this file
19:24 - main.js over here and i close the other
19:26 - one so i don't get confused we have the
19:28 - same code in our main.js file over here
19:31 - and our process.js file is also the same
19:35 - but we did add this draw new error line
19:38 - in this process 01 function so this is
19:41 - the process zero one is going to
19:43 - actually throw an error once runs and
19:46 - we'll see how it
19:48 - how it affects everything over here so
19:51 - let me quickly navigate to that
19:53 - directory
19:57 - and let's see what happens when i run it
20:00 - so i'm going to type node main.js
20:03 - and as you can see um process
20:05 - zero one started and then we get this
20:09 - error over here that process zero one
20:11 - failed so what happened is this code
20:14 - started going sequentially it came to
20:17 - this point over here um then the process
20:20 - zero one through an error and then the
20:23 - execution flow jumped straight from this
20:25 - line
20:26 - to the catch block over here and that's
20:29 - the reason why nothing of this executed
20:32 - afterwards
20:33 - so if you have multiple processes that
20:36 - you want to await sequentially these
20:38 - wouldn't really work because as soon as
20:41 - one process
20:42 - were to return an error the rest of them
20:44 - wouldn't get executed now sometimes this
20:47 - is really good because maybe if this
20:49 - process failed
20:50 - you just want to like exit everything
20:53 - and then you can use this approach but
20:55 - if you really don't care if this
20:58 - process year one throws an error or not
21:00 - and you simply want to get like as much
21:03 - value as you can from the other
21:05 - processes
21:06 - then this
21:07 - wouldn't work for you so now let's take
21:09 - a look at one approach that you can use
21:11 - to avoid having this sort of issue so
21:14 - i'm going to close both of these files
21:16 - and then i'll open this 03 solution
21:19 - directory and here we have the exact
21:23 - same main.js file but this time the
21:26 - process.js file is different
21:29 - we again throw new error inside of the
21:32 - process zero one and we again don't draw
21:35 - any errors in the process zero two
21:36 - function but
21:38 - we did add this try catch block into
21:41 - both of them
21:43 - and what's going to happen is as soon as
21:46 - this process 01 throws an error it is
21:49 - not going to actually bubble up to this
21:51 - part over here but instead it will
21:54 - actually jump to this line in the same
21:56 - function and simply do this
21:59 - and we'll see how this would totally
22:02 - like save our lives if we want to get
22:05 - this value no matter what happens with
22:07 - the first process
22:09 - so now let me actually start this
22:11 - example i'm going to go back again and
22:14 - go back into
22:16 - this new example and then i'll execute
22:18 - node main
22:19 - and as you can see process 1 started and
22:21 - process 1 failed but we're still doing
22:24 - something after that
22:26 - then we are starting the process zero
22:28 - two and then the process zero two
22:30 - actually successfully ended after three
22:32 - thousand milliseconds and then we see
22:35 - that we have undefined value from the
22:37 - process zero one since that is the
22:40 - process failed
22:42 - but we do have a returned value from the
22:44 - process zero two because that one was
22:47 - successfully
22:48 - executed and we see that the total
22:51 - running time for this
22:53 - small example is 3 000 milliseconds
22:55 - because this first one failed and then
22:58 - we didn't need to wait
23:00 - those 5 000 milliseconds to pass by so
23:03 - with these three examples um you should
23:07 - feel more and more confident in writing
23:10 - async obviously the more you learn and
23:13 - the more you know about promises
23:15 - it is going to benefit you a lot so even
23:18 - if you're interested in seeing kuwait
23:20 - exclusively i would suggest that you
23:23 - like take some time and go over promises
23:26 - in your spare time
23:28 - but now let's take a look at what
23:29 - happens when we want to execute things
23:32 - using a sync weight in parallel this
23:34 - time clear this console i'll close this
23:36 - file and then i'll navigate to our
23:39 - second
23:40 - directory that is called parallel and
23:43 - again as i already told you we have
23:45 - three different
23:46 - subdirectories so let's open the first
23:49 - one this is called naive and let's take
23:52 - a look at it so this time um
23:55 - the idea is the same again we have two
23:57 - processes and we want to run them but
24:00 - this time we want to run them in
24:02 - parallel and not sequentially that is
24:05 - what this small comment says
24:07 - and how can we do that well first of all
24:10 - let me take a look at the process.js
24:12 - file just to show that it is the same as
24:15 - we had previously and it is also
24:18 - stripped of try catch blocks and we are
24:21 - drawing no errors this time
24:24 - so in this main.js file
24:26 - what we do first of all is we have this
24:30 - promise that all function okay so what
24:32 - this promise total function does is it
24:34 - returns a single promise to us that
24:38 - resolves when either all of the promises
24:41 - in its argument
24:43 - gets resolved or if there are no
24:45 - promises over here
24:46 - and this promise that all also rejects
24:50 - with the reason of the first promise
24:52 - that got rejected in its argument so all
24:56 - of that might be a bit confusing but the
24:58 - most important thing is that promise at
25:02 - all will call all of these for us and
25:05 - will return a single promise for us that
25:08 - will get
25:09 - say completed when all of these are
25:12 - completed and if any of these fails then
25:16 - the promise dot all will also fail on
25:20 - that return promise with the reason of
25:22 - that failure and what we can do here is
25:25 - that
25:26 - the all the returned values
25:28 - from this get stored into this
25:31 - data variable that is actually an array
25:34 - and then if we wanted to access the
25:37 - returned value from the process zero one
25:40 - since it is the first element in this
25:42 - array we can access that by using the
25:45 - notation of zero so we we're referencing
25:48 - the zeroth element of this array and
25:52 - likewise for the second process returned
25:54 - value it is second element in this array
25:58 - and because it all starts from zero that
26:00 - is the first element in that array and
26:03 - if we actually run this example
26:11 - and if i run it
26:13 - we'll see that both process this time
26:15 - started straight away the process zero
26:18 - two is actually the first one that ended
26:21 - with three thousand milliseconds then
26:23 - the process 0 1 ended with nearly 5 000
26:27 - milliseconds and we can see that we have
26:30 - access to both of those returned values
26:33 - and really importantly this time we see
26:36 - that the total running time of this
26:37 - example is 5000 milliseconds and it is
26:41 - not a thousand milliseconds like it was
26:43 - earlier because
26:46 - like we have those two operations
26:48 - and the operation zero one is the
26:51 - longest one so the running time is
26:54 - pretty much going to equal the longest
26:56 - operation that we are running because
26:58 - the other operations are going to be
27:01 - completed by that time
27:03 - so this is all great and it is working
27:06 - and now let's take a look at one
27:08 - potential issue that you might have with
27:10 - this approach okay so i'll close all of
27:13 - these
27:14 - and let's go into the second folder
27:19 - okay so the issue um okay so this is the
27:22 - same
27:24 - like it was before
27:25 - but if we come to these processes we see
27:28 - that it looks awfully similar to this
27:31 - example over here and in fact i tried to
27:34 - keep them in the same manner so the only
27:37 - change is this time we are drawing new
27:39 - error in the process zero one and let's
27:41 - see how that affects our promise.all um
27:45 - function now if you remember what it
27:47 - just said is that the promise at all
27:50 - returns a single promise and that single
27:52 - promise actually fails with the reason
27:55 - of the first promise that fails over
27:58 - here so let's see what happens i'm going
28:00 - to start this
28:04 - and there it is so we actually
28:07 - um let me bring this up
28:09 - so we started both of the processes
28:12 - and then the process zero one failed and
28:16 - then the process zero two ended but as
28:18 - you can see we don't this never got
28:21 - executed because it jumped straight to
28:24 - this block over here and the total time
28:27 - running we also didn't see that because
28:29 - again all of these was avoided because
28:32 - of that error so this is no good if you
28:36 - were interested in at least say this
28:38 - value over here no matter that the first
28:40 - one failed so um the solution is going
28:43 - to be
28:44 - pretty similar to what we did in the
28:47 - solution for our sequential problem that
28:49 - was of the same nature pretty much so
28:52 - let's quickly jump into it and see the
28:54 - difference
28:59 - okay so the main is the same and now
29:01 - let's jump into the process.js file and
29:04 - see what's changed and it is similar to
29:08 - what we've been able to see before so
29:10 - the only change is that we added the try
29:12 - catch blocks into both of these
29:14 - functions
29:15 - and again we're throwing new error
29:17 - inside of this processor one
29:19 - so let's see how that affects things so
29:23 - i'm going to navigate to
29:25 - that directory
29:26 - and then i'll type node main
29:29 - and as you can see so both of them um
29:32 - both of them start running
29:34 - but immediately the process zero one
29:37 - fails and then we get a notification
29:39 - that process zero two started but this
29:42 - could be slightly misleading because
29:44 - both of them got executed at the same
29:46 - time so let me make one small adjustment
29:48 - because now in the second look this
29:51 - could be a bit confusing let me just
29:52 - simply before we drew a new error let me
29:55 - actually just
29:56 - await
29:58 - um for let's say 100 milliseconds or so
30:01 - just want to show you that um but by
30:04 - reading this you might think that this
30:06 - this is executed sequentially because
30:08 - you see process one started process two
30:11 - process one failed and only then
30:13 - processor started but if i actually
30:15 - rerun this example now we see that both
30:18 - of the processes actually started
30:20 - then the process zero one failed
30:23 - and then the process zero two ended and
30:26 - now we have access to all of these over
30:29 - here because we
30:31 - handled the errors more carefully this
30:33 - time and we see that process zero one
30:35 - returned well we don't know it failed
30:38 - but we have access to this value that
30:40 - pros zero to zero to returned and it is
30:44 - correct one and the total running time
30:46 - is three thousand milliseconds because
30:49 - the first one failed and second one it
30:52 - was running for exactly that amount of
30:54 - time
30:55 - so now if you ever need to run some
30:58 - operations in parallel that are not
31:01 - depending one of another you can use the
31:04 - promise at all just be careful with the
31:07 - errors
31:08 - if any of such
31:10 - process can
31:11 - actually throw an error and most of the
31:13 - time they indeed can
31:15 - make sure that europe that you're
31:17 - handling those errors inside of them and
31:20 - don't simply rely on those errors
31:23 - bubbling up in your main because as you
31:25 - can see it will totally mess up the
31:28 - application flow
31:29 - so now we've seen sequential execution
31:32 - we've seen parallel execution now we're
31:35 - going to take a look at loops and
31:36 - iterations and see how can you do that
31:39 - using a sync weight so i'll quickly
31:42 - close everything and
31:45 - sorry
31:46 - i'll quickly close everything and then
31:48 - i'll open the loops directory and let's
31:52 - get started with a simple old good for
31:54 - loop
31:55 - so i'm going to open the main and this
31:57 - time the idea behind this example is
32:00 - different
32:01 - which should be cool because we got
32:04 - a bit too used to the old example that
32:07 - could be a bit boring by now so this
32:09 - time we have our secret
32:11 - algorithm that we made and we want to
32:14 - benchmark our algorithm and indeed make
32:18 - sure that it is running in the time that
32:20 - we think it is
32:22 - so what we want to do is we want to run
32:24 - it multiple times and figure out the
32:26 - average running time okay and here we
32:30 - have number of tests or number of runs
32:32 - that we want to
32:34 - to do and just thinking about that let
32:37 - me actually rename this number of runs
32:39 - because that makes more sense
32:43 - okay
32:44 - so we have number of runs that we want
32:46 - to do
32:47 - we have our main function
32:49 - and we have our for loop so
32:52 - as long as i is less than number of runs
32:56 - we want to do it and keep incrementing
32:58 - that i variable over here so we pretty
33:01 - much just want to evade secret algorithm
33:03 - 10 times in the loop but we want to do
33:06 - some but
33:08 - based on the description of this problem
33:10 - that we are dealing with we are also
33:12 - interested in time so i did pull in this
33:16 - performance dash now
33:19 - module for the node ecosystems and i'm
33:22 - simply saving storing it in this new
33:25 - variable and then what i simply do is i
33:28 - save the start time of each algorithm
33:30 - run and after it is done i then save the
33:33 - end time and then i pretty much like
33:37 - calculate the difference meaning how
33:39 - long the secret algorithm was running
33:41 - for and then we simply increment this
33:45 - variable that will hold all of the
33:47 - running times of our algorithms and then
33:50 - what we do is at the end we say total
33:52 - time is exactly that number of retries
33:56 - is number of runs that we have over here
33:59 - and then we say the average running time
34:01 - is we simply divide this total time by
34:04 - the number of runs we actually did and
34:06 - we simply format it to three decimal
34:09 - places and in case of an error we simply
34:12 - air it over here so
34:14 - it's
34:15 - so it is really easy the only confusing
34:17 - part could be this performance now but
34:20 - that also should make sense
34:22 - and now if i open this process file
34:25 - things are slightly different this time
34:28 - we again
34:29 - export some functions this time we
34:31 - simply export one function which is our
34:34 - secret algorithm after all
34:36 - and then we again use time and time end
34:39 - to measure the running time by the way
34:41 - um if you're wondering why we didn't
34:44 - simply use time and time end like we did
34:46 - in previous examples to measure
34:48 - this total time over here well it's
34:51 - because time and time dot end
34:54 - actually just outputs the running time
34:57 - in our terminal but we need to somehow
35:00 - store them in a variable and be able to
35:02 - divide them by the number of runs so
35:05 - that's the reason why we needed to use
35:07 - this as well so now let's
35:10 - let me get back to this so what we do is
35:13 - we simply await some time but this time
35:16 - isn't static so instead this is a small
35:18 - function that i wrote that will simply
35:20 - return a number between a and b
35:23 - so here we're returning numbers between
35:26 - 1 and 7 inclusive
35:28 - so both 1 and 7 could happen and then we
35:31 - simply multiply that number with 100 and
35:34 - that's how we get our milliseconds that
35:36 - this secret algorithm should wait for so
35:39 - it's really simple and it is all like
35:41 - just made up for this example but now
35:44 - let me run this and let's see what
35:45 - happens
35:46 - so i'm going to navigate to
35:50 - zero three loops and then zero one
35:54 - okay and now if i execute that
35:56 - example we see multiple secret algorithm
36:00 - runs over here in fact there are 10 of
36:02 - them we then see that the total running
36:04 - time so all of these values combined
36:07 - together is 5 000 and
36:11 - nearly 300 milliseconds we then see that
36:14 - we had 10 retries and one and once we
36:18 - divide this by 10 we see that our secret
36:21 - algorithm is running for
36:24 - roughly
36:25 - milliseconds on average so this is one
36:28 - example
36:30 - in which you can use simple old good for
36:33 - loop and you can see how the regular for
36:37 - loop plays really nicely with a weight
36:40 - we didn't do any new stuff really we
36:43 - simply awaited whatever we wanted inside
36:45 - of our for loop and everything was well
36:48 - so now let's take a look at the for each
36:50 - which i really like and i
36:53 - made a video about it in my es6 series
36:57 - and let's see what happens when we use
36:59 - it instead of this for loop so i'll
37:01 - close both of those files and let me
37:04 - open the main.js now for this example i
37:07 - wanted to create a slightly different
37:09 - example so that i keep things
37:12 - interesting and fresh so in this example
37:14 - we are actually running a grid of power
37:16 - plants and we want to somehow group them
37:19 - together in a single array and be able
37:21 - to quickly turn all of them on and off
37:24 - so we have this power plant class over
37:27 - here and let us first of all take a look
37:30 - at that so if i open this power plant
37:32 - file we see that this is a simple es6
37:36 - class that is called powerplant we have
37:38 - a constructor and in that constructor we
37:41 - simply pass in an id now id could be
37:43 - anything so that's just like the name
37:46 - that will assign to that power plant in
37:49 - particular and then we have two async
37:51 - functions to this class we have turn on
37:54 - and turn off
37:55 - and what we are doing we are simply
37:58 - outputting that like turning on power
38:00 - plant and then the name that we gave it
38:03 - and then we're using time and time end
38:05 - to actually measure how long this
38:08 - turning on operation
38:09 - took and then we're using again the same
38:12 - weight weight and we're getting some
38:14 - random number and we're multiplying that
38:16 - by 200 milliseconds and then we simply
38:19 - do this for like to get a new line so
38:22 - that formatting is a bit prettier turn
38:24 - off function is exactly the same we're
38:26 - just like outputting different words to
38:29 - the console
38:30 - okay so it's it's really easy to
38:33 - understand and now inside of the main
38:35 - what we're doing is we're creating a new
38:37 - array new empty array of power plants
38:40 - then we are adding to that array a new
38:44 - power plant
38:45 - five times and we are simply giving them
38:48 - an id of zero one zero two through zero
38:50 - five
38:51 - and then what we want to do is really
38:53 - quickly
38:54 - to be able to turn all of them on and
38:57 - turn all of them off so we use the
38:59 - forage helper for our power plants array
39:03 - and then we get access to every power
39:06 - plant in that array and for each power
39:09 - plant in that array we want to have a
39:11 - weight in operation
39:13 - of turning it on and turning it off
39:16 - so let's see what happens so i'll
39:18 - navigate to that folder
39:23 - and i'll type node main and as you can
39:26 - see really quickly something is really
39:29 - wrong and
39:30 - it's actually not even running
39:33 - so it says syntax error unexpected
39:35 - identifier power plant which is a bit
39:38 - weird because
39:40 - we kind of defined it over here but the
39:43 - problem is simply that you can't use a
39:45 - weight keyword inside of your forage so
39:49 - if you wanted to use for each with a
39:51 - weight you unfortunately can't do it
39:54 - but there are other ways that you can
39:56 - and one solution to this problem is
39:58 - using the for of so we're going to take
40:01 - a look at that next
40:03 - so let me close this file and
40:06 - let me open this next example
40:08 - which is exactly the same so i don't
40:10 - need to do any explaining we again have
40:12 - the same situation we again do the same
40:15 - things
40:16 - we again have the same class over here
40:18 - so the only difference is this time
40:20 - we're not using the forage but we are
40:22 - using the four off which is you simply
40:24 - start with a four keyword and then you
40:27 - write like the name that you want to
40:28 - reference each and every element of
40:31 - summary a
40:32 - and then you simply type array name so
40:35 - for every power plant that will be in
40:38 - the power plants array
40:40 - we do something and now like this
40:42 - needs to match
40:44 - um our array but this over here you can
40:47 - call it simply x if you wanted this is
40:49 - just
40:50 - a new variable for you that is scoped
40:52 - for just this block of code and then you
40:55 - can use it over here so i'm going to
40:58 - undo that because this makes more sense
41:00 - but just so you're aware this is
41:03 - this is the same
41:05 - that you had over here so you could call
41:06 - this one x as well
41:08 - okay so now in this four
41:11 - four of um
41:12 - example you can see everything is the
41:14 - same and simply let's run it and see if
41:16 - this works this time
41:19 - so i'll go back
41:21 - and i'll go in the for off example and
41:24 - i'll start that off
41:26 - and as you can see it seems to be
41:27 - working so
41:29 - we are turning on power plants so we
41:32 - turned on powerpoint zero one zero two
41:34 - zero three zero four zero five and all
41:37 - that worked
41:39 - and then we proceeded to turn all of
41:41 - them off
41:42 - with this piece of code over here and
41:45 - we turned them all off so this is
41:48 - example
41:50 - how you can use the four of and how you
41:52 - can't use the for each so that should be
41:55 - main takeaway from these two examples
41:58 - over here and now for the final example
42:00 - let's take a look at the while loop so
42:03 - i'm going to close both of these files
42:07 - and i'll navigate here so this time
42:09 - we're back again
42:11 - in our benchmarking example
42:14 - so we're benchmarking our algorithm
42:16 - again let me simply um
42:18 - rename it like i did in the previous
42:21 - okay
42:23 - in the previous example so we have
42:25 - really similar so the the sixth
42:27 - algorithm is the same so i don't need to
42:29 - do any explanation over here but the
42:32 - main is a bit different i mean i made it
42:35 - so
42:35 - that we really want to use while just so
42:38 - that i can demonstrate while loop
42:40 - so what he did is we have this retries
42:43 - variable that is equal to zero and we
42:46 - have total time which is equal to zero
42:48 - and then we simply repeat this piece of
42:51 - code over here while the number of
42:53 - retries are less than the number of runs
42:56 - so this over here will run 10 times and
42:59 - then again we store the time before
43:02 - running algorithm we store the time
43:04 - after running the algorithm and then we
43:06 - save the difference in this variable
43:08 - over here now after each
43:11 - run of this algorithm we want to
43:13 - increment this retries otherwise this
43:15 - will be in infinite while loop and then
43:18 - at the end we simply output total time
43:20 - number of retries and average running
43:23 - time this time we can either
43:26 - divide it
43:27 - by number of runs constant or we can
43:30 - divide it by three tries because they
43:32 - will store the same number in the end
43:35 - so let me do that let me run this
43:38 - example
43:41 - okay node main
43:44 - and let's see what happens um secret
43:46 - algorithm starts running
43:48 - 10 times and this is our average running
43:51 - time so this example i simply wanted to
43:55 - demonstrate that you can use while and
43:57 - that you can simply use a weight keyword
44:00 - in the while and everything works as you
44:03 - would expect it to so and this is it i
44:05 - have run out of examples unfortunately
44:08 - so i don't have anything else to show
44:10 - you but let's simply do a quick recap so
44:14 - we've seen that during the evolution of
44:16 - async programming in javascript we had
44:19 - different approaches with dealing the
44:21 - async code we started with callbacks
44:25 - we've seen that while they do get the
44:27 - job done it isn't the prettiest code
44:30 - ever
44:31 - and
44:32 - it can get really tedious to follow the
44:35 - logic of the the code that you wrote
44:38 - so that that is a downside of callback
44:41 - approach then we have seen that the next
44:44 - best thing were promises and in fact
44:47 - promises we are also going to use
44:50 - promises in our async code you've seen
44:52 - that promise.all function you've seen
44:54 - that if you have some legacy code or
44:58 - simply the the module that you're using
45:01 - is is implementing the callback
45:03 - interface meaning it is expecting you to
45:06 - pass in a callback function
45:08 - you can't really use it directly in your
45:11 - async
45:12 - function but what you can do is turn
45:14 - that function into a promise and then
45:17 - you can use it with a weight keyword so
45:20 - promise is really important they are
45:22 - what allowed the async to actually
45:25 - function so
45:27 - be sure to like study on promises then i
45:29 - briefly mentioned generators now i don't
45:32 - really have much experience using
45:34 - generators so i didn't want to rush in
45:36 - and like create some examples because i
45:39 - don't think it's really necessary given
45:41 - that we have access to uh to async await
45:44 - nowadays
45:45 - and then finally we've seen about the
45:48 - sinkhole weights we've not only seen
45:50 - like a difference in code that it
45:52 - produces in the slide but i also like
45:55 - walk you through all of these examples
45:58 - and you will learn how you can do
46:00 - sequential things using a single weight
46:03 - like this you've seen the potential
46:06 - issues you've seen the potential
46:08 - solution in the strike catch
46:11 - then we went over the parallel flow
46:13 - you've seen how you can use promise at
46:15 - all function over here and then we again
46:18 - seen some issues and some solutions and
46:21 - then last but not least we've seen how
46:23 - you can use a single weight when you
46:25 - need to iterate over through some data
46:28 - and we have discussed for loops for each
46:32 - for of and while
46:33 - so all of that should help you out in
46:36 - the future and i hope you learned
46:39 - something from this video it is a really
46:41 - long one so congratulations for sticking
46:43 - with me through the end hopefully you
46:45 - learned something it wasn't too
46:47 - complicated to follow me and if you
46:50 - liked it please leave me a like if you
46:52 - dislike it please dislike it and if
46:55 - possible let me know what i can do to
46:57 - improve in the future thanks for
46:59 - watching see you in some of my other
47:01 - videos