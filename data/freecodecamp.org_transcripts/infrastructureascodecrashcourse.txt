00:00 - in this course you will learn all about
00:01 - infrastructurist code i'll start by
00:03 - giving you a general overview of the
00:05 - different concepts and then i'll show
00:07 - you how to implement infrastructure as
00:09 - code with three different labs
00:12 - this course will use python and aws but
00:14 - the concepts will apply to other
00:16 - languages and cloud providers
00:18 - so let's start by talking about what
00:20 - infrastructure as code is to put it
00:22 - simply it's setting up your
00:24 - infrastructure as code by infrastructure
00:27 - i mean all the different things needed
00:29 - to deploy your software into a cloud
00:32 - environment
00:33 - that can mean things like virtual
00:34 - machines containers or serverless
00:37 - functions
00:38 - infrastructure also means all the other
00:41 - pieces of infrastructure you need to set
00:43 - up to make that successful
00:44 - that can be security like aim and kms
00:48 - or networking or some of the monitoring
00:51 - and logging capabilities
00:54 - you can also use code to configure and
00:56 - set up data stores
00:58 - these are the things that your
00:59 - application needs to store and manage
01:02 - data the last piece of infrastructure
01:04 - landscape is the applications themselves
01:07 - and getting the applications that we're
01:09 - building into the infrastructure
01:11 - all of these different pieces of
01:13 - infrastructure can be set up using code
01:16 - software as a service or sas
01:19 - is related to infrastructure's code
01:22 - software as a service allows users to
01:24 - connect to and use cloud-based apps over
01:27 - the internet
01:28 - sas provides a complete software
01:30 - solution that you purchase on a
01:32 - pay-as-you-go basis from a cloud service
01:34 - provider
01:35 - you rent the use of an app or software
01:37 - for yourself or for your organization
01:40 - from a cloud service provider and
01:42 - connect to it over the internet common
01:44 - examples are email office tools crms and
01:47 - development tools
01:49 - infrastructure as a service is part of
01:51 - software as a service infrastructure as
01:54 - a service is a cloud computing service
01:56 - where companies rent servers for compute
01:59 - and storage in the cloud this allows
02:01 - users to run operating systems or
02:03 - applications on the servers without the
02:06 - maintenance and operating costs of those
02:08 - servers
02:09 - so infrastructure as code involves using
02:12 - code to manage your infrastructure as a
02:15 - service
02:16 - it's becoming more and more important to
02:18 - automate infrastructure because
02:20 - applications can be deployed to
02:21 - production
02:22 - up to 100 times per day and you don't
02:24 - want to be doing that all manually
02:27 - it's also helpful for infrastructure to
02:29 - be provisioned or d provisioned in
02:31 - response to load we need to answer
02:33 - questions such as how do we get the
02:35 - images for our vms
02:37 - how do we get the container images in
02:39 - how do we package up and ship code into
02:41 - serverless functions
02:43 - over the years there has been a
02:45 - transition with how people are using
02:46 - cloud infrastructure within their
02:48 - organization
02:49 - in the first wave it was fairly simple
02:52 - the infrastructure were fairly static it
02:54 - was often single virtual machines that
02:56 - you just accessed through ssh
02:58 - it got a little more complex in the
03:00 - second wave
03:01 - there were more containers and people
03:03 - started using provisioning tools to
03:05 - specify the application behaviors people
03:08 - use things like docker and datadog
03:10 - modern cloud infrastructure has added
03:13 - way more complexity it uses containers
03:16 - serverless and more managed services as
03:19 - part of the applications
03:21 - there are now way more different pieces
03:24 - involved in how people build the
03:25 - infrastructure
03:27 - infrastructure as code is becoming a
03:29 - more important part of how people build
03:32 - and deliver applications because
03:34 - infrastructure as code is what describes
03:36 - the glue between all the different edges
03:39 - on these diagrams this diagram for the
03:42 - modern infrastructure may look more
03:44 - complicated than the previous ones but
03:46 - it can actually be easier to maintain
03:49 - a key benefit is that the dark gray
03:52 - squares in the diagram are the only part
03:54 - which is the code you own
03:57 - and that part is smaller than the
03:58 - previous ways of doing things
04:01 - so a lot of the operational burden has
04:04 - been decreased compared to how it used
04:06 - to be done
04:07 - with infrastructure as code it is now
04:10 - easier to build deploy and manage
04:13 - infrastructure in a repeatable and
04:15 - scalable way on a variety of cloud
04:17 - service providers
04:18 - infrastructure as code makes it easier
04:20 - to manage that process alongside your
04:23 - actual application code now there is a
04:25 - greater focus on the glue between the
04:28 - different services that are being
04:30 - managed by a cloud provider and these
04:32 - services can be deployed in a repeatable
04:35 - and scalable way infrastructure code
04:37 - takes on an increasingly more important
04:40 - role in how you manage everything in the
04:42 - modern cloud
04:44 - so here are the three main ways that can
04:46 - be used to manage all the resources
04:49 - manual
04:50 - that's how it used to always be done you
04:52 - just point and click to create or modify
04:54 - resources in the console you can do it
04:56 - like through the aws console you can
04:58 - just point and click to what things you
04:59 - want to create
05:01 - then there's ad hoc automation
05:03 - this is when you use cli commands or
05:05 - scripts to create and modify resources
05:09 - so you're kind of using some code but
05:11 - it's not going to be able to be reused
05:14 - over and over and modified very easily
05:18 - the third way is what we're talking
05:19 - about infrastructure as code there's
05:22 - provisioning which is declaratively
05:24 - creating and modifying resources
05:27 - and configuration which means to change
05:30 - the state of an existing resource post
05:32 - provisioning infrastructure as code
05:35 - gives us the ability to write down what
05:37 - we want the desired state of our
05:38 - infrastructure to be i'll be showing you
05:40 - how to do some of these things later
05:42 - there are a few different ways to write
05:44 - infrastructures code so one approach is
05:46 - to use json
05:48 - here's an example
05:50 - you can see this is a way to tell aws
05:54 - what resources you want to have
05:56 - you can see the resources the ec2
05:58 - instance
06:00 - the instant security group and just
06:01 - everything you're going to need just in
06:03 - a json format
06:05 - another method is to use domain specific
06:08 - language or dsl
06:10 - this is a custom method specific to the
06:12 - tool or cloud provider you are using so
06:16 - here's an example
06:17 - you can see it does kind of look like
06:19 - code but it's no no it's not like a
06:22 - popular programming language or even the
06:25 - exact way that json usually is written
06:28 - yet another way of defining
06:29 - infrastructure using code is to use a
06:31 - well-known programming language for
06:34 - instance polumi can be used to write
06:36 - infrastructure as code using typescript
06:38 - javascript python go and net
06:42 - here's an example using typescript
06:45 - and later we'll be using python
06:48 - using code gives the ability to do
06:50 - things that are not possible in some of
06:52 - the other methods
06:54 - in this example there's a for loop that
06:56 - creates an instance for each
06:58 - availability zone
06:59 - code gives the ability to use loops
07:02 - conditionals classes packages and more
07:06 - using popular programming languages also
07:08 - allows the use of common ides linters
07:11 - and test frameworks
07:13 - so let's get into some real world
07:16 - examples
07:17 - we're about to set up some actual
07:18 - infrastructure as code there are a few
07:21 - different services that allow you to use
07:22 - popular languages to create
07:24 - infrastructure as code in this course
07:27 - we'll be using pollumi
07:28 - this course was made possible through a
07:30 - grant from blooming
07:32 - pollumi is an open source infrastructure
07:34 - as code tool for creating deploying and
07:37 - managing cloud infrastructure
07:40 - pollumi works with traditional
07:41 - infrastructure like vms networks and
07:44 - databases in addition to modern
07:47 - architectures including containers
07:49 - kubernetes clusters and serverless
07:51 - functions
07:52 - plumi supports dozens of cloud service
07:55 - providers
07:56 - we'll be using python and deploying on
07:59 - aws
08:00 - though it can be done with other
08:01 - programming languages and cloud
08:03 - providers we'll start with a simple
08:05 - example
08:06 - this will show an end-to-end experience
08:08 - of working with plumi using very simple
08:10 - resources
08:11 - in this first example we'll do the
08:13 - following
08:14 - create a new project configure aws
08:17 - provision infrastructure update
08:18 - infrastructure make your stack
08:20 - configurable create a second stack and
08:23 - destroy the infrastructure we'll use an
08:26 - s3 bucket and then work through the life
08:28 - cycle with a simple set of resources
08:31 - then in future examples you will learn
08:33 - how to implement more complex things
08:36 - with pollumi infrastructure is organized
08:38 - into projects each project is a single
08:40 - program that when run declares the
08:43 - desired infrastructure for pollumi to
08:45 - manage
08:46 - before we start the first lab make sure
08:48 - you have polomi installed
08:50 - the way to install is different
08:51 - depending on your operating system you
08:53 - can check the link in the description
08:55 - for all the instructions for how to
08:57 - install different operating systems
08:59 - one way if you have home brew is just
09:01 - brew install
09:04 - pollumi
09:06 - like i mentioned we'll also be using aws
09:09 - you have to make sure you have an aws
09:10 - account and have the cli set up and
09:13 - authenticated i have a link in the
09:15 - description that shows you how to sign
09:16 - up for a free aws account
09:19 - also there's another link that shows how
09:20 - to install the aws cli for your
09:23 - operating system
09:24 - from aws you're going to need an access
09:26 - key id and a secret access key let me
09:29 - show you how to get that
09:31 - i'm at this url right here
09:35 - um you can do without the v2 at the end
09:37 - just the console.aws.amazon.com
09:40 - iam
09:42 - and then i'm going to go to users here
09:45 - and then i'm going to add a user i'm
09:47 - going to make a new user just for this
09:48 - project
09:50 - and the user is just going to be
09:52 - infrastructure as code or iac
09:56 - and i'm going to click that i want to
09:58 - get the access key here
10:00 - and next permissions
10:02 - i'll just add administrator access so to
10:04 - make sure it can do whatever needs to do
10:08 - and then i'll just go through just keep
10:09 - clicking clicking next and then create
10:11 - user
10:13 - okay now we have the amazon access key
10:16 - and the secret access key
10:18 - so you're going to actually have to copy
10:20 - the access key and the secret access key
10:22 - from this page and you can get that
10:24 - obviously by clicking show to show the
10:26 - secret access key let me show you where
10:28 - you're going to need those things
10:30 - go over to your command line and type in
10:32 - aws configure
10:37 - okay now this is where you're going to
10:39 - enter your access key
10:44 - i'm just going to copy it from here
10:49 - and then the aws the aws secret access
10:52 - key
10:55 - now yours probably won't have this here
10:57 - because i've already done that so it's
10:59 - seeing if i want to use what i already
11:00 - have but i want to put in a brand new
11:02 - one here
11:04 - and then we can just click none for the
11:06 - next few things here
11:09 - okay aws is set up
11:14 - so the first step to starting a pollumi
11:16 - project is to create a new directory
11:20 - each pollumi project lives in its own
11:22 - directory so i'm going to create one
11:24 - first i'm going to go into projects
11:26 - okay i'm gonna make a directory
11:28 - and i'm just gonna call it iac
11:30 - lab
11:32 - one
11:33 - now just jump into my directory i just
11:34 - created
11:36 - okay i'll do paloomi
11:38 - new python because we're making a python
11:40 - project and we'll just select yes to
11:42 - everything
11:44 - now i've already used pollumi on this
11:45 - computer but if this is the first time
11:47 - you've used pollumi you will be directed
11:49 - to enter an access code or log in and it
11:53 - will tell you the website to go to get
11:55 - to get the access code but it's
11:57 - app.paloomy.com
11:59 - account slash tokens you will have to
12:02 - create a plumi account and then you will
12:04 - be able to get your access code
12:06 - so this command has created all the
12:08 - files we need it's initialized a new
12:10 - stack named dev which is an instance of
12:12 - our project we now need to install our
12:15 - dependencies as part of our virtual
12:18 - environment
12:19 - so let's set up our virtual environment
12:21 - we're going to create a virtual
12:22 - environment and install the required
12:23 - python packages the python module used
12:26 - to create and manage virtual
12:28 - environments is called v e and v so
12:31 - let's use these commands first we'll do
12:33 - python
12:34 - 3
12:35 - m v e and v v e n v
12:41 - and then source v e and v slash been
12:44 - slash activate
12:47 - okay i've activated my virtual
12:49 - environment and now i'm going to install
12:51 - the requirements pip 3 install
12:55 - requirements
12:57 - dot txt
12:59 - that requirements.txt file was created
13:02 - when we initialized our polumi project
13:06 - now let's open this up i'm going to open
13:08 - up in visual studio code but you can use
13:10 - any code editor you want
13:12 - okay these are all the files that got
13:15 - installed when we did their pluminew
13:18 - this main.pie is the program's main
13:20 - entry point file this is the file that
13:22 - we'll be putting all of our code in now
13:25 - we have the requirements.txt
13:27 - that's just your project's pip
13:29 - dependency information
13:31 - and then we have pollumi.yaml
13:33 - which is the project's metadata
13:35 - containing its name and language you can
13:37 - see we have python and then we have the
13:40 - name here and the virtual environment
13:43 - so if we go back into the main.pi we'll
13:45 - notice that we just have one line of
13:47 - code that's just automatically put in
13:49 - there which is import gloomy now there
13:53 - could be more or less code in here
13:54 - depending on
13:56 - which way we run the plumi new command
13:59 - but we just wrote ran it with plummy new
14:01 - python so it just started with import
14:04 - polymer which is the line of python so
14:06 - now that we have the basic project let's
14:09 - configure aws support for it
14:12 - i'm actually going to open the terminal
14:14 - right from within vs code okay i'm going
14:17 - to install something so pip 3 install
14:20 - pollumi
14:21 - aws
14:25 - now i'm going to
14:26 - make our code
14:28 - take up more of the room here and i'm
14:30 - going to add another line so import i'll
14:32 - import we just installed so import
14:36 - pollumi
14:38 - and actually recommend it right here
14:41 - as aws
14:45 - okay now we're going to configure an aws
14:48 - region which is whatever region you want
14:50 - to deploy to
14:51 - by we're going to run something in the
14:52 - command line so i'll go back down to the
14:54 - command line and i'm going to do pollumi
14:57 - config
14:58 - set
14:59 - aws
15:01 - region
15:02 - and you can use any aws region that you
15:06 - like but in my case i'm going to use us
15:08 - east
15:10 - one okay now we're actually going to
15:13 - start doing some infrastructure as code
15:15 - we're going to provision infrastructure
15:18 - so now that we have a project configured
15:20 - to use adws we'll create some basic
15:22 - infrastructure we'll start with a simple
15:24 - s3 bucket so let's declare a new bucket
15:28 - right up in our python file here i'm
15:31 - going to say bucket
15:33 - equals a
15:35 - aws.s3 dot well s3 dot bucket
15:42 - bucket
15:44 - and then you can call anything you want
15:47 - but i'm going to call it
15:49 - my
15:50 - bucket
15:53 - okay i'm going to save this and we're
15:55 - going to preview the changes so i'm just
15:57 - going to go back to my terminal down
15:59 - here and type in pollu me
16:02 - up
16:03 - so pluto me up is the command you'll be
16:05 - running a lot with palumi which is going
16:07 - to basically run our main.pi file and
16:11 - set up our infrastructure how we
16:13 - configured it so it looks like there's
16:14 - an error here so let's see what that is
16:18 - hmm looks like there was a mistake with
16:21 - my aws login let me just try doing the
16:24 - login again and see if that fixes the
16:25 - problem
16:29 - aws configure
16:32 - now i'm going to get my access key
16:34 - now try running pollumi up again
16:39 - okay work this time
16:40 - so let me
16:42 - bring up this we can see more of what
16:44 - the output was here
16:46 - so this is a preview the command
16:48 - evaluates your program determines the
16:51 - resource updates to make and shows us an
16:54 - outline of these changes so this is
16:56 - what's going to happen we're going to
16:58 - create this stack and we're going to
17:00 - create this bucket here and it hasn't
17:02 - done anything yet we can decide what we
17:05 - want to do for now i'm going to go to
17:06 - details to see more details
17:09 - so you can see now we can see that the
17:10 - acl
17:12 - is private you can see the actual bucket
17:14 - name we call that my bucket but plume is
17:17 - going to add this at the end so we can
17:20 - actually create a bunch of buckets with
17:22 - the same name but it's just going to
17:23 - have a different thing at the end here
17:25 - and you can just see some extra details
17:27 - about this and i do want to perform this
17:29 - update so i'll just go to yes and okay
17:31 - return
17:35 - so now our s3 bucket has been created in
17:38 - our aws account so if we view our
17:41 - buckets on the aws website you'll see
17:43 - the new bucket so i'm going to go to aws
17:45 - and then go to the s3 section
17:49 - and it's going to show this bucket we
17:50 - just created
17:53 - so it's currently empty but we can see
17:56 - the bucket that we just created with
17:57 - pallumi
17:59 - and there's also this url here
18:02 - if we go to this url i'll let's do uh
18:06 - i'll just do command click
18:11 - and i'm going to have to log into plumi
18:14 - to get this to work out
18:17 - so now we're on the plumi console which
18:20 - records your deployment history so right
18:23 - now we've just done one one thing so you
18:26 - can see one thing on here
18:28 - okay next i'm going to show you how to
18:30 - export your new bucket name so
18:33 - we're going to go back into the code
18:35 - area
18:36 - and to inspect your new bucket you'll
18:38 - need its physical aws name well we did
18:42 - see we were able to see the name
18:45 - up here when we went to more details
18:48 - but there's another way to get the name
18:50 - that i will show you using the code
18:54 - so
18:55 - this
18:56 - is called
18:57 - the logical name my bucket but like i
19:00 - said before the aws name will be a
19:02 - little different
19:04 - programs can export variables which will
19:06 - be shown in the cli and recorded for
19:08 - each deployment so let me show you how
19:10 - to export the bucket's name by adding a
19:12 - line of code in here so right after we
19:15 - get the bucket here i'm going to do
19:17 - pollumi.export
19:21 - x
19:22 - export
19:24 - and then i'm going to export the bucket
19:28 - name
19:30 - so that's just what we're calling this
19:31 - value which we're going to get as
19:33 - bucket.bucket
19:35 - so this bucket.bucket will be the bucket
19:38 - name so let me just save this
19:41 - and then we'll go back into the terminal
19:44 - and i'll do pollumi
19:46 - up
19:49 - and now we can see
19:51 - there's a new line here outputs
19:54 - so
19:55 - you can in your python code you can
19:58 - export certain information that will
20:00 - show up in the output section when you
20:02 - do blue me up
20:05 - so i'll just select yes to perform the
20:08 - update
20:10 - and you can see it's unchanged because
20:12 - the only update was just to output the
20:14 - bucket name here
20:15 - you can see all the output
20:18 - by running this command in the terminal
20:20 - pollumi
20:22 - stack output
20:26 - you can see it's there's only one output
20:28 - the bucket name and then it has the
20:29 - value of it right here
20:31 - now we can run the aws cli to list the
20:35 - objects in this new bucket
20:37 - and we can get the bucket name using the
20:39 - command from above let me show you how
20:41 - you do that so we're going to do aws
20:45 - s3
20:46 - ls and then
20:49 - i'm going to run that command right in
20:51 - here pollumi stack output
20:55 - bucket
20:57 - name so that's going to get the bucket
20:58 - name
20:59 - and if we run that command
21:02 - nothing's going to really happen because
21:04 - there's nothing in the bucket so it's
21:07 - returning what's in the bucket but
21:08 - there's nothing in the bucket so there's
21:09 - nothing to be returned
21:11 - but we'll change that shortly
21:13 - we're going to now update the
21:15 - infrastructure we just saw how to create
21:17 - new infrastructure from scratch so now
21:19 - we're going to make a few updates we're
21:22 - going to add an object to the bucket
21:24 - we're going to serve content from the
21:25 - bucket as a website and we're going to
21:28 - pragmatically create infrastructure
21:31 - this will demonstrate how declarative
21:32 - infrastructure as code tools can be used
21:34 - not just for initial provisioning but
21:36 - also subsequent changes to existing
21:38 - resources so we're going to add an
21:40 - object to the bucket i am going to
21:43 - create a new directory i'm going to just
21:45 - go to new folder i could click this
21:48 - button up here this folder is going to
21:49 - be called
21:51 - site and then i'm going to make a new
21:53 - file and this will be called index.html
21:57 - okay i'm just going to make an extremely
21:59 - simple website here html
22:03 - and
22:04 - body
22:10 - and then just an h1 tag and it's going
22:13 - to say
22:14 - hello
22:15 - everybody
22:20 - okay now let me
22:23 - rearrange things here we'll go back to
22:25 - our main.pi
22:27 - and let's add some lines of code so we
22:30 - can add that file
22:32 - to our bucket
22:34 - so i'm going to add import
22:38 - and put a new library the os library so
22:40 - we can access
22:41 - uh stuff from our operating system the
22:43 - file path in particular
22:45 - so
22:48 - let's see actually we'll put it right
22:49 - here
22:52 - file path equals os dot path dot join
22:58 - and then we'll put the directory name
23:00 - site
23:02 - and then the file name index.html
23:08 - now we're going to create an object
23:11 - variable
23:12 - and we'll do aws.s3
23:15 - dot bucket object
23:21 - index.html
23:24 - so the object is index.html
23:29 - and then
23:31 - the bucket
23:32 - is going to be
23:35 - dot bucket
23:36 - and that's how you get the name of the
23:38 - bucket that we created
23:40 - and for source
23:45 - i'll put polumi
23:49 - file
23:51 - asset
23:54 - file
23:55 - path
23:58 - so this is how you use
24:00 - polumi to get this asset this file path
24:03 - right here we're going to create as the
24:06 - object that goes into our bucket
24:10 - so i'm going to save that and enter
24:12 - terminal we'll do plumi up
24:16 - and then i'll just
24:18 - look at this
24:19 - more
24:22 - oh
24:23 - not fire asset file
24:26 - asset because this is a file asset
24:29 - so i'll go to plume up
24:36 - see that makes a lot more sense to you
24:37 - doesn't it than fire asset okay so you
24:40 - can see it's showing what the change is
24:42 - going to be we're going to create this
24:44 - object which is the index.html we're
24:47 - going to create that
24:51 - so i will go to yes to
24:54 - do these changes perform this update
24:58 - so a single resource is added and the
25:01 - two existing resources are left
25:03 - unchanged this is a key attribute of
25:06 - infrastructure as code such tools
25:08 - determine the minimal set of changes
25:10 - necessary to update your infrastructure
25:13 - from one change to the next
25:15 - so
25:16 - let's list again the contents the
25:18 - contents of the bucket i'll just press
25:20 - up a few times we'll use the same line
25:22 - from before
25:23 - and now let's see what's in the bucket
25:27 - it's showing index.html and if i go back
25:29 - over to my web browser
25:32 - and if i refresh
25:34 - my page that shows the bucket on aws
25:38 - we should see yep we see this index.html
25:41 - right here next step we're going to
25:42 - serve content from the bucket as a
25:45 - website
25:46 - to do that we'll need to update a few
25:49 - properties
25:50 - first the bucket needs a website
25:52 - property that sets the default index
25:54 - document the index.html
25:57 - that can
25:58 - that can be achieved by making a few
26:00 - changes to our python file
26:04 - we have our bucket right here
26:07 - and
26:08 - i'm going to after the buck and nam and
26:10 - add a comma
26:14 - and then i'm going to put
26:15 - website
26:17 - equals
26:21 - and then we just have to set the index
26:22 - document
26:25 - and we'll just set that to
26:27 - index.html
26:30 - and make sure that's in a string here
26:38 - okay next
26:39 - the index.html object will need two
26:41 - changes
26:45 - so let's go
26:47 - down here to see this index.html object
26:49 - that's right here
26:51 - we're going to need an acl which is an
26:53 - access control list of public read
26:57 - so right after the source
27:00 - i'll put
27:03 - acl
27:04 - equals
27:07 - public
27:09 - read
27:14 - there now you can see that better
27:16 - this makes it so it can be accessed
27:17 - anonymously over the internet
27:20 - we also need a content type so it's
27:23 - served as html
27:26 - so
27:27 - for the content type to work
27:29 - let's go back up to the top
27:31 - we're going to import something import
27:34 - mime types because we're going to set
27:36 - the mime type
27:38 - and then down here after the file path
27:41 - we're going to get the mime type of the
27:43 - file so mime
27:46 - type
27:48 - and what
27:50 - we'll put it underscore because this is
27:51 - going to return two things but we only
27:53 - need one of the things which is the mime
27:55 - type so we'll do mime types
27:58 - dot guess
28:01 - type
28:02 - and we'll guess the type of the file
28:05 - path
28:07 - and now down here we can set the content
28:12 - type
28:14 - to
28:14 - the mime type
28:16 - so now we have the content type so it's
28:18 - served as html
28:20 - we'll also need to export the resulting
28:22 - buckets endpoint url so we can easily
28:24 - access it so let me show you how you
28:26 - would do that
28:28 - so here we're exporting the bucket name
28:31 - and now let's export the bucket endpoint
28:34 - the full url so we'll do pollumi
28:38 - dot export
28:40 - and this will be called the bucket
28:42 - endpoint
28:45 - we're going to use this concat function
28:49 - from polumi to concat a string and
28:52 - something else so this bucket.bucket
28:55 - it's actually an object it's not a
28:58 - string but it does return a string so if
29:00 - we want to combine something like this
29:02 - with a string we have to use uh concat
29:04 - let me show you how that's done we're
29:06 - going to do pollumi dot output dot
29:09 - concat
29:11 - and then i'm going to put the two things
29:13 - we're going to concat the first thing is
29:14 - going to be a string https came and see
29:17 - what i'm writing here let's see if i can
29:19 - http
29:21 - let's do http
29:23 - colon slash slash
29:25 - and then we'll get a comma here
29:28 - and
29:29 - then just bucket dot web site
29:33 - endpoint
29:36 - so we're just concatenate we're
29:38 - concatenating the http and this website
29:41 - endpoint
29:43 - okay let's deploy the changes so well
29:45 - let me save it and then we'll do pollumi
29:50 - up
29:56 - if i go up here
29:59 - we can see it's making some updates and
30:01 - i'll go to yes
30:06 - okay now we have this
30:08 - url here so we can use this to access
30:11 - that index.html file so i can actually
30:14 - just copy this url stored on amazon aws
30:18 - and now i can open up the url right in
30:21 - my web browser it says hello everybody
30:25 - i can also use curl to get it so back in
30:28 - my terminal do curl
30:30 - and
30:31 - now i am going to run a command right
30:34 - here to get the website url
30:41 - lumi stack output and then you can get
30:44 - any of the things that get output and
30:46 - we'll get bucket
30:48 - endpoint
30:53 - okay see we got this
30:55 - here's the text of our html file
30:58 - next we are going to make the stack
31:00 - configurable
31:02 - right now the bucket's contents are hard
31:04 - coded
31:05 - we're going to make the location of the
31:07 - contents configurable and add support
31:09 - for populating the bucket with an entire
31:11 - directory's worth of contents
31:13 - so the next step is to add a config
31:16 - variable
31:17 - right now
31:18 - we hard code the directory of the site
31:21 - let me show you here so we have we're
31:24 - hard coding
31:25 - this directory here
31:27 - of the site so we're going to configure
31:30 - it to make it easy to change the
31:31 - location without editing the program
31:34 - so right below the imports here i'm
31:37 - gonna do config
31:40 - equals pollumi dot config
31:44 - that's going to make it possible to
31:46 - access some
31:48 - config settings that we set up
31:50 - and we're going to specifically access
31:53 - the site
31:56 - directory
31:57 - and we're going to get it from
31:58 - config dot
32:01 - require
32:03 - and then we're going to get the site
32:06 - dir and i remembered i see that i
32:08 - spelled paloomi wrong
32:11 - there we go
32:12 - and we are going to set this in a minute
32:14 - the site directory but first let's
32:16 - update our program to use this citer
32:18 - variable so instead of getting the site
32:22 - here i'm just going to paste in the
32:24 - variable name okay so now what we're
32:26 - going to do i'm going to save this and
32:29 - then i'm going to go back into my files
32:30 - i'm going to rename this site directory
32:34 - i'm going to rename it
32:36 - www now you may not actually do this in
32:39 - like a real life situation but we're
32:41 - just doing this as an example to see how
32:43 - this can be helpful
32:45 - so let me go into my terminal
32:47 - and i'm gonna do pollumi
32:49 - up
32:52 - okay it's saying air missing required
32:54 - configuration variable this site dur
32:57 - variable and it says please set a value
33:00 - using the command plume config set ic
33:03 - lab 1 site directory with the value so
33:05 - that's what we're going to do now i'm
33:06 - just going to copy this command here
33:09 - and then i'm just going to paste it in
33:11 - and then i'm going to set it to www so
33:13 - now the directory you'll be looking for
33:15 - is the www directory instead of the site
33:17 - directory
33:20 - okay i'll just do plume up again
33:27 - and i will perform the update
33:32 - okay that works so now we don't have to
33:35 - have the the directory hard hard-coded
33:37 - in here we can use these config
33:39 - variables and you can see how you'll be
33:41 - able to use that with other types of
33:42 - data as well okay now we're going to add
33:45 - more files instead of hard coding the
33:47 - set of files
33:49 - which we do now let me show you what i
33:50 - mean right now we hard code that we're
33:54 - adding the index.html file
33:57 - to our bucket but instead of doing that
34:00 - we're going to change the program to
34:02 - read the entire contents of the www
34:05 - directory and add every file from that
34:08 - directory to our bucket so let's start
34:10 - by adding a new file to that directory
34:13 - so i'm going to go into the directory
34:14 - and click the new file button and this
34:17 - is going to be called about.html and
34:19 - this is just going to be a simple thing
34:21 - you can make it anything you want i'm
34:23 - just going to make an extremely simple
34:25 - file with a paragraph it will say it's
34:29 - about so i want to say something about
34:30 - me and i am not a cat so that's
34:33 - something about me
34:35 - okay let's go back to the main.pi file
34:38 - and we're going to replace the object
34:41 - allocation code
34:43 - and now we are going to update the
34:45 - object
34:46 - allocation code so this right here we're
34:50 - going to put all of this into a for loop
34:54 - so i'm going to say for file in os dot
34:57 - list
34:58 - directory
34:59 - site
35:02 - directory
35:04 - and then i'm gonna just indent all this
35:07 - so it's all in that directory
35:10 - and see we have the the file here so now
35:13 - instead of index.html
35:15 - i'm going to put this variable file
35:19 - so now we are using this for loop to go
35:23 - through
35:24 - every file and adding all those files to
35:27 - our bucket now this is one of the really
35:30 - cool things about infrastructure as code
35:32 - and using an actual programming language
35:34 - like python is that you can use for
35:36 - loops and that can make things go a lot
35:39 - that can make things a lot simpler and
35:42 - save a lot of time like we didn't have
35:44 - to use a for loop we could have just
35:46 - copied and pasted this code a bunch of
35:48 - times and and then added each file
35:51 - individually in insta instead of using
35:54 - this for loop but this is going to save
35:56 - us a lot of time especially if we have
35:58 - tons of files that we want to put into
36:00 - our bucket
36:02 - so let's go back to the terminal i'll do
36:04 - actually have to save first here and
36:06 - then i'll do pollumi up
36:11 - so you can see what's going to do it's
36:12 - going to create
36:14 - this file this is about.html
36:16 - and let's do that i'll go to yes
36:20 - now i'm back in my web browser i'm going
36:22 - to put a slash about
36:26 - dot html at the end
36:29 - and now we can see
36:30 - i'm not a cat i can zoom in on that so
36:32 - you can see a little better it's just a
36:34 - paragraph tag so it's pretty small
36:36 - we can also access it through curl the
36:39 - same ways before
36:40 - let me just press up in here but i'll
36:42 - just put slash
36:44 - about.html at the end
36:47 - and then yep here it is here's the
36:49 - about.html file we created
36:52 - now we're going to create a second stack
36:55 - it's easy to create multiple instances
36:56 - of the same project in pollumi each
36:59 - instance is called a stack
37:01 - this is useful if you have multiple
37:03 - development or test environments like
37:05 - staging versus production or if you want
37:08 - to scale a given infrastructure across
37:10 - many regions
37:12 - so let me show you how to create and
37:14 - configure a new stack we'll create a
37:16 - stack named prod so i'm
37:19 - still in the terminal down here i'll do
37:21 - pollumi stack and knit
37:24 - prod
37:27 - and i just created it now next i'll
37:29 - configure the two required variables
37:32 - the same ones we did before so we'll do
37:34 - paloomy
37:38 - config set
37:41 - this is going to be the region aws
37:43 - region
37:44 - and we're going to do it different from
37:45 - before this time it's going to be eu
37:47 - west
37:48 - one you can basically set this to any
37:50 - aws region
37:52 - we'll also set
37:54 - the the site directory
37:56 - paloomi config
37:59 - set
38:01 - iec
38:03 - lab
38:04 - one
38:06 - site
38:08 - directory
38:10 - and instead of the www this is gonna be
38:12 - www.prod
38:14 - i'm just showing where you can have
38:15 - different site directories for different
38:18 - projects for different stacks
38:21 - so let's see the list of stacks we have
38:24 - paloomi
38:26 - stack
38:28 - ls
38:31 - we have the dev stack
38:32 - and we have
38:34 - the prod or production stack
38:36 - now let's populate the new site
38:37 - directory we could have used the
38:39 - existing www directory for the site
38:42 - directory but for this example we'll use
38:44 - the the www prod directory to
38:47 - demonstrate how it can be configured
38:49 - we will make a directory
38:52 - wwe prod
38:55 - and then i'm just going to create a file
38:56 - right from here we could have created
38:57 - the directory from here so where's our
38:59 - new directory
39:02 - right here i'll just create a new file
39:05 - and it's just going to be another
39:06 - index.html file
39:08 - and
39:10 - we'll just make it pretty similar let's
39:12 - copy this other index.html file but this
39:15 - time we're going to
39:17 - add a paragraph tag here
39:20 - and put
39:21 - in production
39:23 - so then we will be able to know the
39:25 - difference between the production one
39:27 - and the development one so just save
39:29 - that
39:30 - and then we'll just deploy the changes
39:32 - plume
39:34 - up
39:35 - we don't need that up anymore
39:38 - it says we need to set the command the
39:40 - configuration variable apparently this
39:42 - got set wrong oh it's because i call the
39:46 - site
39:47 - i made a mistake a long time ago where's
39:49 - the side drill which should have been
39:50 - site der so let's just go back over here
39:53 - and
39:55 - let's see
39:57 - this is supposed to be site der
40:01 - and i must of uh yeah so now let's try
40:05 - this
40:06 - pollumi
40:08 - up
40:13 - and then i'm actually going to also have
40:14 - to
40:16 - create the site the site der
40:19 - configuration variable for the
40:21 - development
40:22 - stack but we're on the this we're on the
40:25 - production stack now so let's keep going
40:27 - with this
40:30 - okay so we can see
40:33 - the new buckets new objects it's
40:34 - creating
40:35 - and we can go to details just like
40:37 - before
40:39 - and you can see additional information
40:41 - but i will just go to yes and perform
40:44 - the update
40:47 - okay let's try going to this url here i
40:50 - click command click but i'm just going
40:51 - to copy it
40:54 - and then i'm going to go to my you
40:56 - website here
40:57 - hello everybody in production so we're
41:00 - now seeing the production website
41:03 - we can also curl it just like before
41:05 - it's actually pretty much the same
41:06 - command so if i just press up a few
41:09 - times
41:12 - and we see hello everybody in production
41:15 - and especially when you're practicing
41:18 - whenever you get to the end of what
41:19 - you're doing you want to destroy
41:22 - everything destroy the resources
41:24 - this is especially important in aws you
41:26 - don't want to accidentally be charged
41:28 - something if you have stuff on aws for a
41:31 - long period of time so
41:33 - to destroy all the resources we can just
41:36 - use pollumi
41:38 - destroy
41:40 - and that will make sure everything
41:42 - gets destroyed
41:44 - just like before it's going to show us a
41:46 - preview and it's showing that it's going
41:48 - to be deleting
41:50 - all these things
41:51 - three to delete
41:54 - and yes i want to do that
41:57 - and you'll see this message on the
41:59 - bottom
42:00 - the resource and the stack may have been
42:01 - deleted
42:02 - but the history and configuration
42:04 - associated with the stack are still
42:05 - maintained if you want to remove the
42:07 - stack completely run pollumi stack
42:10 - remove fraud which we do want to do so
42:13 - paloomi
42:14 - stack
42:15 - remove
42:16 - prod
42:18 - and i'll just type in prod to remove
42:20 - that but remember we have another stack
42:22 - we have the dev stack so we're gonna
42:24 - have to switch back to the dev stack
42:26 - using pollumi stack select
42:30 - dev
42:31 - and then once we've
42:32 - went back to that stack we can do
42:35 - halloumi
42:36 - destroy
42:40 - and then i will say yes we want to
42:42 - destroy that
42:44 - and then we want to run this other
42:46 - command again
42:48 - gloomy stack remove dev
42:56 - and type in dev
42:59 - okay let's just verify that the stacks
43:01 - are gone so i'll do pollumi
43:03 - stack
43:05 - list
43:06 - and there are no stacks
43:08 - okay we just completed the first lab the
43:11 - next few labs are a little shorter and
43:13 - demonstrate some more advanced tasks
43:20 - the second lab is all about provisioning
43:22 - ec2 virtual machines
43:25 - amazon elastic cloud compute also known
43:28 - as amazon ec2 is a web service that
43:30 - provides secure resizable compute
43:33 - capacity in the cloud it's designed to
43:35 - make web scale cloud computing easier
43:38 - for developers amazon ec2 simple web
43:40 - service interface allows you to obtain
43:42 - and configure capacity with minimal
43:44 - friction so in this lab you'll first
43:47 - create a single ec2 virtual machine
43:50 - afterwards we'll scale that out to a vm
43:53 - per availability zone in your region and
43:56 - then add a load balancer to spread load
43:58 - across the entire fleet
44:01 - now we could do it all within the
44:03 - directory we already created
44:05 - and just update our python file just
44:08 - remove everything from our python file
44:09 - and start from scratch
44:11 - but we'll create a new one to get more
44:13 - practice we'll create a new directory to
44:14 - get more practice so let me create a new
44:17 - directory
44:18 - called iac lab
44:21 - 2 and i'll go right into it cd iac lab 2
44:26 - and then i'll just open that with my
44:27 - code editor in this case visual studio
44:30 - code
44:31 - and before i initialize the project in
44:33 - the terminal and then switch over to
44:34 - code editor now i'll just initialize the
44:37 - project right from the terminal within
44:39 - my code editor so let me open up the
44:41 - terminal
44:43 - and we'll do pollumi
44:45 - new aws python so this is a little
44:48 - different from before
44:49 - why
44:52 - now we just have to make sure our
44:54 - virtual environment is set up so do
44:56 - python 3
44:59 - then
45:00 - then
45:04 - and then source then
45:06 - then activate
45:09 - let's try putting an e at the end that
45:11 - works better okay now let's install the
45:14 - requirements
45:19 - and let me configure the aws region so
45:22 - plumi config set
45:25 - aws
45:26 - region
45:28 - us
45:29 - west
45:32 - two and again you can use any region for
45:34 - this
45:35 - okay you can see the files here are
45:37 - pretty much the same before we have the
45:38 - requirements we have the yaml file
45:42 - move this down
45:44 - in the main.pi you can see this is a
45:47 - little different we've already
45:49 - initialized this with creating a bucket
45:52 - and exporting the bucket
45:54 - you can see the way we created this
45:57 - with the plumey new
45:59 - already added some some extra code
46:02 - creating an s3 bucket
46:04 - i'm going to do this a little
46:05 - differently so i'm actually going to
46:06 - delete all this and i'm going to import
46:10 - pollumi
46:15 - as aws
46:19 - now we're going to dynamically query the
46:21 - amazon linux machine we'll do this in
46:24 - code and so that will avoid needing to
46:26 - hard code the machine image
46:29 - in other words it's ami ami is the
46:32 - amazon machine image and that provides
46:34 - information required to launch an
46:36 - instance so let's get the ami with code
46:39 - so ami
46:40 - equals aws
46:42 - dot ec
46:44 - 2
46:45 - dot get
46:46 - ami
46:48 - and we want to get the most recent one
46:52 - okay you can barely see that
46:54 - okay mo so most recent we can set that
46:56 - to true
46:58 - and then i'm actually just going to
46:59 - paste in some stuff here
47:03 - everything's in the description all the
47:04 - code and everything there's a link to an
47:06 - article that will have all this code
47:09 - but this allows us to set the owner of
47:11 - the ami and some filters we want to use
47:15 - so we also need to grab the default
47:17 - virtual private cloud which is a service
47:20 - that lets you launch aws resources in a
47:23 - logically isolated virtual network that
47:25 - you defined
47:26 - that's available in our aws account so
47:29 - to get that virtual private cloud we'll
47:31 - just do vpc
47:32 - equals aws.ec2.getv
47:39 - and then we'll just set the default
47:42 - to equal true
47:46 - now we'll create an aws security group
47:49 - this will enable ping over icmp and http
47:53 - traffic on port 80.
47:55 - so for this i will just paste it in
47:59 - and we can see this is how you would
48:00 - create a security group on here
48:07 - and again you can get that code right
48:08 - from the article in the description
48:10 - now we're going to create a server
48:13 - and this server is actually going to
48:15 - have a startup script that spins up a
48:17 - simple python web server i'm just going
48:19 - to paste in some code and then i'll
48:21 - explain it
48:22 - so we're creating an instance of the
48:24 - server we're creating a web server and
48:26 - then this is the type a t2.micro
48:29 - and this comes right from aws the types
48:32 - of different servers that you can create
48:34 - so you could do a t3 or t1 and there's
48:37 - just different types you can do
48:39 - and then we're getting the security
48:40 - group ids right from what we already
48:43 - created up here the group ids
48:46 - and then the ami is from what we already
48:48 - created and then this is an interesting
48:50 - thing the user data
48:52 - here we are creating a simple python web
48:56 - server
48:57 - now for most real world applications you
48:59 - would want to create a dedicated image
49:01 - for your application
49:02 - rather than embedding the script in the
49:04 - code like this
49:06 - but for this example we're just trying
49:08 - to spin up something really quick
49:10 - okay now we are going to export the ec2
49:13 - instances resulting i p address and host
49:16 - name so we'll do pollumi
49:18 - dot export
49:20 - and then we're going to export the ip
49:24 - and then server
49:26 - dot public
49:28 - ip we're getting the ip is coming
49:30 - directly from aws here
49:33 - and then the host name
49:37 - which in this case is the public dns
49:40 - okay we're going to provision the ec2
49:42 - instance and access it so to provision
49:44 - it we'll do pollute me up
49:47 - wait first save save and then pollute me
49:49 - up
49:50 - and then let's see what it shows
49:53 - looks like there's an air i think we
49:55 - made a minor mistake here oh api that
49:59 - should be ami
50:01 - so let's save that
50:03 - and then do blue me up again
50:06 - okay and you can see it's showing what
50:09 - it's about to create
50:10 - and i'll just go into yes
50:16 - okay if we go up we can see we have the
50:18 - host name and the ip address
50:20 - so i'm actually just going to take this
50:22 - hostname and copy it we're going to go
50:24 - right into our web browser so if i paste
50:26 - it in here
50:31 - okay it took a few seconds to start
50:33 - working but it must have finished
50:35 - provisioning so it says hello world
50:38 - and another way to do is write from the
50:39 - command line
50:41 - interestingly it looks like a new
50:43 - version of polumi must have came out in
50:44 - the middle of me making this tutorial
50:47 - because it wasn't saying that before
50:49 - okay but right now i'm going to do this
50:52 - curl
50:57 - and do pull
51:00 - pull me
51:02 - stack output hostname
51:07 - and then we can see the hello world
51:09 - right here and i might as well just
51:13 - install the new version of pollumi while
51:14 - i'm at it
51:19 - okay that was simple so the next thing
51:21 - we're going to do is add more ec2
51:23 - instances we're going to create multiple
51:25 - instances that are each running the same
51:27 - python web server and we're going to
51:29 - make them across all aws availability
51:31 - zones in the region
51:33 - so let's go back up to our code
51:37 - and the part of the code that creates
51:39 - this web server
51:41 - and this instance and it exports
51:43 - resulting ip address and host name we're
51:46 - going to
51:47 - modify this a bit
51:49 - well first of all we're going to make a
51:51 - new there's going to be a new ip and
51:53 - host name for each aws availability zone
51:56 - so let's store those in in an array or a
51:59 - list so ips
52:01 - equals and then we're just making an
52:02 - empty list that we're going to be
52:04 - filling
52:05 - host names
52:07 - equals
52:08 - and then we're going to put this into
52:12 - a for loop because we're going to
52:14 - make an instance for each element for
52:17 - each availability zone so for a z and
52:20 - aws dot get
52:23 - of the availability zone we can get
52:25 - right here
52:27 - z
52:30 - dot names
52:32 - so for each availability zone
52:35 - now what i'm going to do
52:39 - i'm going to put this into the for loop
52:42 - and then we'll just do some minor
52:43 - updates
52:44 - so this will be different for each
52:46 - availability zone
52:48 - so for where it says web server i'm
52:50 - going to use the python f string
52:52 - to put a variable in here
52:57 - dash
52:59 - a z
53:01 - which is the availability zone
53:03 - and then for the
53:05 - well we'll add what the availability
53:07 - zone is so i'll put
53:10 - availability zone
53:13 - and it's just going to be a z
53:15 - and now we are going to make it so
53:19 - each
53:20 - and now we're going to make it so it
53:21 - says hello world we're going to make it
53:22 - so this is different the index.html
53:25 - files can be different for each
53:26 - availability zone so for that to work
53:30 - let me just add a few characters here
53:36 - and then we'll just do dot format
53:40 - okay so now it's going to fill in the
53:41 - availability zone uh for in this spot
53:44 - here in the index.html file and we'll go
53:47 - down here and the ip is going to be ips
53:50 - and then we'll use that
53:53 - variable and actually we didn't fill
53:54 - that variable yet so we still have to do
53:56 - that so host names
54:00 - host names
54:03 - and then right here still in the for
54:05 - loop
54:06 - ips.append
54:10 - server dot public
54:12 - ip
54:14 - and then host names
54:18 - append
54:21 - server dot public
54:25 - dns
54:26 - okay so now we'll be exporting the list
54:28 - of ips in the list of host names so
54:30 - let's do another plug me up i'll save
54:32 - that
54:34 - and we'll do pollumi up
54:38 - okay so we're going to be deleting our
54:39 - original one and creating
54:41 - four new ones if we go up here so
54:44 - there's there's four of them for each
54:46 - availability zone and you can see them
54:48 - right here
54:50 - west 2a 2b b2c and 2d
54:53 - so i'll perform that update
55:01 - okay it looks like we have an error the
55:03 - requested instance type which is
55:05 - t2.micro is not supported in the
55:08 - availability zone but just this one so
55:10 - i'm going to copy this and we're going
55:12 - to use an if statement to make sure we
55:14 - create an instance everywhere except
55:16 - that availability zone so
55:19 - if
55:20 - not
55:22 - a z
55:25 - equals
55:27 - us west d2
55:29 - then
55:30 - we'll create the server okay just let me
55:33 - just indent all this here
55:37 - and then i'll save it
55:38 - pull me up
55:41 - i'll go yes
55:45 - okay now we have these three outputs
55:49 - so i can just try going to one in the
55:52 - web browser
55:55 - and you can see this one is in
55:57 - 2a
56:00 - let's try another one
56:08 - and this one's 2b
56:10 - so each web server is going to include
56:12 - in the response what availability zone
56:15 - it's in
56:16 - but this isn't very realistic in the
56:18 - real world you're not going to want all
56:19 - these different urls for each
56:21 - availability zone
56:23 - we're going to now add a load balancer
56:27 - the load balancer is going to be able to
56:28 - distribute the load evenly we'll just
56:30 - have a single url that we can go to and
56:33 - the load balancer will automatically
56:34 - determine which server or which
56:37 - availability zone to get the data from
56:40 - this is the way you can handle a lot of
56:42 - people going to a website at once and
56:44 - the website can be loaded from different
56:46 - places depending on where the load is
56:49 - the lowest so it can kind of balance the
56:51 - load across all the servers
56:53 - okay back over to our code we need to
56:56 - add an egress rule to our security group
56:59 - whenever you add a listener to your load
57:00 - balancer or update the health check port
57:03 - for a target group used by the load
57:04 - balancer to route requests you must
57:06 - verify that the security groups
57:08 - associated with the load balancer allow
57:10 - traffic to the new port in both
57:12 - directions
57:14 - so to do that
57:16 - i'm just going to paste in the egress
57:18 - here
57:19 - this is required to ensure the security
57:21 - group ingress rules don't conflict with
57:23 - the load balancers
57:25 - so now we'll define the alb let me go
57:28 - right after this
57:29 - security group definition
57:32 - i'm going to add the load balancer
57:33 - creation steps someone just paste in
57:36 - some code here and i'll go over it
57:38 - so we already have we already got the
57:40 - vpc up here
57:43 - but we also need the vpc subnets
57:48 - and then we're going to create
57:50 - the load balancer like this
57:53 - we're gonna it's internal equals false
57:55 - so it can be accessed by the public
57:57 - we're going to use the same the group id
57:59 - for the same security groups
58:01 - and then the subnets we get right up
58:03 - here
58:05 - and then
58:06 - we're creating a target group here
58:14 - and then a listener
58:20 - so we've defined the alb it's target
58:23 - group and some listeners but we haven't
58:25 - actually added the ec2 instance to the
58:28 - alb
58:29 - so this is how we're going to add the
58:31 - instance let's go down to our creation
58:34 - of the
58:34 - ec2 the ec2 creation
58:38 - was update this
58:40 - to the security groups
58:46 - and then we'll attach the instances
58:49 - so we'll do attachment
58:55 - equals aws.lb dot
58:59 - target group attachment
59:02 - and then this f string here
59:08 - target group are in is going to be the
59:10 - target group
59:13 - dot arn
59:15 - and the target
59:20 - id
59:21 - is going to be the server dot
59:23 - private
59:27 - ip
59:28 - and then it's going to be on port 80.
59:34 - okay we just want to export one more
59:36 - thing
59:38 - the
59:40 - url
59:41 - and this is going to be the main url
59:43 - we're going to be using
59:44 - which it has the load balancer
59:50 - okay this is all the infrastructure we
59:52 - need for our load balanced web server
59:55 - so i'll just save that and we'll apply
59:57 - it with polumi
59:58 - up
60:02 - and i'll perform the update
60:06 - okay here is the load balancer url if i
60:09 - just copy this
60:12 - and i'm going to do a curl to it
60:15 - now watch i'm just going to keep doing
60:16 - it a few times and every time i do this
60:19 - curl you can see that a different url is
60:23 - loaded because c says
60:24 - us west 2a 2c 2b 2b 2a so the load
60:29 - balancer is working i have one url
60:32 - but each time i go to the url it's being
60:34 - loaded from a different server because
60:36 - the load is being distributed
60:39 - so
60:40 - that works that's how you create a load
60:43 - balancer
60:45 - with infrastructure as code since we're
60:47 - done with that i'm now going to destroy
60:50 - everything since this is just a test i
60:52 - don't want
60:53 - these web servers still going on aws so
60:56 - to destroy everything i'll just do
60:58 - paloomy
60:59 - destroy
61:04 - and then i have to see do i want to
61:05 - delete all this stuff
61:07 - yes i do
61:15 - okay just like it says here we can
61:18 - also run this command plume stack remove
61:20 - dev
61:22 - to remove the stack completely
61:33 - in this final lab we'll use pollumi to
61:35 - deploy a docker image to ecs with
61:39 - fargate
61:40 - so let's start from the beginning again
61:42 - to make more practice
61:44 - so let me go out of this directory
61:48 - and i'm going to create a new directory
61:54 - and then i'll just change into it
62:00 - and i will initialize
62:02 - the project
62:04 - okay we'll do pollumi new aws
62:07 - python
62:11 - and then i'll just fill this in or just
62:13 - hit enter to use the default
62:18 - so just like before it's creating all
62:19 - the files we need it's initializing a
62:21 - new stack named dev which is an instance
62:23 - of our project
62:25 - and it's installing the needed package
62:26 - dependencies from pi pi
62:29 - let's open up this in vs code
62:35 - okay here's the project in nvs code the
62:37 - same files from before we have the
62:38 - main.pi
62:40 - which is going to be our main file where
62:43 - we put all the python code like before
62:46 - and you can see down in the terminal
62:48 - we're in our virtual environment
62:51 - and let's configure the aws region now
62:53 - it did do that when we were setting
62:55 - things up but just to make sure we have
62:57 - the right region pollumi config
63:00 - set
63:01 - aws
63:03 - region
63:04 - us west
63:07 - 2
63:09 - and then we'll go back up to our code
63:11 - and i'm actually just going to delete a
63:12 - lot of this because we're going to start
63:14 - from scratch we're going to start by
63:17 - creating creating an ecs cluster so we
63:21 - imported pollumi now let's import
63:23 - plumy
63:25 - aws
63:27 - as aws
63:29 - and now we'll create a new cluster
63:32 - we can use the default values so it's
63:34 - going to be pretty concise so cluster
63:37 - equals
63:38 - aws.ecs that cluster
63:43 - cluster
63:46 - now we're going to create a load balance
63:47 - container service so we're going to
63:49 - allocate the application load balancer
63:52 - or the alb
63:53 - and listen for http traffic port 80. in
63:56 - order to do this we'll need to find the
63:58 - default vpc and the subset groups for it
64:04 - okay i'll just paste in some code here
64:07 - and i'll just look through it i'm going
64:08 - to go through it pretty quick a lot of
64:11 - it's similar to the last lab we did
64:14 - so we create the vpc and the vpc subnets
64:17 - we got the security group here
64:22 - there's the egress
64:23 - and then we got the load balancer
64:28 - and the target group
64:32 - and the listener
64:34 - so i'll save that and run plummy up
64:42 - and then i'll make the update
64:47 - so we've fleshed out our infrastructure
64:50 - and added a load balancer that we can
64:52 - add infrastructure to
64:55 - in the next step we'll run a container
64:58 - aws fargate is a service that enables a
65:01 - user to run containers on amazon's cloud
65:04 - computing platform without the need to
65:06 - manage the underlying infrastructure
65:10 - in order to create a fargate service
65:13 - we'll need to add an iam role and a task
65:16 - definition and service
65:17 - the ecs cluster will run the nginx image
65:21 - from the docker hub
65:22 - so we're not actually going to create
65:24 - our own docker image for this example
65:27 - we're just getting the image right from
65:29 - docker hub
65:30 - so first we'll need to add an import at
65:32 - the top of our file go to the top and
65:34 - put import
65:35 - json
65:38 - now at the bottom i'm going to paste in
65:40 - some more code here again it's all in
65:42 - the description if you want to get the
65:44 - code
65:45 - so here we define our iam role and
65:48 - attach a policy
65:51 - so this section right here we're
65:52 - defining the role here
65:55 - and then we're going to attach this
65:57 - policy
66:03 - then we define a task definition for our
66:07 - ecs service
66:12 - you can see the image is the nginx image
66:18 - and then here is the service
66:29 - and then at the very end we export the
66:32 - url
66:34 - we get from here the alb
66:36 - the dns name
66:39 - so let's provision the cluster and
66:41 - service
66:43 - we'll i'll save
66:44 - and then do pollumi
66:46 - up
66:50 - this is going to output the status and
66:52 - resulting load balancer url
66:58 - perform the update
67:01 - so if i pull this up
67:03 - we can see the status and the resulting
67:06 - load balancer url
67:09 - i'm going to copy this url and we're
67:11 - actually going to try going to it in the
67:12 - web browser
67:14 - so if i load this it says service
67:16 - temporary on the temporarily unavailable
67:18 - but let's see if i refresh it a few
67:20 - times
67:22 - okay keep refreshing it eventually says
67:24 - welcome to nginx
67:27 - we got the web server
67:30 - says if you see this place the nginx web
67:32 - server is successfully installed and
67:33 - working
67:36 - we can also go to the terminal and do
67:38 - this curl plume stack output url so it's
67:41 - just going to actually just curl that
67:43 - url
67:45 - and you can see we have the same html
67:48 - that we saw in our web browser
67:51 - that the nginx web server successfully
67:54 - installed
67:57 - so now let's update the service
68:02 - we're going to change the desired count
68:04 - from 1
68:06 - to 3.
68:10 - so now we are making three containers
68:15 - save that
68:16 - and then i'll do pull me up
68:22 - and then i'll say i want to update
68:27 - i'm over on the aws console and if i go
68:31 - to the ecs clusters page and i make sure
68:34 - i have the right region in here the one
68:36 - that i set up
68:37 - for my on polumi we can see the cluster
68:41 - that i created we have one service it's
68:43 - running two tasks
68:46 - so desired test three and it's running
68:48 - two
68:53 - so we can see the desired count up here
68:56 - is three
68:57 - just like we set up in pollumi
69:01 - okay we're actually done with this so
69:03 - we're going to destroy everything
69:06 - pollumi destroy
69:11 - and yes
69:16 - okay then we'll remove the stack
69:17 - completely with pollumi
69:20 - remove dev
69:28 - okay we're done with the third lab
69:30 - thanks for watching i hope this spurred
69:32 - your interest to start trying to use
69:34 - some infrastructurized code on some of
69:36 - your own projects