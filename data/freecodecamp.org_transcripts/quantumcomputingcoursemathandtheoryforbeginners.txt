00:00 - Quantum Computing leverages the
00:02 - principles of quantum mechanics to
00:05 - process information at incredible speeds
00:08 - this course provides a solid foundation
00:09 - in Quantum Computing from the ground up
00:12 - taking you from the basics to a thorough
00:15 - understanding of how popular Quantum
00:17 - algorithms work the first section covers
00:20 - all the essential mathematics and the
00:22 - second section is a deeper exploration
00:25 - into the mechanics of quantum computers
00:27 - you'll learn why quantum computers are
00:29 - so powerful and how they're poised to
00:31 - transform technology Michael from
00:34 - Quantum sore created this course if you
00:37 - were to search up on Google M quantum
00:39 - computers you would get answers in the
00:41 - form of analogies like quantum computers
00:44 - use Q bits that are both zero and one at
00:47 - the same time when I first started
00:49 - learning about quantum computers these
00:51 - analogies and explanations never made
00:54 - sense this course was created in order
00:56 - to provide a solid foundation on Quantum
00:59 - computation
01:00 - without using analogies but teaching how
01:03 - quantum computers actually
01:06 - work let's quickly look at the structure
01:09 - of this course the first section of this
01:12 - course goes through the basic
01:14 - mathematics needed to understand the
01:16 - rest of the course including an
01:18 - introduction to complex numbers and
01:20 - basic linear algebra in the next section
01:24 - we'll explore what a cupid is and how we
01:26 - can represent them mathematically we
01:29 - also explore some single qbit operations
01:31 - and discuss some of their properties the
01:34 - third section introduces how we can
01:36 - represent multiple cuq bits
01:38 - mathematically and explor some
01:40 - operations we can perform on multiple
01:42 - cuq bits this section ends on exploring
01:45 - the strange Quantum phenomena of quantum
01:47 - entanglement and phase Kickback in the
01:50 - final section of this course we use
01:52 - everything we have studied up until this
01:54 - point to analyze Quantum algorithms this
01:57 - section showcases why quantum computers
02:00 - as such revolutionary
02:03 - technology let's start with
02:05 - understanding imaginary and complex
02:06 - numbers but before that we need to
02:09 - consider the square roots of numbers
02:11 - let's say we have the equation x^2 is
02:13 - equal to 4 which means X is equal to
02:16 - Plus or - 2 easy but what if x^2 is
02:19 - equal to -4 since a number squared is
02:22 - always greater than zero how can X2 ever
02:25 - be a negative number this is where
02:27 - imaginary numbers come in if we let I be
02:30 - the < TK of1 we can then write the < TK
02:33 - of-4 as plus orus 2
02:41 - I this is an imaginary number any number
02:44 - that contains a factor of theare < TK
02:46 - of1 or
02:49 - I now we move one level up to complex
02:52 - numbers all a complex number is is a
02:54 - number that contains a real number plus
02:56 - an imaginary number a standard complex
02:59 - number looks like this a plus I B where
03:02 - both A and B are real numbers a being
03:05 - the real part of the number and B being
03:07 - the imaginary part of the
03:13 - number complex numbers may not seem very
03:16 - useful but in the next lesson we will
03:18 - see how we can represent complex numbers
03:20 - in another form which is used to model
03:22 - Quantum Computing
03:25 - States we can add and subtract complex
03:27 - numbers pretty easily all we do is add
03:30 - or subtract the real parts and the
03:32 - imaginary
03:33 - Parts pause the video and try adding up
03:36 - these complex
03:45 - numbers multiplication is pretty simple
03:47 - as
03:57 - well but we must remember the before we
04:00 - get i s that becomes -1 since I is the
04:03 - square root
04:09 - of1 the complex conjugate of a complex
04:12 - number is when you take the complex
04:13 - number and flip the sign or negate the
04:15 - imaginary part this is denoted by an
04:18 - asteris here are some
04:22 - examples one cool property of complex
04:25 - numbers is if we multiply any complex
04:27 - number by its complex conjugate the
04:29 - result is always a real number try
04:32 - multiplying 2 + 3 I with 2 - 3 I and
04:35 - confirming this is the
04:42 - case we can think of a complex number as
04:45 - a vector where we have the real axis on
04:47 - the horizontal and the imaginary axis on
04:49 - the vertical this allows us to graph our
04:52 - complex numbers for example the complex
04:55 - number -2 + 3 I would be a vector that
04:58 - would end at the point -2
05:01 - 3 when we represent a complex number on
05:04 - the number plane like this we also
05:06 - uncover another property its magnitude
05:09 - which is its distance from the origin
05:12 - this is denoted with vertical lines and
05:14 - is calculated by using Pythagoras's
05:22 - Theorem so we get that the magnitude of
05:25 - some arbitrary complex number A plus I
05:28 - is equal to the square root of a^ 2 + b^
05:31 - 2 pause the video and see if you can
05:34 - find the magnitude of 4 - 3
05:40 - I this is not the only way of
05:43 - representing complex numbers instead of
05:45 - using real and imaginary Parts as
05:47 - coordinates we can represent them
05:49 - through their magnitude and the angle
05:51 - they make with the Positive xais using
05:54 - trigonometry we find that we can also
05:56 - represent complex numbers in the form r
05:59 - cos theta plus I sin Theta where I is
06:02 - the magnitude of the complex number and
06:05 - Theta is the angle it makes with the
06:06 - Positive X AIS we can find Theta by
06:10 - using the tan function as tan of theta
06:12 - is equal to b a so Theta is arctan of B
06:16 - of A this is called Polar form there is
06:20 - also one other form which is r e to the
06:23 - power of I Theta this form is
06:26 - exponential
06:27 - form pause the video now and try to
06:29 - convert the complex number 1 + I into
06:33 - Polar form then into exponential
06:39 - form in Quantum Computing we almost
06:42 - exclusively use complex numbers in
06:44 - exponential form this is because of the
06:46 - property that when we change Theta we
06:48 - rotate around a
06:56 - circle so multiplying two complex
06:59 - numbers in exponential form whose
07:01 - magnitude is one graphically we are
07:03 - rotating around a unit circle as the
07:06 - angles of the two complex numbers add
07:08 - together you will see once we start
07:10 - studying Quantum Computing that this
07:13 - property is very useful in representing
07:15 - Quantum
07:19 - States a matrix is a 2d arrangement of
07:22 - numbers in the next lesson we will get
07:25 - to the applications of matrices and how
07:27 - they relate to Quantum Computing but in
07:29 - this this lesson we will quickly Define
07:30 - some properties and operations we can do
07:33 - on them we say we have an M byn Matrix
07:36 - if the number of rows is M and the
07:38 - number of columns is n so this Matrix
07:40 - here would be a 2x3
07:44 - Matrix pause the video and see if you
07:47 - can find out the dimensions of these
07:52 - matrices if we want to add two matrices
07:55 - together all we need to do is add each
07:57 - element of the matrices
08:04 - this is the same for subtraction note
08:07 - that we can only add and subtract
08:08 - matrices if the number of rows and
08:10 - columns is the same for both so we
08:13 - wouldn't be able to add these two
08:14 - matrices pause the video and see if you
08:17 - can add these
08:21 - matrices we can also multiply matrices
08:24 - by a scalar if we do each element in the
08:27 - Matrix gets multiplied by the scaler
08:29 - giving us another
08:36 - Matrix when multiplying matrices we have
08:39 - to do this weird operation where to get
08:41 - the element in the First Column and
08:43 - first row we take a sort of dot product
08:45 - with the first row of the left Matrix
08:48 - and the First Column of the right
08:55 - Matrix then to get the second column
08:58 - first row we take the dotproduct of the
09:01 - first row of the left Matrix and the
09:03 - second column of the right
09:10 - Matrix we continue this process until we
09:13 - have all the elements in the new
09:21 - Matrix pause the video and try to
09:23 - complete this matrix multiplication
09:44 - it's important to note that we can only
09:46 - multiply two matrices together if the
09:48 - number of columns of the first Matrix is
09:51 - the same as the number of rows in the
09:52 - second Matrix for example we can't
09:55 - multiply these two mates here since the
09:58 - first one has two columns but the second
09:59 - one has three
10:05 - rows if we have a n by one Matrix we
10:08 - call it a column
10:12 - Vector we can graph these like any other
10:15 - Vector these are useful as one of the
10:18 - ways we can represent a state of a
10:20 - Quantum computation is through a column
10:23 - Vector it turns out that when we
10:25 - multiply a matrix with a column Vector
10:27 - we get another column vector
10:30 - intuitively what is happening is the
10:32 - column Vector is getting transformed by
10:34 - The Matrix so we can use matrices as
10:37 - Transformations on a vector here are
10:40 - some examples
10:50 - graphically as you will see in the
10:52 - quantum Computing sections we do the
10:54 - same process of applying matrices to our
10:56 - Quantum state to apply operations on qu
11:00 - computers we also have a special Matrix
11:03 - called an identity Matrix this Matrix is
11:06 - all zeros except for the main diagonal
11:08 - that has all ones if we multiply the
11:11 - identity matrix by any Matrix we get
11:14 - back the original
11:16 - Matrix verify this is true by
11:18 - multiplying the two-dimensional identity
11:20 - Matrix with this Matrix and check to
11:23 - make sure you get back the original
11:27 - Matrix matrices also have what's called
11:30 - an inverse that when multiplied with the
11:32 - original Matrix gives us the identity
11:34 - Matrix we denote this with a ne1
11:38 - graphically this means that if we have a
11:40 - matrix a and we apply it to a column
11:42 - Vector 1 one if we then apply the
11:45 - inverse of a we lend back on the point 1
11:49 - one therefore applying a than a inverse
11:53 - is the same as applying the identity
11:55 - Matrix which means the column Vector
11:57 - stays in the same spot
12:05 - as we saw previously with complex
12:06 - numbers we can also take the complex
12:09 - conjugate of a matrix this is denoted by
12:12 - the asteris on the top right of the
12:14 - Matrix just like with complex numbers
12:17 - when we apply this we flip the sign of
12:19 - all the imaginary components of all the
12:21 - elements in The Matrix pause the video
12:24 - and find the complex conjugate of this
12:26 - Matrix
12:37 - we can also do what we call the
12:38 - transpose of a matrix this is denoted by
12:41 - the T and involves exchanging its rows
12:43 - with its
12:53 - columns if we combine these two and find
12:55 - the complex conjugate and transpose of a
12:58 - matrix a we get something called a
13:00 - dagger denoted by the dagger symbol what
13:03 - was the point of all this in Quantum
13:05 - Computing we use two types of matrices
13:07 - to apply our operations one of them is
13:10 - unitary matrices these have the property
13:13 - that given a unitary Matrix u u * U
13:17 - dagger is equal to the identity Matrix
13:20 - so U dagger is its
13:22 - inverse geometrically when a unitary
13:25 - Matrix acts on a vector the length of
13:27 - the vector stays the same but it is
13:29 - rotated or flipped this property may not
13:32 - seem very useful but once we start
13:34 - talking about probabilities in quantum
13:36 - computers it will all start to make
13:39 - sense the other type of Matrix we use to
13:42 - apply operations in Quantum Computing is
13:44 - the Homan Matrix these matricies have
13:47 - the property that given a Homan Matrix H
13:50 - H is equal to H dagger as you go through
13:53 - the quantum Computing sections of this
13:55 - course you will start to understand why
13:57 - we use these types of matricies to
13:59 - perform operations on quantum
14:07 - computers sometimes when we apply a
14:09 - transformation to a vector the vector
14:12 - stays in the same direction but just
14:14 - gets stretched or compressed meaning
14:16 - that we can factor out a scalar and get
14:18 - back that same
14:20 - Vector when this happens we call the
14:22 - vector an igen Vector of the
14:24 - transformation matrix that we applied
14:26 - and the Scala we factored out an igen
14:30 - value let's go through an example if we
14:33 - have the Matrix
14:35 - 20112 with the vector 03 applying the
14:39 - Matrix on the vector gives us the vector
14:42 - 06 with this we can Factor at a two
14:45 - leaving us with two times the vector
14:48 - 03 this gives us an igen value of two
14:51 - with the igen vector 03 for that Matrix
15:00 - classical computers use binary zeros and
15:03 - ones to store and process their data
15:06 - quantum computers on the other hand use
15:08 - Q bits or Quantum bits which can be zero
15:10 - and one at the same time we have all
15:13 - heard this explanation of quantum
15:14 - computers but what does that actually
15:16 - mean in order to understand what a
15:19 - quantum computer is actually doing we
15:21 - must look at how we represent them
15:24 - mathematically instead of using binary
15:26 - like classical computers quantum
15:28 - computers use cubits physically a cubit
15:32 - can be any Quantum particle that exists
15:34 - in two distinct states such as a photon
15:37 - of light being polarized either
15:38 - horizontally or vertically just like
15:41 - classical computers we still use zeros
15:43 - and ones but in Quantum computation we
15:46 - Define them instead as the column
15:48 - vectors 1 0 and 01 respectively the
15:52 - weird brackets around 0 and one is
15:55 - direct notation we will look more into
15:57 - it later you may have heard of the term
16:00 - superposition what it means in quantum
16:02 - mechanics is that a Quantum particle is
16:05 - in two states at the same time so back
16:08 - to our Photon polarization example this
16:11 - means that the photon is both
16:12 - horizontally and vertically polarized at
16:15 - the same
16:16 - time in terms of quantum Computing we
16:19 - say a cuit is in superp position if it
16:21 - is both zero and one at the same time
16:24 - let's look at how we represent cubits
16:26 - mathematically
16:29 - mathematically we can represent a qit as
16:32 - a column Vector with two elements the
16:35 - top element indicates how much the qbit
16:37 - is in the zero State and the bottom
16:39 - element indicates how much the cuit is
16:41 - in the one state the convention for a
16:43 - Quantum state is to set it equal to the
16:45 - Greek letter s we'll talk more about
16:47 - this in the next video so if we have a
16:50 - cubit in the state 1 Z it now makes
16:52 - sense why this is zero since it is all
16:55 - in the zero State and none in the one we
16:57 - can say the same for Q bit in the state
17:00 - 01 being one if a qbit is in both the
17:04 - zero and one state so it has nonzero
17:06 - numbers in The Matrix then we say it is
17:09 - in a superposition of 0 and one since it
17:11 - is both of the states at the same time
17:14 - so now we know how to represent a cubit
17:16 - mathematically but how do we measure the
17:18 - cubits for that we must look at another
17:21 - rule of quantum mechanics when we
17:23 - measure a Quantum system it changes the
17:25 - state of the system to the measurement
17:28 - what does that mean
17:29 - if we go back to our Photon polarization
17:32 - example if the photon is in a
17:34 - superposition of both horizontally and
17:36 - vertically polarized then when we
17:38 - measure it we will only measure it as
17:40 - one or the other but not both and once
17:42 - it has been measured it collapses into
17:45 - the state we measured so if it was in a
17:48 - super position and we measure it to be
17:50 - horizontally polarized it would collapse
17:52 - and become horizontally polarized
17:54 - meaning it is not in a super position
17:57 - anymore the same thing happens when we
17:59 - measure Q bits we can only measure a
18:02 - zero or one we do not measure how much
18:05 - the QQ bit is in the zero state or how
18:07 - much the cuq bit is in the one
18:09 - state immediately after measuring a cuq
18:12 - bit its state changes to either zero or
18:15 - one depending on the
18:16 - measurement so what is the point in
18:19 - those numbers telling us how much the
18:20 - cuq bit is in the zero State or the one
18:24 - state what those numbers tell us is the
18:27 - probability of measuring a 0 or
18:30 - 1 the probability of measuring zero is
18:33 - the magnitude squar of the amplitude of
18:36 - the zero State and the probability of
18:39 - measuring one is the magnitude squ of
18:41 - the amplitude of the one
18:44 - state so for this example Cubit when we
18:48 - measure it we have a 75% chance of
18:50 - measuring a zero and a 25% chance of
18:53 - measuring a
18:55 - one if we now think about how we defined
18:58 - the Z and one state at the start of the
19:00 - lesson they should now start to make
19:03 - sense we stated that Zer was the column
19:06 - Vector 1 0 and now we can see why the
19:09 - probability of measuring Z is 1 so will
19:12 - always be measured as zero this is the
19:15 - same for the one state since there are
19:18 - only two possible outcomes when
19:20 - measuring a q bit the probability of
19:22 - measuring a zero plus the probability of
19:24 - measuring a one must equal one giving us
19:28 - this equation
19:29 - so this would be a valid Cubit State
19:31 - since the probabilities add up to one
19:34 - but this would not be since the
19:35 - probabilities add up to more than one
19:39 - when we do measure a qbit that is in
19:41 - superp position it collapses into the
19:43 - measured state so if we measure this
19:45 - state to be zero it collapses into the
19:48 - zero state so every measurement after
19:51 - will be zero this is because of the laws
19:54 - of quantum mechanics when we measure
19:56 - something it permanently changes the
19:58 - state of the system to that
20:09 - measurement normally when we are
20:11 - mathematically representing a Quantum
20:13 - state of a quantum computer instead of
20:16 - using matrices we use a specific
20:18 - notation called direct notation to see
20:21 - how this works let's convert an
20:23 - arbitrary Cubit State Alpha Beta into
20:26 - direct notation all we need to to do is
20:29 - turn the Matrix into the sum of two
20:31 - matrices and then factor out the Alpha
20:34 - and the
20:35 - beta now if you look at the column
20:38 - vectors they are the zero and one States
20:40 - as we saw in the previous lesson this
20:43 - gives us a linear combination of the
20:45 - zero and one
20:47 - States those brackets around the 01 and
20:50 - S are called KS all they tell us is that
20:54 - 0 1 and S are quantum States
20:59 - pause the video and convert this Cubit
21:02 - state from Matrix to direct
21:09 - notation this notation might seem weird
21:11 - at first but it is the conventional way
21:14 - of writing a Quantum Computing State
21:17 - since when we start adding more Q bits
21:19 - using matrices to represent them becomes
21:21 - unmanageable as we start to get very
21:23 - large matrices
21:31 - we can represent a cuit graphically on
21:34 - what is called a block sphere on the top
21:37 - we have the zero State and on the bottom
21:40 - we have the one state on the horizontal
21:43 - we have the plus State minus State I
21:46 - State and negative I State we will
21:49 - discuss these in later lessons the
21:51 - closer up the cuit is to the zero State
21:54 - the higher probability of measuring a
21:56 - zero and the same goes for the one
22:00 - state that means that if we have the
22:03 - state 1 on < tk2 1 on < tk2 it will lie
22:07 - halfway between the North and South
22:09 - Poles since it has an even chance of
22:11 - being measured as Zer or
22:14 - one you may notice that since it is a
22:17 - sphere the cubic can spin around the
22:19 - sphere this is called phase we will talk
22:23 - about this in later
22:24 - lessons right now it is important to
22:27 - understand the basic idea that the
22:29 - higher up the qbit is the more likely we
22:32 - are to measure a zero and the lower the
22:34 - qbit the more likely we are to measure a
22:37 - one pause the video and think about
22:40 - where the state 1 on 2 < tk3 on2 will be
22:44 - on the Block
22:48 - sphere the cuit 1 on2 < tk3 on2 would be
22:53 - halfway between the Equator and the one
22:55 - state since it has a one on4 chance of
22:58 - being measured as a zero and a 3 on four
23:01 - chance of being measured as a
23:09 - one with classical computers we use
23:12 - logic gates to process data with quantum
23:16 - computers we still use gates to change
23:19 - the states of our cubits but they are a
23:21 - little bit different to your usual logic
23:24 - gates the most common single Cubit gates
23:27 - are the X Y and Zed Gates let's first
23:31 - look at the X gate if we have a Q bit in
23:34 - the zero State and apply the X gate to
23:37 - it it flips to the one state let's try a
23:40 - q bit that is halfway between 0 and
23:43 - one try and see if you can figure out
23:46 - what the xgate is doing let's try a q
23:50 - bit in this
23:51 - state as you can see the xgate flips the
23:55 - Cubit 180° or Pi radians around around
23:58 - the
23:59 - x-axis now let's have a look at the Y
24:01 - gate here are some examples of the Y
24:04 - gate
24:08 - transformation as you can see it does
24:10 - the same thing as the xgate but instead
24:13 - it rotates the Cubit State 180° or Pi
24:17 - radians around the Y
24:20 - AIS lastly we have the Z gate which
24:23 - rotates the cubeit
24:25 - 180° or Pi radians around the Z
24:30 - axis since these Gates rotate the cuit
24:34 - around the specified axis by pi radians
24:37 - if we apply the same gate twice one
24:39 - after the other then the Cubit returns
24:42 - to its original position this means that
24:45 - these three gates are their own
24:48 - inverses we can represent these Gates as
24:51 - matrices here are the matrices for these
24:53 - gates for the moment ignore the complex
24:56 - numbers in the Y gate mat mat we will
24:59 - explain this later in the next lesson
25:01 - when we talk about phase mathematically
25:04 - to apply a gate to a cubit we can
25:07 - multiply The Matrix that represents the
25:09 - gate with the column Vector of the
25:13 - Cubit pause the video and prove that
25:16 - applying the X gate to the zero State
25:19 - gives us the one
25:25 - state in direct notation if we we want
25:28 - to apply a Quantum gate we still use the
25:31 - matrices but instead of using matrix
25:34 - multiplication we look at The Columns of
25:36 - the
25:38 - Matrix the First Column of the Matrix
25:41 - indicates the column Vector the zero
25:43 - state becomes after applying the gate
25:45 - and the second column indicates the
25:47 - column Vector the one state becomes then
25:50 - we can factor out both our zero and one
25:53 - States again to get back into direct
25:56 - notation also since Quantum gates are
25:59 - linear if we apply an arbitrary gate U
26:03 - that gate acts on each of the
26:05 - superposition States
26:08 - individually let's look at an example of
26:11 - applying a gate in direct
26:13 - notation if we want to apply a y gate to
26:16 - this state in direct notation the Y gets
26:19 - distributed into the
26:21 - state then the Y changes the zero state
26:24 - to the First Column of the Matrix and
26:26 - the one state to the second column of
26:28 - the
26:31 - Matrix then we can factor out the I and
26:34 - the negative I the column vectors once
26:36 - again become the zero and one States
26:39 - leaving us with this
26:42 - state with this pause the video and
26:45 - prove that applying a zed gate to a cuit
26:48 - in the state Alpha 0 plus beta 1 gives
26:51 - us the state Alpha 0 minus beta 1
27:04 - looking at this you may be thinking what
27:07 - is the point of the Zed gate this Q bit
27:10 - still has an alpha squar chance of being
27:12 - zero and a beta Square chance of being
27:14 - one it didn't affect their
27:17 - probabilities in the next lesson we will
27:20 - finally bring complex numbers into
27:22 - Quantum Computing with an introduction
27:24 - to phase
27:32 - on the Block sphere we saw in the
27:34 - previous lessons that we could also
27:36 - rotate around the Zed AIS this is called
27:40 - phase it may not seem very useful as the
27:43 - probability of measuring a zero or a one
27:46 - is still the same no matter how much we
27:48 - rotate around but phase is what makes
27:51 - quantum computers as powerful as they
27:53 - are we will get into the uses of phase
27:56 - in the next lesson in this lesson we
27:58 - will see how we can represent phase
28:01 - mathematically to represent phase we
28:03 - have to bring back our old friend
28:05 - complex numbers in Quantum Computing we
28:08 - mostly use complex numbers in
28:10 - exponential form you will now see why
28:14 - but first let's consider some states in
28:16 - the block sphere let's first consider
28:19 - the states 1 or < tk2 0 plus 1 or < tk2
28:22 - 1 if we apply a zgate we get it to the
28:26 - state 1 or < tk2 0 0 - 1 < tk2
28:30 - 1 as you can see the one state was
28:33 - multiplied by a factor of -1 and the
28:37 - Cubit rotated Pi radians around the Z
28:40 - AIS if we represent the -1 as a complex
28:43 - number in exponential form we get e to
28:47 - the I Pi notice how the angle of the
28:50 - complex number is pi
28:54 - radians let's try another example let's
28:57 - plot the state 1 on < tk2 0 + 1 < tk2 1
29:01 - and 1 on < tk2 0 + I on < tk2 1 if we
29:06 - represent I as a complex number in
29:08 - exponential form we get e to the I Pi /
29:12 - 2 and if you look at the Block sphere to
29:14 - get that state we rotate Pi / 2 radians
29:17 - around the Z
29:19 - AIS we use complex numbers in
29:21 - exponential form in Quantum Computing
29:24 - since it gives us a nice mathematical
29:25 - way of rotating around a circle by
29:28 - changing the value of f by multiplying
29:31 - the one state of the Cubit with the
29:33 - complex number e to the I we rotate the
29:36 - Cubit around the Z AIS by five radians
29:40 - but why is it the one state and not the
29:42 - zero State being multiplied by the
29:44 - complex number there are two types of
29:46 - phase Global phase and relative phase
29:49 - Global phase is when the entire cuit is
29:52 - multiplied by a complex number and
29:54 - relative phase is when just the one
29:57 - state is multip IED by a complex number
29:59 - it turns out the global phase is
30:01 - physically
30:02 - irrelevant so the state e to the I * 1 <
30:06 - tk20 + 1 < tk2 1 is logically equivalent
30:10 - to the state 1 < tk2 0 + 1 < tk2 1
30:14 - relative phase on the other hand is
30:16 - extremely important and matters in our
30:18 - calculations relative phase is when the
30:21 - amplitude of the one state has a factor
30:23 - of a complex number as we saw earlier
30:26 - having relative phase rotates the Cubit
30:29 - on the Block sphere around the Z AIS but
30:32 - what if we have a complex number in both
30:34 - the amplitudes of the zero State and the
30:36 - one state what we do is we factor out
30:39 - the complex number of the zero state
30:41 - from the entire qbit creating a global
30:43 - phase and relative
30:45 - phase then we can discard the global
30:48 - phase leaving us with a qbit with a
30:50 - relative phase we saw previously on the
30:54 - Block sphere that phase does not affect
30:56 - the probability of measuring a zero or a
30:59 - one as the cupit stays the same distance
31:01 - from the zero State and the one state no
31:04 - matter how far we rotate around the
31:06 - block sphere if we look at an arbitrary
31:09 - Cubit State Alpha 0 plus e to the I5
31:12 - beta 1 the probability of measuring a
31:15 - one is the magnitude of e the5 beta
31:18 - squar we can split the absolute values
31:21 - up like this the magnitude of e to the
31:24 - II is 1 since the coefficient of the
31:27 - complex number in exponential form
31:29 - states its magnitude so the probability
31:32 - of measuring one is still the magnitude
31:34 - of beta squ in the next lesson we will
31:38 - see why relative phase
31:46 - matters before we discuss perhaps the
31:49 - most important gate in Quantum Computing
31:51 - we will quickly revisit the block sphere
31:54 - in earlier lessons we saw that on the
31:56 - equator we have four states
31:58 - the plus State minus State I State and
32:01 - negative I State now that we know about
32:04 - phase we can Define these states all
32:07 - they are a shorthand for commonly used
32:10 - States since they all lie on the equator
32:12 - of the block sphere they all have an
32:14 - even chance of being measured as zero or
32:17 - one but each one contains a different
32:20 - relative phase the plus state is the
32:23 - state 1 < tk2 0 + 1 < tk2 1 the next
32:28 - state is the minus State this is the
32:30 - same as the plus state but with a
32:32 - relative phase of
32:35 - -1 the I state has a relative phase of I
32:39 - and the negative I state has a relative
32:42 - phase of negative
32:45 - I now let's look at the hadam mod gate
32:49 - here is the Matrix for the gate if we
32:51 - look at how the gate acts on a qit on
32:54 - the Block sphere we see that the zero
32:57 - state gets trans transformed into the
32:58 - plus State and the one state gets
33:02 - transformed into the minus
33:04 - State applying a hadam mod to the plus
33:07 - State gives us the zero State and
33:10 - applying a hadam mod to the minus State
33:12 - gives us a one state this means that the
33:15 - hadam mod is its own
33:17 - inverse if we wanted to apply a hadam
33:20 - mod gate to an arbitrary Cubit state in
33:22 - direct notation we can replace the zero
33:25 - with the plus State and the one with the
33:28 - minor State and
33:33 - expand the hadamar gate shows that phase
33:36 - matters if we apply the gate to the plus
33:39 - State we get zero and to the minus State
33:42 - we get one these states only differ by a
33:45 - relative phase but after applying the
33:47 - gate they are different even though
33:50 - initially they both had a 0.5 chance of
33:53 - being measured as zero and a 0.5 chance
33:56 - of being measured as one in the fourth
33:58 - section of this course we will start to
34:00 - look at some Quantum Computing
34:03 - algorithms and you will start to see why
34:05 - the hadide gate and phase is so
34:13 - powerful now that we understand relative
34:16 - phase let's introduce two new gates the
34:20 - s and t Gates the S gate adds a relative
34:24 - phase of Pi on 2
34:26 - radians the T eate adds a relative phase
34:29 - of Pi on 4
34:31 - radians if we take the conjugate
34:33 - transpose of the two matrices of the two
34:36 - gates we get their inverses for the S
34:39 - gate we can see that applying s dagger
34:42 - adds a relative phase of negative pi on
34:45 - 2 which is the inverse of the S gate
34:49 - this means that if we apply a s gate
34:52 - then an S dagger gate we are back in the
34:54 - same spot meaning the S dagger gate is
34:57 - the inverse of the S gate we also have
35:01 - the T dagger gate which is the same
35:03 - thing as the S dagger but adds a
35:05 - relative phase of piun on 4 radians
35:08 - instead meaning it is the inverse of the
35:12 - T
35:17 - gate if we have multiple cuq bits we
35:20 - represent them through the tensor
35:22 - product for example if we had two cuq
35:26 - bits in the zero state then we would
35:28 - represent the state like this this is
35:31 - usually shortened to this where we have
35:33 - the two zeros in the one get
35:36 - Vector if we wanted to represent two
35:38 - cubits in superp position we can expand
35:41 - it out like any other operation by
35:44 - multiplying the amplitudes of the states
35:46 - and using the tensor product on the zero
35:49 - and one
35:50 - States as you can see now we have four
35:53 - states the 0 0 01 1 0 and one one States
35:59 - this makes sense since those are the
36:01 - possible combinations of zeros and ones
36:04 - we can have with two
36:05 - cubits measurement works the exact same
36:08 - as before the probability of measuring 0
36:11 - 0 is the magnitude squared of the
36:14 - coefficient of the 0 State and so
36:18 - on here is an example of combining these
36:21 - two
36:26 - cubits if we want to add another q bit
36:29 - to the system all we need to do is
36:31 - tensor it onto the end of the
36:35 - state we also have some Shand notation
36:38 - you will sometimes see if we have n Zer
36:42 - we can write it like this which means 0
36:45 - tensed with itself n times so this state
36:48 - would be shorthand for 5
36:55 - ones this represents ation of cuits is
36:59 - great but what if we wanted to apply a
37:01 - gate to a certain cuit how would we
37:04 - indicate that we wanted to let's say
37:07 - apply an xgate to the second cubit in
37:09 - this state for this we use a diagram
37:13 - called the quantum circuit here is an
37:15 - example of one on the vertical we have
37:18 - the cubits each line representing a
37:21 - singular Cubit the states on the left
37:24 - are the initial states of the cuits the
37:27 - bo boxes are the quantum Gates and the
37:29 - letters on the boxes are the type of
37:32 - gate we are applying for example this is
37:35 - an X gate these boxes are measurements
37:39 - and represent us measuring the Cubit the
37:43 - horizontal is the order in which we
37:45 - apply the gates we start from the left
37:48 - and go to the right sometimes you will
37:51 - also see size States pointing to
37:53 - different points in the circuit these
37:56 - are used to represent the state of the
37:58 - system at different points during the
38:01 - algorithm let's go through this circuit
38:04 - at S Sub 0 we have the state 0 01 then
38:09 - at SI sub one we apply an X gate to the
38:12 - second
38:14 - Cubit at SI sub 2 we apply a hadam mod
38:18 - gate to the second Q bit giving us this
38:23 - state then at S Sub 3 we apply an xgate
38:27 - to both the first Cubit and the third
38:29 - Cubit giving us this
38:31 - state then at size sub 4 we measure the
38:35 - cubits so we will get one of these
38:37 - states with these
38:45 - probabilities now let's introduce some
38:48 - gates that act on multiple cuy bits the
38:50 - most common multibit gate is the c not
38:54 - or controlled X gate here is the gate on
38:57 - a Quantum circuit the gate acts on two Q
39:00 - bits one of the Q bits is called the
39:03 - control Q bit and the other is called
39:05 - the target QQ bit the C not gate applies
39:09 - an X gate to the Target QQ bit if the
39:12 - control QQ bit is a one and does nothing
39:15 - if the control is a
39:17 - zero let's look at the C not gate acting
39:20 - on some states if we apply a c not to
39:23 - this state with the first Q bit as the
39:25 - control and the second Q bit as the
39:28 - target then we apply that c not gate to
39:31 - each of the superposition States giving
39:34 - us this
39:35 - state here is another
39:43 - example we also have the tooli gate this
39:47 - gate is very similar to the C not but
39:49 - instead it has two control cubits here
39:52 - it is on a Quantum circuit
39:58 - if we apply a tooli gate to this Cubit
40:01 - state with the second and third cuq bits
40:04 - as control and the fourth Cubit as the
40:07 - target we get this
40:10 - state it turns out that we can use senal
40:13 - gates to create controlled versions of
40:16 - single qbit Gates so we also have
40:19 - controlled y z s t and hadamard Gates
40:24 - they act the same as the C not flying
40:27 - the gate if the control is one and does
40:30 - nothing if the control is
40:32 - zero we represent these on a Quantum
40:35 - circuit like this with the regular gate
40:38 - box but with a line going out to the
40:40 - control CU bit for example here is the
40:44 - controlled es gate on a Quantum circuit
40:47 - where the second qbit is the control and
40:49 - the first is the target
40:57 - now that we have multiple cuq bits how
40:59 - do we measure a single cuq bit let's say
41:03 - we have two cuq bits in this state and
41:05 - we wanted to find the probability of
41:07 - measuring the second Cubit as a one we
41:11 - do this by looking at all the
41:13 - superposition states where the second CU
41:16 - bit is one then summing up the
41:18 - probabilities of measuring those
41:25 - States Let's do an example
41:27 - if we wanted to find the probability of
41:30 - measuring a zero in the first CU bit
41:33 - then we sum the probabilities of
41:34 - measuring each of the states where the
41:37 - first Q bit is a
41:39 - zero but how do we know what the state
41:42 - collapses to once we measure a qbit
41:46 - remember once we measure a qbit it
41:48 - collapses its superp position and
41:50 - becomes the measurement let's look at an
41:54 - example say we have this state and we
41:56 - measured me the first cuit to be a one
42:00 - then the state collapses and since the
42:02 - first cuit becomes a one we get rid of
42:05 - all the superposition states where the
42:07 - first Cubit is not a
42:10 - one remember the probabilities must add
42:13 - up to one but we have just removed some
42:17 - states so the probabilities will be less
42:20 - than one we fix this by multiplying the
42:23 - state by what we call a normalization
42:25 - constant let's call it a now we can
42:28 - normalize the state by using the
42:30 - identity that the probabilities must add
42:33 - up to one this gives us values for a so
42:37 - if we measure the first CU bit to be one
42:40 - the state collapses to this state we can
42:43 - use these techniques with any number of
42:46 - cubits let's go through an example with
42:49 - three cubits let's say we have this
42:52 - state and we measure the middle Cubit to
42:54 - be zero the state collapses like this
42:58 - collapsing into this
43:08 - state let's consider this Quantum
43:11 - circuit at SI Sub 0 we have the state 0
43:15 - 0 then at S Sub 1 we have the state 1 on
43:19 - < TK to 0 plus 1 0 Let's distribute the
43:24 - zero State into the equation giving us
43:26 - the state 1 < tk2 0 0 + 1
43:31 - 0 now at size sub 2 we apply a cot with
43:35 - the first qbit being the control and the
43:38 - second being the target this means that
43:41 - the 0 0 state stays the same since the
43:44 - control is zero but for the one zero
43:47 - State the control is one so the second Q
43:50 - bit flips to a
43:52 - one this leaves us with the state 1 on <
43:56 - tk2 0 0 + 1 1 can you notice anything
44:00 - weird about this state if we were to
44:04 - measure one of the cubits as a zero the
44:07 - other would collapse into a zero and if
44:10 - we were to measure a one the other would
44:12 - collapse to a
44:15 - one so without even looking at both the
44:18 - cubits by measuring one of them we
44:21 - immediately know the state of the other
44:23 - Cubit this is called entanglement
44:27 - there are many different entangled
44:29 - States we say a state is entangled if it
44:32 - cannot be factored into the tensor of
44:35 - single Cubit
44:37 - States for example this state is not
44:40 - entangled since we can Factor it like
44:42 - this but this state is entangled since
44:45 - we cannot Factor it into singular Cubit
44:48 - States what this means is that when the
44:51 - cuits are entangled they depend on each
44:54 - other to determine their state
44:57 - there are two types of entangled States
45:00 - maximally entangled States and partially
45:03 - entangled States we say CU bits are
45:06 - maximally entangled if measuring one of
45:09 - the CU bits tells us the state that the
45:11 - other Q bits are in so the example
45:14 - entangled state from the beginning 1 on
45:18 - < tk2 0 0 + 1 1 is maximally
45:23 - entangled here are the common maximally
45:25 - entangled States with two
45:28 - cubits we call these states the Bell
45:30 - States and we denote them with capital
45:33 - fi and
45:36 - S we say cubits are partially entangled
45:40 - if the measurement of a cubit affects
45:42 - the probabilities or phase of the other
45:46 - cubits for example with this state if we
45:50 - measure the first cuq bit as zero the
45:52 - state collapses to this but if we
45:55 - measure the first Q bit as a one then it
45:58 - collapses to this state as you can see
46:01 - the two states have different
46:03 - probabilities of measuring Zer or one so
46:06 - this state is partially entangled since
46:09 - measuring one cubit affects the
46:11 - probabilities of the
46:20 - other another quantum property we can
46:23 - use is something called phase Kickback
46:26 - to understand and how this works let's
46:28 - consider this circuit as you can see we
46:31 - have a Q bit in the plus State and
46:33 - another q bit in the state V we also
46:36 - have an arbitrary controlled U
46:39 - operation let's say that V is an igen
46:42 - state of u so if we apply the U gate to
46:45 - the state V we get e to the I Theta V
46:49 - since all I values of quantum computers
46:52 - can be represented as e to the I
46:55 - Theta now at sub one we have the state
46:59 - plus V Let's expand the plus State and
47:02 - distribute the V State into the plus
47:04 - State at S Sub 2 we apply the controlled
47:08 - uate nothing happens to the first
47:10 - superposition State since the control is
47:13 - a zero but the second superposition
47:15 - state has the gate applied to the V
47:17 - State since the control is a
47:20 - one we can now Factor back out the V
47:23 - state from the equation can you see what
47:26 - has happened
47:27 - V is unchanged even though it was the
47:30 - Target qit and a factor of e the I Theta
47:33 - has been applied as a relative phase to
47:36 - the control
47:37 - Cubit this occurs if V is an igen state
47:41 - of the gate you are applying we call
47:44 - this phenomenon phase Kickback and it is
47:46 - used in some Quantum algorithms
47:58 - let's have a look at superdense coding
48:01 - this Quantum protocol allows us to send
48:03 - two bits of classical information with
48:06 - only one cubit to do this we need
48:09 - entanglement we'll say that the person
48:11 - sending the Cubit is Alice and the
48:13 - person receiving this Cubit is
48:16 - Bob to start off with Alice and Bob
48:19 - maximally entangle two cubits so they
48:22 - are in this state Alice takes one and
48:25 - Bob takes the other we will say that
48:27 - Alice takes the left QQ bit and Bob
48:29 - takes the right cuq bit then Alice and
48:31 - Bob take those cubits with them now when
48:35 - Alice wants to send two bits of
48:36 - classical information to Bob depending
48:39 - on which two bits of information Alice
48:41 - wants to send she performs some
48:43 - operations on her Q bit if Alice wants
48:47 - to send the two classical bits 0 0 she
48:50 - does nothing and sends her Q bit to Bob
48:54 - if Alice wants to send 01 she an X gate
48:57 - to her qbit transforming the CU bits to
49:00 - this state then she sends her Cubit to
49:03 - Bob if Alice wants to send one Z she
49:07 - applies a zgate to her Q bit
49:09 - transforming the Q bits to this state
49:11 - then she sends it to Bob lastly if she
49:14 - wants to send one one she applies both
49:17 - an x and z gate to her cuit giving us
49:21 - this state she then sends her qbit to
49:24 - Bob now Bob has both the cubits in one
49:27 - of these four states he now applies a c
49:30 - not with the first Cubit as a control
49:33 - and the second as the target giving us
49:35 - these
49:36 - states then he applies a hadam mod gate
49:39 - to the left key bit this gives us this
49:41 - state that Alice wanted to send all Bob
49:44 - now has to do is measure the Q bits and
49:47 - he will get the two bits Alice intended
49:49 - to send as you can see with quantum
49:52 - computers we can send two bits of
49:54 - classical information by sending one Q
49:57 - bit this works since there are two
49:59 - entangled Q bits in the entire
50:08 - system before we look at how we can
50:10 - apply functions on quantum computers we
50:13 - will quickly look at how classical
50:15 - computers perform operations on bits and
50:18 - how we make classical operations
50:20 - reversible there are four main
50:22 - operations we can perform on classical
50:24 - bits the and or not and exclusive or
50:28 - operations let's go through each one of
50:30 - them quickly the simplest is the not
50:33 - gate which flips 0 to 1 and 1 to zero
50:37 - here is the truth table for the gate
50:39 - where X is the input and F ofx is the
50:42 - output as you can see this gate acts on
50:45 - one bit now let's look at the end gate
50:49 - here is the truth table for the gate the
50:51 - operation acts on two bits and returns
50:54 - one if the two bits are one and zero
50:58 - otherwise the orgate acts on two bits as
51:01 - well if either of the bits is a one or
51:04 - both or one then it returns one
51:07 - otherwise it returns
51:09 - zero lastly we have the exclusive or
51:12 - gate here is the truth table for the
51:15 - operation as you can see it returns one
51:18 - if either of the inputs is one and
51:20 - returns zero if both the bits are zero
51:23 - or one we use the exclusive or operation
51:26 - to reversible classical Gates we say a
51:29 - function f is reversible if given F ofx
51:33 - we can determine the value of x so if we
51:36 - are given the output we can determine
51:39 - the input so this function here where we
51:42 - negate the second bit is reversible
51:45 - since each row of the truth table for
51:47 - this function is unique so we can map
51:50 - each output to a unique input but the or
51:54 - operation on the other hand is not
51:56 - reversible
51:57 - since if we get an output of one we
51:59 - cannot say what the input was it could
52:02 - have been any of these three
52:05 - inputs to make any classical gate
52:07 - reversible we must input another bit
52:10 - let's call it C and instead of only
52:12 - returning F ofx we return the input X as
52:16 - well as C exclusive or with F ofx this
52:19 - makes the operation reversible let's
52:22 - look at converting the orgate to a
52:24 - reversible operation
52:26 - here is a normal orgate and here is a
52:29 - reversible orgate as you can see we
52:32 - input another bit C and return it
52:35 - exclusive or with the
52:37 - output now looking at the truth table
52:40 - each row of the outputs is unique so the
52:42 - gate is reversible since we can
52:45 - determine the input from the
52:48 - output what is the point in all this
52:51 - well with quantum computers all
52:53 - operations besides measuring the qits
52:55 - must be reversible this is because every
52:58 - operation must be unitary if you
53:01 - remember from the first section of this
53:03 - course unitary matrices rotate and flip
53:06 - a vector so they must be reversible in
53:09 - the next lesson we will discuss how we
53:11 - can apply functions on quantum computers
53:14 - using the same techniques that we used
53:16 - to make reversible classical
53:22 - Gates we discussed in the previous
53:25 - lesson how we can make classical Gates
53:27 - reversible now let's use this same
53:29 - technique to make Quantum functions
53:32 - since the operations we perform on
53:34 - quantum computers must be reversible if
53:37 - we wanted to apply a function on a
53:39 - quantum computer the function must be
53:41 - reversible to do this we use the same
53:43 - techniques for making classical Gates
53:45 - reversible a standard Quantum function
53:48 - looks like this where we input X and Y
53:51 - and get back X and Y exclusive or with f
53:55 - ofx
53:57 - now you might be thinking how are we
53:59 - going to get the output if it is
54:01 - exclusive or with Y but if we set y to
54:04 - zero then we get zero exclusive or with
54:07 - f ofx zero exclusive or with any bit
54:11 - gives us back that bit this means that
54:14 - zero exclusive or with f ofx is just F
54:18 - ofx this allows us to query the function
54:21 - and get its output on a quantum computer
54:24 - we can encode functions within a unitary
54:26 - Matrix and so it is a valid Quantum gate
54:30 - we usually denote a function f as U subf
54:34 - so overall if we apply a function f to
54:37 - the state x0 we get the state x f ofx
54:43 - then to get the function output we can
54:45 - measure the second register of
54:47 - cuits let's see what happens if we apply
54:50 - a function f to this state with the
54:52 - output register being the minor State
54:55 - first let's rewrite the minor State like
54:58 - this and distribute the X State into the
55:01 - superposition since the function is a
55:03 - unitary operation it gets distributed
55:05 - into the superposition like any other
55:08 - gate then it acts on each of the
55:10 - superposition States individually
55:12 - applying U subf we get this state the
55:16 - zero exclusive W with f ofx becomes F
55:18 - ofx and the One exclusive W with f ofx
55:21 - becomes not F ofx now let's consider two
55:25 - scenarios if f ofx is equal to 0 then
55:29 - the state becomes 1 < tk2 x0 - X1 which
55:34 - we can rewrite as x minus on the other
55:38 - hand if f ofx is equal to 1 then the
55:40 - state becomes 1 on < tk2 X1 - x0 we can
55:46 - factor out the -1 leaving us with the
55:49 - state-1 on2 x0 - X1 this can be further
55:53 - factored intox
55:56 - minus now looking at these two states we
56:00 - can see that the only difference is the
56:02 - phase at the front we can combine these
56:04 - two equations into -1 to^ FX
56:09 - xus so if we apply a function to the
56:13 - state xus we get back -1 to the^ of f
56:17 - ofx xus when we query a function in this
56:21 - way where the output bit is in the minor
56:24 - State we call it a phase Oracle in the
56:27 - next lesson we will finally see how
56:29 - quantum computers can outperform
56:31 - classical computers with Deutsch's
56:33 - algorithm which uses this technique of
56:36 - the phase
56:37 - Oracle one more thing we will discuss
56:40 - when it comes to quantum computers is a
56:42 - theorem called the no cloning theorem
56:45 - when we want to copy bits on a classical
56:48 - computer all we need to do is read the
56:51 - values of the bits and write the values
56:53 - to other bits but with quantum computers
56:56 - if if we have a CU bit in an unknown
56:58 - State say we have S is equal to Alpha 0
57:01 - + beta 1 we cannot copy this state if we
57:04 - don't know Alpha and beta if we were to
57:06 - measure s we would get Z or 1 but to
57:10 - copy the state we need to know the
57:12 - amplitudes so we would need to know
57:14 - Alpha and beta we could easily copy qbit
57:17 - states where we know the amplitudes by
57:19 - applying the needed Gates but if we do
57:21 - not know the state we cannot copy a cuit
57:31 - now let's finally look at a Quantum
57:33 - algorithm deutch's algorithm but first
57:36 - let's look at the problem it solves and
57:38 - how we would solve that problem with a
57:40 - classical computer say we have a
57:43 - function f that takes in a bit and
57:46 - returns a bit we don't know what the
57:48 - function does all we can do is send in a
57:51 - bit and read the output bit it is like a
57:54 - black box our t ask is to find out
57:57 - whether the function f is constant or
58:01 - balanced if a function is constant then
58:04 - it Returns the same bit no matter the
58:06 - input here are the two constant
58:08 - functions that can act on one bit
58:11 - constant one which always returns one
58:14 - and constant zero which always returns
58:17 - zero balanced functions on the other
58:20 - hand return zero for half the inputs and
58:23 - one for the other half of the inputs
58:25 - here are the are the two balanced
58:27 - functions that can act on one bit
58:30 - identity which Returns the input and the
58:32 - not gate which we saw before which flips
58:35 - the bit as you can see both these
58:38 - operations return zero for one input and
58:41 - one for the other
58:42 - input for this problem we don't care if
58:46 - the function is a not gate or a constant
58:48 - zero we only care if it is constant or
58:51 - balanced if we wanted to find out if f
58:54 - is constant or balanced on a classical
58:57 - computer we would first need to input
58:59 - zero and then input one to see if we get
59:02 - the same or different values if f of0
59:06 - equals F of 1 then we know that the
59:08 - function is constant and if F of 0 does
59:11 - not equal F of one then the function is
59:13 - balanced so we need to query the
59:15 - function twice once with zero as the
59:18 - input and once with one as the input
59:20 - with quantum computers and Deutsch's
59:22 - algorithm however we only need one query
59:25 - of the function to find out if the
59:27 - function is constant or balanced here is
59:30 - the circuit for the algorithm the U of
59:33 - represents the function f at S Sub 0 the
59:37 - Q bits are in the state 0
59:39 - 0 then at SI sub 1 the cubits are in the
59:43 - state
59:44 - 01 at SI sub 2 we apply a hadam mod to
59:48 - each of the cubits leaving us with the
59:50 - state plus minus let's expand the plus
59:54 - State and distribute the minus state
59:56 - into the
59:57 - equation now at SI sub 3 we apply the
60:00 - unitary Matrix UF acting as the function
60:03 - to the state since all Quantum
60:06 - operations are linear UF gets
60:08 - distributed into the state and acts on
60:11 - each of the superposition States
60:13 - individually if we look at each of the
60:15 - superposition States they are in the
60:17 - phase Oracle form so applying U of f to
60:20 - the first state becomes -1 to the^ of f
60:23 - of 0 0 minus and the second state
60:26 - becomes -1 to ^ f of1 1
60:30 - minus the minus qbit is not needed for
60:33 - the rest of the algorithm so we will
60:35 - emit it to clean up the equation now
60:38 - let's consider two different scenarios
60:41 - if F of 0 equals F of 1 then the state
60:44 - becomes 1 / < tk2 0 + 1 if F of 0 and F
60:48 - of 1 equal 0 or 1 / < tk2 0 - 1 if F of
60:55 - 0 and F of 1 = 1 with this we can factor
60:59 - out a global phase of -1 leaving us with
61:03 - 1 < tk2 0 + 1 therefore if F of 0 equal
61:09 - F of 1 the state becomes 1 / < tk2 0 + 1
61:13 - or the plus State now let's look at if F
61:17 - of 0 does not equal F of 1 so if F0 = 0
61:21 - and fub1 = 1 the state becomes 1 / < tk2
61:26 - 0 - 1 if F of 0 = 1 and F of 1 = 0 then
61:31 - the state becomes 1 / < tk2 - 0 + 1 with
61:36 - this we can factor out a global phase of
61:39 - -1 leaving us with the minus
61:46 - state so overall if F of 0 equals F of
61:50 - one the state becomes the plus State and
61:52 - if F of0 does not equal F of 1 the state
61:55 - becomes the minor State see if you can
61:58 - finish the rest of the algorithm off
62:02 - yourself now at SI sub 4 we apply a
62:05 - hadam mod to the Q bit in the case where
62:08 - F of 0 equals F of 1 this transforms the
62:11 - state into zero and in the case where F
62:14 - of 0 does not equal F of one the state
62:17 - becomes one now all that's left to do is
62:20 - measure the Cubit looking at our
62:22 - equations if we measure a zero then the
62:25 - function is constant since f of0 equals
62:28 - F of 1 and if we measure one then the
62:31 - function is balanced since F of 0 does
62:33 - not equal F of one as you can see what
62:36 - took a classical computer two queries of
62:39 - the function was done with one query of
62:41 - the function on a quantum
62:43 - computer in the next lesson we will look
62:46 - at the DEA algorithm which considers
62:49 - itself with the same problem of deutch's
62:51 - algorithm of finding out if a function
62:53 - is constant or balanced but in instead
62:56 - of having a function that only inputs
62:58 - one bit the algorithm is a general case
63:01 - that accepts any number of bits as
63:08 - input the deuts josa algorithm considers
63:11 - itself with the same problem of
63:13 - deutsche's algorithm of finding out if a
63:16 - function is constant or balanced but
63:18 - instead this algorithm is a general case
63:21 - that can accept any number of bits as
63:24 - input let's quickly revise constant and
63:27 - balanced functions constant functions
63:30 - always return the same value no matter
63:32 - the input here are the two constant
63:35 - functions constant Z and constant
63:38 - one balanced functions return zero for
63:41 - half the inputs and one for the other
63:43 - half of the inputs here is an example of
63:46 - a balanced function that takes in a bit
63:48 - string of length three as you can see
63:51 - the function returns zero for four of
63:53 - the inputs and one for the other four of
63:56 - the
63:57 - inputs for a classical computer to solve
63:59 - this problem it would need to query the
64:02 - function in the worst case 2 ^ n -1 + 1
64:06 - * where n is the length of the bit
64:09 - string the function takes as
64:11 - input this is because in the worst case
64:14 - we check half of the inputs and get the
64:16 - same output for all of them when this
64:19 - happens we need to check one more input
64:21 - to determine whether the function is
64:23 - constant or balanced the there are two
64:26 - to the N possible bit strings of length
64:28 - n so 2 the nus1 is half of the possible
64:32 - inputs therefore we need to check half +
64:36 - 1 so 2 n-1 + 1 inputs in the worst case
64:41 - to be certain the function is constant
64:43 - or balanced with a quantum computer we
64:46 - only need one query of the function just
64:49 - like deutch's algorithm to determine
64:52 - whether the function is constant or
64:54 - balanced
64:55 - here is a circuit for the algorithm this
64:58 - line here going through the circuit
65:00 - represents n qits and the hamod gates
65:04 - tensor n represent n hadam mod Gates
65:07 - each one being applied to one of the N
65:10 - cubits let's go through the algorithm at
65:13 - S Sub 0 we have n z minus then at S Sub
65:18 - one we apply a hadam mod gate to each of
65:21 - the N zeros giving us this state let's
65:24 - quickly derive anide identity that we
65:26 - frequently use when applying hatam mods
65:28 - to a register of zeros this gives us n
65:32 - plus States if we expand them out we get
65:35 - 1 / < tk2 0 + 1 tens with 1/ < tk2 0 + 1
65:40 - and so on N times let's try different
65:43 - values of n to figure out how we can
65:45 - represent this mathematically if we have
65:48 - Nal 2 we have the plus state tensored
65:51 - with itself Distributing the states
65:53 - gives us a state one of a < tk2 2 0 0 +
65:58 - 0 1 + 1 0 + 1
66:01 - 1 we can represent the superposition
66:03 - States like this with a sum over all bit
66:06 - strings of length 2
66:09 - x let's try n = 3 with this we have the
66:13 - plus state tensored with itself three
66:15 - times Distributing gives us this state
66:18 - we can once again represent the
66:20 - superposition States as a sum of all
66:23 - possible bit strings of length three and
66:25 - X resulting in this state we can
66:28 - generalize this and say that if we apply
66:31 - a hadam mod to each of the N zeros we
66:34 - get 1 / < tk2 to the^ of n time the sum
66:37 - of all bit strings of length n x this is
66:41 - a very important identity in Quantum
66:44 - algorithms and is used in many
66:46 - algorithms if you think about it this
66:48 - makes sense since each Cubit is in the
66:51 - plus state it has an even chance of
66:53 - being zero and one so every possible
66:56 - combination of zeros and ones will occur
66:58 - in the state and with equal
67:01 - probabilities going back to size sub 1
67:04 - we can now change this to our
67:07 - identity now at size sub 2 we apply the
67:10 - Oracle function since the function acts
67:13 - on each of the superposition States we
67:16 - distribute it into the sum now if you
67:19 - look at each of the superposition states
67:21 - in the sum they are in the phase Oracle
67:24 - form applying the function function
67:26 - gives us the equation 1 / < tk2 the^ of
67:29 - n * the sum of all bit strings of length
67:32 - n -1 to the^ of f ofx
67:36 - xus let's emit the minus Q bit from the
67:39 - equation as it is not needed in the
67:41 - algorithm anymore at size sub 3 we once
67:45 - again apply a hatam mod to each of the
67:47 - CU bits what this means is that for
67:50 - every bit in the bit string X we apply a
67:53 - hadam mod gate you may be looking at
67:55 - this and thinking that we can use the
67:57 - formula we used before but that one can
68:00 - only be used when the state is all zeros
68:03 - the X State can be any combinations of
68:06 - zeros and ones let's quickly figure out
68:09 - how we can represent this mathematically
68:12 - for this we can rewrite the hadam mod
68:14 - transform on an arbitrary bit XI as 1 /
68:18 - < tk2 0 + -1 to the^ of x i 1 since if
68:24 - XI is0 it becomes the plus State and if
68:27 - x i is one it becomes the minus State
68:30 - let's try X being a bit string of length
68:33 - three this gives us this state if we
68:36 - tend to the states together we get this
68:38 - state let's quickly add the exponents of
68:41 - the negative 1es as you can see whenever
68:44 - there is a one in the superposition
68:46 - state that state is being multiplied by
68:48 - a negative one to the power of x i where
68:52 - x i is the position of the one we can
68:55 - reite write this as the dotproduct of X
68:57 - with the superposition
69:02 - State now we can combine this state as
69:04 - the sum of all Zs that are bit strings
69:07 - of length three -1 to the^ of X do z
69:12 - z generalizing we get this identity
69:16 - where applying a hatam mod to an
69:17 - arbitrary bit string of length n x gives
69:20 - us 1 / < tk2 to the^ of n * the sum of
69:24 - all bits Str of length n -1 to the^ of X
69:28 - do z
69:30 - z this is also a very important identity
69:34 - that is used in many Quantum algorithms
69:37 - with this the qits are now in this
69:47 - state let's now consider the amplitude
69:50 - of the all zero State we find that it is
69:53 - 1/ 2 ^ n time the sum of all bit strings
69:57 - of length n -1 to the^ of f ofx + x
70:02 - dotted with all zeros the X doted with
70:04 - the all zeros become zero so the state
70:07 - becomes this
70:10 - state now if the function f is constant
70:14 - then the value of f ofx will be the same
70:16 - no matter the input this means that if f
70:19 - ofx is equal to Z the amplitude of the
70:22 - state becomes 1/ 2 to the^ of n time a
70:25 - sum over all X's 1 evaluating the sum
70:30 - there are two to the end possible
70:31 - combinations of Zer and ones of length n
70:35 - so the sum is 1 + 1 + 1 and so on 2 the^
70:39 - of n * this gives us 1 / 2^ n * 2^ of n
70:45 - which equals 1 on the other hand if F
70:48 - ofx isal to one we do the same thing
70:51 - giving us netive - 1 so if the function
70:54 - is constant the amplitude of the all
70:56 - zero state is plus or minus 1 if the
71:00 - function is balanced then half the
71:02 - inputs will result in zero and the other
71:04 - half will result in one if we look at
71:07 - the sum this means that there will be
71:09 - the same number of ones being added to
71:11 - the same number of negative ones this
71:14 - means the sum will be evaluated to zero
71:18 - so if the function is balanced then the
71:20 - amplitude of the all zero state is
71:23 - zero now we measure the cubits before we
71:27 - saw that if the function is constant
71:29 - then the amplitude of the all zero state
71:32 - is plus or minus 1 that means the
71:34 - probability of measuring the all zero
71:36 - state is one if the function is balanced
71:39 - on the other hand then the probability
71:41 - of measuring all zeros is zero what this
71:44 - means is that if we measure all zeros
71:46 - the function is constant but if we
71:48 - measure anything else the function is
71:51 - balanced and we done we have determined
71:54 - if the function X f is constant or
71:56 - balanced in a single query of the
71:58 - function the key takeaway from this
72:01 - algorithm are these two identities they
72:03 - will keep popping up again and
72:10 - again let's now look at the Bernstein
72:13 - vasani algorithm here is the problem it
72:16 - solves imagine we have a function f that
72:20 - takes in a bit string of length n and
72:22 - returns a single bit which is a DOT
72:24 - product of the input with some secret
72:27 - string S modulo 2 our task is to find
72:31 - out what the secret string s is on a
72:35 - classical computer the approach is to
72:37 - input a bit string of all zeros except
72:40 - for one in one position this allows us
72:43 - to get the value of one position of the
72:45 - bit string S as all the zeros in the
72:48 - input will cancel out in the dot product
72:51 - this means that we must query the
72:53 - function n * when n is the length of s
72:57 - since each query we get one value of
73:00 - s with quantum computers on the other
73:03 - hand we only need to query the function
73:05 - once to find out what s is if we look at
73:09 - the circuit it may look familiar it's
73:12 - the same circuit as a DOA algorithm just
73:15 - with a different function being applied
73:17 - to the cubits initially the cubits are
73:20 - in the state n z minus then at S Sub 1
73:25 - the state is 1/ < tk2 the^ n * the sum
73:29 - over all X where X is a bit string of
73:32 - length n x minus at S Sub 2 we apply the
73:37 - Oracle since the target Q bit is in the
73:40 - minus State we use the phase Oracle
73:42 - property so the state becomes 1 / < tk2
73:45 - to^ n * the sum over all x -1 to the^ of
73:50 - f ofx
73:52 - xus let's rewrite f ofx as a dotproduct
73:55 - of X and S since that is the definition
73:58 - of our function let's also emit the
74:01 - minus qbit since it is not needed
74:03 - anymore now we apply a hadam mod to each
74:06 - of our Q
74:15 - bits let's distribute the -1 to the
74:18 - power of X do s into the sum we can now
74:22 - add the exponents giving us the dot
74:24 - product of s s and X plus the dot
74:26 - product of x and z we can factor out the
74:30 - X giving us s + z dotted with x the plus
74:34 - indicates bit wise exclusive or so for
74:37 - each bit in s we exclusive or it with
74:40 - the bit in Zed that is in the same
74:42 - position so the I position of S Plus Z
74:46 - is S Sub I exclusive or with Z sub I
74:51 - this gives us another bit string of
74:53 - length n now we measure the Q bits let's
74:57 - look at the probability of measuring s
75:00 - expanding out we find the amplitude of
75:02 - the S state is 1 / 2 to^ n * the sum
75:06 - over all X's where X is a bit string of
75:09 - length n -1 to the power of s + S dotted
75:13 - with X since plus indicates bit yse
75:17 - exclusive or S + S equals to all
75:22 - zeros now in the X exponent we have all
75:26 - zeros dotted with X this will equal Z
75:29 - since all the zeros will cancel out all
75:31 - the X's at each position applying the
75:34 - power means the state becomes 1 on 2
75:38 - the^ n * the sum over all X's 1 since
75:42 - there are two to the power of n bit
75:44 - strings of length n there are two to the
75:47 - N possible values of X so evaluating the
75:50 - sum we get 2 the^ of n this leaves the
75:54 - amplitude of the s State as one this
75:57 - means that the probability of measuring
75:59 - s after applying the algorithm is one
76:03 - and that is it after one query of the
76:05 - function we can find S by measuring the
76:08 - cubits you may start to see the
76:10 - similarities between this algorithm and
76:13 - the others applying a hadam mod to each
76:15 - of the cubits so that the state is in a
76:17 - uniform superp position then applying
76:19 - the function and once again applying
76:21 - hadam mods is used in many algorithms
76:29 - in the next two lessons we will look at
76:31 - the quantum forier transform as well as
76:33 - Quantum phase estimation these are both
76:36 - used within many Quantum algorithms
76:38 - including Shaw's algorithm let's start
76:40 - with the quantum fora transform or qft
76:44 - before we look at the maths and circuit
76:46 - behind it let's look at how it
76:48 - transforms states on the Block sphere so
76:50 - we can gain some intuition on the top we
76:53 - have how we would normally represent a
76:55 - number in binary as you can see each of
76:58 - the Q bits is either zero or one and if
77:01 - we take those bits we get the number
77:04 - then underneath we have the same cubits
77:06 - after the quantum 4A transform has been
77:09 - applied as you can see instead of
77:11 - encoding the numbers like we normally do
77:14 - in a classical computer with zeros and
77:16 - ones the numbers are now encoded by the
77:18 - phase of the Q bits that are in a
77:20 - uniform superp position as you can see
77:23 - the left Q bit has two possible phase
77:26 - options either Zer or -1 relative phase
77:30 - then the next qbit has four possible
77:32 - phase options and so on up until the
77:35 - last CIT which has two to the N possible
77:38 - phase positions where n is the number of
77:40 - qits in this case the right CU bit has 2
77:44 - to the 3 or eight possible phase
77:47 - options depending on the number the
77:50 - phase of the CU bits is different let's
77:53 - see how the number five is encoded Ed
77:55 - once the quantum 4A transform has been
77:57 - applied as you can see the right Q bit
78:00 - has been rotated around the Z AIS 5 8 *
78:04 - 2 piun radians which is 5 piun on 4
78:09 - radians to get the amount rotated around
78:12 - the Z AIS of the next q bit we multiply
78:15 - the previous one by two so the next q
78:18 - bit has been rotated 2 * 58 * 2 piun
78:22 - radians so rotating the cub > / 2
78:25 - radians around the Z
78:27 - AIS the last one is 2 * that which is 2
78:31 - * > / 2
78:35 - radians this means that if we have this
78:38 - state which is five in binary and we
78:40 - apply the quantum forier transform we
78:43 - get this state in the next lesson we
78:45 - will see a use of the quantum forier
78:48 - transform but for now let's look at the
78:50 - circuit here is the Quantum forier
78:52 - transform circuit for any number of bits
78:56 - as you can see there are two gates that
78:58 - we have not seen before this gate here
79:01 - is a controlled R gate we will Define
79:03 - this gate with this Matrix as you can
79:06 - see this gate has a variable K which we
79:09 - can set and affects the phase applied
79:12 - this gate transformed the Bas of State 0
79:14 - into 0 and 1 into e 2 Pi / 2 to the K 1
79:21 - giving us a relative phase if applied to
79:23 - a q bit in in superp position the
79:26 - controlled version like we have in this
79:28 - circuit is the same as all the other
79:30 - controlled versions of other Gates only
79:32 - applying the gate if the control is a
79:35 - one this other weird looking gate is
79:38 - called a swap gate and it swaps the
79:40 - states of the two Q bits for this lesson
79:44 - we will go through an example with three
79:46 - bits for this example we'll use the
79:49 - state J as an input to the algorithm we
79:52 - will label each one of J's bits like
79:54 - this where each ji is either Z or 1 to
79:59 - keep our equations tidy we will look at
80:01 - each one of the cubits individually then
80:04 - combine them at the end of the algorithm
80:07 - let's start with finding out what j0
80:10 - becomes after the hadm mod gate the
80:12 - state becomes 1 < tk2 0 + -1 to the^ of
80:18 - J
80:20 - 01 we can represent this like this
80:25 - you will see why we keep the j0 ided 2
80:29 - and don't simplify the fraction at the
80:31 - end then we apply the controlled R2 gate
80:35 - with J1 as the
80:46 - control we apply the R3 gate in the same
80:49 - way
80:55 - now let's find out what J1 becomes after
80:58 - the hadam mod gate the state becomes
81:00 - this state then after the controlled R2
81:03 - gate and simplifying like we did
81:05 - previously we get this
81:08 - state lastly we apply a hatod gate to
81:12 - the J2 Cubit leaving it in this
81:15 - state so after this part of the
81:18 - algorithm our state J is in this state
81:21 - now once we swap the cuits the state
81:24 - changes to this and we're done with the
81:27 - algorithm it may not seem like we did
81:30 - much but we have in fact encoded the
81:32 - value of J into the phase of the cubits
81:36 - just like we saw with the animation
81:38 - previously let's quickly check this by
81:41 - making J the value of five so 101 in
81:45 - binary if we now input the values into
81:48 - the equations for the state then we can
81:50 - see that the phases do match up to what
81:53 - we had previously discovered at the
81:55 - beginning of the lesson if we were to
81:58 - apply the quantum fora transform to an
82:00 - arbitrary basis State J we get 1 / < tk2
82:04 - to^ of n * the sum from K = 0 to 2 n- 1
82:10 - E to the^ 2 pi i j k/ 2 the n k where n
82:16 - is the number of bits in
82:19 - J we also have the inverse Quantum fora
82:22 - transform and that undoes the quantum
82:25 - forier transform so if we add this state
82:28 - which is the state where we encoded five
82:30 - using the quantum forier transform if we
82:33 - now apply the inverse Quantum forer
82:35 - transform we get back to our state
82:43 - 101 the quantum phase estimation
82:46 - algorithm allows us to find the igen
82:48 - value of an igen Vector given the Matrix
82:52 - so if we have a matrix U and apply to
82:54 - its vector v since V is an Vector we get
82:58 - e to the I Theta V where e to the I
83:01 - Theta is the igen value we can represent
83:05 - all igen values in Quantum Computing in
83:07 - this form the qpe or Quantum phase
83:11 - estimation algorithm finds e to the I
83:13 - Theta to a certain accuracy this
83:16 - algorithm is a key part in many Quantum
83:18 - algorithms including shaes algorithm
83:21 - which we will discuss in the next lesson
83:23 - which allows us to find prime factors of
83:25 - large numbers here is the Quantum phase
83:28 - estimation circuit as you can see we
83:31 - have two registers the first one
83:33 - contains M zeros and is used to store
83:36 - the estimated phase and the second one V
83:39 - is n cubits and is the IG Vector of the
83:42 - gate we're trying to measure the IG
83:45 - value of looking at the circuit you can
83:48 - see that the gate U which we're trying
83:51 - to find the I value of is to the power
83:54 - of some numbers U to the power of n is
83:57 - the same as applying U to a qit n * also
84:02 - you can see we have the inverse Quantum
84:03 - fora transform at the end of the
84:06 - algorithm let's start going through the
84:08 - circuit at S Sub 0 we have the state M
84:12 - Z's V then at SI sub 1 we apply the
84:16 - hadam mod gates to all the Q bits in the
84:18 - first
84:21 - register at SI sub 2 we apply the uate
84:25 - to the igen vector v with the rightmost
84:28 - qbit in the first register as a control
84:31 - since V is the IG Vector of you phase
84:33 - Kickback occurs which adds a relative
84:36 - phase of e to the a Theta to the Cubit
84:39 - then at SI sub 3 we apply two U Gates or
84:42 - the U squared gate with the qbit in the
84:45 - first register as a control and v as the
84:48 - target once again phase Kickback occurs
84:51 - applying a phase of e to the I Theta * a
84:54 - to the I Theta or e 2 I Theta we
84:58 - continue this process for each of the
85:00 - cuits in the first register which leaves
85:02 - us with this
85:04 - state now we let Theta equal 2 pi J
85:09 - where J is a number between 0 and 1
85:12 - since Theta is an angle between 0 and 2
85:15 - pi with this if we find J we can find
85:19 - Theta substituting this in we get this
85:22 - equation now since since J is a bit
85:25 - string less than one we can represent it
85:27 - like this which converts it from a
85:29 - decimal in binary to a decimal in base
85:32 - 10 if we now sub that into our equation
85:36 - it becomes this now if we look at the
85:38 - first Cubit we have a factor of 2 to
85:41 - the^ of nus1 if we distribute that into
85:44 - J we get
85:48 - this since all these terms are integers
85:51 - when we expand them out they will be a
85:53 - factor of 2 Pi so they are not needed
85:56 - since they are redundant this leaves us
85:59 - with J m-1 / 2 if we do the same process
86:04 - to the rest of the cubits we are left
86:06 - with this state can you notice anything
86:08 - about this state this is the same state
86:11 - as if we were to apply the quantum for8
86:13 - transform to the state J so when we
86:17 - apply the inverse Quantum forier
86:19 - transform we end up with the state J all
86:23 - we need to do is measure the state and
86:25 - we've approximated J to M bits now with
86:29 - J we can multiply it by 2 pi to get
86:33 - Theta and then we can find the I value
86:36 - as e to the I
86:44 - Theta now we will tackle probably the
86:47 - most important and popular Quantum
86:49 - algorithm shaes algorithm this algorithm
86:52 - allows us to find the prime factors of a
86:55 - large number so if we have a number n
86:57 - equal PQ where PQ are both Prime Shaw's
87:01 - algorithm allows us to find p and
87:05 - Q this may not seem very useful but this
87:08 - is the backbone of RSA which is a widely
87:11 - used type of encryption so using shaes
87:14 - algorithm will allow us to crack RSA
87:16 - encryption but that won't happen for a
87:18 - while to run sh's algorithm we will need
87:21 - a fault tolerant quantum computer with
87:23 - Mill ions of logical Q bits which won't
87:26 - happen for some time this algorithm uses
87:29 - both classical and quantum computers for
87:32 - different steps first we choose an a
87:36 - that is between 1 and n and the gcd of A
87:39 - and N is one so A and N share no common
87:44 - factors next we do the quantum step but
87:48 - before that we will look at some number
87:51 - theory in modular arithmetic we say say
87:54 - that a is congruent to B mod n if the
87:58 - remainder of a / n is B for example 3 is
88:03 - congruent to 1 mod 2 since dividing 3
88:07 - with two gives a remainder of
88:09 - one we can reduce the factoring problem
88:13 - down into the problem of finding the
88:15 - period of modular exponentiation modular
88:18 - exponentiation is when you take the
88:20 - powers of a number modul a number here
88:23 - is an example
88:25 - example as you can see if we have a
88:27 - number in this case two and put it to
88:30 - increasing Powers we get a repeating
88:32 - pattern when we take the modulo the
88:35 - period of this pattern is the length of
88:37 - the sequence and that is what we are
88:39 - looking for in this case the period R is
88:43 - equal to 6 all of the sequences start
88:46 - with a ^ of 0 is congruent to one mod n
88:50 - so we need to keep increasing the power
88:52 - until we get back to one
88:55 - if we are able to find the period we can
88:57 - use some number Theory to find the prime
89:00 - factors if we have a number n which is
89:03 - equal to the product of two prime
89:05 - numbers p and Q if we pick a number a
89:08 - where the gcd of A and N is equal to 1
89:12 - so they share no common factors and we
89:15 - find the period of a to the X Mod n then
89:19 - if we get a good approximation for R the
89:21 - gcd of a to the^ of r / 2 - 1 and n and
89:27 - the gcd of a ^ n / 2 + 1 and N has a
89:32 - good chance of containing the factors of
89:35 - n let's go through the steps in finding
89:38 - the period of modular exponentiation for
89:41 - this we need to use this gate let's call
89:43 - it U which transforms the state x to the
89:47 - state x a mod n if we apply this gate to
89:51 - the one state multiple times we can get
89:54 - powers of a in mod n how we construct
89:58 - this gate is outside the scope of this
90:00 - course see the problem set for resources
90:03 - on how we can construct this gate let's
90:06 - consider this state
90:10 - us if we apply a uate to the state it
90:14 - gives us this
90:19 - state looking at the a to the r mod n we
90:23 - can change the to a to 0 mod n since
90:26 - they are both 1 if we multiply the right
90:29 - hand side by 1 or e to the 2i i s / R *
90:34 - e - 2i i s / R we get this state we can
90:40 - change the E to -2 Pi I Sr / R to e to
90:46 - -2 Pi i 0/ r since they are both equal
90:49 - to one now as you can see this whole
90:53 - state becomes the US state this means
90:57 - that the US state is an igen Vector of
91:00 - the uate with an igen value of e to ^ 2
91:04 - pi i s /
91:06 - R this means that if we can construct
91:09 - the US state we can use the quantum
91:11 - phase estimation algorithm to get the
91:14 - value of s/ R it turns out that it is
91:17 - far easier to construct the equal
91:20 - superposition of all of the US states
91:23 - what what this becomes is 1 mod n in the
91:27 - problem set for this lesson we will
91:29 - prove this result we can construct the
91:32 - one mod n by applying a KN to the
91:35 - rightmost Q bit in a register of all
91:37 - zeros which gives us the value one which
91:40 - is equal to one in mod n so by creating
91:44 - the state 1 mod n we are actually
91:47 - creating the state 1 /un R * the sum
91:50 - from s = 0 to R -1 of us here is the
91:55 - circuit for the algorithm looking at it
91:58 - this is just the quantum phase
92:00 - estimation circuit as you can see we now
92:03 - know that one is an igen Vector of the
92:06 - uate so we are using this to estimate
92:08 - the igen value e to^ 2 pi i s / R where
92:13 - s is an integer from 0 to R -1 this is
92:17 - because our igen Vector 1 mod n is equal
92:21 - to 1 /un R * the sum from S = 0 to R
92:26 - -1 of U so we will get the I value e to
92:31 - ^ of 2 pi i s / R for one value of s so
92:36 - when we measure the qits we will get the
92:39 - I value of one of the US's which means
92:43 - that we will get S / R for 1 s from 0 to
92:47 - Rus one if we happen to get zero as our
92:50 - igen value so s = 0 then then we repeat
92:54 - the circuit so we can get an igen value
92:57 - that is non
92:58 - zero now we have a decimal number J
93:01 - which is equal to S / r that is the
93:04 - Quantum part of the algorithm done now
93:07 - we estimate the values of S and R by
93:10 - using a technique called continued
93:12 - fractions here is an example with the
93:15 - decimal
93:17 - 0.312 we start by writing it as a
93:19 - fraction then we flip the fraction
93:25 - we continue this process until we have
93:27 - the number one in the numerator by
93:30 - representing a decimal in this way we
93:33 - can approximate its value with a
93:35 - fraction by rounding off the continued
93:37 - fraction here are the first three
93:40 - approximations for the decimal
93:43 - 0.312 to approximate s / R we find an
93:46 - approximation where the denominator is
93:49 - less than n since the period R must be
93:52 - less than n if R is odd then we repeat
93:56 - the algorithm and get a new value of R
93:59 - now that we have a value for R we can
94:01 - use this to find the factors of n we
94:04 - know that a to the r is congruent to 1
94:07 - mod n so a to the r -1 is congruent to Z
94:12 - mod n this means that a ^ of R -1 has a
94:17 - factor of n since when we divide it by n
94:21 - we get zero remainder if we Factor a^ R
94:26 - -1 with the difference of 2 squares then
94:29 - we get this from this we can see that if
94:32 - we calculate the gcd of a^ R / 2 -1 n
94:38 - and the gcd of a^ R / 2 + 1 and N with
94:43 - our approximation of R we have a good
94:45 - chance of them being one of the factors
94:48 - this allows us to find p and
94:51 - Q let's go through a quick example with
94:54 - n = to 15 so p is 3 and Q is 5 in step
95:00 - one we choose an a which is relatively
95:02 - prime to 15 let's choose AAL
95:06 - 7 now in step two we use the quantum
95:09 - part of Shaw's algorithm to find the
95:12 - period or R so we need to find R such
95:15 - that 7 to the power of R is congruent to
95:18 - 1 mod 15 by using the algorithm we find
95:22 - that R is equal to 4
95:24 - now we calculate the gcd of 7^ 4 /2 - 1
95:30 - and 15 and the gcd of 7^ 4/ 2 + 1 and 15
95:36 - the first one becomes the gcd of 48 and
95:40 - 15 and the second becomes the gcd of 50
95:44 - and 15 the gcd of 48 and 15 is three and
95:49 - the gcd of 50 and 15 is five
95:54 - as you can see we have found the factors
95:56 - of 15 3 and 5 using shaes algorithm