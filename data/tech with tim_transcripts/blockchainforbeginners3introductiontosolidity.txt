00:00 - hello everybody and welcome to the third
00:02 - video in this blockchain for beginners
00:04 - tutorial series in this video i'm going
00:06 - to be giving you an introduction to
00:08 - solidity and showing you how to write
00:10 - and deploy your first smart contract
00:12 - this is really really cool i had a lot
00:14 - of fun messing with this before the
00:16 - video and i think you guys are going to
00:17 - be amazed at how simple it is to
00:19 - actually write a smart contract anyways
00:21 - i should mention that solidity is the
00:23 - programming language typically used for
00:25 - deploying smart contracts and writing
00:27 - ethereum smart contracts and so that's
00:29 - why we're going to be using it now in
00:31 - terms of kind of some prerequisites for
00:32 - this video i'm going to assume that you
00:34 - have some understanding of programming
00:37 - some experience writing and maybe a
00:38 - different programming language just
00:40 - because in this video i'm not going to
00:42 - explain the very basics like things like
00:44 - variables functions and all that stuff
00:46 - that's kind of common knowledge when it
00:48 - comes to programming of course i'll go
00:50 - through the solidity syntax and we're
00:52 - really going to learn by actually just
00:53 - doing a bunch of examples and not
00:55 - focusing a ton on theory last thing i
00:58 - will say is that you do need to have
00:59 - your meta mask set up if you want to
01:01 - deploy this to a test network so an
01:02 - ethereum test network if you don't have
01:04 - metamask setup that's fine you just
01:06 - won't be able to follow along with that
01:08 - step in the video alright so with that
01:10 - said we're just about ready to get
01:11 - started i just want to quickly thank
01:13 - cartesi again for sponsoring this video
01:15 - and this series they're an awesome
01:17 - company again dedicated to making the
01:19 - blockchain more accessible and easy to
01:22 - use they've really helped me a ton in
01:23 - terms of coming up with the content for
01:25 - these videos well i hope you guys
01:27 - appreciate that in the future videos in
01:29 - this series we're going to be talking
01:30 - about how we can actually use cartesi to
01:32 - fix some of the scalability issues with
01:34 - smart contracts because you're going to
01:36 - start to see some of the problems that
01:37 - can actually occur when we write a smart
01:39 - contract because they're a lot different
01:41 - than your traditional code anyways let's
01:43 - go ahead and get into the code
01:48 - [Music]
01:54 - all right so i'm here on my computer and
01:56 - the first thing i'm going to discuss is
01:57 - just setting up our environment for
01:59 - writing code and solidity and deploying
02:01 - smart contracts now of course you can
02:03 - write contracts in vs code or any local
02:05 - code editor but instead for this series
02:08 - i'm going to use an online ide called
02:10 - remix now this is a browser-based ide
02:13 - it's completely free and it's super
02:15 - beginner friendly and allows you to
02:17 - actually deploy and test your smart
02:19 - contracts directly from the browser so
02:22 - i'd recommend that you use this you can
02:23 - check it out from the link in the
02:25 - description or just google remix ide
02:27 - again completely free and once you click
02:29 - on that link it should bring you to a
02:31 - page that looks like this so for now
02:33 - what i'm going to do is just give a
02:34 - quick tour of remix then we'll talk
02:36 - about smart contracts what they actually
02:38 - are how they work then we'll start
02:40 - writing some code and going through some
02:42 - examples of smart contracts so the first
02:44 - thing we want to do here when we open up
02:46 - remix is we just want to install a few
02:48 - extensions specifically for solidity so
02:50 - you can write other stuff in remix not
02:52 - just solidity code so that's why we want
02:54 - these extensions so what we're going to
02:55 - do is just on the left hand side here go
02:57 - to this plugin manager it looks like a
02:59 - plug and what we're going to do is
03:01 - search for solidity now for me i already
03:04 - have these extensions installed but what
03:05 - you're going to want to install is the
03:07 - solidity compiler the solidity static
03:09 - analysis and then the solidity unit
03:11 - testing now you don't really need the
03:12 - unit testing but you might as well just
03:14 - install it while we're here so install
03:16 - those three plugins and once you have
03:18 - them installed we're pretty much ready
03:19 - to start writing solidity code now
03:21 - you're going to see in the left-hand
03:23 - side here let me zoom in a little bit
03:24 - that we have a bunch of you know i guess
03:27 - folders directories and inside of here
03:29 - we have some different smart contracts
03:30 - we have some scripts we have all this
03:32 - kind of stuff you don't need to worry
03:33 - about any of that this is all just kind
03:35 - of test code that's provided to you
03:37 - we're not going to use any of this we
03:38 - don't even need to look at it so you can
03:40 - kind of just ignore it for now what i'm
03:42 - actually going to do to get started is
03:43 - i'm just going to make a new file so i'm
03:45 - going to click on this little file icon
03:47 - right here and then i'm just going to
03:49 - call this test.soul
03:51 - so dot sol is the extension for solidity
03:54 - file so that's why we're going to use
03:55 - that when i do that it will open up a
03:57 - brand new file notice we have the little
03:59 - solidity icon now we can start actually
04:01 - writing a smart contract
04:03 - now one thing to notice here is there's
04:05 - stuff like github integrations you can
04:07 - create new directories you can upload
04:09 - files uh you can also have different
04:11 - workspaces so right now i'm in a
04:13 - workspace i created called tutorial but
04:15 - you also could make a new one by
04:17 - clicking this right here i guess this is
04:19 - renaming a workspace and then of course
04:21 - you can delete it i'll let you look at
04:23 - that yourself pretty straightforward
04:24 - anyways all we need to do is get to kind
04:26 - of a file that looks like this just an
04:28 - empty solidity file so i'm just going to
04:30 - zoom in by clicking this plus icon here
04:32 - so you guys can actually read the code
04:33 - all right so now that we're here we
04:35 - might as well write a very basic smart
04:37 - contract i'll briefly show you how it
04:39 - works and how we can run it then i'll
04:41 - actually discuss smart contracts in
04:43 - detail so how they work how you call
04:45 - them and how they're different from
04:46 - traditional code because they are much
04:48 - much different than anything you would
04:50 - have seen before
04:51 - okay so what i'm going to do is zoom in
04:52 - a bit and let's start by writing what's
04:54 - known as our pragma line
04:56 - now the pragma line is required at the
04:58 - beginning of all of your silly files and
05:00 - what this does is actually tell solidity
05:03 - what compiler version this file needs to
05:06 - use so there's a ton of different
05:07 - compilers that are accessible for
05:08 - solidity you just need to define the
05:10 - minimum compiler version so i'm going to
05:12 - say pragma solidity and i'm going to say
05:14 - 0
05:15 - 0.8.10 and then put a semicolon like
05:18 - that so for all of your lines you're
05:20 - going to have semicolons at the end very
05:21 - similar to something like java okay so
05:24 - we have our pragma line again just
05:25 - pragma solidity and then the minimum
05:27 - compiler version if you want to see the
05:29 - compiler versions you can go to i
05:31 - believe it's this tab right here and it
05:34 - will show you all the compiler versions
05:36 - so notice we're on 0.8.10 so i'm just
05:38 - using one of the latest versions that we
05:40 - have okay and then for language of
05:42 - course that'd be solidity and you're
05:43 - just going to have compiler default now
05:45 - here you can actually manually compile
05:47 - your solidity code i'll talk about that
05:49 - in a few minutes for now though let's
05:51 - continue writing the rest of our
05:53 - contract so after we do our pragma line
05:55 - the next thing we need to do is define a
05:57 - contract so i'm going to say contract
05:59 - and then i'm going to give this a name
06:00 - now i can give this whatever name i want
06:03 - i'm just going to call it my contract so
06:05 - what i've just done is created a smart
06:06 - contract okay that's all you need to do
06:08 - you write the word contract give some
06:10 - name the casing you're supposed to use
06:12 - for this name is pascal case which means
06:14 - you're supposed to have capital letters
06:16 - for every single word and then inside of
06:18 - here we can start defining some
06:19 - variables some functions and methods
06:22 - sorry not not functions methods what i
06:23 - mean
06:24 - anyways for now i'm just going to define
06:26 - a very basic variable then i'm going to
06:28 - show you how we actually deploy and test
06:30 - this smart contract and then we'll
06:32 - continue with some theory and looking at
06:33 - this more in depth so for now what i'm
06:35 - going to say is uint this stands for
06:39 - unsigned integer and i'm just going to
06:41 - say that this is public like this i'm
06:44 - going to call this x and i'm just going
06:45 - to make this equal to 21. okay super
06:48 - straightforward this is just me defining
06:49 - a variable the type of the variable is
06:51 - an unsigned integer it is public meaning
06:53 - anyone can view it into name is x and
06:56 - its value is 21. so now that we have
06:58 - this contract what we need to do is
07:00 - compile the contract and then deploy so
07:03 - all of our contracts in solidity need to
07:05 - be compiled into bytecode this bytecode
07:08 - is then sent to the ethereum network
07:11 - where the contract is deployed and then
07:12 - we can call the contract so let's just
07:14 - look at a quick example of doing this so
07:16 - we can manually compile by pressing
07:18 - compile we actually don't need to
07:20 - manually do this when we deploy it will
07:21 - automatically compile for us anyways
07:23 - i've compiled the contract right here
07:25 - notice i have my compiler version
07:26 - solidity compiler default then what i'm
07:29 - going to do is go to this tab right here
07:31 - so just below it let's see what this
07:32 - one's called deploy and run transactions
07:35 - and here what we can do is choose a few
07:37 - different options for actually deploying
07:38 - our contract so if you go here notice we
07:41 - have a bunch of options we have web3
07:42 - provider injected web 3 javascript vm
07:46 - and then we have the berlin version of
07:48 - the javascript vm now the javascript vm
07:50 - is what i'm going to use for right now
07:52 - but what this is is a virtual machine
07:54 - that simulates the ethereum network in
07:56 - your browser so this means you don't
07:58 - actually have to make any real
08:00 - transactions you're not actually adding
08:02 - this to a legitimate blockchain you're
08:04 - just simulating it so you can test this
08:06 - directly in your browser
08:07 - now if you refresh your browser what's
08:09 - going to happen is anything that you've
08:11 - been simulating in the javascript vm is
08:13 - going to disappear because what was
08:14 - being stored and i guess the cache or
08:16 - whatever inside of your browser point is
08:18 - javascript vm is kind of a testing
08:20 - environment and when you're actually
08:22 - going to deploy this smart contract for
08:24 - other people to use you need to deploy
08:26 - it to what's known as a web3 provider or
08:28 - an injected web 3. now injected web 3 is
08:31 - actually going to use whatever network
08:33 - your meta mask is on so if i do this
08:35 - what's going to happen is when i try to
08:37 - deploy this contract it's going to open
08:39 - up metamask and it's going to require
08:41 - that i actually do a transaction to
08:43 - deploy this contract again we're going
08:44 - to look at that in a second for now i
08:46 - just want to quickly show you deploying
08:47 - it and running it and then we'll get
08:49 - into the theory so i'm going to go to
08:50 - javascript vm and notice here that when
08:52 - i do this it's going to give me a bunch
08:54 - of different accounts that have 100
08:56 - ethereum again this is just testing and
08:58 - the point of these different accounts is
09:00 - that i can actually use all of them with
09:02 - my smart contract because every time i
09:04 - deploy the smart contract i want to call
09:06 - a function on the smart contract i need
09:08 - to make a transaction to do that and
09:10 - that requires an account to make the
09:12 - transaction with so for now i'll just
09:14 - select this first account i could copy
09:16 - the address here if i wanted to do that
09:18 - the gas limit just leave this the same
09:20 - for now and then you could pick an
09:21 - amount of ethereum that you actually
09:22 - want to send with this transaction now i
09:25 - don't want to do that for now i don't
09:26 - want to send any ethereum all i want to
09:27 - do is deploy my smart contract so i'm
09:29 - just going to click on deploy and then
09:31 - you're going to see down here it's going
09:32 - to show you my deployed contracts so i
09:35 - now have a contract notice it's showing
09:37 - this little button x and if i click on
09:39 - this it gives me the value of x okay
09:41 - very very simple that's all you need to
09:43 - do to deploy a smart contract we'll talk
09:45 - about this more in a second what i want
09:47 - to do now is hop over to my drawing
09:49 - tablet and start talking about some of
09:50 - the theory behind smart contracts and
09:52 - how they actually work and why we kind
09:54 - of needed to go through this alright so
09:56 - i'm here on the drawing tablet and i
09:58 - want to start by discussing how we
09:59 - deploy a smart contract then i want to
10:01 - talk about their use cases and go
10:03 - through a few properties of them so as
10:05 - we saw we had a smart contract and we
10:08 - stored this inside of a dot sol file now
10:12 - this is our solidity file and this is
10:13 - what we refer to as our source code now
10:16 - the source code is simply the code that
10:18 - we write as a programmer it's the
10:20 - closest to english it's the easiest for
10:22 - us to understand it is the source code
10:24 - okay this is where we actually write
10:25 - solidity code however this code cannot
10:28 - be executed on the ethereum network so
10:30 - what we need to do is compile this by
10:32 - running it through a compiler into
10:34 - something called bytecode so the first
10:36 - step when we're deploying this contract
10:38 - is we run this through a compiler this
10:40 - compiler is capable of taking one
10:42 - language and translating it into another
10:45 - and what we get here is now what i'm
10:46 - going to refer to as the bytecode
10:49 - now the bytecode is just a special type
10:51 - of code that the computer can actually
10:53 - understand and execute in almost every
10:56 - programming language what's occurring is
10:57 - you're taking source code you're
10:59 - compiling it into bytecode and then that
11:00 - bytecode is being interpreted by an
11:02 - interpreter the interpreter you can kind
11:04 - of think of as a mini computer in a
11:06 - sense that's actually going to be able
11:07 - to take all of this code read it
11:10 - understand it and then tell the cpu of
11:12 - your computer how to execute it the
11:14 - interpreter is typically known as a
11:16 - virtual machine anyways you don't need
11:17 - to know too much about that point being
11:19 - you take source code compile it into
11:21 - something like bytecode bytecode is then
11:24 - something that the computer can actually
11:25 - understand and execute and so that's how
11:27 - your code actually ends up running
11:29 - anyways at this point we now have our
11:31 - bytecodes we've taken our solidity code
11:33 - we've ran it through the compiler by the
11:34 - way remix will do this for us
11:36 - automatically so you don't need to
11:37 - manually compile the code and now we
11:39 - have our bytecode so let me just move my
11:41 - bytecode over here so now that we have
11:43 - this bytecode this is the code the
11:44 - ethereum network can understand and the
11:46 - computers can execute but how do i
11:48 - actually get this now to the blockchain
11:50 - well what i need to do is i need to
11:52 - create a transaction
11:54 - now i just want to quickly mention here
11:56 - that what a smart contract is is just
11:59 - code that's sitting on the blockchain so
12:01 - all we're doing is we're taking this
12:02 - bytecode
12:03 - we're putting this in a transaction and
12:05 - then this transaction is kind of special
12:07 - in the sense that it requests to create
12:10 - this code this smart contract on the
12:12 - ethereum network so what happens is we
12:14 - make a transaction
12:16 - we throw the byte code on this
12:18 - transaction we pay some fees and then we
12:20 - kind of upload this or send this in a
12:22 - way to the ethereum network okay so just
12:25 - like sending money between different
12:27 - accounts except in this case we're
12:28 - making a transaction that is adding this
12:30 - byte code as a smart contract to the
12:33 - ethereum network now like all other
12:35 - transactions the first thing that needs
12:36 - to happen here is this transaction needs
12:38 - to be associated with a block then it
12:40 - needs to be mined once it's mined then
12:42 - it's on the ethereum network now what
12:44 - that means is just like any other
12:46 - transaction anyone can go and see this
12:48 - they can see the transaction they can
12:50 - see who created the smart contract they
12:52 - can see all of the code of the smart
12:54 - contract they're able to view when you
12:56 - created it the balance of the smart
12:58 - contract all of these other things and
13:00 - this also means that once we add this
13:02 - smart contract to the network we can
13:04 - never change we cannot mutate it we
13:06 - cannot modify it we cannot change it or
13:08 - delete it and the reason for that is the
13:10 - same reason that we can't delete
13:11 - transactions on the ethereum network
13:14 - right
13:15 - because that's the way the blockchain
13:16 - works it is forever there it is a ledger
13:18 - of everything that has happened is
13:20 - completely transparent and trustworthy
13:22 - and that's actually the main point of
13:24 - our smart contracts so hopefully that
13:26 - makes a bit of sense we're going to
13:27 - continue to clarify this in this section
13:30 - point being is that the reason we create
13:32 - smart contracts is because we're taking
13:34 - advantage of the security features of
13:36 - the blockchain to make people trust the
13:39 - code that we are uploading so let's take
13:41 - an example where we want to write some
13:43 - type of poker application or a casino or
13:45 - something that involves money right
13:47 - something that's going to have money
13:48 - being transacted from either us to the
13:50 - client or from the client to us well if
13:53 - someone comes to our website or we go to
13:55 - some casino website for example
13:57 - most times we can't see the code right
13:59 - we have no idea what's actually
14:01 - happening in the back end we could
14:02 - easily be getting ripped off maybe our
14:04 - money's being stolen maybe the odds are
14:06 - not in our favor or less in our favor
14:08 - than they should be whatever if we can't
14:09 - see the code we don't really have any
14:11 - way to trust what this website is doing
14:14 - or how these transactions are occurring
14:16 - however if you had your code as a smart
14:18 - contract and you knew that the website
14:20 - was using the smart contract maybe
14:22 - you're able to verify that in some way
14:23 - then you could just go and read the
14:25 - smart contracts that were being used and
14:27 - decide if you want to interact with them
14:29 - or not
14:30 - this means you can fully and
14:31 - transparently see all of the code that's
14:33 - actually being ran and executed you know
14:36 - if you want to trust it or not and then
14:37 - you can decide if you want to interact
14:39 - with it right
14:40 - so hopefully that makes sense one
14:42 - important point there as well is that
14:43 - that code that you're looking at can
14:45 - never be changed which means if you're
14:47 - interacting with the same smart contract
14:49 - you know it's always going to look like
14:50 - that and it's always going to be
14:52 - trustworthy so that's kind of the main
14:54 - point of smart contracts is to allow
14:55 - people to trust the code to make it
14:57 - fully visible to everyone and also just
15:00 - to allow everyone to be able to use it
15:01 - right although i will say it is pretty
15:03 - expensive to be interacting with smart
15:05 - contracts and uploading them to ethereum
15:08 - okay that is the main point of smart
15:11 - contracts now one thing i'll mention as
15:12 - well is that smart contracts can have a
15:14 - balance so that means you can send money
15:16 - to a smart contract it can receive money
15:18 - it can send money back to you it can
15:20 - call other smart contracts and in fact
15:22 - we're going to start talking about that
15:23 - now so let me clear the screen and now
15:25 - we're going to talk about how you
15:26 - actually call a smart contract so in
15:28 - front of me i have a beautiful
15:30 - illustration i have a contract and two
15:32 - ethereum accounts now as i said briefly
15:35 - a contract can have a balance so just
15:37 - like an account a contract is going to
15:39 - have an address it's going to have some
15:40 - type of balance so we can actually store
15:42 - ethereum and it can send and receive
15:45 - ethereum as well so that means that the
15:47 - account too can send money directly to
15:50 - the contract the contract could send
15:52 - money back to it and again account one
15:54 - in account two i'm just treating as
15:55 - regular ethereum accounts so ones we
15:57 - already would have talked about anyways
16:00 - the contract has a balance and that
16:02 - means we can go and view the balance we
16:04 - can see every single call and
16:05 - transaction that's happened with the
16:07 - contract everything is completely
16:09 - transparent just like our other regular
16:11 - ethereum accounts
16:13 - great okay so now that we understand
16:15 - that i want to talk about the fact that
16:16 - a contract should really be treated like
16:19 - a state machine so what i mean by that
16:21 - is that most contracts are going to
16:22 - store some type of data so in this case
16:24 - we have x equals one now we need to
16:26 - think of this like the state of the
16:28 - contract and the reason for that is that
16:30 - these contracts are not constantly
16:32 - running they're not just always
16:33 - executing in the background they need to
16:36 - manually be triggered from a transaction
16:38 - to actually do something and so when
16:41 - they're not being called by a
16:42 - transaction they're simply some state
16:44 - that's sitting on the ethereum
16:46 - blockchain okay that's all they are we
16:48 - just have the code we have the values of
16:50 - the different variables so the state of
16:52 - the contract and we can access the state
16:54 - or request to change the state by making
16:56 - some type of transaction
16:58 - okay so let's see now how we actually
17:00 - call a smart contract because i keep
17:02 - saying this for it to do anything we
17:04 - need to call it so calling a smart
17:06 - contract is really just making a
17:07 - transaction that requests some operation
17:10 - be performed on the contract okay so
17:13 - from account two maybe we make a
17:15 - transaction so in fact let's just write
17:16 - tx here representing transaction and
17:19 - this transaction is going to the smart
17:20 - contract now usually what we do is we
17:23 - pick some type of method or some
17:24 - operation we're going to be performing
17:26 - on the contract so maybe we call some
17:28 - method here like set x and we pass value
17:31 - 2. now the smart contract can do
17:33 - whatever it wants in this method but
17:34 - maybe all it does is just change the
17:36 - state to 2 then what we would do is we
17:38 - would simply change this so now x is
17:40 - equal to 2.
17:41 - perfect now when we make this
17:43 - transaction just like any other
17:45 - transactions we need to sign it we need
17:47 - to secure it we're going to have a two
17:48 - address and a from address we're also
17:50 - going to have to pay a transaction fee
17:52 - which is going to be made up of gas now
17:54 - you can think of gas kind of like a
17:56 - literal gas in the real world in the
17:58 - sense that this contract requires gas to
18:02 - actually be able to execute code so
18:04 - every single operation this is going to
18:06 - perform is going to use a tiny bit of
18:08 - gas or it's going to use a little bit of
18:09 - gas and so we send what's known as a gas
18:12 - limit so the maximum amount of gas that
18:14 - we potentially want to use in executing
18:16 - this contract and then if that's enough
18:18 - gas the contract will actually be able
18:20 - to execute it will run through all of
18:22 - the code whatever it will have enough
18:24 - gas to do that it costs us ethereum
18:26 - essentially to execute code on the
18:29 - ethereum blockchain okay now the amount
18:31 - of gas you send and is required is going
18:33 - to depend on what the contract is doing
18:35 - some operations require a lot more gas
18:37 - than others anyways that's pretty
18:39 - complicated we don't need to talk about
18:40 - that for now but just understand that
18:42 - what happens is we're passing along gas
18:44 - and the gas allows the contract to
18:46 - actually execute if it runs out of gas
18:48 - just like a car it's not able to do
18:50 - anything else
18:51 - okay so that's it for calling contracts
18:54 - but now let's quickly talk about
18:55 - contracts calling other contracts
18:57 - because that is possible so let's say i
18:59 - have another contract right here and
19:01 - maybe this contract needs to interact
19:03 - with this one maybe it's going to call
19:05 - something on it's going to send ethereum
19:06 - whatever it's going to do so first of
19:08 - all that's fine these contracts can
19:10 - interact with each other they can only
19:12 - do that if this interaction starts from
19:15 - stems from is at the root of some
19:17 - account sending a transaction so these
19:20 - contracts if they have no transaction so
19:23 - imagine this guy's gone right here they
19:25 - can't do anything they cannot execute
19:27 - they cannot call each other they can't
19:28 - do anything at all they're just sitting
19:29 - there idle they are state machines
19:32 - however as soon as i have some
19:35 - transaction from any regular ethereum
19:37 - account that goes to a contract now this
19:40 - contract is capable of performing some
19:43 - operations executing some code whatever
19:45 - and calling other contracts it needs to
19:48 - start though from one of these main
19:50 - transactions there's no way for this
19:52 - contract to call the other contract
19:54 - unless we start from a transaction that
19:56 - i've showed you right here so all of
19:58 - this needs to kind of root from some
20:00 - transaction outside of the blockchain so
20:02 - what i mean by that is from some kind of
20:04 - regular ethereum account so hopefully
20:06 - that makes sense but again you can
20:08 - really think about this in the sense
20:10 - that these contracts are idle not doing
20:12 - anything unless they're called from
20:14 - outside of the main blockchain network
20:15 - right so from kind of a regular account
20:17 - and so if no account is calling any of
20:19 - these contracts they're not able to do
20:21 - anything and we also need gas which is
20:23 - going to be passed along with the
20:24 - transaction to the first contract call
20:27 - that we make all right so with that said
20:29 - i think that ends the theory section of
20:30 - this video i apologize if this was long
20:32 - but this really did need to be covered
20:35 - now we're going to get back to the code
20:36 - and i'm going to start showing you how
20:37 - to write more advanced smart contracts
20:40 - all right so i am back on the computer
20:42 - and now what i'm going to show you how
20:43 - to do is how to deploy the smart
20:45 - contract to a real ethereum network so
20:47 - we'll go with the test network right
20:49 - rather than the javascript vm which is
20:51 - going to emulate the blockchain in your
20:53 - browser so what i'm going to do here is
20:55 - change this to injectedweb3 now when you
20:58 - do that it's going to connect with
20:59 - metamask which i assume you already have
21:01 - set up and it's going to show you the
21:02 - test network that you have i guess
21:04 - enabled in metamask and the account that
21:07 - you're using for metamask so in this
21:08 - case i have my tutorial account that has
21:11 - a little bit less than one ether
21:13 - anyways in the same way that we deployed
21:15 - this when we were using the javascript
21:17 - vm we could just click deploy it will
21:19 - automatically compile this for us we
21:21 - don't need to manually compile and it's
21:23 - going to actually bring up metamask
21:24 - because we need to make a transaction to
21:26 - do this right we need to create the
21:28 - contract that requires a transaction
21:30 - so we can look at data this is going to
21:32 - have the contract data we're going to
21:33 - have our details that's going to tell us
21:35 - how much it costs now the bigger the
21:36 - contract is the more this would cost
21:38 - anyways this is relatively cheap i will
21:40 - click confirm
21:42 - okay now this is going to take a second
21:43 - and if i bring up this kind of you know
21:46 - terminal here console you're going to
21:47 - see it tells me that it successfully
21:49 - deployed the contract okay so you can
21:50 - view kind of i guess the output of all
21:53 - the transactions and contract calls by
21:55 - just bringing this terminal up right
21:57 - here
21:57 - anyways what we're going to see now is
21:59 - it shows my deployed contracts so this
22:01 - is my deployed contract now what i want
22:03 - to do is actually look at this contract
22:05 - so let's see how we can do that so what
22:07 - i'm going to do is go to metamask here
22:10 - i am going to go to the contract
22:12 - deployment which is right here okay and
22:15 - then you'll see that i can actually
22:16 - click on this button and it will allow
22:17 - me to view the transaction on etherscan
22:20 - now i had some other transactions there
22:21 - i was of course messing with this before
22:23 - the video so you can ignore those ones
22:24 - this is the one that we just crit
22:27 - anyways now we are in ether scan the
22:28 - goreli test network etherscan right and
22:31 - we can see we had our transaction it was
22:33 - successful and we have the from and the
22:35 - two now what i want to look at is the
22:36 - actual contract address so i'm going to
22:38 - click on that right there
22:40 - now it's going to bring me to the
22:42 - contract address on etherscan so i can
22:44 - see the balance i can see the content
22:46 - creator so this was me right i created
22:48 - this contract at this transaction and
22:51 - then it tells you that the content or
22:52 - the contract story was crit now we can
22:55 - look at the contract itself so we can
22:56 - actually view the byte code we can
22:58 - decompile that into the source code if
23:00 - we want and then we have events i'm not
23:02 - going to talk about that right now that
23:04 - will be in the next video
23:06 - anyways we can close that i just wanted
23:07 - to oops uh let's go back i just wanted
23:10 - to show you what that looks like uh okay
23:12 - so let's go back to remix
23:15 - all right so now that we have this
23:16 - deployed we can use the contract right
23:18 - so i can access the variable x that's
23:20 - fine it's going to give me the value 21.
23:23 - so one thing to note here is that when
23:24 - you're viewing the state of a contract
23:26 - so we're just looking at the value of x
23:28 - here right viewing the state this is
23:30 - free we don't need to do a transaction
23:32 - it's fine we can query the state that's
23:34 - a free operation and the reason for that
23:36 - is the state is available right like we
23:38 - can go look at the state of the contract
23:40 - because it's stored in there publicly
23:42 - available it's already on the blockchain
23:44 - so we don't need to do any computation
23:46 - we're just querying and viewing a state
23:48 - so that's completely free to do so
23:50 - that's why when i click x here i get
23:52 - this instantly and it gives me 21
23:54 - because i don't need to actually have a
23:55 - transaction mined to view the state the
23:57 - only transactions i need are when i'm
23:59 - modifying the state of this contract
24:01 - okay or performing some type of
24:03 - computation
24:04 - anyways what i want to do now is change
24:06 - the contract so we can actually update
24:08 - the value of x so this is where we'll
24:10 - talk about functions
24:12 - methods
24:13 - so what i can do is inside of this
24:15 - contract i can create a function this
24:17 - will be a kind of a method associated
24:18 - with the contract obviously i need to
24:20 - give this a name so i'll give it
24:22 - something like set x now for the
24:24 - parameters of this function i need to
24:26 - define first their type and then the
24:28 - name of the parameter so i'm going to
24:29 - say uint
24:31 - underscore x like that this will kind of
24:33 - be my new x value that i want to set x
24:35 - to
24:36 - then i need to give my access modifier
24:38 - for this function now the access
24:40 - modifiers essentially tell people trying
24:43 - to use the contract if this function is
24:45 - private if it is public if it's internal
24:48 - external i'll talk about what all of
24:49 - those mean but you need one of these
24:51 - here
24:52 - so i'm going to say public to define the
24:54 - fact that anyone can use this method so
24:56 - a contract any anyone calling this from
24:59 - a transaction is able to use this method
25:01 - because it's public same with this
25:03 - variable x now if we made x private for
25:06 - example you wouldn't be able to access
25:08 - the state of it at least not very easily
25:10 - because it would be private to the
25:11 - contract again we'll talk about access
25:13 - modifiers in a second for now though
25:15 - we'll just say function set x uint
25:17 - underscore x will make this public then
25:19 - i'm just going to say x
25:20 - is equal to underscore x
25:22 - okay so now when i call this function we
25:26 - will change x change the value and then
25:28 - when we access it again it will be
25:30 - different pretty straightforward
25:32 - okay so now that we've changed the
25:33 - contract we need to redeploy this i'll
25:35 - do this again to the goreli test network
25:37 - so i'll just click on deploy
25:39 - okay we're going to have to confirm the
25:41 - transaction
25:42 - and notice this time it's a bit more
25:43 - expensive we have more content in our
25:46 - contract and so it makes sense this is
25:47 - going to be more expensive right so i'm
25:49 - going to click confirm
25:50 - okay it's going to take a second and
25:52 - then once it's created we should be able
25:54 - to use it and i'll show you what happens
25:56 - when we actually modify x okay so the
25:59 - contract has been created i'm going to
26:00 - click right here
26:02 - and now we'll have a new contract so
26:04 - we'll look at that one in a second but
26:06 - for now what i can do is set x so if i
26:08 - look at x right now it's 21 that was
26:10 - free right i didn't have to pay for that
26:11 - i'm just viewing the state but now if i
26:13 - change the state to say 25 so let's set
26:15 - x notice i need a transaction okay so
26:17 - it's giving me a transaction
26:19 - and this is going to cost me a certain
26:21 - amount of gas right
26:22 - so i will click confirm now this is
26:24 - going to take a minute i need to wait
26:26 - for the transaction to be mined okay it
26:27 - was done pretty quickly now if i click x
26:30 - again its new value is 25. so i've
26:32 - modified the state of this contract okay
26:35 - hopefully that makes sense that kind of
26:37 - wraps up all the explanation in terms of
26:39 - how you call a contract what the state
26:41 - of the contract is all of that stuff now
26:43 - we're going to continue looking at some
26:44 - more solidity syntax all right so i've
26:46 - just cleared my code and changed the
26:48 - environment back to javascript vm now
26:50 - i'm going to talk to you about a few
26:51 - data types in solidity so the first one
26:54 - is uiint now we've already looked at
26:55 - this it stands for unsigned integer
26:58 - meaning we can store any positive whole
27:00 - number okay so i can do something like
27:02 - uint public x is equal to one of course
27:06 - we know that is valid
27:07 - now with the u int this actually allows
27:10 - us to specify the number of bytes we
27:12 - want to use to store the integer so i
27:13 - could do something like you went eight
27:16 - you went 16. you win 32 you and 64. unit
27:19 - 128 and then 256 and i believe 256 is
27:23 - actually the default so if you just
27:25 - write you int i think by default uses
27:27 - 256. i'll put something on the screen
27:29 - that confirms that or not now let's
27:31 - actually just see what happens
27:33 - if we try to store a negative number
27:35 - inside of a uint okay so let me just
27:37 - deploy this contract here we have our
27:39 - smart contract and notice that it's
27:41 - actually not even deploying this right
27:43 - because we would have seen the variable
27:44 - y because we have an error so it's
27:47 - deploying the last contract so the last
27:48 - one that we actually had compiled
27:51 - not this one because we have the error
27:53 - and it's showing that right here okay we
27:55 - cannot implicitly convert negative 1 to
27:57 - an unsigned integer
27:59 - now of course though
28:00 - we have regular integer right so a
28:02 - regular int allows us to store a signed
28:04 - number again just like the uint we can
28:07 - specify the number of bytes so 16 32
28:11 - 64 whatever now let's run to this one so
28:13 - deploy
28:14 - and let's see what we get here and now
28:17 - we have y so it actually deployed this
28:19 - contract and we can look at its value
28:21 - perfect okay so that is it now other
28:23 - than int we have a boolean
28:26 - okay so we can say something like
28:27 - boolean public y
28:28 - is equal to true let's deploy this
28:32 - now oops i want to close that let's look
28:34 - at this contract here click on y and
28:36 - notice we get true now of course other
28:37 - than true we have false i assume most of
28:40 - you know what the boolean data type is
28:42 - just note here there is a lowercase on
28:44 - the first letter rather than a capital
28:46 - if you're coming from python like me
28:48 - okay so we had int uint bool now we also
28:51 - have address address payable and mapping
28:54 - and a ton of other data types as well
28:56 - now i'm only going through these ones
28:57 - because these are kind of the core most
28:59 - important ones we're going to use right
29:00 - now there is strings there is arrays but
29:02 - those work really strangely in solidity
29:04 - compared to other languages so just be
29:06 - careful there if you're looking at say a
29:08 - string or an array there's a lot of
29:10 - nuances and kind of details with those
29:12 - okay for now though let's actually not
29:14 - to a string so let's actually just look
29:16 - at the mapping type so the mapping type
29:19 - allows us to take some key and associate
29:22 - it with some value so i'm going to say
29:23 - public and then we'll just call this map
29:26 - okay
29:27 - now what this means is that i can have
29:28 - some data type for the key and some data
29:30 - type for the value it's very similar to
29:32 - a dictionary or a hash table so when i
29:35 - define a mapping i need to pick the
29:37 - value for the key or the type sorry for
29:38 - the key and the type for the value so
29:40 - for right now i'm just going to say
29:42 - uiint
29:43 - like that is associated with it
29:46 - now just to show you how this works what
29:48 - i can do if i want to set a new mapping
29:50 - is i can say map and then i can put my
29:52 - key like this is equal to my value so if
29:55 - this was a real example i could do
29:57 - something like maybe the map of 1 is
29:59 - associated with the key of negative 2.
30:01 - now that means if i accessed map at 1 it
30:04 - would give me negative 2 okay so this
30:07 - allows you to associate some key with
30:09 - some value
30:11 - very useful you're going to use this all
30:12 - the time anyways that is a mapping again
30:14 - you put the type of the key and then you
30:16 - do it this little equal and i guess
30:18 - greater than sign or less than sign
30:19 - associated with whatever the value data
30:22 - type is
30:23 - so right now what i'm going to do is
30:24 - just make a function that lets us
30:26 - actually add a new key value pair to
30:28 - this mapping so i'm going to say
30:30 - function we'll say set key like that
30:32 - we're going to take in a uint key and
30:35 - we'll take in an int value
30:37 - okay and then we're going to say that
30:39 - this is public
30:40 - and inside of here we'll just say the
30:43 - map at key
30:45 - is equal to value okay
30:48 - now since this function is actually
30:49 - going to be changing the state of this
30:51 - contract that means we will require a
30:53 - transaction to use this
30:55 - excuse me but since we're in the
30:56 - javascript vm we don't need to do that
30:58 - because we're not actually on the
30:59 - blockchain anyways let me quickly go
31:01 - through the syntax so function keyword
31:03 - this lets us make a method or a function
31:05 - inside of the contract or inside of the
31:06 - class whatever you want to call it we
31:08 - then have set key this is the name of
31:10 - that function we have our parameters key
31:12 - and value and we're defining the type
31:14 - that is required for those we then say
31:16 - this is public meaning anyone can call
31:18 - it and we say map key equals value
31:21 - adding a new key value pair to our
31:23 - mapping
31:24 - okay let's deploy this okay so here's
31:26 - our contract let me open this up so we
31:28 - have set key and map now one thing to
31:30 - note is that automatically when you
31:32 - define a variable like this outside of a
31:34 - function so just in the body of the
31:36 - contract it's going to have a getter
31:38 - added for it automatically which means i
31:40 - can access any value in the map so i
31:42 - could do something like map 1 and we're
31:43 - going to see its default value is 0. so
31:46 - in solidity all of our data types have a
31:48 - default value so even though we didn't
31:50 - assign this to something we just
31:52 - declared that it exists if i try to
31:54 - access any key since the value type is
31:56 - int it's always going to give me 0
31:58 - unless we have a different value for
32:00 - that
32:01 - okay so let's just set a key
32:03 - let's set like five with
32:05 - actually let me do this let's set five
32:07 - with like negative 23
32:10 - i'll click on transact and now to test
32:12 - this i'll see if the key 5 is associated
32:14 - with negative 23 and it is so we're all
32:17 - good to go now let's do another one
32:18 - let's do like 4
32:20 - with negative 10
32:21 - okay transact let's go four
32:24 - and then notice we have negative 10.
32:26 - perfect there we go
32:28 - okay so now that we have done that
32:31 - what i want to do is talk about
32:32 - addresses and how we actually accept
32:35 - money in the contract as well as pay
32:37 - money out
32:38 - so let's get rid of all this for right
32:40 - now and let's start making some
32:42 - functions that can receive money and
32:43 - send money so what i'm going to do is
32:45 - write function
32:46 - we're going to call this receive and
32:48 - this is going to be an external like
32:50 - this
32:52 - payable function now let's talk about
32:54 - external because we haven't yet seen
32:56 - this so just like the public keyword
32:58 - that we had what external does is it
33:00 - makes it so that this can only be used
33:02 - from outside of the contract so i cannot
33:05 - call this function from within the
33:06 - contract if i did that that would give
33:08 - me an error and the reason for that is
33:10 - because we're going to be accepting some
33:12 - ethereum and when you define this as
33:14 - payable which is what i've done right
33:16 - here this means that we can actually pay
33:18 - money to this function when we call it
33:20 - okay hopefully that makes a little bit
33:22 - of sense we're saying function receive
33:24 - external payable meaning okay we can
33:26 - accept money and we can only accept
33:28 - money from outside of the contract so we
33:30 - can't call this from within the contract
33:32 - whenever you're accepting money you need
33:33 - to put payable when i say money i'm
33:35 - really talking about ethereum anyways
33:37 - inside of here we actually don't need to
33:39 - do anything we can just write the body
33:40 - of this function in fact that's
33:41 - completely fine and now what i'm going
33:43 - to show you
33:44 - is that what we can do is send money to
33:46 - this contract by calling this receive
33:49 - method because it's external pip so what
33:51 - i'm going to do is deploy this
33:53 - okay when i deploy it i'm going to have
33:54 - my contract down here and we have this
33:57 - receive function so when we click this
33:59 - red button here what's actually going to
34:00 - happen is we're going to send this
34:02 - amount of whatever this unit is so in
34:04 - this case it's way from this account to
34:08 - our contract okay
34:10 - so this function doesn't need any body
34:12 - if it's external payable that just means
34:14 - we can pay money to it and so what i'm
34:15 - going to do here is set this to like
34:17 - i don't know
34:18 - we'll go with 10 000 way now whey is the
34:21 - smallest amount of ethereum that you can
34:24 - send i believe 10 to the 18 way makes
34:27 - one ether so this is a very small amount
34:29 - anyways it's going to take it from this
34:31 - account in fact let's just send it from
34:32 - another account so that we can see if it
34:34 - actually worked let me make it a bit
34:35 - larger and when i click the button again
34:37 - it's going to send that amount from this
34:38 - account to the contract so let's do that
34:41 - and now notice this amount has gone down
34:43 - i have sent some way right
34:46 - there you go makes sense now there was
34:47 - also some gas associated with that
34:49 - that's why it's not perfectly even and
34:50 - the gas limit was right here
34:53 - okay awesome so we said function receive
34:54 - external payable now this contract
34:57 - technically has a certain balance it
34:59 - would be 10 000 way all right so now
35:01 - that we've looked at that i'm going to
35:03 - show you how we can actually view the
35:04 - balance of this contract from a function
35:07 - so i'm going to say function and then
35:09 - this is going to be get
35:11 - balance okay let's spell balance
35:13 - correctly and then we don't actually
35:15 - need anything inside of parentheses and
35:16 - what i can do is make this a public
35:19 - view
35:20 - that returns like this a uint
35:25 - and sorry not unit it's going to be a
35:27 - uiint and then we can actually write the
35:29 - body of our function
35:30 - now let me just talk about this view
35:31 - keyword because we haven't seen this yet
35:33 - view is saying that this is a read-only
35:35 - method or a read-only function which
35:37 - means it cannot modify the state of our
35:39 - contract so you need to add that when
35:41 - you're writing a function that's going
35:43 - to return a value that's not modifying
35:45 - the state okay
35:46 - that's what we're doing so public view
35:49 - returns you it now inside of here what
35:51 - i'm going to do is i'm going to simply
35:53 - return
35:55 - the address
35:57 - of this
35:59 - dot balance now let me talk about this
36:01 - for a second so return i mean pretty
36:03 - straightforward we're returning a value
36:04 - from the function now what address is
36:06 - doing is actually casting this which is
36:09 - referring to the contract itself to an
36:12 - address so this is the address type
36:14 - right we can use this to actually cast
36:16 - this the contract to the address and
36:19 - then on the address type we have balance
36:21 - balance is how much ether is in this
36:23 - account or in this case in this contract
36:25 - now previously you could just write this
36:27 - stop balance however in the new version
36:30 - of solidity what you need to do is
36:31 - manually cast this to an address so
36:33 - again this is giving us the address of
36:35 - the smart contract we're then getting
36:36 - the balance and then returning it
36:39 - awesome so let's deploy the contract and
36:40 - see if this works now so i'm going to go
36:42 - here i'm going to send some money to
36:44 - this contract first actually i'll go get
36:46 - balance when i run get balance notice
36:48 - that we have zero right there's a zero
36:50 - balance and let's now send some money so
36:53 - let's go from this account here and
36:55 - let's just send one ether
36:57 - okay so if i send one like that let's
36:59 - click receive
37:01 - click on get balance and then notice
37:02 - it's going to give me the balance in way
37:04 - okay if i wanted to convert that to
37:06 - ether i would need to divide it by 10 to
37:08 - the 18
37:10 - what do you call it whey or i guess i
37:11 - could just divide it by one ether
37:13 - anyways not super important
37:15 - point is that there you go that is how
37:17 - you get the balance okay so now that
37:19 - we've looked at that i want to talk to
37:20 - you about a few global keywords that we
37:22 - have access to in solidity from our
37:25 - smart contract so remember whenever the
37:27 - smart contract is running it's been
37:29 - initiated whatever it would have had to
37:31 - been called from a transaction so
37:33 - someone had to send the transaction they
37:35 - had to call a specific function or
37:37 - method and then maybe they sent some
37:38 - ether along with that so we actually
37:41 - have a way to access that information
37:43 - like who sent the transaction so what
37:45 - i'm going to do here is write a smart
37:46 - contract that keeps track of the last
37:48 - person to send it ether so i'm going to
37:51 - make a variable up here i'm going to say
37:53 - this is an address now again the address
37:55 - is just storing an ethereum account
37:57 - address right or the address for an
37:59 - ethereum account so that's the data type
38:01 - there we have access to things like dot
38:03 - balance on an address so i'm going to
38:06 - say address this is going to be public
38:08 - i'm going to say this is last sender so
38:10 - let's go last sender like that and for
38:13 - now we'll just make this equal to
38:14 - nothing okay so it'll have a default
38:16 - value i believe the default address is
38:18 - just a bunch of zeros okay
38:20 - then inside of receive i actually want
38:22 - to set this to be equal to wherever the
38:24 - last sender was so i'm going to say
38:28 - last sender is equal to and then this is
38:30 - where we talk about the global keyword
38:33 - message.sender
38:34 - so message is something that you can use
38:36 - to access all of the information about
38:38 - the transaction that was used to call
38:41 - this contract now other than
38:42 - message.sender we also have access to
38:45 - message.value now this is going to be
38:46 - the amount of ethereum that was sent
38:48 - with the transaction and we have access
38:50 - to message.gas as well so the amount of
38:53 - gas i believe that's remaining with this
38:55 - transaction okay so let's go and change
38:57 - this back to message.sender and now we
39:00 - can actually use this smart contract and
39:02 - see if it keeps track of who sent the
39:03 - ethereum so i'm going to deploy this
39:06 - okay so we should be deployed let's
39:08 - change to one of these fresh accounts
39:11 - and let's
39:12 - actually send one ether in the receiver
39:15 - okay
39:16 - so i'm going to send that one ethereum
39:17 - let's check the balance okay now the
39:19 - balance oh sorry this is wrong contract
39:22 - i want to use this contract okay let's
39:24 - send one ether
39:26 - okay so go receive now let's check the
39:28 - balance okay so we have one ether in
39:30 - here and now if i go last sender it
39:32 - gives me the address of the account that
39:34 - actually send this ethereum
39:36 - so now let's change this to be let's go
39:38 - with this account
39:40 - let's set in two ether okay get the
39:43 - balance we now have three ethereum
39:44 - inside of here and the last sender has
39:46 - now changed okay
39:48 - there you go that is how you keep track
39:50 - of the actual last sender of a theorem
39:53 - now what i would like to do is i want to
39:55 - show you how to send ethereum from the
39:57 - contract
39:58 - back to
39:59 - a different ethereum account okay
40:01 - because right now what's happening is
40:02 - we're sending ethereum to the contract
40:04 - but the contract's not sending anything
40:06 - back obviously that's not ideal we need
40:08 - a way to you know pay people back from
40:09 - the contract so let's do that so what
40:12 - i'm going to do is write a function i'm
40:14 - going to say function this is going to
40:15 - be pay this is going to be address
40:18 - payable adr and then this is going to be
40:21 - public
40:23 - like this
40:24 - and then payable now let's just quickly
40:26 - go through this so the reason i have the
40:28 - payable here is because whenever i want
40:30 - an address or whenever i want to be able
40:31 - to send ethereum to an address i need to
40:33 - specify it as payable so address payable
40:36 - is different than just regular address
40:38 - this actually allows me now to send the
40:40 - money to this account if i don't have
40:43 - payable then i won't have access to the
40:44 - methods i need for this address to send
40:47 - the money to so just make sure you put
40:48 - payable then we're going to have public
40:50 - payable now since this function is going
40:52 - to be paying money out it's payable if
40:54 - you're going to be sending money or
40:55 - receiving money you need payable and
40:57 - then of course this is public which
40:58 - we've already talked about so inside of
41:00 - here there's a few different ways that i
41:02 - can actually send ethereum now some are
41:04 - simpler than others unfortunately though
41:06 - there's a bunch that have kind of some
41:07 - issues with them and that are not
41:09 - recommended to use so the ones you
41:10 - should not use are the following adr dot
41:13 - transfer okay now i know i spelt that
41:16 - incorrectly but you should not be using
41:18 - transfer okay there's some problems with
41:19 - that i'm not really going to get into
41:21 - them and then we have dot send again
41:23 - there's some problems with this don't
41:24 - use this instead what you need to use is
41:27 - the most complicated one funny enough
41:29 - which is going to be something like this
41:30 - so let me just type it out then i'll
41:32 - explain it this is going to be bytes
41:35 - memory and then this is going to be data
41:37 - and this is going to equal to adr dot
41:40 - call
41:41 - and then we're going to say here that
41:43 - the value is equal to and whatever the
41:45 - amount of ethereum is we want to send
41:47 - and then we're going to call this with
41:49 - one argument
41:50 - okay
41:51 - i believe this is correct let me move
41:53 - this over a bit so we have some more
41:54 - room okay so function pay address
41:57 - payable adr public payable and then we
41:59 - have this kind of crazy line right here
42:01 - so first of all what this is going to do
42:03 - is it's going to decompose the return
42:05 - value of this into two variables first
42:08 - sent and then second bytes memory data
42:11 - now this first one right here is going
42:12 - to be a boolean variable telling us if
42:14 - this was successful so if it was
42:16 - successful this is going to be true
42:17 - otherwise it's going to be false there's
42:19 - a variety of reasons it could be
42:20 - unsuccessful one of them being you don't
42:22 - have enough money in the contract to
42:23 - send
42:24 - okay then we have bytes memory data now
42:27 - this is going to give us the data of
42:29 - this transaction now you don't really
42:31 - need to worry about this too much
42:32 - in fact i'm not really going to explain
42:34 - it but memory is specifying that we want
42:36 - to store this data which is a reference
42:38 - type in memory
42:40 - again i'm not really going to talk about
42:42 - this much more just write this for now
42:44 - we'll worry about this in a later video
42:46 - then what is this doing so what we're
42:48 - doing is we're saying address dot call
42:50 - okay and then inside of curly braces
42:52 - here we're passing the value which is
42:55 - the amount of ethereum we want to send
42:57 - now optionally we can actually choose
42:58 - the amount of gas that we want to send
43:00 - as well so forward with this transaction
43:03 - you don't need to do that you can just
43:04 - leave it to the default value which is
43:06 - what i'm going to do
43:07 - and then
43:08 - we call this whole thing with a string
43:11 - now this is going to be the message
43:12 - that's going to be sent
43:14 - to our uh what do you call it to our
43:16 - transaction or with our transaction so
43:18 - you don't really need to put anything
43:19 - here for right now it just requires one
43:21 - mandatory argument so that's why i put
43:22 - an empty string
43:24 - okay
43:25 - hopefully this makes a bit of sense
43:26 - again address
43:28 - dot call
43:29 - curly braces with the amount of ethereum
43:31 - that you want to send and then this is
43:32 - setting up the transaction and this is
43:34 - actually going to execute it when you do
43:36 - the kind of parentheses call right here
43:38 - with the string argument anyways what we
43:41 - can do after this is we can check if
43:42 - this was successful or not and the way
43:45 - we do that is we could use an if
43:47 - statement so if do exist in solidity or
43:49 - i could do something like if sent or i
43:51 - can use this fancy thing that we haven't
43:53 - seen yet called require now what require
43:55 - does is similar to an assert statement
43:57 - because it's going to check the value of
43:59 - a condition or a variable and if that's
44:01 - true we're going to continue everything
44:02 - will be fine if that's false it's going
44:04 - to throw an exception and actually tell
44:07 - whoever called this smart contract that
44:08 - there was an issue with that call so i'm
44:11 - going to say require sent and then here
44:13 - i can put an error message so i'll just
44:14 - say error sending money okay
44:17 - like that or error sending let's just go
44:19 - with f
44:21 - okay so again if this is true all is
44:23 - good we will continue if this is false
44:25 - then it's going to tell us that there
44:26 - was an error because we were
44:27 - unsuccessful in sending this ethereum
44:30 - all right now let's add our semicolon
44:32 - and what i can do is deploy this and
44:35 - test it out okay so let's go back here
44:37 - and let's deploy this let me close this
44:40 - contract
44:41 - okay so we have our deployed contract we
44:42 - have pay receive get balance and last
44:45 - sender so let us receive some money
44:47 - first so let's send one ether
44:50 - from this account so let's go receive
44:52 - okay last sender is this get balance is
44:55 - one now let's copy
44:57 - this guy's address right here by
44:59 - clicking on copy let's paste it in here
45:02 - let's click on pay and i think
45:04 - everything should be good we can go back
45:06 - here now
45:07 - and we can see uh if we were paid the
45:10 - ethereum or not all right so i thought
45:11 - something was going wrong until i
45:13 - realized that we actually are only
45:15 - sending a hundred way here rather than
45:17 - an entire ethereum which is what i
45:19 - thought we were going to be sending so
45:20 - what i'm going to do is change this to
45:22 - one ether now ether is actually a
45:24 - built-in word or built-in keyword in
45:26 - solidity and we'll just multiply this by
45:28 - 10 to the 18 so that will give me i
45:31 - guess 10 to the 18 way right so one
45:34 - ether anyways i'm gonna change that to
45:35 - one ether so now this will pay one ether
45:37 - from this function okay so let me
45:39 - redeploy here
45:41 - and let's close this
45:43 - okay and now we have our contract so
45:45 - let's receive some money so let's go
45:46 - from this account let's just send like
45:48 - five ether
45:50 - okay so let's go receive
45:52 - what's the balance
45:53 - five ether now let's copy one of these
45:57 - okay
45:59 - and we'll pay it
46:00 - and let's see if this is all good i'll
46:02 - move up the console
46:03 - and looks like it's sent fine okay
46:05 - so now let's go here and we should see
46:09 - that in one of these accounts we have
46:10 - okay almost 101 ether right so i have
46:13 - 100.99999 because there was gas
46:15 - associated with the transaction so we
46:17 - didn't get a full one ether we got a
46:19 - little bit less
46:20 - perfect there you go that is how you
46:22 - send money using i guess this right here
46:25 - using this line okay
46:26 - great so now that we have that what i
46:28 - want to do is i want to end by quickly
46:30 - writing kind of an example of a bank
46:32 - that allows people to send ethereum to
46:34 - the smart contract and then withdraw up
46:36 - to the amount of money that they had
46:38 - sent to the contract so if i send one
46:41 - ether i can withdraw up to one ether
46:43 - from the contract as soon as i try to
46:45 - withdraw more it's gonna tell me hey you
46:46 - don't have a sufficient balance so kind
46:48 - of just like a very simple bank account
46:50 - so let's go ahead and do that all right
46:51 - so let's get into this example of
46:53 - implementing kind of the basic bank
46:55 - accounts so i'm actually just going to
46:57 - get rid of all this we can just rewrite
46:59 - it this will be good practice so i'm
47:00 - going to start by making a mapping and
47:02 - this mapping is going to allow me to
47:04 - associate an amount of ethereum with an
47:07 - address so that way i'll know how much a
47:08 - specific account has sent so far and so
47:11 - i can regulate how much they can
47:12 - withdraw so what i'm going to do here is
47:15 - say
47:16 - mapping and this is going to go address
47:18 - like that and then this will go to an
47:21 - unsigned integer which will be the
47:23 - amount of way that they have sent so
47:25 - amount of ethereum okay then i will call
47:28 - this
47:28 - balances
47:30 - and i can actually manually make this
47:31 - private if i want now when i make this
47:33 - private what that means is there won't
47:35 - be a default getter for this so i can't
47:37 - easily just access the balance of a
47:39 - specific account
47:41 - instead i'll have to use one of the
47:42 - methods or functions that we define
47:45 - okay
47:46 - now we need some way to receive money so
47:48 - let's write that we're going to say
47:50 - function and we'll say deposit
47:53 - okay and then this is going to be a
47:58 - actually
47:59 - external
48:00 - and then payable
48:02 - okay now what i'm going to do is i'm
48:03 - going to say balances at and then this
48:06 - will be message.sender which is going to
48:08 - be the address of the sender of the
48:10 - transaction
48:11 - is equal to or sorry plus equal to
48:14 - message.value okay so remember all of
48:17 - the keys here are going to have a
48:18 - default value of 0. so even if this
48:21 - address doesn't kind of exist yet in the
48:23 - balances it's going to have a value of 0
48:26 - when i access it so i'm going to add
48:28 - message.value which is the amount of
48:30 - ethereum they deposit okay then of
48:32 - course if this already existed i would
48:33 - just be adding to it whatever the amount
48:35 - of ethereum is they deposited in this
48:37 - transaction that's all i need for here
48:39 - i'm just adding this to the balances
48:41 - then what i'm going to do is say
48:42 - function
48:44 - withdraw
48:46 - and this is going to need to take in an
48:47 - address to withdraw to and in fact i
48:50 - don't necessarily need to do that
48:52 - because what i could do is just use the
48:54 - message.sender address so whoever was
48:57 - withdrawn whoever sent the transaction i
48:59 - just automatically give the money to
49:00 - them but instead what i'll do here is
49:02 - just put in an actual parameter so that
49:04 - you could technically withdraw your
49:05 - money to someone else's account
49:07 - hopefully that makes sense but you'll
49:08 - see what i mean so i'm going to say
49:09 - address payable and then this will be
49:11 - adr and then we'll say this is going to
49:13 - be a public and then this will be a
49:17 - payable function like that
49:19 - okay so what i need to do here is i need
49:21 - to check that they have a sufficient
49:23 - balance in the uh the balances before
49:26 - they can withdraw something i also need
49:27 - to take in the amount that they're going
49:28 - to withdraw so i'm going to say uint
49:31 - amount like that and this will be the
49:32 - amount in way that they want to take
49:35 - okay so we'll say withdraw payable
49:37 - amount okay great that's fine now inside
49:40 - of here what i'm going to do is i'm
49:41 - going to confirm that they have a
49:42 - sufficient balance before i let them
49:44 - withdraw so i'm going to say require
49:47 - and i'm going to say balances at addr
49:50 - is greater than or equal to the amount
49:53 - that they want to take out
49:55 - okay perfect so we'll do that then i'm
49:57 - actually going to send the ethereum to
49:59 - them that they want to withdraw so we're
50:02 - going to say
50:04 - i guess this is going to be bool
50:06 - sent and then this will be
50:08 - byte
50:10 - memory and then what was this data
50:13 - is equal to and then addr dot call and
50:16 - then this is going to be value colon
50:19 - amount
50:20 - okay and then i think i can just call
50:23 - this like that
50:25 - okay so that's good now that i have that
50:28 - i'm going to confirm that they sent it
50:29 - successfully so i'm going to say
50:31 - require
50:33 - sent
50:33 - and we'll say
50:36 - could
50:38 - not withdraw okay we got to spell this
50:41 - properly this is just okay there we go
50:43 - could not withdraw and then what i'm
50:46 - going to do here after i successfully
50:48 - check if they withdrew or not or after i
50:50 - check that they successfully withdrew
50:52 - i'm going to subtract their balance so
50:53 - i'm going to say balances and then this
50:55 - is going to be at message.sender
50:59 - minus equals the amount
51:01 - okay i think that should be good now
51:03 - let's just run through this and make
51:04 - sure we understand so first we're
51:06 - requiring that their balance is greater
51:09 - than the amount so if the balance that
51:10 - they currently have in our kind of bank
51:12 - here is not greater than the amount then
51:14 - we actually need to give them an error
51:16 - message and we'll say in
51:18 - sufficient
51:20 - funds like that okay i think that's how
51:22 - you spell insufficient that should be
51:24 - fine all right and then what we're doing
51:25 - is we're trying to actually send this
51:27 - amount to them so if they have a
51:28 - sufficient balance we'll try to send it
51:30 - to them if this for some reason does not
51:32 - work then we'll tell them they could not
51:33 - withdraw and we'll keep the balance here
51:35 - right because if we didn't send it then
51:37 - the balance is not gone we still have
51:39 - the money in the contract
51:40 - otherwise we will subtract their balance
51:43 - and then we're good to go okay so now we
51:45 - have deposit and withdraw and if we want
51:47 - to we can write one more function here
51:49 - let's go function get
51:51 - balance and this will just give us the
51:53 - balance of a contract okay so let's
51:56 - just go
51:58 - public
51:59 - view
52:00 - returns
52:02 - uint okay and then let's return
52:06 - the address
52:07 - of this
52:09 - dot balance
52:11 - and that should be good
52:13 - okay now we could also write something
52:15 - that allows us to get the the balance of
52:17 - a specific address or we could just make
52:19 - this public but for now i'm going to
52:20 - leave it private
52:22 - okay hopefully that is all good now what
52:24 - i'm going to do is just deploy this
52:25 - contract so let's deploy it let me get
52:28 - rid of this one now what we can do is
52:29 - deposit some money so let's go to this
52:32 - account let's deposit 10 ether okay so
52:34 - we're going to deposit
52:36 - that should have happened successfully
52:38 - let's check the balance looks like we
52:39 - have 10 ether now let's see if we can
52:41 - withdraw so let me copy this
52:44 - address okay so i'm going to paste that
52:47 - in there in fact let's make this larger
52:49 - and for the amount i wish i could copy
52:51 - this uh let's just go
52:53 - with a bunch of zeros here i don't think
52:55 - i can write f directly in here otherwise
52:57 - that would be useful okay so let's click
52:58 - on transact and let's look at our
53:01 - console here and see if this was good
53:02 - okay it looks like we successfully sent
53:04 - the way so now if we go we see we have
53:06 - 85 ether rather than 84 which is what we
53:08 - had before so let me see if i can make
53:10 - this something like 5 now and click
53:12 - transact okay looks like that was
53:14 - successful i guess we're not passing
53:15 - enough zeros okay now we have 85.59
53:19 - okay now let me try to send
53:21 - an entire five ethereum which we know we
53:23 - don't have for this person
53:25 - actually maybe we do because i think we
53:27 - transacted 10 of theorem sorry but let's
53:28 - try this okay transact and that was
53:31 - successful now let's try this again and
53:33 - notice that when i try to do it again i
53:34 - don't have enough ethereum for this
53:36 - balance so i get insufficient funds as
53:38 - my error message
53:40 - okay if i look at the balance of here we
53:42 - have 4.4 ethereum left in the contract
53:46 - so now let's try to do this from another
53:48 - account so let me copy this address and
53:50 - let's see what happens if i try to
53:52 - withdraw
53:53 - say one ethereum
53:55 - from this address
53:56 - okay if i do that notice we get an error
53:58 - it says insufficient funds because this
54:00 - address has not yet deposited any
54:02 - ethereum so let's now deposit some so
54:04 - let's make this one ether
54:07 - let's click deposit okay now let's try
54:09 - to withdraw and notice we were able to
54:10 - withdraw that successfully all right so
54:12 - that is all i have to show you for this
54:14 - example here hopefully that was a decent
54:16 - introduction to solidity i understand
54:18 - there was a lot of stuff covered in this
54:20 - video i don't expect you to know all of
54:22 - it i just wanted to kind of show you how
54:24 - to create a basic smart contract how to
54:26 - send ethereum receive ethereum and then
54:28 - hopefully give you a bit of an idea
54:29 - behind the theory of how smart contracts
54:32 - actually work in the next video we're
54:34 - going to continue learning more about
54:36 - solidity i'm going to show you some more
54:37 - advanced things that we can do and then
54:39 - in future videos we'll talk about some
54:40 - of the limitations of solidity and how
54:42 - to make things more affordable using
54:44 - cartesi which is the sponsor of this
54:46 - video and this series hope you guys
54:48 - enjoyed if you did make sure leave a
54:49 - like subscribe to the channel and i will
54:51 - see you in another one
54:54 - [Music]