00:00 - hello everybody and welcome to video 4
00:02 - in this tutorial Series where we'll be
00:04 - continuing from where we left off and
00:06 - coding the rest of the back end now I'm
00:08 - inside of the main.py file so make sure
00:10 - you navigated there in the previous
00:13 - video we handled all of the routing so
00:15 - now all we need to do is actually write
00:17 - the individual functions now I think it
00:19 - makes sense just to start by writing the
00:21 - create challenge function and then we
00:22 - can go through accept reveal and then
00:24 - finally get challenges now first things
00:27 - first I just want to declare a few
00:29 - Global variables here that we're going
00:30 - to need to use throughout the rest of
00:32 - the code so the first variable we'll
00:34 - need is called challenges and this going
00:36 - to allow us to store all of the
00:38 - different challenges that are going on
00:40 - so we'll have challenges is equal to an
00:42 - empty dictionary and then we will have
00:44 - player uncore challenges is equal to a
00:48 - dictionary as well now this will store a
00:49 - key value pair which will have the
00:52 - player's address associated with the
00:54 - challenge they're currently in this way
00:56 - we know if a player is in a challenge
00:58 - and we can only allow them to be in one
00:59 - challeng challenge at a time at least
01:01 - that's what I'm going to do now I'm also
01:02 - going to have next ID equal to zero now
01:05 - this is just going to keep track of what
01:07 - the next ID of a newly created challenge
01:09 - should be so that all of these
01:10 - challenges have a unique identifier now
01:13 - notice here that these Global variables
01:15 - are actually like the state of our
01:17 - application if you've ever worked at
01:19 - solidity before you know that you have
01:21 - state variables or storage variables and
01:23 - that's exactly what these are in Python
01:25 - any Global variables or really any
01:27 - variable at all that we have stored in
01:29 - some glob context will just be here
01:31 - forever so this acts kind of just like
01:33 - storage or state and there's not as many
01:35 - restrictions on this as there would be
01:37 - in something like solidity okay so let's
01:40 - go over to create Challenge and the
01:42 - first thing we need to do when we're
01:43 - creating a challenge is we need to
01:45 - actually get the commitment from the
01:48 - user who created this challenge so to do
01:50 - that we're going to say commitment is
01:53 - equal to payload doget and then we're
01:57 - going to try to get the key commitment
02:00 - now I spelled that incorrectly so let's
02:01 - spell that correctly remember that
02:03 - payload is the data that's been sent in
02:06 - now inside of the payload we have a
02:08 - method and we could have some other data
02:10 - as well now what I'm going to say is
02:11 - when we're creating a challenge we want
02:13 - the user to send us their commitment
02:15 - which is that secret string so we're
02:17 - going to check the payload and see if
02:19 - that commitment is inside of there and
02:21 - if it's not inside of there we're going
02:22 - to tell the user so we're going to sa
02:24 - not Commitment Report no
02:28 - commitment okay so like that and then
02:34 - return reject now we're going to do this
02:37 - add report so that's spelled correctly
02:39 - okay so that's good next thing is we
02:42 - need to make sure that the player that's
02:44 - trying to create this challenge is not
02:46 - already inside of a challenge so we're
02:48 - going to say if player
02:51 - challenges. getet the sender which will
02:54 - be the key of the player and we're going
02:56 - to say if that is not equal to none then
02:59 - we will add a report and we will say
03:02 - player is already in a challenge and
03:06 - then again we will return reject because
03:09 - an error occurred okay so at this point
03:12 - we've checked the two preconditions
03:13 - we've made sure that they sent us a
03:15 - commitment and they're not already in a
03:17 - challenge now what we need to do is make
03:19 - a new challenge and Associate it with
03:20 - that player so we're going to say
03:22 - challenge is equal to challenge remember
03:25 - we imported this at the top of our
03:26 - program and if we go back to challenge
03:29 - we can see that we need the Creator
03:31 - address the ID and the commitment for
03:33 - this challenge so we're going to say
03:35 - sender we're going to say next ID and we
03:39 - are going to say commitment like that
03:41 - now that we've created The Challenge we
03:42 - actually need to store it so we're going
03:44 - to say challenges at the next ID is
03:48 - equal to this challenge that we store it
03:51 - inside of that dictionary and we're
03:52 - going to say player challenges at sender
03:56 - is equal to the next ID so this is
03:58 - indicating this player is currently
04:00 - associated with this challenge then
04:02 - we're going to add a notice this notice
04:04 - again will be verifiable on the
04:06 - blockchain and something that we kind of
04:07 - want to spit out in log and say okay
04:09 - someone created a new challenge so we're
04:11 - going to make an FST string and we're
04:12 - going to say challenge with id
04:16 - nextore id was created by and then this
04:23 - will be the
04:25 - sender okay then lastly what we will do
04:28 - is we will say next ID plus equal 1 and
04:31 - we're just going to Global next ID
04:34 - here and what that will do is allow us
04:36 - to actually increment this value so the
04:38 - next time we make a challenge the ID is
04:40 - plus one right so it's a new ID we have
04:43 - a unique ID for that challenge make sure
04:44 - you add this otherwise you'll only ever
04:46 - be able to have one challenge at a time
04:48 - okay so that's all we need for creating
04:50 - a challenge if someone calls this
04:51 - successfully it will make a new
04:53 - challenge again assuming they're not
04:55 - already in one and they sent us a valid
04:57 - commitment okay so now we'll go over to
04:59 - accept challenge now if a player wants
05:01 - to accept a challenge we need to know
05:03 - first of all what challenge it is that
05:05 - they're accepting and they also need to
05:06 - send us a commitment so what we can do
05:09 - is a similar thing to what we had before
05:11 - we're just going to copy this line here
05:13 - so commitment and we also going to look
05:16 - in the payload and get the ID of the
05:18 - challenge so we're going to say
05:19 - challenge uncore ID is equal to payload
05:24 - doget and then challenge ID okay so
05:28 - again we want them to send us commitment
05:30 - and the challenge ID so now what we'll
05:32 - also do is we'll say that the challenge
05:35 - they're referring to is equal to
05:37 - challenges doget and we will try to get
05:40 - the challenge with the challenge ID that
05:42 - they sent and then we will check if that
05:44 - challenge exists so we'll say if not
05:47 - challenge add a report and this will say
05:51 - challenge does
05:53 - not exist and then we will return reject
05:58 - otherwise we will we will say if not
06:02 - commitment okay then we will say add
06:07 - report
06:09 - no
06:11 - commitment okay and return reject and
06:15 - then lastly we'll do the exact same
06:16 - thing here so we're just going to copy
06:18 - this line and paste this here and make
06:21 - sure that this player is not already
06:23 - inside of a challenge okay recapping we
06:25 - get their commitment we get the
06:27 - challenge ID we see if there is actually
06:29 - a challenge with that ID so that's what
06:31 - we're checking here we make sure that
06:33 - they have a commitment and we make sure
06:34 - they're not already inside of a
06:35 - challenge now at this point we pass all
06:37 - the preconditions so we can actually add
06:40 - them to our challenge so we're going to
06:41 - say
06:42 - challenge. add opponent because now we
06:46 - know this is a valid challenge because
06:47 - it does exist now to add an opponent we
06:50 - need the sender and we need the
06:52 - commitment remember if we go back to
06:54 - challenge here we have a method add
06:56 - opponent right this just adds them in
06:58 - and kind of accepts the challenge so we
06:59 - need to pass the address in the
07:01 - commitment which is what we do now after
07:04 - we do that we need to add this challenge
07:05 - to them so we'll say player challenges
07:08 - at sender is equal to the challenge ID
07:12 - that they submitted okay and then we
07:14 - will add a notice this again will be an
07:17 - FST string and we will say challenge
07:19 - with
07:20 - ID and this is the challenge ID was
07:25 - accepted by the sender of this uh what
07:30 - do you call transaction okay so that is
07:32 - all we need for accepting the challenge
07:34 - get the commitment get the challenge ID
07:36 - check our preconditions add the player
07:38 - to the challenge and at this point in
07:39 - time if someone has accepted the
07:40 - challenge both the commitments are there
07:43 - and the next thing we need to do is
07:44 - actually reveal what the answers are now
07:47 - there's a bit more to this because this
07:48 - reveal function will also need to
07:50 - determine the winner once uh both
07:52 - players have revealed their answer so
07:54 - let's go inside of reveal and start
07:55 - coding this out first thing we need to
07:57 - do with reveal is we need to get the
07:59 - move and we need to get the nons that
08:01 - the player is submitting so we can
08:02 - verify if that actually matches with
08:05 - what their commitment was so we're going
08:07 - to say move is equal to payload
08:10 - doget move and we're going to say the
08:14 - not is equal to payload
08:17 - doget and then not like that okay then
08:21 - we're going to say the challenge ID is
08:24 - equal to player challenges doget and
08:27 - then sender so we're going to say if
08:30 - challenge ID is none then add a report
08:35 - did not mean to do that there and this
08:38 - will
08:39 - say challenge does not exist and then we
08:44 - will return reject remember that when we
08:47 - need to reveal we need to get the move
08:49 - and the kns we then hash that and check
08:51 - that against the commitment and ensure
08:52 - that the player uh did not lie and that
08:54 - they are actually telling us the correct
08:56 - move that they committed to previously
08:58 - now what I do is I just make sure or I
09:00 - check sorry the challenge that the
09:02 - player is currently a part of by getting
09:03 - it from the player challenges if they're
09:05 - not a part of a challenge and they have
09:07 - no move to reveal so we simply reject
09:10 - okay so now we're going to say challenge
09:12 - is equal to challenges do get and then
09:16 - challenge ID that's so we have access to
09:18 - the challenge object now I'm going to
09:20 - put a try and accept block and I'm going
09:23 - to accept an exception as e because
09:26 - there's many exceptions that could occur
09:28 - in what I'm about to do
09:29 - and just down here inside of my accept
09:32 - I'm going to add a report and I'm going
09:33 - to say error colon plus the string of e
09:39 - like that and I'm going to return reject
09:43 - so this way we're just capturing any
09:44 - errors and just putting those inside of
09:46 - a log uh what is the error here e is not
09:48 - defined okay that's fine once we write
09:50 - the try this should be good okay so
09:52 - we're going to try to reveal the move so
09:56 - we're going to say challenge. reveal and
09:59 - then we're going to pass the sender the
10:01 - move and the knots if we go to challenge
10:05 - and we look at reveal wherever I have
10:08 - that so it's right here we take the
10:09 - address the move and the Nots so that's
10:11 - exactly what I'm doing now notice inside
10:13 - of here an exception is raised if the
10:14 - move does not match so that's why I'm
10:16 - handling the exception here if they
10:18 - submit us the wrong move now what I'm
10:20 - going to do if this works
10:21 - successfully is I'm going to add a
10:24 - notice this will be an F string again
10:26 - I'm going to say
10:28 - challenge
10:29 - challenge ID and this will
10:33 - be the sender revealed their move of and
10:38 - then what we want to do is convert their
10:40 - numeric move to string move so we can
10:42 - read it in the logs so we're going to
10:44 - say move. move to
10:46 - string the int of the move okay if we go
10:51 - back here to move just to show you we
10:53 - have this method right move to string
10:55 - takes in an integer representing the
10:57 - move and then gives us the string
10:58 - representation
10:59 - so what we're doing is just using that
11:00 - so that we can print out the player had
11:02 - a move of rock or paper or scissors not
11:05 - 1 two or three okay now that we've done
11:08 - that what we need to check is if both
11:11 - players have revealed their answer
11:12 - because if they have we need to actually
11:14 - determine the winner so we're going to
11:16 - say if challenge Dot and this is both
11:20 - underscore
11:22 - revealed then what we're going to do is
11:24 - evaluate the winner so we're going to
11:25 - say winner is equal to challenge Dot
11:29 - valuate winner like that and we will
11:32 - kind of add some notices to tell the
11:34 - users who won so we'll say if not winner
11:37 - so if there was no winner that means it
11:38 - was a draw right so we'll just add
11:40 - notice and we'll say F and this will be
11:44 - Challenge and then we're going to put
11:45 - the ID so what is this the challenge ID
11:49 - ended in a draw okay otherwise if there
11:53 - was a winner then we're going to say add
11:56 - notice we're going to say f
12:00 - challenge challenge
12:02 - ID was one by and then this will be the
12:07 - winner okay so we'll just print out with
12:08 - the Winner's address is sweet then we
12:11 - can go here and we can return accept but
12:14 - we're going to do that make sure it's
12:16 - outside of the if statement otherwise
12:17 - you're going to get an error if you
12:18 - don't have any return so we need this
12:20 - kind of outside of the if statement here
12:22 - okay so let's quickly go through this
12:25 - get the move get the kns make sure the
12:27 - player is inside of a challenge
12:29 - get the challenge attempt to reveal the
12:31 - move if an error occurs we'll handle
12:32 - that here let me just get rid of that
12:34 - accept statement down there we don't
12:36 - need that inside of here reveal the move
12:39 - add a notice with what the move was
12:42 - check if both the players have revealed
12:43 - if they have then we can evaluate the
12:45 - winner if there is no winner it means
12:47 - it's a draw so we say that and if there
12:49 - was a winner we just indicate the winner
12:51 - now last thing we need to do here is
12:52 - simply delete the challenge or remove it
12:55 - from the players that um are playing
12:57 - inside of the challenge so I'm just
12:58 - going to going to make a little helper
12:59 - function here and I'm going to say
13:01 - Define delete challenge this will just
13:04 - take in the challenge ID so what we can
13:07 - write here is if the player
13:11 - challenges
13:13 - doget and this
13:15 - is challenge Dot and the opponent uncore
13:21 - address so we're going to say if that is
13:24 - not equal to none then we will simply
13:27 - delete this so let's go D and take this
13:31 - now let me just quickly explain why
13:32 - we're doing this so our player
13:33 - challenges we have an address associated
13:36 - with an ID right so what we're doing
13:38 - first of all is we're just making sure
13:40 - that the address we're about to delete
13:42 - here exists because if we run this code
13:44 - and it doesn't exist inside of the
13:45 - dictionary we'll get an error so we say
13:47 - if player challenges doget the
13:49 - challenge. opponent address I'm just
13:51 - checking the opponent first next I'll
13:53 - check the check the Creator stor if it
13:55 - does exist we'll simply delete that from
13:57 - the dictionary now we can can copy
13:59 - this and paste this down here and we'll
14:02 - do the same thing except now it'll just
14:04 - be the Creator
14:06 - address and then Creator address like
14:08 - that okay so all this is doing is simply
14:10 - removing the challenge associated with a
14:13 - player from this player challenges
14:15 - dictionary which we have up here as a
14:17 - global variable so now what we'll do is
14:20 - we'll go into the reveal and when we do
14:24 - have a winner right so when both players
14:27 - are revealed then we will go and we'll
14:30 - say delete Challenge and we'll pass in
14:34 - our challenge now notice the indentation
14:36 - levels here they're quite important we
14:38 - want to make sure we only have delete
14:39 - challenge inside of if they are both
14:42 - revealed okay if we don't have that
14:44 - we're going to get an error because if
14:45 - we put it here once one player reveals
14:47 - then we'll delete the challenge and then
14:49 - that will cause errors for us so we got
14:50 - to make sure it's inside the right
14:51 - indentation level okay now that we have
14:55 - reveal and we've deleted and we've
14:57 - cleaned everything up we want to write
14:59 - get challenges then that will actually
15:00 - be all of the code we need for the back
15:02 - end and then what we'll do is we'll
15:03 - start writing the front end so that we
15:05 - can actually test this code it's a lot
15:07 - easier to test it once we have our own
15:09 - custom front end so we'll spend a bit of
15:11 - time setting that up I know it's kind of
15:13 - annoying to write a lot of code and not
15:14 - test any of it but in this instance we
15:16 - actually need to kind of write the front
15:18 - end to be able to interact with this in
15:20 - a way where we can actually test it
15:22 - anyways for get challenges what we want
15:25 - to do is we want to list all of the
15:28 - different Challen
15:29 - and we want to give some meaningful
15:30 - information about them so we're going to
15:33 - start by say challenge Keys is equal to
15:37 - challenge. Keys okay this just gives us
15:40 - all of the IDS of the challenging keys
15:43 - or the challenges Keys okay so
15:45 - challenges. keys we're then going to say
15:48 - the challenge list is equal to and this
15:53 - will be an empty list now what I need to
15:55 - do is I essentially need to parse
15:57 - through all of my challenges and convert
15:59 - them to some kind of Json serializable
16:02 - object so something like a python
16:03 - dictionary so that's what I'm going to
16:05 - do here I'm going to say for challenge
16:08 - ID in challenge keys I'm going to get
16:12 - the challenge I'm going to say challenge
16:14 - is equal to challenges doget and then
16:18 - challenge ID and then I'm going to get
16:20 - the opponent move the Creator move and
16:23 - I'm going to kind of make a list of all
16:25 - of the information we'd want to know
16:26 - about a specific challenge so I'm going
16:28 - to say opponent move is equal to
16:32 - challenge do
16:35 - commitments doget okay and then I'm
16:38 - going to say
16:40 - challenge. opponent uncore address I'm
16:44 - then going to say the Creator move is
16:48 - equal to
16:50 - challenge. commitments. get and then the
16:54 - challenge. Creator address so just a
16:58 - show you why I'm doing this if we go to
17:00 - challenge you can see that we have this
17:02 - dictionary here right inside of this
17:04 - dictionary we have an address associated
17:06 - with a move so what I'm doing is I'm
17:08 - just getting this move object here when
17:11 - I access these right here okay so now
17:14 - that I have that I'm going to go down
17:16 - here and I'm going to say challenge unor
17:20 - list. append and I'm going to put inside
17:23 - of here a dictionary that contains all
17:25 - of the information that I want so I'm
17:26 - going to say the challenge ID is equal
17:29 - to the challenge ID I'm going to say the
17:32 - Creator is equal to the challenge.
17:36 - Creator address I'm going to say the
17:42 - opponent is equal to the
17:46 - challenge. opponent address Okay so
17:50 - we've got the Creator we've got the
17:52 - opponents I'm going to say the winner is
17:55 - equal to the challenge. winner because
17:57 - we'll have that information
17:59 - stored then I'm going to say opponent
18:02 - committed and this is going to be equal
18:05 - to
18:06 - challenge. has
18:10 - underscore ponent underscore committed
18:14 - now I know I spelled that incorrectly uh
18:18 - I'll have to fix that let's go over here
18:19 - though and have a look at this method so
18:22 - has opponent committed okay so I'm just
18:24 - going to copy that and paste that here
18:26 - so this going to tell us okay do do we
18:28 - currently have another player or is this
18:31 - challenge still open to be accepted by
18:33 - someone then we're going to have
18:36 - opponent move and this is going to be
18:39 - equal to the opponent move do move if
18:42 - the opponent move otherwise none so what
18:45 - I'm really saying here is I only want to
18:46 - try to access this move if the opponent
18:50 - has made a commitment and they actually
18:51 - have a move otherwise if the opponent
18:54 - move doesn't exist so if they haven't um
18:56 - kind of accepted this challenge yet if I
18:58 - try to access do move that's going to
19:00 - give me an error so I need this little
19:01 - inline if statement here where otherwise
19:03 - I just display none okay now we'll do
19:06 - the same thing for the Creator move so
19:08 - we'll say this is simply going to be
19:10 - equal to the Creator move do move the
19:13 - reason why I don't need the if statement
19:14 - is because I know that this will always
19:16 - exist because to create a challenge you
19:17 - must submit a move perfect so now
19:21 - outside of the for Loop what I'm going
19:23 - to do is I'm going to convert this list
19:25 - that contains all of these dictionaries
19:27 - into a Json object that I can actually
19:29 - return from my code so I'm going to say
19:31 - output is equal to json. dumps which
19:35 - stands for dump string and I'm going to
19:37 - put
19:39 - challenges like this and it's going to
19:41 - be associated with the challenge list
19:44 - then I'm going to add a report and I'm
19:46 - simply going to add the report which is
19:48 - this output and then return accept Okay
19:51 - so let me just break this down a little
19:52 - bit remember that we're going to be
19:54 - returning and receiving Json okay
19:56 - JavaScript object notation I need to
19:58 - make sure that anything I return from my
20:00 - code is Json serializable so it's not
20:03 - possible for me just to return the kind
20:05 - of challenges dictionary because that
20:07 - contains python objects like challenge
20:10 - move Etc that don't have a known way to
20:13 - be serialized serialize just means
20:15 - converted into Json essentially so what
20:17 - I'm doing is I'm kind of just manually
20:19 - converting them into Json and Json is
20:22 - any valid types right so in our case
20:24 - valid types are like strings integers
20:27 - booleans numers Etc right so that's what
20:29 - I'm doing here and that's why I had to
20:31 - kind of parse through these different
20:32 - dictionaries to make sure I got all of
20:34 - the values that we can actually put
20:35 - inside of a Json object anyways we add
20:38 - all of our challenge objects here into
20:40 - the challenge list we convert them to
20:42 - Json and we simply make a report that
20:44 - the user will be able to access when
20:46 - they call this function okay so that's
20:49 - pretty much it that actually wraps up
20:51 - the entire backend now that we have the
20:53 - back end done I want to start writing
20:55 - the front end so we can actually
20:56 - interact with our backend end now one
20:59 - thing to note is that if we make any
21:00 - changes here in our backend we do need
21:02 - to rerun this now there is a command
21:04 - from the caresi documentation that will
21:06 - automatically reload it but I'm just
21:08 - going to rerun the back end and you can
21:10 - see that we actually got an issue here
21:11 - it says Dell player challenges dog get
21:13 - okay well that makes sense so let's go
21:16 - fix these issues really quickly so I
21:18 - have this the reason why I'm getting
21:20 - this is because I'm using doget what I
21:22 - need to do instead is I just need to put
21:24 - these in square brackets so that I'm
21:26 - actually deleting the key inside of the
21:28 - dictionary okay so hopefully that's
21:30 - going to work probably we'll have some
21:32 - other errors as well but let's run this
21:34 - now uh and see if we get any issues okay
21:36 - looks to be fine and we'll see when we
21:38 - interact with it if any problems occur
21:40 - okay so I just reran this now the back
21:42 - end is finished and we want to write the
21:44 - front end now what we'll do just to make
21:46 - our life a little bit easier is if we go
21:49 - here inside of the cartei rollups uh
21:52 - what do you call this repo we'll see
21:54 - that there is a frontend echo now this
21:57 - frontend EO is just written by cesia it
21:59 - already contains a few dependencies and
22:01 - this allows you to interact uh with your
22:04 - application but only the echo
22:06 - applications not the one that we wrote
22:08 - so what I'm going to do is I'm just
22:09 - going to copy this so just hit contrl C
22:11 - there and paste that inside of my folder
22:14 - so that we already have kind of a front
22:16 - end directory set up with our react code
22:18 - and we can just modify this slightly so
22:19 - let me close this let's make this a bit
22:22 - bigger and I'm just going to rename this
22:24 - to be front it now let's have a look at
22:27 - some of the code here so I know there's
22:29 - a lot of files popping up but we have a
22:30 - get ignore we have our source we have
22:33 - public we got a bunch of stuff we don't
22:35 - need so it's actually going to be faster
22:36 - to do this I'm just going to delete a
22:38 - bunch of these files that we don't need
22:39 - so like monster and all this stuff we
22:42 - don't need those index. HTML uh we can
22:46 - change the description if we want so we
22:48 - can just say rock paper scissors and
22:52 - same with the title rock paper and
22:56 - scissors okay
22:59 - then we can go to source and we can
23:00 - start deleting a few things I'm just
23:01 - going to delete everything inside
23:03 - app.css I don't need that for app.js we
23:06 - can delete everything inside of here
23:09 - except for the div and we can just
23:12 - remove some of the things that we don't
23:13 - need so I'm going to remove Echo and
23:15 - Roar here because we don't need those
23:17 - I'm going to get rid of Echoes and
23:20 - Roar okay let's delete those index. CSS
23:24 - that's fine we can keep that index.js
23:27 - we'll keep all of this stuff cuz we're
23:28 - going to use this later and that I think
23:30 - is okay for Source anything else
23:33 - package.json we can change the name here
23:36 - to say rock paper scissors and this has
23:40 - all of the dependencies that we will
23:42 - need okay so now that we've kind of set
23:44 - up this front end directory what we'll
23:46 - do is just go in and build it so I'm
23:49 - going to go to my console now keep in
23:51 - mind you don't need to do this from WSL
23:53 - you can do this from any terminal you
23:54 - want because the front end is kind of
23:56 - separate from the back end and it can
23:58 - run in isolation so what I'm going to do
24:00 - is type CD do Dot and I'm going to CD
24:02 - into the Rock Paper Scissors directory
24:05 - and I'm going to CD into my front end
24:08 - okay so now we have this front end
24:10 - directory now what we'll do is we'll
24:12 - just type yarn and when we do that it
24:14 - should install all of the dependencies
24:16 - that we need or all of our node modules
24:18 - so give this a second and you can see
24:20 - it's generating the node modules
24:21 - directory all right so all of that is
24:24 - installed and what we'll do now is we'll
24:26 - just start working on the front end now
24:29 - for our front end we're going to use
24:30 - metamask to interact with our
24:33 - application now the reason we'll do this
24:35 - is we can very easily change between
24:37 - accounts because we need to have some
24:39 - different users to be able to test
24:40 - creating and accepting challenges right
24:42 - we need to have user one user two user
24:44 - three whatever and they need to be able
24:46 - to well accept the challenge create the
24:48 - challenge Etc so what we're going to do
24:50 - is just remove this account index I
24:52 - don't need that for now and I'm going to
24:53 - start setting up something known as the
24:55 - signer now the signer is the account
24:58 - that's kind of currently authenticated
24:59 - with our web page using metamask now to
25:02 - set all of this up we're going to use
25:03 - something known as ethers it's going to
25:05 - look like a little bit of gibberish if
25:06 - you've never seen this before but just
25:08 - bear with me this is a library that we
25:10 - actually just installed by copying that
25:12 - kind of front end um directory here and
25:15 - this will allow us to connect with
25:16 - metamask and get some account
25:17 - information send transactions Etc so
25:20 - what we're going to do is set up some
25:22 - State we're going to say const signer
25:24 - and then set signer like this is equal
25:28 - to use State and this will be undefined
25:31 - for now because when we start the app we
25:33 - don't have Aigner then we're going to
25:35 - have a use effect and essentially as
25:37 - soon as the application loads we're
25:38 - going to try to connect to metamask so
25:41 - let's make our use effect hook inside of
25:43 - use effect we're going to say if the
25:45 - type of this needs to be inside
25:48 - parenthesis so if the type of window do
25:54 - ethereum is equal to
25:58 - undefined then what we will do is we
26:01 - will return an alert and this alert will
26:04 - say you need metamask to use this
26:09 - application okay so this is just
26:11 - checking to make sure that we have
26:12 - metamask installed window. ethereum kind
26:16 - of exposes the metamask extension or
26:18 - some other types of extensions as well
26:20 - but in this case metamask if we don't
26:21 - have it will tell them hey you need
26:22 - metamask for this to work okay otherwise
26:25 - we're going to try this so we're going
26:26 - to say try
26:28 - catch we're going to catch an error so
26:30 - we'll just handle this
26:32 - first okay we'll say
26:35 - console.log and we will log out what the
26:37 - error is and then we will alert and say
26:41 - connecting to
26:44 - metamask
26:45 - failed okay so if an error occurs during
26:47 - the connection process that's what we'll
26:49 - do otherwise just giving myself some
26:52 - space here we're going to say
26:54 - window. ethereum and then this is do
26:59 - request and we are going to request the
27:02 - following so we're going to say method
27:04 - inside of an object and this is going to
27:06 - be
27:08 - fcor
27:09 - request and then account make sure you
27:12 - type this exactly like I have now what
27:14 - this is going to do is request to
27:15 - connect to the different ethereum
27:17 - accounts we have in metamask we're then
27:19 - going to have a then so we're going to
27:21 - say do then and inside of here we're
27:25 - going to create a provider so we're
27:26 - going to say const
27:28 - provider is equal to new ethers do
27:33 - providers.
27:35 - web3 provider and we are going to
27:38 - connect to window. ethereum which will
27:42 - be
27:44 - metamask okay I know this seems weird
27:46 - but the way this works is in ethers we
27:48 - first create a provider the provider
27:51 - gives us access to a bunch of different
27:53 - accounts in this case we are creating
27:55 - the provider from the metamask extension
27:57 - in our browser that's really what's
27:58 - happening that's all we're doing then
28:00 - what we need to do is get the signer and
28:02 - the signer is essentially getting the
28:04 - current account that is active in
28:06 - metamask that we'll use to sign
28:08 - transactions so we're saying consigner
28:11 - is equal to
28:13 - provider. getet signer and then we're
28:16 - going to say set signer like that and
28:18 - we're going to set this signer okay
28:22 - that's it for the use effect this means
28:24 - when we first open up the window it
28:25 - should attempt to connect us to mask
28:28 - sometimes this will just happen
28:29 - automatically sometimes it will prompt
28:30 - you you got to type in your password Etc
28:32 - and then it should give us the signer
28:35 - okay so we can actually test this out by
28:37 - running our react application so to do
28:40 - that I believe we just type yarn start
28:43 - and that should actually run react so
28:45 - let's give this a second to run and see
28:47 - if this works all right so I ran react
28:49 - and I just got an error here saying
28:50 - ethers is not defin so we just need to
28:52 - import ethers just forgot about that so
28:54 - we're going to say
28:55 - import ethers like this from and then
29:01 - ethers okay so that should fix it now
29:03 - let's go here and we can see nothing's
29:06 - really happening but if we go to
29:07 - metamask notice that we have um kind of
29:09 - this little popup here and that's
29:10 - essentially saying hey you know we want
29:12 - to connect to metamask so let me type in
29:13 - my password I'll be right back all right
29:15 - so we are now connected and you can see
29:18 - that I have a few accounts and I'm
29:19 - actually connected to the hard hat
29:21 - Network now what I'm going to do is just
29:22 - remove a few of these accounts because I
29:24 - want to show you the process of adding
29:25 - them and I don't want to have this
29:26 - already set up beforehand so let me just
29:28 - remove any of them that it will allow me
29:30 - to remove okay that's fine now notice
29:33 - here that I am on the hard hat Network
29:35 - now this is a network I've manually
29:37 - added to metamask obviously I think goes
29:39 - without saying you need to have metamask
29:40 - installed for this to be working but if
29:42 - you don't yet have the hard hat Network
29:44 - which is the local node that we're
29:46 - connected to for our development
29:47 - environment you're going to need to add
29:49 - that so you can go to add Network and it
29:51 - will bring you here and it should show
29:53 - you a few options now you're going to
29:54 - have to add a custom Network so if we go
29:56 - full screen here we can add a network
29:59 - manually now for the network name you
30:01 - just call this hard hat let me just zoom
30:03 - in a bit so you guys can read this for
30:04 - the new RPC URL we have to enter in the
30:07 - URL for hard hat which should be this
30:10 - okay so HTTP col1 127.0.0.1 otherwise
30:15 - known as Local Host and then Port
30:17 - 8545 now it's saying it's already being
30:20 - used because I already have this network
30:21 - but I'm just trying to show you what we
30:22 - need to type in so make sure you type in
30:24 - this exactly and then you type in 1 337
30:29 - or sorry
30:31 - 31337 that should be the chain ID now
30:34 - for the currency symbol I don't think
30:35 - this matters but I'm pretty sure you
30:37 - just type in E and then assuming that
30:39 - this is uh not incorrect you should be
30:41 - able to just go right so again I already
30:43 - have this added which is why it's not
30:44 - letting me add it but you guys should be
30:46 - able to add it using this if for some
30:47 - reason e is not working it's prompting
30:49 - me to use go doesn't really matter what
30:51 - the currency symbol is so just use
30:52 - whatever it tells you okay so I'm going
30:54 - to cancel that because I don't need that
30:56 - if I go to hard hat you you can see that
30:58 - this is my setting so hard hat
31:00 - 31337 and then hard hat eth okay so I
31:03 - guess you can just go with that and you
31:04 - do not need a block Explorer URL okay
31:07 - now once you change the network here
31:10 - what you're going to want to do is reset
31:12 - your accounts or if they don't have it
31:15 - here clear your activity tab so if
31:17 - you're ever getting any errors where
31:19 - transactions aren't going through or
31:21 - things are kind of being messed up and
31:22 - you're not sure what's wrong what you
31:23 - can do is open up metamask go to
31:25 - Advanced and just click clear activity
31:27 - tab when you do that what it's going to
31:29 - do is reset some of the nonces and some
31:31 - of the state metamask is caching for
31:34 - this network so whenever you kind of
31:36 - restart the node so let's open this up
31:38 - here right if you restart this node
31:40 - which we can do right now so let's just
31:42 - close this all right sorry for the cut
31:44 - there but anyways this is stopped right
31:45 - so I'm going to run the commands now
31:47 - that will actually shut this down and
31:50 - then once we restart it so let's go back
31:52 - and compose it up once this gets running
31:55 - again you go here and you clear the
31:57 - activity tab just to make sure any of
31:59 - the accounts that you have don't have
32:00 - all of the nonces in the cach data okay
32:03 - so I'm going to go back here and we're
32:05 - almost done but what we want to do now
32:06 - is actually add some accounts to uh our
32:09 - hard hat Network so I'm not going to
32:11 - connect to one of these I'm going to go
32:12 - to accounts and I'm going to go to add
32:14 - account and I'm going to import an
32:16 - account now what we'll do is when we see
32:18 - our node here we can actually see if we
32:22 - make this a little bit larger that at
32:24 - the very beginning it will spit out some
32:26 - PR keys and they're Associated accounts
32:29 - so you can just grab any random ones you
32:31 - want but I'm going to go with account
32:32 - five for example I'm going to copy this
32:34 - private key again this is in the logs
32:37 - right when your node starts running okay
32:39 - so grab one of the private keys go here
32:42 - and paste it in and hit import now what
32:45 - that will do is actually import a new
32:46 - account for you again I'm going to clear
32:48 - this transaction kind of cash in a
32:49 - second now I'm going to go add account
32:52 - again import account and I'm going to go
32:55 - back here I'm going to find find a
32:57 - private key so let's just go to account
32:59 - number
33:00 - 13 doesn't matter which ones you use
33:03 - they all are just pre-loaded with 10,000
33:05 - eth that you can test with so we're
33:07 - going to go back here smiss okay add
33:11 - account import account paste this in and
33:14 - now we've got a new account now for some
33:15 - reason the accounts are glitching for
33:17 - you you can just get a different account
33:19 - again go back here and just copy another
33:22 - one uh oops this one shut down sorry
33:24 - this is what I meant so let's go get you
33:26 - know a count 18 just to be
33:29 - safe go here and we'll add another one
33:32 - okay so dismiss account add account
33:36 - import account and import okay so we're
33:39 - going to use account number six and
33:41 - account number seven for our testing
33:43 - just because they don't have any
33:43 - transaction history so we're not going
33:45 - to get any weird cashing issues again
33:47 - I'm just trying to make this super clear
33:49 - because metamask can be a little bit
33:50 - glitchy when you're switching between
33:52 - networks and using local nodes and stuff
33:53 - that keep going up and down so if you do
33:55 - have issues just make sure you refresh
33:57 - those accounts and you can add the new
33:59 - private keys if you keep restarting or
34:01 - rerunning your environment all right so
34:04 - this is working now we're connected with
34:05 - metamask let's rerun our back end though
34:07 - because as soon as you shut down the
34:09 - node the back end's going to disconnect
34:10 - from that so now we've got the node and
34:12 - we've got the back end running now we
34:14 - want to start actually writing some code
34:15 - on the front end that allows us to send
34:17 - inputs or transactions to our back end
34:20 - so let's go ahead and do that all right
34:23 - so we're going to make a new component
34:24 - here in our source directory of front
34:27 - end and we're going to call this create
34:30 - challenge. JS now for this component
34:34 - obviously it'll do what it says create a
34:36 - new challenge so we're going to say
34:37 - import react and use state from react
34:42 - like that we're then going to import
34:44 - some pre-built components so we're going
34:46 - to import button use toast and
34:51 - select from and this is going to be at
34:55 - chra I forget how you pronounce this
34:57 - chakra I don't know ui/ react anyways
35:01 - this is a component library that has
35:02 - some components for us okay so now we're
35:04 - going to say
35:06 - function create challenge we're going to
35:09 - take in a signer as a prop and we're
35:13 - going to start setting up some state so
35:15 - let's start by setting up some State
35:17 - we'll say const Choice set
35:20 - choice is equal to use State and by
35:24 - default we'll just set it to one which
35:26 - will be Rock
35:27 - we'll then say const toast is equal to
35:30 - use toast this just allows us to kind of
35:32 - pop up some notifications on the screen
35:35 - and we're going to say const loading set
35:38 - loading is equal to use State and for
35:41 - now it'll be false just so we have a
35:42 - loading indicator when they are actually
35:44 - creating this Challenge and they can't
35:46 - spam the button now we're just going to
35:47 - set up a function so I'm going to say
35:49 - aset async sorry function create
35:54 - challenge okay inside of here this is
35:56 - what we'll do to actually create the
35:57 - challenge and we're going to have
35:58 - another Asing function which will be
36:00 - handle
36:02 - submit this will take in some
36:05 - events and what this will do is handle
36:07 - the submission of a form which we then
36:09 - call create challenge so we can actually
36:11 - write this right now we're going to say
36:12 - event. prevent
36:15 - default we're going to say set
36:17 - loading is equal to true we're going to
36:20 - say await create challenge we're going
36:24 - to say set
36:25 - loading
36:27 - is equal to false okay so all we're
36:30 - doing is we're just going to set loading
36:32 - we're going to wait for this to finish
36:34 - and then we're going to say set loading
36:35 - is equal to false okay pretty
36:36 - straightforward we're just setting some
36:38 - State okay now what we're going to do is
36:40 - create the UI so we're going to return a
36:43 - div the class name for this div can be
36:47 - the challenge form if we want to style
36:49 - this eventually and we can make a form
36:52 - now we can say on
36:54 - submit is equal to and we can call the
36:57 - handle submit function when we submit
36:59 - the form so now we'll actually
37:01 - import heading here and we'll use a
37:04 - heading so we'll say heading like that
37:08 - for the size we can specify that this is
37:10 - going to be large and then we can do
37:15 - create challenge like so okay so that's
37:19 - just going to be the heading for our
37:20 - form then we can have a div we can have
37:24 - a label in here the label can say Choice
37:28 - okay so this is the choice that you're
37:30 - going to select when you are uh kind of
37:32 - creating the challenge and we're going
37:34 - to have a select field okay so for the
37:37 - select I'm going to say the focus border
37:41 - color is equal to Yellow going to say
37:44 - the size is equal to medium the value is
37:49 - equal to
37:51 - choice and the onchange event which is
37:54 - the most important is going to be the
37:55 - following so so we're going to take in
37:57 - event and we're going to say set choice
38:01 - and let me just save this or format it
38:03 - so that we get some better uh kind of
38:06 - spacing here we're going to say event.
38:09 - target. value okay what I'm doing uh
38:12 - just to clarify here is I'm setting up a
38:14 - select field which will have a few
38:15 - different options that we can just
38:16 - choose that we can click on so kind of a
38:18 - drop- down menu and we're setting the
38:20 - value of this field equal to our state
38:22 - variable Choice and then whenever we
38:24 - change the value we're going to get the
38:26 - event and we're going to get what we
38:27 - clicked on so whatever the value of the
38:29 - target was and set that to be our choice
38:32 - now inside of Select we need to specify
38:34 - the options so we're just going to say
38:37 - option first one is going to be
38:39 - Rock okay and then we are going to have
38:44 - paper and scissors however what we want
38:48 - to do is associate these with a numeric
38:50 - value so we're going to say value equals
38:53 - 1 value equals 2 and and value equals 3
38:58 - so that when you actually click on these
39:00 - here they get converted or sorry not get
39:03 - converted but when you click on these we
39:04 - get the value not the inner HTML so we
39:07 - end up setting the choice to be one two
39:09 - or three we don't set it to be uh what
39:12 - do you call Rock Paper Scissors okay now
39:14 - what I'm going to do is just make this
39:15 - value a string as well just so it
39:17 - matches and now we should have the main
39:20 - UI the last thing we need is a button
39:23 - that will submit the form so we're just
39:24 - going to say button here and and we're
39:26 - going to say type is equal to submit we
39:31 - can set the color scheme so I'm going to
39:32 - say the color scheme is equal to yellow
39:36 - and for the button we will just say
39:39 - create challenge like that and I'm going
39:42 - to do one more thing I want to add some
39:44 - state to the button that indicates if we
39:47 - are loading or not so I'm going to say
39:50 - let button props equal to this I'm going
39:53 - to say if loading
39:57 - then button props do is loading is equal
40:01 - to true so I'm just going to set this
40:03 - property and then I'm going to go here
40:05 - and I'm going to say dot dot dot button
40:07 - props so this way if we are loading the
40:09 - button will appear as if it is loading
40:11 - otherwise we just won't do any changes
40:14 - okay so let me save this and format and
40:16 - now we should have the main component of
40:18 - our UI obviously there's some more stuff
40:20 - that we need so let's go down here and
40:22 - Export this we're going to say export
40:24 - default and then what is this create
40:27 - challenge we're then going to go to
40:29 - app.js and we're going to import this so
40:31 - we're going to say
40:33 - import create Challenge from create
40:36 - Challenge and we'll just throw this in
40:39 - here so we'll say create Challenge and
40:41 - we will pass our signer so signer is
40:44 - equal to signer okay so that should be
40:47 - the first part of the UI I know I went a
40:49 - little bit fast there obviously you can
40:51 - pause the video type it out all of this
40:53 - code will be available from the link in
40:55 - the description as well we're just
40:56 - setting up the form to create the
40:57 - challenge this function is the logic
40:59 - we'll need to write to actually send the
41:01 - transaction to create that challenge but
41:03 - obviously we can't do that yet because
41:04 - we don't have all of that logic so let's
41:07 - go here though and just look at our what
41:10 - is this UI and there you go we have
41:12 - create challenge we have our choice and
41:14 - we can choose doesn't look super pretty
41:17 - we can style that in a minute but for
41:19 - now let's get this actually functioning
41:22 - okay so we want to write create
41:24 - challenge now in order to create the
41:26 - challenge the first thing we need to do
41:28 - is we actually need to generate our
41:30 - commitment so what I'm going to do is
41:31 - write a helper function I'm going to go
41:33 - to Source I'm going to type
41:36 - .js and I'm going to put a utility in
41:38 - here that can do some of the hashing and
41:40 - cryptography for us all right so we're
41:42 - going to start with our hashing function
41:44 - which is probably the most annoying
41:46 - we're going to say export
41:49 - async
41:51 - function generate hash and we're going
41:54 - to put inside of here input
41:57 - now what we're going to do is create an
41:58 - encoder we're going to say const encoder
41:59 - is equal to new text
42:02 - encoder and a lot of this is going to
42:03 - seem like gibberish just bear with me um
42:06 - this is just a function that will create
42:07 - the hash you don't have to worry too
42:08 - much about exactly how it works so don't
42:10 - stress about it we're going to say con
42:12 - data is equal to encoder do encode and
42:16 - we're going to encode the input we're
42:19 - then going to create a hash buffer so
42:22 - we're going to say con hash buffer is
42:23 - equal to a weit crypto do subtle dot
42:29 - digest and then we're going to say that
42:31 - we want to use the shaw 256 algorithm
42:33 - which is the same one we used on the
42:35 - back end which is very important we're
42:37 - going to take our data which is this
42:39 - encoded heximal input we are then going
42:41 - to say the const hash
42:44 - array is equal to array. from we're
42:48 - going to say new uint 8 array from the
42:53 - hash buffer we're then going to say the
42:56 - const hash hex the heximal version of
42:59 - the hash is the hash array map we're
43:03 - going to take in B we're going to say b
43:06 - do2 string base 16 that's what we're
43:10 - doing here pad start to zeros okay then
43:16 - we are going to return the hash
43:19 - hex don't ask me why all of that works a
43:22 - lot of this code I did just get from
43:23 - chat GPT but I can promise you it does
43:26 - create the correct hash that we need I
43:28 - know pretty confusing just type it out
43:31 - don't worry about it you can ask chat
43:32 - gbt to explain it to you if you're
43:34 - really stressed about what each line is
43:35 - doing now that we have the hash function
43:37 - though we can write another function and
43:39 - say export con generate commitment not
43:44 - hash okay now we should probably Spell
43:47 - commitment correctly I think that's
43:49 - spelled correctly actually and we'll say
43:51 - this is equal to an async function and
43:54 - this can take in the choice and the
43:57 - signer and this will generate a
43:59 - commitment for us that is the hash of
44:01 - our what is it um what do you call it
44:04 - the move and our knots that's what we
44:06 - want okay so what we need to do to
44:10 - generate the commitment is we need to
44:12 - actually create a random number and we
44:14 - need to store that random number
44:16 - somewhere so we have access to it when
44:18 - we reveal our move now this is where
44:21 - we're going to create another file and
44:23 - we're going to call this constants
44:26 - .js now inside of here I'm going to
44:28 - define a few constants that we're going
44:29 - to need two of which are going to be the
44:32 - keys that we're going to use to store a
44:34 - value in something known as local
44:36 - storage now local storage is associated
44:38 - with your browser so what we can do is
44:41 - we can store the random numbers that are
44:43 - associated with a specific account and
44:45 - the challenge that they are in in our
44:48 - browser and that way we're storing them
44:50 - locally on the client side we're not
44:52 - exposing it to the blockchain until we
44:54 - reveal our answer so the reason I'll
44:56 - store it in local storage is so that if
44:58 - we refresh the page we leave the page we
45:00 - come back to this page we still have it
45:02 - stored there so we'll be able to
45:04 - actually reveal the answer and complete
45:05 - the challenge you'll see what I mean in
45:07 - a second but let's define these
45:08 - constants so we're going to say export
45:11 - const and this is going to be the nons
45:14 - key and this is just going to be equal
45:17 - to nons okay we're going to say export
45:20 - const move
45:22 - key and this will be equal to move now
45:25 - doing them in all capitals just because
45:27 - they are JavaScript constants I'm going
45:29 - to go to util now and I'm just going to
45:30 - import those because we're going to use
45:32 - them in a second so in util I'm going to
45:34 - say import and this is going to be the
45:36 - nons key and the move key from my
45:41 - constant now inside of the generate
45:43 - commitment what we're going to do first
45:45 - is get the address of the person who is
45:48 - making this commitment so to do that we
45:50 - take the signer and we say. get address
45:53 - but this is a promise so we need to
45:56 - await it to get the address from the
45:58 - signer which is from metamask okay we're
46:01 - then going to say
46:02 - constn is equal to math. random
46:07 - multiplied by a large number I'm just
46:09 - going to multiply it by what do you call
46:11 - this here 10,000 this is going to give
46:13 - us a random number between 0o and 10,000
46:16 - so that's what we're going to use for
46:17 - our random number you can make it more
46:19 - secure by adding more zeros if you want
46:21 - although either way we're still going to
46:22 - get a large decimal value so it doesn't
46:24 - really matter in fact you don't even
46:25 - have to multiply it but I will okay
46:28 - we'll just multiply by th anyways we're
46:30 - now going to say local
46:32 - storage do set
46:34 - item and we are going to set the nons
46:37 - key plus the address and actually yeah
46:41 - address. two
46:45 - lowercase to be the knots now what I'm
46:47 - doing here in local storage is I'm
46:49 - making a combined key now the combined
46:52 - key is simply Nots so whatever we put in
46:55 - UIL which is is just the string nods
46:57 - plus the address of the account that
46:59 - created this nods the reason why I need
47:01 - to add this part here is because we're
47:03 - going to have multiple different
47:04 - accounts that could be interacting from
47:06 - the same browser so I don't want to
47:08 - override previous nonces that other
47:10 - accounts have created so when I store
47:13 - the knots I store it with the address of
47:17 - the account that created that knots that
47:19 - way we can also access it only when
47:21 - we're signed in with that address
47:23 - hopefully that makes sense but that's
47:25 - kind of this works now we're going to do
47:27 - the same thing here for the choice
47:30 - because just like we're caching this
47:31 - random number we also need to cach the
47:33 - choice so that we know what that is when
47:35 - we go to reveal the answer so we're
47:38 - going to say move key plus address. to
47:43 - lowercase and then this is going to be
47:45 - choice now it's important that we
47:47 - convert the address to lowercase because
47:48 - sometimes they have like mixed
47:50 - capitalization and it can cause some
47:52 - issues when you're checking the local
47:53 - storage if the capitalization is off so
47:56 - I just always convert to lowercase just
47:57 - to be safe okay so now we've stored the
48:00 - nons and the choice which we'll use
48:02 - during the reveal phase now that it's
48:04 - stored we'll create a hash of it so
48:06 - we'll say cons
48:08 - commitment is equal to await generate
48:11 - hash so let's fix that and for the hash
48:14 - we're going to take the not. two string
48:18 - plus the choice which should already be
48:20 - a string we're then going to return the
48:23 - commitment okay so what we did is we got
48:26 - the address we generate a random number
48:29 - we store the random number and the
48:30 - choice that the user made and then we
48:32 - create a hash that takes the nons first
48:34 - and then the choice the order here is
48:36 - important it needs to be in this order
48:38 - then we return the commitment which will
48:40 - just be a random string notice on line
48:43 - 15 we're generating a random number
48:46 - using math.random now this will generate
48:49 - a random floating point value between 0
48:51 - to 1 and then we multiply it by a th000
48:54 - what that means is we're going to have
48:56 - actually quite a few decimal places in
48:58 - our number and we have a floating point
49:00 - value here now we really shouldn't use a
49:03 - floating point value for our nons
49:05 - because the amount of digits that can be
49:07 - represented floating Point digits that
49:09 - is in JavaScript is different than in
49:12 - other languages say like python or go or
49:14 - whatever our back end is written in so
49:16 - what we should really do here is
49:17 - actually round off the nons now in this
49:20 - video I don't do that and I end up using
49:21 - a decimal value and you'll see that
49:23 - everything works completely fine but I
49:25 - wanted to mention that really we
49:27 - shouldn't use a decimal value Nots we
49:29 - should use a whole number so ideally
49:31 - what you would do here is just round it
49:33 - off you just simply round it to the
49:35 - nearest whole number and that way you'd
49:36 - avoid any significant digit issues with
49:40 - kind of values in different programming
49:42 - languages and how things are handled
49:43 - okay so we now have the two utility
49:45 - functions we need to generate the
49:47 - commitment which also involves
49:48 - generating the hash now we also need a
49:51 - way to send an input to our smart
49:54 - contract or to to our back end now to do
49:56 - that we're going to go over to constants
49:58 - and we're going to write another few
50:01 - variables so we're going to say export
50:03 - const and to be able to send something
50:06 - right to be able to send a transaction
50:08 - we need to know where we're sending it
50:10 - so we're going to get the DAP
50:13 - address of our backend okay so we're
50:16 - going to say export con dap address I'll
50:17 - show you how we get that I'm going to
50:19 - say export const
50:22 - default
50:24 - URL okay and this is going to be equal
50:26 - to the URL that I'll type in here which
50:30 - is HTTP
50:32 - Co Local Host Colin
50:36 - 55/ inspect just copy that in don't
50:40 - worry about that a ton that's just the
50:42 - port essentially that we are running the
50:44 - kind of inspect server on WE we'll talk
50:47 - about that later but just put that in
50:50 - we're then going to say export const and
50:51 - we're going to say input box address
50:56 - is equal to the following so let me just
50:58 - pause here and explain something when we
51:00 - send a transaction to our backend so
51:02 - something verifiable on the blockchain
51:04 - it needs to First be logged on the
51:06 - blockchain so we need to send the
51:08 - transaction to the blockchain it then
51:10 - needs to get forwarded to our cartez
51:12 - node where it can then be handled by the
51:14 - cartei framework and our backend so what
51:17 - we're going to do is use something known
51:19 - as the input box now caresi will deploy
51:22 - a series of contracts that are used
51:24 - within the caresi rollups framework to
51:27 - interact with our backend which is
51:29 - running offchain if we go into our
51:32 - folder here and we go to deployments and
51:34 - we go to Local Host you can see that we
51:36 - have a bunch of different um what do you
51:38 - call it contracts right one of them is
51:40 - the input box now the input box lets us
51:43 - take a transaction and forward that to
51:46 - our backend okay it's like sending an
51:48 - input remember we can send inputs or we
51:50 - going send Advanced requests and inspect
51:52 - requests so this is how you send an
51:54 - advanced request using the input box so
51:56 - we're going to copy the input box
51:58 - address again you go into the kind of
52:00 - root folder go to deployments Local Host
52:03 - and find input box and we're going to
52:04 - copy that in here for the input box
52:07 - address okay now there's a bunch of
52:10 - other ones as well so if we go here we
52:11 - have authority bit mask cartez dap
52:13 - Factory dap address relay portal right
52:16 - ether portal erc20 portal these are
52:19 - contracts that you would send assets to
52:21 - that would then tell uh our backend that
52:24 - the asset was received
52:26 - okay so what would happen is assets
52:28 - would be stored inside of these
52:30 - contracts which can be controlled from
52:32 - our backend and our back end can be
52:34 - indicated when something is sent to that
52:35 - contract now what we need as well is the
52:38 - DAP address so if we go to dap. Json we
52:41 - can just copy the address here okay
52:43 - that's for the current deployment and
52:46 - paste that in here okay I know it was a
52:48 - bit confusing but whenever you need any
52:49 - of the addresses you go to deployments
52:52 - and Local Host and if you restart your
52:55 - card aresi node these addresses might
52:57 - change so you may need to change these
52:59 - when the node resets okay when I'm
53:01 - talking about the node I'm mentioning
53:03 - the kind of hard hat node that's running
53:04 - that test Network for you okay so we
53:07 - have these inside of constants now we're
53:09 - going to go back into util and we're
53:11 - going to write the function that allows
53:13 - us to send an input so to send an input
53:16 - we're going to do the following we're
53:17 - going to say export const send input and
53:20 - remember this is advancing the state so
53:22 - we're going to say async we're going to
53:25 - take in a value we want to send we're
53:27 - going to take in signer and we're going
53:28 - to take in toast toast is something that
53:30 - again will allow us to kind of pop up a
53:32 - message on the screen and we'll use that
53:34 - in a second so we're going to say const
53:37 - input box is equal to and we're going to
53:40 - import an input box Factory from the
53:43 - cartei um what do you kind of call this
53:47 - I don't know node module I don't know
53:48 - the name of it the uh the package that
53:50 - caresi has that works in react and works
53:52 - in node.js just stuttering on my words
53:54 - here we're going to say import input
53:58 - boxcore uncore Factory from at caresi
54:06 - rollups now caresi rollups is already
54:09 - installed inside of this package okay
54:11 - it's already in the uh the yarn lock we
54:13 - already installed it when we copied the
54:15 - frontend directory into here and we
54:17 - typed yarn now inside of this rollups
54:20 - package we have a bunch of different
54:21 - factories which essentially instantiate
54:24 - the contract that we're going to use to
54:26 - interact with our backend so just like
54:28 - we have the input Factory we have other
54:30 - ones for things like the portals right
54:33 - for sending Assets Now really what these
54:35 - are doing is wrapping a lower level
54:38 - operation that is getting something
54:39 - known as the contract ABI now the ABI is
54:43 - a specification of the different
54:44 - functions that exist on the contract and
54:47 - it kind of maps it into JavaScript code
54:49 - for us so we can call those functions
54:51 - without having to know all of their
54:52 - heximal representations and some of the
54:55 - weird stuff that goes on in solidity
54:57 - anyways we get the input box Factory
55:00 - we're going to go here and we're going
55:01 - to create a new instance of this so
55:03 - we're going to say input box factory and
55:05 - we're going to connect the input box
55:08 - Factory to the input box address with
55:12 - our
55:13 - signer okay so this again is going to
55:17 - create kind of like a JavaScript
55:19 - instance or connection to the input box
55:22 - which is a contract running on the
55:24 - blockchain Network which will allow us
55:26 - to forward information to our
55:28 - decentralized application okay so we
55:30 - have input box next what we're going to
55:33 - do is we are going to get the bytes that
55:36 - we're going to be sending so we're going
55:37 - to say const input bytes is equal to
55:40 - ethers do utils do is bytes like and
55:46 - then we're going to say value question
55:48 - mark value otherwise ethers do utils do
55:53 - let's spell ethers correctly
55:56 - do2
55:57 - utf8
55:59 - bytes then we're going to take in the
56:01 - value now we're also going to import
56:02 - ethers oh ethers is already there okay
56:04 - and we're just going to save this all
56:06 - right let me quickly explain this so
56:08 - what we're doing is we're getting the
56:10 - input box which I already did and then
56:11 - we're saying okay we're going to have
56:13 - some input that needs to be in a bite
56:15 - format or kind of like a heximal format
56:18 - that we're able to submit to our D so
56:21 - what we do is we look at our value and
56:23 - we first check is it already the format
56:25 - that we need it to be if it is then we
56:27 - can simply just take the value otherwise
56:29 - we need to convert it to utfa bytes
56:30 - which is what we do right here okay so
56:32 - that's what we're doing with input bytes
56:34 - now that we have that what we can do is
56:36 - send a transaction to our input box so
56:39 - we can say const TX is equal to a weit
56:43 - input box do add input now notice I'm
56:46 - getting autocomplete here the reason I'm
56:48 - getting autocomplete is because I use
56:49 - this input box Factory that returns an
56:52 - instance of the input box class okay so
56:54 - we're going to say input box or add
56:56 - input sorry we're going to send an input
56:59 - to our dap address and the input we're
57:01 - going to send is the input bytes so we
57:04 - connected to this contract which allows
57:06 - us to send inputs to our decentralized
57:09 - application we turn the input into a
57:11 - format that we can actually send and
57:13 - then we use this contract to send to our
57:15 - dap address the following invites all
57:19 - right so now that we are sending the
57:21 - transaction what we're going to do is
57:22 - just write some code that will wait for
57:24 - the transaction and give us some kind of
57:26 - output on the screen so we're going to
57:28 - say export const weit for
57:33 - transaction and this is going to be an
57:35 - async function again which is going to
57:37 - take in our transaction and our toast
57:39 - object now what we're going to do is say
57:43 - toast and we're just going to put kind
57:45 - of a notification on the screen that's
57:47 - what toast does we're going to say title
57:49 - and transaction sent we're then going to
57:53 - say description
57:56 - waiting for confirmation like that we're
58:00 - going to say the status of
58:02 - this is
58:04 - success for the
58:07 - duration this can be 9,000 so that's 9
58:10 - seconds we'll say is
58:13 - closable true and
58:16 - for the
58:18 - position we can say that this will be
58:21 - the top left obviously you can change
58:23 - that top right bottom left bottom right
58:26 - Etc okay format that so we're going to
58:29 - do the toast we're then going to say
58:31 - const
58:33 - receipt is equal to wait transaction. we
58:38 - one now what this does is wait for one
58:40 - confirmation for the transaction just to
58:43 - make sure that it went through we're
58:44 - then going to say const event is equal
58:49 - to receip do events question mark. find
58:54 - and we're going we're going to say e and
58:56 - then e. event is equal to input added
59:02 - like that so what this is doing is just
59:04 - giving us the event associated with the
59:06 - transaction which will contain the logs
59:08 - with anything like reports or whatever
59:11 - else is generated from that uh
59:13 - transaction you'll see what I mean in a
59:15 - second but what we're doing is we're
59:16 - looking at the receipt we're checking if
59:18 - there is any events if there are we're
59:19 - finding the ones associated with input
59:22 - added which is what we just did with
59:24 - this transaction so now we can do
59:26 - another toast so let's copy this okay
59:29 - and we will
59:30 - say
59:32 - confirmed like that and we can say input
59:38 - added and then the index of this will be
59:41 - the following so let's just add our back
59:44 - ticks here so we're able to actually
59:45 - embed this
59:47 - value and this will
59:49 - be event. args do inbox
59:55 - input and then index okay I know this a
59:59 - bit confusing but what this is really
60:00 - doing is telling us the index of the
60:03 - transaction that we sent to the back end
60:05 - or the input we sent to the back end to
60:07 - advance the state so it could be the
60:09 - first one second one third one Etc okay
60:11 - then we're just going to return the
60:13 - receipt of the transaction so now we're
60:15 - going to go up here to where we have
60:18 - send input and we're going to wait for
60:20 - the transaction so we're going to say
60:22 - return await wait for transaction and
60:26 - what does this take well this is going
60:29 - to take the following the transaction
60:33 - and the
60:34 - toast okay so that is send input and
60:37 - wait for transaction now we are almost
60:39 - done we're going to go to create
60:40 - Challenge and we're going to write this
60:42 - function here which is going to use the
60:43 - code that we just wrote which was the
60:45 - more complex stuff so to create the
60:47 - challenge we first need the commitment
60:49 - so we're going to say con commitment is
60:51 - equal to a wait generate commitment and
60:54 - we're going to take our choice and our
60:57 - signer we're then going to say wait send
61:00 - input and we're going to send our input
61:03 - now the input we're going to send is
61:05 - json.
61:07 - stringify and we're going to create the
61:09 - Json object we want to send so we're
61:11 - going to say method is create undor
61:16 - Challenge and the commitment is the
61:20 - commitment right and then we're going to
61:22 - pass our signer so let's go down here
61:26 - and we're going to pass our toast and
61:28 - let me just save that okay quickly go
61:30 - through this generate the commitment
61:32 - using that hash function we're then
61:34 - sending the input using the send input
61:36 - function we just wrote here which uses
61:38 - all this other stuff now remember what
61:40 - we're passing here is our payload okay
61:43 - so this is the Json we have our method
61:45 - which is creating a challenge what we
61:46 - also need to pass with that is the
61:48 - commitment to make the challenge so
61:49 - that's what we pass to do that we need
61:51 - the signer and we need the toast so we
61:53 - get our notifications now let's just
61:55 - quickly have a look at our code looks
61:57 - like everything is running so we should
61:59 - be able to go here and try this out I'm
62:03 - going to refresh the page let's just
62:05 - open up the inspect window see if we
62:07 - have any errors appearing uh don't worry
62:10 - about this unchecked runtime thing these
62:11 - are not really associated with us I'm
62:13 - going to go ahead and click on create
62:16 - Challenge and when we do that metamask
62:18 - should appear uh it says you do not have
62:20 - enough hard hat e in your account to pay
62:21 - for transaction fees okay that's weird
62:24 - so I'm going to change the account that
62:26 - I'm using I'm probably just connected
62:28 - with the wrong account ah so that's why
62:31 - I'm going to connect with account 7 okay
62:33 - so let's refresh the page there let's
62:36 - check our account looks like account 7
62:38 - is connected now I'm going to create the
62:40 - challenge and there you go so let's go
62:42 - ahead and click confirm we get the toast
62:45 - transaction sent waiting for
62:47 - confirmation and we should be able to
62:49 - see it popping up in our back
62:51 - end like here okay so it says receive
62:54 - advance request data method create
62:56 - challenge commitment and then we have
62:58 - this array adding notice challenge with
63:00 - ID Z was created okay so that worked
63:02 - successfully however this is a little
63:05 - bit messed up um I don't know if that's
63:07 - exactly what we wanted I think we wanted
63:08 - it in a string format so let's just go
63:10 - and have a look at our functions and see
63:12 - if we made a mistake which is quite
63:14 - possible okay so we're going to go to
63:16 - generate
63:18 - commitment and we generate the hash okay
63:21 - so generate hash we have our hash hex
63:25 - but I'm pretty sure we need to convert
63:27 - that to a string so yes the thing we're
63:30 - missing here is join and we're just
63:33 - going to join an empty string and that's
63:35 - going to take this array and convert it
63:37 - to a string so we're no longer getting
63:39 - an array submitted there okay so that's
63:40 - what we wanted so let's go and fix this
63:45 - now what we're going to need to do is
63:46 - just restart our back end here because
63:48 - this player has already created a
63:50 - challenge but I don't want them to be in
63:51 - a challenge so I'm just going to stop
63:53 - that and restart it to kind of clear
63:55 - that application data okay so now we
63:58 - should be able to go back to react go to
64:01 - the left side of our
64:03 - screen okay and let's just refresh to
64:07 - make sure we've kind of cleared this
64:08 - over we'll do rock that's fine we're
64:11 - going to create our challenge this time
64:13 - says we have one pending transaction
64:14 - that's fine we're going to go ahead and
64:16 - click confirm and we're going to wait a
64:18 - second here and we should see that we
64:21 - get the result appearing on the
64:22 - blockchain and we do so we get the
64:24 - method create Challenge and we get the
64:27 - commitment okay it says adding notice
64:28 - challenge with ID Z was created by this
64:31 - address fantastic so I think guys with
64:33 - that said I'm going to leave it here
64:35 - that's all I want to do for this video
64:37 - is get the backend finished and start
64:39 - interacting with it from the front end
64:41 - in the next video we'll write all of the
64:42 - rest of the front end codes that we can
64:44 - list out all of the different challenges
64:46 - that we have we can accept those
64:48 - challenges we can reveal our answer Etc
64:50 - anyways I hope you guys are excited and
64:52 - looking forward to it I will see you in
64:53 - the next
64:55 - [Music]
65:02 - video