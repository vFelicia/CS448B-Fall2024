00:00 - this video is gonna be dedicated to
00:01 - helping you guys ace your final exam in
00:03 - your computer science course whether
00:05 - that be university high school outside
00:09 - of school or whether you just want to
00:10 - learn what I'm gonna be doing in this
00:11 - video is going over some really common
00:13 - mistakes that I see all the time
00:14 - personally when I'm teaching people
00:16 - Python how you can fix those mistakes
00:18 - and remember how to fix those mistakes
00:20 - because a lot of people will be able to
00:22 - do it once and then forget it and then
00:24 - I'm also going to be going through Big O
00:26 - notation quickly I mean we talking about
00:27 - recursion on you're talking about the
00:29 - time complex that you have standard
00:30 - algorithm so searching and sorting
00:32 - algorithms and all of that the more
00:35 - difficult things that you learn in a
00:37 - first-year computer science course now
00:39 - I'm going to be doing this all in Python
00:41 - if for some reason your course is not in
00:43 - Python and you're watching this that's
00:45 - fine you're still gonna understand the
00:47 - time complexity you're still gonna
00:48 - understand most of the stuff although
00:50 - some of the syntax will be a little bit
00:52 - different and some of the stuff is
00:53 - specific to Python now this is really
00:56 - important that you guys watch through
00:58 - most of the video especially if you're
00:59 - struggling with this I want to explain
01:01 - everything in depth and I'm going to
01:02 - attempt to do it fairly quickly I try to
01:05 - keep this video under like mmm 20 30
01:09 - minutes and explain all the topics as
01:12 - well as I can if you have any questions
01:13 - please leave a comment down below or
01:15 - join my discord server and ask me I am
01:17 - more than happy to help with you guys
01:18 - now personally I am a computer science
01:20 - student so I do have experience writing
01:22 - these exams and writing tests like this
01:25 - and I personally have created some of my
01:27 - own so I can tell you exactly the kinds
01:29 - of questions you're gonna see and this
01:30 - will definitely help you a lot without
01:32 - further ado let's get started okay so I
01:36 - guess the first thing we're gonna talk
01:38 - about really quickly is mute ability now
01:40 - in Python this is a really important
01:42 - really really very important topic that
01:44 - a lot of people do not understand so we
01:46 - have different data types in Python some
01:48 - of which are mutable some of which are
01:49 - not standard data types we have like our
01:51 - int string bool topple float and so on
01:57 - we have list we have sets we have
01:59 - dictionaries and there is obviously more
02:01 - data types as well now can you tell me
02:03 - off the top of your head which of these
02:04 - are mutable in which these are immutable
02:06 - if not that's okay I'm about to tell you
02:09 - so int string bool topple
02:13 - float conveniently the first five that I
02:16 - typed are all immutable data types now
02:18 - what does that mean we'll talk about
02:20 - that a second list sets dictionaries
02:23 - which are the only ones I'm going to
02:24 - cover in this video are evening or sorry
02:26 - mutable data types
02:27 - immutable simply stands for not
02:30 - changeable mutable stands for changeable
02:32 - what do I mean by that let's create a
02:34 - few variables to show an example so I'm
02:36 - gonna have x equals five and have y
02:38 - equals string like this and we're going
02:42 - to create a list Li which is equal to
02:45 - one two three four five six and alone
02:49 - because why not
02:49 - okay so we have XY and L now X is
02:56 - immutable and why is he mutable li is
02:59 - not so the way that we can check this
03:02 - for example is if we add something to X
03:05 - okay and it might seem confusing now but
03:07 - just watch and you'll see how this works
03:09 - I'm gonna say X plus nine it just in a
03:11 - line there's nothing wrong with this
03:12 - line I'm just gonna say X plus nine I'm
03:14 - going to print X okay and I'm going to
03:18 - print X like this alright so what you'd
03:22 - say is okay so five plus nine well
03:24 - that's equal to 14 so what is X gotta
03:27 - print here what is X gonna print here
03:28 - take a guess
03:29 - okay we have five and we get five why
03:31 - did this happen why did we not add nine
03:33 - to X well when we add nine to X what we
03:36 - actually get is a returned value of 14
03:40 - okay we don't change X to equal 14
03:45 - because we're not reassigning X by
03:46 - saying x equals x plus nine we're just
03:50 - simply saying X plus nine so this
03:52 - returns to us value 14 but since we
03:54 - don't assign 14 to anything nothing has
03:57 - changed now obviously if I do something
03:59 - like x equals x plus nine we're going to
04:02 - get 14 okay now this seems trivial you
04:05 - guys probably already knew this but
04:06 - let's let's do it again now with Y okay
04:08 - so we're just going to say and this is
04:11 - we're gonna see so remember how if we
04:13 - want to slice strings or grab indexes of
04:15 - strings like I can say y 0 okay if I say
04:17 - y 0 that gives me the string s okay now
04:22 - I'm just gonna try to change Y 0 right
04:24 - so I will print Y
04:27 - and then we'll print why after I don't
04:28 - say why zero equals instead of asked
04:30 - we're gonna say T so now we're gonna say
04:32 - to toe ring okay that's what we're gonna
04:34 - say watch what happens when I run this
04:35 - string object does not support item
04:38 - assignment now why can't we do that
04:40 - that is because string that strings are
04:43 - immutable data types meaning that we
04:44 - can't change them I like it's implicitly
04:48 - like this okay if we wanted to change Y
04:50 - zero to B that we would have to say Y is
04:53 - equal to Y and then we can say t plus
05:01 - y12 the rest okay and that would give us
05:04 - the changed value because now we're
05:06 - reassigning Y to be equal to this
05:08 - because we can't just change it in one
05:10 - line now again this seems trivial but
05:13 - watch what happens would want to do this
05:14 - with lists where I print Li we did the
05:17 - exact same thing we did with with y - I
05:20 - say Li zero is equal to in this case
05:23 - changed okay and now watch what happens
05:28 - it says changed to three four five hello
05:32 - no issues were totally allowed to do
05:34 - that
05:34 - that is because lists are mutable
05:36 - meaning that we can change them
05:38 - implicitly like this and we can just
05:40 - change values we can also say like Li
05:43 - and we can take a slice well I would say
05:44 - like 0 - 4 equals changed okay and that
05:48 - gives us changed 4 or 5 6 float now I
05:51 - know this is like a weird thing that
05:52 - just happened but it just shows you the
05:53 - power of what we're able to do with that
05:55 - versus what we can't do with this okay
05:57 - so another thing with immutability is
06:00 - copying and aliases okay and this is
06:02 - really important a lot of people get
06:03 - really confused by this if we're gonna
06:05 - have a list we said li is equal to 1 2 3
06:07 - 4 5 6 hello and so Li 2 is equal to and
06:11 - I'm just gonna change this I'm gonna say
06:14 - it is equal to Li okay I'm just gonna
06:16 - print Li and Li 2 and you should see we
06:21 - get the same value we didn't same about
06:23 - you okay now if I change Li - so I'm
06:27 - gonna say like Li 2 dot append let's
06:31 - just do like this we were able to see it
06:33 - really quickly well what we did things
06:35 - were getting at Li equals 1 2 3 4 5 6
06:37 - low and we're going Li 2 is just equal
06:38 - to well
06:39 - this added at the end of this and
06:41 - they're different entities right let's
06:43 - check well what happened by us changing
06:47 - Li - we actually changed Li one now how
06:52 - does that work well add something called
06:54 - immutability alright and when we change
06:58 - Li - since it's equal to Li one what
07:01 - actually ends up happening is we say Li
07:03 - - okay so what's Li - we're gonna append
07:05 - whatever this is a hundred thousand to
07:07 - it alright so let's go to Li - we see Li
07:09 - - and we say well that's equal to Li 1
07:10 - or Li so then we go to Li and we say
07:13 - okay Li is this we want to append to Li
07:15 - 2 which is Li 1
07:16 - so let's just add one hundred thousand
07:18 - three here because the way that this is
07:20 - stored in memory is simply one object
07:22 - and when we set Li two equals Li well
07:25 - all we're doing is giving Li another
07:26 - name now this is the way it works with
07:28 - lists if you don't want to understand
07:30 - the whole memory addresses and all that
07:31 - stuff that's fine just understand that
07:34 - if you say Li - equals Li and you
07:36 - created a new list then whenever you
07:38 - change something on Li - it's going to
07:40 - change Li 1 and whenever you change Li 1
07:42 - it's gonna change Li 2 again like if I
07:45 - do L I thought depend and we'll just add
07:49 - like three hundred like that both of
07:53 - these are gonna be changed so you can
07:55 - see that we get three hundred and both
07:57 - of these lists because these are exactly
07:59 - the same object okay now if we want to
08:02 - avoid this problem and we want to create
08:03 - two independent lists one which is a
08:06 - copy of the other the way that we can do
08:08 - this is simply type square brackets put
08:10 - a colon what this means is return a
08:12 - value from us from the beginning of the
08:14 - list to the end of the list and it's
08:15 - going to create a copy which means now
08:17 - that Li 2 is its own unique object which
08:20 - is the exact same as this except it no
08:22 - longer points to this it points to its
08:24 - own representation of this so we do this
08:27 - we now get 1 2 3 4 5 6
08:29 - hello 300 because we add that to the
08:30 - first list and we get the hundred
08:32 - thousand in the second list and you can
08:34 - see that they're no longer connected so
08:36 - understand that to create a copy you
08:39 - have to use square bracket colon square
08:41 - bracket and if you just want to create
08:43 - an alias which means another name for
08:45 - then you just simply assign it like this
08:47 - okay and that's the way it works notice
08:50 - you can have unlimited aliases you could
08:52 - do like
08:53 - li 3 equals pretty cool goes to L I -
08:58 - wow I really can't type okay x equals L
09:01 - ID 2 and then if you do any operational
09:04 - Li 3 it's gonna change Li 2 which is
09:05 - gonna change Li 1 right because these
09:07 - all Li three Li 2 and Li 1 are this one
09:10 - list and whenever you change this it's
09:12 - gonna change all the rest of them okay
09:13 - if you want to understand more about
09:14 - mutability are you confused I'll leave a
09:16 - link where I go through a really
09:18 - in-depth explanation and this will help
09:20 - you understand it if you're still
09:21 - confused okay top right corner or in the
09:23 - description okay now let me go in for
09:25 - you debility let's go into hmm what
09:28 - should we talk about sets and
09:29 - dictionaries and time complexity okay so
09:32 - lists in Python again right our square
09:35 - brackets sets so like s are in curly
09:39 - brackets like one four five six six
09:41 - seven okay dictionaries are in square
09:43 - square brackets as well except they're a
09:44 - little bit different because they have a
09:45 - key value pair all right so okay : five
09:48 - or so like test : eight okay now sets
09:55 - and dictionaries are different than
09:57 - lists in that they are an unordered
09:59 - collection of unique elements remember
10:03 - this definition well you can type it out
10:04 - for you okay on an ordered collection of
10:08 - unique if I could even type today unique
10:12 - elements okay and that can be changed to
10:15 - unordered okay unordered collection of
10:18 - unique elements remember remember this
10:20 - definition you will need to know this
10:22 - okay
10:22 - this simply means that each element in
10:25 - our set or a dictionary can only appear
10:27 - once and the order of it is completely
10:30 - ambiguous it doesn't matter
10:31 - so I'll prove this to you so in our
10:33 - first set which is just in these curly
10:35 - braces which is s okay if I print s
10:38 - you're gonna see that we get one four
10:41 - five six seven we don't get all of these
10:43 - sixes that is because it is a set of
10:46 - unique elements which means that if an
10:49 - element appears more than once in it it
10:50 - simply removes that element and says
10:53 - note we don't care about that it's
10:55 - already in here we're just gonna have
10:56 - one six in the reason this is important
10:59 - is because we use sets when we care if
11:00 - something exists not how many times it
11:03 - exists or where it exists
11:06 - if you care about the order of Donna or
11:08 - the occurrence or frequency of data use
11:11 - a list if you only care if data exists
11:14 - if it's there if one occurrence is there
11:16 - you use a set now why would I bother
11:19 - using a set when I can just use a list
11:20 - and get the order and get the data well
11:23 - a set is a lot faster than a list and
11:25 - the reason it's faster is because we
11:27 - don't care about the order of elements
11:28 - so whenever we look for something in a
11:30 - set it only costs us one operation
11:33 - Big O of one and this should be a Big O
11:37 - okay Big O of one four sets is to add
11:41 - anything to set to remove anything from
11:44 - the set and to find anything in a set
11:46 - that is how many operations it costs us
11:48 - for the set and I hope you know a little
11:51 - bit of Big O if you don't talk about in
11:53 - just a second all right now if you're
11:55 - trying to do this on a list to add any
11:59 - element into a list to add to the end of
12:01 - the list cost one to add to the
12:03 - beginning of the list actually costs and
12:05 - operations because when I add element
12:08 - zero into the beginning this list like
12:09 - what actually happens in my computer is
12:12 - we have to reshuffle every position in
12:14 - this list we have to say okay so now
12:16 - element one is moved into position one
12:19 - element two has moved into position two
12:21 - three three four four okay and zero gets
12:23 - index zero so that costs us the length
12:26 - of the list operations and the length of
12:28 - the list is always denoted by n okay the
12:30 - length of a list length was set length
12:32 - of any data always is represented by n
12:34 - so when we do that it costs us n now
12:38 - that takes a lot longer and times longer
12:41 - than it does to add in to set now the
12:43 - reason a set is so fast is cuz we don't
12:45 - care about the order of data and I'll
12:46 - show you that even though our set looks
12:48 - ordered like this it looks like it's
12:49 - going in a sending order I can prove to
12:52 - you it doesn't do that so I add an
12:54 - element undred and add an element
12:55 - negative 400 okay you'd think negative
12:57 - 400 go here 700 would stay there let's
13:00 - print ask to our screen and see what we
13:02 - get we get 1 4 5 600 negative 400 now it
13:07 - looks like it's just in the same order
13:08 - that we set it but if I do what do you
13:11 - call it negative 4 and 10 like this
13:14 - let's see what happens we actually get
13:16 - negative 4 shuffle to the end it's
13:18 - because the order does not matter
13:19 - although it looks like it's an order
13:20 - it's not okay this is not in order
13:23 - and that's why we can add things so fast
13:24 - because when we add them in we just add
13:25 - it into like a bubble okay and the
13:27 - bubble has no order it's just a bunch of
13:29 - things floating around in space that
13:31 - exists okay
13:32 - dictionaries are the exact same as sets
13:33 - except they have a key okay
13:35 - they run in the exact same runtime so to
13:37 - find something in the dictionary cost of
13:39 - one to add something is over one to
13:41 - remove something at so of one to access
13:42 - an element in dictionary
13:44 - you need the key of that element this is
13:46 - known as the key this is known as the
13:47 - value it's why it's called a key well
13:49 - I'll keep doing that key value pair
13:52 - there's two things once a key wants a
13:54 - value the key corresponds to the value
13:56 - okay so if I say dict hey this is going
13:59 - to return to me a value of five now just
14:02 - like lists and everything I can change
14:03 - this very easily I can say dict a equals
14:06 - 100 and this is no issue when if I print
14:08 - my dictionary to the screen then I will
14:11 - simply get a change value of hey
14:13 - corresponding to five or 200 and test
14:16 - eight and you can see that that gives it
14:17 - to me just like that
14:18 - notice that keys can be anything you
14:20 - want like I need like six corresponds to
14:22 - eight I could have a couple as my key do
14:24 - anything you want as those keys okay so
14:28 - it works the exact same speed as sets
14:30 - and yeah to delete a dictionary key you
14:34 - can see you can just do a del dictionary
14:36 - and then whatever the key name is to
14:38 - change it like I showed you to add a new
14:40 - key simply type the key once and do like
14:42 - key string seven equals five
14:45 - if I do that it's just gonna add that
14:46 - key in and you can see we get hey test
14:48 - and seven five same thing here there's
14:50 - no order okay so don't think there's an
14:53 - order same runtime very important that's
14:55 - why I keep talking about it these are a
14:57 - lot faster a lot a lot a lot faster than
15:00 - this okay in most cases again last thing
15:04 - I'm gonna say if you care about the
15:04 - order of the data use a list if you
15:06 - don't care about the order with a
15:07 - frequency of the data use a set or use a
15:09 - dictionary okay let's talk about tuples
15:11 - really quickly because these are kind of
15:12 - a weird data type and python tuples are
15:14 - represented like this so they're like t
15:16 - and i have curly braces like this and i
15:18 - got like five six or nine okay now
15:22 - although this looks similar to a list
15:24 - it's not so it is ordered meaning I can
15:27 - do something like T zero and I can find
15:30 - like the element in here
15:32 - okay because I don't know if I showed
15:33 - you but if I try to do s 0 this actually
15:35 - gives a crash because there's no zero
15:37 - index index don't exist so I tried to do
15:39 - dictionary and I put like a and I'm
15:42 - trying to index like hey by doing zero
15:44 - since the key 0 doesn't except exist in
15:46 - my dictionary it gives us an error okay
15:48 - just for warning I can do this there's
15:50 - an order and it's completely mutable
15:52 - which means I can't just do like T 1
15:55 - equals or sorry immutable I can't do
15:57 - like T 1 equals 5 like I try to do that
15:59 - and I run did it mean to run in debug
16:02 - mode you can see a temple object does
16:04 - not support item assignment which means
16:06 - that it is immutable and if I did like
16:08 - does that equals T and then I'd changed
16:10 - Zed it would not it wouldn't change T
16:13 - okay
16:13 - it's G understanda okay let's get rid of
16:16 - this and now let's go into the fun stuff
16:18 - which is algorithms and recursion which
16:23 - should i do first you know what i think
16:24 - i'm going to talk about recursion first
16:25 - and then go into actually we're already
16:27 - on the topic of run time let's go into
16:29 - algorithms okay i'm gonna create a
16:31 - function you can say this is sort all
16:33 - right in here I'm gonna put a list let's
16:37 - stand for Li all right inside of here
16:40 - I am going to sort a list using Python
16:43 - sort method okay I'm going to return Wow
16:47 - okay return Li dot sort all right and
16:51 - down here I'm gonna create list was it L
16:53 - R equals like one two three six I should
16:57 - probably add some stuff to sort in here
16:59 - and let's just add like a hundred in
17:02 - here okay and then if I print to the
17:05 - screen sort alright let's see what we
17:09 - get okay none return oh sorry
17:14 - let's do this one second I'll talk about
17:16 - this is a second because I sell so
17:17 - another mistake people yet Li does sort
17:19 - print sort Li just say sort Li print Li
17:24 - Wow
17:25 - I even made the mistake that shows you
17:26 - how common it is okay sort Li there we
17:28 - go okay so the way that this sort method
17:31 - works in Python is it takes a list and
17:35 - rather than returning a new list that is
17:39 - sorted it simply sorts the existing list
17:42 - and you can see here that I say Li
17:44 - equals like this list I call my sort
17:47 - function which simply does Li dot sort
17:49 - so this is the exact same as just doing
17:51 - a lie dot sort after here okay and then
17:54 - I print Li and we get the sorted version
17:57 - of it how does this work well this works
18:00 - because of mutability so the way that
18:03 - this can actually operate is since lists
18:07 - are mutable and we can change them
18:08 - without like reassigning them without
18:10 - saying like Li equals Li dot sort we can
18:14 - call this method on it now you guys saw
18:16 - what happened when I tried to for
18:18 - example return Li dot sort well what
18:22 - this does is since this is a method okay
18:25 - and I'm calling Li dot sort
18:28 - well Li dot sort doesn't return a value
18:31 - it just sorts the list so when I return
18:33 - the value of Li dot sort it's equal to
18:36 - none because again it doesn't return
18:39 - anything to us so let like the Python
18:41 - built-in function that sorts all it does
18:44 - is sort the list it doesn't return it so
18:47 - if we try to return what is being
18:49 - returned from there nothing's being
18:50 - returned from there so we're essentially
18:52 - returning none I hope that makes sense
18:53 - on how that works cuz a lot of people
18:55 - what they do is say Li equals Li dot
18:57 - sort like literally exactly what I did
18:59 - and then it prints none and they're like
19:02 - what like what the heck why isn't it
19:03 - working
19:03 - it's because when you call this sort
19:05 - method on a list it just sorts the list
19:08 - in place like it doesn't create a new
19:10 - list it just sorts the original list
19:11 - that's really important it seems trivial
19:13 - but like a lot of people make that
19:15 - mistake I even made a mistake and I've
19:17 - been coding a Python for way too long to
19:18 - uh to have made that right now I'm going
19:22 - to show you what the sorted function
19:24 - does and then I'm going to talk about
19:24 - the time complexity of all of these okay
19:26 - so sordid is a little bit different so I
19:29 - say a sorted and then I do Li this is
19:34 - the opposite of dot sort what still
19:36 - sorts it but it just returns to us a
19:39 - sorted list so what should I say sorted
19:41 - Allah and I print Li watch what happens
19:42 - Li does not change because this function
19:46 - what it does is it returns to us a new
19:48 - list which is a version of Li that is
19:51 - sorted so if I wanted to have this
19:53 - change I would have to say
19:55 - li equals sorted Li and now we get the
19:59 - sorted list so whenever you call sorted
20:02 - on something it returns to you the
20:04 - sorted list creates a copy of that list
20:06 - whereas when you call dot sort it simply
20:09 - just sorts the actual list and changes
20:11 - it now you can run into a lot of issues
20:12 - when you want to sort something but you
20:15 - want to have the original list as well
20:16 - and you decide to call dot sort because
20:20 - now what you're doing is instead of
20:23 - creating a new list you're just changing
20:25 - this original list and you care about
20:27 - what is in the original list right so
20:29 - now you've just lost all your data and
20:30 - it's a huge problem that people run into
20:31 - all the time okay
20:33 - now let's talk about how fast all these
20:35 - are speed speed speed common exam
20:37 - questions how fast do certain sorting
20:39 - methods work now in computer science
20:41 - there's main sorting methods gamma I'm
20:43 - gonna write a few down here there's
20:45 - bubble sort the most famous and the
20:47 - simplest there is in search and sort
20:49 - there is shell sort there is merge sort
20:55 - we have what you call it heapsort and we
21:00 - also have the famous quick sort now how
21:04 - fast are all of these and how can we
21:07 - determine the speed I'm just going to
21:08 - write down the speed in case any of you
21:10 - need a quick review and then we will
21:12 - talk about why in a second so that's o N
21:14 - squared which means whatever the length
21:16 - of the list is and always represents our
21:18 - length of our list it's gonna take n to
21:22 - the power of two so the length of list
21:23 - to the power of two time to sort that
21:25 - okay insertion sort is the same and to
21:27 - the power of two shellsort ranges okay
21:31 - so it can actually have multiple
21:34 - different times based on the sequence
21:36 - this is typically not when you're gonna
21:37 - have to know but I'm just going to tell
21:38 - you in case you do it ranges from o of n
21:41 - log to the power of two n to what do you
21:47 - call it and log or not am I saying sorry
21:52 - N squared okay so based on the sequence
21:55 - in which you're sorting it on it can
21:57 - range in the complexity so just know
21:58 - that it's it's not faster than merge
22:01 - sort heap sort of quicksort but it is
22:03 - faster than searching sort and bubble
22:04 - sir okay that's probably all you're
22:05 - gonna have to know if you even have to
22:06 - know if she'll sort merge sort
22:08 - in what do you call it log N and log n
22:12 - so the length of the list time longer
22:14 - than n okay next one
22:17 - heapsort also runs in O n log n okay and
22:22 - quicksort is the one that most
22:24 - programming languages use typically runs
22:27 - in n log n pythons sort method that we
22:30 - were using there runs the quicksort
22:33 - sorting algorithm okay so what are these
22:36 - and what the heck does all this stuff
22:38 - that you just typed even mean okay so
22:40 - pretty much these are different methods
22:42 - to sort I think that's all it is there's
22:45 - tons of different ways these are just
22:46 - some of the most famous and basic ones
22:48 - you will need to know on your exam most
22:51 - likely the runtime analysis of these
22:53 - it's pretty straightforward okay it's
22:55 - either N squared or n log n shell sort
22:58 - is a little bit different you probably
22:59 - don't have to know that one bubble sort
23:01 - and insertion sort the reason they take
23:03 - N squared is because they run through
23:04 - the data two times okay so ever like n n
23:09 - times for every element and I'll show
23:12 - you in just a second merge sort runs in
23:14 - and log n heap sort n log n quicksort
23:17 - and long and these are your fastest
23:19 - sorting algorithms these are the ones
23:21 - you always want to use if possible okay
23:24 - let's just write an example quickly of
23:26 - maybe a sorting algorithm algorithm and
23:29 - talk about the time complexity of it
23:30 - because we're talking about that now so
23:32 - how can you determine the time
23:33 - complexity of a program just given like
23:36 - a function or something okay
23:37 - I'm going to show you how to do this and
23:39 - it's like to fly and run and say a list
23:42 - which is well obviously just gonna be a
23:44 - list it's gonna be of length n all right
23:47 - just so we understand that and in here
23:49 - let's do something okay for every
23:52 - element I'm going to say for L stands
23:55 - for element in Li we're gonna check if
23:58 - the element equals equals one okay and
24:01 - if the element equals 1 we're gonna loop
24:02 - through the list again or si for L 2 and
24:06 - L I print el2 okay now this function
24:12 - makes no sense like there's no reason
24:14 - why we'd want to do this but we're just
24:16 - gonna go through and analyze the time
24:18 - complexity okay so we're going to call
24:20 - this function
24:21 - when I say run on one two three four one
24:25 - six seven eight okay and let's see what
24:28 - we print out and then we'll talk about
24:29 - it so we get a bunch of numbers together
24:30 - yeah like 1 2 3 K now the way that we
24:34 - can determine how fast this is going to
24:36 - run is by looking at loops okay so n is
24:40 - the length of our list in operation is
24:44 - like one operation represents one okay
24:47 - so for example in whenever I check this
24:49 - sorry this is hard to explain I'm trying
24:51 - to think of better way and I just lost
24:52 - my mouse okay there you go sir
24:54 - this if statement down here costs us and
24:57 - we're just gonna think about this as
24:59 - cost o of one operation because we've
25:02 - now looked at the data one time and
25:04 - we've done something with the gate costs
25:06 - us o of one this print statement we can
25:08 - think of as costing us o of one okay
25:11 - because we printed one thing if I add
25:13 - another thing I said like x equals five
25:15 - like randomly x equals five we can think
25:16 - of this as costing us o of one operation
25:19 - which means constant okay this is
25:21 - constant time like no matter how many
25:23 - times we do this it always costs us o of
25:25 - one okay it doesn't matter what the
25:27 - length of the list is the length of list
25:28 - could be ten million every time we
25:30 - execute x equals five it costs us o of
25:32 - one which is constant time okay these
25:36 - loops however cost us a lot more and how
25:39 - many times these loops gonna run well
25:41 - for Li it's gonna run and times right
25:45 - don't say o of n because if we have I
25:49 - don't know 10 elements in our list then
25:51 - this loop needs to run ten times so and
25:54 - representing the length of our list how
25:55 - many times this loop is gonna run what
25:57 - about this loop inside of here well how
26:01 - many times could it possibly run
26:02 - whenever we're looking at time
26:04 - complexity we want to look at the worst
26:06 - possible case so you're saying if Li
26:10 - equals 1 we're going to run this loop
26:11 - now in this instance this loop is only
26:14 - gonna run twice because we only have one
26:16 - two times right
26:18 - but what if every element our list was
26:20 - one and that's completely possible
26:22 - there's nothing saying that can't happen
26:23 - then that would mean that this list are
26:25 - this loop would run at times okay so we
26:30 - have over 1 here and got over 1 or 1
26:33 - and then we're running this loop n times
26:37 - and running this loop end times so
26:39 - what's the time complexity of this
26:41 - algorithm how like how long does it take
26:43 - to run so we can look at here we're
26:45 - gonna say for every row of n right
26:48 - then we're gonna do all of this which
26:50 - means we're gonna have one operation for
26:51 - every n so that's one times n so we'll
26:54 - do we're just gonna say x one okay and
26:57 - then we're gonna also run over N times
27:00 - Co so we'll run o n times every event
27:05 - I'm certain times K and then we're gonna
27:07 - do two operation we're gonna print and
27:09 - we're gonna say X ago swap so that's of
27:10 - one plus o of one right so what does
27:17 - this give us well if we give equals n we
27:18 - do a little bit of math here we can see
27:20 - that that's actually gonna give us a
27:21 - value of oh of and right because we're
27:25 - multiplying by one and then oh of n
27:27 - times over well what's that that's oh of
27:29 - N squared so and to the power of two
27:32 - okay and after this we'll we have old
27:35 - 101 which means we're gonna get again
27:37 - another what do you call it wow I don't
27:41 - know what I just rented there again
27:42 - we're gonna get another event another
27:44 - two times okay so we're gonna have Oh N
27:47 - all right so let's add these up now and
27:49 - see what we get well we do a little bit
27:52 - of simplification here we can say that
27:55 - equals three O of n plus o of n to the
28:02 - power 2 so this is our run time of this
28:05 - algorithm however we want to reduce this
28:10 - and simplify this and the way that we
28:12 - can do this is by removing constants
28:14 - okay
28:14 - so o 1 times o of n we get it's like all
28:19 - these these ones here are known as
28:21 - constants okay they run in constant time
28:22 - it doesn't matter how long our list is
28:25 - these are always going to take one
28:26 - operation to run so we can actually
28:28 - remove them which means that now our
28:30 - operation becomes what we get rid of
28:32 - this okay and we get rid of this and we
28:34 - get event x o of n which means that now
28:37 - our final product is just oh of N
28:38 - squared
28:39 - another way to do this is you can
28:40 - multiply it out like I did so like let's
28:42 - say we just we get to the point here
28:44 - we're at Oban plus 1 squared plus o of n
28:46 - Levin now we have 300 event plus o of n
28:50 - to the power two now this 300 event is
28:53 - much much much much smaller than L of n
28:56 - squared let's think about this for
28:58 - example because we only really care
29:00 - about Big O analysis for like extremely
29:02 - large piece of data because that's gonna
29:05 - determine literally how long it takes if
29:07 - you're just running this on 10 elements
29:09 - it doesn't matter if you run three
29:11 - thousand operations on those tenets is
29:12 - so going to run like instantly right so
29:15 - let's plug in ten million here okay ten
29:17 - million to the power of two how much
29:19 - larger than that is three times ten
29:21 - million well that is a lot larger so we
29:26 - can simply omit this three O of n
29:28 - because this o of N squared is going to
29:30 - overpower that so much that we just care
29:33 - about that okay and that's how you can
29:35 - look that Big O analysis the way that I
29:37 - typically do it is just look at the
29:39 - loops and look at how many times each
29:40 - loop could possibly run so we say we
29:42 - have okay we have this if statement but
29:43 - we don't care about that we have this
29:45 - print we don't care about that we have
29:46 - this X we don't care about that you
29:48 - could have infinitely many more
29:49 - operations in here we don't care about
29:51 - them unless they're a loop so if we can
29:54 - run another for loop and we say like for
29:55 - you O for in Li now what we've gotten is
30:00 - well we have a chance to possibly be
30:03 - hitting this third for loop every single
30:05 - time we run the program which means now
30:07 - we have well o of N squared times what
30:10 - another event so that's gonna give us
30:12 - well o of n cubed and this is a very
30:16 - slow algorithm because we have to do oh
30:19 - of n cubed operations to get our result
30:22 - okay I hope that makes sense for like a
30:25 - really basic comparison now let's let me
30:27 - show you log N and O of n just simple
30:32 - because that was like a pretty complex
30:33 - example okay and I'm gonna do this by
30:36 - showing searching algorithms so I talked
30:38 - about sorting algorithms now we're going
30:39 - to talk about searching algorithms now
30:41 - sorting algorithms obviously are gonna
30:42 - take a lot longer than searching
30:43 - algorithms because we have to change
30:45 - that around we have to move them we have
30:46 - two operations on them whereas searching
30:49 - algorithms we're just looking for
30:50 - something right so I have a list and I
30:52 - set this equal to like 1 2 3 4 5 6 7 8 9
30:55 - and ten okay here we go list ascending
30:59 - order one to ten I want to find the
31:01 - element eight for example how can I go
31:04 - about doing this well the most simple
31:06 - way to do this is you say okay for I in
31:10 - range and we'll say the length of Li
31:15 - okay what we can do now is we can say
31:19 - well if statement here if Li I Wow okay
31:25 - equals equals looking for and I'm going
31:29 - to create like what I'm looking for up
31:30 - here okay looking for equals eight okay
31:35 - then what we're going to do is simply
31:38 - say I need another variable found equals
31:43 - negative one so found equals eight or
31:47 - eight found equals I because that's the
31:49 - index at which it occurred okay so we're
31:52 - doing here is we're looking through
31:53 - every element in the list okay we're
31:55 - gonna see if that element is equal to
31:56 - what we're looking for and if it is when
31:57 - I say found equals I and you're going to
31:59 - break B list because if we found the
32:01 - element well we don't need to continue
32:03 - looking through okay so then we can
32:05 - print found all right and let's see what
32:09 - we get
32:09 - we get seven okay that's the index at
32:12 - which we found it now what is the
32:13 - runtime analysis of this algorithm well
32:16 - first of all this is known as a linear
32:17 - search so that might give you a hint
32:19 - linear search okay see if you can
32:22 - understand what that means
32:23 - the runtime analysis of this and I hope
32:25 - you're able to guess it is n now the
32:28 - reason this is n is because the length
32:29 - of our list is known as n in this case
32:31 - it is a length 10 okay and we could run
32:35 - this for loop at most ten times now how
32:39 - could we run it ten times well what if I
32:41 - do this and say one two three four five
32:44 - six seven eight hour six seven zero nine
32:46 - ten well where's our element it does
32:50 - exist that means we're gonna look
32:52 - through the entire list just to find out
32:53 - that our element does not exist unless I
32:55 - have this found negative one so that if
32:56 - you get to the end it says negative one
32:58 - you know you didn't find it right and
32:59 - that is a linear search looking through
33:02 - every single element a list always
33:04 - happens n times right and again we don't
33:07 - care about these operations we don't
33:08 - care about a sound
33:09 - found equals AI or Li equals AI whatever
33:13 - it like we don't care about that because
33:14 - these run in constant time whereas this
33:17 - is dependent on the length of the list
33:19 - okay now I'm going to talk about binary
33:22 - search so this is linear search the most
33:24 - basic search like you usually come up
33:26 - with this without even knowing anything
33:28 - about computer science right binary
33:30 - search is a little bit different now
33:32 - binary search only works on a sorted
33:35 - list I'm going to show you why so I have
33:37 - a sorted list one through ten okay and I
33:41 - want to find the element three now if
33:44 - you're clever and you know a little bit
33:45 - about computer science you know that
33:47 - there's a much faster way to find that
33:49 - element rather than looking through
33:50 - every element of the list because we
33:51 - know that the list is sorted so if we
33:54 - know that the list is sorted there's
33:56 - something sneaky that we can do and I'm
33:58 - just gonna illustrate to you and then
33:59 - I'm gonna code it so pretty much what
34:02 - we're actually able to do is and the way
34:03 - this algorithm works is we're gonna
34:04 - start and we're gonna look in the middle
34:06 - of the list rather than going from
34:08 - beginning it to the end and look at the
34:10 - middle of the list we're gonna grab this
34:11 - element which this case is five okay
34:13 - look at that middle list we're looking
34:14 - at five we know the element we're
34:17 - looking for is one or two or three or
34:19 - whatever case let's say we're looking
34:20 - for two what we're gonna do now is going
34:22 - to split this list into two we're gonna
34:24 - say elements that are greater than five
34:25 - and elements that are less than five so
34:28 - we're gonna check ran say was two less
34:30 - than or equal to five it's less than
34:33 - five that means that any element above
34:35 - five since we know the list is sorted
34:37 - can't be two so let's just remove that
34:39 - from our search query and no longer look
34:41 - there okay next now we're gonna look at
34:44 - the middle of this list
34:46 - so we've now essentially cut this list
34:47 - in two right we were had ten elements
34:49 - now we only have five so now we're in
34:51 - the middle of this new list we're
34:53 - looking for two we're at three so we
34:55 - look at three and we say okay is two
34:58 - less than this or is 2 greater than this
35:01 - well twos less than this so that means
35:04 - we're gonna remove all of these elements
35:05 - and we actually remove the middle at
35:07 - element as well because we know that if
35:09 - it's less than or greater than it it's
35:10 - not age right okay now we have a list
35:13 - one or two we're gonna look at the
35:15 - middle of the list in this case we'll
35:16 - just grab 0 just you could either grab
35:18 - one or two if it Steven list it doesn't
35:19 - matter
35:19 - and I say okay so is
35:22 - less than 1 no it's not ok is to greater
35:25 - than 1 yes it is so we remove and now we
35:27 - have one element left in our list which
35:29 - is the element we're looking for and
35:30 - we've been tracking the indexes the
35:32 - whole time so we know that it occurs at
35:34 - index 2 right or index 1 or whatever ok
35:37 - no safe say that we haven't exactly
35:40 - doing 1 2 3 4 5 and the first time we
35:43 - look at is 3 another operation mundi
35:45 - which I didn't really say is we're first
35:46 - gonna check if the element is the one
35:47 - we're looking for and if it is that
35:49 - we're just gonna break out we already
35:50 - found it ok otherwise then we continue
35:54 - doing that process now how does how fast
35:57 - does this work well give you a second to
35:59 - think about it but think that every time
36:03 - that you look through the list you cut
36:05 - the list in half right so if you have a
36:07 - list of 10 well you can just run some
36:09 - basic math you say ok so 10 we look
36:10 - through and we get now we're at 5 we
36:13 - look through it so 5 divided by 2 okay
36:15 - let's say our list now is what do you
36:18 - call it 2 3 okay we divide that by 2 and
36:21 - now we're at one element all right and
36:23 - we just keep dividing so the way that we
36:25 - actually do this in math is log base 2
36:27 - of n because however long our list is
36:31 - well every time we cut it into so it's
36:33 - actually log base 2 of N and if you run
36:36 - like math logs on stuff saw as an import
36:39 - math you can see that how much faster
36:42 - and how many more or how many less
36:43 - operations were actually gonna have to
36:44 - run if I just do math dot log there we
36:49 - hope you've been telling me here and
36:50 - we'll do of a massive number base to
36:53 - watch what we get oh I just freakin
36:57 - printed to the screen turns a lie okay
37:01 - let's try this we get 26.5 so instead of
37:04 - doing whatever this is like a million or
37:06 - ten million operations we do 26.5
37:08 - operations to find our element that is
37:11 - freaking amazing that we're able to do
37:13 - that so now let's code it and see how it
37:16 - actually works so define
37:19 - binary underscore Wow okay I'm really
37:22 - not type of enough all right behind
37:23 - Harry underscore search don't know what
37:25 - happened there
37:26 - anyways and then we will put our list
37:28 - which me a lie and say X and X is gonna
37:30 - be what we're looking for okay we're
37:32 - gonna do here's gonna have to bears a
37:34 - top equals the
37:35 - length of our list and bottom is equal
37:39 - to zero and what we're gonna do is we
37:43 - are going to change bottom and top to
37:46 - slice our list in half and the reason we
37:48 - can't just slice the list right we have
37:50 - to do the bottom and top variables
37:51 - because we slice it then we're gonna
37:52 - lose the indexes at which our number is
37:55 - we can't just say like to divide the
37:58 - list in two and then take like a new
37:59 - list and look at it we look at the same
38:01 - list just from different indexes right
38:02 - and say well top is greater than bottom
38:07 - because if we get to the point where
38:09 - bottom is greater than top then that
38:10 - means now we're like flipped around and
38:12 - list and our element doesn't exist in
38:14 - there like we haven't found it yet so we
38:16 - need to stop running at that point what
38:18 - we're gonna do is we're going to say
38:19 - middle which is we need the middle index
38:21 - is gonna be equal to top plus bottom in
38:25 - brackets I've made this mistake earlier
38:28 - integer divided by two it's gonna give
38:30 - us the middle index or list right now
38:31 - we're just gonna check the first thing
38:33 - that we always check is like if the
38:34 - middle is actually our element that's
38:36 - what we're looking for
38:36 - so we'll say if Li at index middle is
38:40 - equal to X then let's simply return
38:45 - middle because we're done we found it
38:48 - okay otherwise so L if Li middle is
38:54 - greater than X then what we have to do
38:58 - is change the bottom so now we're gonna
39:00 - shoot the bottom upwards because we
39:03 - don't need to look at anything below
39:05 - that middle index right because we know
39:07 - it's gonna be greater so we can simply
39:09 - say that middle is going to be equal to
39:12 - or may not want to miss it bottom is
39:15 - equal to middle plus one now the reason
39:20 - we can do this is only if we know that
39:24 - the element exists in the list okay if
39:26 - you don't know the element exists
39:28 - analyst you gotta leave this as middle
39:30 - because if you try to add one to the
39:33 - middle like this right and there's only
39:35 - one element in the list and that's not
39:37 - the list then you're gonna run into like
39:41 - an index error so I'm gonna leave it
39:42 - plus one but just just so you understand
39:43 - that okay otherwise and so if it's not
39:46 - greater then it's not equal to it must
39:48 - be less than
39:48 - if it's less than we're gonna change our
39:50 - top and our top must be equal to middle
39:53 - index plus one I think um let's see here
40:00 - one of them is minus and one of them's
40:01 - plus okay let's just see if this works
40:03 - and then we'll play around at it because
40:04 - I honestly forgets and for some reason
40:07 - I'm not thinking too great right now
40:08 - okay so binary search and then let's go
40:11 - in here let's create a list that's
40:13 - bordered okay nine ten and let's look
40:17 - for element four see if we run into an
40:19 - issue here oh we didn't okay
40:21 - I am D equals the second time I've done
40:24 - nine now probably actually more than
40:25 - that sure someone's counting print IND
40:28 - none we didn't return anything so we
40:31 - didn't find it that means we had an
40:32 - issue with our middles let's just do
40:34 - this this is gonna work and it's gonna
40:36 - be slower oh and now we're running into
40:38 - an issue Li middle equals equals x
40:42 - bottom equals Middle top equals middle
40:45 - okay give me one sec I'm gonna have a
40:47 - look and I'll come back okay so
40:49 - apparently uh I wasn't thinking very
40:52 - very well when I made this so you can
40:54 - see I changed the sign now pretty much
40:55 - it's cuz usually I say like if X is less
40:58 - than Li but for some reason I decided to
41:00 - do it the other way anyways you just
41:02 - need to flip this sign around so that
41:05 - it's actually gonna work because what we
41:07 - were saying before is if if the index in
41:10 - the list is greater than X they were
41:13 - saying bottom it would be like
41:14 - incrementing bottom to move up so we'd
41:16 - never find the element but now it's the
41:18 - other way around so it's proper so you
41:20 - see we round this now I just changes to
41:22 - seventeen to make sure I was working but
41:23 - uh we get with the correct index and you
41:25 - can chain just whatever index you want
41:26 - and you - oh now we're running into
41:29 - another issue great let's see
41:37 - okay so there you go so just make sure
41:40 - you get rid of this minus one now as
41:41 - well
41:41 - and there you go sorry about butchering
41:44 - that algorithm for you guys but I just
41:46 - work and do it as well anyway so that's
41:48 - how this binary search algorithm works
41:50 - if you want to see an example of how
41:52 - this works really quickly I'm gonna fast
41:55 - forward once I've created like a massive
41:57 - list and then test it on it and show you
41:59 - it versus the linear search so you can
42:01 - see how how much faster it is so just
42:03 - yeah bear with me okay
42:05 - so I'm just gonna run the program now
42:07 - it's already tested it once but pretty
42:09 - much all I did is just create like a
42:10 - random list and then we do a binary
42:13 - search and then we do a linear search
42:14 - and you can just kind of see by when it
42:15 - prints how much longer one of them takes
42:17 - any other it's hard to show you like a
42:19 - really relevant example because the
42:22 - memory limit on my computer doesn't let
42:23 - me do any more digits in this random
42:25 - list so I can only search like so many
42:27 - but you'll you'll see like there's quite
42:30 - a bit of a time difference I guess
42:32 - relatively so when I run this it's gonna
42:34 - take a second to actually create this
42:35 - list this is the longest part that's why
42:37 - I print start searching binary so you
42:39 - don't think that it's doing that anyway
42:42 - so we started and ended binary instantly
42:45 - and linear did take a few seconds to run
42:47 - now if I have another zero to this you
42:50 - would see the linear would take a lot
42:53 - longer to run where binary would still
42:55 - run pretty well instantly and you can
42:57 - actually prove how many operations this
42:58 - runs in but just saying like our equals
43:01 - math dot log of whatever this number is
43:05 - and then what do you call it base to and
43:09 - then if I print that to the screen so
43:11 - instead of printing all this jazz what
43:12 - was print are get rid of this and run
43:16 - this you can see that it only runs 26
43:20 - operations right and if I remove a zero
43:22 - you'll see that it runs in 23 like if I
43:25 - just keep adding adding adding adding
43:27 - zeros and it hardly runs in 43 like
43:30 - that's how many operations this many
43:32 - pieces of data in a list takes to find
43:34 - so that's incredibly fast and it's
43:36 - that's why binary search is so important
43:38 - so a recap binary search runs in log n
43:41 - linear search runs in n ok log n is
43:44 - exponentially faster than n alright if
43:48 - you guys are still here
43:50 - I commend you because this has been a
43:51 - very long video but right now I'm gonna
43:53 - go over recursion now recursion is it's
43:58 - a fun topic I guess you could say and
44:00 - there's three standard rules to
44:02 - recursion so for something to be
44:04 - recursive first of all it must be a
44:06 - function so in this case I'm going to
44:08 - call function say X okay and we're going
44:12 - to return func of X plus one okay and
44:18 - for someone to be recursive there's
44:20 - three rules we've satisfied the first
44:22 - rule the first rule is it must call
44:24 - itself a recursive call means that the
44:26 - function within its function body so the
44:29 - indentation makes a call to itself it
44:33 - can make multiple calls can make one
44:34 - call can make ten calls it can make
44:37 - unlimited calls actually can't do
44:39 - unlimited because on the programmer
44:40 - crash but anyways okay that is the first
44:42 - criteria the second criteria is it must
44:45 - have a base case so right now if I were
44:47 - to run this my program would crash and
44:49 - it would give me a stock error because
44:51 - what I constantly do is just keep
44:53 - calling this function and I never
44:55 - terminate and that is an infinite loop
44:57 - of recursion so we must have a base case
45:00 - so for example if x equals equals zero
45:05 - return zero okay that could be base case
45:08 - and every time I run X every time I run
45:11 - this function we would eventually get
45:14 - closer to X and this leads me to my
45:16 - third criteria this is not a proper
45:18 - recursive function by the way I'm going
45:19 - to talk about a proper one in a second
45:21 - the function must get closer and closer
45:24 - to that base case with every function
45:26 - call so for example if I call a value of
45:29 - x and I know that my function is going
45:32 - to return a or is going to be given a
45:34 - positive value of x every time I run
45:36 - this function and it runs through it
45:37 - subtracts one from X which is
45:39 - essentially moving closer to our base
45:40 - case of where x equals zero and we can
45:42 - just return zero okay so that is how
45:46 - these are the three basic criteria for
45:48 - recursion for something to your cursor
45:49 - it must do those three things I'm going
45:52 - to show you the most trivial example of
45:53 - recursion that I possibly can and it is
45:57 - factorial if you don't know what
45:58 - factorial is I think it's like
46:00 - exclamation point five stands for
46:02 - factorial
46:03 - and that is equal to all of the numbers
46:05 - underneath five multiplied by each other
46:06 - so that is fought four times three times
46:09 - two times one and I actually think five
46:12 - is included as well
46:13 - five times four times three times two
46:14 - times one that is the factorial of 5 so
46:17 - you can see that as we keep multiplying
46:19 - this it gets much and much larger if I
46:21 - were to do the factorial of 10 like
46:23 - that's a massive number okay so you can
46:25 - say define fact which could be factorial
46:28 - of n and it's going to be the number
46:30 - that we're given not to be confused with
46:32 - the length of a list what we're going to
46:34 - do here is we are going to set up our
46:36 - three criteria so the first criteria is
46:38 - a must call itself we're gonna do some
46:39 - different order we're going to set a
46:40 - base case R and say if and equals equals
46:43 - 1 return 1 because the factorial of 1 is
46:48 - 1 this is the case that we know so we
46:51 - can return we could also do factorial of
46:54 - 2 which is 2 if we wanted to make this
46:56 - simpler
46:56 - we'll say return 1 I think we'll sequels
46:58 - to return too because you know what
47:01 - that's fine or what say n is yeah okay
47:03 - that's fine all right otherwise so if n
47:07 - is not equal to 2
47:08 - well we must call herself and we must
47:10 - get closer to 2 so what we're gonna do
47:12 - is we're going to return the current
47:15 - number times the factorial of the last
47:18 - number and that will give us the numbers
47:20 - we're gonna return n multiplied by the
47:23 - factorial of n minus 1 because if you
47:26 - think about it 5 factorial is equal to 5
47:29 - x 4 factorial right and 4 factorial well
47:35 - 4 factorial is equal to 3 factorial x 4
47:40 - so other way around 4 x 3 factorial and
47:44 - you can keep going on and on until
47:45 - eventually you hit 2 and we know the
47:47 - answer to 2 so we can traverse backwards
47:49 - and find the answer to 5 factorial so
47:52 - might seem confusing but lets me run it
47:53 - for you factorial 5 let us print this
47:57 - out to the screen I believe it's
47:59 - actually I don't know let's do it again
48:01 - 120 is the factorial 5 so 5 times 4
48:03 - times 3 times 2 times 1 the factorial 4
48:07 - let's see is 24 factorial 3 test this
48:11 - out is 6 3 times 2 times 1
48:13 - okay it makes sense factorial 1
48:17 - we just get an issue for one because we
48:19 - said if it equal to two okay you know
48:20 - what we can do another base case if and
48:22 - equals equals 1 return one and then just
48:25 - assume that we're going to return a
48:28 - number greater than one okay we're gonna
48:30 - be given a number greater than or equal
48:31 - to one okay so now we're gonna talk
48:33 - about something which is height of
48:35 - recursion which I almost can guarantee
48:37 - if you've learned recursion will be a
48:39 - question on your exam I'm gonna show you
48:40 - a very basic standard way to solve this
48:43 - problem and it does involve like a
48:45 - pencil and paper so I just took a break
48:46 - quickly I just pulled out my tablet now
48:48 - I'm just gonna draw on the screen here
48:51 - excuse is black okay to use let's use
48:53 - red excuse my messy handwriting but
48:55 - anyways we're just gonna run through the
48:57 - factorial of 5 okay so we're just
49:00 - literally gonna run through this
49:01 - function and see how many times we call
49:03 - the function because the hyde recursion
49:04 - simply means how many times we actually
49:07 - make this function call right so to do
49:10 - this we start at five we go and and
49:13 - we're just gonna look when you say is
49:14 - five you want no it's fabulous to so
49:17 - we're gonna return so art wow I really
49:20 - do have messy handwriting written with
49:21 - this tablet in a while so excuse me it's
49:23 - gonna be five times the factorial of 4
49:28 - okay so that's our first function call
49:31 - or our first one can call is actually
49:32 - this so we'll just say factorial of 5
49:37 - okay and then 5 times factorial 4 ok now
49:40 - we're looking at factorial 4 factorial 4
49:42 - is it's not one it's not two so that is
49:45 - n times factorial 3 and n in this case
49:48 - is 4 because we've passed four so that's
49:50 - multiplied by the factorial of 3 ok next
49:56 - one let's see here so we have three now
49:59 - right so three multiplied by the
50:02 - factorial of 2 and now we'll look at
50:06 - factorial of 2
50:07 - what's factorial 2 well factorial of 2
50:09 - is just 2 so now we have 3 times 2 and
50:13 - now we're just gonna have to and we're
50:17 - not gonna return this right so we have 5
50:19 - times 4 times 3 times 2 and it's okay
50:22 - that we don't do this one because
50:24 - anything multiplied by 1 is simply
50:26 - itself right so 5 times 5 the factorial
50:28 - 4 is
50:29 - five times four times factorial three
50:31 - now what's factorial three well that's
50:32 - five times four times factorial of 3
50:34 - times factorial 2 okay so our height of
50:37 - recursion in this case is 4 because we
50:40 - have one two three four function calls
50:42 - now this is a really basic example but
50:45 - it kind of walks you through how it
50:46 - works right so we go five times factory
50:49 - for factorial 4 is 4 times factorial 3
50:51 - factorial 3 is 3 so if you sub all these
50:53 - in right like say a sub in this right
50:56 - here 4 factorial 4 and then I sub in
50:59 - this 4 factorial 3 and then you just
51:01 - keep moving up then you can find like
51:03 - your answer for that actual thing if you
51:05 - didn't know what the factorial of 5 was
51:07 - you could just run through that to find
51:08 - it
51:08 - ok I'm gonna close that I'm gonna type
51:10 - out another example now that's a little
51:13 - bit more complicated and this is gonna
51:14 - be like a what do you call like in a
51:16 - rhythmic series I think that's what you
51:19 - call it like given a number
51:21 - it adds the last two numbers you guys
51:23 - will you guys will see what it is I'm
51:24 - just gonna call this a R of N and what
51:28 - I'm simply gonna do NSA if n equals
51:31 - equals 1 return 1 and let's see Inc 2 is
51:39 - equal to 0 we're gonna work through this
51:42 - together because I forget the exact case
51:44 - otherwise we're going to return a R of n
51:50 - minus 1 plus the a r of n minus or it
51:57 - should be other way around n minus 1
51:58 - plus the a R of n minus 2 so we're gonna
52:01 - end up getting a sequence that looks
52:03 - something like this and you guys will
52:04 - see in a second so it starts at 1 1 2 3
52:09 - 5 8 8 plus 5 is 13 13 plus 8 is 21 and
52:15 - this is the sequence I'm going for so we
52:17 - want to generate a sequence based on
52:19 - however many numbers so in this case the
52:20 - secret 1 2 3 4 5 6 7 8 so I gave n is 8
52:25 - we should get 21
52:27 - I believe that's that's what I'm gonna
52:29 - so you say if n is actually less than or
52:32 - equal to 2
52:34 - we're gonna return 1 because the first
52:36 - two sequences are 1 in 1 okay and we're
52:38 - just gonna add them together and keep
52:39 - returning so what is the height of
52:40 - recursion on this well first of all it's
52:41 - just make sure it works because
52:43 - you know we always should test those
52:44 - things okay we get 21 so that's working
52:47 - fine let me now pull up the tablet again
52:49 - and let us try this one more time okay
52:52 - so we need to go to this all right
52:55 - hide a recursion on this now this we
52:57 - have two recursive calls so this is
52:59 - going to be a little bit different eight
53:01 - I'm gonna change this to four to make
53:03 - our life a little bit easier okay so
53:05 - let's start the first recursive call or
53:07 - first call is here okay so we have and
53:11 - go over here we have a are of four okay
53:16 - now what's that equal to well that's
53:18 - equal to the AR of three plus the AR of
53:24 - to scan excuse my handwriting okay so
53:28 - what is this one equal to now well the
53:30 - AR of three so we branch out here I'm
53:32 - going to branch out here because we're
53:33 - gonna have to do this twice right the AR
53:35 - of three is actually equal to the AR of
53:38 - n minus 1 which is 2 plus the AR of and
53:45 - life's 2 which is 1 now we know the
53:48 - values of this that's one and that's one
53:51 - okay now the AR of two is equal to one
53:54 - okay so from our four if you count on
53:58 - the recursive calls with one two three
54:00 - four recursive calls and five calls in
54:02 - total okay
54:04 - now the way that we can calculate the
54:07 - value is just by adding all these up
54:08 - right so they are four should give us a
54:10 - value of three and like I have in the
54:12 - list here so we say 1 1 1 there you go
54:16 - that's our value of 3 now if we change
54:19 - this to 5 we let's see if I can do this
54:23 - to find without erasing everything okay
54:25 - so we'll get rid of that and we'll say
54:28 - the AR of 5 is equal to the air for
54:33 - right so that's a are for the AR f4 is
54:37 - equal to the AOR of 3 and the AR of 2
54:40 - right whereas the AR of 3 is equal to
54:44 - this so we have like a bunch of arrows
54:46 - now going right but then you can
54:48 - calculate it like this so the AR of 4 is
54:50 - equal to the AR of 3 plus the air to so
54:55 - then you go here we get 3
54:56 - but then the AR of five which is plus AR
54:58 - four is equal to this which is three or
55:02 - is equal to two right so I know I just
55:04 - completely mess up that explanation but
55:06 - hopefully you can see how you would go
55:08 - about like branching out and doing all
55:10 - those you can figure out not only the
55:12 - value but how many calls you're gonna
55:14 - have okay so yeah anyways I think I'm
55:19 - going to end the video there I know this
55:22 - went a lot longer than expected but
55:25 - there was some things that I want to
55:26 - make sure we're clear for you guys and
55:27 - that I explained well if you watched
55:29 - this entire video you should be fairly
55:31 - prepared or at least now refreshed on a
55:33 - lot of the material that you learned in
55:34 - class obviously I can't explain it as
55:37 - well as a professor because I don't have
55:39 - an hour and a half lectures every other
55:41 - day to explain one topic instead I did
55:43 - everything in like what is this gonna be
55:44 - like 40 minutes 45 minutes whatever that
55:46 - is so yeah hopefully you guys enjoyed
55:49 - the video and it helped you out it
55:51 - definitely helped me to study for my
55:53 - exam by making this and if you guys
55:55 - enjoyed the video please make sure you
55:56 - leave a like on it as did take quite a
55:58 - while to make and subscribe to the
56:00 - channel for more content like this
56:03 - [Music]
56:13 - you