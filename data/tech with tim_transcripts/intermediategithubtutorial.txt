00:03 - foreign
00:08 - I'll be sharing with you intermediate
00:11 - git and GitHub features and
00:13 - demonstrating how to use this software
00:14 - in a professional environment
00:16 - specifically I'll be discussing the
00:18 - proper way to create a pull request and
00:20 - contribute to a repository how to fix
00:22 - conflicts the difference between a
00:24 - rebase and a merge how to pull and
00:26 - modify existing branches cherry picking
00:29 - different commits and then how to reset
00:31 - history and commit and more advanced git
00:34 - and GitHub features that are not
00:35 - typically shown now this video is
00:37 - designed for people that have some
00:39 - familiarity with Git but if you're a
00:41 - beginner or just need a refresher then
00:43 - feel free to check out the video that
00:44 - I'm going to put on the screen which
00:46 - will give you the fundamentals you need
00:47 - to then go through this video lastly I'm
00:50 - happy to mention that this video is
00:51 - sponsored by Microsoft who helped me
00:53 - develop this video and on May 9th we'll
00:55 - be hosting a 45 minute long webinar as a
00:58 - part of the developer digital Meetup
01:00 - tour this webinar will go much more in
01:02 - depth on this topic and teach you about
01:04 - Advanced developer workflows while also
01:06 - including a live q a session at the end
01:09 - to register for the webinar go to AKA
01:11 - dot Ms slash Tech with Tim or click the
01:14 - link in the description with that said
01:16 - let's dive into the video
01:18 - [Music]
01:22 - alright so let's go ahead and get
01:24 - started so in front of me I have a
01:26 - sample GitHub repository and what I'm
01:28 - going to do in this section of the video
01:30 - is demonstrate to you how to correctly
01:32 - create a pull request and contribute to
01:34 - a repository now this is going to be
01:36 - more applicable if you're working in a
01:37 - team environment with multiple
01:39 - developers or for a company if you're
01:41 - just working on your own kind of solo
01:43 - git repository or GitHub repository this
01:46 - isn't going to be super applicable and
01:47 - you don't need to follow these steps but
01:48 - whenever you're working with more than
01:50 - one developer you're going to want to do
01:51 - what I'm outlining here just to keep
01:53 - everything clean and kind of best
01:55 - practice
01:56 - so first thing to understand here when
01:58 - we're looking at this repository if I
01:59 - can open it back up is that we have a
02:01 - branch called main or in some instances
02:03 - it's going to be called Master now you
02:05 - can see this is the default Branch now
02:07 - your main branch in most instances is
02:10 - going to be the branch that you want to
02:12 - have clean reviewed and finalized
02:15 - functioning code on what that means is
02:17 - that you don't want to be directly
02:19 - contributing work that's not finished to
02:21 - the main or Master Branch you want to be
02:23 - doing essentially all of your Dev work
02:25 - on in a kind of additional Branch so a
02:27 - feature branch and then once you've
02:29 - finished a completed feature or bug fix
02:31 - or whatever it may be then you're going
02:33 - to merge that onto the main or Master
02:35 - Branch so in most repositories your main
02:38 - or Master branch is going to be locked
02:40 - which means unless you're a I guess you
02:43 - would call this an admin of the
02:44 - repository you're not able to actually
02:46 - directly contribute to this Branch
02:48 - instead what you need to do is work on
02:50 - an additional branch that is forked off
02:52 - of the main or Master branch and then
02:54 - merge it onto the master bedroom our
02:56 - main branch once it's been reviewed and
02:58 - your code is completed tested and
03:00 - functioning so just keep that in mind
03:02 - your main branch you want to always be
03:04 - kind of production ready to some extent
03:06 - and always fully functioning so that
03:09 - additional people can always revert back
03:11 - to the main branch and know this is kind
03:13 - of the current uh version of the
03:15 - repository the current up-to-date State
03:17 - whereas all these other branches are
03:19 - Works in progress that are eventually
03:21 - going to be contributed onto the main or
03:23 - Master Branch alright so with all that
03:25 - said let's actually get into an example
03:26 - of making a contribution then to this
03:28 - repository keeping in mind that we want
03:30 - to do our work on an additional branch
03:32 - and that eventually merge it into this
03:34 - main branch okay so I've opened this
03:36 - repository here in Visual Studio code
03:38 - and I want to start creating a feature I
03:41 - want to start adding some code now
03:42 - obviously I'll just do something simple
03:43 - for this video but what is the process
03:45 - to do this well the first thing I always
03:47 - do is I check what branch I'm currently
03:50 - on by typing git branch in this case I'm
03:53 - on the main branch that's what I want to
03:55 - be on and what what I like to do before
03:57 - I start working or creating a new Branch
03:58 - or feature is I like to make sure that
04:00 - my local repository is up to date with
04:03 - the remote repository this is just going
04:04 - to save me a ton of headaches in the
04:06 - future so what I do is I type A git pull
04:09 - when I do that that's going to pull all
04:11 - of the changes from the remote
04:13 - repository to my local repository and
04:16 - keep my local version of the main or
04:18 - massive Branch up to date so what I'm
04:20 - trying to do locally is always keep this
04:22 - main branch up to date with the remote
04:24 - repository you know every day I like to
04:26 - make a poll something along those lines
04:28 - so that whenever I decide to Fork off of
04:30 - Main I'm not forking too far kind of in
04:33 - the past and I have a very up-to-date
04:35 - version of the code base there's
04:36 - different ways to do this but this is
04:38 - what I'd like to do now you may have to
04:40 - actually fully type out git pull origin
04:42 - and then whatever the branch name is in
04:44 - this case it's going to be main it's
04:45 - going to do the same thing here in my
04:47 - case the get pull command is just
04:48 - automatically set up to pull from this
04:50 - main branch when I'm on that Branch okay
04:53 - so now I'm fully up to date with the
04:55 - remote Repository uh and what I'm going
04:57 - to do is create a new Branch so I'm
04:58 - going to type git checkout hyphen B
05:01 - standing for a new branch and I'm going
05:02 - to give this a name now when you name a
05:04 - branch it's typically a good idea to
05:06 - give it some kind of unique prefix that
05:08 - is specific to you so you don't
05:10 - accidentally name Branch the same thing
05:13 - that someone else has named that's
05:14 - eventually going to push it to the
05:16 - repository so what I'll do typically is
05:18 - something like get checkout hyphen B and
05:21 - then Tim
05:22 - and in this case I'll say feature now
05:24 - obviously whatever the feature name is
05:26 - like if this was a leaderboard or a
05:28 - scoring system or whatever I would name
05:29 - it that in this case we'll just do
05:30 - something generic which is feature now
05:32 - again the reason I use Tim is because if
05:34 - someone else is working on a branch
05:35 - called feature we could have kind of
05:37 - conflicts and be pushing to the same
05:39 - remote repository branch which could
05:42 - kind of cause some headaches so it's a
05:44 - good idea just to prefix your branches
05:45 - with your name or some unique ID that no
05:48 - one else is going to be using alright so
05:49 - I'm on my new branch and now that I'm on
05:51 - my new Branch I can go crazy I can
05:53 - create my new features so let's say my
05:54 - new feature is just a text file okay so
05:57 - we'll just say feature Dot txt and I'll
05:59 - say this is a great feature okay perfect
06:03 - I'm going to save that now obviously we
06:05 - can go through our standard gate
06:06 - commands we can also just use the
06:07 - interface here in vs code and I can add
06:10 - these changes to the staging area so git
06:12 - add dot then I can make my commit I'm
06:14 - going to do the commit message using
06:16 - hyphen M and I want to name this
06:17 - something meaningful it's going to be
06:19 - easy to review later on so I would say
06:21 - added a feature
06:25 - dot txt file and actually it's standard
06:29 - practice to write this in present tense
06:31 - not in past tense now it doesn't really
06:33 - matter I don't see many people actually
06:35 - follow this practice but you are
06:36 - supposed to write this in present tense
06:38 - uh not past tense so add a feature.txt
06:41 - file as if you're doing it kind of right
06:43 - now okay so I've done that I've now
06:45 - created my commit and now I'm at the
06:47 - point where I actually want to push this
06:48 - to GitHub I want to get my code reviewed
06:50 - and then I want to contribute this to
06:52 - the main branch so other developers can
06:54 - start using this so if I want to do this
06:56 - now what I need to do is I need to push
06:58 - this Branch so I'm going to type git
06:59 - push
07:00 - Tim Dash feature when I do that sorry I
07:04 - need to First specify the location I'm
07:06 - going to push to so get push origin Tim
07:08 - feature because origin is the remote
07:10 - repository I want to go to so we're
07:12 - going to push to this remote repository
07:13 - and now you can see it's created a new
07:15 - branch on the remote repository called
07:17 - Tim feature so by me simply doing this
07:20 - push because I had access rights to this
07:22 - GitHub repository I've now created this
07:24 - new branch and if I click on this button
07:26 - and I view all branches you can see that
07:28 - there's a Tim feature Branch right here
07:30 - and I have the option to manually click
07:32 - create new pull request I can also view
07:34 - this Branch by clicking on it and then
07:36 - view that this new file is here I also
07:38 - have the ability to just press this
07:40 - button which is automatically being
07:41 - generated by GitHub although sometimes
07:43 - it doesn't actually give that to you
07:45 - based on kind of when you contribute if
07:47 - you change something
07:48 - all kinds of reasons why you may not see
07:50 - this button so I wanted to show you
07:52 - manually you can go here and then click
07:53 - that okay so I'm going to go compare and
07:55 - pull request now we get to the pull
07:57 - request kind of template page now
07:59 - typically when you get to this page
08:00 - there's going to be some kind of
08:01 - template that you'll need to fill out
08:02 - depending on the organization that
08:04 - you're working for and it may tell you
08:05 - to upload some photos or to tick some
08:07 - boxes or to describe the feature
08:09 - whatever you got the idea you want to
08:10 - give a descriptive pull request name and
08:13 - the point is that through this pull
08:14 - request you may actually go back
08:16 - um kind of in the future and say okay
08:18 - what did I change here what were the
08:19 - changes and you just want to have a
08:21 - decent name so it's easy to find what
08:23 - this pull request is so in my case we've
08:25 - done a very simple thing which is just
08:26 - add a file that's about as much
08:28 - subscription as I need to add than if I
08:30 - wanted to I could add additional
08:31 - comments again in this case I don't need
08:33 - to do that but it is good practice to
08:35 - add as much detail as you possibly can
08:37 - so I'm going to click on create pull
08:38 - request and now what I've done is I've
08:40 - created my pull request now this pull
08:42 - request will typically need to be
08:44 - approved depending on the settings of
08:46 - the GitHub repository before it's able
08:48 - to be emerged into the main branch so in
08:52 - my case I can just directly merge it in
08:53 - here because I'm an admin of the GitHub
08:55 - repository however if someone who was
08:57 - not was working on this repository then
08:59 - someone like myself would have to review
09:01 - their pull request and then approve it
09:03 - before they'd be able to actually merge
09:05 - it in
09:06 - so if I go here to reviewers if there
09:08 - was other people on this repository I'd
09:10 - be able to select them and say request
09:12 - review so that's typically what you're
09:14 - going to do and then you're gonna have
09:15 - to wait for them to come here and review
09:17 - the pull request now in my case I can
09:19 - show you an example of doing that
09:20 - because you may also do that for other
09:22 - people's pull requests so here it says
09:24 - review changes I can obviously go and
09:25 - look through all the changes and tick
09:27 - the files that I've seen and if you had
09:28 - more files and directories it would show
09:30 - you that setup on the left hand side
09:31 - anyways it's quite simple here so I'll
09:33 - click on review changes maybe I leave a
09:35 - comment here and I ask them why they did
09:37 - something a certain way I also can
09:39 - select a line here click on this plus
09:41 - button and then directly add a comment
09:43 - on this line so I can add a single
09:46 - comment right here and now if you go to
09:48 - the conversation tab you'll see that
09:50 - there's a comment kind of discussing a
09:52 - specific line and then you could reply
09:54 - to that comment and kind of keep all
09:55 - your conversation on one pull request so
09:57 - that you have history of it and you can
09:59 - look at it later you can also resolve
10:00 - the conversation which means you've kind
10:02 - of fixed whatever they commented on now
10:04 - you'll see when I go here that it's tell
10:06 - telling me that I can't approve or
10:07 - request changes because I'm the author
10:09 - again that kind of makes sense but what
10:11 - I would do if this was someone else's
10:12 - pull request I would review it I would
10:13 - leave some comments and then I would
10:15 - approve it and then they would be able
10:16 - to merge so I just want you to
10:18 - understand that this is the process
10:19 - right you create this pull request and
10:21 - now I can merge this pull request into
10:23 - the repository I'm going to delete this
10:25 - branch which is typically good practice
10:27 - you want to keep your branches clean
10:28 - that you're not using I'm going to go
10:30 - back to code and now notice that I've
10:32 - created a merge commit here that has
10:34 - merged all of this content into the main
10:37 - branch so now I have my one branch I
10:39 - have feature.txt on here and everything
10:42 - is up to date and we can go and look at
10:44 - the three commits we have our initial
10:45 - commit this and then we have the merge
10:48 - commit which is actually merging all of
10:50 - my code from my Branch into this main
10:52 - repository okay we're almost done here
10:54 - now we go back here okay
10:56 - we're working on some other feature or
10:58 - maybe it's the next day we want to do
10:59 - some new code so now what I want to do
11:01 - is I want to get check out the main
11:05 - branch remember you always want to keep
11:07 - your main branch your local copy of the
11:09 - main branch up to date with the remote
11:11 - repository so I'm going to go to my main
11:12 - branch and then I'm going to type git
11:14 - pull and I'm going to pull down the
11:16 - remote changes now even though I've
11:18 - already made these changes locally I've
11:20 - only made them on my other Branch so on
11:23 - my Tim feature Branch not on the main
11:25 - branch so I go to main I pull that gives
11:28 - me the changes from the remote
11:29 - repository including that merge commit
11:31 - and now I can create new branches and
11:34 - work off this main branch to avoid any
11:36 - conflicts now you'll see that if I go
11:39 - get checkout so let's go here
11:42 - get check out Tim Dash feature and I try
11:46 - to push this up so get push origin and
11:50 - then Tim
11:51 - feature like this
11:54 - it's gonna create this new Branch okay
11:56 - so it creates a new Branch now I'm gonna
11:58 - go back to the GitHub repository and we
12:01 - are going to go here we're gonna go to
12:03 - Tim feature and it says this one commit
12:05 - behind main now the reason it's saying
12:07 - it's one commit behind main even though
12:09 - it has the same content is because the
12:11 - main branch has a merge uh merge commit
12:14 - sorry that merge these two things in
12:15 - whereas my current local copy doesn't
12:17 - have that merge commit so I don't want
12:20 - to keep working on this Branch because I
12:22 - could potentially be getting conflicts
12:23 - instead what I want to be doing is
12:25 - creating a new branch and then working
12:27 - off that hopefully that makes a little
12:29 - bit of sense of what I'm describing here
12:31 - I'm just going to go back to the main
12:32 - branch though so get checkout Main
12:34 - okay and now I would create a new Branch
12:37 - so git checkout hyphen B and then Tim
12:40 - feature two and this is where I would do
12:43 - any additional changes this branch is up
12:45 - to date with the main branch meaning
12:47 - that whenever I make a push I'm not
12:49 - going to have any conflicts at least I
12:51 - shouldn't have any conflicts based on
12:52 - how we're doing this right now and it
12:53 - should just be kind of smooth sailing to
12:55 - add new code to the code base
12:59 - [Music]
13:02 - alright so continuing here the next
13:04 - thing I'm going to go through is
13:05 - resolving conflicts and I'm going to
13:07 - kind of explain to you why a conflict
13:08 - occurs because this is a point where
13:10 - people get very frustrated and
13:12 - oftentimes kind of don't know how to
13:14 - deal with this in some kind of
13:15 - production environment or you know kind
13:17 - of workplace team environment so what
13:19 - I'm going to do here is essentially
13:20 - create a conflict now before I do that
13:23 - I'm just going to look at the current
13:25 - status of my repository so it says I'm
13:28 - on Tim feature two so what I'm going to
13:30 - do is check out the main branch again
13:32 - I'm going to pull to update everything's
13:34 - up to date okay and now I'm going to
13:37 - delete these two branches that I don't
13:39 - need just so that I don't get confused
13:41 - and accidentally use them throughout
13:42 - this section
13:43 - so I'm going to type git Branch hyphen
13:46 - capital D and then I'm going to go Tim
13:48 - feature that's going to delete that
13:49 - branch
13:50 - and I'll do the same thing with Tim
13:52 - feature two alright so now let's create
13:54 - a conflict so let's clear let's go get
13:57 - check out hyphen B Tim Dash and we'll
14:01 - just go C1 for conflict one and all I'm
14:04 - gonna do here is go to this file and I'm
14:06 - just going to delete this line okay so
14:08 - I've deleted that line here now I'm
14:09 - gonna go get add dot git commit hyphen m
14:12 - delete
14:14 - line
14:15 - in and then feature dot txt okay and
14:19 - then I'm going to push this up to GitHub
14:21 - now you'll see in a second kind of how I
14:23 - create the conflict for now though all
14:25 - I'm doing is just making a change the
14:26 - repository which is not going to cause a
14:28 - conflict okay so I've gone here uh and
14:31 - you can see
14:32 - then now I have Tim C1 and I can create
14:33 - a pull request so I'm going to do that
14:35 - create pull requests and I'm going to
14:37 - create that now for now I'll just leave
14:38 - this on the repository and we can merge
14:40 - it in later all right now what I'm going
14:42 - to do is go get checkout and then main
14:45 - now notice here that we still have the
14:47 - text inside of the file okay so now I'm
14:48 - going to create a new Branch now imagine
14:50 - that I was doing this as a different
14:52 - user so you know Tim me just created a
14:55 - branch that I uploaded for a pull
14:57 - request that Branch deleted a line now
14:59 - imagine some other developer is checking
15:01 - out a branch from their local main copy
15:03 - they don't have that deleted line
15:05 - because that was worked on on a separate
15:07 - branch and now what they're going to do
15:09 - is maybe modify this liner they're going
15:10 - to modify this file in some way this is
15:12 - kind of how a conflict will occur so I
15:14 - go get check out hyphen B I'm going to
15:16 - go Tim C2 for conflict two okay and here
15:19 - all I'm going to do is say this is a
15:20 - great feature Tim is the best uh just
15:23 - two true statements on one line okay so
15:26 - now that I've done this I'm going to do
15:27 - the same thing I'm going to push this up
15:28 - for a pull request I'm gonna go get push
15:31 - origin and then Tim C2 so essentially
15:34 - what I've done here is I've created two
15:36 - separate branches each branch has made a
15:39 - change on the same file and in this case
15:41 - on the same line so what that means is
15:44 - that there's conflicting changes on both
15:46 - of these branches so I'm going to go
15:47 - back here to pull requests let's go to
15:50 - code
15:51 - let's go to our branches Tim C2
15:54 - and let's create a pull request uh okay
15:58 - for some reason uh apologies for the cut
16:01 - here I realized I forgot to make my
16:02 - commit so I'm gonna go get add dot get
16:05 - commit hyphen m
16:07 - I'm just gonna go with a simple one like
16:09 - make changes and now I'm gonna push this
16:11 - again back up to the repository so that
16:15 - now I will see it here okay so Sim Tim
16:17 - C2 has changes so let's go here and make
16:20 - changes Okay so we've created two pull
16:22 - requests and you'll notice that on both
16:24 - of these pull requests right now
16:25 - everything's completely fine I can merge
16:27 - them in because all I've done is made a
16:29 - change to one of the lines in this case
16:31 - I've deleted the line okay and then on
16:32 - my other pull request here I have simply
16:35 - added to the line so what I'm going to
16:37 - do is just pick any of the pull requests
16:38 - it doesn't matter which one I pick here
16:39 - and I'm going to make a change
16:41 - okay so I'm going to confirm this uh now
16:43 - this is the file that is adding to the
16:46 - line okay so let's confirm this merge
16:48 - all right and check that okay now this
16:51 - is in I'm going to delete this branch
16:52 - and what you're going to see is when I
16:53 - go back here now all of a sudden it's
16:56 - going to show me that I have a conflict
16:57 - now the reason it's telling me I have a
16:59 - conflict is that the change that I've
17:01 - made here is trying to change the same
17:04 - line that was just changed in the
17:06 - previous pull request but on a different
17:08 - version of the file now I know this
17:11 - seems kind of strange but essentially
17:13 - both of these branches were kind of
17:15 - merged or sorry forked off of the main
17:18 - branch at the same time so two minutes
17:20 - ago I created these two new branches
17:22 - they both modified the same version of a
17:25 - file and now I've checked it's called
17:28 - checking in but I've merged one of these
17:31 - file changes into the main repository
17:33 - but this Branch was making a change to a
17:36 - previous version of that file so it was
17:38 - making a change to a version different
17:40 - than what is now inside side of the
17:42 - repository hopefully that makes a little
17:44 - bit of sense but the actual definition
17:46 - here of one emerge conflict occurs is
17:48 - when people make different changes to
17:50 - the same line or the same file or when
17:52 - one person edits a file and another
17:53 - person deletes the same file so that's
17:55 - exactly what's happening here we're
17:57 - editing the same line in the same file
17:59 - and git doesn't know what version of the
18:01 - file to take
18:03 - so we have to resolve these conflicts
18:04 - now we can do this in Visual Studio code
18:07 - or we can do this here on GitHub alright
18:10 - so now that I'm inside of this file I'll
18:11 - quickly explain what this syntax means
18:13 - so in between these two symbols here
18:15 - where it says Main and it shows all of
18:17 - the equal signs this is what's currently
18:19 - on the GitHub repository okay this is
18:21 - what's currently here and then this um
18:23 - kind of weird because I've deleted a
18:25 - line but this is what's on this Branch
18:27 - so essentially what it needs me to do
18:29 - here is delete all of these symbols that
18:31 - have been added in now I can put
18:33 - anything I want in this file but it
18:35 - needs these symbols to be removed before
18:36 - it's going to tell me that I've marked
18:38 - or before it's going to allow me sorry
18:39 - to mark this file as resolved so that's
18:42 - one way you can do this directly from
18:43 - the editor on GitHub or you can do this
18:46 - from vs code so I'll show you from vs
18:47 - code as well if I go back to visual
18:50 - studio code here now what I can do is I
18:52 - can try to update my C2 Branch with the
18:55 - main branch so the way I'll typically do
18:57 - this is I'll go get checkout main I'll
19:00 - pull main which is going to give me the
19:02 - fixes so or the updates now it's going
19:04 - to modify this file and now I'm going to
19:06 - go get chick checkout and then in this
19:08 - case it's C1 and now what I'll do is I
19:11 - will merge the main branch with this
19:13 - branch and when I do that you're going
19:15 - to see that I get a merge conflict
19:16 - Happening Here locally I can then fix
19:18 - that and then re-push to GitHub and then
19:21 - everything will be okay so what I'm
19:23 - going to do is go get
19:24 - and then this is going to be merge and
19:26 - I'm going to merge main now I could
19:28 - merge origin slash main or I can just
19:32 - merge mate now if I do main that's my
19:34 - local copy which in this case is fine
19:35 - because I know that's up to date with my
19:37 - origin or my remote repository
19:40 - alternatively if I knew it wasn't up to
19:42 - date then I would just do origin slash
19:43 - main in this case they're both going to
19:45 - give me the same result origin slash
19:47 - main by the way of course is the remote
19:48 - repository and then the version of the
19:50 - main branch on there okay so I'm going
19:53 - to hit enter here and notice it says
19:55 - automatic merge failed fix the conflicts
19:56 - and then commit the result now here we
19:58 - get some better kind of choices so we
20:00 - can accept the current change or the
20:02 - incoming change or both changes or
20:04 - alternatively we can just manually
20:06 - update this file now for clarity here
20:08 - the incoming change is what's coming
20:10 - from the remote repository or from the
20:13 - other branch and then the current change
20:14 - is what you currently have on your
20:16 - current Branch so what I can do is
20:18 - accept the current change if I actually
20:20 - want to delete this line then I'm going
20:23 - to save and then what I need to do is I
20:25 - need to commit the results so I'm going
20:26 - to fix the conflicts and commit the
20:28 - result my file is already added into the
20:30 - staging area so just type git commit
20:32 - hyphen M and I say fix
20:35 - dot txt file
20:38 - conflicts okay this is kind of my merge
20:40 - commit now
20:41 - I'm gonna do that uh and sorry actually
20:43 - I forgot I have to add this to the
20:44 - staging area I thought it was already
20:45 - there and then I commit okay so now that
20:48 - I've made my commit here what I can do
20:50 - is re-push this so I'm going to type get
20:52 - push origin Tim C1 and now that I
20:56 - re-push this to the remote repository
20:58 - with the conflicts fixed so we're gonna
21:01 - go here all right uh I should be able to
21:04 - just merge this directly in and you'll
21:06 - notice that now I have two commits so I
21:07 - deleted the line and then I have what's
21:09 - referred to as a merge commit which is
21:10 - what I made to merge the changes from
21:13 - the main branch onto my feature Branch
21:15 - so now when I merge my feature Branch
21:18 - back onto the main branch the history is
21:20 - correct and everything is up to date I
21:22 - know this can be a little bit confusing
21:24 - but what I just did to fix the conflict
21:26 - was I essentially merge my Branch with
21:28 - the main branch so that I integrated all
21:31 - of the changes from the main branch onto
21:33 - mine I then from that point forward
21:35 - created the change I wanted to put on
21:38 - the main branch which is what we've done
21:40 - by deleting the line and now I am able
21:42 - to merge this pull request in
21:45 - okay I again I apologize this stuff is
21:48 - not simple hence why this video is
21:49 - intermediate kind of GitHub topics but
21:51 - that is how you go about fixing a merge
21:53 - conflict now obviously the conflicts you
21:56 - can you get can be much nastier than
21:58 - what I just showed you here uh there is
22:00 - some more advanced tools that you can
22:01 - use to fix these however typically what
22:04 - you want to do to avoid getting too many
22:06 - conflicts is always be branching off of
22:09 - a clean version of the main repository
22:11 - if you're doing that or sorry off the
22:13 - main branch if you're doing that you're
22:15 - going to limit the amount of conflicts
22:16 - that you have and you know once in a
22:18 - while yes you will get them but what you
22:20 - need to do then is merge with the main
22:22 - branch and then you'll have to manually
22:24 - go through and fix all of those
22:25 - conflicts once you fix them then you can
22:27 - re-push and then you'll be able to merge
22:30 - back into the Repository
22:33 - [Music]
22:36 - all right so I've just moved to the
22:38 - drawing tablet here because I'm going to
22:39 - quickly explain to you the difference
22:41 - between a merge and a rebase which are
22:43 - two popular commands to integrate
22:45 - changes from different branches that
22:47 - many developers don't actually
22:48 - understand so it's helpful to view these
22:51 - visually they're actually not overly
22:52 - complicated but you just want to
22:54 - understand kind of the core difference
22:55 - between what emerge is doing uh compared
22:57 - to a rebase so let's just draw a simple
23:00 - example here of a git history so all of
23:04 - these circles are going to be commits
23:05 - and this white Branch here is going to
23:07 - be our main or our Master Branch now
23:10 - let's say at some point in time we
23:11 - decided we're going to start creating a
23:12 - feature and maybe we did that here okay
23:14 - so at this point we decided to Fork off
23:16 - and we created a new branch
23:19 - in this Branch maybe we called something
23:21 - like C1 now obviously that's a horrible
23:23 - name but we decided to call it C1 there
23:24 - we go we have our C1 feature wrench now
23:27 - let's say that we are here and we
23:30 - decided this point in time okay you know
23:31 - we finished our feature now we want to
23:33 - actually kind of combine this or merge
23:35 - this into the code base there's a few
23:38 - different ways to go about doing this we
23:40 - also may just want to update our current
23:42 - Branch to integrate all of the changes
23:44 - from Main so let's put put it in that
23:46 - scenario we want to update our current
23:48 - Branch with all the changes from Main so
23:50 - that way when we continue working we
23:51 - have an up-to-date code base
23:53 - everything's kind of you know updated
23:54 - nice and clean and ideally we're gonna
23:56 - kind of remove the riskiness or remove
23:59 - sorry the likelihood of having a
24:01 - conflict okay so we want to take changes
24:04 - from here that have happened since we've
24:05 - been working on this branch and
24:07 - integrate them here obviously what's
24:09 - happened is since we've branched off new
24:10 - code has been added to the main branch
24:12 - we want that code now in this Branch how
24:15 - do we get that well the First Command we
24:17 - can run is our merge now when we decide
24:20 - to run a merge what's going to happen is
24:22 - a new commit is going to be created this
24:25 - is called our merge commit and I'm going
24:27 - to put an asterisks here which means
24:29 - it's new now what this merge commit is
24:31 - going to do is it is going to
24:33 - essentially combine all of the changes
24:35 - since we branched off with the changes
24:38 - from this Branch so it's a brand new
24:40 - commit and it just combines well all of
24:43 - these different changes now a conflict
24:45 - could occur here if that's a case we
24:46 - need to fix that and then the kind of
24:48 - conflict fix will be involved in this
24:50 - merge commit alright so we create this
24:52 - merge commit it essentially combines
24:53 - everything together and now say I'm on
24:56 - my Branch C1 if I were to continue to
24:58 - work I would kind of add off of this
25:01 - merge commit and there we go now I have
25:04 - all the changes from my main branch and
25:06 - I'm continuing to work now the advantage
25:08 - here of creating this merge commit is
25:10 - that I keep the entire history of my git
25:13 - repo what I mean by that is I know still
25:17 - all of these different commits I know
25:19 - when I originally branched off and I
25:21 - know at what point in time I decided to
25:23 - do this merch now the disadvantage is
25:26 - that this merge commit is very messy
25:28 - oftentimes it kind of messes up the
25:30 - history you can see here now we have a
25:32 - non-linear history because we have
25:33 - different branches kind of being
25:35 - integrated together and it can make the
25:38 - history of the GitHub repository well
25:39 - just very messy right it's difficult for
25:42 - me if I'm reviewing this later on to
25:44 - understand if I should be looking down
25:45 - here if I should be looking up here if
25:47 - I'm looking after the merge commit it
25:48 - just kind of complicates things a little
25:50 - bit when you're going back and review it
25:52 - okay so that's a disadvantage but again
25:54 - the advantage is you're retaining all of
25:57 - this history and you know everything
25:58 - that's occurred you're not losing any
26:00 - information you've just added this
26:02 - additional merge commit which can make
26:03 - things a little bit messy now one thing
26:05 - to note here is that since I've
26:07 - integrated main with my C1 branch that
26:10 - doesn't mean that on my main branch I
26:13 - now have my C1 one changes only if I've
26:16 - actually made a pull request and kind of
26:18 - merged this into the main branch am I
26:20 - going to have that if I were to locally
26:22 - check out the main branch now as I
26:25 - continue to work I'm going to continue
26:26 - to Branch off of my main branch and then
26:29 - later maybe I integrate the changes of
26:31 - C1 but what I've done is I've taken the
26:33 - changes from Main and put those on my C1
26:35 - Branch not the other way around it's not
26:38 - going to happen on both branches it just
26:39 - happens on the branch you're currently
26:41 - on when you run the git rebase commit
26:44 - okay now let's talk about merge so I
26:47 - think actually will be easier if I just
26:48 - delete all of this so let's erase all
26:50 - the ink okay so now what happens when we
26:52 - do a rebase well what a rebase is doing
26:56 - is taking essentially this entire Branch
26:59 - here so all of the code that we've done
27:01 - and it's just moving it to be at the tip
27:04 - of our main branch so let's say I'm on
27:07 - to C1 right I want to integrate my main
27:08 - changes then all I do is I rebase it and
27:12 - when I rebase it it moves my brand inch
27:15 - over here now obviously it's a little
27:16 - bit more complicated than that but
27:17 - that's essentially what's happening
27:19 - rather than creating a new commit here
27:21 - which is a merge of these two branches
27:24 - together I am simply taking all of this
27:27 - code or all of these commits sorry from
27:29 - this branch and I'm moving them so that
27:32 - now they're going to be attached at the
27:35 - head of my main branch or whatever
27:36 - Branch I am merging or sorry rebasing
27:39 - with my
27:41 - what do you call it feature Branch now
27:44 - what actually happens here is this right
27:47 - so this new branch is going to contain
27:49 - entirely new
27:51 - commits all the asterisks are just new
27:53 - commits what happens is my original
27:55 - branch which I can kind of do like this
27:58 - so my original commits are going to be
28:01 - copied and added to the head so I'm not
28:04 - taking the same commit I'm actually kind
28:06 - of copying them and turning them into a
28:08 - brand new commit and then attaching them
28:10 - to the head of whatever Branch I'm
28:13 - rebasing with now the reason why this is
28:15 - nice is that we no longer have a merge
28:18 - commit and our history is fully linear
28:21 - so now it's very easy for me if I'm
28:23 - reviewing this later on to understand
28:24 - that okay I just go from here here down
28:27 - to here I don't have this kind of fork
28:29 - in the road where I have this merge
28:30 - commit that's combining the two
28:32 - different branches I have a full linear
28:34 - history the disadvantage of doing this
28:37 - is that I lost all of the history that I
28:39 - previously had when I decided to Branch
28:42 - off so again we originally had branched
28:45 - here and if we had done a merge we would
28:47 - have known that we branched here we
28:49 - would have known all the commits that
28:50 - were on this Branch versus here now when
28:53 - I do the rebase it becomes unclear I
28:55 - lose that history and instead I kind of
28:58 - trade that for this straight linear
29:00 - history so you might be asking yourself
29:03 - now okay I understand you know rebase is
29:05 - essentially attaching to the head and
29:07 - what actually occurs here is we apply
29:09 - every single one of the commits that are
29:11 - on our Branch to this Branch right so
29:14 - we're really just tacking them on that's
29:15 - all that's happening and these become
29:17 - new commits but you might be asking
29:19 - yourself well when do I use which right
29:21 - when do I use rebase first when do I use
29:23 - merch well the Golden Rule here is that
29:26 - you never want to use a rebase on a
29:29 - public Branch now what I mean by a
29:30 - public branch is a branch that someone
29:32 - else could potentially be working on the
29:35 - reason you don't want to do that is
29:36 - because if someone else has a copy of
29:38 - the branch that looks like this and then
29:41 - you rebase and you push that Branch when
29:44 - they pull this they're going to get all
29:46 - kinds of conflicts and they're going to
29:48 - have a completely different version of
29:49 - the branch locally than what you've
29:51 - pushed so you've now moved every single
29:54 - one of your commits over to the head of
29:56 - the main branch where theirs are still
29:58 - forked off and have not been rebased and
30:01 - when they decide to do a pull uh there's
30:03 - just kind of you know like a mini
30:04 - disaster that's going to occur so
30:05 - essentially it's referred to as the
30:07 - golden rule of rebase is you never use
30:09 - this on a public branch which is a
30:11 - branch that anyone else could be um kind
30:14 - of using now this is a little confusing
30:16 - because if I have a local branch it's
30:19 - fine for me if I'm working on kind of a
30:21 - local feature Branch to rebase that
30:23 - Branch against my main Bridge it's fine
30:25 - for me to put my C1 Branch like it is
30:27 - right now because I'm the only one
30:29 - working on this C1 Branch I can fix all
30:32 - of the conflicts and then I'm going to
30:33 - push that up to get I'm going to have my
30:35 - nice clean history I can then merge that
30:37 - in
30:38 - to my main branch and then anyone else
30:41 - can simply pull the main branch which
30:43 - will have its nice clean linear history
30:45 - and then allow uh allow them sorry to
30:48 - just continue working so the simple
30:50 - summary here on when to use rebase is
30:51 - when you're working on a private Branch
30:53 - so that means pretty much only you are
30:55 - working on the branch and you're trying
30:56 - to update essentially the state of your
30:58 - branch to match the state of a remote
31:00 - Branch or some other Branch you can use
31:02 - rebase however if you're working on any
31:04 - kind of public Branch then instead
31:06 - you're going to want to use merge that
31:08 - you don't lose any history and you're
31:10 - not going to mess anyone else up that is
31:12 - using that same Branch so just remember
31:14 - those two rules if it is a public Branch
31:16 - then you use merge if it is your own
31:19 - private Branch then you are fine to use
31:21 - the rebase command
31:24 - foreign
31:27 - switched back to the computer and for
31:29 - this next section in the video what I'm
31:31 - going to show you is how to check out
31:32 - and modify an existing Branch from
31:34 - GitHub that is not the main branch so
31:37 - you can see here that I've created a new
31:38 - branch called Tech with Tim patch one
31:40 - I've made a pull request using this
31:42 - branch and let's say that now I'm a new
31:45 - developer I'm looking at this code and I
31:47 - want to modify this Branch so maybe I
31:50 - want to push directly to this pull
31:51 - request or I just want to get access to
31:53 - the branch whatever I want it from this
31:55 - remote repository how do I get this well
31:57 - let's go to my local GitHub repo here
32:00 - and first I'm going to type git Branch
32:01 - notice I don't have this Branch even if
32:05 - I type git pull
32:06 - and this will actually give me all of
32:08 - the branches by the way from the remote
32:10 - repository if I didn't already have them
32:12 - even when I type this and I type git
32:14 - Branch again it's not going to show me
32:16 - this Branch now there is a way to view
32:18 - these kind of remote branches however if
32:20 - you know the name of the branch and you
32:22 - just want to it's directly go to the
32:24 - state of that Branch then what you can
32:26 - do is to follow it you can type git
32:28 - checkout and then you can just put the
32:31 - name of the branch in this case it's
32:32 - going to be Tech with Tim patch one now
32:34 - notice that I haven't put hyphen B I
32:36 - didn't put origin I didn't put anything
32:38 - special I'm not creating a new Branch
32:40 - I'm checking out a branch that exists on
32:43 - the remote repository so since I know
32:45 - the name I'm just going to put it here
32:46 - and when I hit enter it's going to say
32:48 - switch to a new Branch so it
32:49 - automatically creates one for me and
32:51 - this branch is tracking the remote repo
32:54 - now what that means is that I'm gonna
32:56 - have the same state as the remote
32:59 - repository Branch at the time that I ran
33:02 - this code and now any changes that I
33:05 - make are happening locally and I can and
33:07 - then push them to the remote repository
33:09 - so let's say I go here and create a new
33:11 - file
33:12 - okay new file.txt
33:15 - a new text all right perfect I can now
33:19 - type git add Dot
33:21 - get command hyphen m
33:24 - create file and then I can push this now
33:27 - to the remote repository so I'm going to
33:29 - type git push origin Tech with Tim Dash
33:35 - patch dash one
33:37 - okay I do that I'm now able to push my
33:41 - code I go here and refresh and notice
33:43 - that I've added this new commit to this
33:45 - Branch okay so that's something you can
33:47 - do fully valid I just want to show you
33:49 - that's how you do it you check out the
33:50 - branch name it's then going to
33:52 - essentially track that Branch from the
33:54 - remote repository if the branch exists
33:56 - on the remote repository and then you
33:59 - have that state and then you can do
34:00 - whatever you want now similarly someone
34:02 - else may change something on this Branch
34:04 - right so you go to Tech with Tim patch
34:05 - one maybe they go to feature uh go here
34:08 - and they edit this and they say
34:10 - another line okay so let's do this
34:12 - commit changes I'm just going to commit
34:15 - uh directly commit that to the branch
34:16 - okay now I'm here and you'll see that I
34:20 - don't have these changes so if I want to
34:21 - get those changes then I can type get
34:23 - pull now what might happen is I could
34:26 - maybe potentially have a conflict here
34:28 - right so like I edit this line and then
34:30 - I type get add dot get commit hyphen M
34:34 - okay I don't know fix whatever I'm just
34:36 - doing random commit messages and then I
34:38 - try to push this again get push origin I
34:41 - should already have this command okay so
34:43 - you can see here when I ran this command
34:45 - that now I'm getting an error message
34:46 - and it's saying the updates were
34:47 - rejected because the remote uh contains
34:50 - work that you do not have locally this
34:52 - is usually caused by another repository
34:53 - pushing to the same ref you may want to
34:55 - First integrate the remote changes with
34:56 - the git pull before pushing again so I'm
35:00 - just going to clear here and what I can
35:01 - do is type git pull and this will be
35:04 - connected to that Branch when I type git
35:06 - pull it will automatically pull those
35:07 - changes and then what I'll need to do is
35:09 - fix the conflict because I have edited
35:11 - the same line so I'm just going to
35:13 - accept the current change here and then
35:15 - I would go get add Dot
35:17 - get commit hyphen M fix
35:23 - conflict okay and now I can go get push
35:26 - origin Tech with Tim Dash hatch dash one
35:30 - and now I'm able to push the changes
35:32 - because I have integrated them with the
35:35 - remote Repository
35:38 - foreign
35:41 - so continuing here I'm now going to show
35:44 - you how you can use the cherry pick
35:46 - command and how you can reset your git
35:48 - branches and state now these are more
35:51 - advanced commands you want to actually
35:52 - know what you're doing when you're using
35:54 - them uh they're not overly complicated
35:55 - but they can mess things up quite badly
35:57 - if you don't know what you're doing so
35:58 - just kind of be careful with these
35:59 - commands if you are using them in your
36:01 - own GitHub repository anyways First
36:04 - Command I want to show you is the cherry
36:05 - pick command which is extremely useful
36:07 - when you have a few commands where just
36:09 - one commit that you want to apply onto a
36:11 - different branch
36:12 - so let's say I'm doing a ton of work on
36:14 - a feature Branch all of a sudden I come
36:16 - up with a pretty critical bug fix and I
36:18 - fix that in one commit now my feature
36:21 - isn't finished but my feature Branch
36:22 - contains the bug fix so rather than me
36:26 - trying to finish the feature bench
36:27 - really quickly or trying to kind of uh
36:29 - submit a half finished feature what I
36:32 - would do instead is I would simply
36:33 - cherry pick this commit off onto a new
36:35 - branch and then I would push that new
36:37 - Branch to GitHub and merge that with my
36:40 - main branch so that I got the bug fix in
36:42 - immediately but I could still continue
36:44 - to work on my feature Branch without
36:46 - pushing that kind of prematurely so this
36:49 - just allows you to take any work you do
36:50 - in a commit and apply it anywhere else
36:52 - use it however you see fit but it's a
36:54 - useful command so I want to show you how
36:55 - it works now when I uh kind of
36:57 - frequently use this command is when I
36:59 - accidentally make a commit on the wrong
37:01 - branch and then I want to move it to
37:03 - another one so let's say that I create
37:05 - this new feature Branch okay
37:07 - and I'm going to do all kinds of work on
37:09 - this feature Branch blah blah but in the
37:11 - meantime I check out the main branch and
37:13 - I pull it just to make sure I'm up to
37:14 - date okay great I'm up to date next day
37:16 - comes along all of a sudden I come to my
37:18 - git repository and I'm like all right
37:19 - I'm gonna start doing my work and I
37:21 - forget that I'm on this main branch
37:25 - so I do my work I add my critical file
37:27 - here and I add my commit so I go get dot
37:30 - get commit hyphen m
37:32 - add python file and all of a sudden I
37:35 - see Main and I go oh no I've made a
37:37 - mistake what do I do now well not to
37:40 - worry we can use the cherry pick command
37:42 - so first of all I don't want this on the
37:44 - main branch so I want to get rid of it
37:45 - from the main branch but I want the work
37:47 - still and I need to move that to another
37:48 - Branch so I'm going to type git log and
37:51 - I'm going to look at the commit hash so
37:54 - this is the hash of the commit that I
37:55 - just made there might be multiple
37:57 - commits by the way that you want to move
37:58 - over in that case you're just going to
38:00 - repeat this process but I grabbed the
38:02 - hash of the commit that I want to move
38:03 - so I'm going to copy that I'm going to
38:05 - quit here
38:07 - I'm going to check out the branch I want
38:08 - to move it to so git checkout in this
38:10 - case feature and then I'm going to type
38:12 - get Cherry Peck
38:15 - I'm going to paste the hash
38:16 - I'm going to cherry pick this commit
38:18 - over to this new bridge so easy as that
38:21 - I've now moved this commit over and if I
38:23 - go back to main now
38:26 - okay you see that I still have the code
38:28 - here so I haven't removed it from Main
38:30 - but I took the commit and I applied it
38:32 - onto the feature branch so now kind of
38:34 - step one of my problem is done I've
38:36 - saved this code and moved it over to a
38:38 - new Branch where it's supposed to be but
38:39 - now I need to get rid of it from this
38:41 - main branch so there's a few ways that I
38:43 - can get rid of it first of all I can
38:45 - just revert back by one commit
38:48 - second of all I can actually reset to
38:52 - the state of my remote repository so I'm
38:55 - going to show you a few different ways
38:56 - to do it the first one I'm going to show
38:57 - you is what I will typically use because
38:59 - I always want my main branch to be up to
39:02 - date with the remote repository main
39:05 - branch so if that's the case if that's
39:06 - all you care about you just want to be
39:07 - completely up to date you don't have any
39:09 - work on the main branch that you care
39:11 - about losing then what you're going to
39:12 - do is type this get reset hyphen hyphen
39:15 - hard this is a dangerous command I'm
39:17 - going to explain this but be careful
39:18 - when you use this and then origin slash
39:21 - make now what this means is I'm going to
39:24 - reset my current Branch to essentially
39:26 - just match origin main now what this
39:29 - dash dash hard means is that I'm going
39:31 - to reset the working tree as well as the
39:33 - get index that essentially means that
39:36 - any files that I've worked on but I
39:37 - haven't committed yet those are going to
39:40 - be deleted so if I've added them into
39:42 - the staging area like they're currently
39:44 - being tracked by git they're going to
39:45 - get deleted now I can kind of prove that
39:47 - to you if I create file
39:49 - txd or text.txt okay I go here and I
39:54 - just add it alright so I've added it to
39:56 - the staging area but I haven't deleted
39:58 - it now if I run git reset dash dash hard
40:00 - origin main you're going to see that
40:02 - that file gets deleted so that's what
40:04 - happens when you do hard all right now
40:07 - if you do soft which is the next one so
40:09 - let me show you this if I create a new
40:10 - file text Dot txt the same thing is
40:14 - going to happen but it's going to keep
40:15 - any that are in the staging area so if I
40:17 - go here and I add this into Stage
40:19 - changes now if I go get reset dash dash
40:22 - soft
40:24 - then what it's going to do is it's going
40:25 - to keep this text file it's not going to
40:27 - delete it because I did a soft reset
40:29 - which means yes the entire like git
40:31 - history this Branch got reseted uh I'll
40:33 - grab reset it sorry got reset but I keep
40:36 - any files that were in my staging area
40:38 - there's a few other options you can use
40:40 - here when it comes to resetting
40:41 - typically I just use hard and that will
40:43 - essentially do a clean kind of reset for
40:45 - you get rid of any changes and just make
40:47 - sure that your branch is up to date with
40:49 - the remote repository again a slightly
40:51 - dangerous command but something that I
40:53 - would keep in mind
40:56 - [Music]
40:59 - so with that said I'm going to start
41:00 - wrapping up this video as a reminder on
41:03 - May 9th I'm teaming up with Microsoft to
41:05 - host a 45 minute long webinar as a part
41:08 - of the developer digital Meetup tour
41:10 - this webinar will go much more in depth
41:12 - on git and GitHub talk about best
41:14 - practices Advanced developer workflows
41:16 - and also discuss vs code GitHub actions
41:19 - and many more topics if you want to
41:21 - register for that you can go to AKA dot
41:23 - Ms slash Tech with Tim and if you are
41:26 - watching this video after May 9th you
41:27 - can still click that link from the
41:29 - description to access the recording with
41:31 - that said I hope you enjoyed the video
41:33 - and I look forward to seeing you in
41:34 - another one
41:38 - foreign
41:42 - [Music]