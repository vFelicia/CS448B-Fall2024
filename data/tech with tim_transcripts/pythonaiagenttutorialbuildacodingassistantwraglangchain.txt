00:00 - in this video I'll be showing you how to
00:01 - build your own custom AI agent using
00:04 - Lang chain and retrieval augmented
00:06 - generation now we'll build this out
00:08 - using Python and even if you're just an
00:10 - intermediate python user you can still
00:12 - follow along you don't need to be a
00:14 - complete expert what we'll do here is
00:17 - actually query information about one of
00:18 - our GitHub repositories and then make an
00:21 - AI agent that acts like a coding or
00:23 - GitHub assistant that means they can
00:25 - summarize different issues it can
00:27 - actually respond to them if we wanted to
00:29 - do that and it can access different
00:30 - tools that we give it so I'm on the
00:32 - computer now and I'll give you a quick
00:34 - demo of how this works now the first
00:36 - thing the agent is going to ask us is if
00:38 - we want to update the issues from GitHub
00:40 - that's because we're going to go to
00:41 - GitHub and grab all of the different
00:43 - issues from whatever repository we
00:45 - select but we don't always need to get
00:47 - fresh issues maybe only every day or
00:49 - every few days we actually want to do
00:51 - that update so in this case I've already
00:53 - updated the issues recently so I'm just
00:55 - going to press no and then what it's
00:56 - going to do is allow me to ask some
00:58 - questions about the GitHub repository or
01:00 - to utilize some different tools that
01:02 - we've given it access to so it says ask
01:04 - a question about GitHub issues so I'm
01:06 - going to say something like hey can you
01:08 - tell me what and we'll do like this what
01:11 - issues people are having related to
01:15 - flashing messages okay so what it's
01:18 - going to do now is show us the thought
01:19 - process of the agent you can see that it
01:22 - goes in queries in our tool which is the
01:24 - GitHub Vector search database we'll talk
01:26 - about that in a second for flashing
01:28 - messages it then retrieves all of the
01:30 - messages that actually fit that criteria
01:32 - and then it gives us a summary of them
01:33 - so it says here are some of the issues
01:35 - related to flashing messages that people
01:36 - are facing and then it spits out the
01:38 - different issues now what I can do is I
01:40 - can actually tell it to make a note of
01:42 - this and it will utilize a different
01:43 - tool that it has access to to actually
01:45 - save this information onto our local
01:47 - computer you'll see what I mean but the
01:49 - agent has various tools and based on
01:51 - what we ask it to do it can reach out
01:53 - and utilize those different tools it's
01:55 - really really cool and you can expand
01:57 - this and make it really awesome so I'm
01:59 - going to ask the same now but I'm going
02:00 - to tell it to save a note so I've just
02:02 - said can you summarize the GitHub issues
02:04 - related to flashing messages and then
02:05 - save them as a note so let's type this
02:07 - in now you can see the first thing it's
02:09 - going to do is use this tool GitHub
02:11 - search with the query flashing messages
02:13 - and then you can see it's invoking the
02:15 - note tool and it saves all of the
02:17 - different uh kind of summary of what do
02:19 - you call it issues so if we go here this
02:21 - is the note that it just saved it says
02:23 - flash messages not showing in the login
02:24 - page and alert message in homepage and
02:26 - then it gives us a description of the
02:28 - issues that people are facing this is
02:30 - just a really small demo showing you
02:32 - what's possible in terms of building an
02:33 - AI agent obviously you can build this
02:35 - out and make it that much cooler and
02:37 - just as a final thing here I'll show you
02:39 - that this is the GitHub repository it's
02:41 - working on and if I go to issues you can
02:43 - see that one of the first issues we have
02:45 - here is related to flashing messages so
02:47 - you can see that's exactly what it found
02:49 - and then summarized for us and stored as
02:51 - a note we could expand this and we could
02:53 - make it automatically reply to issues we
02:55 - could even make it write a poll request
02:57 - to solve certain issues that people are
02:59 - having with that said let's get into the
03:01 - tutorial and let me show you how to
03:03 - build this out so we're going to start
03:04 - building this project out now so what
03:06 - I've done is opened up VSS code I've
03:08 - opened a new folder and this is where
03:10 - we'll write all of our code now the
03:12 - first step is to install a lot of
03:14 - different packages in dependencies and
03:16 - then what we're going to do is retrieve
03:17 - the different issues we need from a
03:19 - GitHub repository this can be your own
03:21 - repository or a public repository I'll
03:23 - show you how we connect that and set
03:25 - that up then we're going to take those
03:27 - issues we're going to store them in
03:28 - something known as a Vector store
03:30 - database we're then going to build out
03:32 - the AI agent which will have access to
03:34 - the database and it can query and look
03:36 - up specific issues really really fast
03:39 - that's basically the process so we need
03:40 - to start with GitHub and getting
03:42 - everything set up so let's do that right
03:44 - now so what I've done is invs code here
03:46 - I've opened up my terminal and I'm going
03:47 - to create a virtual environment to
03:49 - install the various packages that we
03:51 - need now in order to do that we're going
03:53 - to use the command Python
03:55 - 3-m
03:57 - venv and then we can write the name of
03:59 - our ver viral environment in this case
04:01 - I'm just going to call it GitHub now if
04:03 - you're on Windows you can change the
04:04 - command to Simply say python so this is
04:06 - going to create a new virtual
04:08 - environment for us if we spell python
04:10 - correctly and then we can activate the
04:12 - virtual environment with the following
04:14 - command now if you're on Mac the command
04:16 - is going to be source and then GitHub SL
04:20 - bin SL activate like that and then
04:23 - you'll see that we get this GitHub
04:25 - prefix in our terminal if you're on
04:27 - Windows the command will be slightly
04:28 - different and I'm going to leave the
04:30 - command on screen you may also just have
04:32 - to look it up because depending on the
04:34 - command prompt or Powershell or whatever
04:36 - it is that you're using the command
04:37 - could be slightly different anyways I'll
04:39 - put something on screen and then again
04:41 - you might just have to look up exactly
04:42 - how to activate it because it differs
04:44 - based on the shell that you're using
04:46 - regardless once the virtual environment
04:48 - is activated we can install the
04:49 - different packages now if you want a
04:51 - little bit of a cheat you can go to the
04:53 - link in the description and I have all
04:55 - of the finished code for this project
04:57 - already there what you can do is copy
04:59 - the requirements.txt file you can put
05:02 - that inside of this directory and then
05:04 - you can install all of the requirements
05:06 - there or you can follow along with what
05:08 - I'm about to show you here where we just
05:10 - install the different packages manually
05:12 - so what we're going to do now is type
05:13 - pip install and then we're going to
05:15 - write the different packages that we
05:17 - need now the first package we need is
05:19 - python let's make sure we spell that
05:21 - correctly d.v for loading in environment
05:25 - variables we then need the request
05:28 - module this is so that we can send
05:30 - requests to the GitHub API to get
05:32 - different issues we then need the Lang
05:35 - chain package okay this is how we're
05:37 - going to actually write our agent we
05:39 - then need the Lang chain dastra DB this
05:43 - is because we're going to use astrab as
05:45 - our Vector store provider again we'll
05:47 - talk about how that works in a second we
05:49 - then need Lang chain and this is going
05:51 - to be open Ai and then Lang chain and
05:56 - this is Hub okay so let me just double
05:58 - check that those are correct correct
06:00 - looks like those are good to go so again
06:02 - python. EnV requests Lang chain Lang
06:05 - chain astrab Lang chain open aai and
06:07 - then Lang chain Hub we're going to
06:09 - install all of those in our virtual
06:11 - environment and then we should be good
06:12 - to go all right so our virtual
06:14 - environment is set up so now we can
06:15 - actually start writing some code but
06:17 - what I'd like to do now is I'd like to
06:19 - get all of the different tokens and
06:21 - credentials that we're going to need for
06:23 - this project and just get them set up so
06:25 - we can do all of the coding at once and
06:26 - we don't have to keep going back and
06:27 - forth between our browser and different
06:29 - websites so what we'll do in VSS code is
06:32 - we'll create a EnV file now this is an
06:34 - environment variable file where we're
06:36 - going to store all of the sensitive
06:38 - credentials that we're going to need
06:39 - because we're going to be connecting
06:40 - with various apis we're going to be
06:42 - connecting with the database and we're
06:43 - going to be connecting with open AI so
06:45 - bear with me here and we're going to
06:47 - write out a few different keys that
06:48 - we're going to be filling in in the next
06:49 - few minutes so we're going to type
06:51 - GitHub token and this is going to be
06:54 - equal to an empty string we're then
06:56 - going to say Astra and this is going to
06:58 - be underscore d
07:00 - bcore API uncore endpoint is equal again
07:04 - to an empty string we're then going to
07:06 - say Astra _ DB underscore application
07:11 - underscore token is equal again to an
07:14 - empty string we're going to say Astra
07:16 - uncore
07:17 - dbor keyspace is equal to an empty
07:20 - string and then open aior apore key is
07:25 - equal to an empty string so we're going
07:27 - to fill all of these in with our own
07:28 - credentials for astrab this is the
07:31 - vector store database provider this
07:33 - actually comes from data Stacks which is
07:35 - the sponsor of this video don't worry
07:37 - they're free to use and I'm going to
07:38 - show you how to set that up in just a
07:40 - second so the first thing we're going to
07:41 - do is get our GitHub token this is going
07:43 - to allow us to access the GitHub API so
07:46 - what I'm going to do here is go to my
07:48 - browser I'm going to go to GitHub which
07:50 - conveniently I already have open I'm
07:51 - actually just going to open this in a
07:53 - new tab so we can save that page and
07:55 - what we're going to do here is click on
07:56 - our little icon and we're going to go to
07:59 - settings from settings we're going to
08:01 - scroll down here to the developer
08:03 - settings on the bottom left hand side
08:05 - and what we'll do is we'll go to
08:07 - personal access tokens and then tokens
08:10 - classic from here we're going to create
08:12 - a new token I've already created it so
08:14 - I'm not going to make a new one here but
08:15 - you can simply press this button make
08:17 - sure you create a classic token and then
08:19 - copy the token into the location that I
08:22 - showed you all right so you should have
08:24 - copied that token and then you just want
08:25 - to paste it right here where it says
08:27 - GitHub token don't worry I'm going to
08:29 - invoke this token after the video so you
08:31 - guys cannot use it and the next step is
08:33 - to get all of our information for our
08:34 - Astro DB database so what we're going to
08:37 - do now is go to this site right here
08:39 - which is the data Stacks website again
08:41 - thank you to them for sponsoring this
08:43 - video and providing this database for
08:44 - free for all of us to use you can simply
08:47 - click the link in the description and
08:48 - you'll be able to view it now let me
08:49 - quickly explain what this actually is
08:51 - and why we need it for this video so
08:53 - we're going to be building a rag
08:55 - application retrieval augmented
08:57 - generation and what that means is that
08:59 - our AI agent is going to have access to
09:01 - in this case a database something called
09:03 - a vector store database where it can
09:05 - really quickly look up in query
09:07 - information now data Stacks is going to
09:09 - be providing that database through their
09:11 - product known as astrab this is a very
09:13 - fast Vector database that allows us to
09:15 - really quickly look up information based
09:17 - on similarity so rather than dumping all
09:20 - of the different contents of our GitHub
09:22 - issues to our agent which it might not
09:24 - even be able to handle because it could
09:26 - be so much information what's going to
09:28 - happen is the agent is going to utilize
09:29 - this Vector database it's going to query
09:32 - for a certain piece of information and
09:34 - then it's going to be able to look up
09:35 - based on similarity this is what the
09:37 - database is doing all of the pieces of
09:39 - information that are relevant to the
09:40 - query and then return just that data to
09:43 - our model so it can utilize it and give
09:45 - us some results based on it so this is
09:47 - kind of the basic setup for rag usually
09:49 - we are using a vector store database and
09:52 - the way this works is we have vectorized
09:54 - information that allows us to search for
09:56 - information based on context based on
09:58 - similarity and that's much faster and
10:01 - more efficient than using a traditional
10:02 - SQL database so I don't want to explain
10:05 - it too much you can look up Vector store
10:06 - databases if you want to learn more but
10:08 - Astro DB has a free one that we can mess
10:10 - with for this video and obviously they
10:12 - have paid plans as well if you want to
10:13 - scale this up to production so what
10:15 - we're going to do is click on try for
10:17 - free here and if you don't already have
10:19 - an account make one in my case I'm just
10:21 - going to sign in we're going to make a
10:23 - new database and I'm going to show you
10:24 - how we can configure this all right so
10:26 - once you've created your account or
10:27 - signed in you'll be brought to a page
10:29 - that looks like this where what we're
10:30 - going to do is click on databases and
10:32 - we're then going to create a new one now
10:34 - you can see I already have one that I
10:35 - was messing with when preparing this
10:37 - video what we can do is click on create
10:39 - a database we're going to go with the
10:41 - serverless vector database which is the
10:43 - one that I was talking about and then
10:44 - we're going to give this a name now in
10:46 - this case I'm just going to call this
10:47 - the GitHub agent and then we need to
10:49 - choose a provider and a region so I'm
10:51 - just going to leave it as Amazon web
10:53 - services and I'll go with us East 2
10:55 - obviously if you're upgrading to the
10:56 - premium version you'll get some more
10:58 - options here but for case this is
10:59 - completely fine and we'll be able to do
11:01 - everything we need without paying for
11:03 - this service okay so I've just done that
11:05 - here you can see that it's initializing
11:07 - the database this will take a few
11:08 - minutes once it's done I'll be right
11:10 - back and I'll show you how we retrieve
11:12 - the information that we need to connect
11:13 - to this from our code all right so the
11:15 - database has been created now and what
11:17 - we're going to be looking for is our API
11:19 - endpoint and our application token so
11:22 - what I'm going to do is copy the API
11:23 - endpoint here we're going to go back to
11:25 - our code and we're going to paste that
11:27 - in and then we're going to do the same
11:29 - same thing for our token so we're first
11:30 - going to press generate token it's going
11:32 - to give us one let's copy that obviously
11:34 - you don't want to leak it like I am and
11:36 - then paste it here and for the key space
11:40 - if we can go back here this is something
11:42 - that you don't actually need to fill in
11:43 - I'm just putting it here in case you do
11:45 - want to enter this information you don't
11:46 - really have to concern yourself about
11:48 - what that is okay next we need our open
11:50 - AI API key so that we can connect to
11:53 - openai and use chat GPT so in order to
11:56 - do that we're going to go to platform.
11:58 - open.com / API keys I can leave this
12:01 - link in the description you also can
12:03 - probably find it pretty easily just by
12:04 - going to open aai and we're going to
12:06 - make a new key now I believe at this
12:08 - point you do need to actually add a
12:09 - credit card to open AI in order to
12:11 - utilize this it should only cost you a
12:13 - few cents if anything it might even be
12:15 - free but I just want to make you aware
12:17 - that you do need to have some kind of
12:18 - payment method here I believe as of the
12:20 - last time I did this in order to use
12:22 - this API there are other ways to run
12:24 - this project locally using something
12:25 - like oama but we're not going to be
12:27 - walking through that in this video so
12:29 - I'm going to click on create new key I'm
12:31 - just going to call this my GitHub agent
12:33 - okay it's going to give us a new secret
12:35 - key here and we're going to copy this
12:37 - and then same thing go back to our code
12:39 - and paste this for our open a open AI
12:42 - API key that is always a mouthful okay
12:45 - so now we have all of our tokens and we
12:47 - can stay here in vs code and actually
12:49 - write the completed project so let's
12:51 - close our terminal and let's make a new
12:53 - file here called
12:59 - and retrieve the different GitHub issues
13:02 - so inside of here we're going to start
13:03 - with our Imports we're going to say
13:05 - import OS we are going to
13:07 - import requests we are going to import
13:11 - actually we're going to say from. EnV
13:14 - import and then load. EnV and then we're
13:17 - going to say from Lang
13:20 - chain
13:22 - core. documents import the document okay
13:27 - we're going to use that in a second
13:28 - that's how we're actually going to wrap
13:29 - our GitHub issues and then pass it to
13:31 - our Vector store database now the first
13:34 - thing we're going to do is call this
13:35 - load. EnV function and what that will do
13:37 - is search for the presence of a EnV file
13:40 - and then load all of these environment
13:42 - variables uh for us so you need this to
13:44 - actually load those different variables
13:46 - so that they're in the Python program
13:48 - and we're able to utilize them the next
13:50 - thing we're going to do is grab our
13:51 - GitHub token so we're going to say
13:52 - GitHub unor token is equal to os. getet
13:56 - EnV and then we're going to grab the
13:58 - name of that variable which is GitHub
14:01 - token which will now have been loaded
14:03 - from this function okay next what we're
14:06 - going to do is write a function that
14:07 - will utilize the GitHub API you don't
14:09 - need to set anything up here you just
14:10 - need this token in order for it to work
14:13 - so we're going to say Define fetch
14:14 - uncore GitHub we're then going to have
14:17 - the owner the repo and the Endo of the
14:20 - information that we want to fetch now
14:22 - what we're going to do is craft a URL
14:24 - here so we're going to make an F string
14:26 - in Python and this is going to be https
14:28 - called sl/ api. github.com SL repos SL
14:35 - and then we're going to put inside of
14:36 - curly braces here the owner the repo and
14:41 - the endpoint so you can see that we're
14:43 - making this Dynamic let me just make
14:45 - this a bit smaller so we can see it uh
14:47 - so that we can load any kind of repo
14:49 - that we want we just need to pass in
14:51 - these different parameters so that's how
14:52 - we're crafting the URL and the end point
14:54 - would be something like the issues or a
14:56 - readme file or PLL requests we can grab
14:59 - grab different pieces of information in
15:00 - this case we're just doing the issues
15:02 - but you could really easily adapt this
15:04 - code to grab all different kinds of info
15:06 - from your GitHub repository and then
15:08 - pass that to the agent okay next thing
15:11 - is we're going to set up our headers so
15:13 - we're going to say headers are equal to
15:15 - and we're going to create the
15:16 - authorization header which is what we'll
15:18 - need in order to actually send an
15:20 - authorized request to GitHub so we're
15:21 - going to say authorization and then this
15:23 - is going to be an F string and this is
15:25 - going to be Bearer and then it's very
15:26 - important that you have a space and then
15:29 - curly braces and then the GitHub token
15:31 - this is how we pass our authentication
15:33 - token so that we're able to actually
15:34 - send this request and get back a valid
15:36 - response next what we're going to do is
15:38 - we're going to craft the request so
15:40 - we're going to say response is equal to
15:43 - request.get we're going to send this to
15:45 - the URL and we're going to say that our
15:47 - headers is equal to the headers that
15:50 - we've just set up now what we're going
15:52 - to do is check the status of this
15:54 - response so this will send a request to
15:56 - this get URL and give us some
15:57 - information back so we're going to say
15:59 - if
16:00 - response. status code is equal equal to
16:04 - 200 then we can say data is equal to
16:08 - response. Json so that's how we can
16:10 - actually load this this will load it as
16:12 - a python dictionary the data we got back
16:15 - otherwise we're going to say print and
16:18 - we'll just say failed with status code
16:23 - and then we can print out the status
16:24 - code which will be response. statuscode
16:29 - okay then we can just return an empty
16:31 - array
16:33 - here otherwise we'll come down here and
16:36 - we're going to return our data okay
16:39 - perfect so now that we have our fetch
16:42 - GitHub function we're going to write a
16:44 - function that will call this and then
16:46 - get all of the results and wrap them as
16:49 - a lang chain document which we're going
16:51 - to need for the next step which you'll
16:53 - see in a minute but for now what we can
16:55 - actually do just to test this out is we
16:57 - can print and we'll just print the data
17:00 - that we got before we return it so that
17:02 - we can see what that looks like so let's
17:04 - call this function so to call the
17:06 - function we're going to say fetch GitHub
17:08 - and then what we need to pass to this is
17:09 - an owner a repo and an endpoint now what
17:13 - are the owner repo and endpoint going to
17:15 - be well for the owner this is going to
17:17 - be Tech with Tim because that's my
17:19 - GitHub account obviously you can change
17:21 - this to your own for the repo I actually
17:24 - need to find what the repository name is
17:26 - so that I don't mess it up okay so the
17:28 - repo is going to be our flask web app
17:31 - tutorial I believe that you guys should
17:33 - be able to put this in as well because
17:34 - this is a public repository and then the
17:36 - endpoint is going to be equal to issues
17:40 - so now I'm going to pass this owner repo
17:43 - endpoint and we can run our code and we
17:45 - can test to see if this is working so
17:47 - let's clear and go Python 3
17:58 - pretty difficult to see but the main
18:00 - important thing to understand is that
18:02 - this is inside of a list and what this
18:04 - is doing is giving me all of the
18:05 - different issues with a bunch of
18:07 - different parameters and properties
18:08 - about them now you can look through this
18:10 - request and you can parse it however you
18:12 - want but just trust me in the next step
18:14 - here because I've already looked through
18:15 - it and found the important keys that we
18:17 - want to extract so what I'm going to do
18:19 - is close this and now let me just make
18:22 - this a bit smaller so we can see it
18:24 - we're going to write a function that
18:26 - will take the results here and then wrap
18:28 - them as a l chain document so we're
18:30 - going to say Define and this is going to
18:33 - be the following we're going to call
18:35 - this load issues so we're going to say
18:37 - load uncore issues this is simply going
18:39 - to take in the different issues and then
18:42 - as I said it's going to parse them and
18:44 - load them as a document that we can
18:45 - actually use in our retrieval augmented
18:47 - generation program so we're going to say
18:49 - docs is equal to an empty list we can
18:52 - make this bigger again so we can see it
18:54 - okay let's go up here we're then going
18:56 - to say for entry in issues remember that
19:00 - issues is a list of all of the different
19:02 - issues that have a bunch of different
19:03 - Keys now what we're going to do is
19:05 - create some metadata so we're going to
19:07 - say metadata is equal to and we're going
19:09 - to make a python dictionary the first
19:12 - piece of metadata we're going to want is
19:13 - the author so in order to get the author
19:15 - from our issue this is going to be entry
19:18 - user and then it's called login again
19:21 - this might seem like gibberish but I've
19:23 - gone through the issues and these are
19:24 - all of the different keys that are in
19:26 - that Json or that are in that python
19:28 - dictionary that we need to access next
19:30 - we're going to have the comments we
19:32 - probably want that as metadata as part
19:33 - of the issue so to have that we're going
19:35 - to say entry and then comments this is a
19:38 - list of all of the different comments
19:39 - that then contain some more information
19:41 - we're then going to have the body of the
19:43 - issue which is the main text description
19:45 - so that's going to be entry and then
19:47 - body we'll then have the labels so maybe
19:50 - they've labeled this and that can help
19:51 - us get some context about the issue
19:53 - that'll be entry and then labels and
19:57 - then lastly here we're just going to get
19:58 - the created at date so we're going to
20:01 - say created at and then this is going to
20:02 - be entry and then created at so this is
20:06 - metadata that will store with all of our
20:08 - different documents there is a lot more
20:10 - information associated with the issues
20:11 - but this is the important stuff that
20:13 - we're pulling out next we're going to
20:15 - say data is equal to entry and then
20:19 - title so we're going to get the title of
20:21 - this entry or of this issue because
20:23 - that's the main thing that we want when
20:25 - we're actually indexing or looking up
20:27 - these issues and then what we're going
20:28 - to is we're going to say if entry and
20:31 - then body so if we actually have some
20:34 - body text through a description because
20:35 - not all issues do then we're going to
20:37 - say data plus equals the entry of the
20:41 - body now what this is doing is it's
20:43 - taking that description and it's
20:45 - concatenating that to the title so that
20:47 - when we add kind of the main content of
20:49 - our documents which you're going to see
20:51 - in a second we have both the title and
20:53 - the description so we have more
20:54 - information so our model can perform
20:56 - better so I'm going to say Doc is equal
20:59 - to document and then what we're going to
21:01 - do is say the pageor content is equal to
21:05 - and then this is going to be the data so
21:06 - what we've just crafted right here and
21:09 - then we're going to set our metadata so
21:10 - we're going to say metadata is equal to
21:13 - metadata so when we actually search in
21:15 - the database for this information we're
21:16 - mostly going to be looking in the page
21:18 - content and the metadata is additional
21:20 - information that's provided about the
21:23 - document okay so that's why we've taken
21:24 - the title and the body and we've
21:26 - combined them together for the page
21:28 - content
21:29 - uh argument okay now that we have this
21:31 - document crafted we're going to say
21:33 - docs. append and we're going to append
21:36 - this document and then from this
21:38 - function here we're going to return the
21:41 - different docs okay we're almost done
21:43 - we're just going to write one more
21:44 - function here this function is going to
21:46 - say Define and this is going to be fetch
21:50 - unor
21:51 - GitHub issues and what we're going to do
21:54 - is have an owner and a repo and inside
21:57 - of here we're going to say data is equal
22:00 - to fetch GitHub and we're going to fetch
22:03 - the owner the repo and we're manually
22:05 - going to specify that we want the issues
22:07 - endpoint and then we're going to return
22:10 - load
22:12 - issues okay and we're going to pass in
22:15 - here the data okay so all I'm doing is
22:19 - writing one function that combines these
22:20 - two functions together it first fetches
22:23 - the GitHub information that we need it
22:24 - then loads the issues and then returns
22:27 - all of that for us great now that we
22:29 - have that what we're going to do is
22:31 - write another file this file is going to
22:33 - be called main.py where we're then going
22:35 - to import this code that we've ridden
22:37 - and we're going to use it to actually
22:39 - load this in and store it in the vector
22:41 - store database all right so we're inside
22:43 - of main.py and we're going to start with
22:44 - all of our Imports there are actually
22:46 - quite a few and then we'll write the
22:47 - main kind of chunk of code here again
22:50 - now at this point I know we haven't
22:51 - really seen it or tested it we're
22:53 - fetching all of the different GitHub
22:55 - issues from our repository and we're
22:57 - loading those as documents that we need
22:59 - to actually store in the vector store
23:00 - database now we need to connect to the
23:02 - vector store database and save that
23:04 - information and then we can move on to
23:06 - writing the agent which will have access
23:08 - to this database as a tool so we're
23:10 - going to go to the top of our program
23:12 - and we're going to say from EnV uh
23:14 - import load. EnV we're then going to
23:17 - import OS and then we're going to import
23:19 - a bunch of stuff that we need from Lang
23:21 - chain so we're going to say from Lang
23:22 - chain openai import and this is going to
23:25 - be chat openai and open a I embeddings
23:29 - we're then going to say from langing
23:32 - chain asrb and we're going to import the
23:36 - Astra DB Vector store by the way don't
23:39 - worry if I'm going too fast for you you
23:40 - can always copy all of this code from
23:42 - the link in the description or feel free
23:44 - to pause the video or slow down the
23:45 - playback speed we then are going to say
23:48 - from Lang
23:49 - chain. agents and we are going to import
23:53 - the create and this is going to beore
23:56 - agent uncore is this actually what it's
23:59 - called no sorry create tool calling
24:02 - agent that's the name of it we're then
24:04 - going to say from Lang chain do agent
24:09 - import and this is going to be the agent
24:11 - executor we're then going to say from
24:14 - Lang chain.
24:17 - tools.
24:19 - retriever import and this is going to be
24:21 - the create retriever tool we're then
24:24 - going to say from Lang chain hub import
24:29 - and this is going to be Hub and then
24:31 - we're going to say from GitHub which is
24:33 - the file that we wrote import the fetch
24:37 - GitHub issues okay now we're going to
24:40 - call the load. EnV function so we load
24:43 - in the environment variables inside of
24:45 - this file as well and now we're going to
24:47 - connect to our Vector store database
24:50 - okay so what we'll do here is we'll
24:52 - write a function called connector 2or
24:56 - Vore standing for our Vector store
24:59 - inside of here what we need to do is
25:01 - create something known as a set of
25:02 - embeddings I'll talk about that in a
25:04 - second and then connect to the astrab
25:06 - database provided by data Stacks now in
25:09 - order to do that we'll load in the
25:10 - different keys that we have in our
25:11 - environment variable file we'll create a
25:13 - new instance of the vector store connect
25:16 - to it and then I'll show you how we
25:17 - utilize it okay so let's create some
25:19 - embeddings we're going to say embeddings
25:21 - are equal to the open Ai embeddings and
25:24 - what an embedding is is a way of
25:26 - actually kind of turning turning a piece
25:28 - of data in this case textual data into a
25:31 - vector now a vector is something that
25:33 - exists in multi-dimensional space and
25:35 - this is what we're actually storing
25:37 - inside of the vector stor database so
25:39 - these embeddings will be used by the
25:41 - vector store database to first take our
25:43 - textual data or our documents convert
25:45 - them into vectors and then we store them
25:48 - inside the database so that's why we
25:49 - first need to use these embeddings now
25:51 - these are provided by open Ai and the
25:53 - reason why this function here is going
25:55 - to work is because we've specified
25:57 - inside the environment variable file our
26:00 - open AI API key if we didn't specify
26:03 - that this code wouldn't work because in
26:04 - the background it's looking for that
26:06 - special environment variable so we're
26:08 - using open AI here to provide us these
26:11 - embeddings which is kind of like a mini
26:12 - machine learning model which is going
26:14 - again and converting that data into
26:16 - vectors which we can then store inside
26:18 - of the database okay so the next thing
26:20 - we need to do is load in our Astra DB
26:22 - credentials so we're going to say Astra
26:24 - DB API uncore endpoint
26:28 - is equal to os. get EnV and then we can
26:33 - simply take this and we can paste it
26:36 - inside of here as a string okay we then
26:40 - need our Astra DB uncore application
26:46 - unor token which is equal to os. getv
26:50 - and then same thing we can take this and
26:52 - we can paste it inside of here as a
26:54 - string and then we're going to have the
26:56 - desired undor name namespace equal to
27:00 - os. getet EnV and then same thing this
27:03 - is going to be the
27:04 - Astra
27:06 - dbor keyspace okay this is going to be
27:08 - blank we don't actually need to Define
27:10 - this um there's some more advanced
27:12 - configurations where you can again we
27:13 - don't need to talk about that right now
27:15 - so I'm going to say if the desired name
27:18 - space actually exists then we're going
27:20 - to say the Astra
27:22 - dbor
27:24 - keyspace okay let's write this out is
27:27 - equal to the
27:28 - desired name space otherwise we're going
27:32 - to say the Astra DB key space is equal
27:34 - to none the reason for that is when we
27:36 - load this in it's going to give us an
27:37 - empty string an empty string is not
27:39 - actually a valid option so what we need
27:41 - to do is check okay is this an empty
27:43 - string if it is or if it isn't sorry
27:45 - then we'll just actually set it to this
27:46 - astrab key space otherwise we'll set it
27:49 - equal to none so that astrab knows not
27:51 - to use this option okay now we're going
27:54 - to say the V store is equal to the as ra
27:58 - DB Vector store and inside of here we're
28:01 - going to pass our different options so
28:03 - we're going to pass embedding is equal
28:05 - to the embeddings we're going to pass
28:08 - the collection name which is kind of
28:10 - like the name of the database or the
28:11 - table in this case it's uh non-sql
28:14 - database it's not really a table but
28:16 - it's called a collection where we're
28:17 - actually going to be storing our data in
28:19 - this case we're going to store it in
28:20 - something called GitHub but you can
28:21 - change the name of this if you want
28:23 - we're then going to set our API endpoint
28:25 - equal to the Astro DB API endpoint and
28:29 - then we're going to have our token equal
28:31 - to our Astra DB application token and
28:35 - then the Nam space oops did not mean to
28:38 - do that let's close all that equal to
28:41 - the Astro DB keyspace okay then lastly
28:45 - we're going to return our V store and
28:48 - that is our function to connect to the
28:50 - vector store now what this will do is it
28:52 - will look to see if this collection
28:54 - exists if it doesn't already exist it's
28:56 - actually going to automatically create
28:58 - it for us so just something to keep in
29:00 - mind there The Collection name GitHub if
29:02 - it doesn't exist well it will just make
29:03 - it for us when it connects to it okay so
29:06 - now what we're going to do is we're
29:07 - going to write a function and we're
29:08 - going to say or sorry we're going to
29:09 - write a line and we're going to say V
29:10 - store is equal to connect to V store the
29:14 - next thing we're going to do is we're
29:15 - going to ask the user if they want to
29:17 - update the issues the reason why we're
29:18 - going to ask them that is we don't
29:20 - always need to update the issues in the
29:22 - vector store it's only maybe every day
29:24 - or every few days that we're getting new
29:25 - issues on our GitHub repository so it's
29:28 - inefficient to constantly do this so
29:30 - we'll just manually tell the program
29:31 - when we want to update it and only then
29:33 - will we actually hit the GitHub API and
29:35 - then do the operations with our database
29:38 - so we're just going to have a line here
29:39 - we're going to say add to Vector store
29:43 - like that is equal to an input statement
29:46 - and instead of here we're going to say
29:47 - do you want to update the issues
29:52 - question mark and then we're going to
29:53 - put our options y comma or y/ capital N
29:57 - the reason I'm doing a capital N is
29:59 - that's the default option I'm then going
30:01 - to convert this to lower and I'm going
30:03 - to check if this is in the list of yes
30:07 - or Y so all I'm doing is I'm getting the
30:09 - input here and I'm saying okay if what
30:11 - they typed in as lowercase is in yes or
30:14 - Y so if it's one of those two options
30:16 - then that means yes we do actually want
30:18 - to update the vector store or add our
30:21 - issues to the vector store so then we'll
30:22 - go ahead and do that okay so if this is
30:25 - the case so if we are adding to the
30:27 - vector store then what we're going to do
30:29 - is we're going to call the function that
30:31 - we had here which is fetch GitHub issues
30:35 - so I'm just going to copy all of the
30:36 - code that we had here because we no
30:38 - longer want that inside of this file and
30:41 - we're going to paste that inside of here
30:42 - so we have our owner and our repo and
30:45 - our endpoint and we don't actually need
30:47 - the endpoint here because we're going to
30:49 - be using a different function this
30:51 - function is fetch GitHub issues where we
30:53 - don't need to pass the endpoint we just
30:55 - pass the owner and the repo now with
30:57 - this returns is a bunch of different
30:59 - documents again these are the documents
31:01 - generated by Lang chain which we can
31:03 - then use to add to our Vector store okay
31:06 - so now we need to add them to the vector
31:08 - store so to do that we're first just
31:10 - going to try the following we're going
31:12 - to say V store. delete
31:16 - collection we're going to say accept and
31:18 - then pass now the reason I'm doing this
31:21 - is that if we are going to update the
31:22 - vector store we first want to clear any
31:24 - issues that are currently in there in
31:26 - case for example an issue was deleted or
31:29 - resolved or removed since the last time
31:31 - that we updated it so we're just going
31:33 - to clear the entire collection so remove
31:35 - everything that we currently have and
31:37 - then add all of the new issues that
31:38 - we've grabbed into there okay so we're
31:40 - going to go here and we're going to say
31:42 - Vore is equal to connect to V store and
31:46 - then we're going to say vor. addore
31:49 - documents and we're just going to go
31:52 - here and add our different issues and
31:55 - actually sorry issues is equal to fetch
31:58 - GitHub issues okay let me quickly run
32:00 - through this because I want to make sure
32:01 - I'm not confusing any of you we have our
32:02 - owner we have our repo we go and we
32:04 - fetch our different GitHub issues we
32:06 - store those as issues we then try to
32:08 - delete the collection in case it already
32:10 - existed now what I'm doing after this is
32:13 - I'm reconnecting to the vector store and
32:15 - the reason why I'm doing this again
32:17 - because you notice I have it up here as
32:18 - well is because if we did actually
32:21 - delete the collection then that means
32:22 - that we need to connect to it again so
32:24 - that it's automatically recreated so you
32:27 - can see I have my collection name GitHub
32:29 - if I delete it and then I just try to
32:31 - continue to use the vector store well
32:33 - we're not going to have that GitHub
32:34 - collection so I try to connect to it
32:37 - again so in case it was deleted it will
32:39 - automatically be recreated from right
32:41 - here and then return to me so I can
32:43 - start using it so it's slightly
32:45 - inefficient but it's just kind of the
32:46 - most or it's kind of the best way sorry
32:48 - to actually go about recreating the
32:49 - collection if in case we deleted it okay
32:52 - so that's going to add all of the
32:53 - documents but now we want to actually
32:55 - test and see if this database is is
32:58 - working and if it can actually look up
32:59 - any of the GitHub issue information so
33:02 - in order to do that we can write the
33:03 - following line we can say results are
33:06 - equal to and this is just some test code
33:08 - we can delete after and we're going to
33:10 - say Vore Dot and then we can use this
33:13 - similarity search and we can pass inside
33:16 - of here something like flash messages
33:19 - and we can say k equals 3 which is the
33:21 - number of documents that's going to be
33:23 - returned to us so we could return more
33:24 - if we want in this case we'll just get
33:26 - the three most similar documents to
33:28 - flash messages so we're doing a vector
33:31 - lookup here on all of the different
33:33 - issues okay so now what we're going to
33:35 - do is say for res in results because
33:37 - this will be a list of various documents
33:40 - we're going to print the following and
33:41 - this is going to be an FST
33:43 - string okay inside of here we're going
33:46 - to put an asterisk and then we're going
33:48 - to say that this is res. Page uncore
33:52 - content and then we're going to put here
33:55 - this is res.
33:58 - metadata okay so that should be good and
34:01 - now if we run our code and we type yes
34:04 - or why it should go to GitHub fetch
34:06 - those different issues and then print
34:08 - out to us the various results so let's
34:09 - test this out before we go any further
34:11 - let me get out of this however I ended
34:13 - up doing that let's clear this I'm going
34:15 - to type Python 3
34:19 - main.py and we'll see here it's going to
34:21 - give us some warning we can ignore that
34:23 - for now and let's give it a second here
34:25 - to connect and load everything up and we
34:28 - got some issue it says cannot import the
34:31 - name hub from Lang chain Hub okay let me
34:34 - see what the problem is here and then we
34:35 - can fix that all right so it's actually
34:37 - not the import of Lang chain Hub it's
34:40 - just from Lang chain import Hub my
34:42 - apologies guys on line nine there we'll
34:44 - fix that up and we'll rerun our code now
34:47 - and hopefully this time it will work all
34:48 - right so we have the prompt appearing
34:50 - here so I'm just going to type in why
34:52 - for yes so that we can update the issues
34:54 - and we can test this code okay so you
34:56 - can see that that worked extreme fast
34:58 - you can see that it printed out all of
35:00 - the different GitHub issues okay so
35:01 - actually we're not yet at the similarity
35:02 - search this was just me forgetting to
35:04 - remove that print statement from the
35:06 - GitHub code that we had so no problem
35:07 - but it did retrieve these different
35:09 - issues and it's worth noting by the way
35:11 - this only retrieves 30 issues at a time
35:13 - we could build in some pagination and we
35:15 - could get all of the different issues
35:17 - but in this case we'll just go with the
35:18 - 30 most recent ones which is what it's
35:20 - giving us and then the similarity search
35:22 - should work in a second but it does just
35:24 - take a minute to actually connect to the
35:26 - uh what do you call it dat datase and
35:28 - then do that search operation okay so we
35:30 - got an issue here that says document
35:32 - object has no attribute met data the
35:34 - reason why we got that issue as well
35:36 - because we spelled metadata incorrectly
35:38 - of course another silly mistake we can
35:41 - quickly fix that and we can rerun our
35:43 - code one more time I'll fast forward
35:45 - through it and we'll just make sure that
35:46 - this works all right so the code did
35:48 - indeed work and you can see here that
35:51 - when I WR scroll through kind of the
35:52 - results that we get a bunch of different
35:55 - uh kind of similarity searches or Sim
35:57 - Sim similarity search results sorry so
35:59 - it says alert message and homepage and
36:01 - then it spits out the whole body here hi
36:03 - there so as I'm following the video Blah
36:04 - Blah Blah this was the issue and then it
36:06 - gives us information like the author the
36:08 - comments uh and everything else that we
36:10 - specified here in the metadata so that's
36:13 - pretty much it in terms of doing the
36:14 - similarity search I just wanted to show
36:16 - you that that does work and how you can
36:18 - test it out manually by using this line
36:20 - of code right here we don't actually
36:22 - need this so I'm just going to comment
36:23 - it out and now what we're going to do is
36:25 - move on to actually writing the agent
36:27 - we're going to provide this Vector store
36:30 - so the one that we wrote right here as a
36:32 - tool to the agent and it can decide when
36:34 - it needs to use it so that's the really
36:36 - cool part about agents we just give them
36:38 - these different Tools in this case one
36:39 - of the tools is the retrieval augmented
36:41 - generation part so our Vector store
36:43 - database and if it needs to use it it
36:46 - will if it doesn't need to use it it
36:47 - won't we're also going to build another
36:49 - tool which is just a python function
36:51 - that will allow us to save a note okay
36:53 - so let's go and do that so since this is
36:56 - going to be a tool we need to write app
36:57 - this as a tool in order to do that we're
36:59 - going to say Retriever and did I spell
37:03 - that correctly I'm not really sure but I
37:05 - think that's fine will be the vor.
37:09 - asore retriever we're going to go here
37:12 - and say the search uncore quars are
37:17 - equal to and this is going to be K3 so
37:20 - it just returns three documents if we
37:22 - wanted to return more documents we can
37:24 - set this to five 10 whatever we want
37:27 - okay then we're going to say the
37:30 - retriever tool is equal to the create
37:33 - retriever tool which we imported earlier
37:36 - we're going to pass in here the
37:38 - Retriever and then we need to give some
37:40 - description to what this tool is so
37:42 - we're going to say GitHub undor search
37:45 - so what we're doing first is we're
37:46 - providing the name for the tool and then
37:48 - we're going to write a description of
37:50 - what the tool does and when the agent
37:52 - should use it so this is kind of how the
37:54 - tools work we provide what the tool
37:56 - actually is in this case it's a vector
37:58 - store database Lang chain will
38:00 - automatically kind of allow the agent to
38:02 - invoke this and start querying for
38:04 - different documents but the agent needs
38:05 - to know when to use it and in order to
38:07 - do that we have to provide it that data
38:09 - so we say okay the name is GitHub search
38:12 - and then the description is going to be
38:13 - whatever it is uh that we want to tell
38:15 - the agent that this tool is about so I'm
38:17 - just going to copy in the description to
38:19 - save us a little bit of time you can
38:21 - modify this and see if it works better
38:22 - for you but this was working well for me
38:25 - this says search for information about
38:26 - GitHub issues for any questions about
38:28 - GitHub issues you must use this tool
38:30 - okay so really straightforward I'm just
38:32 - telling you what the tool is and when it
38:33 - should use it and now that we have that
38:36 - tool what we'll do is start setting up
38:37 - our chain of kind of different prompts
38:40 - and return types and all the things we
38:42 - actually need in order to run this agent
38:44 - so now that we have this tool set up and
38:46 - by the way we're going to write another
38:47 - one in a second we need to have a
38:49 - special prompt that kind of tells our AI
38:52 - in this case it'll be chat GPT how to
38:54 - utilize these tools and how it should
38:56 - behave now rather than than writing our
38:58 - own prompt and trying to come up with
38:59 - one we can actually just download one
39:02 - from Lang chain Hub that's automatically
39:04 - configured to do everything that we want
39:06 - so we're going to say prompt is equal to
39:09 - hub. pull and bear with me while I write
39:12 - this out this is HW Chase 17 this is
39:16 - going to be slopen aai and then
39:19 - functions agent okay so this is a
39:22 - special prompt for openai or for chat
39:24 - GPT that tells it how it should behave
39:28 - and how it should utilize the various
39:29 - tools that we give it that's it this is
39:31 - just going to download it for us and
39:32 - automatically inject it into our code if
39:35 - you want to view how it works you can
39:36 - just go to this URL or you can just look
39:38 - this up on Lang chain Hub and you can
39:40 - see kind of what the prompt looks like
39:42 - now that we've done that we're going to
39:44 - create the llm that we'll use our
39:45 - various tools so we're going to say llm
39:47 - is equal to chat open aai we don't need
39:50 - to do any other configuration because in
39:52 - our environment variable we've provide
39:54 - the open AI API key okay now what we're
39:57 - going to do is we're going to say tools
39:59 - are equal to this is going to be a list
40:01 - because we can provide as many tools as
40:02 - we want in this case we'll have the
40:04 - retriever tool and in a second We'll add
40:06 - another tool and we're then going to
40:08 - make our agent so we're going to say the
40:10 - agent is equal to the create tool
40:13 - calling agent a function from Lang Lang
40:15 - chain sorry we're going to pass the llm
40:18 - we're going to pass the tools and we're
40:20 - going to pass the prompt that we want to
40:22 - provide to this agent and by the way you
40:25 - can customize this prompt if you want
40:26 - I'm just knock going to show that in
40:28 - this video okay so now that we have the
40:31 - agent we actually need something that
40:32 - allows us to execute the agent now
40:35 - that's called the agent executor so
40:37 - we're going to say agent executor is
40:39 - equal to agent executor which we
40:41 - imported above we're going to provide to
40:43 - that our agent which we just created and
40:46 - our tools which will be equal to the
40:49 - tools and then we're going to say
40:51 - verbose equals true now what this means
40:54 - is we're going to get all of the details
40:56 - on the thought process process of the
40:57 - agent so we can see what it's thinking
40:59 - and how it's selecting the tools if you
41:01 - don't want to see that and you just want
41:03 - the output then you can set this
41:04 - variable to false okay so we're almost
41:07 - done at this point now what we need to
41:08 - do is just write a loop where we utilize
41:11 - this agent executor so that we can
41:13 - continue to ask it various questions and
41:15 - then you'll really see this project come
41:16 - full circle so we're going to say w like
41:20 - this and I'm going to write some fancy
41:22 - python code I'm going to say question
41:24 - colon equal to and then this is going to
41:26 - be input and we're we going to say ask a
41:29 - question about GitHub issues okay and
41:33 - we're just going to specify Q to quit
41:36 - because if you type in Q then we're
41:37 - going to quit I'm going to say while all
41:39 - of this does not equal to Q because if
41:42 - you type in Q then we're going to quit
41:44 - then what I'm going to do is say my
41:46 - result is equal to the agent executor do
41:50 - invoke and I'm going to invoke this by
41:53 - passing in a python dictionary that has
41:55 - a key input and the value of question
41:59 - I'm then going to print the result and
42:03 - the output there's a few other Keys you
42:04 - can look at here but all we really care
42:06 - about is the output let me make this a
42:08 - little bit smaller just so we can
42:09 - quickly summarize what we've done before
42:11 - we run this code and then write our
42:13 - additional tool so you can see that we
42:15 - have tools equal to retriever tool we
42:17 - create the tool calling agent you don't
42:19 - really have to worry about exactly
42:20 - what's happening here this is just a
42:22 - function from langing chain that again
42:23 - takes the llm take the tools and takes
42:25 - the prompt and creates that agent for us
42:28 - we then need an Executor so that we can
42:30 - actually utilize the agent so again pass
42:32 - the agent pass the tools specify if we
42:34 - want the detail about the thought
42:36 - process or not then we write some code
42:38 - here we're saying while question colon
42:40 - equal to now this is what's known as The
42:42 - Walrus operator in Python and allows us
42:44 - to actually Define or declare a variable
42:47 - while we have it as part of a condition
42:49 - which is what we've done here so all
42:51 - we're doing is setting the variable
42:52 - question equal to the result of this
42:54 - input and then making sure it's not
42:56 - equal to Q because if it is Q we're
42:58 - going to quit then we take this question
43:00 - we pass it to the agent and we print out
43:03 - the result okay so before we test this
43:06 - let's write that last additional tool
43:08 - it's really simple it's going to be just
43:10 - a few lines of code so let's make a new
43:12 - file here and we're going to call this
43:15 - note dopy and all I'm going to show you
43:17 - how to do here is how you wrap a python
43:20 - function that can be literally anything
43:22 - you want as a tool that you can provide
43:24 - to your agent so we're going to say from
43:26 - l L chain dot sorry underscore
43:31 - core. tools we're going to import tool
43:35 - which is a decorator we're then going to
43:37 - say Define notore tool we're going to
43:41 - pass in a parameter called note okay and
43:44 - then we're going to write a doc string
43:46 - now the doc string here acts as the
43:49 - metadata or the description of the tool
43:51 - so make sure you write a good dock
43:53 - string that describes what this function
43:55 - actually does and how acts as a tool so
43:58 - I'm going to say saves a note to a local
44:02 - file and then you need to make sure you
44:04 - specify the arguments that this function
44:06 - takes in in this case it takes in one
44:08 - argument which is a note and we're going
44:09 - to say the text note to save okay so
44:13 - this is equivalent to what we wrote
44:15 - manually for the other tool and also the
44:17 - name of the tool will be the function
44:19 - name so make sure you give it a good
44:20 - name then we're going to decorate this
44:23 - we're going to say at tool what this
44:25 - does is convert this into something that
44:26 - can passed as a lang chain tool to our
44:30 - agent so take in how easy that is you
44:32 - write the function name you write a
44:34 - little bit description of how the
44:35 - function works as well as its different
44:37 - arguments so the agent knows how to call
44:39 - it and what it is and then you just
44:40 - write the function body on what you want
44:42 - it to do so in our case we're going to
44:43 - say with open we're going to open a file
44:46 - called notes.txt we're going to open it
44:49 - in a mode which stands for append we're
44:51 - going to open it as F we're just going
44:53 - to say f. write and we're going to write
44:55 - the note Plus the back sln which just
44:58 - means we're going to move to the next
44:59 - line that's it that's our note tool and
45:01 - we could write as many tools we want
45:03 - like this that our python functions that
45:05 - the agent has access to which I just
45:07 - think is really really cool okay last
45:10 - thing let's make a new file called
45:12 - notes.txt just so that that file exists
45:15 - so that when we try to open it in a pend
45:17 - mode we don't get an error and then
45:19 - we're going to go to main.py we're going
45:20 - to import this tool we're going to add
45:22 - it to the list and we're done so let's
45:24 - go to main let's go up to the top here
45:26 - we're going to say from note import the
45:29 - note uncore tool okay and we're going to
45:33 - go to our tool list it's as easy as this
45:35 - we're just going to add it into the list
45:37 - so we're going to say notore tool and
45:41 - now we can test out our agent so in
45:43 - under an hour we've been able to build
45:45 - this which I think is pretty impressive
45:47 - let's clear and let's run our code so
45:50 - Python 3
45:51 - main.py and let's see what we get so we
45:54 - don't need to actually update the issues
45:55 - here because we updated the recently so
45:57 - I'm just going to go with no and then we
45:59 - should get a prompt popping up here
46:00 - saying hey ask us some questions okay so
46:02 - it does so I'm going to say hey can you
46:04 - answer or can you
46:08 - tell me about issues related to flashing
46:14 - messages okay so it's entering this you
46:17 - can see it's using the GitHub search
46:18 - with query flashing messages and it
46:20 - finds a bunch of different results here
46:22 - okay and then it gives me a summary of
46:23 - them I found some issues related to
46:25 - flashing messages you can see that it
46:26 - found two different documents here it
46:28 - says let me know if you need more
46:29 - information on these issues so you can
46:31 - say hey that's
46:33 - great thanks and you'll notice in this
46:36 - case it's not actually going to use any
46:37 - of our tools because it didn't need to
46:39 - so it just said you're welcome if you
46:40 - need any more help let us know that's
46:42 - the beauty of an agent it knows when to
46:44 - use the tools so now I can say something
46:46 - like hey can you save a note
46:49 - saying hello world so now what it should
46:52 - do is use the note tool which it is and
46:54 - you can see if we go now to our notes so
46:56 - let's go to notes.txt we have the note
46:59 - hello world now what we can also do is
47:01 - we can combine multiple tools together
47:03 - so we can say hey can you summarize a
47:08 - few issues from GitHub related to flask
47:13 - and then save them or save the summary
47:18 - as a new note okay so now it should use
47:21 - both of these tools so the first thing
47:22 - it's doing is querying for flask okay it
47:25 - found some issue here related to flask
47:27 - that's great that's what we're looking
47:28 - for okay now it's invoking the note tool
47:31 - and you can see that when we look here
47:32 - it says these are the issues or this is
47:35 - the issue that it found and it just
47:36 - saved a note related to it now this
47:38 - wasn't the best results in the world
47:39 - obviously we could fine-tune this and
47:41 - maybe make the prompt better but you get
47:43 - the idea the agent is working and we
47:45 - have now completed it so that's it guys
47:47 - that's how you build a complete AI agent
47:49 - that implements rag in under an hour
47:52 - that goes first and queries GitHub finds
47:54 - different issues and can really act as a
47:56 - code cing or AI assistant this is super
47:59 - cool obviously we just built something
48:01 - really simple in this video but you can
48:02 - extend this you can make it much more
48:04 - complicated and you can make it a lot
48:05 - more effective imagine if you were
48:07 - pulling GitHub issues pull requests
48:09 - maybe you had a code generation agent to
48:11 - and you combine those together you can
48:12 - make something amazing I hope you guys
48:14 - were excited about this video and
48:16 - enjoyed if you did make sure to leave a
48:18 - like subscribe to the channel big thank
48:19 - you to data stacks for sponsoring this
48:21 - and I will see you in the next one
48:25 - [Music]
48:28 - oh
48:30 - [Music]