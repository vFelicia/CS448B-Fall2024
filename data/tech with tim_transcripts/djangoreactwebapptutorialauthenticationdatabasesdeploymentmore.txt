00:00 - in this video you'll learn how to use
00:01 - Python and JavaScript to create a full
00:04 - stack web application we'll be using
00:06 - Django for the backend and react for the
00:08 - front end and we'll Implement
00:09 - authentication using JWT tokens now as a
00:13 - bonus I'm even going to show you how to
00:14 - deploy this application completely for
00:16 - free so by the time you finish this
00:18 - video you'll have an entire project
00:20 - completed it will be a great starting
00:22 - point that you can extend and build upon
00:24 - and you'll even learn about how to get a
00:25 - free deployment so you can share this
00:27 - with other people and you can see it
00:29 - working online not just on your local
00:31 - machine I'm going to go over a ton of
00:33 - stuff in this video you're going to
00:34 - learn a ton and with that said let's get
00:36 - into a quick demo so you can see what
00:38 - you're going to build so I have a quick
00:39 - demo in front of me that I'm going to
00:41 - run you through but I do want to mention
00:43 - that this video is more designed for
00:44 - intermediates this is not a beginner
00:46 - tutorial and I'm going to assume that
00:48 - you already understand both Python and
00:50 - JavaScript and have some familiarity in
00:52 - D Jango and react that said I will of
00:54 - course explain everything that I'm doing
00:56 - and I will make it as clear as possible
00:58 - but I'm not going to be going over basic
01:00 - syntax like for Loops what a variable is
01:02 - or anything that is more in the beginner
01:04 - section if you are looking for more
01:05 - beginner tutorials I have tons of them
01:07 - on my channel but this is for those of
01:09 - you that really want to level up
01:11 - understand how to use multiple languages
01:13 - and create a more advanced application
01:14 - that can actually be deployed and have
01:17 - some real world use with that said
01:19 - though let's go through a quick Demo
01:20 - First let's have a look at how this
01:21 - works so you can see that we have a
01:23 - login page we also have a register page
01:27 - if I go here so I can start by
01:29 - registering a new account so I can do
01:31 - something like tim1 123 let's set a
01:34 - password we're going to wait a second
01:36 - for it to load and then we can log into
01:38 - this account and you'll see the main
01:39 - functionality that we've implemented so
01:41 - now that we're registered let's log
01:44 - in okay wait for that to load and then
01:46 - it will bring us to a page where we'll
01:48 - be able to create some different notes
01:50 - now I know this seems really basic but I
01:52 - promise you this is what you need to
01:54 - understand to create some more advanced
01:55 - applications how you associate data with
01:58 - specific users and how you create create
02:00 - read update and delete data that's what
02:02 - I'm going to be showing you here so
02:03 - let's do new
02:05 - note test content here okay and then
02:09 - we'll submit this and the note should be
02:11 - created in just a second you'll notice
02:12 - there's a little bit of lag just because
02:14 - of how the deployment set up and if we
02:16 - wait we should see that the note appears
02:18 - here so let's refresh the page here and
02:21 - you can see that the note pops up now
02:22 - it's obviously not the prettiest thing
02:24 - in the world but that's not the point of
02:25 - this tutorial and if we want we can
02:27 - click on delete again we just have to
02:29 - wait a few seconds and the note will be
02:31 - deleted so that's it that's what I'm
02:32 - going to be showing you how to build but
02:33 - this involves building the front end
02:35 - building the back end having
02:36 - authenticated requests registering users
02:38 - creating new users signing in logging
02:41 - out there's a lot of stuff in this video
02:43 - and I promise you're going to learn a
02:45 - bunch however there is something I need
02:47 - you to know about right now which is
02:48 - your chance to win a cyber Tru or
02:51 - $100,000 cash now the way to do that is
02:54 - really just to complete this video and
02:56 - develop and deploy this application that
02:58 - we're going to build step by step on
03:00 - Coro now I've partnered with them for
03:02 - this video but they're running this wso2
03:04 - code challenge which is giving you the
03:06 - chance to win a cybertruck which is
03:08 - pretty incredible now in order to
03:10 - actually enter this challenge all you
03:11 - have to do is develop and deploy an
03:13 - application it has to have a front end
03:15 - and a back end and you have to deploy it
03:16 - to production using the Coro platform
03:19 - again I'm going to walk you through
03:20 - doing that in this video if you want to
03:22 - maximize your chances of winning there's
03:23 - some bonuses that you can get here by
03:25 - adding additional functionality like
03:27 - connecting with databases and the key
03:29 - data you'll want to know about here are
03:31 - the following obviously I'll link this
03:32 - in the description so you can check it
03:34 - out but the main date you're going to
03:35 - want to know is April 30th you want to
03:37 - finish your project before then so that
03:39 - you'll be entered into the draw it gives
03:41 - you some information on how to submit
03:43 - I'll let you guys read that from the
03:44 - link in the description and there's also
03:46 - going to be 10 other winners that will
03:48 - receive a 14-in MacBook Pro with an
03:51 - apple M3 chip so even if you don't win
03:53 - the cybertruck you have 10 other chances
03:55 - to win a MacBook Pro pretty incredible
03:57 - competition and the great thing is you
03:59 - literally just have to follow along with
04:00 - this video and you'll already have a
04:02 - project that you can use to submit
04:04 - obviously you can make it better if you
04:05 - want to but this as a bare minimum is
04:07 - all you need to be able to enter the
04:09 - competition so with that said I hope
04:11 - you're excited let's get into the code
04:12 - here and start by writing our backend so
04:15 - let's begin here by walking through a
04:16 - quick overview of what it is that we
04:18 - actually need to do now we need to start
04:21 - by building the back end the back end is
04:23 - going to be our API it's going to store
04:25 - our data and it's what's going to handle
04:27 - our different users or any other
04:29 - information we're storing related to
04:31 - them once we build the back end we need
04:34 - to build the front end the front end is
04:36 - the user facing component of the
04:38 - application which will allow people to
04:40 - interact with the API in our case to
04:43 - make new nodes to sign in to sign out
04:46 - Etc once we do that we're then going to
04:48 - deploy a database and we're going to
04:50 - connect the database to our backend so
04:52 - we have something that's a little bit
04:53 - more robust and that's stored in the
04:55 - cloud that means we could access our
04:57 - database from other sources and that's
04:59 - typic best practice after that we're
05:02 - actually going to deploy the back end
05:04 - then we're going to deploy the front end
05:06 - and we're going to connect both of them
05:07 - together but first we're going to begin
05:10 - with our backend so what we want to do
05:12 - here is open up a directory in Visual
05:14 - Studio code or any other code editor you
05:16 - want to use in this case I've just
05:18 - opened one called D Jango react tutorial
05:20 - it's on my desktop you can store it
05:22 - anywhere you want so open up that
05:24 - directory and then change into that
05:26 - directory in your terminal and the first
05:28 - thing we're going to do here is create a
05:30 - virtual environment to install our
05:31 - various python packages so to do that
05:34 - the command is going to be Python
05:36 - 3-m venv and then EnV and if you are on
05:40 - Windows the command is going to be
05:42 - python so you're just going to exclude
05:43 - the three so we're going to run that
05:45 - it's going to create a new virtual
05:47 - environment directory for us what we're
05:49 - going to do now is activate that virtual
05:51 - environment so to do that we're going to
05:52 - type Source then this is going to be EnV
05:55 - SL
05:57 - bin slash active AC at and if the
06:00 - activation is correct you should see a
06:02 - prefix before your terminal line now if
06:05 - you're on Windows the command to
06:06 - activate is a little bit different it
06:08 - should be EnV SL scripts SL activate
06:13 - dobat if that doesn't work you'll need
06:15 - to look up the specific command for
06:17 - whatever shell you're using powers shell
06:19 - command prompt Etc because it is a
06:21 - little bit different okay now that the
06:24 - virtual environment is activated what
06:26 - we're going to do is install all of the
06:27 - dependencies for this project in inside
06:29 - of here now to do that we're actually
06:31 - going to create a new file here called
06:34 - requirements.txt and we're going to
06:37 - paste all of the different requirements
06:38 - we need so all of the Python packages
06:40 - directly inside of here so what we're
06:43 - going to do is go to a link in the
06:44 - description I'll leave this link down
06:46 - below it's going to bring you to a
06:47 - GitHub repository that looks something
06:50 - like this now this GitHub repo has all
06:52 - of the code you need for the entire
06:54 - project so if you're getting stuck come
06:56 - here you can look at it it has all of
06:58 - the different files all of the completed
07:00 - code and if I tell you to copy something
07:02 - you can find it from here now in our
07:04 - case we're just going to go into the
07:05 - backend directory and we're going to
07:06 - find requirements.txt and you'll see
07:09 - this has a list of all of the
07:11 - requirements that we need so what I'm
07:13 - going to do is just copy these and I'm
07:15 - going to go back and I'm going to paste
07:16 - it inside of my requirements.txt because
07:19 - we're going to use this file to have all
07:21 - of the requirements we need and to
07:22 - install all of them in our environment
07:25 - now notice we need D Jango D Jango cores
07:28 - headers this allows us to fix that cross
07:31 - origin request issue that you've
07:32 - probably seen in your terminal before if
07:35 - you haven't seen that don't worry about
07:36 - it but we do need this we then need
07:38 - Jango rest framework D Jango rest
07:40 - framework simple JWT for handling our
07:42 - JWT authentication then a few other
07:45 - dependencies we need in here as well you
07:46 - don't need to worry about all of them
07:48 - this one here is for working with a
07:49 - postris SQL database which we'll be
07:51 - doing later and then python. EnV for
07:54 - loading in some environment variables
07:56 - again don't stress too much about what
07:57 - these are but we do need to install them
07:59 - to do that we're going to type pip
08:01 - install dasr and then requirements.txt
08:04 - make sure that's in the virtual
08:06 - environment that you activated so you
08:08 - see this prefix here when you hit enter
08:11 - it should install all of those different
08:12 - dependencies for you and then we'll be
08:15 - good to go okay so now that we've done
08:17 - that what we're going to do is create a
08:19 - new D Jango project to make a new Django
08:21 - project we're going to type
08:23 - django-admin and then start project and
08:26 - then we're going to give it a name in
08:27 - this case we'll call it backend now I
08:30 - recommend you go with the same names as
08:31 - me and this should make a new directory
08:33 - for you we're now going to change into
08:36 - the backend directory and we're going to
08:37 - make a new D Jango app now apps are
08:40 - where we can actually write our own
08:42 - custom views and custom code you'll
08:44 - notice here if you look in the backend
08:45 - directory we have another directory
08:47 - named the same thing this is kind of the
08:50 - main directory where we have some
08:51 - settings we link different applications
08:54 - but this isn't where we write a lot of
08:55 - custom Django code where we write our
08:58 - custom Django code is in an app and we
09:00 - can have multiple different apps for
09:02 - different types of things we're doing to
09:04 - organize logic out maybe we have an app
09:06 - for authentication for a certain
09:08 - component of our application in this
09:10 - case we just need a single app so what
09:12 - we're going to do is type Python
09:15 - manage.py and then this is going to be
09:18 - start app and we're going to call this
09:21 - API okay so that will make a new
09:23 - directory for us called API now that
09:26 - we've done that what we're going to do
09:28 - is we're going to go into back end and
09:30 - we're going to go into
09:31 - settings.py now inside of here I'm going
09:33 - to put a bunch of settings that we need
09:35 - to write it's very important that you
09:38 - watch this very carefully and do exactly
09:40 - what I do if you miss even the smallest
09:42 - thing it will mess up your project so
09:44 - just be very careful here going through
09:46 - and following with what I show you and
09:48 - if for some reason you're getting some
09:49 - errors you can just copy the settings.py
09:51 - file from the GitHub repository okay so
09:54 - we're going to start right from the very
09:56 - top and we're going to import something
09:58 - that we need we're going to say from
09:59 - date time import the time Delta we're
10:04 - then going to say from. EnV import load.
10:09 - EnV and we're going to import
10:11 - OS then we're going to call the function
10:14 - load. EnV now you'll see why we need
10:17 - these Imports in a second but what this
10:18 - one will do here is load an environment
10:21 - variable uh file for our story so we can
10:23 - use that for having credentials for our
10:25 - database and other things that we need
10:27 - we're then going to scroll down and
10:29 - we're going to go to where it says
10:29 - alloud host now for alloud host we're
10:32 - going to put an asterisk inside of a
10:34 - string and this will allow any different
10:36 - host to host our Django application now
10:39 - the reason we do this is just so we
10:40 - don't get an error later on when we
10:42 - deploy this application and it's running
10:44 - on some host that it's not aware of okay
10:46 - so we're going to put alloud host here
10:48 - and what I'm going to do now is copy in
10:50 - some configuration that we need now this
10:52 - is related to our JWT tokens which we're
10:54 - going to talk about in a second so I'm
10:56 - going to paste these in and you'll see
10:58 - that we have rest framework and simple
11:01 - JWT now if you don't want to write this
11:03 - yourself you can just again go copy it
11:05 - from the settings.py file in the GitHub
11:07 - repository but what we're specifying
11:09 - here is the default authentication
11:11 - classes and the default permission
11:13 - classes now we need these when we're
11:15 - working with our JWT tokens I don't need
11:18 - to get into it too much but you just
11:20 - need to specify this configuration for
11:21 - the JWT tokens to work properly next
11:25 - we're going to specify the lifetime for
11:27 - our JWT tokens so the access token which
11:30 - is what we'll use to actually access
11:32 - different Roots will expire in 30
11:34 - minutes you can change that if you want
11:36 - and the refresh token will expire in one
11:38 - day the refresh token is something we
11:40 - can use to get a new access token so
11:43 - your refresh token should always have a
11:44 - larger expiration date than the access
11:47 - token okay now that we have that we're
11:49 - going to move down into installed apps
11:51 - now in installed apps we're going to add
11:53 - API which is the name of the application
11:55 - that we added here so the one that we
11:57 - created that's what you need to add then
11:59 - we're going to add restore framework
12:03 - again make sure you spell this exactly
12:04 - as I have here and then we are going to
12:07 - add the cores headers now what we're
12:11 - going to do for the rest of the settings
12:12 - or at least a lot of the other ones you
12:14 - see is enable cores or add some
12:17 - configuration so that cores is not an
12:19 - issue for us cores is a problem when you
12:21 - have a different origin trying to hit
12:24 - this back end so you've probably seen
12:26 - this before if you've worked with any
12:27 - kind of front end and back end it says
12:29 - there's some ches issue and you can't
12:31 - make a request that's what I'm just kind
12:33 - of enabling here or I'm fixing for us
12:35 - preemptively so we don't get that issue
12:36 - later on okay so we're going to add
12:38 - cores headers we're then going to go
12:40 - into middleware and we're going to add a
12:43 - middleware for Cores now I'm just going
12:45 - to copy in the middleware so I don't
12:46 - mess it up so it's going to look like
12:48 - this it's going to be cores headers do
12:51 - middleware do cores middleware with the
12:54 - Correct capitalization okay and then
12:57 - Simply Save the file
12:59 - and we'll keep moving down now as we
13:02 - move down what we are going to go down
13:04 - to is all the way at the bottom and all
13:08 - the way at the bottom we're going to
13:09 - paste in two variables here we're going
13:11 - to write them out I'm going to say
13:12 - corescore allow underscore allcore
13:16 - Origins is going to be equal to true I'm
13:19 - then going to say
13:21 - corescore allow uncore
13:26 - credentials is equal to true now
13:29 - typically if I could uh disable my cap
13:32 - blocks here sorry typically you would
13:34 - actually just allow a specific origin
13:37 - not all of them but in our case all of
13:40 - our Origins will be slightly different
13:41 - based on how we do the deployment so I'm
13:44 - just enabling all of the different
13:45 - Origins to work here so that you don't
13:47 - get any issue and you can proceed with
13:49 - the tutorial later if you wanted to make
13:51 - this more secure there's some changes
13:52 - you could make inside of the settings
13:54 - but for now this will just make sure you
13:56 - don't hit any roadblocks which is my
13:57 - main goal right now so that should be
13:59 - all we need to do for the settings what
14:02 - I'm going to do is I'm going to take my
14:03 - requirements.txt file now and I'm going
14:05 - to place that inside of the backend
14:07 - directory and just leave the environment
14:10 - variable or the environment uh python
14:12 - virtual environment sorry outside of
14:14 - this directory okay so we have our
14:17 - backend directory we've messed with the
14:19 - settings what I want to do now is
14:21 - quickly explain to you how JWT tokens
14:24 - work and then we'll start implementing
14:26 - them here in the rest framework which is
14:28 - the first thing we need to do okay so
14:30 - what is a JWT token we'll actually have
14:33 - an entire video on this so I'll link it
14:35 - here in case you want to watch it but
14:37 - this stands for Json web tokens now the
14:40 - Json web token will act as our
14:43 - permissions or our authentication every
14:46 - time we access a website the idea is we
14:49 - have a front end and the front end is
14:50 - separate from our backend so every time
14:53 - we make a request to the back end the
14:56 - backend needs to know who we are and
14:58 - what we have permiss misss to do so what
15:00 - we'll do is we'll include a token along
15:03 - with our request to the back end and
15:05 - that token can be decoded and understood
15:09 - to represent a certain set of
15:10 - permissions so for example I may sign in
15:13 - as my user Tim that user will be granted
15:16 - a token and then that token will be used
15:18 - with all future requests to tell the
15:21 - backend who's actually interacting with
15:23 - it and what permissions they have now
15:25 - fortunately for us a lot of this
15:27 - difficult logic we don't need to write
15:28 - our s it will already be handled by D
15:30 - Jango but what I want you to understand
15:33 - is that the basic flow goes like this we
15:35 - have some front end and the front end is
15:37 - communicating with the back end it's
15:39 - doing that through a request it will
15:41 - send a request to the back end and then
15:44 - we will receive a response from the back
15:46 - end so let's say we first visit our
15:48 - front end the first thing that we'll
15:50 - need to do is we'll need to get access
15:52 - to a JWT token so we're able to actually
15:55 - interact with the back end and perform
15:57 - some operations now in order order to do
15:59 - that what we will do is we will pass
16:02 - some credentials to our front end so
16:04 - maybe a username or a password or
16:05 - something along those lines the front
16:07 - end will then take those credentials and
16:09 - send it to the back end and it will ask
16:12 - the back end it'll say hey look at these
16:14 - credentials and grant me a token based
16:16 - on these credentials so assuming the
16:18 - username and the password is correct
16:20 - then we will be granted two tokens an
16:23 - access token and a refresh token the
16:26 - access token is what we'll use with all
16:27 - of our requests and the refresh token is
16:29 - what we'll use to refresh the access
16:31 - token now what our front end will do at
16:33 - that time is it will store both the
16:35 - access token and the refresh token now
16:38 - it will store them so it can continue to
16:40 - use them with future requests and we
16:42 - don't have to constantly sign into the
16:44 - application now let's say that we are
16:47 - using this access token and all of a
16:49 - sudden it expires maybe it's been 30
16:51 - minutes and the token is no longer valid
16:53 - well what the front end will do is it
16:55 - will simply submit the refresh token to
16:57 - a specific route on the back back end
16:59 - and if that refresh token is valid a new
17:02 - access token will be sent back to us
17:04 - we'll store that token and we'll
17:05 - continue using that now the reason we do
17:08 - that is because if an access token were
17:10 - to be leaked we want that access token
17:12 - to expire in a certain amount of time so
17:14 - it can't be used permanently and give
17:16 - someone else access to our account so
17:18 - the concept is we're going to expire the
17:20 - token relatively quickly and we can keep
17:23 - refreshing it and then after our refresh
17:25 - token expires we need to actually sign
17:27 - back into the website alt together to
17:29 - get a new set of refresh and access
17:31 - tokens there's obviously more to this
17:33 - but that's the basic idea behind JWT
17:36 - token authentication and that's what
17:37 - we're going to implement here you'll
17:39 - learn more about it as we go through
17:41 - this example so what we need to do in
17:43 - order to actually Grant an access token
17:46 - is we need to have a set of credentials
17:48 - so the first thing we need to do is
17:49 - figure out a way to create a new user
17:52 - once we can create a new user we can
17:54 - then store their username and their
17:55 - password and we can use their
17:57 - credentials so their username and their
17:58 - their password to log in and access the
18:01 - access token for that user so we're
18:03 - going to go into our API view here and
18:06 - we're going to create a file called
18:09 - serializers if we spell this correctly
18:12 - dop now inside serializers we're going
18:15 - to import a few things we're going to
18:16 - say from Jango do contrib doo do and
18:21 - this is going to be models import the
18:25 - user model so let's Spell import
18:27 - correctly we're then going to say from
18:30 - restore framework import serializers let
18:34 - me zoom in a little bit so we can read
18:36 - this better and what we're going to do
18:38 - now is create something known as a
18:39 - serializer now what Jango does is it
18:42 - uses something known as an OM an omm is
18:45 - an object relational mapping what this
18:48 - does is it Maps python objects to the
18:52 - corresponding code that needs to be
18:53 - executed to make a change in the
18:55 - database so the idea is from the
18:57 - developer perspective we can just write
18:59 - normal python code and D Jango in the
19:02 - back end will automatically handle all
19:04 - of the database operations that need to
19:06 - be performed now where a serializer
19:08 - comes in is that with our API we're
19:11 - going to use something known as Json now
19:14 - Json is Javascript object notation and
19:17 - this is the standard format for
19:18 - communicating with web applications so
19:21 - from our API we're going to be accepting
19:24 - Json data that contains things like the
19:26 - username and the password for a new user
19:28 - we want to make we'll also be returning
19:31 - Json data with information about the
19:34 - response that this API is giving to
19:36 - whoever made a request so what we need
19:38 - to do is create a serializer which is
19:41 - something that can take this python
19:43 - object and convert it into Json data
19:46 - that can be used in the communication
19:48 - with other applications right so it'll
19:50 - allow us to take in some Json data and
19:52 - convert that into the python equivalent
19:54 - code and then vice versa have some
19:56 - python code and convert that into the
19:58 - Json equivalent format so what we're
20:00 - going to do is say class user
20:03 - serializer and this is going to inherit
20:06 - from the serializers do the model
20:09 - serializer now inside of here we're
20:10 - going to say class meta and we're going
20:13 - to specify the model that we want to
20:14 - serialize as the user model the user
20:17 - model is built into D Jango and it well
20:19 - represents a user right within Jango
20:22 - then we're going to say fields are equal
20:24 - to
20:25 - ID
20:27 - username and password now these are all
20:31 - the fields that we want to serialize
20:32 - when we are accepting a new user and
20:35 - when we are returning a new user
20:36 - remember the serializer is used in two
20:38 - different places next we're going to
20:41 - specify extraor quars and this is going
20:44 - to be equal to password colon and then
20:48 - we're going to specify write only equal
20:52 - to true now what this does here if we
20:56 - spell true correctly is it tells D Jango
20:59 - that we want to accept a password when
21:02 - we're creating a new user but we don't
21:04 - want to return the password when we are
21:06 - giving information about a user so that
21:08 - when we specify this as right only it
21:10 - means no one can read what the password
21:12 - is which is intentional okay so now
21:15 - we're going to have another class or
21:17 - sorry not another class we're going to
21:18 - make a function here called create and
21:20 - we're going to take in self and
21:22 - validated uncore data and inside of here
21:27 - we're going to say user is equal to
21:30 - user. objects. creatore user and we're
21:34 - going to pass to this Asis Asis
21:37 - validated data we're then going to
21:39 - return the user now all this is doing is
21:42 - implementing a method that will be
21:44 - called when we want to create a new
21:45 - version of this user in this case to
21:47 - create a new version of the user what
21:49 - we're going to do is we're going to
21:50 - accept the validated data this is data
21:52 - that we have already passed all of the
21:54 - checks that the serializer does for us
21:56 - where it looks for a valid username and
21:58 - looks for a valid password really what
22:00 - will happen is the serializer will look
22:02 - at this model it will look at all of the
22:04 - fields on that model and the ones that
22:06 - we've specified here it will make sure
22:09 - that they are valid and if they're valid
22:11 - it will pass the data here once the data
22:13 - has been passed here it's up to us to
22:15 - actually create the new user to do that
22:17 - we can say the user is equal to user.
22:19 - object.create user and then we pass all
22:22 - of the data what we're doing here is
22:24 - just splitting up the keyword arguments
22:26 - and passing them in as such from a
22:29 - dictionary now you don't need to really
22:31 - understand how that works but that's
22:32 - what's happening and then we return the
22:34 - user okay now that we've done that what
22:37 - we're going to do is go to views.py now
22:39 - inside of views.py we're going to write
22:41 - a simple view that allows us to create a
22:43 - new user so we have the serializer but
22:45 - we still need the view or the path to
22:47 - make this user so we're going to say
22:50 - from Django do contrib do
22:53 - off. models import the user again okay
22:59 - we're then going to say from the rest
23:01 - framework import and this is going to be
23:04 - generics we're then going to say from do
23:07 - serializers the file we just made import
23:11 - the user serializer and then we're going
23:14 - to say from rest framework undor simple
23:18 - J or sorry that's actually incorrect
23:20 - from rest framework. permissions
23:23 - apologies import and this is going to be
23:25 - is authenticated and allow
23:29 - now what we're going to do is make the
23:31 - class-based view that will allow us to
23:33 - implement creating a new user or kind of
23:35 - like a registration form so we're going
23:37 - to say class and this is going to be
23:39 - create userv View and then what we're
23:42 - going to do is inherit from the generics
23:44 - do create API view now this is a generic
23:47 - view that's built into D Jango that will
23:49 - automatically handle creating a new user
23:52 - or creating a new object for us now in
23:55 - order for this to work we need to
23:56 - specify a few values so we're going to
23:57 - say the query reset is equal to user
24:00 - doobs doall we're then going to pass the
24:03 - serializer class which is equal to our
24:06 - user and we're going to say the
24:07 - permission classes are equal to allow
24:11 - any what we're doing here is we're
24:13 - specifying okay here's a list of all of
24:15 - the different objects that we're going
24:17 - to be looking at when we're creating a
24:19 - new one to make sure we don't create a
24:21 - user that already exists this is the
24:23 - serializer class which tells this view
24:26 - what kind of data we need to accept to
24:28 - make a new user so in this case a
24:29 - username and a password and then the
24:32 - permission class specifies who can
24:34 - actually call this in this case we're
24:36 - going to allow anyone even if they're
24:37 - not authenticated to use this view to
24:40 - create a new user okay so that's it for
24:43 - the view now that we've done that we're
24:45 - going to go to urls.py within this
24:48 - backend directory so notice we moved
24:50 - outside of the app directory and we're
24:51 - in that main backend directory inside of
24:54 - here I'm just going to remove all of the
24:56 - comments so it's a little bit cleaner
24:58 - and what we're going to do is configure
24:59 - all of our different URLs so that we
25:02 - kind of link them up and we can go to
25:04 - the correct routs now we need to import
25:06 - a few things here so we're going to say
25:08 - from
25:09 - api. views import and this is going to
25:12 - be the create sorry this needs to be
25:15 - views we're going to say create user
25:17 - view so this is the view we just wrote
25:20 - inside of here we're just importing it
25:21 - over here we're then going to say from
25:24 - the rest framework this time it's going
25:26 - to be simple JWT do views we're going to
25:30 - import the token obtained pair viiew and
25:35 - the token refresh view now let me just
25:39 - save this and format it and let's make
25:41 - this bit smaller so we can read it now
25:43 - what these views are are pre-built views
25:46 - that allow us to obtain our access and
25:49 - refresh tokens and to refresh the token
25:52 - okay I know it seems a little bit
25:54 - strange but they're already built for us
25:56 - and now that we've implemented what we
25:58 - need to do which is creating a new user
26:00 - once the user is created we can use
26:02 - these pre-built views to obtain the
26:04 - token for that user and to effectively
26:06 - sign them in now we're going to write a
26:09 - few paths here these paths are URLs that
26:12 - we can go to uh that will call a
26:14 - specific function or do some type of
26:16 - operation so the first one we're going
26:18 - to have is API SL userregister and make
26:22 - sure you always include the trailing
26:24 - slash here now this is going to call the
26:26 - create userview do asore View and we're
26:30 - going to give this a name and we'll say
26:32 - this is
26:33 - register so that means when we go to
26:35 - this route right here it's going to call
26:37 - that view that we just created and it's
26:39 - going to allow us to make a new user we
26:42 - then are going to implement the view for
26:43 - actually getting our token now that's
26:45 - already built for us but we just need to
26:47 - link it up so we're going to say API SL
26:50 - token slash and then this is going to be
26:52 - the token obtain pairview do
26:56 - ascore view sorry and then name name is
26:58 - equal to and we'll say getor token you
27:01 - can name these whatever you want it
27:02 - doesn't really matter what you have here
27:04 - next we're going to have the view for
27:05 - refreshing the token so we're going to
27:07 - say API SL token SL refresh and this is
27:11 - going to be the token refresh view. as
27:14 - View and then the name will just be
27:16 - equal to
27:17 - refresh okay we're almost done we're now
27:20 - going to do another path and this path
27:22 - is going to be the API Das off view okay
27:26 - make sure you have your trailing SL
27:28 - and this is going to Simply include all
27:31 - of the URLs from the
27:35 - restore framework. URLs and we need to
27:39 - just import the include function from
27:42 - here where it says Django
27:44 - dols okay so those are all the URLs we
27:46 - currently need what we've done is we've
27:48 - linked our register view we've linked
27:50 - our token obtain pair viw and our token
27:53 - refresh view we've also linked all of
27:55 - the pre-built uh URLs that we need from
27:58 - the rest framework you don't have to
27:59 - worry too much about those okay so at
28:02 - this point we have mostly everything
28:04 - done to actually start working with this
28:06 - uh and seeing how it works so what we're
28:08 - going to do is we're going to bring up
28:10 - our terminal let's clear all of this and
28:13 - we're going to start by making some
28:14 - migrations on our database now whenever
28:17 - you start a new jangle project or you
28:18 - make any significant changes that
28:20 - involve the data model what you need to
28:23 - do is run some migrations so the first
28:25 - thing you'll do is type python manage.py
28:29 - and then this is going to be make
28:31 - migrations now what make migrations will
28:34 - do is it will create the file that
28:36 - specifies the M migrations that need to
28:38 - be performed so that's what we're going
28:40 - to do to start and it probably will say
28:43 - that we don't have any migrations but
28:44 - let's see what it says here if it runs
28:46 - so yeah it says no changes detected so
28:48 - that's fine but I just want to show you
28:49 - that this is the process now once you've
28:51 - made the migrations you need to actually
28:54 - migrate so it's kind of two steps you're
28:56 - making the migrations and then you're
28:57 - actually apply Ling the migrations and
28:59 - the way you apply them is by using the
29:01 - migrate command so we're going to go
29:03 - ahead and hit enter and you'll notice
29:04 - that it will migrate and make all of
29:06 - these changes and really what this will
29:08 - do is provision the database so that it
29:10 - has the correct tables and everything
29:12 - set up so whenever you connect to a new
29:14 - database you want to do those same steps
29:15 - again so you're provisioning the new
29:17 - database so now that that's set up we
29:19 - can run our application now to run our
29:21 - application we'll type Python manage.py
29:24 - and then run server Okay so let's do
29:28 - that and you should see that the server
29:30 - starts running and it tells you the URL
29:31 - it's running on so what we can do is
29:33 - open that up I'm just going to bring it
29:35 - over to my other screen here and you'll
29:38 - notice that right away we get this kind
29:40 - of 404 not found it's just because we
29:41 - haven't gone to any of the roots that
29:43 - we've defined so what we can do now is
29:45 - Define or go to those roots so we're
29:47 - going to go to the off or sorry the API
29:51 - SL
29:52 - userregister
29:55 - root and when we do that what is the
29:58 - issue here did I spell something
30:00 - correctly uh user got unexpected keyword
30:03 - arguments context all right so I've
30:06 - found the error here kind of a silly one
30:08 - under my serializer class here for my
30:10 - create user view this should say user
30:13 - serializer not user so let's save that
30:17 - now and go back to where we were before
30:19 - and refresh and notice now it brings us
30:21 - to the correct page okay so let's look
30:24 - at this going to go into HTML form and
30:27 - what I can do is pass a username and
30:30 - password and create a new user so let's
30:33 - begin doing that and then we can see how
30:35 - we sign in as that user and get the
30:36 - access token all right so I just created
30:38 - a new user here and what we'll do once
30:41 - the user is created is we'll go to the
30:43 - rout that is API token now it's going to
30:47 - bring us to this page where will ask us
30:49 - to pass our credentials and once we pass
30:51 - our credentials it will give us our
30:53 - access token so let me type in my
30:55 - credentials and then let's get the token
30:57 - okay so I'm going to to go ahead and hit
30:58 - on post here and you'll notice now that
31:01 - what it gives me is a refresh token and
31:03 - an access token now this is what our
31:05 - front end would store and then it would
31:08 - use this access token with every request
31:10 - that it sends in order to actually
31:13 - access the different protected Roots so
31:15 - that's the idea here but I'll show you
31:17 - that if I copy this access token and I
31:20 - now go to the refresh route you'll see
31:23 - that what I can do is pass my refresh
31:25 - token and post and when I do this uh oh
31:28 - it says token is wrong type maybe it's
31:31 - because it started with the space or
31:33 - something I'm not sure exactly why we're
31:34 - getting that issue with the refresh
31:36 - token maybe it's just based on how I'm
31:38 - calling it here but idea is that this
31:40 - should have given us a new access token
31:42 - uh not this issue all right so I just
31:44 - went back and I realized I had copied
31:46 - the wrong token so now when I paste in
31:48 - the refresh token it gives me a new
31:50 - access token and all is working okay so
31:53 - those are the main routes right we
31:55 - wanted to have the ability to get the
31:57 - tokens to refresh the token to create a
31:59 - new user now that we have these written
32:02 - what we want to do is start writing some
32:03 - roots for our authenticated users so now
32:07 - that we have the ability to authenticate
32:08 - them using these tokens we want to give
32:11 - them the ability to for example create a
32:13 - new note delete note something along
32:15 - those lines I know it seems simple but
32:17 - trust me this is what we need to
32:19 - understand so we know how to connect
32:21 - data to authenticated users so let's go
32:23 - back to vs code and let's start writing
32:25 - what we need for creating different
32:27 - notes so I'm going to clear this here
32:29 - and shut down the server and what we're
32:31 - going to do now is we're going to make a
32:33 - new model inside of API models.py now
32:37 - this model will be for our note so let's
32:39 - write that out so inside here what I'm
32:41 - going to do is I'm going to say from
32:43 - Django do contrib
32:46 - doo. models I'm going to import the user
32:49 - model I'm now going to make a new class
32:52 - called notes we can zoom in on this a
32:55 - little bit and this is going to be a
32:57 - model so we're going to say that this is
32:59 - models. model now as I said before Jango
33:03 - uses an OM an object relational mapping
33:06 - so what I'll do is I'll write out the
33:08 - model definition in Python and then jeno
33:10 - can automatically handle converting this
33:13 - into the correct database code so what
33:15 - we do here inside of models is we Define
33:17 - the python version of our models which
33:20 - specify the type of fields we want to
33:21 - store on this model or in this data or
33:24 - table whatever you want to refer to it
33:26 - as and then Jango automatically map it
33:28 - for us and add the corresponding table
33:31 - rows Etc in our database so we're going
33:33 - to have a note and for our note we want
33:35 - the following we want to have a title
33:38 - and the title is going to be models.
33:41 - character field and we're going to
33:42 - specify the max length of the title
33:45 - which is equal to 100 next we're going
33:48 - to have some content and the content
33:50 - will be equal to a models. text field
33:53 - and we're not going to specify any
33:54 - minimum or maximum length we'll just let
33:56 - them put as much text as they want next
33:59 - we're going to have a created at field
34:01 - and created at is going to be models.
34:03 - time field and inside here we're going
34:06 - to have Auto uncore nowor add equal to
34:11 - True next we're going to have our author
34:14 - and the author is going to be the
34:16 - models. foreign key we'll talk about
34:19 - this in a second and this is going to
34:21 - reference our user and we're going to
34:23 - have
34:24 - undelete equal to models. Cascade
34:29 - in the related name equal to notes okay
34:35 - lastly let's zoom out so we can read all
34:37 - of this we're going to Define anore
34:40 - uncore string uncore uncore method and
34:42 - we're simply going to return the self.
34:45 - tile okay let's quickly talk about what
34:47 - we just did here specifically with the
34:49 - forign key well first we added the title
34:53 - maximum length of 100 content is just a
34:55 - text field that makes sense created at
34:57 - models. dat Time Field when we add this
35:00 - argument right here it tells it that we
35:02 - don't want to be passing this we want it
35:03 - to just automatically populate whenever
35:06 - we make a new version or a new instance
35:08 - of this note then we have our author now
35:11 - the author is specifying who made this
35:13 - note whenever we have that well we can
35:15 - use something known as a foreign key now
35:17 - a foreign key can link something like a
35:19 - user because that's what it is in this
35:21 - case with some data that belongs to that
35:24 - user now we can use foreign keys in a
35:26 - lot of different sit situations but we
35:28 - want to link different pieces of data
35:30 - together in this case I want each user
35:32 - to have a collection of notes and I want
35:35 - there to be one user that can
35:36 - potentially have many different notes
35:39 - now this is known as a on to many
35:41 - relationship so what I do is for my
35:44 - author I say that this is going to be a
35:45 - model Stop forign Key when we specify
35:47 - forign key that's indicating that we're
35:49 - going to be linking with some other data
35:51 - source in this case it's the user then
35:54 - we specify the on delete now what on
35:56 - delete means is if I were to delete this
35:58 - user so the thing that's being
36:00 - referenced what should we do well
36:02 - models. Cascade simply says that we
36:04 - should also delete all of the notes that
36:07 - this user has that's all it's doing then
36:09 - as the related name this tells us what
36:12 - field name we want to put on the user
36:15 - that references all of its notes so from
36:18 - my user object I'll now be able to
36:20 - actually access the notes and notes will
36:23 - give me all of these note objects that
36:26 - the user has created okay so that's how
36:28 - we link data with a user we use a
36:31 - foreign key there's a lot more about
36:32 - foreign keys that you can learn I
36:34 - actually have all kinds of other Jango
36:35 - videos on my channel that go through
36:37 - foreign keys and more advanced
36:38 - relationships but for now we're just
36:40 - going to stick with this okay so now
36:42 - that we have our model created we're
36:43 - going to make a serializer for this
36:45 - model because remember this is an API
36:47 - and we need to be able to convert this
36:49 - into Json data so that we can receive it
36:52 - and we can return it so we're going to
36:53 - go up to the top here and we're going to
36:55 - say from models import the note then
36:59 - we're going to make our serializer this
37:01 - is going to be the note
37:05 - serializer okay if we could spell this
37:08 - correctly and this is going to be
37:09 - serializers doth model serializer we're
37:14 - then going to specify our meta class
37:16 - here and inside here we're going to say
37:18 - the model is equal to the note and then
37:21 - we're going to say our fields are equal
37:24 - to
37:25 - ID title
37:29 - content and then created at and author
37:35 - and for our extraor quarks we're going
37:39 - to pass author okay so let's specify
37:43 - this and this is going to say read
37:47 - only true now what that tells us is
37:50 - actually the opposite of what we did
37:52 - here for our user serializer which says
37:54 - hey we should be able to read who the
37:56 - author is but we shouldn't be able to
37:58 - write who the author is the reason we're
38:01 - doing that is because we'll manually set
38:03 - who the author is based on who creates
38:05 - this note we don't want someone to be
38:07 - able to tell us who the author is so if
38:10 - I'm signed in and I'm authenticated and
38:11 - I make the note well then I become the
38:13 - author so we're specifying it as read
38:15 - only which means we can't write it we
38:16 - can just read what it is okay so I know
38:19 - it's a bit weird but we want to make
38:20 - sure that for certain fields we do that
38:23 - so that we can see them but we can't set
38:25 - them or we can set them but we can't see
38:26 - them and in this case author is one of
38:28 - those where we want that to be set by
38:29 - the back end not by someone just
38:31 - deciding who the author should be okay
38:34 - so now that we have our serializer and
38:36 - our model we're going to go into views
38:38 - and we're going to make some views for
38:40 - creating a note and for deleting a note
38:42 - now first let's import the note so to do
38:45 - that we're going to say from Models
38:48 - import note now we're also going to
38:50 - import the note serializer in the same
38:53 - line here as our user
38:55 - serializer now let's go above and let's
38:58 - make a view for creating a new note now
39:02 - to do that we'll say class note list
39:06 - create okay and this is going to be
39:10 - generic. listc create API view what
39:13 - we're going to do in here is the
39:15 - following we're going to specify our
39:17 - serializer class which is going to be
39:19 - equal to the note
39:20 - serializer and our permission classes
39:23 - which will be equal to and this is going
39:25 - to be is authenticated now what this
39:27 - says is that you cannot call this rout
39:30 - unless you're authenticated and you pass
39:31 - a valid JWT token perfect now notice
39:35 - that we're using list create view not
39:38 - just create the reason for that is that
39:40 - this view will actually do two things it
39:42 - will list all of the notes that the user
39:44 - has created or it will create a new note
39:47 - so there's two functions here so first
39:50 - thing we're going to do is specify a
39:51 - method called get query set now that's
39:55 - not what I wanted but I want to return
39:57 - learn from here and we're going to write
39:59 - up here that our user is equal to
40:03 - self.
40:05 - request. user now this is really nice
40:08 - but in Jango if we want to get the user
40:11 - that is actually authenticated and that
40:13 - is interacting with this route all we
40:16 - have to do inside of our class based
40:18 - views is we write self. request. user
40:21 - and that's going to give us the user
40:23 - object so it says abstract base user or
40:25 - Anonymous user don't worry about that
40:26 - but it's going to give us the correct
40:27 - user because we are actually
40:29 - authenticated we can then use that user
40:31 - to filter our notes and just get any of
40:34 - the notes that were ridden by this user
40:37 - so if we wanted to get all of the notes
40:39 - we would just do note doobs doall but if
40:43 - we want to get all of the notes that are
40:45 - written by a specific user we instead
40:48 - pass filter and then we pass the author
40:51 - equal to the user now this needs to be
40:54 - the lowercase user story and what that
40:57 - does is filter by this field now we
40:59 - could filter by all kinds of other
41:00 - fields as well right like I could filter
41:02 - by the title equal to something specific
41:04 - if I wanted to do that but in this case
41:06 - we do the author filter and that
41:08 - effectively is just going to get us all
41:09 - of the notes written by this user okay
41:13 - so that's why I've written get query set
41:15 - rather than having query set specified
41:17 - here because I need access to the
41:19 - request object with specifies the user
41:22 - so that I can then filter all of the
41:24 - notes by that user this also means that
41:26 - your only able to view the notes that
41:28 - were written by you you can't view notes
41:30 - that were written by someone else okay
41:33 - next we're going to have a perform
41:36 - create and this is going to take in self
41:39 - and the serializer now this is just
41:42 - because we want to do some custom uh
41:45 - kind of configuration here when we
41:46 - create a new user so we're overriding
41:49 - the create method okay so all these
41:53 - generic views you can just leave them as
41:55 - is and as long as you specify a serial
41:57 - izer Class A permission class and a
41:59 - query set it's automatically going to
42:01 - work and it will let you create list Etc
42:04 - whatever it specifies here but if you
42:06 - want some custom functionality which we
42:08 - need you need to override specific
42:10 - methods and in this case we need to
42:12 - override the get query set and the
42:14 - perform create now how do you know that
42:16 - well you do have to reference the Django
42:18 - documentation because there's no way you
42:20 - can memorize all of this stuff and even
42:22 - myself I don't have this memorized like
42:23 - I'm looking off of some pre-made notes
42:25 - because there's no way I would memorize
42:27 - this when I was originally writing it
42:28 - out I had to go look at the python or
42:30 - sorry the Django documentation to know
42:32 - what it is I had to do here okay so what
42:35 - we're going to do is we're going to say
42:36 - if the serializer do isore valid then
42:40 - we're going to say
42:42 - serializer
42:44 - dove and we're going to pass the author
42:47 - equal to the self.
42:50 - request. user otherwise we're simply
42:54 - going to print the serializer .
42:58 - errors okay so what is this what are we
43:00 - doing here how does this work well
43:02 - serializer itself so this class when we
43:06 - pass to it different data it will tell
43:08 - us if it's valid or not now what happens
43:11 - automatically in these generic list
43:12 - views is any data that's required to
43:15 - create the note will be accepted it will
43:17 - be passed into the serializer that we've
43:20 - written here and the serializer will
43:22 - check against all of the different
43:24 - fields on the model and make sure that
43:26 - the data is accurate so we'll check that
43:28 - the title is not above the maximum
43:31 - length for example we'll check that we
43:32 - have some content that we have a date
43:35 - whatever right it'll check all the
43:36 - things that we need so what we're doing
43:38 - here is we're getting access to that
43:40 - serializer object and we need to
43:42 - manually check if it's valid so we say
43:45 - okay if this is valid if the serializer
43:47 - passed all of the checks with the data
43:49 - that was passed to create a new version
43:51 - of the note what we'll do is we'll save
43:54 - the serializer and when we save the
43:56 - serializer it will make a new version of
43:58 - the note and anything we pass here will
44:00 - be an additional field that will add
44:02 - onto that note so in this case we're
44:05 - adding the author because remember in
44:07 - the serializer we specified that the
44:09 - author was read only so it won't be
44:11 - passed into us we have to manually add
44:14 - that ourself which is what we're doing
44:16 - okay so that is how we create a note now
44:19 - let's do a view for deleting a note
44:21 - which is a little bit easier so we're
44:23 - going to say class note
44:25 - delete and this will be generics do
44:28 - destroy API view now inside here we're
44:31 - going to specify the query set and this
44:33 - will be equal to
44:35 - note
44:36 - doobs doall we're then going to say the
44:40 - serializer class is equal to the note
44:43 - serializer we're going to say the
44:45 - permission classes are equal to is
44:49 - authenticated and actually I realized
44:51 - that we don't need to specify the query
44:52 - set we're just going to go down here and
44:54 - we're going to say Define get query set
44:57 - and it's actually going to be the exact
44:58 - same as this one so we're just going to
44:59 - copy this and paste it here because
45:02 - similar to up here we want to make sure
45:04 - that you can only delete notes that you
45:06 - own so the query set of notes that we
45:08 - allowed to delete are simply ones that
45:11 - are within this filtered list so sorry
45:13 - we don't need to specify the query set
45:14 - manually we just specify the method here
45:18 - okay so works the exact same as the note
45:20 - list create but this time there's
45:21 - nothing special we need to do we just
45:23 - specify okay here are the valid notes
45:25 - that you could delete and then we'll
45:27 - what we'll actually do sorry is we'll
45:29 - specify a note we want to delete and it
45:31 - will automatically delete it for us if
45:32 - we're authenticated which is what we
45:34 - need to be so now that we have these
45:36 - views what we need to do is we need to
45:38 - set up some URLs for them but this time
45:40 - I'm going to set up the URLs in this API
45:43 - folder so I'm going to make a new file
45:44 - called urls.py and inside urls.py I'm
45:48 - going to say URL patterns is equal to an
45:51 - empty list now here we need to write the
45:53 - different URL patterns and we'll
45:55 - actually forward URLs from the main
45:57 - application to here so at the top of my
45:59 - code I'm going to say from
46:01 - Django do URLs import path I'm then
46:05 - going to say from dot import views now
46:10 - inside URL patterns I'm going to specify
46:11 - two paths the first path will be for
46:14 - viewing or creating our notes so we're
46:16 - just going to say notes slash and this
46:18 - is going to go to the Views Dot and this
46:21 - is going to be the note list
46:23 - create. as view we are then
46:27 - going to have the
46:29 - name equal to the note- list we're then
46:33 - going to have another path and inside
46:35 - this path we're going to say notes slash
46:38 - delete slash and then this is going to
46:41 - be int colon PK which stands for primary
46:44 - key and then this is going to be views.
46:47 - note delete. as View and the
46:52 - name can be delete note okay so now we
46:57 - have our uh URL story here for the notes
47:01 - okay so for creating and listing and for
47:03 - deleting now what we need to do is link
47:05 - the URLs from our main URLs file into
47:09 - this file so we're going to go to
47:10 - urls.py within our backend which is
47:12 - where we wrote the URLs before and we're
47:14 - going to make a link so that we forward
47:17 - specific URLs over to this file where
47:20 - they're then handled from this app so
47:22 - the way we do that is we specify a path
47:24 - and inside the path we're going to say
47:26 - API
47:27 - slash and then we're going to include
47:30 - and this is going to be the api. URLs
47:33 - now when we do that what we're saying is
47:35 - okay whenever we go to something that
47:36 - has API slash and it wasn't one of the
47:39 - ones above we're going to take the
47:41 - remainder of the path so what comes
47:44 - after the slash and we're going to
47:45 - forward that to this file api. URLs
47:48 - which is right here now inside of here
47:51 - we'll parse the rest of the path and if
47:53 - it matches anything here we'll handle it
47:56 - and we'll go to the views that we wrote
47:57 - within this app now you may be asking
48:00 - yourself why didn't we write the create
48:03 - user view in this same manner right like
48:06 - inside of URL patterns well we could
48:08 - have done that here inside of the app
48:10 - but I wanted to keep all of the
48:11 - different Roots related to our
48:13 - authentication and registration in the
48:15 - same place so that's why I did it the
48:17 - way that I did it here there's all
48:18 - different types of ways to link URLs but
48:20 - I wanted to kind of show you both of
48:21 - them so that's why we're doing there
48:23 - okay so that's really going to wrap up
48:25 - most the backend code but obviously want
48:26 - to check if this is working so let's go
48:28 - ahead and run our code but before we do
48:30 - that we need to make a migration to our
48:32 - database because we've made a major
48:34 - change the data model so we're going to
48:36 - say python manage.py make
48:39 - migrations okay so you can see that it
48:41 - says we've now made a new migration
48:43 - which is creating the model note we now
48:45 - need to actually migrate so let's go
48:48 - ahead and migrate and you'll see that
48:50 - this works okay now we're going to run
48:52 - our code so python manage.py run server
48:56 - and we're going to test this out so
48:58 - let's open up this
48:59 - view okay so I need to actually go over
49:02 - here and I guess we already have it open
49:04 - so let's just refresh okay continue
49:07 - that's fine and let's go and get our
49:11 - token so we're going to go to slash
49:13 - token here let me pass in some
49:15 - credentials so I get a token okay so I
49:17 - have a token I'm going to copy the
49:18 - access token I'm now going to go to
49:21 - slash API SL notes so you'll notice here
49:25 - that we're getting this error saying
49:26 - authentication credentials were not
49:28 - provided now this is actually good it
49:29 - means this is working properly and the
49:32 - reason it's working is because we didn't
49:33 - actually pass the token when we sent the
49:36 - request to this route in order to uh
49:39 - view the different notes now we're not
49:41 - going to be able to pass that token
49:42 - without doing some things that are a
49:44 - little bit more advanced so what we're
49:45 - actually going to do is just write the
49:46 - front end and you'll see in the front
49:48 - end how we pass that token and actually
49:50 - are able to create the notes for now
49:53 - just trust me this does work if you
49:55 - wanted to test it out you could remove
49:57 - the authentication so if we go here you
50:00 - could go to what is it views.py and you
50:03 - could just remove this and make it to
50:05 - allow any instead then you would be able
50:07 - to access that route the issue is though
50:10 - that you wouldn't have a user because
50:12 - you wouldn't be passing the correct
50:13 - access token so just bear with me here
50:15 - guys that's going to wrap up the back
50:17 - end now what we're going to do is go
50:18 - over and write the front end all right
50:21 - so now we are moving on and we are
50:22 - working on the front end now this is
50:24 - going to be in react so what I've done
50:26 - is a just opened up that same directory
50:28 - that we were in before but I've got into
50:30 - the base directory so I'm no longer in
50:32 - that backend uh directory now what we're
50:34 - going to do is use vit to create a new
50:36 - react project to do that I'm going to do
50:38 - npm create this is going to be
50:41 - vit at latest and then front end
50:47 - d---
50:49 - template react and this is going to
50:51 - create a front-end directory which is
50:53 - going to have react installed so let's
50:55 - go ahead and hit enter
50:57 - and that should make it for us let's go
50:59 - yes let's install that and now we need
51:01 - to install a few different packages so
51:03 - let's go to CD front end and we're going
51:05 - to install the various packages that we
51:07 - need so we're going to type npm install
51:10 - and we're going to install axios for
51:12 - using our Network requests we're going
51:14 - to install react router Dom and then
51:17 - we're going to install JWT dcode these
51:21 - are the three packages that we need here
51:22 - so let's install all three of those
51:25 - let's give those a second and once
51:26 - they're finished I'll be right back all
51:28 - right so I realized that I typed in the
51:30 - wrong thing for react router Dom so
51:33 - let's fix that I'm not sure how I made
51:34 - that mistake there uh but it says it
51:36 - can't find what is it react react Dom
51:38 - yeah it's cuz that's not a package we
51:39 - need react rotor domom so let's fix that
51:43 - and install and hopefully it we'll be
51:45 - good now okay looks like we are good to
51:47 - go so now we can go inside of our front
51:49 - end directory and we can start creating
51:51 - some different files now I'm not going
51:52 - to lie to you there is a fair amount of
51:54 - code here but as always I'm going to
51:55 - walk through it step by by step and if
51:57 - you want to copy anything you can just
51:58 - do that from the GitHub repository which
52:00 - is linked in the description okay so
52:02 - what we're going to do is go inside of
52:05 - SRC here and we're just going to start
52:07 - organizing this directory a little bit
52:09 - first of all we're going to delete these
52:10 - CSS
52:11 - files so let's get rid of those because
52:13 - we don't need them we're going to go
52:15 - into assets uh that's actually fine
52:16 - there we'll go into
52:19 - app.jsx and we'll just remove everything
52:22 - inside of the body here of this
52:24 - component and we'll get rid of this
52:27 - okay and we'll get rid of all three of
52:29 - those Imports and the import to app.css
52:33 - we're just going to import react from
52:36 - react here okay just so we don't get any
52:38 - errors all right now we'll go into main.
52:40 - jsx we're going to remove the import to
52:43 - index.css because we don't need that and
52:45 - we're going to create a few directories
52:47 - in here where we'll organize our code
52:49 - now the first directory is going to be
52:51 - Pages the next directory is going to be
52:55 - Styles and the last one is going to be
52:59 - components okay so this is where we're
53:00 - going to organize all of our different
53:02 - code now we're going to create a few
53:03 - other files here we're going to make a
53:06 - constants if we can spell this correctly
53:09 - do JS and we're going to make an
53:13 - api.js we're also going to make an
53:16 - environment variable file inside of the
53:18 - front end directory so we're going to
53:20 - type EnV like that okay so we have our
53:24 - EnV we then have our new directories
53:26 - components pages and styles we have our
53:29 - constants file and we have our api.js
53:31 - file now let's go into constants to
53:34 - start I just need to define a few
53:35 - constants that we'll use inside of API
53:38 - so let's write these constants out we're
53:39 - going to say export const and this is
53:41 - going to be accessor token and this is
53:45 - just simply going to be equal to access
53:48 - and then we're going to say export const
53:50 - and this is going to be refresh unor
53:53 - token and this is going to be equal to
53:56 - refresh now the reason why I'm putting
53:58 - these here is that we're going to use
53:59 - local storage to store the access token
54:02 - and the refresh token in our browser and
54:04 - I want to have a key that I can use to
54:06 - access in my local storage and that's
54:08 - what this key is going to be so I'm
54:10 - going to use these constants here to
54:12 - access the access token and the refresh
54:14 - token okay so now that we have that
54:16 - we're going to go inside of api.js I
54:18 - just want to hook up the more complex
54:20 - stuff to start and then we can start
54:21 - writing all of the components now the
54:23 - idea in this api.js file is that what
54:26 - I'm going to do is I'm going to write
54:27 - something known as an Interceptor now an
54:30 - Interceptor will essentially intercept
54:32 - any request that we're going to send and
54:34 - it will automatically add the correct
54:36 - headers so that we don't need to
54:38 - manually write it a bunch of different
54:39 - times repetitively in our code now we're
54:42 - going to be using something known as
54:43 - axios axios is a really clean way to
54:46 - send Network requests that's pretty easy
54:47 - to use uh so we're going to set up
54:49 - something called an axios Interceptor
54:51 - where anytime we send a request it's
54:53 - going to check if we have an access
54:54 - token and if we do it will auto
54:56 - automatically added to that request so
54:58 - we don't need to think about it once we
54:59 - write this code once so we're going to
55:01 - say
55:03 - import aios from axios okay we're then
55:08 - going to say import the access token
55:11 - from our constants now what we're going
55:14 - to do is we're going to get the API so
55:16 - we're going to say const API is equal to
55:19 - axios do create and inside of create
55:23 - we're going to pass an object and the
55:25 - object is going to specify spey the base
55:27 - URL which is going to be equal to
55:30 - import. meta
55:33 - env. Vore
55:37 - apiurl okay now this might seem
55:40 - confusing but what this allows us to do
55:42 - is import anything that's specified
55:44 - inside an environment variable file now
55:47 - if we want to have an environment
55:48 - variable loaded inside of our uh what do
55:51 - you call it JavaScript code here our
55:53 - react code it needs to start with V so
55:55 - the IDE a here is that we're going to
55:57 - have this in an environment variable so
55:59 - that it's really easy for us to load and
56:00 - change what the URL should be so what
56:03 - I'm going to do is I'm going to go to
56:04 - myv file and inside of here I'm going to
56:07 - specify that same thing so
56:09 - Vore API URL and we're just going to
56:12 - make this equal to http
56:16 - colon Local Host colon
56:20 - 8000 okay now we can change that later
56:22 - if we need to but this should be the URL
56:24 - of our backend server obviously it's
56:26 - running right now but when we start
56:28 - running it then this will be the correct
56:29 - one okay so since that's in there this
56:31 - is how you import that environment
56:33 - variable
56:34 - importa env. vapi URL and we're
56:37 - specifying that as the base URL so when
56:39 - I start using this API here all I need
56:42 - to do is specify the path I want to
56:44 - access I don't need to specify the base
56:47 - URL now what I'm going to do is I'm
56:49 - going to say api. interceptors and this
56:52 - is going to be request. use now inside
56:56 - of here it's going to take a function so
56:58 - we're going to write an arrow function
57:00 - like so now inside of this function
57:03 - we're going to accept the config and
57:04 - what we're going to do is look in our
57:05 - local storage and see if we have an
57:07 - access token if we do we're going to add
57:10 - that as an authorization header to our
57:12 - request otherwise there's nothing that
57:14 - we need to do because we don't have a
57:15 - header so I'm going to say const token
57:18 - is equal to local storage. getet item
57:22 - and I'm going to try to get the item
57:23 - with the key access token we'll set this
57:26 - later but for now we're just going to
57:27 - try to get it we're going to say if we
57:30 - have a token then what we'll do is say
57:33 - config do headers do authorization is
57:37 - equal to and then we're going to use
57:38 - back ticks here and we're going to say
57:40 - Bearer and then we're going to embed the
57:43 - token like so now this is how you pass a
57:46 - JWT access token you simply create an
57:49 - authorization header which can
57:51 - automatically be handled for us by axios
57:53 - which is why we're using it and it needs
57:55 - to start with Bearer then you have a
57:57 - space and then you have what the actual
57:59 - token is now this is how you embed a
58:02 - string inside of another string or yeah
58:04 - I guess that's what we're doing right we
58:05 - use backticks and then we can embed a
58:07 - variable here inside of the string okay
58:09 - so that is if this is successful and
58:11 - then we need to return config now we're
58:14 - just going to have another function here
58:16 - which is called error and if there's an
58:19 - error all we're going to do is say
58:21 - return promise. reject and we're going
58:24 - to reject with the error
58:27 - okay now don't worry about this too much
58:28 - this error function the main thing that
58:30 - we want to be looking at here is adding
58:31 - this authorization header that's
58:33 - automatically going to happen in all our
58:35 - requests so now what we're going to do
58:36 - is say export default API so we're going
58:40 - to export this object that we've just
58:42 - added this Interceptor on and from now
58:44 - on we're actually going to use this API
58:46 - object rather than using axios by
58:48 - default uh to send all of our different
58:50 - requests so the authorization token will
58:52 - automatically be added for us okay so
58:55 - now that we've done that we actually
58:56 - need a way to get our token right and
58:58 - also to protect our different roots on
59:01 - the front end as well as on the back end
59:04 - now the order I'm going to do this might
59:05 - seem a little bit weird but you just
59:07 - need to bear with me because there's a
59:08 - lot of code that needs to be written
59:10 - before any of this will actually be
59:11 - testable because of the security that we
59:13 - have on our back end so I'm going to go
59:16 - inside of my components here I'm going
59:18 - to make a new component called protected
59:21 - root. jsx okay now this is going to
59:24 - represent a wrapper for or a protected
59:26 - route and the idea is if we wrap
59:28 - something in protected rout then we need
59:31 - to have an authorization token before
59:33 - we'll be able to actually access this
59:35 - route so what I'm going to do is the
59:37 - following I'm going to say
59:39 - import navigate from react router Dom
59:45 - I'm then going to import the JWT dcode
59:49 - from and this is going to be JWT D
59:52 - decode I'm then going to import API
59:56 - from and this is going to be dot slash
59:59 - or actually dot do slash
60:02 - API okay and I'm going to import the
60:08 - refresh token and the access token from
60:12 - my constants now what I'm going to do is
60:14 - I'm going to take my function and I'm
60:17 - going to say
60:18 - function protected root and inside of
60:22 - here we're going to take in children now
60:24 - this is what will be wrapped
60:26 - and then for our protected route we're
60:29 - going to do a few different things here
60:30 - now the basic idea is we need to check
60:32 - if we are authorized before we allow
60:35 - someone to access this route otherwise
60:37 - we just need to redirect them and tell
60:39 - them they need to log in before they can
60:41 - view this now theoretically someone
60:44 - could uh bypass this because it's all
60:46 - frontend code but the concept is I don't
60:48 - want to allow someone to go to a route
60:50 - on the front end they shouldn't be able
60:52 - to access until they've logged in so I'm
60:54 - writing my own kind of custom front end
60:56 - protection here just to make this a
60:57 - little bit cleaner so what I'm going to
60:59 - do is I'm going to write a const here
61:01 - and I'm going to say this is is
61:03 - authorized and then set
61:06 - is
61:08 - authorized uh if we could spell this
61:11 - correctly and this is going to be equal
61:12 - to use state which we're going to import
61:16 - from react and by default this is going
61:19 - to be null okay then what we're going to
61:22 - do is we're going to write two functions
61:24 - the first function is is going to be
61:26 - refresh
61:28 - token okay which is going to be an async
61:31 - function all right and what this is
61:33 - going to do is refresh the access token
61:35 - for us automatically we're then going to
61:37 - have an O
61:39 - function which is also going to be
61:41 - async which is going to check if we need
61:44 - to refresh the token or if we are good
61:46 - to go okay so down here before I
61:49 - Implement these functions I'm just going
61:50 - to say something where I say if is
61:53 - authorized is equal to null then what
61:56 - I'm going to do is return a div and this
62:00 - div is just going to say
62:01 - loading dot dot dot the reason for this
62:04 - is that until this has some State that's
62:07 - not null I'm loading and I'm just
62:09 - checking the tokens or I'm potentially
62:11 - refreshing them okay otherwise I'm going
62:13 - to return is authorized question mark So
62:17 - if we are authorized so if that's true
62:20 - then we're going to return whatever the
62:21 - children were that we wrapped otherwise
62:23 - we're going to return a component called
62:25 - navig
62:26 - and this is going to go two equals and
62:28 - it's going to go to the login rout so 2/
62:32 - login now this is a root or this is a
62:34 - component are that we can use from react
62:36 - router Dom as soon as this is rendered
62:38 - it's just going to automatically
62:39 - navigate us to the login page I know we
62:41 - haven't implemented all of the routing
62:43 - yet uh but this is what it will do once
62:45 - we implement the routing then down here
62:47 - I'm going to say export default and this
62:50 - is going to be the protected route okay
62:53 - so we're going to go inside of our off
62:54 - function now and the IDE aidea inside of
62:56 - oth is to first look at our access token
62:59 - see if we have one and if we have one
63:02 - check if it's expired or not now if it's
63:04 - expired we want to just automatically
63:06 - refresh the token so that the user
63:08 - doesn't have to worry about anything and
63:10 - it just happens by itself in the
63:11 - background that's what this function
63:13 - will do now if we cannot refresh the
63:16 - token or it's expired then what we'll do
63:18 - is just say hey no you're not you're not
63:20 - authorized and you need to log in again
63:21 - by going to that login route so the
63:23 - first thing we're going to check is if
63:24 - you have the token so we're going to say
63:26 - const token is equal to local storage.
63:30 - getet item and we're going to access the
63:32 - item with the access token we're then
63:35 - going to say if not
63:37 - token then what we'll do is we'll say
63:39 - set is authorized to false and we will
63:44 - return okay now if we do have the token
63:47 - then what we can do is decode the token
63:50 - and we can get what the expiration date
63:52 - is so to do that we can say const
63:54 - decoded is equal to JW
63:57 - dcode and then take in the token now
64:00 - this is automatically going to decode it
64:02 - for us and give us access to the value
64:04 - and the expiration date so I'm going to
64:06 - say const token expiration is equal to
64:11 - decoded. okay which stands for
64:13 - expiration I'm now going to get today's
64:15 - date I'm going to say con now is equal
64:17 - to date. now and I'm going to divide
64:20 - this by a th so I get the date in
64:22 - seconds not in milliseconds now what I'm
64:26 - going to do is I'm going to say if the
64:28 - token expiration is less than now which
64:31 - would mean it's already expired I'm
64:33 - going to say await refresh token
64:37 - otherwise I'm going to say set is
64:41 - authorized and this is going to be true
64:44 - now the reason I can set it equal to
64:45 - True is because if the token is not yet
64:47 - expired that means that it's valid and
64:49 - we're good to just simply say that yes
64:51 - it's authorized we're good to go okay
64:54 - now what we'll do is we go write the
64:56 - refresh token and then we actually need
64:57 - to call these functions so inside of
65:00 - refresh token we're going to say const
65:03 - refresh token is equal to local storage.
65:07 - getet item and we're going to get the
65:09 - refresh token I'm then going to do a try
65:12 - catch block here so let's write the
65:14 - catch to start so we're going to catch
65:16 - some error and we'll just say set is
65:20 - authorized and then false and we can
65:22 - just
65:23 - console.log the error here
65:26 - okay now inside of the try what I'm
65:28 - going to do is I'm going to send a
65:30 - request to my backend with my refresh
65:33 - token to get a new access token so I'm
65:36 - going to say const res standing for
65:38 - response is equal to await
65:41 - api. poost and I'm going to post to/ API
65:45 - SL token SL refresh don't forget the
65:48 - trailing slash otherwise this won't work
65:51 - and then as the payload I'm going to
65:53 - pass refresh equal to my refresh token
65:57 - now let's just format this so it's a
66:00 - little bit easier to read okay so here
66:02 - what we're doing right is we're saying
66:04 - let's get the refresh token and then
66:06 - we're going to try to send a response to
66:08 - this route with the refresh token which
66:11 - will should give us a new access token
66:13 - so what we'll do here now is we'll say
66:15 - if
66:16 - res. status is equal to 200 meaning it
66:20 - was successful we're going to say local
66:23 - storage. set item we're going to set the
66:26 - new access token to be equal to the res.
66:29 - dat. access okay because that's what's
66:32 - going to contain the access token we're
66:34 - then going to say set is authorized to
66:37 - True otherwise we're going to say set is
66:42 - authorized to false okay so that's how
66:45 - the refresh token function works we get
66:48 - the refresh token we send it to the back
66:50 - end notice we're using api. poost when I
66:53 - do that it's automatically going to
66:55 - handle the base URL for me so I just
66:58 - need to pass if we go back here the
67:00 - route that I want to access which is
67:02 - this I passed my refresh token if the
67:05 - response status code is 200 that means
67:07 - it's successful and I did get back an
67:08 - access token so I will change or I will
67:11 - set sorry the new access token as the
67:13 - access token in local storage so I can
67:15 - use it when I now send requests then I
67:18 - set is authorized to True otherwise I
67:20 - set it to false because for some reason
67:22 - there was an error here and we didn't
67:23 - get a new access token okay last thing
67:26 - we need to do here is we're going to
67:28 - write a use effect so we're going to say
67:30 - const actually we're going to
67:32 - say use effect up here to import that
67:37 - and we're going to say use effect like
67:39 - this we're going to implement our
67:42 - function and all we're going to do is
67:44 - we're going to say off so we're going to
67:45 - call this function and we're just going
67:48 - to catch in case there's any errors so
67:51 - we're going to say off. catch and if
67:53 - there is an error we're going to say set
67:54 - is author ized to false okay so the idea
67:58 - is as soon as we load a protected route
68:01 - we're going to try to do this right
68:03 - where we call the off function we see if
68:05 - we have a token if we do have a token
68:07 - and it's not expired we can simply set
68:09 - authorized to true if it is expired we
68:12 - need to refresh the token so we'll wait
68:13 - for that to happen and then as soon as
68:15 - the token is refreshed and we're
68:16 - authorized we'll be able to access that
68:18 - route if we are not able to access the
68:20 - rout or we're unauthorized then we're
68:22 - going to return the navigate component
68:24 - back to login okay let's zoom out a bit
68:27 - so you can kind of read some of it I'll
68:28 - just slowly scroll through it of course
68:31 - you can also copy this directly from the
68:34 - GitHub okay so that is our protected
68:36 - root component now what we're going to
68:38 - do is we're going to stub some pages
68:40 - that we're going to need and we're going
68:42 - to set up the navigation for our
68:43 - application so I'm going to make a few
68:45 - different components I'm going to say
68:47 - login.
68:49 - jsx I'm going to say
68:52 - register.
68:54 - jsx I'm going to I'm going to say home
68:57 - so let's do this.
69:00 - jsx what else do we need and I'm going
69:02 - to do not
69:04 - found.
69:05 - jsx okay now inside of each of these I'm
69:08 - just going to stub a component so I'm
69:10 - going to say const home let's zoom in a
69:13 - bit okay or actually let's just make it
69:16 - function let say function home like that
69:19 - and then we will
69:21 - export default home and from home we can
69:26 - just return some div that says home
69:31 - let's copy that and let's go into login
69:34 - and let's just change home here to be
69:39 - login okay obviously we're going to fill
69:41 - in these components later but I just
69:42 - need to have some of them right now for
69:44 - my navigation for this one it'll be not
69:46 - found so this is like a 404 page okay so
69:49 - we're going to
69:50 - do not
69:52 - found and then
69:56 - not found and then lastly register this
69:59 - is going to
70:01 - say
70:04 - register register
70:07 - and register okay so now that we have
70:10 - our four pages let me make this bigger
70:14 - so we can see it and close all of these
70:17 - what we're going to do is we're going to
70:19 - go to our
70:20 - app.jsx and we're going to write the
70:23 - navigation essentially so how we go
70:25 - between the different pages using react
70:27 - router Dom so let's start importing a
70:30 - few things we need again the idea is
70:31 - that this is the root of our application
70:33 - and we want to be able to navigate
70:35 - between different pages by going to a
70:37 - different address in the URL bar so
70:39 - that's what I'm going to show you how to
70:40 - implement so I'm going to say import the
70:43 - browser
70:45 - router import Roots import roots and
70:49 - import navigation from react router Dom
70:54 - I am then going to import the login
70:56 - component from this is going to be dot
70:59 - slash and this is going to be
71:02 - Pages /login we are then going to import
71:06 - the register
71:08 - component
71:09 - from do SL Pages SL register I'm then
71:15 - going to import the home component from
71:17 - the same thing pages slome and we're
71:21 - going to import the not found component
71:24 - from
71:25 - do/ Pages SL not found okay we also need
71:30 - to import the protected rout so we're
71:32 - going to say import protected root from
71:36 - SL components SL protected root okay now
71:42 - we're going to write two very simple
71:44 - functions one for logging us out so I'm
71:46 - going to say function log out and all
71:50 - log out is going to do is as soon as we
71:52 - call it it's going to say local storage.
71:54 - CLE so as as soon as we log out we're
71:56 - going to clear our refresh token and our
71:57 - access token and we're just going to
71:59 - return a navigate so let's do this and
72:04 - this is going to be two so let's write
72:06 - two equals slash
72:09 - login okay and navigate we need to
72:12 - import that so do we have that imported
72:15 - sorry this needs to be navigate not
72:18 - navigation okay so that is our log out
72:20 - function and then we're going to import
72:22 - one more function or write one more
72:23 - function and this is going to be
72:25 - register and log out okay and what this
72:30 - is going to do is it is going to say
72:33 - local storage. CLE then this is going to
72:36 - return simply the register component now
72:40 - the reason why I'm writing this is that
72:41 - if someone is registering I first want
72:43 - to clear the local storage so that I
72:45 - don't end up submitting access tokens to
72:47 - the register route where I could
72:49 - potentially get an error so we just need
72:51 - to make sure that when we are
72:53 - registering we first clear the local
72:54 - storage so we don't have any old access
72:56 - tokens lingering around I know it seems
72:59 - a bit strange but it's just something
73:00 - that we need to do in order for this to
73:01 - work properly okay now what we want to
73:04 - do is we want to set up this app
73:06 - component so we can navigate between our
73:08 - different pages so to do that we're
73:10 - going to return the browser router okay
73:14 - this is a component from react router.
73:17 - now inside of here we need to specify
73:18 - Roots so we're going to say roots and
73:21 - inside of here we can put all of our
73:22 - different roots that we want to navigate
73:24 - between so let's begin by specifying the
73:27 - home root so we're going to say root
73:30 - this is going to be a self-contained
73:31 - component and inside of here we're going
73:33 - to say the path is equal to this so just
73:35 - the standard path if you go to just the
73:37 - normal path this is where it'll bring it
73:39 - to and the element that we want to
73:41 - render here is going to be the following
73:44 - now this is going to be the protected
73:46 - roote and then inside of the protected
73:48 - roote we are going to render home so the
73:51 - point is that you cannot access the home
73:54 - component unless unless you have the
73:55 - access token and it's valid because you
73:58 - shouldn't be able to access that because
74:00 - home is for people that are logged in
74:01 - and authenticated so that's how this
74:03 - works right we're wrapping the component
74:05 - that we want to be protected with
74:06 - protected root and you can use protected
74:08 - root for any component that you want so
74:11 - now we're going to do another rout and
74:13 - let's end it like this the path for this
74:17 - one this time will be slash
74:19 - login and this element that we're going
74:21 - to render is going to be the login page
74:24 - okay okay now that's not protected you
74:26 - can go to that no matter what now let's
74:29 - copy this and do the same thing for
74:31 - register okay but the element we're
74:33 - going to go to this time is going to be
74:35 - the component we wrote so register and
74:37 - log out right the one that's going to
74:39 - log us out first by removing the tokens
74:43 - and then we're going to have another
74:44 - rout this is going to be path equal to
74:47 - and we're just going to put in asteris
74:49 - and if you go to any other path we're
74:51 - going to render the element which is
74:53 - equal to
74:55 - the not found Route which is going to be
74:57 - like a 404 page okay so what we're doing
75:00 - is we're looking first starting at the
75:01 - very first route so we're saying okay is
75:03 - it the normal path if it is go to home
75:06 - if it's login go to login if it's
75:08 - register go to register if it is
75:10 - anything else go to the 404 not found
75:13 - page okay that's going to handle all of
75:15 - our routing now we can actually test if
75:17 - this routing is working so to do that
75:20 - we're going to bring up our code here
75:23 - notice we're inside of the front end
75:24 - directory and we're going to type npm
75:27 - and actually I believe we are going to
75:28 - need to
75:29 - install uh okay no actually that seem to
75:32 - work that's fine and then we're going to
75:33 - type npm run Dev now when we type npm
75:37 - run Dev that's going to run the
75:38 - development server for us what we can do
75:40 - now is we can open it up let me just
75:43 - bring it over to the other page and
75:45 - you'll see that we go to login by
75:47 - default if I try to go to home notice
75:49 - it's redirecting me to login because it
75:51 - is a protected route and we don't have
75:53 - our access token
75:55 - now let's see what happens if we go to
75:56 - register brings us to register and if we
75:59 - go to something like some random string
76:02 - it brings us to not found okay so that's
76:05 - working so let's go ahead and shut this
76:07 - down and start writing some more of our
76:09 - components okay so first component that
76:11 - I think is pretty easy to get out of the
76:13 - way is the 404 or the not found
76:15 - component so let's write that one so for
76:17 - this all we can do in here is just
76:20 - remove that and we can go with an H1 tag
76:23 - and we could say 404 not found and then
76:27 - we can go with ap and we can say the
76:29 - page you're
76:32 - looking
76:34 - for does not exist okay like that that's
76:40 - fine and maybe we'll do doesn't exist
76:44 - okay so that's good for the not found
76:46 - page next what I actually want to write
76:48 - is I want to write a generic form that
76:50 - can be used by our register and by our
76:54 - login page and I also realized here that
76:56 - we didn't implement the logout route so
76:58 - let's quickly do that so we're just
77:00 - going to write another one here and just
77:02 - change this to say log out and we'll go
77:05 - to log
77:06 - out okay so sorry just add that one I
77:08 - just forgot that right there okay so as
77:10 - I was saying what I want to do is I want
77:11 - to make a form this form will just
77:14 - collect a username or password and then
77:16 - submit it to either the register route
77:18 - or to the login route now we can just
77:22 - write one form and we can just kind of
77:24 - make it a bit dynamic so it works for
77:25 - both registering and logging in because
77:28 - for our registration it's the exact same
77:30 - process as logging in right just a
77:31 - username and password it'll be the same
77:33 - for both so what I'm going to do is go
77:34 - to components and I'm going to make a
77:37 - form. jsx so inside here let's import a
77:40 - few things that we need we're going to
77:42 - say
77:43 - import use
77:45 - state from react we're going to say
77:49 - import
77:50 - API from do/ API I'm going to say import
77:56 - and this is going to be use navigate
77:58 - from react router Dom okay this a hook
78:01 - that we can use to actually access the
78:02 - navigation from code I then am going to
78:05 - import the access token okay come on
78:08 - give it to me and the refresh token from
78:12 - our constants and I am going to actually
78:15 - for now that's it okay we're now going
78:18 - to write a function this is a form and
78:21 - we're going to take in two props the
78:23 - props that we're going to take in our
78:25 - root and our
78:27 - method okay now the root is the rout
78:30 - that we want to go to when we submit the
78:31 - form so it could be the token route or
78:33 - it could be the register route and the
78:34 - method is just telling us okay are we
78:36 - registering or are we logging in the
78:39 - idea is this form will work again for
78:41 - both logging in and registering and this
78:42 - is the dynamic props that we'll pass to
78:44 - specify what it should be used for so in
78:47 - terms of the state we're going to need
78:48 - to store the username and the password
78:50 - that the user is typing in so we're
78:52 - going to say con username uh what is it
78:55 - comma set username is equal to use State
78:58 - and this will be an empty string we're
79:00 - then going to say
79:01 - const password and then set password is
79:06 - equal to use State and this will be an
79:08 - empty string and then we'll do one more
79:10 - piece of state to just keep track of if
79:12 - we're loading or not so we're going to
79:13 - say con loading set loading is equal to
79:18 - use State and this will be false to
79:22 - start we're then going to say const
79:24 - navigate is equal to use navigate and
79:28 - we'll call that hook okay now what we
79:31 - want to do is just write a basic form so
79:33 - we're going to say return and we're
79:35 - going to return a form now the form is
79:38 - going to have on
79:40 - submit okay and this is going to call a
79:42 - function and the function it's going to
79:44 - call is handle submit so we can stub
79:47 - that function right now we can say cost
79:49 - handle submit is equal to a function and
79:53 - instead of here we're going to take in E
79:55 - and we're going to say e. prevent
79:58 - default now what this will do is prevent
80:00 - us from actually submitting the form and
80:03 - it will kind of remove the default
80:04 - Behavior so we won't reload the page
80:06 - because we don't want to reload the page
80:07 - here when we're doing that okay so now
80:09 - that we've made the form I'm just going
80:10 - to add a class to this because we're
80:11 - going to style it in a second so I'm
80:13 - going to say class name is the
80:15 - form container and then inside the form
80:18 - we'll write our different elements so
80:21 - first things first we're going to write
80:22 - an H1 tag and we're actually going to
80:24 - look at what the method is that's passed
80:26 - as the prop now we're going to say if
80:28 - the method is equal to login then we're
80:30 - just going to uh render login as the
80:32 - text inside of here otherwise we're
80:35 - going to Lo uh render register sorry
80:37 - okay so this is just giving us the name
80:39 - and in fact what we can do just to make
80:40 - this a little bit cleaner is we can say
80:42 - const name is equal to and we can copy
80:45 - this and paste this here and then we can
80:47 - just render the name inside of here so
80:50 - the idea is we're just getting the name
80:52 - that we should put for the title of the
80:54 - form okay so if it's login then do login
80:57 - otherwise do register so method will be
80:58 - either equal to login or register okay
81:01 - now we're going to have some input
81:03 - fields for the username and the password
81:05 - so we're going to say input okay and for
81:07 - the first input we'll specify the class
81:11 - name equal to and this can be the form D
81:14 - input then we can do type is equal to
81:18 - text we can do the value is equal to
81:22 - username and on change
81:25 - is equal to and then we're going to take
81:27 - in a function here and this is going to
81:28 - be e and then set username so let's
81:32 - spell that correctly and this is going
81:33 - to be e. Target
81:36 - doval okay lastly we'll have a
81:40 - placeholder and this will be equal to
81:43 - username okay so this is one of our
81:45 - input Fields again form input type text
81:48 - value username so this means that
81:50 - anytime we make a change here we take in
81:52 - the variable e we're then saying set us
81:54 - us name and then whatever we typed we're
81:56 - just going to adjust and set that in the
81:58 - state so that we'll be able to access
81:59 - that when we actually submit the form
82:01 - now we're going to copy this and we'll
82:02 - just do similar thing here for the
82:04 - password so we're going to change this
82:06 - from type text to type password we're
82:09 - going to change the value to be password
82:13 - we're going to change set username to be
82:14 - set password and we're going to change
82:17 - the placeholder to be
82:19 - password okay almost done last thing we
82:22 - want to do now is add the button cuz we
82:24 - need a button to submit so for the class
82:26 - name of this button it will just be the
82:28 - form-b button and the type of this will
82:31 - be submit and then inside of the button
82:35 - we're just going to put the name that we
82:38 - have from up here so it'll either say
82:39 - login or register depending on the
82:42 - method that we pass to this form okay we
82:44 - can zoom out a little bit so it's a bit
82:46 - easier to read and that's it for the
82:48 - actual uh jsx or uh what do you call it
82:51 - word rendering on the screen let me just
82:53 - format this and now let's write our
82:56 - handle submit method so when we submit
82:59 - the form the first thing we'll do is
83:01 - we'll set loading equal to True okay
83:04 - let's zoom in so we can see this a bit
83:08 - and then after that we're going to
83:10 - attempt to send a request to whatever
83:12 - root it is that this form is
83:14 - representing so we're either going to
83:15 - try to log in or we're going to try to
83:17 - register so what we'll do is we'll set
83:19 - up a TR catch because this could
83:22 - fail okay and we're going to make this
83:24 - an Asing function as well okay so we're
83:27 - going to catch error if we have an error
83:30 - we're just going to alert what the error
83:33 - is so it'll just show it on screen and
83:35 - then we're going to add a finally block
83:37 - and we're going to say set
83:40 - loading false so no matter what happens
83:43 - we're going to try to send the request
83:44 - if there's an error we'll catch it and
83:46 - whether it worked or it didn't work
83:48 - we're just going to set loading equal to
83:49 - false because eventually we'll have a
83:50 - loading indicator here and we want to
83:52 - obviously like turn that off right and
83:54 - let me just fix this a little bit okay
83:58 - so inside of our try we're going to send
83:59 - a request so to send the request we're
84:01 - going to say const res is equal to await
84:05 - api. poost and we're going to post to
84:08 - the root that was passed into the form
84:12 - we then are going to pass a
84:14 - username and a password so this is it
84:17 - it's going to use the API that we wrote
84:20 - it's going to send a post request to
84:21 - whatever the route is pass the username
84:23 - and password we're going to wait until
84:25 - we get that back and we're going to
84:26 - check the following we're going to say
84:28 - if method is equal to
84:32 - login then what we're going to do is say
84:35 - local
84:36 - storage. set item and we're going to set
84:38 - the access token to the res. dat.
84:42 - access and we're going to say local
84:44 - storage do set item and we're going to
84:47 - set the refresh token to be res.
84:51 - dat.
84:53 - refresh
84:55 - okay so the idea is we're going to send
84:56 - this request if an error occurs it'll be
84:59 - handled here in the catch if there's no
85:01 - error that occurs then we're going to
85:02 - check if the method was log in if it was
85:05 - that means that we need to get the
85:06 - access token and the refresh token and
85:08 - we need to set them okay then we are
85:11 - going to
85:12 - navigate to the slash login or sorry not
85:17 - to the SL login to the SL page so we're
85:19 - going to use the navigate function that
85:20 - we have here and just navigate to home
85:22 - so we'll be able to view our notes which
85:24 - you'll see in a second otherwise we are
85:27 - going to
85:28 - navigate to/ login the reason for this
85:32 - is that if it wasn't login it must have
85:34 - been register if it was register there's
85:36 - no tokens that we need to set in order
85:38 - to get the tokens we actually need to
85:40 - log in with our new registered account
85:43 - okay so that's our form again we can
85:45 - kind of zoom out a little bit so you can
85:47 - read it a little bit better now there's
85:49 - some more things that we'll do here
85:50 - later on but for now I just want to
85:52 - apply The Styling and then I want to
85:53 - actually go to these elements and test
85:55 - out and see if they're working so for
85:57 - the styling I'm going to make a new
85:59 - style sheet here in Styles and I'm going
86:01 - to call this
86:02 - form. CSS now what I'm going to do is
86:05 - just copy in the Styles I'm not going to
86:07 - write them out because I think that's
86:09 - kind of a waste of time so I'm going to
86:11 - paste in all of the Styles here if you
86:13 - want these Styles you can simply have
86:15 - them from the GitHub repository that is
86:17 - linked in the description okay so you
86:19 - can just go find them from the for. CSS
86:21 - file and just paste them in your own
86:23 - file or you can just cop the entire file
86:25 - right whatever you want to do anyways
86:26 - I've read them in here in order for
86:28 - these styles to be applied though we do
86:29 - need to import that file so we're going
86:31 - to say import do do
86:34 - Styles form. CSS okay just so that we'll
86:38 - have some nice styling last thing we
86:40 - need to do is we need to export this
86:41 - component so we're going to say export
86:44 - default form and now that we have
86:47 - exported the form we can start using it
86:49 - so now that we have the form component
86:51 - we're going to use that from the login
86:53 - and from the register component
86:54 - component and it's going to be pretty
86:55 - straightforward but all we'll do from
86:57 - login here is we'll start by importing
87:00 - the form so we're going to say import
87:02 - form from dot slash or dot dot slash if
87:07 - we can do two dots components SL form
87:11 - and then rather than returning this div
87:14 - we're just going to return the form
87:15 - component but we're going to pass two
87:17 - props to it now when we're logging in or
87:20 - sorry when we're registering the route
87:22 - that we want to go to is API slash
87:25 - userregister again make sure you have
87:28 - that trailing slash then the method is
87:31 - going to be equal to
87:34 - register okay so that's it that's all we
87:37 - need to do we're just setting the rout
87:38 - that we want to send the request to and
87:40 - we're specifying the name or the method
87:42 - which is register now we can copy this
87:44 - same thing and we can go to login and
87:47 - for login we need to import the form
87:49 - again so we're going to say import let's
87:51 - zoom in uh form from
87:54 - do do/ components SL form this time for
87:58 - login the root is going to be API SL
88:01 - token slash and the method is going to
88:04 - be to log in okay so now we should be
88:09 - using this for both the login and the
88:11 - register route and we can check if we
88:13 - are by clearing and going to npm runev
88:17 - so now if we open this up let me just
88:19 - bring this over so we can see it because
88:21 - it keeps opening on my other screen you
88:23 - see that we have a login field and if I
88:25 - go to slash
88:27 - register we have the register form now
88:31 - the main thing to check here is if the
88:33 - token is actually going to be working
88:36 - however before we can do that we need to
88:37 - make sure that the back end is running
88:39 - so what I want to do now is I want to
88:41 - split my terminal here I want to CD into
88:45 - the backend directory and I want to run
88:48 - my app so I'm going to say python
88:49 - manage.py run server all you need to do
88:52 - here is get in the backend directory and
88:53 - just run the server like you normally
88:54 - would okay so we're going to run this
88:56 - now and let's just check where it's
88:58 - running right so HTP 1.7.0 point0 point1
89:01 - Co in 8000 I'm going to copy that and
89:05 - I'm going to go to my environment
89:06 - variable and I'm just going to paste it
89:08 - inside of here just so it's exactly what
89:11 - we had before and actually I think I got
89:13 - to remove that trailing slash otherwise
89:16 - we might get an error okay I'm just
89:18 - going to shut down my V server and I'm
89:20 - just going to rerun it to make sure it
89:21 - reloads the environment variable and now
89:23 - I have my back end running and my front
89:25 - end and technically we should be sending
89:27 - requests now to the back end so let's
89:29 - test that out so what I'm going to do
89:31 - from register is I'm going to say
89:33 - newcore user and let's go with a
89:36 - password like 1 2 3 4 5 and I'm just
89:38 - going to open up the inspect window here
89:40 - in my console so I can see what's
89:42 - happening so let's click on register and
89:45 - notice that it redirected me to log in
89:47 - now if we want to see if that's working
89:48 - we can go to our back end and we'll see
89:50 - that a post request was actually sent
89:51 - here and even shows us what the options
89:53 - were username new user password here I
89:56 - don't know if maybe I printed that out
89:57 - or something I'm not sure if that's
89:58 - supposed to show us regardless you can
90:01 - see the post was successful with 2011 it
90:04 - immediately redirected us to login so
90:06 - now I can try to log in so I'm going to
90:08 - go new user then 1 2 3 45 log in and
90:12 - notice it brings me to home so I can
90:14 - access home even though it's a protected
90:16 - route because now I have my access token
90:18 - and if we go back here and we look uh
90:21 - where is it we have a post to token and
90:23 - you can see we have a status code of 200
90:25 - working successfully okay so we're able
90:27 - to communicate no cores errors
90:29 - everything is good and let's see what
90:31 - happens uh actually I guess there's not
90:33 - much more that I can check I mean I can
90:34 - go to login okay it brings me there and
90:37 - I can go back to home because I still
90:39 - have the access token but you'll notice
90:41 - now if I go to SL logout it's going to
90:44 - redirect me to login and if I try to go
90:47 - back to home it doesn't let me go there
90:49 - because I'm no longer authorized because
90:51 - I've logged out so I would need to log
90:53 - in again
90:54 - newcore
90:55 - user okay and then it will bring me to
90:58 - home and I'm good to go all right so
91:00 - there you go we're making really really
91:02 - good progress now now that we've done
91:04 - that we want to start writing the
91:05 - homepage so we can actually start making
91:07 - some notes and our application can
91:09 - actually do something so we're able to
91:10 - log in we're able to register the form
91:13 - is built I would say the hard part is
91:15 - done and now we need to start actually
91:17 - interacting with our notes so that's
91:19 - going to involve writing some code
91:21 - inside of the homepage here so let's
91:23 - start doing that so from our homepage
91:25 - what we want to be able to do here is
91:27 - view all of the notes that we have and
91:29 - then create new notes and delete notes
91:32 - so let's go through those operations one
91:34 - at a time we're going to start by
91:36 - importing a few things so I'm going to
91:38 - say import and we're going to import use
91:41 - State and use
91:43 - effect from
91:46 - react okay and we're going to import our
91:49 - API
91:51 - from dot do/ API
91:55 - okay now inside of home let's start with
91:57 - the state that we need so we're going to
91:59 - need to keep track of all of the notes
92:01 - that we have that we've already grabbed
92:03 - from the server because the first thing
92:05 - we'll do when we load this page is we'll
92:06 - send an authorized request to get all of
92:09 - the notes that we've created so let's do
92:11 - that first we're going to say con notes
92:14 - set notes is equal to use State and this
92:18 - will be an empty
92:19 - array we then need some State for the
92:22 - form that will be on this page that
92:24 - allows us to create a new note now I'm
92:26 - going to do it all in this component we
92:27 - could put it in a separate component if
92:29 - we wanted it to be cleaner but in this
92:31 - case I'm just going to have some State
92:32 - for the content and for the title of my
92:35 - note so I'm going to say con content set
92:39 - content is equal to use State this will
92:43 - be an empty string I'm then going to say
92:45 - const and this is going to be title
92:48 - set title is equal to use State and this
92:55 - is going to be an empty string and now
92:57 - what we're going to do is write a few
92:59 - different functions that will send some
93:01 - requests so I am going to write all of
93:03 - the HTML obviously in a second but I
93:05 - want to show you how we send the request
93:07 - to for example get all of the notes that
93:09 - this user has written so we're going to
93:11 - write a function called get notes now
93:14 - this can be written like this and what
93:16 - this is going to do is say API doget and
93:20 - we're just going to call the/ Api SL
93:24 - notes root notice I have my trailing
93:26 - slash okay now if you weren't sure how
93:29 - you would figure out what this route is
93:31 - in the back end remember if we go to API
93:34 - and URLs we have these different roots
93:36 - that we've written right we have the
93:38 - notes rout and we have notes / delete
93:40 - now the reason I'm prefixing this with
93:42 - API is because the way that we forwarded
93:45 - the URLs if we go back into back end
93:47 - here is anything that had API and wasn't
93:50 - one of these roots up here got forwarded
93:52 - to the other API roots that we have here
93:55 - so that's why I know that that's the
93:57 - correct route hopefully that's helpful
93:59 - but the idea is we've ridden all of
94:01 - these paths in our back end and now
94:02 - we're going to access them from our
94:03 - front end okay so I have api. getet SL
94:07 - API notes slash that's going to give me
94:09 - all the notes this user has written so
94:11 - I'm going to have a then and I'm going
94:14 - to say res and I'm going to return my
94:16 - res. data I'm then going to have another
94:19 - dot then and inside of here I'm going to
94:22 - have my
94:24 - data and I'm going to say set
94:28 - notes equal to whatever the data is now
94:31 - let me just format this so it looks a
94:34 - little bit nicer okay then we're going
94:36 - to have a catch in case there's an error
94:39 - and if there is an error we're just
94:40 - going to alert the error on screen okay
94:44 - and let me format this so that we get it
94:46 - looking nicer okay so there we go that's
94:48 - our get note function that will get all
94:50 - of the notes for us and really this
94:51 - should be get notes so what we can do is
94:54 - we can write a use
94:56 - effect and this use effect can simply
95:00 - call the get note function sorry as soon
95:04 - as we visit this page and then what we
95:06 - can do is inside of the then we can just
95:09 - console.log what the notes
95:11 - are so
95:14 - console.log and this will be the data
95:16 - just so that we can see what it is uh
95:18 - when we load this component okay so
95:21 - before we go much further let's actually
95:23 - just see if this request works so let's
95:25 - open up our terminal here let's go back
95:28 - to our front end and let's refresh and
95:30 - notice that you see we get an empty list
95:32 - here okay so we're getting the empty
95:34 - list the reason why we're getting the
95:35 - empty list is because well there's no
95:37 - notes that we've created and if we go
95:39 - back here you can see that it's sending
95:40 - the request to SL API sln notes perfect
95:45 - okay so let's bring that down and then
95:47 - let's continue writing our code so now
95:50 - that we have get notes let's have a way
95:52 - to delete notes notes and to create
95:54 - notes now to delete a note we're going
95:57 - to say
95:59 - const delete note and we need to take in
96:02 - the ID of the note that we want to
96:05 - delete then what we'll do is we'll say
96:08 - api. delete because the request is
96:10 - delete this time we're going to use some
96:12 - back Texs and we're going to say SL API
96:15 - sln notes SL delete slash and we're
96:18 - going to pass inside of here the ID of
96:22 - the note that we want to remove
96:24 - we're then going to say do then and
96:26 - we're going to get the response and
96:28 - we're going to check the status code of
96:30 - the response so we're going to say if
96:33 - res. status is equal to 204 which means
96:37 - we successfully deleted it then we're
96:39 - going to have an alert and we'll say
96:41 - note was deleted okay otherwise we're
96:46 - going to say alert and then
96:49 - failed if we do this failed to delete
96:53 - note like that okay then we're going to
96:57 - have a catch and for the catch we're
97:00 - going to catch an error and we're going
97:02 - to alert whatever that error is on
97:04 - screen and then I'm just going to call
97:06 - the get notes function this is not the
97:08 - most optimal way to do this but the idea
97:10 - is if we just deleted a note then it
97:12 - means that our notes have changed so I
97:13 - want to show that update on the screen
97:15 - so we'll just call get notes again and
97:17 - then that will actually update the
97:19 - screen by removing the notes when we
97:21 - receive the new notes from our backend
97:24 - really what we should be doing is on the
97:25 - front end just removing it from this
97:26 - list but I don't want to write that
97:28 - JavaScript to do the removal so we're
97:30 - just going to do it like this okay so
97:32 - I'm just going to format this again so
97:34 - it's a little bit easier to read and now
97:36 - we need to write our last function
97:38 - before we get into the HTML which is
97:40 - creating our notes so to create our
97:42 - notes we're going to say const create
97:44 - note and we're going to take in some
97:47 - value e because this is going to come
97:48 - from a form and we're going to say e do
97:51 - prevent and then default
97:54 - okay we're then going to say api. poost
97:57 - and we're going to post to SL API SL
98:00 - notes okay so the same one that we use
98:03 - to get our results but this time we're
98:04 - not using get we're using post and what
98:06 - we'll do is we'll pass the content and
98:09 - the title of the note we want to create
98:12 - then similarly to before we're going to
98:14 - take in the response here in the do then
98:16 - and we're going to say if the response.
98:20 - status is equal to 200 or sorry to 20
98:23 - one which means we created the note
98:25 - we're going to say
98:26 - alert and then note if we can do
98:30 - this created okay otherwise there was an
98:34 - error so we're going to say alert and
98:37 - then failed to make
98:41 - note okay then we need a do catch same
98:45 - thing if we have an error so we'll say
98:47 - error like this then we are going to
98:50 - alert the error and then lastly we're
98:53 - going to do the same thing we're going
98:54 - to say get notes like that okay and
98:59 - let's Zoom back in and format and now we
99:04 - have our create note function okay so we
99:07 - have create note delete note and get
99:09 - notes now we need to write the HTML okay
99:12 - so for our HTML we kind of have two main
99:15 - components here the first part is just
99:17 - displaying all of our notes and the
99:19 - second part is going to be a bit of a
99:20 - form to create a note so for displaying
99:23 - our not notes we'll just make a div here
99:25 - and we're going to say H2 and then notes
99:29 - then inside of here we're actually going
99:30 - to render all of our notes however I'm
99:32 - going to write a separate component that
99:33 - will display the notes so for right now
99:35 - we're just going to leave that empty
99:37 - we're now going to come down here though
99:38 - and we're going to make a form and this
99:40 - form is create a
99:42 - note okay so we're going to write a form
99:46 - and this needs to be in lowercase the
99:49 - form is going to have an onsubmit and
99:51 - the onsubmit is going to be equal to the
99:52 - create note function now inside of the
99:55 - form we're going to write our different
99:57 - elements so we're going to have a label
100:01 - this is going to be HTML 4 equal to the
100:05 - title and this is going to say title
100:08 - colon where then going to have a Brak
100:11 - line and we're going to have an input
100:14 - field for the input we're going to say
100:16 - type is equal to text we're going to say
100:19 - the ID is equal to the title we're going
100:22 - to say the the name is equal to the
100:25 - title and we're going to say required
100:28 - and then onchange is going to be equal
100:31 - to and this is going to be e and then
100:35 - set like this set title and then
100:40 - e. target. Val don't worry I'm going to
100:43 - save it so we can actually see what it
100:45 - looks like okay so this is the input
100:48 - type equals text ID title name title on
100:51 - change we'll also set the value equal to
100:55 - the
100:55 - title perfect okay so that's the first
100:58 - part now we need the same thing but for
101:00 - the content so I'm just going to copy
101:02 - this and paste this down here and change
101:05 - this to say
101:07 - content and then this will say content
101:10 - and then we're going to use a text area
101:12 - this time so it's a little bit larger so
101:14 - we're going to say text area and inside
101:17 - of text area we're going to say
101:18 - ID is equal to content we're going to
101:21 - say name is equal to content we're going
101:24 - to say required we're going to say value
101:27 - is equal to content and we're going to
101:30 - say onchange is equal to and then this
101:34 - is going to be a function where we take
101:36 - in E let's save this or actually it's
101:38 - it's just going to work right now okay
101:41 - let's go there so it's going to be
101:42 - function e and then this is going to be
101:45 - set content e.
101:48 - target. value okay I no this a lot we're
101:52 - almost done we're now going to have
101:54 - another brake line and then beneath this
101:56 - we're going to have an
101:57 - input and this is going to be type equal
102:00 - to submit and we'll say the value is
102:04 - equal to
102:06 - submit okay and let's format it nice
102:10 - okay zoom out a bit so we can read it a
102:12 - bit easier you can see that what we're
102:14 - returning here is a big div inside the
102:17 - div we have a first part which will
102:18 - display all of our notes in and then we
102:20 - have a second part here where we are
102:22 - going to create a note when we submit
102:24 - the form it's going to call the create
102:26 - note function which is going to pass the
102:29 - title as well as the
102:31 - content okay uh oh last thing yeah value
102:34 - content okay so that's good all right so
102:37 - I think that's going to complete the
102:38 - homepage other than displaying all of
102:40 - the notes so let's test this out let's
102:42 - make sure our servers are currently
102:44 - running looks like they are we'll come
102:46 - back here and you can see that we have
102:48 - kind of a sketchy little uh form here
102:49 - we'll fix that in a second but for now
102:51 - let's see if we can make a new note so
102:53 - we're going to say test note and then
102:55 - test content and submit and it says the
102:59 - note was created and if I refresh here
103:02 - you can see now that we have a new note
103:05 - okay so it says author is id2 content
103:08 - test content created at ID title perfect
103:12 - that is working okay now we did have an
103:14 - issue though where when I created the
103:16 - note it didn't update right away so I
103:18 - just want to see why that was the case I
103:21 - think it's because we need to put the
103:22 - get note notes inside of the then yes
103:26 - that's going to make sense so we'll put
103:27 - that inside of then and we're going to
103:29 - do that for all of the places where we
103:31 - created it so we're going to take
103:33 - this and put it here okay perfect so
103:37 - that should fix that for us and now we
103:40 - want to start displaying the different
103:41 - notes and we also want to style this
103:43 - page a bit we'll do the styling after
103:45 - first we're going to make a new
103:46 - component inside of the components
103:47 - directory called note.
103:50 - jsx okay this is going to represent one
103:54 - single note and we'll just use this to
103:56 - render all of our notes really easily so
103:58 - we're going to say
104:01 - import
104:03 - react from
104:05 - react we're then going to make a
104:08 - function called note now the note is
104:11 - just going to take in the note itself
104:12 - and a function which is on
104:14 - delete and we're going to return um some
104:17 - jsx here or some HTML so we're going to
104:20 - have a div the class name of this is
104:23 - going to be the note
104:26 - container okay we're then going to have
104:28 - a P tag this is going to have a class
104:30 - name equal to the note title this is
104:35 - going to be
104:37 - note.
104:39 - tile we're going to have another P tag
104:42 - this is going to say class name is equal
104:44 - to and this is going to be the note and
104:47 - content and then you guessed it this is
104:49 - going to be the note do content we're
104:53 - then going to have another P tag and
104:55 - this is going to be class name equal to
104:58 - the note date and then what we're going
105:01 - to do is pass in a value here which I'll
105:03 - put in in a second and then we're going
105:04 - to have a button and this button is
105:06 - going to have a class name equal to
105:10 - delete button and it's going to have an
105:15 - onclick equal to and we're going to call
105:19 - the on delete function so we're going to
105:21 - have a function that calls on delete
105:22 - delete and passes the note. ID and then
105:26 - here this will say delete okay let's
105:31 - format this so we can read it nice so
105:35 - what we're doing right is we're
105:36 - rendering the container inside of here
105:38 - we're going to have the title the
105:39 - content we're going to put the date here
105:41 - which I'm going to do in a second and
105:42 - then we have the delete button which
105:44 - will call the on delete function that we
105:46 - pass as a prop with the ID of the note
105:49 - which is what we'll need to actually
105:50 - delete the note so that's why we wrap
105:52 - this with another function so we can
105:53 - pass this uh argument here into the
105:56 - function so now I'm just going to make a
105:58 - variable I'm going to say const
106:00 - formatted date is equal to new date and
106:03 - I'm going to take in the note. created
106:06 - at and I'm just going to convert this to
106:08 - a local date string in
106:12 - enus now what this is going to do is
106:14 - just strip off all the parts that we
106:16 - don't need to see like the time zone and
106:18 - it's just going to tell us what the date
106:20 - was when we actually created this string
106:23 - so it's just going to give us a nicely
106:24 - formatted date essentially I know I said
106:26 - that kind of backwards it's just going
106:27 - to make the date look nicer that's all
106:29 - it's doing now you can do all kinds of
106:30 - formatting for it but that's fine for
106:32 - now so we're going to pass the formatted
106:34 - date here where we were kind of missing
106:36 - that value now that we have this note
106:38 - component we can use it inside of the
106:41 - home page so to do that where we have
106:44 - notes here we're going to start
106:45 - rendering all of our note components so
106:48 - to render our note components we're
106:50 - going to render some code here and we're
106:52 - going to say notes
106:53 - map and we're going to map each one of
106:56 - our notes and we're going to show the
106:58 - note component so we're going to say
107:00 - note the note is going to be equal to
107:03 - the note on delete is going to be equal
107:07 - to and then this is going to be the
107:09 - delete note function so it will call
107:11 - that with the ID we're then going to say
107:13 - the key is equal to the note. ID just so
107:16 - we don't get that error that we so
107:18 - commonly see where it says hey we need a
107:19 - key on all of our dynamically rendered
107:21 - elements so let's format this again and
107:26 - there we go okay so we're rendering
107:27 - notes however we need to import note so
107:29 - let's do that from the top of our
107:31 - program we can say import
107:35 - notes from dot do/
107:39 - component
107:41 - slote okay we're almost done here so
107:45 - let's bring this up and let's test this
107:46 - now so we're going to come here and
107:49 - refresh and it gives an an error here
107:51 - sorry it says Source comp components
107:53 - note. jsx does not provide exported
107:55 - named default okay let's fix that error
107:58 - so we're going to go back to note and we
108:00 - need to export this so we're going to
108:02 - say export default notes all right so
108:05 - let's go back to our front end and we
108:07 - can see now that the note is appearing
108:09 - if I refresh it works and I can delete
108:12 - it and notice it goes away now let's add
108:14 - a little bit of styling here and then
108:16 - that's going to pretty much wrap up the
108:17 - front end and then we can move on to the
108:19 - deployment okay so let's begin by
108:21 - styling the note to do that we'll just
108:23 - go to Styles we'll make a new one called
108:26 - note. CSS and while while while we are
108:29 - here excuse me I will do home. CSS and
108:33 - we're going to add a component called
108:34 - loading indicator so I'm just going to
108:36 - add that while we're here okay I'm going
108:38 - to go to note. CSS I'm just going to
108:40 - copy in all of the code again you can
108:42 - find this from the GitHub repository I
108:44 - don't like just writing a bunch of CSS
108:46 - in a video I find it's not very useful
108:49 - okay so that's for note for home let's
108:53 - copy in this okay again all this
108:57 - available from the GitHub and then
108:59 - loading indicator let me copy in this
109:02 - code paste it and format it okay so that
109:08 - is that for the Styles now we need to
109:10 - import it so from home. jsx we're going
109:12 - to import our Styles so we're going to
109:15 - import do/
109:17 - stylehome
109:19 - docss now let's go to the same thing for
109:22 - our
109:23 - what is this
109:24 - note okay and we'll import note. CSS
109:30 - okay let's go back here now and you can
109:31 - see that looks quite a bit nicer and now
109:34 - we can do
109:35 - hey what is up submit that note created
109:40 - and you see the note pops up we have our
109:41 - date delete button Etc okay last thing
109:45 - to do is add a loading indicator so for
109:47 - example if we go to slash log out in the
109:52 - logi when I press login I want to see a
109:54 - login kind of loading indicator when we
109:57 - are loading so to do that we're going to
109:58 - make a new component so inside of
110:00 - components we're going to say loading
110:04 - indicator like that do jsx we've already
110:07 - got the CSS written for it but now we're
110:10 - just going to write the component which
110:11 - is very straightforward so we're going
110:12 - to say import do do/ Styles SL loading
110:18 - indicator if we can type this indic
110:22 - indicator. CSS okay we're then going to
110:25 - say const loading indicator and this is
110:30 - going to be actually we make this as an
110:32 - arrow function okay then we're just
110:36 - going to return here a div for the div
110:40 - we're going to say class
110:41 - name is equal to loading container and
110:46 - then we're going to have a div and this
110:48 - is going to be class name is equal to
110:51 - loader and then we're just going to
110:53 - export
110:55 - default the loading indicator okay now
110:59 - we can use this anywhere that we want so
111:00 - we're going to go to our form and let me
111:03 - just make this a bit smaller inside of
111:05 - our form in between the last input and
111:08 - the button we're just going to write
111:10 - some conditional rendering here so we're
111:11 - going to say loading and and and then
111:14 - the loading indicator like that and we
111:17 - just need to make sure we import the
111:18 - loading indicator from the loading indic
111:20 - indicator component sorry so pretty
111:22 - straightforward
111:23 - we're just going to show the loading
111:24 - indicator when we're loading and then
111:26 - the CSS that I wrote um inside of the
111:28 - loading indicator file here will
111:30 - automatically do like the nice animation
111:32 - for us so if we go back here now you
111:35 - should see it kind of pops up here right
111:36 - while we're waiting for this Okay click
111:38 - okay and there you go the loading
111:39 - indicator component has now been written
111:42 - so with that said guys that is going to
111:43 - wrap up the front end at this point now
111:46 - we have the front and finished we have
111:47 - the backend finished everything is
111:48 - working on Local Host The Next Step here
111:51 - is going to be to deploy a database
111:53 - connect to the database and then we're
111:55 - going to deploy both the back end and
111:56 - the front end using coreo so let's go
111:59 - ahead and do that starting with our
112:00 - database all right so now that the front
112:02 - end and the back end are finished we're
112:04 - going to be deploying our database now
112:06 - as a reminder we're going to be using
112:08 - Coro to do that this is completely free
112:10 - they're also the ones that are running
112:11 - that challenge for the Cyber truck or
112:14 - the
112:14 - $100,000 so really follow along with
112:17 - these steps here if you want to make
112:18 - sure that you're eligible to enter that
112:20 - so what we're going to have to do here
112:21 - is go to the Coro website I'm leave a
112:22 - link to it in the description once
112:24 - you're here you got to create a new
112:26 - account or log into an existing one I'm
112:28 - going to do that please do that and then
112:30 - we'll be brought to a portal and I'll
112:32 - kind of show you how we create the
112:33 - database all right so once you sign into
112:36 - your Coro account you will be brought to
112:38 - the dashboard now from here you can do a
112:40 - lot of stuff and you can actually create
112:42 - a project but the first thing we want to
112:44 - do is just create the database
112:46 - integration after that we're going to
112:48 - make a project within that project we're
112:50 - going to create some components we're
112:52 - going to have our back end and our front
112:54 - end and we're going to use Coro to
112:55 - actually link these two together this is
112:57 - a really cool platform it's actually
112:59 - really fast to be able to spin up and
113:00 - deploy different applications best part
113:02 - is it's free when you're in the
113:04 - developer tier and obviously you can
113:06 - upgrade if you wanted to do more
113:07 - production ready deployments okay so
113:09 - what we're going to do is go to the
113:11 - dependencies tab on the left hand side
113:13 - of the screen and we're going to click
113:14 - on databases now it's going to bring us
113:17 - to this page right here and what we can
113:19 - do is we can create a new database now
113:21 - I'm just going to delete the one that I
113:22 - already have because I can only have one
113:24 - going at a time and this is going to act
113:27 - as a trial database uh it's not really
113:29 - meant to be production ready but it's
113:31 - just allowing you to mess with the
113:32 - features and try it out so it's a good
113:34 - thing to get some practice on how we
113:36 - actually deploy regular databases and
113:38 - how we connect to them from D Jango so
113:41 - what I'm going to do is create a new
113:42 - database I'm going to select post Christ
113:44 - SQL and for the name I'm just going to
113:47 - call this database you can call it
113:48 - whatever you want but make sure you
113:49 - select postris okay now you're only
113:52 - going to have one option here for the
113:54 - hosting the reason for that is because
113:56 - this is kind of like a free trial demo
113:58 - database under the developer tier so you
114:01 - can see you can try it out for free for
114:02 - seven days and then you'd have to
114:04 - recreate it if you wanted to keep using
114:06 - it so I'm going to go United States
114:08 - digital ocean and hobbyist plan here it
114:10 - says 3 cents per hour but don't worry
114:12 - you don't have to pay for it it is free
114:14 - and then it's going to create this
114:15 - service now it'll take a few minutes to
114:17 - spin up the database and one thing to
114:19 - know is that this is a trial database so
114:21 - it's going to be powered off every every
114:22 - hour so what that would mean is if it if
114:24 - it is powered off sory you got to come
114:26 - back here and just power it on manually
114:28 - but for development purposes this is
114:30 - totally fine so while this spins up what
114:33 - we're going to do is copy all of the
114:35 - values that we have here into an
114:37 - environment variable file in our uh what
114:40 - do you call this backend kind of python
114:43 - script or backend python project so
114:45 - let's set that up while this is creating
114:48 - so I'm going to go back here and I'm
114:49 - just going to close all of this and
114:51 - we're going to open up our backend
114:53 - directory and we're going to go to just
114:55 - the main kind of root directory here and
114:58 - we're going to create an EnV file so
115:00 - we're going to say dot EnV for the EnV
115:03 - file we're going to specify a few
115:04 - variables and then we're going to use
115:05 - the values from this page here as those
115:08 - values so the first variable we need is
115:10 - going to be our dbor host we're then
115:13 - going to have our dbor Port okay we're
115:17 - then going to have our dbor user and our
115:20 - dbor name
115:22 - and our password dbor
115:25 - PWD okay so now we're just going to take
115:27 - all the values from here and we're going
115:29 - to copy them into the corresponding
115:31 - variables so let's copy the host to
115:33 - start we're going to put a set of quotes
115:35 - and paste that in here for the port this
115:39 - is going to be
115:41 - 21510 so let's paste that over here for
115:45 - the user it's going to be this let's
115:47 - make sure we put that inside of quotes
115:49 - here and for the name it's going to be
115:52 - default
115:53 - DB and then we'll need to wait for the
115:56 - service to be created before we have
115:58 - access to the password and actually I'm
116:00 - just going to surround this in quotes
116:02 - because that's what I have in my demo
116:03 - project so I don't want to mess anything
116:05 - up okay so let's wait for this to finish
116:07 - it's going to give us the password we
116:08 - can click to view it and then we'll put
116:10 - it in the environment variable file and
116:11 - we'll be good to move on to the next
116:13 - steps all right so the service has been
116:15 - created here and I just copied the
116:17 - password and put it in my environment
116:18 - variable file now that we've created the
116:21 - database what we want to do is connect
116:22 - to it from D Jango and then we can
116:25 - provision it using pythons manage.py or
116:28 - what exists here inside of D Jango and
116:30 - then we can just use our application
116:31 - like we normally would except this time
116:33 - will'll be connected to a remote
116:34 - database so in order to do that we need
116:36 - to go into backend settings.py and we're
116:39 - going to go to the databases so where it
116:42 - says databases here what we're going to
116:44 - do is change a bunch of these things so
116:47 - where it says engine we're going to
116:49 - change the engine to be
116:50 - Jango in low lower case. DB doback ends.
116:57 - postgis SQL like that then for the name
117:01 - this is going to be the environment
117:03 - variable which is os. getet
117:06 - EnV and we're going to get the DB name
117:09 - now the reason why this works is because
117:11 - at the very top of our code we load in
117:14 - our environment variable file and we
117:16 - have all those variables in the EnV file
117:19 - so make sure they're there for this to
117:20 - work okay so now that we have the name
117:23 - the next thing that we need is the user
117:25 - so we're going to say the user is equal
117:27 - to os.
117:29 - getv and this is going to be the dbor
117:34 - user we then need the password the
117:37 - password is going to be
117:39 - os. getet EnV and this is going to be
117:43 - the dbor PWD for password we then are
117:47 - going to have the host and the host is
117:50 - going to be os. get EnV and this is
117:53 - going to be the host or the dbor host I
117:56 - should say and then lastly we need the
117:58 - port and the port is going to be os.
118:01 - getet en EnV and then dvore Port okay
118:05 - and let's make sure we have our commas
118:07 - so that's it that will configure our
118:09 - database so now that we have all of our
118:11 - environment variables loaded in we can
118:13 - actually connect to the database what we
118:15 - need to do now is let's bring up our
118:16 - terminal I'm going to stop running the
118:19 - back end here so let's stop that
118:22 - and for some reason I think we were
118:23 - getting an error where it was saying
118:25 - that this was typed wrong it was okay so
118:27 - I just spelled that incorrectly so let
118:29 - me fix that quickly and now what we're
118:31 - going to do is type Python manage.py
118:35 - and then migrate what this is going to
118:38 - do is connect to that remote database
118:40 - you're going to notice this will take
118:41 - quite a bit longer because we actually
118:42 - need to connect over the Internet we're
118:44 - not connecting locally so once this is
118:46 - finished I'll be right back okay so this
118:48 - code just finished running so now what
118:50 - we can do is type python manage.py and
118:53 - then run server and now our server will
118:56 - be running just like before and what we
118:58 - can do is we can go back here and we can
119:01 - start using our app as we normally would
119:03 - so now we're going to be in a new
119:04 - database so we'll need to make any
119:06 - accounts again so I'll make an account
119:09 - set the password okay you're going to
119:12 - notice it will take longer now because
119:14 - again we're connecting to that remote
119:15 - database not the local one so let's try
119:18 - to sign into our
119:20 - account okay log in
119:23 - let's wait and it should bring us to the
119:25 - homepage there you go we have the
119:26 - homepage and we could go and we could
119:28 - make our notes so now we're just
119:29 - connected to the remote database if we
119:31 - want to see the logs we can go and view
119:33 - it we can see metrics advanced settings
119:35 - all kinds of stuff here uh very useful
119:37 - and also super super easy to use if we
119:40 - want we can also gate access based on
119:42 - IPS all kinds of settings you can mess
119:44 - with here so now that we've deployed the
119:46 - database it's time to deploy the back
119:48 - end now to deploy the back end we first
119:50 - need to actually set up a git repository
119:53 - because Coro will be able to view the
119:54 - git repository read it and actually
119:57 - automatically respond to new commits and
119:59 - do automatic deployments and all kinds
120:00 - of cool stuff so we're going to go over
120:02 - to our code here and we're going to
120:04 - start setting this up to work for a git
120:06 - repository now to do that we're going to
120:08 - create a new file so we're going to make
120:10 - a new file called G
120:12 - ignore okay inside of the G ignore we're
120:15 - going to ignore the environment variable
120:17 - directory because or the environment uh
120:19 - what do you call it python virtual
120:21 - environment directory because we don't
120:22 - need that we're then going to go to
120:24 - front end and we're going to go to our
120:26 - get ignore and we're just going to add
120:27 - the EnV file because we don't want to
120:30 - include that in the git repo and we're
120:32 - going to go to backend and we're going
120:34 - to make a git ignore and inside backend
120:36 - we're going to ignore the EnV and the
120:39 - db.
120:42 - sqlite3 uh which we want to ignore as
120:44 - well okay now that we've done that we're
120:46 - just going to make a few deployment
120:48 - related files inside of our backend
120:51 - directory and and then we'll upload this
120:52 - to GitHub so we're going to start by
120:55 - doing a Coro folder now inside of Coro
120:58 - we're going to make a new file and this
121:00 - is going to be
121:01 - endpoints do yaml now this is where
121:05 - we're going to specify the endpoints
121:06 - that we want to deploy and then we want
121:08 - to expose from this specific component
121:11 - which is the back end now Coro obviously
121:14 - will look inside of this do Coro folder
121:16 - to find this configuration so we're
121:19 - going to write here the version which is
121:21 - 0. .1 we're then going to specify our
121:23 - end points now for the end points we're
121:26 - going to specify a name the name can
121:29 - just be rest API doesn't really matter
121:31 - what you call it and now we're going to
121:34 - specify a few other things so we're
121:36 - going to do the port the port is going
121:38 - to be
121:40 - 8,000 the context is going to be a
121:42 - single forward slash the type is going
121:46 - to be rest and the network visibility is
121:51 - going to be public now this is a basic
121:55 - configuration that Coro is going to look
121:56 - for when we're deploying a rest API the
121:59 - port obviously needs to match the port
122:01 - of our D Jango API which is 8,000 type
122:04 - of course is going to be rest because
122:06 - this is a rest API when we set the
122:08 - network visibility to public that means
122:10 - anyone will be able to view this we also
122:12 - could specify it as project or
122:14 - organization and then for the context
122:16 - this is the base path of the API that we
122:19 - want to expose in this case I just want
122:21 - to expose the entire one so I'm going
122:23 - with Slash okay and that's what you guys
122:25 - will use as well obviously there's a lot
122:27 - of details for this in the documentation
122:29 - on the Coro website you guys can check
122:32 - that out if you want to learn more about
122:33 - how to set up these configurations
122:34 - especially for something a bit more
122:36 - advanced now we also need to make one
122:38 - more file this will be the last one that
122:40 - we need to do and this is called the
122:42 - proc file and the proc file is going to
122:44 - specify the command to start executing
122:46 - our application and that command is
122:48 - going to be web colon and then python
122:51 - manage. pi and then run server and then
122:54 - it's going to be
122:55 - 0.0.0.0 Port
122:58 - 8,000 okay so exactly what we would
123:00 - normally do to execute our server except
123:03 - this time we're doing 0.0.0.0 which
123:05 - means run on any origin or on the public
123:08 - IP address of the server that we're
123:11 - executing on so this way it'll be public
123:12 - and anyone will be able to access it
123:15 - perfect so that's it for uh the kind of
123:18 - configuration now what we need to do is
123:19 - add this to GitHub so we're going to
123:21 - make a new git repository with the
123:23 - command get anit we're going to type G
123:25 - add Dot and then get commit hyphen M and
123:29 - then first
123:30 - commit okay so we just make a commit we
123:33 - are then going to change the branch so
123:35 - we're going to type git
123:37 - Branch hyphen M and then main this is
123:41 - going to change the branch from Master
123:44 - to main which we need to do when we push
123:45 - to get we're going to clear this and
123:48 - we're going to go over to get make a new
123:50 - remote repo and then add here and push
123:52 - this code to GitHub so I'm on GitHub
123:54 - here and I've just made a new repo
123:56 - called Django react full stack app it's
123:59 - important that we make this public
124:00 - because in the developer tier for Coro
124:02 - we can only have public repositories
124:04 - we're not going to add a read me we
124:06 - already have the repository set up we
124:08 - just need to add the origin and then
124:09 - push our code so we're just going to
124:11 - take this Command right here which is
124:13 - get remote add origin and we're going to
124:15 - move over here and paste this in our
124:18 - terminal okay we're then going to push
124:20 - this so get push
124:22 - - origin and then Main and this will
124:25 - push all of the code to the remote repo
124:27 - so we can then start setting up our
124:29 - deployment okay so let's go back here
124:31 - and let's refresh we'll see here when we
124:34 - refresh we get all of our code popping
124:35 - up now what we can do is go back here to
124:39 - Coro and we can go to the overview tab
124:42 - so now that all of this is set up on
124:43 - GitHub we're going to create a new
124:45 - project in Coro now to do that you can
124:48 - go to the overview Tab and then click on
124:49 - create project or you can go up here
124:51 - here and make a new project so I'm going
124:53 - to click on create project I'm going to
124:55 - call this D Jango react tutorial and I'm
124:58 - going to use the mono repo because we
125:00 - just have one repo that contains all of
125:02 - our project code so we're going to go
125:04 - next and we're going to authorize this
125:05 - with GitHub now you're going to have to
125:07 - go through a few steps here to authorize
125:09 - it it's very straightforward just give
125:10 - it access to your repos then what you're
125:13 - going to need to do is go to the GitHub
125:15 - repository and select the one you want
125:18 - so in my case it's Jango react full
125:20 - stack app now here you can select the
125:22 - branch I've selected main cuz that's the
125:24 - only branch that I have but you could
125:26 - set up a separate deployment branch and
125:27 - that would probably be a good idea so
125:30 - let's go next and notice that it's
125:31 - actually automatically going to detect
125:33 - our different components now I want to
125:35 - show you how we manually create them so
125:37 - I'm just going to click on create for
125:38 - now it's going to go ahead and make the
125:40 - new project and then we can add the
125:42 - components ourself so let's go ahead and
125:44 - do that the first thing we're going to
125:46 - do is add a new service the service is
125:48 - going to be for our rest API so I'm
125:50 - going to click on service here
125:52 - and for the component name I am going to
125:54 - go with the back end and for the
125:58 - description we'll just leave it empty
125:59 - and I'm going to select python as my
126:01 - build pack now for the python directory
126:03 - I'm going to select backend okay and for
126:06 - the language version I'm going to go
126:08 - with
126:08 - 3.10 so let's go ahead and click create
126:11 - and notice there's a bunch of other
126:12 - services you could make here okay so
126:14 - Coro is going to automatically go ahead
126:16 - and make this backend service for us and
126:19 - while it does that I'm going to create
126:20 - the front-end service now for the front
126:22 - end service we're going to go with a web
126:24 - application for the name this is going
126:26 - to be the front end and for the build
126:28 - pack this is going to be react now for
126:31 - the project directory this is going to
126:33 - be the front end okay and for the build
126:36 - command this is going to be npm install
126:40 - and npm run built we're then going to
126:44 - have the build path as/
126:46 - D this is where the output file will go
126:50 - when we actually build this
126:52 - application then for the node version
126:54 - we're going to go with 20.0 you can go
126:56 - with any version you want really I think
126:58 - as long as it's high enough but 20.0
127:00 - should be fine okay so that should be
127:02 - good that's going to create the front
127:05 - end component for us and now what we'll
127:07 - need to do is build each of these
127:09 - components and then deploy them now
127:12 - there's a few other steps as well
127:13 - obviously but this is pretty
127:14 - straightforward and it's actually pretty
127:16 - impressive how fast we can get this
127:18 - deployed out okay so let's go back to
127:21 - our back end we can do that by just
127:23 - selecting the service up here and from
127:25 - our back end we're going to go to the
127:27 - build tab now you'll notice that there's
127:29 - a bunch of other tabs here right like
127:31 - usage insights observability devops
127:33 - testing the API deploying managing right
127:36 - it's got everything you can imagine now
127:38 - what we can do is build latest or we can
127:40 - view the different commits and we can
127:41 - build a specific commit in our case we
127:43 - just want to build latest so we're going
127:45 - to click on build latest we're going to
127:47 - wait for a little bit it should build
127:49 - the latest version of this and then we
127:50 - can go ahead and deploy it and we can
127:52 - test the API all right so the build has
127:54 - just completed and now what we'll do is
127:56 - go over to deployment now from
127:59 - deployment we can deploy the build you
128:01 - also will have noticed from the build
128:02 - tab we have the option to Auto deploy if
128:04 - we enable that as soon as a build is
128:06 - finished or actually as soon as a new
128:08 - commit is made on our Branch it will
128:10 - automatically build it and then deploy
128:12 - it now you can see that what we can do
128:14 - here is configure and deploy so if I
128:17 - click on this it gives me the option to
128:18 - actually Mount some environment
128:20 - variables now that's what I'll do now
128:22 - because remember we need to pass the
128:24 - environment variables for our database
128:27 - configuration so what we can do is add a
128:29 - bunch of environment variables in this
128:30 - case it's just allowing us to do one so
128:32 - I'm actually going to do it another way
128:34 - I'm just going to click on next we have
128:35 - the option to file Mount uh endpoint
128:38 - details here this is fine we can go
128:40 - ahead and deploy that and once this
128:42 - first version is deployed it's going to
128:44 - give us the option to configure some
128:46 - secrets so I'm going to click on manage
128:47 - config in secrets and here I'm going to
128:50 - click on Create and then I'm going to
128:51 - going to go secret and environment
128:52 - variable now the reason this is secret
128:54 - is because I don't want anyone to be
128:55 - able to view this once it's been created
128:57 - this is going to be the data to connect
128:59 - to my database now what we'll do here is
129:02 - just add the different environment
129:03 - variables that we need that match what
129:05 - we had in our local repo I'm going to
129:07 - call this EnV and then what I'm going to
129:09 - do is go back to my code here I'm going
129:12 - to go find my environment variable file
129:15 - which is this and I'm going to copy all
129:16 - of these values over so let me do that
129:18 - and I'll be right back all right so I've
129:20 - added all of these values and notice
129:22 - that I'm not used quotation marks for
129:24 - any of them I'm just adding them as
129:25 - plain text inside of here I have my host
129:28 - Port user name and password the exact
129:30 - same as I had from the environment
129:32 - variable file in my local repository
129:34 - what I'm going to do now is press on
129:36 - create this is going to add the
129:38 - environment variables as Secrets now if
129:40 - you want to edit them you'll have to
129:42 - actually read all of the values because
129:44 - you can't view the contents anymore
129:46 - we'll go back to deploy and within
129:48 - deploy now it should automatically
129:50 - redeploy with those environment
129:51 - variables so now what will happen is our
129:54 - API will be deployed if we want to view
129:56 - the end points we can view them right
129:58 - here we can see the project URL and the
130:00 - public URL however the public URL is
130:03 - automatically going to be protected from
130:05 - coreo now the way that this works is
130:08 - that Coro is automatically going to add
130:10 - an API key that we need to pass in order
130:13 - to access this URL so if I just try to
130:16 - go to the URL in fact I can do that just
130:18 - to show you you'll notice that it's not
130:20 - going to work so if I go to the public
130:21 - URL and I paste it in here it's just
130:24 - going to tell me hey like you don't have
130:25 - the correct security credentials to be
130:27 - able to view this now that's intentional
130:29 - because Coro will automatically protect
130:31 - your apis for you and if you want to
130:33 - disable the protection which is what
130:35 - we're going to do you need to do that
130:37 - manually so what we're going to go to
130:38 - now is the settings page within manage
130:42 - sorry for the quick cut here but I do
130:44 - need to quickly jump in because the
130:45 - website has changed a little bit since I
130:47 - filmed this video so I just want to show
130:49 - you quickly how to get to the correct
130:51 - page page so that none of you are lost
130:53 - so in the video what you're going to see
130:54 - me do is go to this manage Tab and then
130:56 - for manage go to settings now that's no
130:58 - longer available and instead what you're
131:01 - going to need to do is go to the deploy
131:03 - Tab and then simply click on endpoint
131:05 - configurations from this point forward
131:07 - all of the settings and all of the
131:09 - instructions I give you are the same
131:11 - simply do them from this page rather
131:13 - than the page you're seeing in this
131:15 - video now from here what we're going to
131:17 - do is change the API visibility to be
131:20 - public now we want this to be public so
131:22 - that anyone can access this API and use
131:24 - it to interact with our application now
131:27 - as well as that we're going to go and
131:29 - press on edit now from edit we're going
131:31 - to change some of the settings here by
131:33 - disabling the application Level security
131:36 - Now this tells you exactly what it does
131:37 - this option determines the type of
131:39 - security that will be used to secure the
131:40 - API an API can be secured with either
131:42 - ooth or any other available security
131:44 - type or it can be secured with both of
131:45 - them if oo 2 option is selected relevant
131:47 - API will require a valid oo 2 token for
131:50 - successful in if so we want to disable
131:53 - that because we already have our JWT
131:55 - tokens and for this example it's going
131:56 - to be a little bit complex to have this
131:58 - enabled so what we'll do is disable this
132:01 - and press on Save when we do that what's
132:04 - going to happen now is that when we try
132:06 - to access the API we will actually be
132:09 - able to send a request to it whereas
132:10 - before we would need to pass an API
132:13 - token and that would add kind of some
132:15 - more code changes which I don't want to
132:16 - make at this point because we've already
132:18 - done quite a few changes so now that
132:20 - we've changed our settings what we're
132:21 - going to do is go back to the deploy Tab
132:24 - and if you haven't already just redeploy
132:26 - the API to make sure the new settings
132:28 - are applied now we can go view the
132:30 - endpoints and if we take the public URL
132:33 - and we paste it in here we can see if
132:34 - this is working or not or if we get any
132:36 - issues now in this case it just says bad
132:38 - request which is fine because it means
132:39 - we were actually able to access the API
132:42 - but what happened was we didn't have a
132:44 - security um what do you call it issue
132:46 - like we had before right so here we just
132:48 - access a route that didn't exist but if
132:50 - I go to something like / API SL token we
132:53 - can see if that one's going to load and
132:55 - in this case it gave us some connection
132:57 - error which tells me there's probably
132:58 - some issue with the database connection
133:00 - so let's actually go check that quickly
133:02 - the way we can do that is we can go to
133:04 - observability and we can go to metrics
133:07 - and we can actually see all of the logs
133:09 - for what's happening with our
133:10 - application so let's go here give it a
133:13 - second to load and see what we're
133:14 - getting we can also see the throughput
133:16 - the latency and some other issues or not
133:19 - other issues other stats I guess which
133:20 - are meaningful
133:22 - okay so when we go here it just says
133:24 - that we're not able to connect to the
133:25 - database so what most likely happened is
133:27 - the database just turned off because
133:28 - it's been an hour so let me return the
133:30 - database back on and in fact I'll show
133:32 - you how we do that so what I can do is
133:34 - get out of this project go to
133:36 - dependencies databases and we'll see if
133:39 - that was the culprit and it was you can
133:41 - see the database is powered off so what
133:43 - I'm going to do is just power on this
133:45 - service it's going to take a second to
133:46 - power back on and we'll go back into our
133:49 - application so Jango re act tutorial
133:52 - we'll just give it a minute to power
133:53 - back on we'll go into our components
133:56 - we'll go into our backend and we'll just
133:58 - redeploy this as soon as the database is
134:00 - powered back on and we should be good to
134:03 - go and uh actually able to well interact
134:05 - with the application and the API all
134:07 - right so the database is powered back on
134:09 - so let's just redeploy our app here to
134:12 - make sure that everything is all good
134:14 - we'll wait for that to finish and then
134:16 - what we can do is go to the endpoint and
134:18 - we can test this again just to see if
134:20 - everything is functioning now assuming
134:22 - the back end is working then the next
134:24 - step is to deploy the front end once we
134:26 - have the front end deployed we just need
134:27 - to connect it to the back end and once
134:29 - the two are connected we'll have a fully
134:31 - deployed application and you'll actually
134:33 - have a project that you can submit to
134:35 - the Coro wso2 challenge to potentially
134:38 - win the cybertruck don't forget about
134:40 - that so now our back end has been
134:41 - successfully deployed and it's time to
134:43 - move on to the front end so what we're
134:46 - going to do is make a new component
134:47 - we're going to go to the front end
134:49 - component I should say and from the
134:50 - front front end now we're going to go to
134:52 - build we're going to build the latest
134:55 - version of our front end and once this
134:57 - is built we're going to check out the
134:58 - front end then we're going to connect it
135:00 - to the back end so the front end has
135:02 - been built we could enable auto deploy
135:04 - if we want but I'm just going to go over
135:06 - to deploy and now we will deploy this
135:09 - now there's a few settings that we need
135:10 - to change first of all so we're going to
135:12 - go to authentication settings and we're
135:14 - going to disable the managed
135:15 - authentication with Coro as I talked
135:17 - about before we're not using the
135:19 - authentication for this specific app
135:21 - however if you were building this from
135:23 - the ground up and you wanted to use the
135:24 - authentication from Coro obviously you
135:26 - would enable this and they have some
135:27 - really good documentation that shows you
135:30 - how to handle off using the Coro
135:32 - platform they can do user authentication
135:34 - they can do application Level
135:35 - authentication it's very interesting so
135:37 - I definitely recommend checking it out
135:39 - but just for this app since the whole
135:40 - point was to look at JWT tokens in
135:42 - Django we don't need this feature so I'm
135:45 - going to click on deploy and now that
135:47 - we've disabled that it's going to deploy
135:49 - this it's going to take a second
135:51 - and once this has been deployed we
135:53 - should see the front end working so
135:55 - let's click on this web app URL uh and
135:58 - we're getting a not found error okay so
136:01 - let's give it a second here because it
136:02 - probably just needs a minute to spin up
136:04 - let's go to it again and not found okay
136:07 - let me look at the issue here and I will
136:09 - be right back all right so I just had to
136:11 - deploy the app and wait a second and
136:13 - there we go we now see that we have our
136:15 - front end and this is deployed we can go
136:18 - to register if we try to go to something
136:21 - that doesn't exist we'll get that not
136:23 - found page we can go back to register
136:27 - here but you'll notice that if I try to
136:29 - actually use this to make a new account
136:31 - it's not going to work now and the
136:32 - reason it doesn't work is because we're
136:34 - not connected to the back end so let's
136:36 - now go with the connection and then that
136:37 - we'll wrap up this video so in order to
136:39 - make the connection here what we need to
136:41 - do is go to dependencies and then
136:43 - connections now what Coro can do which
136:46 - is really interesting is actually deploy
136:48 - our backend on the same origin as our
136:51 - front end or at least allow us to make
136:53 - the request on the same origin so that
136:55 - we don't need to be interacting with
136:57 - something that's outside of this origin
137:00 - which is actually quite useful for a lot
137:01 - of applications so you're going to see
137:03 - that I clicked on create there and what
137:05 - I'm going to do is use my backend rest
137:07 - API so I'm going to go backend rest API
137:09 - here going to select that we'll just
137:11 - call this backend as the connection name
137:14 - and click on create now that we've done
137:16 - this you're going to see a bunch of
137:18 - instructions on the right hand side for
137:20 - how to do this action now this is if you
137:22 - were using the authentication handled by
137:24 - coreo in our case we are not so we don't
137:26 - need to follow the steps on the right
137:28 - hand side but if you are again check out
137:30 - these steps the authentication is a very
137:32 - useful feature especially if you don't
137:34 - build it in yourself like we have with
137:36 - Jango so what we're going to do here is
137:38 - copy this service URL now this service
137:41 - URL is hosted on the same domain as our
137:43 - front end which means we can send
137:45 - requests to this and then whatever we
137:48 - add afterwards is the API route that
137:50 - will be be redirected to so the way that
137:53 - we're going to do this is we're going to
137:54 - go back to our repository here I'm just
137:57 - going to close all of this and I'm going
137:59 - to go to my front end directory and to
138:01 - api.js now all I'm going to do is I'm
138:04 - going to say const API URL is equal to
138:08 - and I'm going to paste this root in here
138:11 - now notice I'm not putting a different
138:12 - domain I'm just putting the path that
138:14 - will Bey on the same domain now what I'm
138:17 - going to do is I'm going to look for the
138:18 - presence of this environment variable
138:20 - file if it exists I'm going to use
138:22 - what's inside of there otherwise I'm
138:24 - going to use the API URL now let me just
138:27 - format this so it's a bit easier to read
138:30 - so what this will do now is it will use
138:32 - this when we're in the deployed
138:34 - environment which is the connection that
138:35 - we need to our backend so what we can do
138:38 - now is we can make a new commit so we
138:42 - can say get add Dot and then get commit
138:45 - hyphen M add backend URL and then we can
138:49 - type get push origin Main and we can
138:53 - make a push now what we'll need to do is
138:55 - just redeploy the front end with this
138:56 - new commit and what will happen is now
138:59 - the front end will make a request to its
139:01 - same origin with this slash URL as the
139:04 - base URL and then it will add the API
139:07 - path afterwards so we'll go to like API
139:10 - SL token or register or whatever the
139:12 - URLs are so that's it that's really all
139:15 - we have to do for the connection it's
139:17 - quite easy I'm pretty impressed with how
139:19 - Coro has been able to handle this and
139:21 - what we can do is go back to build now
139:23 - and we can go to build latest so let's
139:25 - view the commits first of all okay we
139:27 - have the backend URL so let's go with
139:30 - build latest and build that out okay so
139:34 - our front end is now built so let's go
139:36 - back to deploy and let's deploy the new
139:39 - version
139:40 - here okay so that's going to take a
139:42 - second to deploy and once that's
139:43 - finished everything should be good to go
139:46 - fingers crossed obviously things can go
139:48 - wrong but if that's the case we could go
139:49 - and we could check out the logs we can
139:51 - use all of the tools that Coro has built
139:53 - into the platform now let's go to the
139:56 - web
139:57 - URL okay there we go we have V plus
139:59 - react let's go to SL register and make a
140:02 - new
140:03 - account okay so we got to spell register
140:06 - correctly though okay so let's go with
140:09 - new
140:11 - user and then we'll go with a password
140:15 - here okay good sign that's taking a
140:18 - second to load that means it's probably
140:20 - connected to the remote database okay so
140:22 - that account was created so now let's
140:24 - try to log into this okay and then we
140:28 - should be able to view our notes okay so
140:31 - stop telling me to change my password I
140:32 - know it's very weak that's fine so let's
140:34 - make a new note say new note test
140:37 - content let's submit that should take a
140:41 - second here the note should be added
140:43 - then we'll be able to view them delete
140:45 - them Etc now I know there's a little bit
140:46 - of latency it's just because of the
140:48 - database that we're using so it takes a
140:49 - second to make all all of those
140:51 - operations uh but if you're using one
140:53 - that was actually deployed that wasn't
140:55 - kind of the trial or like the temporary
140:57 - test database obviously this would be a
140:59 - lot faster all right so the new note has
141:02 - been added here and we can see that all
141:04 - of the functionality is working properly
141:06 - I guess the last thing we can do is log
141:07 - out and when we do that brings us back
141:09 - to the login page and then we can log in
141:12 - with another account so there you go we
141:13 - now have a fully deployed application
141:16 - completely for free by the way that you
141:18 - could now use to enter this cyber truck
141:20 - giveaway so with that said guys I'm
141:22 - going to wrap up the video here all of
141:24 - this code will be available on GitHub so
141:26 - you can simply download it from the link
141:28 - in the description you can modify it
141:30 - tweak it whatever you need to do a big
141:32 - thank you to Coro for sponsoring this
141:33 - video and for hosting that giveaway make
141:35 - sure you check out the platform more and
141:37 - you enter that giveaway again you have a
141:39 - chance to win a cyber truck or
141:41 - $100,000 and then there's going to be 10
141:43 - other people that are picked to win a
141:45 - MacBook Pro 14in with a M3 chip wrap it
141:49 - up here guys I hope you enjoyed enjy if
141:50 - you did leave a like subscribe to the
141:52 - channel and I will see you in the next
141:55 - [Music]
142:01 - one