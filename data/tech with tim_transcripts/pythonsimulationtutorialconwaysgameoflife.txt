00:00 - in this video I'll show you how to
00:02 - create the famous simulation known as
00:04 - Conway's Game of Life now this is a very
00:06 - interesting cellular simulation in which
00:08 - each cell you see on the screen has a
00:10 - few rules applied to it I'll go through
00:12 - those rules in one second but cells can
00:14 - either be recreated they can die or they
00:17 - can remain on the screen this is a very
00:19 - interesting project that I'll show you
00:21 - how to build in Python using pi game not
00:24 - overly complicated and you can finish
00:25 - this in under an hour or whatever the
00:27 - length of the video is all of the code
00:29 - for this will be available in the
00:31 - description in case you want to check it
00:32 - out without actually going through the
00:34 - tutorial anyways let's go through the
00:36 - rules of the game rule number one is
00:38 - that in a live cell so the yellow cells
00:40 - you see right here that have fewer than
00:42 - two live neighbors will die now that's
00:44 - due to underpopulation rule number two
00:47 - is a live cell with two or three live
00:49 - neighbors will remain alive this is
00:51 - known as survival rule 3 a live cell
00:54 - with more than three live neighbors dies
00:57 - and that's due to overpopulation or
00:59 - overcrowding
01:00 - rule 4 this is the last rule a dead cell
01:03 - with exactly three live neighbors
01:05 - becomes alive that's reproduction now
01:08 - with these rules you can see that we get
01:10 - these really interesting shapes and
01:11 - patterns and there's been all kinds of
01:13 - research and studies related to this
01:15 - game where you can create some really
01:16 - interesting objects the way I've set it
01:18 - up here is that you can actually add
01:19 - cells onto the screen you can delete
01:21 - them by clicking on them we have a few
01:23 - keystrokes that I've added here that
01:25 - will automatically generate some cells
01:26 - for us really interesting project I hope
01:29 - you stick around to build it with me
01:30 - with that said let's go ahead and get
01:32 - started after a quick word from our
01:34 - sponsor thanks to taipai for sponsoring
01:37 - this video If you're looking for an
01:39 - all-in-one solution for building and
01:41 - deploying web applications in Python
01:43 - typi has you covered taipi is an open
01:46 - source python library for building web
01:48 - applications you can make the front end
01:50 - back end and deploy web applications
01:52 - with ease forget learning Advanced CSS
01:55 - and JavaScript instead use Simple syntax
01:58 - to create multiple page dashboards and
02:00 - and front ends with only Python and
02:02 - augmented markdown at the same time
02:05 - Taipei is designed to build powerful and
02:07 - customizable data-driven back-end
02:09 - applications it provides components to
02:11 - organize and manage data through
02:12 - pipelines and dataflow orchestration
02:14 - each pipeline execution is referred to
02:17 - as a scenario scenarios are stored
02:19 - recorded and actionable enabling what-if
02:22 - analysis or kpi comparison type is
02:25 - designed to rapidly reduce your
02:27 - development time and provide all the
02:28 - functionalities you need to build and
02:30 - deploy entire applications get started
02:33 - with taipi and their open source package
02:35 - from the link in the description alright
02:37 - so as we get into the video here I want
02:39 - to quickly go over the rules one more
02:40 - time in a graphical setting just so
02:42 - everyone understands exactly what we
02:44 - need to do to implement this so I just
02:46 - pulled up a website that has kind of a
02:48 - great explanation here that you can read
02:49 - through so pause the video if you want
02:51 - to have a look at it but you can see
02:52 - that each cell with one or a one or no
02:55 - neighbor sorry dies as by Solitude and
02:58 - then each cell with four more neighbors
02:59 - dies as as if by overpopulation each
03:02 - cell with two or three neighbors Will
03:04 - Survive and for a space that is empty or
03:06 - unpopulated if it has exactly three
03:08 - neighbors it will become populated so it
03:10 - shows you a few examples here with the
03:11 - visuals just wanted to kind of pop that
03:13 - up in case you guys want some more
03:15 - explanation anyways what we'll be doing
03:17 - is implementing this the first thing
03:18 - we'll need to do is Implement a grid
03:20 - system we'll then need to add a way to
03:22 - actually add in these different cells
03:24 - and kind of generate them randomly then
03:26 - we'll start adjusting the grid by
03:28 - applying these different rules we're
03:29 - really cool what ends up happening here
03:31 - let's go ahead and start building this
03:33 - alright so I've just cleared my python
03:35 - file and we're going to begin writing
03:36 - this code now the first thing we need to
03:38 - do is install pygame pygame is a 2d
03:40 - Graphics library that we'll be using for
03:42 - this simulation very straightforward you
03:44 - don't need to know anything about it
03:45 - I'll explain to you everything you need
03:47 - in this video so to install Pi game
03:49 - we're going to Simply type pip
03:51 - install and then Pi game here in our
03:54 - terminal if you're on Mac or Linux
03:56 - you're going to do pip 3 install Pi game
03:58 - if that doesn't work I will leave two
03:59 - videos on the screen that will show you
04:01 - how to install pie game that's really
04:03 - all the setup we need now we can start
04:05 - setting up our PI game window which will
04:07 - be responsible for the simulation so
04:09 - we're going to begin sorry at the top of
04:11 - our program by importing Pi game we are
04:14 - then going to say pygame dot init we're
04:16 - going to initialize the modules so we
04:18 - can use it we're going to start now by
04:20 - actually adding a few different colors
04:21 - so we're going to say black is equal to
04:24 - zero zero zero these are RGB color codes
04:27 - that we're going to use throughout the
04:29 - rest of the program so I'm going to
04:31 - Define all of the constants that we need
04:32 - at the top of the screen and then as we
04:34 - go through we'll kind of write the rest
04:36 - of the code next we are going to have
04:38 - gray now gray can be a bunch of
04:41 - different colors but I'm going to go
04:42 - with 128 128 128 again the amount of red
04:45 - green and blue that's what we're doing
04:47 - for the colors lastly we're going to
04:49 - have yellow now yellow is going to be
04:51 - 255 255 0 whenever you're writing RGB
04:54 - the maximum value is 255 the minimum
04:57 - value is zero okay so now we have the
04:59 - three colors that we can use next we're
05:00 - going to set up some dimensions for our
05:02 - grid and for our screen so I'm going to
05:04 - say with comma height is equal to and
05:07 - we're going to go with 800 800. now you
05:10 - can adjust this if you want but I
05:11 - recommend you make it even numbers that
05:13 - are divisible by the next variable here
05:15 - which is going to be our tile size now
05:18 - the tile size is the size of one
05:20 - individual tile in this case it will be
05:21 - 20 that means it's going to be 20 pixels
05:23 - by 20 pixels if you want to make it
05:25 - larger go ahead and do that again I just
05:27 - recommend you make it evenly divisible
05:29 - by the width and the height so it's a
05:31 - little bit easier or kind of looks
05:33 - better on the screen next we're going to
05:35 - Define our grid underscore width here
05:39 - now the grid width is going to be equal
05:40 - to the width integer divided by the tile
05:43 - size this is just the number of tiles
05:44 - that we'll have in our grid remember
05:46 - we're creating a grid but we have pixels
05:48 - on the screen so we need to kind of make
05:50 - the grid based on the pixels
05:52 - next we're going to have grid height
05:54 - grid height is going to be the height
05:56 - divided by the tile size
05:59 - lastly we're gonna have an FPS this FPS
06:02 - is going to be 60 meaning we have 60
06:04 - frames per second if you wanted to
06:05 - increase this you can but another
06:07 - variable again that we need okay now
06:09 - that we have our constants we're going
06:11 - to define a screen now the screen is
06:13 - where we're going to do all of our
06:14 - python drawing or our PI game drawing so
06:16 - I'm going to say screen is equal to Pi
06:18 - game dot display dot set underscore mode
06:21 - and inside a tuple here I'm going to
06:24 - pass the width and the height that I
06:26 - want this screen to be so this is how
06:27 - you initialize a new Pi game window
06:29 - again you just pass the width and the
06:31 - height that you want inside of a tuple
06:32 - to this set mode that's going to
06:35 - actually pop up a screen for us and now
06:37 - what we need to do is create a clock and
06:40 - then implement the main Loop I'll
06:42 - explain this more in depth in a second
06:43 - but for now we're going to say clock is
06:45 - equal to Pi game dot time dot clock and
06:49 - now we're going to set up what's known
06:50 - as the main Loop now whenever we're
06:52 - working in pi game we have an event Loop
06:54 - or a main Loop this is something that's
06:56 - running constantly that's checking for
06:57 - things like button presses key key
06:59 - presses adjusting the grid for us for
07:02 - example so this is where a lot of the
07:03 - core logic will be called from will
07:05 - separate it out into different functions
07:07 - but we always have this main Loops
07:09 - that's what we need to write first so we
07:10 - can actually see something appearing on
07:12 - the screen right
07:13 - so what we'll do here is we'll Define a
07:16 - main function where we'll place the main
07:17 - Loop for now we're going to say running
07:19 - is equal to true and then we're going to
07:22 - say while running this is going to be
07:25 - our main Loop inside of here we're going
07:27 - to say clock dot tick and we're going to
07:30 - tick the FPS now what this will do is
07:32 - regulate the speed of this while loop so
07:34 - that it only runs a maximum of the FPS
07:36 - times per second so since we have 60 FPS
07:39 - this means that this Loop will run a
07:42 - maximum of 60 times per second if you're
07:44 - on a very slow computer it could run
07:46 - less than that but this will make it so
07:48 - at maximum it runs at this speed so that
07:50 - if you have a really fast computer like
07:51 - I do here the simulation doesn't run
07:53 - insanely fast okay now what we need to
07:56 - do is simply handle an event when a user
07:58 - attempts to quit the screen or quit the
08:01 - game so we're going to say it for event
08:02 - in pygame.event dot get
08:05 - now this is where you can actually Loop
08:07 - through all of the events that have
08:08 - occurred since the last frame so this
08:11 - will run 60 times per second and handle
08:13 - all of our different events the one
08:15 - event that we want to handle right now
08:16 - is if the user exits out of the window
08:19 - so we're going to say if event.type is
08:21 - equal to pygame.quit in all capitals
08:24 - then we're going to say running
08:26 - is equal to false that will then stop
08:29 - this while loop from running and then we
08:31 - will go down here and we'll write Pi
08:33 - game
08:34 - dot quit which will close the window for
08:36 - us so as soon as the while loop is
08:38 - finished we simply quit okay that's
08:40 - great now we're simply going to call
08:42 - this main function so we're going to say
08:43 - if underscore underscore name is equal
08:45 - to underscore underscore main then we
08:48 - will call Main now what this does is
08:50 - ensure that we are only going to call
08:52 - this main function if we are directly
08:54 - running this python file that's because
08:57 - you could be importing say a function a
08:59 - module a class whatever it may be from
09:01 - this file into another file and if we
09:04 - were to do that without having this line
09:06 - then it would actually start running the
09:07 - simulation we don't want that we only
09:10 - want to run the simulation when we
09:11 - directly execute this python file not if
09:14 - this python file is imported by another
09:16 - file okay so now what we're going to do
09:19 - is go to our terminal or however you
09:20 - want to run your python code I'm going
09:22 - to say Python main.pi and notice a pi
09:25 - game window pops up it's 800 by 800
09:27 - pixels that's the width and the height
09:29 - that we set if we hit on the x button it
09:31 - closes the window that's what we
09:33 - implemented with this event right here
09:35 - perfect the next thing we need to do is
09:37 - draw our grid so what we'll do is create
09:39 - a function called Draw grid
09:42 - now inside of draw grid we're going to
09:45 - take actually a set of positions now
09:48 - this will be a good time for me to kind
09:49 - of explain how we're going to go about
09:51 - actually implementing this so what we're
09:53 - going to do is we're going to have a set
09:54 - and this set is going to contain all of
09:56 - the positions of cells that are alive
09:58 - now we'll do this so that we can very
10:01 - easily access all of those positions
10:03 - without having to Loop through every
10:05 - grid position when we're trying to
10:07 - update it as we go through and kind of
10:09 - perform the simulation you'll see what I
10:11 - mean in a second but this is very
10:12 - efficient because this means we only
10:14 - actually look where cells are alive and
10:17 - then check the neighbors around those
10:18 - cells rather than looking at every
10:21 - single position in the grid where most
10:23 - of those positions will be unfilled so
10:25 - when we draw our grid we're going to
10:26 - draw our grid lines
10:28 - then we're going to draw the cells that
10:31 - are alive kind of inside of those lines
10:33 - right so essentially a bunch of squares
10:35 - will be drawn inside of the grid lines
10:37 - hopefully that makes a bit of sense but
10:39 - that's kind of how we'll go about it so
10:40 - with that said we're going to go down
10:41 - here we're going to say positions is
10:43 - equal to a set in Python just so we have
10:45 - that defined and now we'll go inside a
10:48 - draw grid and we'll start by just simply
10:49 - drawing the grid lines and then we'll
10:51 - draw the different positions so to draw
10:54 - the grid lines is fairly straightforward
10:55 - we're going to need however many rows
10:57 - and however many column lines we have
10:59 - going both horizontally and vertically
11:02 - so we can start in any order that we
11:04 - want but I'm going to start with my rows
11:06 - so I'm going to say four row in range
11:09 - and then the range of this is going to
11:10 - be our grid height
11:12 - now what we'll do is we'll draw lines
11:15 - for every single row that we have in our
11:17 - grid right which is the height of our
11:18 - grid so to do that we're going to say hi
11:21 - game dot draw dot line
11:24 - now the first argument to this function
11:26 - right here is going to be the screen
11:27 - that we want to draw the line on so in
11:29 - this case we want to draw it on our
11:30 - screen right we could actually have a
11:32 - subsurface or a nested surface which is
11:34 - why this argument exists but I'm not
11:36 - going to get into that in this video
11:37 - next we need to define the color that we
11:39 - want to draw now we Define the color in
11:41 - RGB you can actually pass a string here
11:43 - as well but I like to use RGB because
11:45 - it's more flexible so I'm going to pass
11:47 - black which is my RGB color code here
11:49 - for well black right zero zero zero next
11:52 - you pass the starting position and the
11:54 - ending position where you want to draw
11:55 - this line so the first position we want
11:58 - to draw this line is the following well
12:00 - it's going to be 0 and then the row so
12:03 - whatever row we're currently on in our
12:04 - iteration
12:05 - multiplied by and then this is going to
12:08 - be the tile size so the way this is kind
12:11 - of going to work is when we're on row 0
12:12 - will we draw a line at the very top of
12:14 - the screen when we're on Row one then
12:17 - we're drawing a line 20 pixels down
12:19 - right because we take one and we
12:20 - multiply that by the tile size which is
12:22 - 20 and then on this side for for the
12:24 - other position we draw the line going to
12:26 - the entire width of the screen which we
12:28 - have defined and then same thing row
12:31 - multiplied by the tile size so the x
12:34 - coordinates are always staying the same
12:36 - for our line because we want to go from
12:37 - one side of the screen to the other but
12:39 - the x coordinate or the y coordinate
12:41 - sorry is going downwards as we draw
12:43 - right so we're drawing every single row
12:46 - now this would be a good time to mention
12:47 - that in pi game we use a zero zero
12:50 - coordinate system in the top left hand
12:52 - corner of the screen a little bit
12:53 - different than some other programs that
12:55 - means that 0 0 is top left so as you go
12:58 - down your y increases and as you go to
13:00 - the right your X increases so keep that
13:03 - in mind y increases as you go down
13:05 - that's the opposite of a lot of other
13:07 - grid systems where Y is going to
13:09 - increase as you go up okay so it's the
13:10 - opposite here in pi game all right
13:12 - that's our row and actually before we go
13:14 - any further let's just look at what
13:16 - that's doing so we're going to kind of
13:18 - write a function here that says draw a
13:19 - grid we'll just pass it this empty
13:22 - position set for now and if we run on
13:24 - this uh the script here so let's go
13:27 - and run this uh well we don't have a
13:30 - background that's different than black
13:31 - so we're not seeing any lines but it
13:33 - should actually be rendering those lines
13:34 - so what we'll do now is we'll change the
13:36 - background color to Jane to change the
13:39 - background color sorry we're going to
13:40 - say screen dot fill and we're going to
13:42 - pass the color we want to fill this in
13:44 - now I want the background color to be
13:45 - gray so I'm going to say screen dot fill
13:47 - gray what this will do is fill in the
13:49 - entire screen with gray and then draw
13:51 - the grid okay now actually that reminds
13:54 - me that one thing we need to do is we
13:56 - need to put this inside of the while
13:58 - loop because I just realized it's not
13:59 - inside of here hence why nothing is
14:01 - happening and we need to update the
14:03 - display after we draw
14:06 - okay so silly mistake there we're going
14:08 - to say pygame.display.update
14:10 - inside of the while loop which I messed
14:12 - up there so now we fill the screen with
14:14 - gray we then draw the grid line and then
14:18 - we update the display whenever you want
14:19 - to actually take any of the changes or
14:21 - drawing events that you've done and put
14:23 - them onto the screen you run this update
14:25 - command and any of the draws that you've
14:27 - done will automatically be applied to
14:28 - the screen okay now these draws are also
14:30 - in an order that means that if I fill
14:32 - the screen gray and then I draw the grid
14:34 - lines the grid lines go on top of the
14:36 - gray screen if I did this in the other
14:39 - order that means that I would actually
14:40 - go over top of my grid lines here and I
14:43 - would not be able to see them because
14:44 - I'd be filling the screen after I drew
14:46 - the grid lines hopefully that makes
14:48 - sense but that's kind of how that works
14:50 - so if we run this now you can see that
14:51 - we get our horizontal grid lines the
14:54 - next thing we need to do is do the
14:56 - vertical ones so the vertical ones are
14:57 - going to be the exact same thing except
15:00 - just in the other direction so let's
15:01 - copy this and let's change this to B4
15:04 - call in Grid width and now what we want
15:07 - to do is be drawing lines where we're
15:09 - changing the x coordinate but we're not
15:10 - not changing the y coordinate so for the
15:12 - y coordinate we're going to have 0 and
15:15 - we're going to have the height of the
15:16 - screen because we're always drawing from
15:18 - the top to the bottom and what changes
15:19 - now is the x coordinate we'll reset call
15:22 - multiplied by the tile size
15:25 - and then we do the exact same thing over
15:28 - here okay
15:29 - so now we've changed this just to be
15:31 - adjusted for columns so if we go here
15:33 - and run this you see that we get our
15:35 - beautiful grid okay now that we have the
15:37 - grid what we'd like to do is actually
15:39 - start drawing positions within the grid
15:41 - and to be able to do that we need to
15:43 - kind of be able to create these
15:45 - positions so let's make it so that we
15:47 - can actually click down on the screen
15:48 - create the positions and then draw them
15:51 - onto the screen now we can go in any
15:53 - order we want but I actually will start
15:55 - by drawing them just so that once we
15:56 - actually get that code down for creating
15:58 - them we can see them so we have these
16:00 - positions now our positions are going to
16:02 - be in the following format row column or
16:04 - actually we're going to do column row
16:06 - okay so kind of like X Y now this is not
16:09 - going to tell us actually the pixel
16:12 - positions it's going to tell us what
16:14 - kind of uh what do you call it position
16:16 - in the grid right so it's going to give
16:18 - us a column Row in the grid not the
16:21 - pixel location so what we'll do is
16:23 - translate the column in row to the pixel
16:26 - location and then draw the position
16:29 - so we're going to say four position
16:31 - in positions
16:33 - okay so we're going to Loop through this
16:35 - set we're going to say call row is equal
16:37 - to position so we're just kind of
16:39 - decomposing this into its two components
16:41 - and now we need to figure out the top
16:43 - left hand corner where we want to draw a
16:46 - rectangle
16:47 - um kind of in this grid box so whenever
16:49 - you draw something in python or in pi
16:51 - game Sorry you draw it from the top left
16:53 - hand corner so I want to figure out the
16:55 - top left hand corner of the grid box
16:58 - little Cube where I want to be drawing a
17:00 - square so to do that I'm going to say my
17:02 - top left is equal to and very simply
17:05 - we're just going to take the column and
17:07 - we're going to multiply it by the tile
17:09 - size and we're going to take the row and
17:12 - again we're going to multiply that by
17:13 - the tile size as well now we're going to
17:15 - draw a rectangle so we're going to say
17:17 - Pi game dot draw dot rectangle and to
17:20 - draw a rectangle again we pass the
17:21 - screen we pass the color we want to draw
17:24 - it in this case it's going to be yellow
17:25 - we're then going to pass an asterisk and
17:28 - top left and then we're going to say
17:30 - comma tile size tile size now what we're
17:33 - passing here is a rectangle object now
17:36 - this asterisk will actually take the two
17:39 - different kind of objects we have here
17:40 - the two different what you call these
17:43 - elements column times tile size and row
17:45 - times tile size and it will just kind of
17:47 - write them out as if they were
17:49 - individual values inside of this Tuple I
17:52 - know this seems a bit weird but this is
17:54 - called unpacking so I'm unpacking the
17:56 - values so that they would kind of be
17:58 - written like this right tile size tile
18:00 - size I know seems a little bit weird but
18:03 - just bear with me here I wanted to show
18:04 - you a bit more advanced python syntax in
18:06 - case you haven't seen that it just
18:08 - treats them as their individual
18:09 - arguments inside of the Tuple not a
18:12 - tuple being passed here then I'm passing
18:14 - the tile size and the tile size which is
18:16 - going to be the width and the height so
18:17 - it goes the X Y width height and what
18:20 - you're doing there is specifying the top
18:22 - left hand corner and then the width and
18:23 - the height of the rectangle you want to
18:25 - draw
18:25 - okay so that's it that will now draw the
18:28 - positions if we want to test that we can
18:30 - just add a position into the set here so
18:31 - we can do something like 10 10 and now
18:34 - if we go ahead and run our code we
18:35 - should see a position appearing on the
18:37 - screen uh we got an issue here says
18:38 - cannot unpack non-iterable int object uh
18:42 - okay not sure why I'm getting that error
18:46 - there it says row call position ah so
18:49 - this is a bit of an issue the way that I
18:52 - just put this inside of the set it's
18:54 - actually treating each 10 as an
18:56 - individual 10 not as a tuple kind of
18:59 - annoying that if that's the case but we
19:01 - can actually fix this by just writing
19:02 - Tuple like that and actually no I don't
19:05 - think that's going to fix it uh to fix
19:06 - it we can do this sorry
19:09 - positions.add
19:11 - and then we can add a position like 10
19:13 - 10 and now it will actually add the
19:15 - Tuple it won't just add two tens which
19:18 - is why we're getting that issue so let's
19:20 - rerun here and now you can see we have
19:22 - that position appearing on the screen
19:23 - okay that's great so now that we have
19:26 - that the next thing that we want to do
19:27 - is we want to make it so we can click
19:29 - down on the screen and have a position
19:31 - appearing so we're going to go inside of
19:33 - this event Loop here
19:35 - and we're now going to check for the
19:36 - event which is the mouse button down so
19:38 - we're going to save event.type is equal
19:41 - to pygame dot mouse button down all
19:45 - capitals no spaces and this means you
19:47 - pressed any Mouse so like Left Right
19:49 - middle button doesn't matter what we're
19:51 - going to do is we're going to capture
19:52 - the position of the mouse and then we're
19:54 - going to figure out what row column you
19:56 - pressed on and then we're going to add a
19:58 - position for that so we're going to say
20:00 - X Y is equal to Pi game dot mouse dot
20:04 - get underscore position
20:05 - and now we need to translate a pixel
20:08 - position to the column and the row that
20:10 - you clicked on to do that is kind of the
20:13 - opposite of going from row call to pixel
20:15 - right we're going to say column is equal
20:17 - to X integer divided by the tile size
20:20 - and we're going to say row is equal to Y
20:22 - integer divided by the tile size okay so
20:25 - if we know every single tile is 20
20:27 - pixels if I'm at say 40 40 then I would
20:29 - be at position 2 2 right because I'm in
20:32 - that second kind of grid uh hopefully
20:35 - that makes sense but that's how you
20:36 - figure out what row column you're in
20:38 - we're then going to say the position is
20:40 - equal to column row like that and now
20:43 - what we just need to do is first check
20:45 - if the position already exists in the
20:47 - set if it does that means that we're
20:49 - actually going to remove it because if
20:51 - we're clicking on a tile that exists in
20:53 - the set we'll just remove it from the
20:54 - set if it doesn't exist there then we'll
20:56 - add it so we're going to say if the
20:57 - pause is in the positions another
21:00 - benefit of using this set is that you
21:01 - can look this up in Big O of one or
21:03 - constant time complexity and we're going
21:05 - to say positions dot remove and then
21:08 - pause another constant time complexity
21:10 - operation otherwise we're going to say
21:12 - positions dot add and then pause if
21:16 - you're unfamiliar with time complexity
21:17 - don't worry about it my point is just
21:19 - this is my much much faster than working
21:21 - with an array so we can support a much
21:24 - larger grid by writing code in this way
21:26 - okay so there we go we now will actually
21:28 - be able to press these down onto the
21:30 - screen at least if I didn't make any
21:32 - mistakes so let's bring this up and
21:34 - let's start clicking and you can see
21:36 - that we have some positions now we can't
21:38 - click and drag that would be a different
21:40 - implementation but for now this is fine
21:42 - although it looks like when I press on
21:44 - them it doesn't actually remove them so
21:47 - we might have an issue there let's look
21:49 - at why we're getting that problem ah so
21:51 - this is a silly issue but I had is
21:53 - instead of in here so that was never
21:56 - actually uh triggering true so just
21:58 - change that from is to in I was thinking
22:00 - like is in but it's just in my apologies
22:03 - there guys if we run now
22:05 - you can see now we can actually remove
22:06 - our positions okay great so that is most
22:10 - of the user input handled next thing
22:12 - we'll do is just make it so we can clear
22:14 - the screen and so we can randomly
22:16 - generate some positions just so we don't
22:17 - have to constantly write them out write
22:19 - them out ourselves sorry so what we'll
22:21 - do now is We'll add another event down
22:23 - here and we'll say if event.type is
22:25 - equal
22:26 - to pygame dot key down then we're going
22:29 - to check for a few different Keys now
22:30 - the first key will be the clear key the
22:33 - second key will be the generate key and
22:35 - then we'll have the space bar which will
22:37 - allow us to pause and play the
22:38 - simulation so actually we can go in a
22:41 - slightly different order uh excuse me
22:43 - here we're going to say if event.key is
22:45 - equal to pygame.k underscore space
22:48 - obviously this is checking if you
22:50 - pressed the spacebar key down then what
22:53 - we're going to do is we're actually
22:53 - going to set a variable here called
22:56 - playing
22:57 - we're going to make that equal to false
22:58 - and we're going to go here and we're
22:59 - going to say playing is equal to not
23:01 - playing now all this will do is toggle
23:04 - this playing variable so that we are
23:06 - either pausing or playing the simulation
23:08 - that's it that's all that the space key
23:10 - will do next we're going to say if event
23:12 - dot key is equal to Pi game dot k
23:16 - underscore C notice this is a lowercase
23:18 - C this time what we're going to do is
23:20 - clear the screen to clear the screen
23:22 - we're going to say positions is equal to
23:24 - a set so we're just going to create a
23:25 - new set that'll just remove everything
23:27 - that was in the existing set and then
23:29 - we're going to say uh sorry that's
23:31 - coming a little bit later uh playing is
23:33 - equal to false so we just pause the
23:35 - simulation after you clear lastly we
23:38 - want to randomly generate a bunch of
23:40 - positions if you press the G key now you
23:43 - can pick whatever key you want for this
23:44 - but I'm going to go with G so I'm going
23:45 - to say if event.key is equal to pygame.k
23:48 - underscore G then I'm going to say that
23:51 - positions
23:53 - is equal to I'm going to call function
23:55 - gen inside of gen I'm going to specify
23:58 - how many positions it is that I actually
24:01 - want to generate now I want this to be
24:03 - random so I'm going to say random dot
24:05 - Rand range and this is going to be 2 to
24:08 - 5 multiplied by the grid width now I
24:14 - know we haven't actually defined all of
24:16 - this yet just bear with me for one
24:17 - second first of all go to the top of the
24:19 - screen here
24:21 - import random so we have access to that
24:23 - random module there and then we're going
24:25 - to make this gen function now the idea
24:27 - is again I'm passing the number of
24:28 - unique positions that I want to generate
24:30 - okay
24:31 - so now
24:33 - we're going to go to gen and we're going
24:34 - to write this function so we're going to
24:35 - say Define gen
24:37 - we're going to take in a number and all
24:39 - we're going to do is generate that
24:41 - number of random positions
24:43 - to do that we're going to return a set
24:45 - inside of the set we're going to have a
24:48 - list the list is going to have a tuple
24:51 - and the Tuple is going to say random Dot
24:54 - randrange
24:56 - and we're going to pass 0 as the start
24:58 - index and as the stop Index this is
25:00 - going to be the grid underscore width
25:03 - and then for actually sorry it says to
25:06 - be grid height
25:08 - and then we're going to do the same
25:09 - thing again random dot randridge this is
25:12 - going to be zero and grid width
25:15 - okay and then we're going to say four
25:17 - underscore in range and then number let
25:22 - me zoom out so we can actually read this
25:23 - so how does this work well what we're
25:25 - doing is we are creating a list here
25:27 - this list is going to contain a bunch of
25:30 - random positions in a tuple so what
25:32 - we're doing is using something known as
25:34 - a list comprehension we're first
25:35 - generating a random position in the y
25:38 - direction okay so for the row so we're
25:40 - picking a random one between zero and
25:42 - the grid height because that's all
25:43 - that's valid same thing here we're
25:45 - picking a random one for the X position
25:46 - now between zero and grid width and then
25:49 - we're doing this for underscore this is
25:52 - just a placeholder variable you could
25:53 - put I here if you want but since we're
25:55 - not actually going to use the variable
25:56 - I'm just putting underscore in range and
25:59 - then number okay so we're just creating
26:01 - this number of random positions for
26:04 - whatever the num is that we pass to this
26:05 - function now why I'm converting this to
26:08 - a set is that what's going to end up
26:09 - happening here is all of these um values
26:12 - here they could potentially overlap now
26:14 - a lot of times they won't but it is
26:16 - possible that I generate the exact same
26:18 - random position well I don't want to
26:19 - have duplicated positions so we just
26:21 - convert it to a set and that's going to
26:23 - remove any of the duplicates for us plus
26:25 - we need to set anyways so now positions
26:28 - will work and if we press this key we
26:30 - should actually generate those random
26:31 - positions so let's give this a shot here
26:33 - and see if I press G you can see that it
26:35 - randomly generates a bunch of positions
26:37 - for us if we want more of them we can go
26:39 - down here and we can just kind of change
26:41 - these numbers around a little bit so
26:42 - maybe four to ten right because it's
26:44 - going to be random
26:46 - multiply by the grid width and now you
26:48 - see we get a lot more positions
26:49 - appearing on the screen now while we're
26:52 - at it let's try the c key notice C works
26:55 - it just clears the screen and there we
26:57 - go okay
26:58 - so now that we've done that we want to
27:00 - start updating the grid now updating the
27:03 - grid is not overly complicated but it is
27:05 - kind of the most logic intense part of
27:06 - this application
27:08 - so we're going to write a few functions
27:09 - here
27:10 - first this is going to be adjust
27:12 - grid and what this is going to take in
27:15 - is positions okay
27:17 - and we're going to write another
27:18 - function here and this is going to be
27:19 - Define
27:21 - get underscore neighbors like that
27:24 - and this is going to take in a position
27:25 - and this is going to return an array or
27:27 - a set containing all of the neighbors of
27:29 - that position now remember that what
27:32 - we're doing here is we're looking at
27:33 - every single um kind of cell and we're
27:36 - saying okay does this cell exist does it
27:39 - get deleted and then if there's a cell
27:42 - that is not alive we have to see okay
27:43 - should this become alive based on the
27:45 - neighbors of those positions we'll go
27:48 - over the rules again don't worry and
27:49 - obviously we'll be coding them out but
27:51 - it's important that for every single
27:52 - position we look at we need to know all
27:55 - of the neighbors of that position we
27:56 - need to know if they are in a live cell
27:58 - or not and if it is a live cell then we
28:01 - need to check okay how many live cells
28:03 - are you neighbors with based on that
28:05 - value we either delete you we keep you
28:07 - or we potentially create a new cell in
28:10 - one of those neighboring positions all
28:12 - right so let's go to adjust grid now
28:14 - again the way we're doing this is we're
28:16 - only looking at positions that could
28:18 - potentially have any update to them that
28:21 - means that I don't actually Loop through
28:22 - the entire grid I just Loop through the
28:24 - positions which are live cells
28:26 - so what I'm going to do is say all
28:28 - underscore neighbors is equal to a set
28:31 - and I'm going to say my new underscore
28:34 - positions
28:36 - is equal to a set now the reason I need
28:38 - this is whenever I make any updates I'm
28:40 - making it based on the current frame or
28:43 - the current set of live cells that means
28:46 - that I need a new set that I put all of
28:48 - my new cells into which will exist at
28:51 - the next step because if I try to update
28:53 - the existing set while I'm kind of doing
28:56 - this update step I could potentially
28:59 - kind of mess up how things are working
29:00 - because I'm going to be deleting and
29:02 - adding cells which will then change how
29:04 - the other cells react I'm not sure if
29:06 - that makes sense to you or not but I
29:08 - can't
29:09 - kind of make the update in the same
29:11 - position set I need to use a new set for
29:13 - all of my updates so that those updates
29:15 - don't affect the other cells that I've
29:16 - yet to have a look at now that's why we
29:18 - have new positions why do we have all
29:20 - neighbors well the reason I have all
29:22 - neighbors is that I need to potentially
29:24 - check for the Neighbors of any live
29:26 - cells if they should become a live cell
29:29 - right I don't need to check ones that
29:31 - are really far away that don't have any
29:33 - live cell neighbors but any cell that
29:35 - has at least one live neighbor I'm gonna
29:37 - put inside of here because then I'm
29:39 - going to check if it needs to become a
29:40 - live cell okay so first what we're going
29:43 - to do is simply see if we need to delete
29:45 - or keep existing cells so we're going to
29:48 - say four position
29:50 - in positions
29:52 - okay and what we're going to do is get
29:54 - all of the neighbors of this position so
29:55 - we're going to say Neighbors
29:57 - is equal to get neighbors and we're
29:59 - going to pass this position we're going
30:01 - to write Neighbors in one second or that
30:03 - function for now though imagine this
30:05 - gives us all of the neighbors now what
30:07 - I'm going to do is say all neighbors dot
30:09 - update
30:10 - neighbors what this will do is take this
30:13 - list of neighbors and it will pass them
30:15 - all into this set if any of those
30:17 - neighbors already exist which is very
30:19 - possible if they will not be duplicated
30:21 - because they're inside of a set
30:22 - so now that we have all of the
30:24 - neighboring positions the next thing
30:26 - that we need to do is check if these
30:28 - neighbors are alive or not because what
30:30 - get neighbors will do for us is just
30:31 - return the coordinates or the row column
30:34 - of all of the neighbors of Any Given
30:36 - cell so now we're going to do some
30:38 - pythonic syntax here and we're going to
30:40 - say neighbors is equal to a list
30:43 - that is filtered using the filter
30:45 - function now this filter is going to be
30:47 - quite easy we're going to say Lambda X
30:48 - we're going to say X in positions like
30:52 - that and then we're going to pass here
30:53 - the neighbors okay what did we just do
30:56 - well I wrote what's known as an
30:58 - anonymous function all this is doing is
31:00 - acting as a filter function that
31:02 - essentially means that we're going to
31:03 - take this list of neighboring positions
31:05 - and we're going to Loop through them and
31:07 - we're going to pass every single one of
31:08 - those positions to this function so that
31:11 - they're going to be passed as the
31:12 - parameter X we're then going to ask is x
31:15 - in positions so is this position a live
31:17 - cell
31:18 - if it is then we're going to keep that
31:21 - position inside of this filtered list if
31:23 - not we're going to remove it so what
31:25 - happens is filter actually gives us
31:27 - something known as an iterator we don't
31:29 - want that we want a list
31:30 - so we're going to convert filter to a
31:32 - list and now we're good to go that might
31:34 - be a little bit more information that
31:35 - you need but essentially this just
31:37 - filters the neighbor positions and gives
31:39 - us only the ones that are alive which is
31:41 - what we care about so now
31:43 - we can say if the Len of our filtered
31:45 - neighbors here is in
31:49 - 2 or 3 meaning it's equal to two or
31:52 - three just just a shortcut to do that
31:54 - then what I'm going to do is say new
31:56 - positions dot add and I'm going to add
31:59 - this position so all I'm saying is here
32:01 - is okay well if this position based on
32:03 - the current positions has enough live
32:06 - neighbors so it has two or three then
32:08 - we'll keep it for the next round so
32:10 - we'll add that into our new positions
32:11 - that's it that's all we have to do here
32:13 - now if we don't add it we are kind of
32:15 - implicitly deleting it because well if
32:17 - we don't add it it's not going to exist
32:19 - in new positions after this right
32:20 - perfect so that is it for kind of
32:23 - handling the positions or the cell story
32:25 - that we're going to be keeping or not
32:27 - keeping now what we need to do is see if
32:29 - there's any cells that we need to create
32:31 - right or that need to become alive so to
32:33 - do that we're going to say for position
32:36 - in all neighbors so now we're looping
32:38 - through all of the neighbors of the live
32:40 - cells that's why we collected them so we
32:43 - could Loop through them now we're going
32:44 - to say
32:45 - neighbors is equal to get neighbors of
32:49 - and this is going to be the position
32:51 - right so now I want the neighbors of
32:53 - what were the neighbors of all of the
32:55 - live cells I know a little bit
32:56 - overwhelming but that's what we want now
32:58 - similar to this we're going to filter
33:00 - this I probably could make this a
33:02 - separate function but it's fine we're
33:03 - just going to copy this in here so again
33:05 - we're now going to look and say okay
33:06 - well which one of these neighbor
33:07 - positions are alive we're going to get
33:10 - all those and then we're going to check
33:11 - the following we're going to say if the
33:13 - length of neighbors is equal to 3 then
33:16 - we're going to say new underscore
33:18 - positions dot add and we're going to add
33:20 - the current position which will create a
33:23 - new live cell lastly we're going to
33:26 - return the new neighbors or the new
33:28 - position sorry
33:30 - okay so that's it for adjust grid we
33:32 - need to write the get neighbors function
33:34 - and then we're actually pretty much done
33:35 - with this code other than just calling
33:37 - these functions and stepping through a
33:39 - few things quick let's recap what I did
33:41 - just because this is the most complex
33:42 - logic that we've had given it's not that
33:44 - complicated but you get the idea we have
33:46 - all neighbors right storing all of the
33:48 - neighbors of all of the live cells from
33:51 - the current set of positions new
33:53 - positions this will be what is updated
33:55 - after we kind of run this whole update
33:57 - Cycles this is what we'll see at the
33:58 - next step
33:59 - here we go through all the positions
34:01 - these are live right these are the live
34:03 - cells and we say okay let's get the
34:06 - neighbors of that live cell this gives
34:08 - us all of those neighboring coordinates
34:10 - right so all eight potential neighbors
34:12 - of that position
34:13 - we're then going to say all
34:14 - neighbors.updates we're going to put
34:15 - that in there so we can use them later
34:17 - we're going to filter the neighbors so
34:19 - we only get the live cells and we're
34:21 - going to say if the length of the live
34:23 - cells that our neighbors is two or three
34:25 - then that's good we're going to keep
34:26 - this position that's it
34:29 - down here what we're doing is looping
34:31 - through all of the neighbors now of the
34:33 - live cells we're checking their live
34:35 - neighbors and we're saying if they have
34:37 - exactly three live neighbors well we
34:39 - need to make this cell become alive so
34:41 - we do that and then finally we return
34:42 - new positions once we write get
34:44 - neighbors this will put it all into
34:46 - perspective how do we get the neighbors
34:48 - well we have eight neighbors right we
34:49 - have top left hand corner uh kind of top
34:52 - middle top right the middle to the right
34:54 - middle right or bottom right I guess uh
34:57 - bottom middle bottom left and then like
35:00 - the left middle side uh you know what I
35:03 - mean right if you're looking at a grid
35:04 - one position you have eight potential
35:05 - neighbors diagonally and um what do you
35:08 - call it horizontally and vertically so
35:09 - what we're going to do is say X Y is
35:12 - equal to position
35:14 - okay so we're going to break this down
35:15 - because again remember we're passing a
35:16 - tuple here that contains the column and
35:18 - the row so we'll just denote that with X
35:20 - Y we're going to say neighbors is equal
35:22 - to a list and we're going to say 4
35:25 - DX in negative one
35:30 - comma 0 comma one this is one uh kind of
35:33 - more creative approach to get the
35:34 - neighbors we'll explain this in one
35:36 - second
35:36 - four d y in negative 1 0 1 and this
35:41 - stands for displacement in X and
35:43 - displacement in y okay so continuing
35:45 - here we are going to say if DX is equal
35:49 - to zero and the Y is equal to zero then
35:53 - just continue now the reason for that is
35:55 - that if we have no no displacement in X
35:57 - and no displacement in y then we're
35:59 - looking at the current position which we
36:01 - don't want to look at but the way that
36:02 - I'm writing this we just need this
36:04 - little check here okay so we just press
36:06 - continue there or say continue next I'm
36:09 - going to say neighbors dot append and
36:11 - I'm going to append X plus the
36:12 - displacement in X and then y plus the
36:15 - displacement in y now again notice we
36:17 - have negative 1 0 1 meaning that as we
36:19 - Loop through this we have nine
36:21 - iterations one of those iterations won't
36:23 - count which is the center position so
36:25 - all of those other eight iterations will
36:27 - give us every single combination of
36:28 - neighbors right so we have like negative
36:30 - 1 in The X which is moving left and then
36:32 - that would be combined with negative 1
36:33 - and the Y 0 and the Y and one in the Y
36:36 - which would give us all those positions
36:37 - uh to the kind of furthest left side
36:40 - then zero okay that's in the middle same
36:42 - thing negative one zero one one that's
36:44 - to the right negative one zero one okay
36:46 - only thing we need to do here is just
36:47 - make sure we don't handle a position
36:49 - that's off the screen to do that we just
36:51 - say if DX
36:53 - Plus or actually if X plus the x is less
36:59 - than zero or X plus the x is greater
37:02 - than the grid width then we will
37:04 - continue and we'll copy this exact same
37:07 - thing and we'll put this here but we'll
37:09 - just check it with Y okay so we'll say
37:10 - if y plus d y
37:12 - or Y plus Dy is greater than the grid
37:16 - height all right just making sure that
37:17 - we don't have any positions that are
37:19 - going off of the screen uh so we don't
37:21 - get any index out of bounds exceptions
37:22 - or any kind of issues related to that
37:24 - but we don't end up generating the
37:25 - simulation that we can't actually see
37:27 - which would be kind of silly okay so now
37:30 - we have get neighbors and we're going to
37:31 - return the neighbors list and that is
37:34 - going to do pretty much most of the code
37:36 - that we need okay so now that we have
37:38 - that what we want to do is actually
37:40 - start calling these functions now
37:42 - remember we kind of have this pause
37:43 - state right I have playing so either
37:45 - we're playing or we're not playing now
37:47 - we also need to kind of keep track of
37:49 - what step we are on or at least how
37:52 - often we want to update the screen so we
37:54 - could update the screen every one second
37:55 - every two seconds every three seconds
37:57 - you can kind of pick but what I'm going
37:58 - to do here is say step is equal to zero
38:01 - or actually this would be a better
38:03 - variable we'll say count is equal to
38:04 - zero and we're going to say the count
38:06 - underscore frequency
38:09 - or really we could call this update
38:12 - frequency is equal to 120. now what I'll
38:15 - do is at the very top of my code here
38:18 - I'm going to say if we are playing
38:21 - then my count
38:23 - plus equals 1. so this is saying okay if
38:26 - we're in the play mode if we actually
38:28 - are activating the simulation we're
38:30 - going to add one to our count now that
38:31 - will happen to maximum almost 60 times
38:33 - per second right so that means that
38:35 - every second account is going to go up
38:37 - by 60. so now what we'll do is we're
38:39 - going to say if the count is greater
38:42 - than or equal to the update frequency
38:44 - which is 120 which means two seconds
38:46 - then we're going to reset the count to
38:49 - be equal to zero and we're going to say
38:51 - our new positions are equal to the
38:54 - adjustment of the grid
38:56 - passing the original positions because
38:59 - again remember this is returning new
39:01 - positions which will be the new ones
39:02 - that we want to see so we simply set our
39:04 - position set equal to those new
39:07 - positions that are returned from our
39:08 - adjusted grid function
39:10 - there you go that's pretty much all we
39:13 - need a few other Smite slight tweaks we
39:15 - can make for example if we decide to
39:17 - clear the screen we can just reset our
39:19 - count so we can say count is equal to
39:21 - zero here uh so it's not kind of stuck
39:23 - at something and lastly we can just add
39:26 - a caption onto the screen here that
39:28 - tells us if we are paused or playing so
39:30 - that we know so we're going to say hi
39:32 - game dot display dot set underscore
39:35 - caption and we're just going to say
39:38 - playing
39:40 - if playing
39:42 - else
39:44 - paused
39:45 - okay so this is an inline if statement
39:47 - and this will just allow us to again
39:49 - either show playing if we're playing or
39:51 - show paused if it is paused so we get
39:53 - some feedback now it's possible I made
39:55 - an error or two here but let's zoom out
39:57 - for a second I'll kind of slowly scroll
39:59 - through in case you guys need access to
40:01 - this
40:01 - obviously the code will be available in
40:03 - the description as well
40:05 - okay kind of there you go
40:08 - now let's run this
40:10 - and make sure it works okay so let's
40:13 - generate and let's press the play button
40:16 - notice it says playing and we should see
40:18 - that we start to get the kind of game
40:20 - running and there you go the simulation
40:22 - is running
40:23 - okay so as we run the simulation uh
40:26 - while it's playing I can do things right
40:28 - like I can remove them I can add stuff
40:29 - in I can kind of do whatever I want I
40:31 - can press G and just have it like
40:33 - continue to go
40:34 - right and I can also press C and I can
40:36 - clear it just keep in mind that you know
40:39 - playing and pausing up here it's kind of
40:40 - a little weird like if you're generating
40:42 - while you're playing through it but that
40:44 - works you can do that I set up that way
40:46 - okay so I think with that said that's
40:48 - gonna wrap up this video there's
40:49 - actually a lot shorter than I thought it
40:51 - was going to be uh and yeah that kind of
40:53 - covers everything that we needed so if
40:55 - you guys enjoyed make sure you leave a
40:57 - like subscribe to the channel let me
40:59 - know if you enjoyed the simulation and
41:00 - you want more and I look forward to
41:02 - seeing you in another YouTube video
41:04 - [Music]
41:07 - foreign
41:08 - [Music]