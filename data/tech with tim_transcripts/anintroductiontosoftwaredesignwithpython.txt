00:00 - hello everybody and welcome back so in
00:01 - this tutorial what we're gonna do is
00:03 - talk about software design now software
00:05 - design is a fundamental concept in
00:07 - computer science in programming and
00:09 - creating applications or projects and
00:11 - something that I know a lot of people
00:13 - don't ever learn or they don't ever
00:15 - formally learn it now the purpose of
00:17 - this tutorial is gonna be to give you a
00:18 - general introduction to what software
00:21 - design is and show you some of the tools
00:23 - and tricks that you can use in Python to
00:24 - better write and write cleaner code so
00:27 - this is gonna help you a ton especially
00:29 - when it comes to debugging and to
00:30 - designing programs and I'm gonna
00:32 - hopefully kind of engrave in your brain
00:34 - the way that you should be thinking
00:36 - about actually writing code so this is
00:38 - really designed for people that have
00:39 - kind of moved from the beginner stages
00:41 - and now are now trying to jump into
00:42 - their own projects or trying to do some
00:44 - more complex things this is the next
00:47 - step that you really need to master and
00:49 - you're gonna notice that what ends up
00:51 - happening is you get better and better
00:52 - and programming is that the coding
00:54 - itself is not actually very difficult
00:55 - but what is very difficult is when
00:57 - you're working in large projects how you
00:59 - actually structure organize and write
01:01 - your code so what I mean by write your
01:03 - code is in which method do you do it
01:05 - it's not about can you get the task done
01:07 - it's about how well do you get the task
01:09 - done how organized is the codebase can I
01:12 - jump in there and read your code and be
01:13 - able to modify and use it very
01:15 - intuitively and that's hopefully what
01:17 - I'm gonna start to introduce to you guys
01:18 - here I know this has been a long
01:20 - introduction but stick with me for
01:21 - another few seconds because these next
01:23 - parts are important so I'm actually
01:25 - teamed up with Manning for this video
01:27 - now Manning publishing has a ton of
01:28 - different books on their website I'm
01:30 - gonna pop it up here so you guys can see
01:32 - and what we're gonna be doing for a few
01:33 - pieces of content on this channel is
01:35 - they've actually given me access to some
01:36 - great books that I would like to read
01:38 - from their website I'm gonna be taking
01:39 - some small snippets from the book and
01:41 - some things making some notes on them
01:43 - and then presenting that to you guys
01:44 - here now if you would like to learn
01:46 - software design more in-depth obviously
01:48 - you can purchase this book there will be
01:49 - an affiliate link in the description as
01:51 - well as a discount code but just full
01:52 - disclaimer I read the few chapters of
01:55 - this book beforehand I think it's very
01:56 - good I haven't read the entire thing and
01:58 - that's where I'm taking some of this
01:59 - content from and it's kind of a
02:01 - reference for this video
02:02 - alright so practices of the Python pro
02:04 - again link in the description alright so
02:07 - let's go ahead and get started with
02:09 - software design now what I want to do is
02:11 - just introduce to you a few differ
02:13 - pieces of code and I want to talk about
02:15 - why software design is important before
02:17 - we get into actually learning how to
02:18 - really do this so let's have a look at
02:21 - example one here I just have some code
02:22 - that I've written already and
02:24 - essentially the goal of this program is
02:26 - to print a list of words delimited by
02:28 - commas
02:29 - now delimited just means separated by
02:31 - and you can see that this is the first
02:33 - solution that I've come up with and
02:34 - there's many different ways to do this
02:35 - so I have my list of words hello yes
02:38 - goodbye last and then I say list of
02:40 - words 0 plus comma plus list of words 1
02:42 - plus comma plus list words 2 so on so
02:45 - looking at this can we determine and
02:47 - take a second to think to yourself what
02:49 - might be wrong with this piece of code
02:50 - yes it works it accomplishes the task
02:52 - I'll show you that when I print this out
02:54 - we actually do get this list separated
02:56 - by commas but what could be improved
02:58 - well looking at this there's a few
03:00 - different things so when we design code
03:03 - the first thing that we want to think
03:04 - about is designing for flexibility and
03:06 - this is a huge beginner mistake so what
03:08 - happens now if I decide to add another
03:11 - word to my list so let's add another
03:12 - hello here and I print this out you see
03:14 - that this code does not change this
03:16 - means we have not designed this flexibly
03:18 - and when we change the problem very
03:20 - slightly by adding say another word to
03:22 - our list this whole piece of code falls
03:25 - apart right it works for the initial
03:27 - thing that we designed it for but it's
03:29 - not flexible enough to work for
03:30 - something else okay so that's one
03:33 - mistake with it but what's another one
03:34 - well the next one is what if I decide
03:36 - that I want to change the delimiter so
03:38 - let's say that the current thing that
03:41 - we're gonna use is commas right and
03:42 - that's what we have here now what
03:44 - happens if I change the problem and I
03:46 - say let's do this with periods well now
03:49 - you have to go and change every single
03:51 - one of these commas to be a period now
03:53 - it doesn't seem like that big of an
03:55 - inconvenience here but will happen quite
03:57 - often in larger projects when you do
03:59 - something like this and say hard code a
04:01 - and a delimiter or hard code in some
04:03 - variable is this may appear many many
04:05 - times in the program especially as it
04:07 - gets larger so when you now want to
04:09 - change say all of those periods are all
04:11 - of those commas to be something
04:13 - different you need to go through and
04:14 - change every single aspect which
04:16 - obviously is not good and it's probably
04:17 - gonna lead to a little bit of human
04:19 - error and that's what we want to avoid
04:21 - is any potential for when we're changing
04:23 - or fixing this code later to make
04:25 - mistakes and here this is a Hugh
04:27 - potential because if I forget to change
04:29 - one comma or one period first of all
04:31 - it's gonna be difficult to find that
04:32 - error but second of all it's just a big
04:34 - issue right so let's move to example two
04:37 - so that was the worst example I kind of
04:38 - have here example one and showing you
04:40 - that yes this works but this isn't a
04:42 - good design this is not how we should
04:43 - write this and when we think about this
04:45 - code we should think about how we can
04:47 - design this more flexibly and scalably
04:49 - so that if we change the problem
04:51 - slightly this still works okay so now
04:54 - we're on e 2 and this is my solution too
04:56 - so we can see that I've defined a list
04:58 - of words I have a variable here called
05:00 - to print and what I've done is said for
05:02 - I in range 4 so that's the amount of
05:04 - things that I have in this list here
05:05 - what we're gonna do is add the list to
05:09 - this to print and then if I is not equal
05:10 - 3 so if it's not the last element we
05:13 - will add a comma and we'll print this
05:14 - out so let's look at this we can see
05:16 - that we get the same thing but looking
05:18 - at this solution what is wrong here well
05:20 - take a second to think about it but it's
05:23 - kind of the same thing as the previous
05:24 - one yes ok so this works a little bit
05:27 - better for us now but not much right so
05:30 - if we want to change the comma at least
05:31 - all we need to do now is change one
05:33 - thing instead of three so it's a little
05:34 - bit of an improvement from beforehand
05:36 - but what about this 4 here right this
05:39 - again is hard coding how many elements
05:41 - were gonna have in this list so what
05:43 - happens when we add another element if
05:44 - we go ahead and do hello here right we
05:47 - still get the same thing so if we want
05:49 - to make this more scalable and more
05:51 - flexible we'd likely change this to be
05:53 - the Len of list of words so that way
05:55 - when this changes our solution can adapt
05:58 - and it can add all of those extra words
06:00 - so now what's the issue here though
06:02 - right we said if I does not equal 3 and
06:04 - we hard-coded that variable in but now
06:07 - that we've increased the length of our
06:08 - words this doesn't work anymore we can
06:10 - see these commas are getting all messed
06:11 - up so what we really should do is change
06:13 - this to be be the land of the list of
06:16 - words minus 1 and now we can see that we
06:19 - fixed the solution slightly now this one
06:22 - is a little bit complex that's ok you
06:23 - know it has a few more lines of code
06:25 - than we really need but this is showing
06:27 - how we can kind of get more flexible and
06:29 - redesign our programs that it works for
06:31 - different variations of the problem so
06:34 - let's go to e3 now ok so this one is a
06:37 - little bit better so what we've done is
06:38 - we've said lists of words equals we have
06:40 - or words and we do comic join list of
06:43 - words and that already is much better so
06:46 - what we've done now is we said okay so
06:48 - this will work for any number of words
06:49 - right no matter how many are in there we
06:52 - only have the comma one time which means
06:54 - if we need to change something we can
06:55 - change it right here that's pretty easy
06:56 - and if we go ahead and print this we see
06:58 - that this works fine so this is a better
07:01 - solution I would mark this as you know
07:02 - acceptable this is okay if I saw this
07:04 - that wouldn't be upset but an even
07:06 - better solution now moves us to e4 where
07:09 - what I've done is I've actually defined
07:11 - a delimiter constant and now instead of
07:13 - having comma dot join I have a delimiter
07:16 - dot join now the reason this is better
07:18 - is because to change this now all I have
07:20 - to do is change the constant which is
07:22 - denoted in all capitals which tells me
07:24 - this is a constant this is used
07:26 - throughout the program and this is where
07:27 - I should change it and now let's say
07:30 - that we change the problem even so
07:31 - slightly and we want to print this twice
07:33 - now rather than putting another comma
07:35 - here right like we would have in a
07:37 - different solution we simply write to
07:39 - limiter again and it will use that same
07:41 - delimiter from above so this is much
07:44 - better what is the issue here oh I
07:47 - haven't asked at the end ok so let's run
07:48 - that and we can see that this continues
07:49 - to work so this is hopefully starting to
07:52 - make you think about the way in which we
07:54 - write code we want to make things
07:56 - flexible scalable and we want them to be
07:58 - able to work well if we adapt or modify
08:00 - the problem which happens quite often
08:02 - when we're writing large programs we
08:04 - initially started with some algorithm
08:05 - that does something very well but then
08:07 - the problem may change or adapt and what
08:09 - you really need to think about is ok
08:11 - what can I do now to make sure that if
08:13 - this changes in the future my code still
08:15 - works or it only needs very minor
08:17 - adjustments to adapt to that and that's
08:19 - really what I want to start getting you
08:21 - guys thinking about and that's why I've
08:22 - done this example here of example 1
08:23 - which again I just called common design
08:26 - mistakes ok so let's move to example 2
08:28 - now and let's have a look at this so
08:30 - we're gonna get into some more complex
08:32 - examples this is just the beginning to
08:33 - get the kind of wheels spinning and get
08:35 - you guys thinking about it so I have
08:36 - this game here this is a number guessing
08:38 - game right we have a guess up here we
08:40 - have some while loop and what we do is
08:42 - we essentially get the user to guess a
08:44 - number between 0 and 100 if they get it
08:46 - correct you know it tells them how many
08:48 - guesses they got it in otherwise it
08:49 - tells them if they were under or if they
08:51 - were over so it's actually added some
08:52 - periods here just to make
08:54 - this is consistent okay and now let's
08:56 - run this so let's look at the program
08:58 - down here actually don't know if this is
08:59 - gonna work in my sub line so I'm gonna
09:01 - have to bring up a terminal window but
09:03 - if I click 45 yep so this doesn't work
09:04 - in here for some reason but let's just
09:07 - go into a terminal window and I'll run
09:09 - this for you
09:09 - so CD example to Python
09:13 - II 1 dot PI okay so please guess a
09:15 - number between 0 100 let's guess 34 says
09:18 - your guest was under okay let's guess 40
09:20 - your guest was under I think the number
09:22 - is like 44 your guest was under 45 you
09:26 - guessed it in four guesses so that's the
09:28 - basic game now looking at this what do
09:31 - you think that we could improve on or
09:32 - why might this code might not be optimal
09:35 - right why may it not be optimal
09:36 - especially if we want it to say reuse
09:38 - this in the future well I'll start
09:40 - listing a few things that I see
09:41 - immediately if we want to change the
09:44 - number right what we need to do is
09:46 - change both instances of 45 here so if
09:49 - we want to change what number we need to
09:50 - guess and we know the number here is 45
09:52 - we need to change both of these
09:54 - immediately not optimal this means
09:56 - there's room for human error we could
09:57 - change one and not change the other one
09:59 - we could break our program quite easily
10:01 - and if I want to change this number it's
10:03 - not that easy especially if this game
10:05 - gets more complex for me to go through
10:07 - this code and find where 45 exists right
10:09 - so number one problem there is that 45
10:12 - is hard-coded we shouldn't have that we
10:14 - should add a constant to the top here
10:16 - right where we do like number and then
10:18 - set that ok anything else well what
10:22 - about this range so between 0 and 100 so
10:25 - we haven't actually really defined that
10:27 - like anywhere else in this code that
10:28 - this range needs to be set but you know
10:31 - what happens when we change our number
10:32 - now to be 800 this range up here
10:35 - now needs to change as well so that is
10:37 - obviously not good that means that now
10:39 - if we change this number to be anything
10:41 - lower than 0 or higher than 100 we also
10:43 - have to figure out that this is gonna be
10:45 - a problem what we're printing we need to
10:46 - change that so immediately again not
10:48 - optimal okay so now what if we want to
10:51 - run this guessing game 500 times but
10:53 - with a bunch of random numbers well we
10:55 - aren't really able to do that without
10:57 - just copying and pasting this and then
10:58 - making all those modifications that we
11:00 - made before so this really is not an
11:02 - optimal solution yes this works for what
11:05 - needed to do and in a smaller program
11:07 - where you're only going to use this once
11:08 - this would be acceptable that would be
11:09 - fine but let me show you a better
11:11 - approach to this which is e2 so now what
11:15 - I've actually done is I've taken this
11:17 - program and I've converted it into a
11:19 - class a class that is scalable flexible
11:22 - and that will work multiple times and
11:25 - this is the idea behind software design
11:27 - right when we start making things even
11:28 - something like this that's simple we
11:30 - should think about the idea that we may
11:32 - want to use this again and that we need
11:34 - to say what's gonna happen if we change
11:36 - this problem right if we change the
11:38 - range from you know zero to 100 to 400
11:40 - to 700 or something like that right what
11:43 - do we need to do we actually have to go
11:44 - in here and change that value we
11:46 - shouldn't have to do that we should set
11:49 - up what I've done here which is a class
11:50 - which will handle that change for us and
11:53 - we design that at the beginning because
11:54 - we've thought about the problem and
11:56 - we've said okay well we're gonna need to
11:58 - potentially have something different so
12:01 - let's design this so it's very flexible
12:02 - and then it doesn't work for only the
12:04 - specific problem we're solving right now
12:05 - but it works for future problems so
12:08 - what's gonna just dive through this
12:09 - guest number here and look what's
12:10 - happening so what I've done as I've said
12:12 - we have a class called guest number and
12:14 - here in the initialization it takes some
12:16 - number and then two optional parameters
12:18 - for the minimum and maximum range now
12:21 - notice these are optional I don't need
12:22 - to put them in if I don't want to and
12:23 - that again is another thing designing
12:25 - for flexibility is if you know this
12:27 - standard case is just that they need to
12:29 - guess some number between 0 and 100 it's
12:31 - totally fine to leave your min and
12:33 - you're max like at some standard value
12:36 - right which is what we have here so we
12:38 - define the guesses we have the min we
12:40 - have the Max and then what I've actually
12:42 - done is I've taken some of the
12:44 - functionality that's in here and I've
12:46 - split it up into separate functions now
12:49 - the concept behind this is that what we
12:51 - want to do is we want to have things
12:53 - that are cohesive that work together
12:55 - that are combined in the same class and
12:58 - then inside of the same class we want to
13:00 - have operations or methods functions
13:03 - right that do of a specific task be
13:05 - separated and grouped out so that if
13:07 - something goes wrong or we need to
13:09 - change one aspect of the code it's very
13:11 - easy to do so as opposed to here where
13:14 - everything's in one kind of mainline
13:16 - program if we want to change anything we
13:18 - will
13:18 - likely have to modify the entire thing
13:20 - so let's just have a look at here so we
13:22 - have defined get guests so what get
13:24 - guests does is gets a guess from a user
13:27 - now notice back here what we did to get
13:29 - the guests was these few lines of code
13:31 - here that's totally fine but again now
13:33 - if we want to change this we need to
13:35 - change all of this code to do something
13:37 - else so here kind of be you know
13:39 - complement I guess if you want to say
13:41 - that is this we have a method what it
13:44 - does is it gets the guest from the user
13:45 - so it says gasps equals input please
13:47 - guess a number between notice this is
13:49 - not a hard-coded value the minimum and
13:52 - the maximum then what we do is we save
13:54 - self-taught valid guests then return
13:56 - into guess and guess what this is a
13:58 - method here and by doing this what we've
14:00 - actually done is made this a lot more
14:02 - readable for ourselves so I can read
14:04 - through this method and understand
14:05 - exactly what it does
14:07 - because I've split up some functionality
14:09 - into another method so I can read
14:11 - through this understand that self
14:13 - thought valid guess what is that doing
14:14 - exactly what it says determining if this
14:16 - is a valid guess if it is we would turn
14:18 - the integer for the guess otherwise
14:19 - we'll ask them to enter a valid number
14:21 - again and then we will just recursively
14:24 - call this same method to get that number
14:26 - now if we go down here to valid guess we
14:29 - can see that all this does is make sure
14:32 - that the number that we put in is
14:33 - actually an integer and that it's in the
14:35 - correct range so we can see that here
14:37 - we're checking that invalid guess and
14:39 - then if we go down to play we can see
14:41 - that play actually implements playing
14:43 - this game and then to actually create
14:46 - the game we have game equals guest
14:47 - number game dot play so hopefully you
14:50 - can appreciate the difference between
14:52 - this code here and why this might be
14:53 - better than this code because if we go
14:56 - back to the examples of things that were
14:58 - wrong with this code right we were
14:59 - saying well we have this constant value
15:01 - that's in that's no good we fixed that
15:04 - here by allowing our user to simply
15:06 - enter a constant value when we want to
15:07 - create a new guest number game right and
15:10 - then we had some other issues with this
15:12 - as well like we need to change the range
15:14 - potentially here that range is handled
15:17 - for us we already have that inside an F
15:18 - string we enter the minimum and maximum
15:20 - range when we create this game and
15:22 - anything else that was wrong with this
15:23 - well if we wanted to reuse this we
15:25 - couldn't but here now what I can do to
15:28 - use this is simply copy this change this
15:31 - number to say
15:31 - seventy-five and now we have two games
15:34 - of guest number and we can use this as
15:35 - many times as we want wherever we want
15:38 - by simply using two lines of code sweet
15:41 - so that is kind of the idea behind this
15:43 - and notice that I've separated things
15:45 - out into functions or methods and these
15:47 - methods do one thing and they do one
15:50 - thing very well a common mistake that I
15:52 - see quite often is what people will do
15:55 - is rather than kind of separating these
15:57 - things out into three different
15:59 - functions that are all good at what they
16:01 - do is they'll write one mega function
16:03 - and one mega function is something like
16:05 - this right you define like you know clay
16:07 - so you could define play and instead of
16:10 - writing all of these separate kind of
16:12 - cohesive blocks that make sense what
16:14 - they do is they would just take all of
16:15 - this code right that we have here and
16:17 - just paste it inside of this one method
16:19 - and have everything happen inside of
16:22 - here now again the problem with that is
16:24 - especially when you're writing larger
16:25 - programs is that when you run into any
16:27 - bug it's very difficult to determine
16:29 - where that bug was because all that code
16:32 - is in the same area but if you split
16:34 - these code this code up into different
16:36 - functions and methods what you can do is
16:38 - you can test each method individually
16:41 - make sure that that method is
16:42 - functioning and then as soon as you get
16:44 - to a method that's not functioning is
16:46 - very easy to determine what the problem
16:48 - is you can write cohesive small
16:50 - functions or methods that do one thing
16:53 - and do one thing very well that's kind
16:55 - of the standard design principle I think
16:57 - it's called something of separation then
17:00 - that's gonna help you tremendously and
17:02 - even just reading through this we
17:03 - understand we have a get guess we know
17:04 - what that does we have a valid number we
17:06 - can understand what that does and then
17:07 - we have play we understand what that
17:08 - does and we don't even need to call play
17:10 - if we don't want to until maybe later on
17:12 - in the code so we could initialize the
17:14 - game have it set up and ready to go and
17:16 - then when we need to play we could play
17:18 - right and we could implement this into a
17:19 - program where we ask the user would you
17:21 - like to play they say yes boom we go
17:24 - ahead and we start playing so the design
17:26 - principle is here again that I teach
17:27 - here really Nayland is that we need to
17:29 - separate things out into functions or
17:31 - methods that do one thing and they do
17:33 - one thing very well and it's quite
17:35 - common that what we want to do is make
17:37 - sure our methods or functions do not
17:39 - have side-effects and what I mean by
17:41 - side effects is that they modify some
17:44 - value
17:44 - or they make a bunch of changes or they
17:46 - call a bunch of other methods if that's
17:48 - not necessary
17:49 - the reason for that again is because you
17:51 - want these functions do one thing and do
17:53 - one thing very well and if they can do
17:54 - that it makes your life a lot easier
17:56 - again notice just in the play here I was
17:58 - able to clean this code up quite a bit
18:00 - because now instead of having to
18:01 - implement all this stuff to get the
18:02 - guess I can simply call the method self
18:05 - don't get guess this one can use the
18:07 - method valid number right these things
18:09 - work well for the one task that they can
18:11 - achieve and if I needed to reuse them
18:13 - later on to check if a number was valid
18:15 - for some other purpose it'd be quite
18:16 - easy to do that and then here we
18:18 - implement these few lines of code
18:20 - everything's very clean easy to read and
18:22 - this is what you define house good clean
18:24 - code alright so that has been it for
18:26 - this design now we're gonna move into
18:28 - example three we start talking about
18:31 - packages modules and namespaces in
18:33 - Python which we're gonna allow you to
18:34 - organize your code even more so I hope
18:37 - this is making sense I hope I'm giving
18:38 - you a few design principles and things
18:40 - to think about and again that's the idea
18:42 - behind this whole tutorials to get you
18:43 - thinking like a proper programmer get
18:46 - you thinking about your design and how
18:48 - you want to actually make things and a
18:50 - good idea is to always think about these
18:51 - things before you actually go ahead and
18:53 - start programming okay so what I have
18:56 - here is a math functions kind of module
18:59 - right so I've said math functions PI and
19:00 - the idea here is that I would like to
19:03 - use some of the functions there inside
19:04 - of here in this script test op PI so
19:07 - we'll talk about how we could do that in
19:08 - a second but let's just have a look at
19:09 - this module it's fairly long you know
19:11 - it's 64 lines and has a few different
19:13 - functions that seem to do different
19:15 - things or act on different objects so
19:17 - first of all we have these list
19:18 - functions that I've denoted here these
19:20 - all act on lists we have get max get men
19:22 - get average and get median clearly some
19:24 - operations just to test you know those
19:26 - specific things from a list then we have
19:29 - some hash table functions what I mean by
19:31 - hash table is simply dictionary and here
19:33 - we have get keys hash key or has key
19:35 - sorry max value min value right so we
19:38 - have all these different functions but
19:39 - they're all in one module or one block
19:42 - so right now if I want to use these what
19:44 - I have to do is import this math
19:47 - functions module right
19:49 - so by import math functions because I'm
19:51 - in the same folder here example 3
19:53 - I should have access to all of these
19:55 - different functions so that's fine let's
19:57 - see how we can
19:58 - use that so let's print math functions
20:01 - dots get averaged and then here let's
20:04 - pass a list let's go 1 4 5 8 whatever
20:07 - some random stuff so let's print that we
20:10 - run this here and we look up we get five
20:12 - point six six six six six seven as our
20:14 - average so that's how we use that now
20:16 - what if we want to use one of those hash
20:17 - table functions so if we make a hash
20:19 - table here we'll say hte
20:20 - equals and let's just do high one Tim we
20:27 - get this in here six and let's call one
20:30 - of those hash table functions now
20:31 - instead of get average let's do get max
20:34 - I think get max is the correct one let's
20:37 - see or max value I believe this would
20:39 - this actually so max value and then in
20:41 - here we'll pass HT and we'll see that we
20:44 - get the value of six so this is fine we
20:48 - have these math functions all in this
20:49 - one module but can you think of what
20:51 - might be wrong with what I've done here
20:53 - or why this might not be the best thing
20:55 - so think back to that property that I
20:57 - talked about of cohesiveness we want
20:59 - things that are similar to be in similar
21:02 - areas right so if we go back to example
21:04 - two and we look at this everything that
21:06 - pertains to guessing a number is stored
21:08 - inside of this guessing number class
21:10 - right we have those three different
21:11 - methods so get guest valid number and
21:13 - play which are all pertaining to our you
21:16 - know in the same context as guessing a
21:18 - number we have the attributes that are
21:20 - involved in guessing a number stored in
21:22 - this class and then display method you
21:24 - know uses the appropriate methods it's
21:26 - all cohesive right whereas get guests
21:29 - all the things that are involved in
21:30 - getting a guess are in this one function
21:32 - or in this one what do you call it
21:34 - method right cohesive that's what we
21:36 - call it this in math functions I would
21:39 - not call cohesin the reason for that is
21:41 - because we have two different purposes
21:43 - for this module one for hash table
21:45 - functions and one for list functions
21:47 - yes these are all utility functions
21:49 - that's fine we could call it that but
21:51 - what I want to show you is how we can
21:52 - separate these out into separate modules
21:54 - that make this a little bit more clear
21:56 - so let's go ahead and let's make two new
21:58 - files in here and let's call the first
22:00 - one HT functions so for hash table
22:03 - function stop by and let's make our next
22:05 - one so new file called was Yellin list
22:09 - underscore functions
22:11 - now these are not the best names in the
22:13 - world but hopefully out you're getting
22:14 - the point here and what we're going to
22:15 - do is just take all of these list
22:17 - functions that we had and put them
22:18 - inside of list functions and we'll take
22:20 - all the hash table functions that we
22:22 - have and put them inside of hash table
22:25 - functions so here I'm going to show you
22:26 - how we can import these properly so
22:28 - don't worry about that for now but now
22:30 - we have two cohesive modules so we have
22:32 - the module HT functions which has an
22:34 - appropriate name that stores all of the
22:36 - functions related to hash tables we have
22:38 - a module called list functions that
22:40 - stores all of the functions related to
22:42 - lists right so these are now cohesive
22:44 - and if I was say looking at this program
22:46 - a year later and I wanted to figure out
22:48 - oh there's something wrong with a list
22:49 - function I would very easily be able to
22:51 - find that because I know that it should
22:53 - be in the module list functions again
22:55 - this is organizing this is kind of
22:57 - setting up for the future and thinking
22:58 - if I was gonna add more functions do I
23:01 - want to add them into this huge script
23:02 - called math functions or do I want to
23:04 - separate things out into separate
23:06 - modules that make sense so right now
23:08 - that's what we've done we've separated
23:09 - them out so to use these now instead of
23:11 - just importing math functions we're
23:12 - gonna import HT underscore functions and
23:16 - we'll import so just do a separate line
23:19 - list underscore functions as well so now
23:22 - if we want to use this instead of math
23:24 - function we have to say HT underscore
23:26 - functions like that and run this code
23:28 - and we see that we get the same answer
23:29 - of six so now say we only wanted the
23:33 - list functions we don't need to
23:34 - implement or import all of the hash
23:37 - table functions as well in fact we can
23:38 - just remove that line or comment it out
23:40 - and we just get the list functions great
23:43 - so this is splitting things up this is
23:45 - working well and now I'm just gonna show
23:47 - you what happens if we do something
23:49 - that's quite common which is named
23:51 - methods the same or named modules are
23:53 - the same that are inside both things
23:56 - here so are inside both modules so HT
23:58 - functions list functions so here notice
24:01 - in list functions I have get max get men
24:03 - get average get median and then here I
24:05 - have get keys has key max value min
24:08 - value ideally when we're creating
24:10 - something like this we want our naming
24:11 - to be consistent so that it's intuitive
24:14 - enough that if I had to guess what a
24:16 - specific function was doing or guess a
24:19 - function name I could do so so if I knew
24:21 - you know list functions was named with
24:23 - gap prefixes
24:24 - I would hope that this one would be
24:26 - getting on named with gap prefixes as
24:28 - well so that it would be easier for me
24:30 - to you know guess or understand what is
24:32 - happening so what I'm actually gonna do
24:34 - is go ahead and change these names to
24:36 - say instead of max value get max like
24:40 - that and here we'll say get min now
24:43 - we'll leave the house key because that
24:45 - kind of makes sense to be named what it
24:46 - is but get keys get Max and get min
24:49 - let's name them the same and notice that
24:50 - now we have duplicates so get Max and
24:52 - get min okay so I've named both of the
24:55 - functions in here the same thing so get
24:57 - min and get max is now named the same as
24:59 - get min and get max what I want to do is
25:02 - show you what happens when we actually
25:04 - import the specific functions from these
25:07 - modules so I haven't showed you yet how
25:08 - to do this but we can import HT
25:10 - functions which is gonna be the module
25:12 - here right but if I want to actually not
25:14 - have to do something like HT hundreds
25:16 - core functions dot then what I can do is
25:19 - import the specific function itself so I
25:22 - can actually say from HT underscore
25:24 - functions imports get max and I can
25:28 - import get min as well if I wanted to
25:30 - and then we'll do the same thing from
25:31 - list functions with those same name so
25:34 - we'll import get Max and get me in as
25:36 - well and I want to show you what happens
25:38 - when I actually do get Max of HT so in
25:42 - theory this should work right because
25:43 - we've imported get max we know that we
25:45 - have a function that works in HT
25:47 - functions that's called get max so let's
25:49 - see what happens when we call kept max
25:51 - on HT we run that and we actually run
25:54 - into a problem and it says that string
25:57 - and float cannot be others there's a
25:59 - type error right something's wrong now
26:01 - the reason for that is because look what
26:02 - module it's actually running in it's
26:03 - running in list functions so a lot of
26:05 - people probably would have guessed this
26:07 - but what happens is when you import
26:08 - methods that have the same name or it
26:11 - functions that have the same name from
26:12 - different modules
26:13 - the most recent import is what's used so
26:16 - in this case get max and get min are
26:18 - going to be used from list functions
26:19 - instead of HT functions because in the
26:22 - namespace is what it's called for this
26:24 - program there was two versions so it
26:26 - took the most recent version and use
26:28 - that so if I wanted to explicitly use
26:30 - the hash table one right instead of the
26:33 - list one I would have to do with HD
26:35 - functions but I can't even do that right
26:37 - now
26:38 - till I decide to go here in import HT
26:41 - underscore functions this is kind of
26:43 - weird but you need to actually import
26:45 - explicitly the module if you're gonna
26:48 - use it like this so with the dot
26:49 - operator and if you import these names
26:52 - right so get max get min you have to
26:55 - make sure they're not gonna be named the
26:56 - same as something else or you can fix
26:58 - this using what's called an alias so
27:00 - what I'm actually gonna do is say okay
27:02 - well I want to import it like this I
27:03 - want to import the function itself but I
27:06 - want to fix this naming collision so
27:08 - what I'm actually gonna do is I'm going
27:09 - to import get max as HT underscore get
27:12 - max now what this does is called an
27:14 - alias
27:15 - it simply renames this get max to HT get
27:18 - max in this scope so in this file scope
27:20 - this means now if I want to use HT get
27:23 - max I wanna use get max from HT
27:25 - functions I use HT get max so to do that
27:28 - I'm gonna say HT underscore get max and
27:30 - run this and notice that there's no
27:32 - issue that works fine so we can use this
27:34 - as to what's called alias something we
27:36 - can also say import H to underscore
27:40 - functions as say H right and now if we
27:43 - wanted to use something specifically
27:44 - from there so we say you know H dot get
27:48 - keys from hash table notice that we get
27:50 - the dictionary keys hi and Tim and that
27:52 - works fine okay so that's kind of the
27:54 - basics on importing modules and using
27:57 - modules and to separate things into
27:58 - cohesive kind of blocks but what I'm
28:00 - gonna do now is show you how we can
28:02 - actually create something called
28:02 - packages so notice that since list
28:05 - functions and HT functions are kind of
28:07 - similar right they kind of do a similar
28:09 - thing they both work for functions what
28:11 - we can actually do is separate these
28:13 - into what we call a package and use a
28:15 - package now what a packages is
28:18 - essentially just a folder full of Python
28:21 - modules now to make a package you have
28:24 - to make a new folder so we'll make a new
28:25 - folder first I'm gonna call this let's
28:27 - just call this the functions package or
28:30 - actually let's call it you tale because
28:31 - it's gonna be like utility things for
28:33 - our programs we'll call it you two like
28:34 - that and what I'm gonna do is drag in HT
28:38 - function so I don't think I can drag it
28:39 - but I think I can move it in to example
28:41 - three util /hd functions okay and let's
28:47 - move this one in as well so move
28:49 - into if I can get this off my screen
28:52 - it's just being annoying all right so
28:55 - let's move this into util like that so
28:59 - now they're both inside of you till now
29:01 - all I have to do if actually want to
29:02 - make this folder what's called a package
29:05 - which means I can import the package so
29:07 - the entire folder rather than the
29:08 - specific modules is I have to put a new
29:10 - file in here and I have to call it an it
29:12 - so underscore underscore net underscore
29:14 - underscore X dot PI now what that does
29:17 - is pretty much just tell Python that hey
29:20 - we're initializing this package this is
29:22 - a Python package which means rather than
29:25 - having to import HT functions and list
29:27 - functions separately I can actually
29:29 - import them both at the same time by
29:30 - simply importing this package so I'll
29:32 - show you how that works now so X we
29:34 - don't need math functions anymore but if
29:36 - we go to test op PI rather than having
29:37 - to do something like this so from HT
29:39 - functions from list functions what I can
29:41 - actually do is import and in this case I
29:44 - can import util now importing util will
29:47 - actually let me have access to this HT
29:50 - functions and this list functions so now
29:52 - essentially what I've done is I've
29:53 - created a folder that is cohesive and
29:56 - the reason it's cohesive is because it
29:57 - contains two modules right these two
30:00 - modules are similar they both act on
30:02 - functions and then I have two modules
30:04 - inside of this folder and these modules
30:06 - right have functions inside of them that
30:09 - are cohesive that are similar they both
30:11 - act on hash tables or they act on lists
30:14 - right and then these functions
30:15 - themselves do one thing and do one thing
30:18 - very well they're not doing this huge
30:19 - amount of things so my program or my
30:22 - whatever you want to call it project is
30:23 - cohesive which is what we wanted to get
30:25 - to we wanted to organize things so that
30:27 - they make sense where they are so we
30:29 - have that now so how do I use util so to
30:31 - import a package you can simply import
30:33 - it like this but there is some kind of
30:35 - tricky things in terms of how this works
30:37 - so since this is a package you can just
30:39 - import the name but if I want to
30:41 - actually use the modules that are inside
30:43 - of it what I have to do is say something
30:45 - like this
30:46 - so from util and you've probably
30:48 - actually seen this before
30:49 - so from util import and then we'll do
30:53 - the name of those files we want so we'll
30:55 - import HT functions and we'll import in
30:58 - this case the list underscore functions
31:00 - now you might say well what was the
31:02 - point of that
31:02 - that seems like if anything you just
31:04 - made it more complicated from before
31:05 - well the point of that was to organize
31:07 - things well in my program so that I now
31:10 - have functions that are kind of grouped
31:12 - together and modules that are grouped
31:13 - together inside of the same folder so
31:15 - now if I wanted to say if I had a larger
31:17 - project with a bunch of files it'd be
31:18 - very easy for me to find where my
31:20 - utility functions are because they're in
31:22 - the util package and then inside that
31:25 - package I have modules that are
31:26 - organized correctly which means I can
31:28 - find what I need to find so we'll import
31:30 - HD functions and lay import lists
31:32 - functions and now we can use them like
31:33 - we would before so I can say HD
31:35 - functions dot get keys and use that that
31:37 - works totally fine nothing wrong with
31:39 - that and if I wanted to
31:40 - Elias these what I could do is simply
31:42 - say import HD functions as HT and then
31:46 - do the same import here so from util
31:49 - import list functions as LS right and
31:52 - then if I wanted to use a list function
31:54 - I could say LS dot get max right and I
31:57 - gets to LX get max of 1 4 5 like that
32:02 - and my HT max will still work so I can
32:05 - say print HT dot gets underscore max of
32:09 - and here we'll just put actually the
32:12 - hash table like that and what is the
32:15 - issue here oh I've called this HT 1 HT
32:20 - is what that is called so let's just
32:22 - make this H instead of HT so that was an
32:25 - issue there and do that let me see that
32:27 - this works fine so that has been
32:29 - packages modules and the hierarchy kind
32:31 - of goes package module and then classes
32:34 - methods functions and then you have
32:36 - everything else right which just
32:37 - attributes are regular lines of code so
32:39 - this is the way that you can organize
32:40 - and separate your code out so that it's
32:42 - easier to find in to tweak later and
32:44 - remember every time you're programming
32:46 - what you want to be thinking about is
32:47 - okay how can I make this as simple for
32:49 - myself as possible how could I make it
32:51 - so that when I look back at this in two
32:52 - years if I need to change a file I can
32:54 - do that because everything's organized
32:56 - and clear and hopefully this kind of
32:58 - video I know there's a lot of repetitive
33:00 - stuff in it really drilled that into
33:02 - your head and I know that this probably
33:03 - was a lot for for some people there was
33:05 - a lot of things shown here but the idea
33:07 - is to make things cohesive and that's
33:09 - the introduction to software design
33:11 - there's a lot more to talk about and I
33:13 - am planning on doing some more videos in
33:15 - this domain
33:16 - if you want to read up more on this
33:17 - again there is that book in the
33:18 - description that has so much more detail
33:20 - than what I've provided here this was
33:22 - just to give you some examples get you
33:23 - thinking about how software design
33:25 - actually works why software design is
33:27 - important and showing you some of the
33:29 - tools like creating packages and modules
33:31 - in Python that allow you to separate out
33:34 - your code and again to make that package
33:36 - you simply make a folder called an it
33:38 - dot pi this folders in the same
33:39 - directory as my math functions and my
33:41 - test dot pi which means that from either
33:43 - of these files I can import that entire
33:45 - package and use anything that's inside
33:47 - of it obviously there's a lot more to
33:49 - talk about with packages but I think
33:50 - that's where I'm gonna leave it here and
33:51 - hopefully this gave you a good
33:53 - introduction to software design so if
33:55 - you have any questions do leave them
33:56 - down below let me know any series you'd
33:57 - like to see in the future and if you
33:59 - enjoyed the video of course leave a like
34:00 - subscribe to the channel and I will see
34:02 - you guys in another YouTube video