00:00 - hello everybody and welcome to part two
00:02 - of this series where I'll be showing you
00:04 - how to set up your development
00:06 - environment for writing decentralized
00:08 - applications in Python using cartez now
00:12 - the setup here is a little bit in depth
00:14 - just because of the inherent complexity
00:16 - of writing smart contracts in well any
00:19 - language fortunately once we get it set
00:21 - up it's very easy to work with it and to
00:23 - do our development so please bear with
00:25 - me in this video and make sure you go
00:27 - through the steps one by one don't skip
00:29 - anything thing I promise you will thank
00:31 - me later now the setup is going to be
00:33 - different depending on the operating
00:35 - system that you're on so on Windows it's
00:36 - a bit different Linux Mac Etc
00:39 - fortunately caresia has some really
00:41 - great documentation and I'll link three
00:44 - guides in the description that I highly
00:46 - recommend you download right now first
00:48 - one is for Windows next is Linux and
00:51 - last is Mac now I'll be kind of running
00:53 - through these and sharing with you the
00:55 - differences between Windows Linux Mac
00:57 - Etc obviously it's impossible for me to
00:59 - show you the in-depth setup for all of
01:01 - them as I don't have three operating
01:03 - systems running on my computer I just
01:05 - have one which is Windows I'll make
01:07 - everything very clear but I highly
01:09 - recommend that you actually attempt to
01:10 - go through this document on your own and
01:13 - you can refer this video if you have any
01:15 - challenges or questions about the
01:16 - commands that are being ran so again go
01:18 - down to the description there's three
01:20 - guides one for Windows one for Linux and
01:23 - one for mac and they will show you the
01:25 - setup steps for running your first
01:26 - decentralized application which is
01:28 - already built for you you using cartei
01:31 - that's going to be the goal of this
01:32 - video get a demo application running on
01:35 - our computer get the setup fully
01:37 - finished and configured and then I'm
01:39 - going to start explaining to you how
01:40 - caresia Works a little bit more in depth
01:43 - and giving you some insight into what it
01:45 - is we're actually going to be doing as
01:46 - we start building our decentralized
01:48 - application now another note if you have
01:50 - any issues with this installation please
01:52 - join the Discord server that I'll link
01:54 - below you can actually contact the
01:56 - cartei team directly and they can help
01:58 - you one-on-one with any issue that you
02:00 - have now I have Windows Linux and Mac
02:02 - here I am running Windows on my computer
02:05 - now the prerequisites for setting up the
02:07 - environment are going to be the same for
02:08 - all of our operating systems so you can
02:10 - see that generally what we need is
02:12 - Python 3 node.js yarn and Docker desktop
02:17 - if we go over here to Linux same thing
02:19 - Mac same thing now installing these
02:21 - requirements are a little bit different
02:23 - just based on the way the operating
02:25 - systems function so on Linux and Mac
02:27 - you're actually running in a Unix
02:29 - environment or a Unix shell that means
02:31 - you have access to some specific
02:32 - commands and some operating system
02:34 - features you don't have by default on
02:36 - windows so on Windows what we first need
02:39 - to do is set up our WSL environment in
02:41 - this case WSL 2 which is Windows
02:43 - subsystem for Linux now this is a Linux
02:46 - like environment that will align with
02:48 - the carteia ecosystem which will allow
02:50 - us to do all of our development now for
02:52 - a lot of you you may actually be on Mac
02:54 - or Linux if that's the case you don't
02:55 - need to do that because you already have
02:57 - the correct shell and the correct
02:59 - operating system system so if you are on
03:01 - Windows what you need to do is start by
03:04 - installing and configuring Docker as
03:07 - well as
03:08 - wsl2 so it goes through here right
03:10 - manual installation of wsl2 you need to
03:13 - open Powershell as an administrator run
03:16 - this specific command now for all these
03:18 - commands again just download the guide
03:19 - from the description and you can copy
03:21 - them directly in you then need to switch
03:23 - from wsl1 to wsl2 if you don't already
03:26 - have that installed by running this
03:28 - command restart your computer and after
03:31 - restarting you're going to download the
03:33 - kernel package for wsl2 you're then
03:36 - going to set wsl2 as your default
03:38 - installation and then what you can do is
03:41 - open the Microsoft Store and download
03:43 - the current version of auntu Linux so if
03:45 - you go to store here and you type in the
03:50 - search bar if Microsoft will ever load
03:52 - for me here a bun to as you can see I
03:54 - already have it typed in you can
03:56 - actually download an installation so you
03:57 - can see I have one owned right here I
03:59 - don't know exactly what version this is
04:01 - but this installs this abunto operating
04:04 - system in wsl2 so now I have a Linux
04:07 - like environment on my Windows computer
04:10 - so that's the first step if you are on
04:11 - Windows then what you're going to need
04:13 - to do is install Docker desktop now this
04:16 - is going to be the same if you are on
04:18 - Linux or if you are on Mac okay you need
04:20 - Docker desktop you can see on Mac
04:22 - there's different installations for the
04:23 - silicone chip so the M1 M2 Etc or for
04:27 - the Intel chip now after we install
04:30 - Docker desktop if we are on Windows what
04:32 - we're going to do is just open it up now
04:34 - this will be the same on any operating
04:36 - system so whether you're on Mac Linux
04:37 - whatever you want to open Docker desktop
04:39 - so it's running it needs to be running
04:41 - in the background for everything to work
04:43 - if you are on Windows you going to click
04:45 - on settings and you're going to go to
04:47 - General and where it says use the wsl2
04:50 - based engine you're just going to make
04:51 - sure that's checked okay so make sure
04:53 - you have that selected that's going to
04:55 - allow you to access the docker command
04:57 - within your wsl2 installation
05:00 - okay so hopefully at this point you have
05:02 - WSL installed and you have the correct
05:05 - operating system once you do that a lot
05:07 - of the commands now are going to be
05:08 - similar for uh both Linux Mac Etc next
05:12 - thing you need is node.js and mpm now
05:16 - you're going to need to do this
05:17 - installation if you're on windows inside
05:19 - of wsl2 so open the auntu terminal now
05:22 - the way you can do that is you can just
05:24 - type A buntu like this okay so it's
05:26 - going to actually show you kind of this
05:28 - virtual operating system system and it
05:30 - just will open up okay so that's if
05:32 - you're on uh what do you call this
05:34 - windows again if you're on Mac or Linux
05:35 - you just open any terminal environment
05:37 - and you're kind of already set up now
05:39 - what we're going to do is we're going to
05:40 - install nodejs and mpm I've already ran
05:43 - through these installs you're just going
05:44 - to copy these commands Okay so you're
05:46 - going to install NVM You're Going To
05:48 - Source The Bash RC you're going to
05:50 - install node and you're going to Alias
05:53 - NVM with node perfect okay if we go to
05:56 - Linux same thing exact same commands
05:59 - Okay we go to Mac a little bit different
06:01 - because we're going to be using Brew to
06:03 - make sure we have nodejs installed great
06:06 - next installation step is python okay so
06:10 - again same thing we want to make sure
06:11 - we're in the auntu terminal everything
06:12 - we do from this point forward we're
06:14 - doing inside of WSL don't do this in
06:17 - your standard kind of Linux uh or sorry
06:20 - standard Windows uh command prompt
06:22 - Powershell whatever otherwise it's not
06:24 - going to work okay so now what we want
06:26 - to do is install python so same thing
06:28 - we're going to pseudo AP up update
06:29 - pseudo APD install Python 3 that's going
06:31 - to install it inside of our Linux
06:33 - environment if we're on Windows if we're
06:36 - on Linux we're going to update and
06:38 - install Python 3 I assume most of you
06:41 - probably already have Python 3 but if
06:42 - you don't you're going to install it
06:43 - right let me just zoom in a bit here if
06:45 - we are on Mac to install python a little
06:49 - bit different here okay Brew install
06:51 - Python 3 okay going back next thing we
06:55 - want to do is install yarn so again same
06:58 - thing make sure you're in the ABN of
06:59 - terminal we're going to add the yarn AP
07:01 - repository and we're going to install
07:03 - yarn okay next install yarn same
07:07 - commands here on Linux and on uh what do
07:10 - you call it Mac here fortunately you can
07:11 - just use brew and just say Brew install
07:13 - yarn at this point you should now have a
07:17 - wsnl environment if you are on Windows
07:20 - you should have Python 3 installed in
07:22 - that environment you should have nodejs
07:24 - installed and you should have yarn you
07:26 - also should have Docker desktop Docker
07:28 - desktop is running on your windows
07:30 - instance okay so we installed Docker
07:31 - desktop for Windows we tick that box
07:34 - we're good on Linux same thing okay
07:36 - Python 3 node yarn Docker desktop
07:39 - installed on Linux Mac OS exact same
07:42 - thing if we have all those three
07:43 - dependencies we are now ready to start
07:45 - running through the steps that are
07:47 - actually going to be the same for all
07:48 - the operating systems okay or at least
07:50 - very very similar so keep this reference
07:52 - open because again you can always go
07:54 - back to it and you can copy the commands
07:56 - now as we see here on Windows very
07:59 - important for a seamless development
08:00 - flow it is recommended to not execute
08:02 - Docker commands with Powershell or the
08:04 - WSL terminal instead open the auntu
08:06 - distribution that you have installed and
08:08 - perform all coding and command execution
08:10 - within that Linux environment so I've
08:12 - been saying that a bunch of times just
08:13 - make sure you do this because that's a
08:14 - mistake that I had plenty of times which
08:16 - is actually why they put it in this
08:17 - documentation okay so what we're going
08:20 - to be doing here is we are going to
08:22 - create a simple appap we're going to run
08:24 - a backend that will interact with the
08:26 - cartez rollups framework which we're
08:27 - going to talk about later and we are
08:29 - going going to use a basic kind of front
08:30 - end or console environment to send some
08:33 - requests just so you can see how we can
08:35 - send data to a decentralized application
08:39 - ridden in Python so I'm going to put
08:41 - this on the left hand side of my screen
08:43 - or sorry on the right hand side of my
08:44 - screen and on the left side I'm going to
08:45 - have my auntu terminal okay I've got
08:48 - auntu open up here I'm just going to
08:50 - open another instance of this and
08:52 - actually to do that I'm just going to
08:54 - type a buntu like that and I'm just
08:56 - going to combine these well let me
08:58 - combine them no it won't okay but I just
09:00 - have two of them open because we're
09:01 - going to need two of them at some point
09:02 - again if you're on Mac or Linux just use
09:04 - your normal terminal environment okay so
09:07 - I'm going to clear the screen with clear
09:09 - and the first thing we're going to do
09:10 - here is we are going to launch Docker
09:14 - desktop to start the engine and run the
09:16 - command to check if this is working so
09:18 - we're going to type Docker build X LS
09:22 - like that now we're going to see that we
09:24 - might get this protocol thing uh don't
09:25 - worry about that what we're looking for
09:27 - here is that we have the Linux risk 64
09:31 - installed inside of this you can see
09:33 - that I have Linux risk 64 if you don't
09:37 - see that so if you don't see it right
09:39 - what you're going to do is run this
09:40 - command here pseudo APD install Q menu
09:43 - user static don't worry about what
09:45 - that's really doing but we just need
09:47 - this architecture installed in our kind
09:50 - of Linux distribution so again if we go
09:52 - back here now we're on Linux okay same
09:55 - thing exact same command we want to make
09:57 - sure we see that in our terminal like
10:00 - that okay now we want to make sure that
10:03 - we have git
10:04 - installed so you can see I have git
10:06 - installed here if you don't have git
10:08 - you're going to install git on your
10:10 - machine you can click on this link link
10:12 - right here again in Windows same thing
10:14 - Linux Mac and install G now what we are
10:16 - going to do is clone a repository that
10:19 - we are going to use for this tutorial
10:21 - that has some starting code for us now
10:24 - the link that's here is actually not
10:25 - correct I'm going to pop it up here and
10:27 - I'll will put it in the description this
10:29 - is the caresi rollups example repository
10:31 - so it says rollups example right here
10:33 - and if we click on code we can copy that
10:35 - again don't worry I'm going to put that
10:37 - in the description so you guys can just
10:38 - copy it from the description okay but
10:40 - it's get up.com cartesi robs
10:43 - examples. so what we're going to do is
10:45 - we're first going to make sure we're in
10:47 - the folder that we want this to exist in
10:49 - so you see right here like I'm in just
10:51 - my home folder so if I type print
10:53 - working directory I get slome SL Tim now
10:57 - if I want to be in a folder that that
10:59 - I'm able to access from Windows because
11:01 - I'm in WSL what I'm going to do here is
11:04 - uh let me get out of this cd. dot CD do
11:08 - Dot and LS now notice here we got a
11:10 - bunch of stuff appearing what we
11:13 - actually want to CD into here is Mount
11:16 - now this is only if you're on Windows
11:19 - and in WSL if you're in a normal
11:21 - terminal environment you can just save
11:22 - this wherever you want but I'm trying to
11:23 - show you on Windows how you'll be able
11:25 - to access these files so I CD into Mount
11:28 - then I can type out s and notice that I
11:29 - have all my drives so I have CF so I'm
11:32 - going to CD into my C drive notice LS I
11:35 - got a bunch of files here okay I'm going
11:36 - to CD into users CD into Tim CD into
11:42 - desktop and now I'm on my Windows
11:44 - desktop which is mounted to my Linux
11:47 - environment so this just allows me to
11:48 - share files between my auntu
11:50 - installation and my Windows installation
11:52 - which is my host operating system okay
11:55 - now what I'm going to do is just make a
11:56 - directory or CD into a directory where I
11:58 - want to clone so I actually have a
12:00 - directory called cartez on my desktop so
12:02 - I've cded into there now that I'm inside
12:04 - this environment I'm going to clone the
12:06 - repository so I think I can actually
12:08 - just paste this command or actually no
12:09 - that's just the URL and I'm going to
12:11 - type get clone and I'm going to clone
12:14 - this repo okay so that's going to take a
12:16 - second and I'm going to clone this into
12:18 - cartei and now that we have this cloned
12:20 - we'll actually be able to work with this
12:22 - and start setting everything on again on
12:23 - Mac or Linux just clone the repo
12:25 - wherever you want we're now going to CD
12:26 - into that repo so the repo is rollups
12:29 - examples and if I LS you see that we get
12:31 - a bunch of stuff now to make this a
12:33 - little bit easier for us to see we can
12:35 - open up a code editor like Visual Studio
12:37 - code and we can view all of the
12:40 - different code inside of our folder so
12:42 - you see I have rollups example okay and
12:43 - I've got a bunch of folders inside of
12:45 - here that I can start working with erc20
12:49 - uh Eco rust whatever uh or sorry not Eco
12:52 - echo echo rust Echo python Etc and these
12:55 - are all examples of how to write carteia
12:57 - code feel free to have a look through it
12:59 - you can read the readmes and stuff but
13:00 - I'm going to give you the in-depth
13:01 - explanation okay so now let's open this
13:04 - back up we've cloned the repository and
13:07 - what we want to do next is we want to CD
13:08 - into the echo python repository which
13:11 - contains a very simple decentralized app
13:14 - in Python that we're going to work with
13:16 - so CD into Echo Python and then clear
13:19 - now I want to make it very clear that
13:20 - all the commands I'm running again are
13:22 - from my wsl2 abun to installation if you
13:25 - do this from Powershell or from a
13:27 - terminal if you're on Windows it will
13:29 - break everything make sure you are in
13:31 - your Linux environment for those of you
13:33 - who get on macro Linux don't worry about
13:35 - that okay now that we're inside of echo
13:38 - python we can go to vs code and we can
13:41 - have a look at our Echo Python and if we
13:43 - go to echo. py which is our main python
13:45 - file here we can quickly run through
13:48 - some of the code now it's going to seem
13:50 - a little bit confusing but essentially
13:52 - the way that all of this is going to
13:53 - work is there is a bunch of code that we
13:56 - didn't write this is stuff provided by
13:58 - cartei inside of something known as the
14:00 - cartei machine the cartei machine is
14:03 - going to take any data that is submitted
14:05 - on the blockchain it's going to do
14:07 - something known as a rollup and it's
14:08 - going to send a bunch of requests to our
14:11 - backend now this makes our backend act
14:14 - very similar to a web server it's not
14:17 - quite like that but it's very similar in
14:19 - terms of how we receive and send data so
14:21 - we have our main Loop down here now
14:24 - we're going to run this in a second but
14:25 - essentially what we're doing is we're
14:27 - waiting to receive some kind of request
14:31 - now the request can be one of two things
14:33 - it can be an inspect request or an
14:35 - advanced request inspect simply acts
14:39 - kind of like a get request where we're
14:41 - receiving some kind of request to return
14:43 - some data so someone is saying hey I
14:45 - just want to inspect the state of this
14:48 - machine I want to see for example what
14:50 - this variable is I want to see what
14:52 - players have what balance whatever right
14:54 - whatever the application is doing
14:55 - inspecting allows us to view the state
14:58 - Advanced state is something like a post
15:01 - request or a put request could be a
15:03 - delete request as well anything that
15:05 - might actually modify the state of the
15:07 - machine this comes through as a
15:09 - transaction and what we're able to do is
15:12 - kind of handle this Advanced State
15:14 - request and respond to it by doing
15:16 - something specific we're going to get
15:17 - into this more and more but the way that
15:19 - our cartei machine and really our whole
15:21 - backend which is what this is right here
15:23 - think of this kind of like your kind of
15:25 - pseudo smart contract is it acts as a
15:27 - state machine and this state is held
15:29 - however you want could be in a variable
15:31 - could be on the file system could be in
15:32 - a database whatever you want to do okay
15:35 - the state is held and any time you get a
15:37 - request which is an advanced State you
15:39 - can modify the state or respond to that
15:41 - when you get an inspect request you're
15:43 - going to return some data which is some
15:45 - information about the state of the
15:47 - machine okay and this is a little bit in
15:49 - terms of how carteia works with security
15:52 - since we have these discrete States
15:54 - we're actually able to reproduce these
15:56 - states and to verify that states are
15:58 - correct correct we'll talk about that
15:59 - later on but that was kind of a very
16:01 - quick primer Okay so we've got this back
16:04 - end which is in echo. piy now there's a
16:06 - bunch of other files here we don't need
16:07 - to look at those right now what we're
16:09 - going to do is go back and we're going
16:10 - to start trying to kind of run all of
16:11 - this code so let's open up this okay so
16:16 - there's some explanation here where it
16:17 - says Advance inspect Etc and these are
16:19 - just regular HTTP requests that we're
16:22 - responding to in Python now what we need
16:25 - to do is run the environment now since
16:28 - we're running kind of a blockchain
16:29 - application well the first thing we need
16:32 - is some kind of blockchain network now
16:34 - we're not going to run this on a main
16:35 - Network like ethereum because we're just
16:37 - doing development instead what we're
16:38 - going to do is run this on kind of a
16:40 - test Network the test network is just
16:42 - going to be running locally on our
16:44 - computer once we run the test Network we
16:47 - are then going to run our backend and
16:49 - our backend is interacting with the test
16:52 - blockchain network using the caresia
16:54 - machine so the first thing we need to do
16:56 - from this Echo python directory is run
16:59 - this command so let's copy it in
17:01 - actually I'll just type it Docker build
17:04 - X bake D- load okay from the echo python
17:08 - directory we're going to go ahead and
17:10 - run this now this is going to build the
17:12 - entire Docker image and this is going to
17:15 - get everything set up so we can start
17:17 - running our test Network now the way
17:19 - that things will work is when we run our
17:21 - test Network all of the components that
17:23 - caresia requires to kind of work will
17:26 - automatically be deployed on chain
17:28 - there's a bunch of smart contracts that
17:30 - are kind of running in the background
17:31 - that we don't really need to know a lot
17:33 - about that are allowing us to use this
17:35 - framework so that we can write our kind
17:38 - of dap logic in a normal programming
17:41 - language so what we just did here is we
17:42 - just built the whole image for you it
17:44 - might take a little bit longer I believe
17:45 - I have some kind of cach here in my
17:47 - system anyways we've built that now what
17:50 - we're going to do is spin up what's
17:52 - known as our node okay this is the
17:54 - caresan node which is running all of the
17:57 - again kind of onchain components that we
18:00 - require for our code to work now it's
18:03 - also going to be running it's going to
18:04 - be running a few things okay it's not
18:05 - just that it's running some other stuff
18:07 - for the cartez rups framework I don't
18:09 - want to uh mislead you with my
18:11 - vocabulary but it's just running
18:12 - everything that we need for development
18:13 - okay that that's the way to think of it
18:15 - so I'm going to right click here and
18:16 - just copy in this command and just make
18:18 - sure that you kind of fix all the line
18:20 - breaks here because for example you
18:21 - could see I had this down on a separate
18:23 - line and that would break okay so we're
18:25 - Docker compose Docker compose Docker
18:28 - over ride Docker compose a bunch of
18:30 - commands you don't need to understand go
18:32 - ahead and hit enter and you're going to
18:33 - see that it spins up a bunch of stuff
18:35 - and we get some output kind of popping
18:36 - out on the screen okay what we're
18:38 - viewing right here is our node which is
18:41 - deploying a bunch of stuff that caresia
18:43 - needs and running U kind of a blockchain
18:46 - network for us locally on our
18:48 - computer okay amazing so that is step
18:51 - one we've got this running and we're
18:53 - always going to need this running when
18:54 - we do our development because this is
18:56 - the development server that we're
18:57 - working with right write the development
18:59 - note now that we have this running we
19:01 - can kind of leave that in the background
19:02 - we don't really need to worry about it
19:03 - we're going to open up another
19:05 - terminal now this terminal is where
19:07 - we're going to run the back end this is
19:09 - the one that we can start we can stop
19:10 - and this is where we're really going to
19:11 - do quite a bit of our development so
19:13 - what we need to do is get back into the
19:15 - same directory we were in before so I'm
19:17 - just going to CD into it so CD into
19:20 - Mount C drive users Tim desktop
19:26 - cartei and then what is this rollups
19:29 - examples LS CD Echo python okay I'm
19:34 - inside of my uh directory now that I'm
19:37 - inside of the directory where this code
19:38 - exists again same place that we were
19:40 - here in here what we're going to do is
19:41 - start running our back end so first
19:43 - thing we're going to do is create a
19:44 - virtual environment to install all of
19:46 - the Python dependencies because again
19:47 - we're running this in Python just like
19:49 - we would run any python app so we're
19:51 - going to type Python 3 hypen M
19:54 - vv. venv this is just our virtual
19:56 - environment that we're creating which
19:58 - will store our dependencies you don't
20:00 - always need to do this just the first
20:02 - time you spin up an example so this
20:03 - going to take a second I'll be back when
20:05 - it's finished all right so now that we
20:07 - have created this virtual environment if
20:08 - I type LS you should see that we have a
20:10 - ven V or it's hidden because we have the
20:12 - dot folder but anyways there is a DOT
20:13 - venv directory here probably see it in
20:16 - vs code but that's okay and what we're
20:18 - going to do is just activate this
20:19 - environment so we're going to type Dot
20:21 - and then dot venv SL bin slash activate
20:27 - like that now that should activate the
20:28 - virtual environment and you should see
20:29 - this appearing you're probably not going
20:31 - to see Bass by the way this is just some
20:33 - kind of thing I have in my WSL
20:35 - installation don't worry about that but
20:36 - we have vvy now we're going to install
20:39 - the requirements for python so we can
20:41 - type pip install requirements.txt I'm
20:43 - going to make this pip three and we're
20:45 - going to install all of the ones that we
20:48 - need again this will take a second once
20:50 - it's finished I will be right back all
20:52 - right so all of that is installed and
20:54 - now that we have that installed we're on
20:55 - to actually one of the last steps which
20:57 - is running our back end so we're just
20:59 - going to copy this Command right here
21:02 - and what this will do is simply run this
21:04 - echo. py file but we're just declaring a
21:06 - environment variable that's going to be
21:08 - read by that file okay so that's why we
21:10 - have this text beforehand don't worry
21:12 - about it too much but we're saying the
21:13 - roll up HTTP server URL is equal to
21:15 - Local Host Port 54 this is just the port
21:18 - that this needs to be running on for
21:20 - everything to communicate correctly and
21:21 - then we're running the python echo. file
21:24 - by putting this beforehand again is just
21:26 - declaring an environment variable which
21:28 - will be read by this file so we're going
21:30 - to go ahead and hit enter and you will
21:32 - see here that some stuff starts coming
21:34 - in now you can see that I'm getting kind
21:36 - of some requests and some data that
21:37 - you're not going to see it's just CU I
21:39 - have some stuff cached on my system
21:41 - don't worry about it too much for right
21:43 - now but in your case you should get some
21:44 - output that kind of looks like this HTTP
21:46 - rollup URL sending finish sending finish
21:49 - no pending rollup whatever right you
21:51 - kind of see it's appearing here again
21:52 - don't worry about the stuff that's
21:53 - cached it's just because I had uh some
21:56 - stuff running on my system earlier when
21:57 - I I was testing this okay so now what we
22:00 - have is following we have our node which
22:03 - is running and we have our back end the
22:05 - backend is what's going to handle all of
22:07 - the logic and the node is what's going
22:08 - to take care of essentially forwarding
22:10 - that logic logging it and making sure
22:12 - everything is secure what we need to do
22:14 - now is need to actually interact with
22:17 - our smart contract um application right
22:19 - or with our decentralized application so
22:21 - the way we can do that is we can send
22:23 - one of two types of requests to our back
22:26 - end now let's have a look at these again
22:29 - from our code so you can see that we
22:31 - have an advance and an inspect now an
22:34 - inspect is just querying the state okay
22:37 - it actually doesn't require that we go
22:39 - through the blockchain to do an inspect
22:41 - um it's kind of just like viewing event
22:43 - data or viewing logs of a normal smart
22:45 - contract that's kind of what an
22:47 - inspector request is doing we then have
22:49 - advance and Advance is actually
22:50 - advancing the state and anytime we
22:52 - change the state of our machine this
22:54 - needs to be verified and secure so this
22:56 - actually requires a transaction on the
22:59 - blockchain okay now let me show you how
23:01 - we interact with this so what I can
23:02 - actually do is from any terminal doesn't
23:04 - have to be my WSL terminal I can send a
23:08 - kind of Inspector advaned request to my
23:11 - application so I'm going to CD into the
23:14 - robs examples and CD into Echo python
23:20 - now what actually sorry we're not going
23:21 - to go into Echo python we're going to go
23:23 - into the front-end console the front end
23:27 - console is just a little tool that's
23:28 - built by caresi which allows us to
23:30 - interact with our dap now remember in
23:32 - the previous video I showed you a front
23:33 - end I built in react that was my
23:35 - front-end console right that was how I
23:37 - was interacting with the application you
23:39 - can write your own interacting code or
23:41 - you can just use this one from caresan
23:43 - so I'm going to put this on the left
23:45 - side of my screen here let me just make
23:46 - this so we can see it and we're going to
23:50 - start interacting with the back end now
23:53 - to do that we go into the front end
23:54 - console and we need to install our
23:55 - dependencies this is a normal kind of
23:57 - javascrip package so we're going to type
23:58 - yarn okay just going to install
24:01 - everything that we need inside of the
24:02 - front end console once that's done I'll
24:04 - be right back okay installation is done
24:07 - we are now going to build the
24:08 - application by typing yarn build okay
24:11 - and now that that is built we are going
24:13 - to take this Command right here and what
24:15 - this is going to do is send an input to
24:19 - our back end so I'm going to paste this
24:20 - here I'm going to close this guide now
24:22 - let's open up our back end which is this
24:25 - now I was just testing this a second ago
24:27 - so you can see actually have some output
24:29 - anyways what we typed is yarn input send
24:31 - and then we're sending a payload which
24:33 - is just some text now what our backend
24:36 - currently does and I mean we can read
24:37 - the code if we want to is it simply
24:39 - creates something known as a notice and
24:42 - a notice contains the exact same data
24:46 - that we sent to the application hence
24:47 - the name Echo python we're going to talk
24:49 - about notices reports and vouchers which
24:51 - are important in one second but for now
24:54 - I just want to make sure that this is
24:55 - working so what we do from the front end
24:56 - console is the start input send we send
24:59 - a payload and this is going to
25:01 - essentially trigger the Advan State type
25:04 - of request okay so what I'm going to do
25:06 - is hit enter and when I do that quite
25:09 - quickly once this actually sends you're
25:11 - going to see in my back end that I will
25:14 - actually get a transaction coming
25:15 - through so it says sending hello world
25:18 - this is my first St and then it will say
25:20 - the inputs added now you can see here it
25:22 - says receive the advanced request data
25:24 - here's the metadata here's the message
25:26 - sender and then we have a payload now
25:29 - this is hexadecimal encoded so we do
25:31 - have to decode it if we want to be able
25:32 - to read it that's fine don't worry about
25:35 - that right now we'll look at that later
25:37 - the point is that we sent some data it
25:39 - was received by our backend and if we
25:41 - actually go over here to our host or to
25:44 - our node uh you will will have seen if
25:47 - you look at all of the uh kind of data
25:49 - going on here that a transaction went
25:51 - through so it was sent using the
25:53 - blockchain and it was received here in
25:55 - our back end so our back end is is able
25:57 - to respond to that and do whatever it
25:59 - needs to do again being sent through the
26:02 - blockchain network I know this is a
26:04 - little bit confusing but if all of this
26:06 - works what I just showed you you are set
26:08 - up you are ready to go and we have
26:10 - everything that we need now the last
26:12 - thing I can quickly show you before I
26:13 - start getting into some explanations of
26:15 - what the heck it is that we actually
26:16 - just did is the following so what
26:19 - happens is that our backend so if we go
26:22 - here yeah back end is able to generate a
26:24 - few different types of outputs right if
26:26 - you're familiar with contract
26:28 - development you know that whenever you
26:29 - have a transaction you can't actually
26:31 - return data from that there's no way to
26:34 - return information back to the center
26:36 - instead what you can do is you can emit
26:38 - events right and these events are kind
26:40 - of like logs of what's occurred now in
26:43 - cesi we have three types of things that
26:45 - we can kind of emit or create that can
26:47 - give the user some information about
26:49 - what happened in the back end we can
26:50 - create something known as a notice now a
26:53 - notice is something that's verifiable on
26:54 - the blockchain network they pretty much
26:57 - notify all of the users who are
26:58 - interested in the state of the uh
27:01 - application that something occurred so a
27:03 - notice could be hey this user deposited
27:06 - some money this user withdrew some money
27:08 - whatever something that everyone would
27:09 - care about that we'd actually want to be
27:11 - verifiable that's a notice and you
27:13 - actually saw that what happened was when
27:15 - we sent an advanced request here we
27:17 - created a new notice now these notices
27:21 - we can view we can query them we can
27:22 - have a look at them now as well as
27:23 - notices we can create a report now a
27:26 - report is what's right here and a report
27:28 - is essentially some kind of log some
27:30 - information giving you typically
27:32 - debugging information or it could be
27:34 - some information about the state of the
27:36 - machine something that we don't need to
27:39 - really have stored on the blockchain
27:40 - that doesn't need to be verifiable and
27:43 - that is essentially just telling you
27:44 - what happened in the transaction that
27:46 - you sent or in the request that you sent
27:48 - to the backend so it could be hey there
27:50 - was some issue with what you did so we
27:52 - generate a report kind of like an error
27:54 - message that you might get from a
27:55 - regular smart contract we could also
27:57 - generate a report and say hey the data
27:59 - that you wanted it's stored inside of
28:00 - this report go ahead and have a look at
28:02 - it okay those are the two types of
28:04 - outputs notice and report and we have
28:06 - something known as a voucher which
28:08 - allows you to interact with other smart
28:09 - contracts which we'll talk about later
28:11 - on anyways what happened was is we
28:14 - generated a notice now these notices we
28:16 - can view so if we go back here you can
28:19 - see that we have a command yarn start
28:21 - notice list if I run this what it will
28:24 - do is it will list out all of the
28:26 - notices that have been generated by my
28:28 - backend so we'll give this a second here
28:31 - and we should see that we get some kind
28:33 - of output and it shares with us a list
28:35 - of all of the notices and you can see
28:36 - that we have these notices so we sent a
28:38 - payload right and said hello world this
28:40 - is my first app and you can see that
28:42 - we're viewing it right here now there's
28:44 - a bunch of other notices because again I
28:45 - was telling you I was messing with this
28:46 - later we have notices like accepting a
28:48 - challenge um what do you call it
28:50 - creating challenges remember from the
28:52 - first video these were some of the
28:53 - inputs that we were sending so there's a
28:55 - whole log of them and we can see
28:57 - everything that's occurred perfect so
29:00 - that is kind of the basic idea here
29:02 - behind the setup I'm going to get more
29:04 - into the explanations you understand how
29:06 - this works but for now we can clear this
29:09 - we can close that up and we can start
29:11 - tearing down our development environment
29:13 - now when we tear down our development
29:14 - environment there's a few things that we
29:16 - need to do so first of all we can go to
29:18 - the back end and we can simply just shut
29:19 - the back end down by hitting contrl C
29:22 - Okay contrl C close it down that's fine
29:25 - if we were to start running this again
29:27 - in our node were still to be up here
29:29 - what would happen is it would actually
29:31 - resend all of the different inputs that
29:33 - are stored on the blockchain because
29:34 - they're securely logged and our back end
29:36 - would be in the same state it was when
29:38 - we shut it down so what that actually
29:40 - means is that we can have as many
29:42 - versions of the back end as we want
29:43 - running around the world decentralized
29:45 - as many as we want to and they can all
29:47 - be in the exact same state by viewing
29:50 - the information that secure that's
29:51 - stored on the blockchain but all the
29:53 - computations are done offchain which is
29:55 - what's giving us that kind of
29:56 - performance benefit anyways we shut down
29:58 - the back end and we're going to shut
30:00 - down our node by just hitting contrl C
30:03 - now it's going to stop a bunch of
30:04 - containers here but we're not quite done
30:06 - I'm just going to close this we have
30:08 - this command here and what this command
30:10 - will do is actually tear down the
30:12 - environment for us and remove logs of
30:15 - what's currently stored in this node so
30:17 - that if we start it up again we're kind
30:18 - of starting fresh so it's a good thing
30:21 - to know you always want to be running
30:22 - this command when you're doing like a
30:24 - new cycle of development so you don't
30:25 - have all of these inputs that you did
30:27 - previously logged on the blockchain so
30:29 - we're just going to copy this command in
30:31 - now again there's some issues with the
30:32 - line breaks so I'm just going to fix
30:34 - those there this is again deleting some
30:36 - of the containers volumes Etc so you can
30:39 - see all these volumes are getting
30:41 - removed which is what we want and now we
30:43 - have torn down our environment amazing
30:46 - there you go that is how you set up your
30:48 - environment for writing decentralized
30:50 - applications in Python again please
30:52 - refer to these guides I recommend you
30:53 - download them and keep them because
30:55 - they're helpful to share with you the
30:56 - commands you need to copy and paste if
30:59 - we're getting started again we're just
31:01 - going to start from running our backend
31:03 - so we're literally just going to run the
31:05 - backend we're going to run our node as
31:07 - well okay so make sure that's up and
31:09 - running and then we can just use the
31:10 - front end console and we can interact
31:12 - with our application okay so now that
31:14 - all of that is done let me open up a few
31:17 - pieces of documentation here and I'll
31:18 - start sharing with you exactly what it
31:20 - is we just did and kind of how all of
31:22 - this stuff works so here is a basic kind
31:24 - of overview of the architecture of how
31:26 - this works
31:27 - we have a front end we have some chain
31:29 - this chain is just a blockchain network
31:31 - right something like ethereum we then
31:33 - have our cartei rollups framework and
31:36 - what that consists of is a cartez
31:37 - machine which has the HTTP rollup server
31:41 - and our back end now the cartez machine
31:43 - is a virtual machine that runs on a
31:46 - Linux risk 5 architecture now this
31:49 - machine is very important to the
31:50 - security of cesia which we'll get into
31:52 - later but for now what I want you to
31:54 - understand is that what we focus on as
31:55 - the developer here is the front end and
31:58 - the back end just like we would in a
31:59 - traditional web application the front
32:01 - end is what's interacting with the chain
32:04 - or directly with our Cartesian machine
32:06 - what it can do is it can send
32:08 - transactions or Advance kind of state
32:11 - requests which are aiming to change the
32:13 - state of the cartisian machine this is
32:15 - something that wants to be verifiable
32:17 - that we have to pay for right we got to
32:18 - pay our gas submit that to the network
32:20 - even though it will still be a lot
32:21 - cheaper and then we have inspect which
32:23 - again is kind of like a get request I
32:25 - just want to see what's going on I want
32:26 - to inspect this State I don't need to go
32:28 - through the evm chain to do that I can
32:30 - go directly to the Cartesian machine
32:33 - okay so this are the two types of things
32:35 - we can do right advance and inspect and
32:37 - we're going to look at these more in
32:38 - depth later on inside the caresia
32:40 - machine we have the rollup server and we
32:42 - have the backend now what the rollup
32:43 - server is doing is really facilitating
32:46 - the communication between our back end
32:48 - and our evm chain and it's doing quite a
32:50 - few other things as well but what's
32:52 - important for us to understand is that
32:53 - we don't really even need to worry about
32:54 - what this is doing we just need to focus
32:56 - on our back end so we need to respond to
32:58 - the advance and the inspect State
33:01 - requests but that's all we need to do
33:03 - everything else from the rollups the
33:04 - Securities the disputes Etc will be
33:06 - handled by the machine the rollups
33:08 - framework and the rollups server but
33:10 - what you noticed is that we were
33:12 - receiving requests in our code as just
33:15 - normal HTTP requests right just normal
33:18 - requests and we were actually creating
33:20 - requests that were posting or creating
33:23 - new notices reports vouches Etc so we're
33:26 - able to work in a very familiar
33:27 - environment using an HTTP API which
33:31 - we'll talk about later on from our back
33:32 - end which interacts with the RO up
33:34 - server okay so if we look at our things
33:37 - right we have CES rollups a set of
33:39 - onchain and offchain components that
33:41 - Implement an optimistic rollup solution
33:42 - and provide the general framework for
33:44 - building daps Cartesian machine a
33:46 - virtual machine that runs an entire
33:48 - Linux operating system in which the daps
33:51 - backend is executed so anything that can
33:53 - run inside the cesan machine we can
33:55 - write so we can write in multiple
33:56 - languages one language we can use all
33:59 - kinds of stuff we can use the file
34:00 - system math tools Etc because we can
34:02 - write the whole back end inside of this
34:04 - VM we then have the DAP backend this is
34:07 - the application State and verifiable
34:09 - logic which corresponds to the DAP smart
34:11 - contract the backend runs inside the
34:13 - cartes machine as a regular Linux
34:15 - application front end the application's
34:17 - user facing interface such as web app
34:18 - that is the most basic part now there's
34:20 - a bunch more stuff here you guys can go
34:22 - ahead and read through this just by
34:23 - looking up cartei we have the cartez
34:26 - machine though which I will quickly
34:27 - touch on so Central to cartez rups is
34:30 - the cartez machine now what this does
34:32 - code execution abstraction of
34:34 - infrastructure flexibility and
34:36 - scalability the important stuff here is
34:38 - the following the cartisian machine
34:40 - contains discrete States now the way
34:43 - this kind of works that we run in
34:44 - something known as a risk five
34:46 - architecture this architecture is
34:48 - important and this is essentially the
34:50 - instructions that are being executed by
34:52 - our code now it's pretty complicated but
34:55 - what happens is anytime we receive some
34:57 - kind of request so if we go back to our
34:59 - code here what we do is we execute some
35:02 - instructions on the CPU or inside of our
35:05 - virtual machine okay now these
35:07 - instructions we don't really know
35:09 - exactly what they are as you know normal
35:11 - python developers that don't work in
35:12 - assembly and low-level languages but
35:14 - when I do things like create a variable
35:16 - or send a request or log some
35:17 - information these are instructions okay
35:20 - they're executed now these instructions
35:22 - are discret it means every single time
35:24 - we receive some kind of input or some
35:26 - spe or whatever the instructions we're
35:29 - going to do are going to be the exact
35:30 - same so that means that if we receive
35:32 - some kind of state we know based on what
35:35 - we receive exactly what the next state
35:37 - of the machine should be and we know
35:39 - what the current state of the machine
35:41 - should be based on all of the previous
35:43 - States I'm not sure if this is making
35:44 - sense but we start in some state zero we
35:47 - know what that state is and it's
35:48 - verifiable what the state is okay we
35:51 - receive some kind of input that advances
35:54 - us to another state only that input
35:56 - would have advanced us to that next
35:58 - state now since this kind of makes our
36:01 - backend act like a state machine we can
36:03 - actually verify it any point in time if
36:05 - the states being produced by the back
36:07 - end are valid based on the inputs that
36:10 - were sent and what we do is we store all
36:12 - of the inputs on the blockchain so those
36:14 - are secure and then we can verify that
36:17 - what's being produced by our different
36:19 - machines which are running offchain is
36:21 - correct that is a very very very high
36:23 - level overview of how this works but if
36:25 - we read through here stay TR transitions
36:27 - happen deterministically as I was saying
36:28 - any state transitioning from one state
36:30 - to another state is deterministic it
36:32 - will always be the same now as the
36:34 - emulator processes the risk five
36:36 - instructions changing the state of the
36:37 - system to a new discrete State
36:39 - determinism given the same initial State
36:41 - and input caresan machine will always
36:43 - produce the same output and final state
36:46 - to ensure that the offchain computations
36:47 - can be verified and agreed upon to
36:50 - engage with cartes rups either interact
36:52 - by sending requests or accessing
36:53 - generated outputs now you can read
36:56 - through more of this if you want but the
36:57 - general idea is Cartesian machine acts
36:59 - as a state machine its state is always
37:01 - verifiable because it's discreet and it
37:04 - is deterministic that means if we
37:06 - advance the state by some input any
37:08 - other caresan machine should have the
37:10 - exact same state if it doesn't that
37:13 - means it's a malicious actor it's doing
37:15 - something incorrect and using blockchain
37:17 - technology and consensus mechanisms we
37:19 - can actually say hey what was produced
37:21 - by this caresi machine or someone who is
37:24 - controlling this some node on the
37:25 - network was invalid
37:27 - kind of similar to how it works in
37:28 - things like ethereum or any other
37:30 - blockchain network where if you get some
37:32 - kind of output that is not verifiable
37:35 - that's not correct you reject it right
37:37 - you don't accept that and there's some
37:39 - kind of ways of of handling that and um
37:41 - some validators and stuff like that we
37:43 - don't need to get into all of it but the
37:44 - point is to understand caresan machine
37:46 - State machine can advance its machine
37:49 - discreetly and deterministically which
37:51 - allows us at any point in time to
37:53 - understand if it is valid the state or
37:55 - not valid it also means we can have as
37:57 - many cartisian machines running as we
37:58 - want these are all nodes sitting on our
38:00 - Network and they can always have the
38:02 - exact same state because they're simply
38:04 - reading the inputs which are verified on
38:06 - the blockchain network which is layer
38:08 - one all right so now that we understand
38:10 - a little bit about that let's go over
38:11 - here and talk about the backend API
38:13 - which is most prevalent to us as the
38:15 - developer so what happens in the backend
38:18 - we have the rollups framework which I
38:20 - told you is sitting inside of um our
38:23 - caresan machine and we have our back end
38:25 - again which is running inside of this
38:26 - Lin VM which is the cartei machine what
38:28 - the backend will do is it will
38:30 - consistently send a finish request to
38:33 - the cartez rups framework which just
38:34 - working on a simple HTTP API and when
38:37 - this finished request is sent it will
38:39 - essentially set their idle and it will
38:41 - wait for a new request or a new state
38:43 - inspect whatever to be sent now once we
38:46 - get one of these the backend can perform
38:48 - all of its logic it can store stuff it
38:51 - can delete stuff it can do whatever it
38:52 - needs to do and it can generate outputs
38:55 - that tell whoever is using this
38:57 - decentralized application what's going
38:58 - on the three types of outputs it can
39:00 - create are a voucher a notice and a
39:03 - report we've already touched a bit on
39:04 - notice and reports vouer will touch on
39:06 - in a second okay so you can see here
39:09 - advaned state provides an input to be
39:11 - processed by the back end in order to
39:12 - advance the application State this is
39:14 - what needs to be verified on the
39:15 - blockchain and submitt on the blockchain
39:17 - inspect state does not need to be
39:18 - handled on the blockchain and it submits
39:20 - a query about the application's current
39:22 - state when running inside a ctes machine
39:25 - its operation is guaranteed to leave
39:26 - leave the state unchanged okay we cannot
39:29 - change the state using an inspect
39:31 - request which is why it's fine for us to
39:33 - just submit this directly to the node
39:35 - and skip over the blockchain which makes
39:37 - things a lot lot faster for inspect
39:39 - State requests this input data contains
39:41 - only a payload all right now let's go
39:45 - through and talk about vouchers notices
39:47 - and reports quickly and then we can wrap
39:48 - up this video all right voucher so a
39:51 - vouer is a combination of a Target
39:52 - address and a payload in bytes it is
39:55 - used by the offchain machine to respond
39:57 - and interact with layer one contracts so
40:00 - a question you might be asking is okay
40:01 - well if I'm running this caresia machine
40:03 - offchain how do I do things like redeem
40:06 - an erc20 token how do I interact with an
40:08 - nft how do I interact with other smart
40:10 - contracts or a defi protocol well you do
40:13 - that using a voucher so what you can do
40:15 - is you can submit a voucher you can
40:17 - create one from your dap and that
40:19 - voucher can then be executed on chain
40:23 - now there's some smart contracts written
40:24 - by carteia that do this but you can see
40:26 - that vouches can only be executed when
40:28 - the epoch in which they're contained in
40:30 - is finalized now we're going to go back
40:31 - to that and talk about in a second but
40:32 - vultures are your way of essentially
40:34 - transferring assets and interacting with
40:36 - onchain components next we have notices
40:39 - now a notice is an arbitrary payload
40:41 - inites that is submitted by the offchain
40:43 - machine for informational purposes
40:45 - similar to vouchers when the epoch
40:47 - containing a notice is finalized a proof
40:48 - will be produced so the validity of the
40:50 - no content can be verified on Chain by
40:52 - any interested party now a report is an
40:54 - application log or piece of diagnos
40:56 - information as I talked about like a
40:58 - notice represented by arbitrary payloads
41:00 - report is never associated with a proof
41:02 - and is thus not suitable for trustless
41:03 - interactions so you don't use a report
41:06 - to verify something is correct or what
41:08 - not you just use it for Diagnostic or
41:10 - logging piece of information lastly we
41:12 - have a portal as the name suggests you
41:15 - are using a uh sorry a portal teleports
41:17 - assets from the ethereum blockchain to
41:19 - daps running on caresi rups so let's say
41:21 - I want to send some money to my
41:22 - decentralized application well it's not
41:24 - running on ethereum it is running
41:26 - running on layer two so I need to send
41:28 - it through a portal that portal will
41:29 - then inform my decentralized application
41:32 - hey you received some money and then you
41:34 - can handle the money however you would
41:36 - in a normal decentralized application
41:38 - okay so that's kind of how a portal
41:39 - works and there's portals for sending
41:40 - regular ethereum erc20 erc721 and these
41:43 - other types of erc20 tokens okay now
41:46 - let's quickly go up here and we can talk
41:48 - about nodes and EPO so we have nodes
41:52 - just like we have in any type of
41:53 - blockchain network and these nodes are
41:56 - the decentralized component right we
41:58 - have multiple people anyone can run a
41:59 - node if they want anyone can be a
42:01 - validator anyone can be a reader node in
42:03 - this case or a user now when we have
42:05 - these normal nodes user or reader nodes
42:07 - these are simply just advancing the
42:09 - state of the offchain machine uh and
42:11 - making sure that anyone can publicly see
42:13 - what the state of the machine is so for
42:15 - us to be able to know what the state of
42:17 - our application is we need to have some
42:19 - nodes running just like if we want to
42:21 - know what the state of the ethereum
42:22 - blockchain network is there needs to be
42:24 - some nodes that we can access on the
42:25 - ethereum blockchain that tell us the
42:27 - state exact same thing here except with
42:29 - the offchain component next we have
42:32 - validator nodes now similar to how
42:34 - validators work on ethereum or miners
42:36 - work on ethereum these are going to make
42:38 - sure that everything is honest that
42:40 - there's no uh kind of malicious activity
42:43 - going on and there is actually some kind
42:46 - of incentive mechanism that goes on here
42:48 - in terms of how validators get paid out
42:50 - how the gas fee goes there Etc there's
42:53 - some more complexities in this we're not
42:55 - going to get into this right now we
42:56 - start talking about deployment we can
42:57 - dive into it more but understand that
42:59 - there is an incentive mechanism using
43:01 - caresia tokens for validator notes and
43:03 - then the reader nodes again they're just
43:05 - making sure that everything is available
43:07 - now lastly we have Epoch now essentially
43:09 - what happens is all these validator
43:11 - nodes at certain points in time are
43:13 - going to checkpoint the state of the
43:15 - offchain machine on the blockchain so we
43:18 - know okay at this point in time
43:20 - everything was valid everything was
43:21 - Secure however they don't do this until
43:24 - they reach the end of an OT
43:26 - now an Epoch will contain a batch of
43:28 - inputs that follow the same cycle so
43:29 - you're not checkpointing every single
43:31 - state update you're doing it more
43:33 - efficiently now in order to end an Epoch
43:36 - all of the validators need to reach a
43:37 - consensus about the state of the machine
43:39 - after processing all of the batched
43:41 - inputs now once that consensus is
43:43 - reached they're going to essentially
43:45 - take all of the vouchers notices Etc and
43:48 - these are going to be considered final
43:49 - because they are checkpointed on the uh
43:52 - what do you call it on the blockchain
43:53 - network now during this Con ensus period
43:56 - is when disputes can occur so for
43:58 - example if a validator were to put
44:00 - something onto the network or say oh
44:02 - this is the state of the machine but all
44:03 - the other validator say no that's not
44:05 - the state of the machine like that
44:06 - that's not how it works based on the
44:07 - decentralized and consensus mechanism
44:10 - then they would reject the state coming
44:12 - from the dishonest validator I'm hoping
44:14 - that makes a little bit of sense but
44:16 - there is a dispute mechanism so if any
44:18 - validator sees that a uh state is
44:21 - incorrect coming from another validator
44:23 - they can dispute that state there is a
44:25 - process where they go through some kind
44:27 - of dispute game I'm not going to talk
44:28 - about that in this video and that is
44:30 - essentially the security mechanism now I
44:32 - will leave all of these links in the
44:33 - description so you guys can read them on
44:35 - your own if you are interested so that
44:37 - was the General architecture and key
44:39 - points that I hope you understand a bit
44:40 - of so that in the next video when we
44:42 - start writing code things are in context
44:45 - and you have some foundation for why it
44:47 - is we're writing code in the way that we
44:49 - are now in the next video we'll start
44:51 - writing our back end once we finish that
44:53 - we'll then move on to the front end but
44:55 - I just want to make it clear clear that
44:56 - what we'll be doing is actually using
44:58 - kind of the template that you see right
44:59 - here now this might seem a little bit
45:02 - confusing right the way that we're doing
45:03 - things isn't 100% clear because we
45:05 - haven't walked through this line by line
45:07 - and you can see that we have a function
45:09 - for example to handle inspect requests
45:11 - handle Advan requests we are logging
45:13 - some information we're creating uh what
45:16 - is it reports notices Etc now this is
45:19 - just using kind of standard python we
45:21 - don't have any highlevel framework we're
45:22 - not abstracting away any of the
45:24 - complexity now intentionally I'm going
45:26 - to show you how to do it this way
45:28 - throughout the tutorial so that you
45:30 - really have a deep understanding of
45:31 - exactly what's going on at the lowest
45:33 - level possible and then eventually you
45:36 - can move on to start using something
45:37 - known as the highlevel Frameworks now
45:39 - just to give you an example of what I'm
45:41 - talking about I'll actually show you how
45:43 - we would write the same code that we
45:45 - just saw using the cartei python
45:48 - highlevel framework now really what this
45:50 - is is a framework that wraps over top of
45:52 - some of the complexity we just saw and
45:54 - puts things in a more famili amiliar
45:56 - environment for us typically web 2
45:58 - developers so you can see here we're
46:00 - using a framework here that's wrapping
46:01 - some of that complexity and we have
46:03 - things like dap. Advance dap. inspect
46:06 - creating a report notice this is cleaner
46:08 - a little bit easier to understand and
46:10 - there's a bunch of these Frameworks that
46:12 - are being created by the caresia
46:13 - community and that you could actually
46:15 - contribute to so I'll pop open some of
46:17 - the GitHub Pages as I kind of just go
46:19 - through the value proposition here so
46:21 - for example we have python caresia which
46:23 - is the one I just showed you where it
46:24 - gives us a very familiar API and
46:26 - development experience what we might
46:28 - have in web 2 we have one for go rollups
46:31 - now this is just a framework in cartez
46:33 - for go right to make things easier we
46:34 - have another one called a roll same
46:36 - thing makes things easier and go when we
46:38 - work with cartesi code then we have one
46:40 - for typescript this is called droll
46:42 - right so these are four that you could
46:44 - use I'll link these in the description
46:45 - in case you want to check them out and
46:47 - the main advantage here is that these
46:48 - are rapidly being improve to make your
46:50 - life easier as a developer and you could
46:53 - actually contribute to these because
46:54 - most of them are created by community
46:56 - members now this will also just make it
46:58 - a little bit easier to write the code
46:59 - and have some cleaner code and it's a
47:01 - more familiar experience for most of us
47:04 - last of all it's going to give you a
47:05 - better ability to unit test your code
47:07 - which is not something we'll do in this
47:09 - series but if you were making a
47:10 - production application you'd probably
47:12 - want to write some tests so again the
47:14 - way we're going to do things is without
47:15 - using these Frameworks just to make sure
47:17 - we don't have them as a dependency and
47:19 - we don't rely on some of the
47:20 - abstractions that we don't fully
47:22 - understand but once we get through all
47:23 - of that you're going to be an expert in
47:25 - w kind of the base level cartey code and
47:28 - you can start using these Frameworks and
47:30 - actually understand what a lot of the
47:31 - methods and abstractions are doing
47:33 - anyways that was it for this video if
47:35 - you made it to the end give yourself a
47:37 - pat on the back I am excited to bring
47:40 - you on to the next video we'll start
47:41 - writing some code and some logic I hope
47:43 - you are too and I will see you
47:46 - [Music]
47:52 - there