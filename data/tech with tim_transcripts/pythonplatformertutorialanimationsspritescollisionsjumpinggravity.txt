00:03 - foreign
00:09 - [Music]
00:18 - with you how to build a platformer game
00:21 - in Python this game will have Pixel
00:23 - Perfect Collision it will have an
00:24 - animated character as you can see here
00:26 - it will have single and double jumping
00:28 - it will have all kinds of different
00:30 - animations for falling jumping colliding
00:33 - with obstacles for example you can see
00:35 - here when I hit the fire I kind of go
00:37 - into this hit State I will show you how
00:39 - to generate different objects how to
00:41 - scroll the background and really at the
00:43 - end of this video you will have a solid
00:45 - fundamental understanding of how to
00:46 - build a platformer game in Python and
00:49 - you can go and extend this and build
00:50 - really anything that you can think of I
00:53 - will even include a ton of free assets
00:54 - for you that allow you to change your
00:56 - character change the terrain change the
00:58 - background and do all of that extremely
01:00 - easily in fact in this tutorial alone I
01:03 - will show you how to use four different
01:04 - characters let me show you those
01:06 - characters before we continue so this is
01:08 - the second character here this is being
01:10 - referred to as mask dude this is the
01:12 - third character I'm calling this guy the
01:15 - ninja Frog as you can see and Final
01:17 - finally we have this character here
01:19 - which is called pink man now in this
01:21 - tutorial you will learn how to use all
01:23 - of these characters and you can swap
01:24 - them out with a single line of code with
01:27 - that said I hope you're excited this
01:28 - video has taken a very long time to
01:30 - prepare so please click the like button
01:32 - subscribe to the channel and we'll dive
01:34 - in after a quick word from our sponsor
01:36 - thanks to dice for sponsoring this video
01:39 - dice is the platform for go-getters like
01:41 - yourself to find your next job in Tech
01:43 - that aligns with your values and skill
01:45 - set on dice.com you can easily search
01:48 - and filter for jobs and set personalized
01:50 - alerts so you never miss a job
01:52 - opportunity start by creating your free
01:54 - profile setting up your job alerts and
01:57 - then going visible and connecting with
01:59 - employers immediately now Beyond Just
02:01 - Landing a job dice helps you gain
02:02 - insights into the tech industry and
02:04 - learn what skills and Technologies you
02:06 - need to master to get to the next level
02:08 - with dice.com you get access to
02:10 - countless articles free ebooks and a
02:13 - variety of other resources that help you
02:15 - understand things like what tech
02:16 - salaries you can expect effect job
02:18 - postings by volumes the number of jobs
02:21 - by occupation and a lot of other
02:23 - valuable information that helps you
02:25 - craft your career in Tech we all know
02:27 - that searching for a tech job can be
02:28 - difficult but with dice it doesn't have
02:30 - to be click the link in the description
02:32 - to start leveling up with dice today and
02:34 - don't forget to download their mobile
02:36 - app so you never miss a great job
02:38 - opportunity thanks again to dice for
02:40 - sponsoring this video alright so let's
02:42 - go ahead and get into it now since this
02:45 - is a long video I do want to spend a
02:46 - minute here just talking about who this
02:48 - video is designed for exactly what
02:50 - you're going to learn and what you can
02:52 - expect just so you don't waste your time
02:53 - if you don't want to go through it so
02:55 - this video is really designed for people
02:56 - that have a bit of experience with
02:58 - python ideally you are an intermediate
03:00 - python programmer you understand the
03:02 - syntax you know for Loops you know
03:04 - functions you know all of that if you
03:06 - don't feel free to follow along but I'm
03:08 - not going to be explaining those basic
03:09 - concepts now this video will teach you
03:12 - how to build exactly what you see here
03:13 - so by the end of the video you will have
03:15 - exactly this and if you're not
03:17 - interested in waiting until the end of
03:18 - the video then you can download the code
03:20 - from the GitHub repository that I will
03:22 - leave in the description that's also
03:24 - where all the assets are going to be so
03:25 - regardless you're going to have to
03:27 - download the code from GitHub again I
03:28 - will leave that in the description
03:29 - download that open up the folder and
03:33 - kind of we can start working from there
03:34 - now really what I'm going to be showing
03:36 - you here mostly is Sprite sheet
03:37 - animation uh Pixel Perfect Collision
03:40 - using what's called masks and then how
03:42 - you can do the scrolling background
03:44 - generating objects all of that kind of
03:46 - stuff that is really the hard part when
03:48 - it comes to generating a platform or
03:49 - game once you have all of that down it's
03:52 - very easy to extend this to add levels
03:54 - to add like you know a finishing flag to
03:57 - add coins to add you know lives you can
04:00 - turn this game into anything you want
04:01 - and that's how I've designed this so
04:03 - that you have the base and then you can
04:04 - go and make it kind of a full-fledged
04:06 - game and work off of that so with that
04:08 - said I will stop talking now I think
04:11 - this game looks really good I'm excited
04:12 - to share this with you guys so let's get
04:14 - into actually building it
04:18 - so right now I have Visual Studio code
04:21 - open obviously we're doing this in
04:23 - Python and I already have Pi game
04:25 - installed now the first thing we're
04:27 - going to have to do is install pygame
04:29 - which is the module we're going to be
04:30 - using so to do that go to your terminal
04:33 - and type pip install Pi game if that
04:36 - doesn't work for you you're going to try
04:37 - pip 3 install Pi game if that doesn't
04:40 - work try python
04:42 - hyphen M pip install Pi game if that
04:45 - doesn't work try Python 3 hyphadam pip
04:47 - install Pi game if none of those work I
04:49 - will leave two videos on the screen that
04:50 - show you how to install that module now
04:52 - once you have Pi game installed I'm
04:54 - going to assume that you've downloaded
04:56 - the GitHub repository go to GitHub
04:58 - there's a little button that says click
05:00 - to download download the folder extract
05:03 - it to your desktop and then open it in
05:05 - vs code or whatever editor you want so
05:07 - you have something that looks like this
05:08 - you should have an assets directory
05:10 - inside of assets you should have a bunch
05:12 - of different folders then you should
05:14 - have a main python file that contains
05:16 - all of the finished code now obviously
05:19 - we're going to write the code from
05:20 - scratch but you can either work off that
05:22 - existing code or you can kind of clear
05:23 - the file and type along with me whatever
05:25 - you want to do I quickly want to run you
05:27 - through the assets folder and then we'll
05:28 - get into the code so in assets we have a
05:30 - ton of stuff we're not going to use most
05:31 - of this but I wanted to include all of
05:33 - it so that you could kind of continue
05:35 - the game later if you want so we have
05:37 - for example backgrounds these are a
05:38 - bunch of background tiles so you can
05:40 - change kind of the theme or color
05:42 - background very easily I'll show you how
05:44 - to do that we have items like boxes
05:46 - checkpoints fruits Etc we're not going
05:49 - to use any of those then we have main
05:51 - characters for main characters we have a
05:53 - bunch of sprite sheets inside of here
05:55 - and I'll show you how we can split these
05:56 - Sprite sheets apart and use all of the
05:59 - different kind of animations inside of
06:00 - here right
06:01 - so we have that for Mass dude ninja frog
06:04 - Pinkman and virtual guy all of the file
06:06 - names are the exact same okay then we
06:09 - have menu we're not going to be using
06:10 - anything from there we have other we
06:12 - have terrain we are actually going to be
06:14 - using terrain specifically we're going
06:16 - to pull out this kind of block here but
06:18 - you could change the block again if you
06:19 - want to do that and then we have traps
06:21 - and we are going to be using the fire
06:23 - trap wherever that is right here that
06:26 - has kind of an animation right where the
06:28 - fire is going but again you can add all
06:30 - of this stuff later on I'll show you
06:32 - kind of the base on how to do it and
06:33 - then you'll be able to extend from there
06:35 - okay now that we understand the assets I
06:37 - apologize for such a long introduction
06:39 - let's get into writing the code I also
06:41 - need to plug the idea of a course
06:43 - programmingexpert.io if you guys want to
06:44 - get better at python check that out from
06:46 - the link in the description
06:50 - okay so let's start at the top of our
06:52 - program here by importing everything we
06:54 - need we're going to import OS we're
06:56 - going to import random we're going to
06:58 - import math we're going to import pygame
07:01 - we're going to say from OS import list
07:06 - directory
07:07 - and we're going to say from OS dot path
07:11 - import is file and join now the reason
07:14 - I'm doing all this OS stuff is because
07:17 - we are going to be dynamically loading
07:19 - all of the Sprite sheets and the images
07:21 - so we don't have to manually like type
07:23 - out the file names that we want I'll
07:25 - show you how we write a function that
07:26 - just loads these folders here kind of
07:29 - splits the Sprite sheets automatically
07:31 - and gives us all the images that we're
07:32 - interested in okay
07:34 - after we do that we're going to say
07:35 - pygame.net we need to initialize the pi
07:37 - gate module then we're going to go down
07:40 - here we're going to set a caption for
07:41 - our display I'm going to say Pi game dot
07:43 - display dot set underscore caption if
07:46 - you're unfamiliar with what this is
07:47 - doing this is setting the caption at the
07:49 - top of the window I'll try to explain
07:51 - most the pi game stuff as we go through
07:53 - the video I also have a ton of videos on
07:55 - Pi game on my channel if you want to
07:57 - check out something a little bit more
07:58 - basic okay now what I'm going to do is
08:00 - Define a few Global variables that we're
08:02 - going to be using here the first one is
08:04 - going to be the background color now
08:07 - we'll use this for now until we
08:08 - Implement our own background and for the
08:10 - background color I'm going to make this
08:12 - white which is going to be 255 255 255
08:15 - all of our colors in pi game are going
08:17 - to be in RGB okay so red green blue
08:20 - that's what we have for our background
08:21 - color we're then going to define the
08:23 - width and the height of our screen
08:25 - for some of you you're going to have to
08:27 - make this smaller if you're on a smaller
08:29 - display for me I'm on a 2K monitor so
08:31 - I'm going to go with a thousand by 800
08:33 - but if you're on again a smaller screen
08:35 - you might want to make this just a bit
08:37 - smaller so that it works for you
08:38 - although it doesn't really matter
08:40 - um make it whatever size you want next
08:42 - I'm going to say my FPS which is my
08:44 - frames per second is going to be equal
08:45 - to 60 and I'm going to Define my player
08:48 - velocity equal to 5 and this is going to
08:51 - be the speed at which my player moves
08:53 - around the screen
08:54 - okay now that we've done that we need to
08:56 - set up a pi game window
08:58 - so I'm going to say
09:00 - pygame.display.set underscore mode and
09:02 - then I'm going to pass the width and the
09:04 - height to this window argument here this
09:07 - mode argument and this is going to kind
09:09 - of create the pi game window for us
09:11 - I'm going to store that in the window
09:13 - variable and there we go we have kind of
09:15 - our Global variables created
09:17 - now I'm going to make a main function
09:20 - I'm going to say Define Main
09:22 - this main function is going to be what
09:24 - we run to kind of start the game
09:26 - so inside of here I'm going to take a
09:28 - window and at the bottom of my program
09:30 - I'm going to say if underscore
09:31 - underscore name underscore underscore is
09:33 - equal to underscore underscore Main
09:35 - underscore underscore then
09:38 - call the main function and pass the
09:40 - window argument
09:42 - okay so hopefully you can see kind of
09:43 - the structure of our program already the
09:45 - reason I have this line right here is so
09:47 - that we only call the main function if
09:49 - we run this file directly if we don't
09:52 - run this file directly say we imported
09:54 - something from it then we won't run the
09:56 - game code okay
09:57 - so that's why I have this inside of main
09:59 - is where we're going to write kind of
10:01 - our event Loop the event Loop will be
10:03 - what's handling say the Collision moving
10:05 - our character redrawing the window all
10:08 - of that kind of stuff this kind of good
10:09 - practice to have your event Loop in one
10:11 - place
10:12 - so inside of the main function we need
10:14 - to set up a few things the first thing
10:16 - we need is a clock so we're going to say
10:18 - clock is equal to Pi game dot time dot
10:21 - clock we also need to Define uh what is
10:24 - it a while loop that's going to
10:26 - continually Loop and act as our event
10:28 - Loop so I'm going to say run is equal to
10:30 - true
10:31 - I'm going to say while true or while run
10:33 - sorry and then the first thing I'm going
10:35 - to do is say clock.tick FPS now FPS
10:39 - members our variable right here what
10:41 - this line does is ensures that our while
10:43 - loop is going to run 60 frames per
10:46 - second okay so no more than 60 times per
10:48 - second that's what this ensures if
10:50 - you're on a really slow computer chances
10:52 - are you could be running less than 60
10:54 - frames per second but in my case I'm on
10:56 - quite a fast computer and if I didn't
10:57 - put this here then you'd see that my
10:59 - game would be like way faster than yours
11:01 - so we need to do this to regulate the
11:03 - frame rate across different devices okay
11:06 - now that we have that we're going to say
11:08 - four event in pygame dot event dot get
11:12 - and the first event that we're going to
11:15 - check for is if the user quits the game
11:16 - if they quit by quitting I mean they hit
11:18 - the red X in the top right hand corner
11:20 - then we need to stop the event Loop and
11:22 - exit our program so I'm going to say if
11:24 - event DOT type
11:26 - is equal to pygame dot quit then we're
11:31 - going to say run
11:33 - is equal to false and we can break out
11:36 - of this Loop
11:37 - then we can go down here and we can say
11:39 - hi game dot quit notice this is outside
11:41 - of the while loop
11:43 - and then we can put quit which will
11:45 - actually quit the Python program okay
11:47 - so now we have our basic event Loop and
11:50 - what should happen if I run the code now
11:52 - is a pi game window should pop up
11:53 - nothing should be on the screen and if I
11:55 - hit the red arrow it should close so
11:57 - let's try this and see what we get okay
11:59 - notice it says platformer and then I hit
12:01 - X and it closes perfect uh we're well on
12:04 - our way to creating the platformer game
12:08 - all right so now that we've done that I
12:11 - actually think that the first thing we
12:12 - can do is generate our background then
12:14 - once we have the background we can
12:15 - create a basic player that we can move
12:17 - around the screen and once we have that
12:19 - we'll start doing all of the animations
12:20 - and then later in the video once we've
12:22 - got uh kind of the bulk of the stuff
12:24 - done we'll handle the collision and all
12:26 - of the movements right
12:28 - okay so I need to make a function here
12:30 - and I'm going to call this get
12:31 - underscore background
12:33 - now before I dive into this let's have a
12:35 - look at our assets folder again now what
12:38 - I want to do is use these tiles right
12:40 - they're just tiles I believe their size
12:42 - is 64 by 64 or 32 by 32 something along
12:45 - those lines anyways we'll want to use
12:47 - these tiles and tile the whole
12:49 - background
12:50 - so what I need to do is essentially
12:52 - create a whole grid of these tiles based
12:56 - on the size of my screen so the way I'm
12:58 - going to do that is by using a folder
12:59 - here this folder is going to return to
13:02 - me sorry not this folder my bad this
13:04 - function this function is going to
13:05 - return to me a list that contains all of
13:08 - the background tiles that we need to
13:10 - draw so that's what we're going to do
13:11 - here with get background now what we
13:13 - want to take is the name
13:15 - sorry as I was saying the name is going
13:17 - to be the color of our background and
13:18 - that's going to allow us to change what
13:20 - background that we're using so the first
13:22 - thing we need to do here is load this
13:24 - background image now it's very important
13:26 - that when you run this file you run it
13:28 - from the directory that the file exists
13:31 - in now the reason I'm saying that right
13:33 - now is because the way I'm going to load
13:34 - this image relies on the fact that
13:37 - you're running this code from the
13:39 - directory that it exists in so see here
13:41 - that I'm in desktop python platformer
13:43 - and then notice tutorials inside of that
13:45 - directory that's why this is going to
13:47 - work if you try to run this code from a
13:49 - different directory say a CD to desktop
13:51 - and then I tried to run this then I'm
13:53 - going to get an issue so just make sure
13:54 - you're in the correct directory I just
13:56 - want to say that before we even get into
13:57 - this okay so I'm going to load my image
13:59 - I'm going to say image is equal to
14:01 - pygame dot image dot load
14:04 - and then what I'm going to do is join
14:07 - the assets path which is directly in the
14:10 - directory this file is in with the
14:12 - background uh path here if I spell
14:15 - background correctly and then with the
14:18 - name which is going to be the file name
14:19 - that I want to load which is really just
14:21 - the color of the background okay now
14:23 - that I have that I want to get the width
14:25 - and the height of this image so I'm not
14:26 - guessing what it is so I'm going to say
14:28 - underscore underscore with height is
14:31 - equal
14:32 - to image.get underscore rect now when
14:35 - you do this it will give you the X Y
14:38 - width height I don't care about the XY
14:40 - so I've just put two underscores here
14:42 - denoting that I don't care about these
14:43 - values and then I'm able to grab the
14:45 - width and the height so now that I have
14:47 - the width and the height
14:48 - I'm going to say tiles is equal to an
14:51 - empty list and then I'm going to Loop
14:53 - through
14:55 - um essentially how many tiles I need to
14:56 - create in the X and the Y Direction
14:59 - so I'm going to say 4i in range and then
15:03 - I'm going to take my width I'm going to
15:05 - integer divide this by the width of my
15:06 - tile and I'm going to add one and I'm
15:08 - going to do the same thing for my height
15:10 - here so I'm going to say 4J in range
15:12 - height over the height of my image Plus
15:15 - 1. okay so notice width here is the
15:18 - width of the screen height is the height
15:20 - of the screen I'm integer dividing this
15:22 - by the width of my tile and that tells
15:24 - me approximately how many tiles I need
15:26 - kind of in The X direction to fill the
15:28 - whole screen then just to make sure that
15:30 - I don't have any gaps I add one
15:33 - and I do the exact same thing for height
15:35 - in the y direction
15:37 - then what I'm going to do is say
15:39 - actually
15:40 - yeah I'm going to say rect uh is this
15:42 - wrecked no we're gonna say pause is
15:44 - equal to I multiply by the width and J
15:48 - multiplied by the height and this is
15:51 - going to denote the position of the top
15:53 - left hand corner of the current tile
15:55 - that I'm adding to this tiles list in pi
15:58 - game when you draw something on the
16:00 - screen you draw it from the top left
16:01 - hand corner so what I'll be doing is
16:03 - continually moving the positions based
16:06 - on how this for Loop is going right so
16:08 - for every eye for every J I'm
16:10 - multiplying it by the width and
16:11 - multiplying it by the height and that
16:13 - gives me the accurate positions I need
16:14 - to place every single tile in on the
16:16 - screen
16:17 - hopefully that makes a bit of sense but
16:19 - that's how this is working uh and then
16:21 - I'm going to say towels.append my
16:23 - position and then I'm going to return my
16:26 - tiles I'm also going to return the image
16:28 - so that I can know what image I need to
16:31 - use when I'm drawing all of these tiles
16:33 - okay now that I have my background I'm
16:35 - going to go into Main and I'm going to
16:37 - say my background is equal to get
16:40 - background and for the name I'm going to
16:42 - reference here in the background folder
16:44 - any of these images so we can use anyone
16:47 - we want it doesn't really matter I kind
16:48 - of like the blue one so I'll go with
16:50 - blue feel free to change this though on
16:52 - your end and
16:55 - there we go if I can type this correctly
16:57 - okay so I'm going to say background
16:58 - comma
17:00 - BG image like that
17:03 - and now I want to set up something
17:04 - that's going to draw my background so
17:06 - I'm going to make a function here and
17:08 - I'm going to say draw this is going to
17:10 - take in a window and for now it's going
17:12 - to take in a background and later it'll
17:13 - take in everything else we want to draw
17:15 - inside of here I'm going to say Pi game
17:18 - dot display
17:19 - dot update
17:21 - and before I do that I'm going to draw
17:23 - my background so I'm going to say
17:25 - 4 and this is going to be tile in
17:28 - background like that and then I'm going
17:31 - to say window
17:33 - dot blit
17:34 - and actually I need to take my BG image
17:36 - as well
17:38 - so let's take that
17:40 - and I'm going to draw the background
17:41 - image
17:43 - and then what I need to pass here is the
17:45 - position I want to draw it at which is
17:47 - going to be tile so what I can actually
17:50 - do is just convert this to a tuple
17:52 - notice the tile is going to be a list
17:54 - right tile is going to contain kind of
17:56 - my X Y position you can see that here
17:59 - right we're appending pause which is a
18:01 - list of x y and now that I think of it
18:03 - to make it easier let's just make this a
18:04 - tuple directly and now we don't need to
18:06 - convert it
18:08 - okay so in case anyone's confused what
18:10 - we're doing here is looping through
18:11 - every single tile that we have and then
18:13 - we're going to draw our background image
18:15 - at that position which will fill the
18:18 - entire screen with background images
18:19 - then what we're going to do is update
18:21 - the display the reason we update it so
18:23 - that every single frame we kind of clear
18:25 - the screen right and we don't have old
18:27 - drawings still on the screen you'll see
18:29 - what I mean in a second but this draw
18:31 - function is what we're going to do all
18:32 - of our drawing for now the only thing we
18:34 - need to draw is the background later it
18:36 - will be the player the blocks the
18:37 - obstacles Etc
18:39 - okay so now I'm gonna go inside of my
18:41 - wallet I'm going to call this draw
18:42 - function that we just created I'm going
18:45 - to pass window and then of course I'm
18:46 - going to pass my background and my BG
18:49 - image okay now this reminds me that I no
18:52 - longer need this background color we're
18:53 - not going to use that so I can get rid
18:54 - of that there
18:56 - okay so at this point assuming I've
18:58 - loaded the image correctly we're now
18:59 - going to see this tiling the entire
19:01 - screen so let's save and run and notice
19:04 - that we get it right it's tiling the
19:06 - entire screen looks pretty good to me
19:07 - and we can quite easily change this if
19:09 - we want by just going here and saying
19:11 - okay rather than blue I want yellow and
19:14 - then we say yellow and now we get a
19:16 - yellow background great so that's kind
19:18 - of the advantage of how I've done this
19:19 - here you can change the background to
19:21 - any color you want well given that it's
19:23 - in the background directory
19:27 - now that we have our background what
19:29 - should we do next well we probably want
19:31 - to put a player on the screen and start
19:33 - seeing some images for that player now
19:36 - the player itself is the most
19:37 - complicated aspect of this program
19:39 - there's a lot of movement going on with
19:40 - it so we'll start by just creating like
19:42 - a block for our player kind of move the
19:44 - block around have it jumping around then
19:46 - once we do that we'll do all of the
19:48 - Sprites and animations just so that we
19:50 - can get some more progress before we
19:52 - dive into that because it is a bit of
19:53 - work okay so let's go here and let's say
19:56 - class player
19:58 - we're going to use a class for our
19:59 - player kind of makes sense here and this
20:01 - class is going to inherit from pie game
20:04 - dot Sprite dot Sprite now I don't
20:07 - typically use Sprites when I'm working
20:09 - in pi game but I'm going to use them in
20:11 - this tutorial and the reason for that is
20:13 - that it makes it very easy to do Pixel
20:15 - Perfect Collision when we have two
20:18 - Sprite objects which we're going to have
20:19 - because we're inheriting from the pi
20:21 - game Sprite class we can use a method
20:23 - that tells us if these Sprites are
20:26 - colliding with each other so just
20:27 - understand that's why I'm doing this
20:29 - inheritance you don't have to understand
20:30 - exactly what the Sprite is but it kind
20:32 - of denotes that we have some properties
20:34 - on our class and then it allows these
20:36 - special Pi game methods to use those
20:38 - properties to handle the Collision for
20:40 - us so we don't have to write anything
20:41 - too complicated when it comes to the
20:43 - Collision although we still do need to
20:45 - handle it a bit okay so what we're going
20:47 - to do here is Define our initialization
20:49 - and we're going to take in a self an X Y
20:52 - width and height
20:54 - now the width and height will really be
20:56 - determined by the image that we're using
20:58 - for our player but for now since we're
21:01 - going to have like a block for our
21:02 - player until we add that image we're
21:04 - going to have a width and height now
21:05 - that reminds me that I just need to set
21:07 - a color for my player so I'm going to
21:09 - say color is 255.00 I'm making this a
21:12 - class variable just so it's the same for
21:15 - all of my players and I have access to
21:17 - it just right on the class
21:18 - okay now what I'm going to do is say
21:20 - self direct is equal to pygame.rect I'm
21:25 - going to pass my X Y width and height
21:28 - so rather than representing all of these
21:30 - values individually uh we're just going
21:32 - to put them on the rectangle and this is
21:35 - going to make it a little bit easier for
21:36 - us to kind of move the play around and
21:39 - do collision and all of that so erect
21:41 - really is just a tuple that's storing
21:43 - four individual values when I make it Pi
21:45 - game.rect it means we can use it in some
21:47 - kind of special equations and whatnot
21:50 - okay now for our player we're gonna have
21:52 - to have a few values uh the first thing
21:56 - we're going to have I'm getting a bit
21:57 - ahead of myself here but is going to be
21:59 - the x velocity and the next is going to
22:01 - be the Y velocity now the X and Y
22:04 - velocity is going to denote
22:07 - um what do you call it here
22:09 - how fast we are moving our player every
22:11 - single frame in both directions right so
22:15 - the way that we'll actually move our
22:16 - player
22:17 - is we'll just apply a velocity in a
22:19 - direction and then it'll just keep
22:21 - moving in that direction until we remove
22:23 - that velocity now this will be great for
22:25 - example for something like gravity or
22:27 - jumping
22:28 - um and you'll you'll see what I mean in
22:30 - a minute
22:30 - okay now that we have that we need to
22:34 - add something known as a mask for now
22:37 - I'm going to say the mask is equal to
22:39 - none and then I think that's all we need
22:43 - for right now so now that we have that
22:45 - let's add our first function here which
22:47 - is going to be the move function so move
22:49 - is going to take in a displacement in
22:51 - the X Direction and a displacement in
22:53 - the y direction and it's going to say
22:55 - the self.rec dot X plus equals the
22:58 - Direction X or displacement X sorry and
23:01 - self.rect.y
23:03 - plus equals the displacement y now if we
23:05 - want to move upward down or left or
23:07 - right we just change the sign of this DX
23:11 - or d y right
23:12 - okay so now we have a move next what we
23:16 - want to do is create two functions one
23:17 - for moving to the left
23:20 - and this is going to take in the
23:22 - velocity we want to move in the left
23:24 - Direction and the next is going to be
23:26 - moving in the right direction again this
23:29 - is going to take in self and Vel now to
23:32 - move left what we're going to do is say
23:34 - ourself.x velocity is equal to and then
23:38 - this is going to be negative velocity
23:39 - and then to move to the right we're
23:41 - going to say self.xfel is equal to Vel
23:44 - now the reason we use negative velocity
23:47 - here is because if we want to go left we
23:49 - have to subtract from our X position in
23:51 - pi game remember our coordinate system
23:53 - is that 0 0 is the top left hand corner
23:56 - of the screen so if I want to move down
23:58 - I add to my y-coordinate and if I want
24:01 - to move to the right I add to my x
24:03 - coordinate so if I want to go up I
24:05 - subtract y if I want to go left I
24:07 - subtract X so that's why I'm putting a
24:09 - negative Val here I know it seems a bit
24:11 - weird how I've just done move and now
24:12 - I'm saying move left we're going to have
24:14 - negative don't worry you'll see how this
24:15 - works in a second next I'm going to say
24:18 - if self dot Direct action does not equal
24:22 - left then self Dot
24:26 - Direction
24:27 - is equal to left and I'm going to say
24:30 - self.animation count is equal to zero
24:32 - now we're not going to use these right
24:34 - now but I just want to add them in
24:36 - um for now at least and you'll see why
24:38 - in a second now I'm also going to say
24:40 - appear yourself dot direction is equal
24:42 - to left and the reason I'm adding this
24:44 - direction is because I need to keep
24:46 - track of what direction my player is
24:48 - facing so later once I have my Sprites I
24:50 - know if I'm showing the animation to the
24:53 - left or I'm showing the animation to the
24:54 - right now the animation count uh we're
24:58 - resetting that when we change directions
24:59 - and the reason we're doing that is so
25:02 - that the animation doesn't look all
25:03 - wonky when we go from going left to
25:05 - right so we need to kind of reset the
25:07 - count that we're using to change the
25:09 - animation frames again you're going to
25:11 - see that later as we go through the
25:12 - tutorial now I've just added up here um
25:15 - self.animation count equals zero just to
25:17 - make sure we don't get any weird errors
25:18 - later so now I have my direction and my
25:20 - animation cap perfect
25:22 - okay now I'm going to copy this I'm
25:24 - going to put the same thing in move
25:25 - right and I'm going to change the
25:27 - direction here to say right
25:30 - and then right so now we know what
25:32 - direction we're facing at all points in
25:33 - time
25:34 - okay
25:35 - perfect next what we need to do is we
25:39 - need to have some kind of draw function
25:41 - and we also need to have what I'm going
25:42 - to call the loop function and in fact
25:44 - let's do the loop function first so I'm
25:46 - going to say Define Loop
25:48 - and inside of here I'm going to take in
25:52 - self and FPS now what Loop is going to
25:55 - do is be called once every frame when I
25:59 - say frame that's really one iteration of
26:00 - the while loop and this is going to move
26:03 - our character in the correct direction
26:04 - and handle things like updating the
26:07 - animation and all of the stuff that we
26:09 - constantly need to do for our character
26:11 - so for right now I only care about
26:14 - moving in the X Direction we'll handle
26:15 - the jumping later so what I'm going to
26:18 - do is just say self.move
26:20 - and I'm going to say
26:21 - that we're going to move based on our x
26:23 - velocity
26:25 - and our y velocity
26:28 - now notice we're updating our x velocity
26:30 - here when we move left or we move to the
26:32 - right so now if we call Loop and we have
26:34 - some velocity in the X Direction it's
26:35 - going to move our character to the left
26:37 - or to the right
26:38 - okay again all this will start to make
26:40 - sense as we get through the tutorial
26:42 - there is a lot of stuff I need to do
26:43 - kind of up front before I can just show
26:45 - you instantly so hopefully you guys are
26:47 - following along but I just want to note
26:49 - we eventually of course will see how all
26:51 - this works I'll walk through the code so
26:52 - no worries if it's a bit confusing right
26:54 - now now what else do we need to do
26:56 - inside of the loop well we need to
26:57 - update something known as The Mask which
26:59 - I'm going to get to in a second but
27:01 - before we can do that we need to Define
27:02 - uh what's known as our image so I'm
27:04 - going to say Define and this is going to
27:07 - be draw and this is going to be the
27:08 - function that handles drawing on the
27:10 - screen and for draw we are going to take
27:13 - in our window which I'll just represent
27:15 - with win now what we'll do for now is
27:18 - we'll just say Pi game
27:20 - dot draw dot rectangle we'll draw the
27:23 - rectangle on the window which is the
27:25 - first argument here it's where we're
27:26 - drawing it the second argument is the
27:28 - color which is going to be self.color
27:30 - then the last is the rectangle so I'm
27:33 - going to say that is self dot rect now
27:36 - notice the react here right has our XY
27:39 - width height and when we move we're
27:40 - updating the X and Y of the rectangle
27:42 - which will then change where we're
27:44 - drawing it if I can find it here on the
27:46 - screen
27:47 - okay so that's what we need for drum now
27:51 - actually for now I think that's okay
27:54 - uh we will add to this obviously in a
27:58 - second but I think we can generate a
27:59 - player draw the player see it moving and
28:02 - then go from there
28:03 - so let's do that so let's go to main
28:05 - here
28:06 - I'm going to create a player
28:08 - I'm going to say player is equal to
28:09 - player I need to pass an x a y and a
28:11 - width and a height so I'm going to pass
28:13 - let's say a hundred
28:16 - and let's make him 50 by 50.
28:18 - and then what we can do now
28:20 - is pass our player to the draw function
28:25 - we can then take player inside of here
28:28 - and we can say player don't draw and we
28:31 - can pass the window
28:33 - okay so I will move the player in one
28:34 - second but for now let's just see if
28:36 - this is working if it's going to show up
28:37 - on the screen so let's run the code
28:40 - and notice that now we have a red
28:41 - rectangle in the top left hand corner
28:43 - obviously nothing's happening right now
28:45 - because we're not moving it around the
28:46 - screen but you could see it's showing
28:51 - so we have our player we're drawing the
28:52 - player on the screen now we want to
28:54 - start using some of these methods Right
28:56 - Moving left moving right Etc so I want
28:59 - to separate my movement into a function
29:01 - so I'm going to say Define handle move
29:03 - like this and for this right now we'll
29:06 - just take in the player
29:08 - now inside of handle move what we're
29:10 - going to do is essentially check the
29:11 - keys that are being pressed on the
29:13 - keyboard if you're pressing left or
29:14 - you're pressing right then we'll move
29:16 - the character to the left or to the
29:17 - right eventually we will check for
29:19 - collision and we will do all of it so
29:21 - I'm going to say key is equal to pygame
29:23 - dot keys
29:26 - actually not keys.key DOT get underscore
29:28 - pressed this tells you all of the keys
29:30 - on the keyboard that are currently being
29:32 - pressed and I'm going to say if
29:34 - and actually this is going to be key
29:36 - really we should call this Keys though
29:39 - because this makes a bit more sense so
29:40 - we're going to say if keys and then this
29:43 - is pygame dot k underscore left this is
29:46 - the left Arrow key if you wanted to use
29:48 - the a key then you would use a like that
29:51 - uh yeah actually I'll go with left Arrow
29:53 - key because that's what I usually do but
29:55 - you can use a or swap it however you
29:57 - want and then I'm going to say if this
29:59 - is the case then player dot move
30:02 - underscore left and how much do I want
30:05 - to move the player bikes we have to pass
30:06 - the velocity well this is going to be my
30:08 - player velocity right
30:10 - okay next I'm going to say if keys and
30:13 - this is pygame dot k underscore right
30:16 - then I'm going to say player dot move
30:19 - underscore right
30:20 - again same thing I'm going to move this
30:22 - by my player velocity now it's important
30:25 - that before I do this I set my player
30:28 - velocity to be zero now the reason this
30:31 - is the case is because if I don't do
30:33 - this what will happen is as soon as I
30:35 - move left this is going to set my player
30:37 - velocity right which you can see here my
30:39 - X Val it's going to set the x velocity
30:42 - now once I set that I'm going to
30:44 - continue moving in that direction until
30:46 - it gets set back to zero so if you
30:49 - wanted to make it so when you press a
30:50 - key you just continually move in that
30:52 - direction until you press a different
30:53 - key then you could omit this but in our
30:56 - case we only want to move while you're
30:58 - holding down the key so I'm going to say
31:00 - player.xval equals zero there's a lot of
31:02 - other ways to go about doing this but I
31:04 - just wanted to stay consistent with our
31:05 - movement because of how we're going to
31:06 - do the gravity so for now just bear with
31:09 - me we essentially set the velocity to
31:11 - zero and then if we are moving left or
31:13 - right so if we're pressing these Keys
31:14 - then we change the velocity to be you
31:16 - know the negative player velocity or the
31:18 - positive player velocity based on the
31:20 - direction we're moving in
31:22 - okay that's actually all we need for
31:24 - handling the movement so let's put the
31:26 - handle movement function uh where are we
31:29 - going to put this we're going to put
31:30 - this before we draw
31:32 - so I'm going to say handle move I want
31:34 - to pass my player all right now I need
31:36 - to make sure before I do this that I
31:38 - call my Loop function okay and I pass my
31:42 - FPS and the reason I need to call Loop
31:45 - is because Loop is what actually moves
31:47 - my player right
31:48 - if you look at loop it's moving my
31:50 - player in the x velocity and Y velocity
31:53 - direction every single frame so if I set
31:56 - the x velocity well then I continue
31:57 - moving again if I set the Y velocity I
31:59 - move in that direction but that only
32:00 - works if we're continually calling this
32:02 - Loop function
32:04 - okay
32:05 - good so we've made great progress so far
32:07 - let's see now if we can move our player
32:09 - or if I've made any mistakes which are
32:11 - very likely so let's run the code
32:13 - and let's see okay so I'm going to hit
32:15 - my right arrow key you can see I can
32:16 - move to the right and I can move to the
32:18 - left obviously if I wanted to go up and
32:20 - down I could Implement that but we want
32:22 - to have it jumping
32:23 - which I will show you uh in a second but
32:26 - we kind of need Collision before we can
32:27 - do jumping
32:31 - very good all is looking great so far
32:34 - now let's Implement gravity so we kind
32:37 - of fall down then we can do uh kind of
32:40 - the Sprite sheets then we can do the
32:42 - Collision because the Collision makes
32:43 - more sense I guess once we have the uh
32:45 - the Sprite sheets done so let's
32:46 - Implement gravity now gravity is a
32:48 - little bit complicated because we want
32:50 - to have
32:52 - um like kind of a realistic gravity
32:54 - right that actually implements some
32:55 - basic physics what I mean by that is
32:57 - rather than just having a constant
32:58 - velocity we want to actually have an
33:01 - acceleration for our gravity so as many
33:03 - of you know if you're in physics gravity
33:06 - um the acceleration is negative 9.8
33:08 - meters per second squared I believe
33:09 - that's what the acceleration is anyway
33:11 - in our game we want to emulate something
33:13 - similar to that where it feels like the
33:15 - longer you're falling the faster you
33:17 - fall you're not falling at a constant
33:18 - speed that makes the game just feel like
33:20 - really really unrealistic so the first
33:22 - thing we need to do is pick some value
33:24 - that we want our gravity to be and this
33:27 - is the acceleration of gravity so keep
33:29 - that in mind
33:30 - so for this I'm going to make a variable
33:31 - in my player class because it's the only
33:33 - place we need it right now I'm going to
33:35 - say this equal to 1. so gravity is equal
33:37 - to one if you want gravity to be faster
33:39 - obviously you increment this value right
33:41 - make it large
33:43 - okay now inside of loop this is where we
33:46 - need to handle our gravity
33:48 - so every single frame in our loop we're
33:51 - going to increase the Y velocity by our
33:55 - gravity however how we know how much to
33:59 - increase the velocity by varies on how
34:03 - long we've been falling for
34:05 - again I know this seems really weird but
34:07 - we essentially need to keep track of how
34:09 - long we've been falling so that we know
34:11 - how quickly we should be increasing our
34:13 - velocity or how quick we should be
34:15 - accelerating downwards so that means
34:18 - that I need to create a variable here
34:19 - called self dot count and given we
34:23 - should really call this something better
34:24 - I'll call it fall count and this will um
34:27 - essentially tell us okay how long have
34:28 - we been in the air for how long have we
34:30 - been falling and we'll use this value to
34:32 - determine how much we um increment our
34:35 - velocity by so I'm now I'm going to say
34:37 - myself.w underscore velocity
34:40 - and I'm going to add to this the minimum
34:43 - of 1 or and I'm going to take my
34:46 - self.count and this is my fall count
34:49 - divided by the frames per second
34:52 - multiplied by the self.gravity now this
34:55 - isn't truly what the acceleration would
34:57 - be but this will give us like a kind of
35:00 - somewhat realistic looking gravity in
35:03 - the game so just bear with me here so
35:05 - what we're doing we're taking our fall
35:06 - count we're dividing it by FPS the point
35:08 - of this is that if I want this value to
35:10 - be in seconds then I need to take
35:12 - whatever my count is which I'm going to
35:13 - increment every single Loop in fact
35:15 - we'll do this right now
35:17 - plus equals 1 and I divide it by FPS so
35:20 - if my FPS is 60 as soon as this is 60
35:22 - then I've been falling for one second I
35:24 - take that amount of time I multiply it
35:26 - by my gravity and then that tells me how
35:29 - much I'm going to increment my y
35:30 - velocity by however this is going to
35:32 - start out being really really small just
35:34 - like fractional decimal decimal amounts
35:36 - so just to make this a bit easier for us
35:38 - when we do our Collision I'm going to
35:40 - increment this by the minimum of 1 or
35:42 - this value so every frame we're moving
35:44 - at least one pixel down and it doesn't
35:47 - take us like a full second before we
35:48 - really start feeling any effect of
35:50 - gravity
35:51 - hopefully uh that makes a bit of sense
35:53 - you guys are understanding me here but
35:54 - just bear with me I've uh experimented
35:56 - with these numbers quite a bit so I
35:57 - think this should be fine
35:59 - okay so now that we have this what
36:01 - should happen when I just click run here
36:03 - is I should just start falling
36:05 - immediately on the screen and obviously
36:06 - until we have some platforms or
36:08 - Collision we can't really stop falling
36:09 - if we have gravity uh but let's have a
36:12 - look and let's see how it works right
36:13 - now
36:15 - okay so you can see that I've fall and
36:17 - notice I'll do this again that I start
36:19 - falling slowly and then it picks up the
36:21 - pace right so this is somewhat realistic
36:23 - to how gravity would actually work and
36:25 - that's what I was trying to implement
36:26 - when I did this
36:30 - now that we have done that it's time to
36:33 - move on and have some kind of Sprites or
36:35 - images I was going to do this later but
36:37 - I realized that we can't really do the
36:38 - Collision which is going to be Pixel
36:40 - Perfect Collision until we have some
36:42 - kind of images that's that's really what
36:43 - we need we need our Sprites so what we
36:45 - need to do here first is examine what
36:48 - our Sprites look like for our characters
36:49 - now remember all these characters pretty
36:51 - much the exact same they just look
36:53 - different but in terms of their
36:54 - movements their animations number of
36:56 - images they're identical so whatever I
36:57 - show you for one of these is the same
36:59 - for all of them hence why we can just
37:00 - kind of swap them out so when I go to
37:02 - mask dude here let's zoom in you can see
37:04 - that we have for example double jumper I
37:06 - just picked a random Sprite sheet now
37:08 - this sheet has six different animations
37:10 - or six different frames which represent
37:12 - what this guy's going to look like while
37:14 - he's kind of jumping or double jumping
37:16 - in the air so what we need to do is we
37:18 - need to split this one image into the
37:22 - six individual images and then Loop
37:24 - through those images at some frequency
37:26 - or some time so that we can show them on
37:28 - the screen and show in an animation
37:30 - right we need to kind of manually do
37:32 - this now some of these are single frames
37:34 - like falling is just single frame that's
37:35 - easy
37:36 - hit okay this is um like you know the
37:39 - guy disappears for a second kind of
37:41 - expands goes back
37:43 - you get the point where you want to Loop
37:45 - through these animations idle single
37:47 - frame actually no idle is not a single
37:48 - frame it's a bunch of frames this guy's
37:50 - arms are kind of wagging up and down we
37:52 - have jump a single frame run a bunch of
37:54 - frames and then wall jump now
37:57 - notice here with these images that
38:00 - they're in different directions or let's
38:03 - say they're all kind of facing right so
38:06 - another thing we're going to have to do
38:07 - is rotate this image to face left when
38:11 - our character is facing left so that's
38:13 - another thing we have to handle that not
38:14 - only do we just have to split these
38:15 - images up we also have to get a rotated
38:18 - version of them so that we can show you
38:20 - moving in a different direction same
38:22 - with jumping same with being idle like
38:24 - whatever Direction you're going we need
38:25 - to show the image flipped in that
38:27 - direction
38:28 - uh so not rotate sorry flip that's what
38:30 - we're gonna do okay
38:32 - so let's do this first thing I will do
38:35 - actually is I'll write the function that
38:37 - will flip our image
38:39 - so I'm going to say flip Sprites this is
38:42 - going to take in a list of Sprites
38:44 - and I'm going to return
38:46 - High game
38:47 - dot transform dot flip and this is going
38:50 - to be Sprite true false notice as it
38:54 - says here this is indicating what
38:56 - directions you want to flip in when I
38:58 - pass true this means flip in the X
39:00 - Direction when I pass false this means
39:01 - don't flip in the y direction if you
39:03 - want to flip both you'd pass true twice
39:06 - but we don't want to do that so I have
39:08 - Pi game.transform.flip Sprite and then
39:10 - this is going to be four
39:12 - Sprite in Sprites really I could call
39:15 - this image but you get the point okay so
39:18 - we have flip now we're going to write a
39:20 - function which is load Sprite
39:23 - sheets and
39:26 - should we call it sheet or sheets I
39:27 - think sheets is fine and what this is
39:29 - going to do is load all of the different
39:31 - Sprite sheets for our character so it's
39:33 - going to give us the spreadsheet for
39:34 - double jumping for hitting for falling
39:36 - and then within our character we can
39:38 - pick what sheet we want to be using and
39:40 - what animations we want to Loop through
39:43 - so I'm going to take in directory 1 and
39:44 - directory 2 and the reason I'm doing
39:46 - this is so that I can load other images
39:49 - that aren't just my characters and this
39:51 - will be very dynamic I also want to take
39:53 - in the desired width and height of my
39:55 - image
39:56 - and if we need to load multiple
39:59 - directions so I'm going to say Direction
40:01 - equals false as a default parameter so
40:03 - that we only load like the left and the
40:06 - right side images like we flipped the
40:07 - images if you pass this equal to true
40:10 - okay now the first thing we need to do
40:12 - is determine the path to the images
40:14 - we're going to be loading so I'm going
40:15 - to say join assets der one dir 2. notice
40:20 - I can use join because I imported this
40:22 - from os.path okay
40:24 - now I'm gonna get all of the images in
40:27 - this directory now the way I do that is
40:29 - a phone I'm going to say images is equal
40:30 - to and this is going to be f for f in
40:34 - list directory again notice I can use
40:36 - that because I import it here we're
40:38 - going to list all of these things that
40:40 - are inside of this path directory and
40:43 - then we're going to say if
40:45 - is file and then this is going to be
40:47 - join path
40:49 - and F
40:51 - so what this for Loop is going to do
40:53 - here this uh I forget what you actually
40:55 - call this when you write a for Loop in a
40:56 - list anyways what this line is going to
40:58 - do here is load every single file only
41:01 - file that is inside of this directory so
41:05 - again we're just going to get every
41:06 - single one of these file names and then
41:08 - once we have those file names we can
41:09 - load that image and we can then split
41:11 - that image up into the individual images
41:13 - that we want
41:15 - okay so we have images now I'm going to
41:17 - say
41:18 - all Sprites is equal to a dictionary and
41:20 - what I'm going to do with this
41:21 - dictionary is have key value pairs where
41:23 - the key is the let's say animation style
41:26 - and the values all of the images in that
41:29 - animation
41:30 - okay so I have all Sprites and I'm going
41:32 - to say for image in images
41:35 - and I'm going to say that my Sprite
41:37 - sheet so the individual Sprite sheet I
41:39 - want to load here is going to be equal
41:40 - to pygame dot image dot load and then
41:45 - this is going to be join
41:47 - path and image and then dot convert
41:51 - Alpha which is essentially going to
41:52 - allow me to load a transparent
41:54 - background image okay so we are loading
41:57 - the image which is just one of the files
42:00 - that we found right from this path and
42:03 - we just need to append the path to it
42:05 - right
42:05 - so whatever the path to the directory is
42:07 - plus the image name
42:09 - okay we're going to load that in we're
42:10 - going to get the transparent background
42:11 - now that we have this we need to get all
42:13 - of the Sprites in this image
42:16 - so I'm going to say Sprites is equal to
42:18 - and now this is going to be a list okay
42:21 - so again the processes load all of the
42:23 - different files
42:25 - okay we have all the files these are
42:26 - sprite sheets now we need to get all the
42:27 - individual images from the Sprite sheet
42:29 - and load those okay so I'm going to say
42:32 - 4i in range and then this is going to be
42:35 - Sprite sheet dot get underscore with
42:39 - integer divided by the width of the
42:42 - image that we're loading now width is
42:45 - going to be the width of an individual
42:47 - image inside of our animation or inside
42:49 - of our Sprite sheet so if I know this is
42:51 - say 32 pixels I pass 32 and then it
42:55 - gives me a bunch of images that are 32
42:57 - pixels wide that's how I'm doing the
42:59 - loading so that's why I took width and
43:00 - height here okay
43:02 - now that we have that
43:03 - we're going to say surface
43:05 - is equal to
43:07 - High game
43:09 - dot surface and then this is going to be
43:12 - with
43:14 - height
43:15 - we're going to pass Pi game dot s r c
43:19 - Alpha which allows us to load again
43:21 - transparent images and then I'm going to
43:23 - pass 32 here which is the depth don't
43:26 - worry about that but this is what we
43:28 - need to load these images and now we
43:30 - need to create a rectangle which is
43:32 - going to tell us where in this image
43:35 - again image being the Sprite sheet that
43:36 - we want to take an individual image from
43:39 - and BLT it onto this surface I know this
43:42 - seems really weird what we're doing is
43:43 - we're going to create a surface that's
43:45 - the size of our desired individual
43:47 - animation frame we're then going to grab
43:49 - that animation frame from our main main
43:51 - image we're going to draw it onto the
43:53 - surface and then we're going to kind of
43:55 - export that surface that's the way that
43:57 - we have to do this so I'm going to say
43:59 - rectangle is equal to Pi game
44:02 - Dot rect and for the rect this is the
44:06 - location on our original image that we
44:08 - want to grab this new frame from so I'm
44:10 - going to say this is I multiplied by my
44:12 - width and then 0 and then the width and
44:16 - the height of my image
44:17 - okay now that I have that I'm going to
44:19 - say surface.blit blit really means draw
44:22 - and I'm going to draw my Sprite sheet
44:25 - but I'm going to draw this at 0 0 and
44:28 - I'm only going to draw the portion of it
44:30 - which is my rectangle so notice this is
44:32 - my source this is the destination and
44:35 - this is the area of my source that I'm
44:37 - drawing so in position 0 0 which is the
44:40 - top left hand corner of my new Surface I
44:43 - am drawing my Sprite sheet but I'm only
44:45 - drawing the frame from my Sprite sheet
44:47 - that I want
44:48 - okay then I'm going to say Sprite start
44:50 - append and I'm going to append my
44:53 - Surface but I'm going to make my Surface
44:55 - Two Times larger because that's what I
44:57 - want to do I want this to be bigger than
44:58 - the default size so I'm going to say Pi
45:00 - game Dot
45:02 - transform dot scale to X and then I'm
45:06 - going to scale to X my Surface
45:08 - okay
45:10 - again I know this seems a bit
45:11 - complicated but now we have essentially
45:14 - stripped out all the individual frames
45:16 - we've just scaled them up to be double
45:18 - their size so if they're 32 by 32 we've
45:20 - made them 64 by 64 that's what scale 2x
45:23 - does and now we need to handle the
45:25 - directions
45:26 - okay so now we need to say
45:30 - if Direction then all underscore Sprites
45:35 - and this is going to be image
45:37 - dot replace it's going to be dot PNG
45:40 - this is going to be an empty string plus
45:43 - underscore right is equal to our Sprites
45:47 - and then we're going to copy the same
45:49 - thing
45:50 - let's copy this and put it here and now
45:52 - this is going to be underscore left is
45:55 - equal to
45:56 - and this is going to be flip
45:59 - Sprites
46:01 - so what we're saying here is if you want
46:03 - a multi-directional animation then we
46:06 - need to add two keys to our dictionary
46:07 - here for every single one of our
46:09 - animations so for falling for hit for
46:11 - idle we need a left and a right side so
46:14 - the right side is the one that we
46:15 - already have so we're going to say okay
46:16 - all Sprite at and then we're just going
46:19 - to strip off the dot PNG from whatever
46:21 - the name of our base image was so that's
46:23 - going to give us run jump idle hit
46:25 - whatever the name of our files and then
46:26 - we're going to append underscore write
46:28 - or underscore left now for underscore
46:30 - right that's our basic Sprites for
46:32 - underscore left we need to flip all of
46:34 - those Sprites and we already wrote the
46:35 - function that did that now otherwise
46:38 - then what we'll do is say all underscore
46:42 - Sprites at image dot replace
46:45 - dot PNG
46:47 - with an empty string this just removes
46:49 - the dot PNG
46:50 - and then it's going to be equal
46:52 - two Sprites
46:53 - okay then we can return
46:57 - all of our Sprites
46:59 - all right probably one of the most
47:01 - complicated aspects of the code that we
47:03 - need to write so don't worry we are done
47:05 - now with loading images at least we'll
47:07 - have to load our block but that's going
47:09 - to be a lot easier than loading our
47:10 - Sprite sheets so this now will load a
47:13 - Sprite shoot for us now that we've
47:15 - loaded our Sprite sheet we actually want
47:16 - to start using this so inside of player
47:19 - we are going to grab our images so I'm
47:22 - going to say my Sprites is equal to and
47:26 - it's going to be load Sprite sheets and
47:28 - now I need to pass what I want to load
47:29 - so now I need to pass the main character
47:33 - directory and actually this is the main
47:35 - characters
47:37 - okay so have a look here so inside of
47:40 - assets right uh yes so we're joining
47:42 - assets with dur1 and dirt 2. so the
47:44 - first directory I pass is main
47:46 - characters and then I pass the second
47:47 - directory which is the name of the
47:49 - character I want to load so mask dude
47:51 - ninja frog pink men or virtual guy you
47:54 - can pick whatever one you want I'm gonna
47:56 - go with mask dude for now now for width
47:59 - and height uh the width and the height
48:00 - of this is going to be 32. so make sure
48:02 - you do this 3232 and then you pass true
48:05 - because we want a multi-directional
48:07 - Sprite so both the left and right side
48:09 - animations that's what we want okay
48:12 - now that we have that we are going to
48:14 - change our draw here so that we're
48:16 - drawing our Sprite now for for now we're
48:19 - just going to draw like one simple
48:21 - Sprite just so you see how it looks on
48:22 - the screen then I'll go through
48:24 - animating the Sprite and showing you how
48:25 - that works
48:26 - okay so rather than pygame.draw.rect I'm
48:29 - going to say self.sprite is equal to and
48:33 - then this is going to be self dot
48:35 - Sprites at idle now idle is one of the
48:40 - name of our animations right so if we go
48:41 - here you can see we have idle jump Etc
48:43 - so I'm accessing the key from my
48:45 - dictionary and then I'm going to access
48:47 - the first frame of this key which is
48:49 - zero because every single key is a whole
48:51 - like Sprite sheet right so now that I
48:53 - have my Sprite
48:54 - I'm going to say window blit and then
48:56 - this is going to be self.sprite and I'm
48:58 - going to blip this at self.rec dot X and
49:02 - self.rec.y which is the position on the
49:04 - screen and then if we want we can just
49:06 - turn off the gravity for right now so we
49:08 - can kind of see it on the screen it
49:10 - doesn't just disappear okay let's try
49:12 - this out let's just make sure it
49:13 - actually loaded correctly so let me run
49:15 - this and we got an error okay so let me
49:17 - see what error we got here
49:20 - um
49:20 - run this again
49:23 - it said key key error idle okay so the
49:26 - issue here is that since we load a
49:28 - directional Sprite we need to reference
49:30 - either idle right or idle left so we can
49:33 - actually do this by saying idle
49:34 - underscore Plus
49:36 - self
49:37 - dot Direction and then so long as we set
49:39 - the direction which we did here to left
49:41 - uh this should work so now it'll change
49:43 - based on if we're going left or right so
49:45 - actually you'll see that it should swap
49:46 - as we change directions okay let's try
49:48 - this now
49:50 - all right so now we have this guy facing
49:52 - left if I go right
49:54 - he turns right left right perfect now we
49:58 - want to see him animated
50:02 - so as I was saying let's get into the
50:04 - animation now this is actually going to
50:07 - be pretty easy because we've already
50:08 - loaded in all of the frames that we need
50:11 - so I know that we don't have a ton to
50:12 - show right now but a lot of the hard
50:13 - stuff is done for this video so just
50:16 - making you aware that all this time has
50:17 - not gone to waste what we need to do is
50:20 - we need to come up with something that
50:22 - has a way to kind of update our Sprite
50:24 - or update what we're showing on the
50:26 - screen so I'm going to write a function
50:27 - here called update
50:30 - Sprite
50:31 - and I'm going to take in self
50:34 - and I'm going to say Sprite sheet
50:36 - is equal to idle now this is the default
50:40 - spreadsheet if we're not moving if we're
50:42 - not jumping if we're not falling if
50:43 - we're not being attacked we use idle
50:46 - however if we are running or we're doing
50:48 - something else then we use the other
50:49 - spreadsheet so now I'm going to say if
50:51 - myself dot x velocity does not equal
50:54 - zero
50:56 - then my Sprite sheet is going to be
50:59 - equal to run so if I have some velocity
51:01 - in the X Direction then I'm running
51:03 - right so then I want to change this to
51:05 - the Run spreadsheet so now I'm going to
51:07 - say my Sprite sheet name
51:09 - is equal to and this is going to be my
51:13 - Sprite sheet plus and then underscore
51:17 - and then plus the self dot Direction
51:21 - perfect so now we just change the main
51:23 - Sprite sheet name so idle run jump
51:25 - whatever we add the direction to it and
51:27 - this tells us you know what exact Sprite
51:30 - shoot we want
51:31 - okay now that we have that what we're
51:33 - going to do is say these Sprites that we
51:35 - could be using for this animation is
51:37 - equal to self.sprites and this is in all
51:40 - capitals at the Sprite sheet name all
51:44 - right now that we've done that we need
51:46 - to essentially iterate through these
51:48 - Sprites and every few seconds change the
51:51 - Sprite that we're showing so it looks
51:52 - like we're animating so we need to add a
51:54 - variable here that is going to account
51:56 - for the amount of delay between changing
51:58 - Sprites so I'm going to call this the
52:01 - animation delay I'm going to make this
52:04 - equal to five okay now I'm going to come
52:07 - here and I'm going to say that my Sprite
52:10 - index which essentially a Sprite that I
52:12 - want to be using here is equal to my
52:14 - self.animation count which we're going
52:16 - to increment in a second integer divided
52:19 - by my self.animation delay
52:22 - modulus by the length of these Sprites
52:26 - that I'm using now let's just put
52:28 - some parentheses here for order of
52:29 - operations
52:31 - and let me explain what we're doing so
52:33 - we have an animation delay that's every
52:35 - five frames so every five frames we want
52:37 - to show a different Sprite in whatever
52:39 - animation we're using so if we're
52:41 - running left if we're idle whatever it
52:42 - doesn't matter we want to show a
52:43 - different one so we take the animation
52:46 - count we divide it by five and then we
52:48 - mod whatever the line of our Sprites is
52:50 - so if we have five Sprites then when
52:52 - we're on say animation count 10 we're
52:54 - showing the second Sprite right you get
52:56 - the idea so this is dynamic this will
52:58 - now work for any single Sprite so
53:01 - hopefully you guys understand how this
53:02 - animation count is kind of working but
53:04 - we're just trying to pick a new index
53:06 - every animation frames from our uh
53:09 - Sprites but we want this to be dynamic
53:11 - so we're using the length of the Sprites
53:12 - and again it's just it's dynamical work
53:14 - for any single Sprite sheet we have now
53:17 - we need to select our Sprites we say
53:19 - self.sprite is equal to the Sprites that
53:22 - we have access to at the Sprite index
53:24 - then we update our animation count by
53:26 - one
53:27 - now what we can do is remove this here
53:30 - from draw and we just need to Now call
53:33 - the self Dot
53:35 - update sprite from our Loop okay so now
53:39 - that we've done that we'll call this
53:40 - we'll update our Sprite every single
53:43 - frame and then we'll draw that updated
53:45 - Sprite on the screen
53:47 - okay let's run it and let's see what we
53:49 - get
53:50 - notice we have idle notice I can run to
53:53 - the right and I can run to the left now
53:56 - if you think this is too slow and some
53:58 - of you may argue that it is then you
53:59 - just make this number smaller so make
54:01 - this three
54:04 - okay and now it looks like we're running
54:06 - a little bit faster so it's completely
54:07 - up to you how you want to animate this
54:09 - um I'll do two for now and let's see if
54:12 - this looks better
54:14 - so actually I think three was a pretty
54:16 - kind of happy medium here so let's go
54:18 - back to three again you guys can change
54:20 - this is up to you how you want it to
54:21 - look okay now that we have that
54:23 - we're almost ready to start doing
54:25 - Collision however we need to introduce
54:27 - something known as a mask so I'm going
54:30 - to make another method here I'm going to
54:32 - say Define update
54:34 - now what we need to do here is
54:37 - essentially update the rectangle that
54:39 - bounds our character based on the Sprite
54:42 - that we're showing so there's different
54:45 - um like kind of sizes to the Sprites
54:47 - right some are a little bit taller some
54:48 - are a little push to the left or pushed
54:50 - to the right and the rectangle that we
54:52 - have we want to be essentially the same
54:54 - as the Sprite that we have again I know
54:58 - this seems a bit weird but we're going
55:00 - to do this we're going to say self.rect
55:02 - is equal to self Dot and then it's going
55:05 - to be Sprite dot get underscore rect and
55:08 - we're going to say that the top left of
55:10 - this rectangle is equal to the
55:13 - self.rect dot X
55:16 - and the self.rec dot y
55:18 - now pretty much what's going to happen
55:20 - here is depending on what Sprite image
55:22 - we have if it's slightly smaller
55:24 - slightly bigger whatever we're going to
55:25 - constantly adjust the rectangle
55:27 - specifically we're going to adjust the
55:29 - width and the height of it but we're
55:30 - going to use the same X and Y position
55:32 - that we've had for this rectangle if you
55:35 - don't understand that
55:36 - um it's fine it's not a massive deal
55:37 - this line is not crazy important but
55:39 - it's just trying to make sure that the
55:41 - rectangle we're using to kind of bound
55:42 - our character is constantly adjusted
55:44 - based on the Sprite that we're using now
55:46 - what's more important is this line which
55:48 - is updating the mask we're going to say
55:50 - self.mask is equal to pygame dot mask
55:53 - Dot from surface and this is going to be
55:56 - self dot Sprite
55:59 - now let me quickly explain this a mask
56:01 - is essentially a mapping of all of the
56:04 - pixels that exist in the Sprite so
56:06 - whenever we draw something on the screen
56:07 - we're really drawing a rectangle right
56:09 - but the rectangle may not have
56:13 - um non-transparent pixels right so only
56:15 - part of the rectangle is actually filled
56:17 - in hence why we get kind of a circular
56:19 - image a dynamic image whatever so what
56:21 - this mask tells us is where there's
56:23 - actually images or where's this actually
56:25 - pixels sorry and this mask allows us to
56:28 - perform Pixel Perfect Collision because
56:30 - we can overlap it with another mask and
56:33 - make sure that we only say two objects
56:35 - Collide if pixels are colliding not if
56:37 - the rectangular box is colliding if we
56:40 - did rectangular Collision then it
56:42 - constantly looks like we're hitting
56:43 - something even when we're not because
56:45 - the rectangle for our character is
56:47 - larger than where all of the pixels for
56:49 - our character are you've probably seen
56:51 - this in a lot of games before but what
56:53 - the mask does is solve that problem for
56:54 - us and allow us to do this kind of Pixel
56:57 - Perfect Collision it's very important
56:58 - though that you you call this mask if
57:00 - you don't do that this Collision is not
57:02 - going to work properly it needs to be
57:04 - masked because the Sprite that we
57:06 - inherited from here uses this rectangle
57:09 - and uses this mask property when it does
57:12 - the Collision all right so now that
57:14 - we've done this I just need to call this
57:15 - function so I'm going to go here and say
57:17 - self dot update and now we're done with
57:21 - most of what we need for the player
57:26 - so what we want to do now is we want to
57:28 - start adding blocks onto the screen and
57:30 - then letting a player fall collide with
57:32 - those blocks and then be able to jump
57:33 - because obviously we can't really jump
57:35 - until we have something to jump off of
57:37 - otherwise jumping in thin air doesn't
57:39 - make a ton of sense alright so let's
57:42 - create another class here and this class
57:45 - I'm going to call object and this will
57:48 - be a base class that we use for
57:50 - essentially all of our objects just so
57:52 - that the Collision will be uniform
57:53 - across all of them so again we're going
57:55 - to inherit from the Sprite class from PI
57:57 - game and we're going to Define our
57:59 - initialization so to find a knit we're
58:02 - going to take in self X Y width and
58:06 - height and name which for now is going
58:08 - to be equal to none but could be equal
58:10 - to something we're then going to say
58:12 - super dot underscore underscore knit
58:15 - which will initialize the superclass
58:18 - which is this one right here now that
58:20 - reminds me we need this as well in our
58:22 - Constructor for player so let's put that
58:25 - in player
58:26 - okay now we need to define a rectangle
58:29 - so we're going to say self-directangle
58:31 - is equal to Pi game
58:33 - Dot rect
58:36 - and then this is going to be x y
58:38 - width and height
58:41 - we're going to say self.image is equal
58:44 - to Pi game
58:47 - dot surface and then this is going to be
58:50 - width
58:51 - height and then we're going to say Pi
58:54 - game
58:54 - dot source
58:56 - Alpha like that if we spell Pi game
58:59 - correctly again this just supports
59:01 - transport transparent images for us my
59:03 - apologies and then we're going to say
59:06 - self dot width equals width
59:10 - self.height
59:12 - is equal to height and self dot name
59:17 - is equal to name
59:18 - where are they going to say Define draw
59:22 - I'm going to say self and window like
59:25 - this and then we're going to say win
59:28 - dot blit
59:30 - and this is going to be self.image
59:33 - and then we're going to blip this at the
59:35 - self Direct
59:37 - dot X and the self.rect.y
59:41 - okay I know I went fast essentially this
59:44 - is just a base class we're not actually
59:46 - going to instantiate this but this just
59:48 - defines all the properties that we need
59:49 - for a valid Sprite so we have a
59:52 - rectangle we have our image we are
59:55 - drawing the image and then in a class
59:57 - that we're about to use we're going to
59:58 - inherit from this and it will just save
60:00 - us from rewriting a bunch of
60:01 - functionality that we don't need so the
60:03 - idea here is that
60:05 - all we do is modify this image when we
60:07 - change the image now the draw function
60:09 - will automatically draw it accurately on
60:10 - the screen for us and all these other
60:13 - properties we're just saving in case we
60:14 - need them from our child class so I'm
60:17 - going to make a class now called block
60:18 - this is going to inherit from object
60:22 - now we're going to say Define
60:24 - a net and we're going to take in self x
60:27 - y and the size of our block now since
60:29 - the block is a square we just need one
60:31 - dimension not two right
60:33 - okay we're going to say super
60:35 - dot underscore underscore knit
60:37 - and we're going to pass x y
60:40 - size size so notice this Constructor
60:42 - requires four arguments so we have to
60:44 - pass four here we just duplicate size
60:46 - because it's the same for the width and
60:48 - the height then we're going to say block
60:50 - is equal to load block which is going to
60:52 - be a function that we write in a second
60:54 - that will take a size we're then going
60:57 - to say self dot image dot blit
61:00 - imagine that this is going to give us an
61:02 - image okay which it will in a second
61:03 - when we write it we're going to blit the
61:05 - block
61:06 - at position zero zero and then we're
61:09 - going to say the self.mask is equal to
61:12 - High game
61:13 - dot mask Dot from surface we're going to
61:16 - take our self.image and there you go we
61:20 - have our mask which we need for
61:21 - Collision
61:23 - again I know this is a little confusing
61:25 - it'll make more sense in a second but
61:27 - we're using this object which now has
61:28 - this draw function built in for us it
61:30 - also defines the rack that defines the
61:32 - width and the height and all of that
61:33 - stuff here what we do is we get the
61:35 - image that we need which we're going to
61:37 - write this in one second then we BLT
61:40 - this image to our image which is a pi
61:42 - game surface and then we say self.maski
61:45 - we'll do pygame.mask Dot from surface
61:47 - self.image we also could just say
61:48 - self.image is equal to the block but
61:51 - let's do it this way for now okay so
61:53 - let's now write our get Block function
61:55 - which I'm going to do beneath our get
61:58 - Sprite sheet or load Sprite sheet so I'm
62:00 - going to say get Block
62:02 - and I'm going to take in a size now what
62:05 - I need to do here is essentially find
62:06 - the block that I want in my train folder
62:09 - so I'm going to say path is equal to
62:11 - join
62:13 - assets and then this is going to be
62:15 - terrain like so and then we're going to
62:19 - use the terrain.png file so if I go here
62:23 - you can see that we have train terrain
62:25 - and then what we want to do is load this
62:27 - block
62:28 - which I'll be showing you how to load in
62:30 - one second
62:32 - okay
62:33 - now that we have done that now that we
62:34 - have our path we're going to say the
62:36 - image is equal to Pi game dot image dot
62:40 - load and we're going to say path again
62:42 - dot convert Alpha so that we get a
62:44 - transparent background we don't really
62:46 - need it for this one but just in case
62:47 - later we load something does have
62:49 - transparency we will
62:51 - and then we're going to say surface is
62:52 - equal to Pi game dot surface and for the
62:56 - surface we're going to pass size size
62:58 - which is the width and the height of our
63:00 - surface
63:01 - we're gonna pass pygame DOT Source Alpha
63:04 - with a depth sorry of 32. we're going to
63:08 - say rectangle is equal to pygame Dot
63:11 - rect and then this is going to be 96 0
63:15 - size size now let me slow down for one
63:18 - second if we go to Terrain
63:20 - we can see that we want to load this guy
63:23 - right here now I've already done the
63:25 - math this image starts 96 pixels from
63:29 - the top of the screen so that's the
63:30 - reason I'm putting 96 there because I
63:32 - want to start at 96 so 960 is my
63:34 - position and then I want to load the
63:36 - size of this which I think is going to
63:38 - be either 96 or 64 or something along
63:41 - those lines anyways if I wanted to load
63:43 - say this terrain image then I would
63:45 - still have 96 but my y position would be
63:48 - different in fact the Y position would
63:50 - probably be a little bit less than 96 it
63:52 - might be 80 it might be 85 I'd have to
63:54 - like experiment with it to see exactly
63:56 - where this image starts but I just want
63:58 - you to understand that what I'm passing
64:00 - here when I say something like 960 I'm
64:02 - passing the position that I want to load
64:05 - the image from from the image right so
64:08 - I'm picking out a part of this image and
64:10 - this is like 96 0. that's where I'm
64:13 - picking it right here
64:14 - hopefully uh you guys understand that
64:16 - but if you want to load a different
64:18 - train image then you have to adjust
64:19 - these to be the starting position the
64:21 - top left hand corner of whatever image
64:23 - it is you want to load here and if yeah
64:26 - I was going to say we could load a
64:27 - different one but I don't want to waste
64:28 - time guessing which one it is so you
64:30 - guys can mess with that if you want but
64:31 - let's just load this top one which I
64:33 - already know works okay now that we have
64:35 - that
64:36 - we're gonna say surface dot Blitz and
64:39 - we're going to Blitz the image
64:42 - and again we're going to BLT it at 0 0.
64:45 - but we're only going to blit the area of
64:47 - it which is represented by the rectangle
64:49 - then we're going to return pygame Dot
64:52 - transform dot scale 2X
64:57 - surface
64:58 - Okay so we've passed what size we want
65:02 - our block to be
65:04 - then we create an image that is of that
65:06 - size okay we then say rectangle is equal
65:09 - to 96 0 size size right and then we BLT
65:13 - this image onto our surface which will
65:16 - be the image that we return and we
65:17 - return this scaled up by two times so it
65:19 - just doubles the size that we pass here
65:21 - you don't have to scale it if you don't
65:22 - want but I want it to be larger so I am
65:24 - scaling it now I understand again it's a
65:27 - bit confusing this size is going to be
65:29 - the dimension of this block so you want
65:32 - to pass whatever the size from this
65:34 - Sprite sheet is that you want to get in
65:35 - our case I think it's going to be 64 or
65:37 - something along those lines so that's
65:39 - what size will be
65:41 - you guys can mess around with this but
65:42 - really what you're going to be changing
65:44 - is these two values and the size that's
65:46 - what you're going to change when you
65:48 - want to load a different image for your
65:49 - block okay so now for Block we have get
65:52 - block or load block uh did I call it
65:55 - load block or get Block
65:56 - I called it get Block okay so let's
65:58 - change this to be get Block
66:01 - all right so we now have our block let's
66:04 - create a block let's draw a block on the
66:06 - screen and let's do some collision with
66:08 - our blocks
66:10 - okay so let's go here to Main
66:13 - and let's say blocks is equal to and
66:16 - let's just start by creating a single
66:18 - block so for our block uh let's just put
66:20 - it kind of randomly on the screen for
66:22 - now uh where do I want to put this let's
66:25 - go with something like
66:29 - actually I'm going to create a variable
66:30 - first I'm going to say block size let's
66:33 - put this at zero
66:34 - height minus the block underscore size
66:38 - block size is going to be equal to 96
66:41 - okay and then 4
66:44 - B size we're going to pass block size
66:46 - okay
66:48 - so the size of our block is actually 96
66:50 - I lied it is not 64. it's going to be
66:53 - 96. so we're going to create a block
66:55 - it's going to be positioned at zero
66:56 - height minus block size which is going
66:58 - to put it at the bottom of the screen
66:59 - and then the size is this now we need to
67:03 - draw our blocks so I'm going to pass
67:04 - blocks to my draw function
67:06 - okay and I'm going to go here
67:09 - and actually let's call this objects
67:12 - and we're going to say form objects or
67:15 - for obj
67:17 - in objects if we could type this
67:20 - correctly
67:22 - obj dot draw I'm struggling here with
67:25 - the typing and we will draw this on the
67:27 - window
67:28 - okay so we have our block now
67:31 - let's quickly look at this again right
67:32 - we load our image okay we get our block
67:34 - we have our size now we create the block
67:36 - down here
67:38 - and then we put it on the screen
67:40 - let's run it and let's see if we got a
67:41 - block
67:42 - and of course we've got an error what
67:44 - does it say here I need to run this
67:46 - again
67:48 - I take zero positional arguments but one
67:50 - was given okay so let's go to our player
67:53 - class here
67:54 - and we can see update I forgot to add
67:56 - the self parameter so let's add that in
67:58 - and that should fix it
68:00 - okay so now you can see that we have a
68:02 - block so now what we can do is create a
68:04 - whole floor of blocks if we want to do
68:06 - that and then we'll Implement gravity
68:07 - and then collision with the block so
68:09 - that you can see that you like can land
68:10 - on the Block and we can jump off of the
68:12 - block
68:13 - all right so let's make a whole floor so
68:15 - to make a floor we can do this we can
68:19 - say floor is equal to we're going to say
68:21 - block
68:22 - it's going to be I
68:24 - times
68:26 - block size
68:30 - it's gonna be height minus block size
68:31 - block size
68:34 - 4 I in range and I'm going to say
68:38 - negative width
68:40 - width times two
68:43 - um and we're going to divide this
68:46 - by the block size
68:48 - and by the block size
68:51 - okay then for my
68:53 - blocks uh let's actually just
68:56 - replace this and instead we'll just pass
68:58 - floor
68:59 - okay what I've done here with this for
69:01 - Loop is I've said I want to create
69:04 - blocks that go kind of to the left and
69:07 - to the right of the screen so I don't
69:08 - want to just fill the current screen
69:10 - because we're going to have a scrolling
69:11 - background in a second which we'll
69:12 - Implement in a minute anyways I want to
69:14 - have some kind of going to the left and
69:15 - so I'm going to the right so I'm taking
69:16 - my negative width uh over the block size
69:19 - which is how many blocks I want to the
69:21 - left side of the screen and then I'm
69:23 - taking my width times 2 and I'm
69:25 - interested dividing that by the block
69:26 - size again that's how many blocks I want
69:28 - to the right of the screen then I'm
69:31 - taking I I'm multiplying it by my block
69:33 - size which is telling me the x
69:35 - coordinate position that I want my block
69:37 - to be at
69:39 - and then this is always going to be the
69:41 - same because I want it to be at kind of
69:43 - the bottom of the screen and then for my
69:45 - block size well I want that to always be
69:46 - the same
69:47 - okay so let's run this now and see what
69:49 - we get
69:50 - and now we get a bunch of blocks so now
69:53 - that we have these blocks let's make it
69:55 - so we can collide with the blocks and so
69:57 - we have gravity and we actually fall
69:59 - onto those blocks
70:03 - so the Collision all right Collision is
70:06 - a little complicated but let's write it
70:09 - and let's see how we can how we can get
70:12 - it going here so inside of handle move
70:14 - is where we're going to handle our
70:15 - Collision which means we need to have a
70:17 - list of objects that we can potentially
70:19 - be colliding with now we are going to
70:22 - write a function here
70:24 - called handle vertical
70:27 - Collision because we need to handle the
70:29 - vertical and horizontal Collision
70:30 - differently for now we'll just start
70:32 - with uh vertical and we're going to take
70:34 - in player objects and the displacement
70:36 - in y that we just moved
70:39 - now we're going to have collided
70:40 - underscore objects is equal to a list
70:43 - we're going to say for object in
70:46 - objects these are all the objects we
70:48 - could be colliding with
70:49 - and we're going to say if High game
70:53 - Dot Sprites dot Collide mask and then
70:58 - we're going to pass
70:59 - our player
71:01 - and our object
71:04 - now remember I told you Collision was
71:05 - going to be simple well there you go
71:07 - this is all you need to do to determine
71:09 - if two objects are colliding the reason
71:11 - we can do this is because our objects
71:13 - we've inherited from the Sprite class
71:15 - and on them we have a mask so we're
71:18 - going to use this mask property as well
71:19 - as the rectangle property when we
71:21 - collide with the mask so I pass my
71:23 - player I pass my object and this will
71:25 - tell me if I am colliding with my object
71:28 - perfect now if I am I'm going to do some
71:32 - stuff differently depending on what
71:34 - direction I'm colliding in so if I'm
71:35 - hitting the top of the object it's going
71:36 - to be different than if I'm hitting the
71:38 - bottom so we need to handle that here so
71:40 - I'm going to say if my displacement Y is
71:42 - greater than zero really this should be
71:45 - velocity but that's fine
71:47 - then what I'm going to do is place
71:50 - my character on top of the object it
71:53 - collided with so I'm no longer colliding
71:55 - with it
71:57 - now what this is saying is if I'm moving
71:59 - down on the screen so if I'm moving down
72:01 - then that would mean I was colliding
72:02 - with the top of this object so if I am
72:05 - I'm going to take the bottom of my
72:07 - player rectangle which is my bottom my
72:09 - player's feet essentially and I'm going
72:11 - to make it equal to the top of the
72:14 - object I'm colliding with this is
72:16 - another advantage of using rectangles
72:17 - you can use this kind of bottom and top
72:18 - property and avoid having to do you know
72:20 - add the height and all that kind of
72:22 - stuff so that's what I'm going to do now
72:24 - otherwise I'm going to say if my
72:25 - displacement Y is less than 0 and I
72:27 - suppose this can be an L if
72:29 - then
72:30 - what I will do is say myplayer.rec dot
72:34 - top is equal to the obj.rec dot bottom
72:37 - because if I'm moving up which means I
72:39 - have a negative velocity then I am
72:42 - hitting the bottom of an object so I
72:44 - need to make my top be equal to the
72:46 - bottom okay this just makes it so you
72:48 - don't like say stay inside of the object
72:50 - excuse me you go outside of it and it
72:52 - looks like you collided but you didn't
72:54 - go through the object
72:55 - now one thing we also need to do here is
72:58 - we need to call the method player.landin
73:00 - and player.hit head which I've not yet
73:02 - created and we're going to write these
73:05 - to handle what happens when we land on a
73:07 - block and when we hit our head on a
73:09 - block
73:09 - okay then we're going to say collided
73:11 - objects dot append and we're going to
73:13 - append our object and we're going to
73:15 - return our collided objects just so that
73:18 - we know what objects we collide with so
73:21 - that we can check if we collided with
73:22 - like fire or a certain special object or
73:25 - something like that
73:26 - okay so let's handle vertical Collision
73:28 - now we need to write the uh landed and
73:32 - hit head method
73:33 - so let's go to player
73:35 - and let's do this so I'm going to say
73:38 - let's do it here
73:39 - landed
73:41 - self
73:42 - now what do we do if we lend it well if
73:46 - we just landed then we need to reset our
73:48 - gravity or our fall counter
73:50 - so we're going to say self dot fall
73:52 - count
73:54 - is equal to zero so that way we stop
73:57 - um like adding gravity right okay what
74:00 - else do we need to do if we land it we
74:01 - need to say that our y velocity is equal
74:04 - to zero if we let it on a block stop
74:06 - moving us down
74:07 - and I'll add this in now we're going to
74:10 - say our self.jump count is equal to zero
74:12 - we're going to do something with jumping
74:14 - that involves double jumping so we'll
74:15 - have a jump counter I'll just put this
74:17 - here now and then we'll we'll use it
74:18 - later
74:19 - okay so that's if we landed otherwise
74:21 - I'm going to say Define
74:23 - hit head
74:25 - for self I'm going to say self.count
74:27 - equals zero but if we hit our head I
74:29 - want to reverse our velocity so that now
74:31 - we move down because we're moving up
74:33 - right so I'm going to multiply my
74:35 - velocity by negative one so when I hit
74:37 - my head I kind of bounce off the block
74:38 - and go downwards that's what's going to
74:40 - look most natural
74:41 - okay so that's all we need for right now
74:43 - for hitting the head now we can add our
74:45 - gravity back and when we add our gravity
74:47 - back what's going to happen is we'll
74:49 - fall we'll hit the block I'll move us to
74:51 - the top of the block
74:52 - and then we should just be able to move
74:53 - on top of the block
74:54 - let's see if that's going to work though
74:56 - uh although it's not gonna work if we
74:58 - don't add the function call so let's add
75:01 - the function call here
75:03 - in handle move we're going to say
75:06 - handle vertical Collision we'll pass the
75:09 - player the objects
75:10 - and the player.y velocity
75:13 - and the Y velocity is essentially how
75:16 - much we just moved right
75:18 - okay very good now let's make sure
75:21 - handle move we need to pass our floor so
75:25 - let's do that
75:26 - all right let's run the code
75:28 - let's see what we get
75:30 - and boom look we land on a block and we
75:33 - can now run on top of the block
75:36 - and everything is looking very good
75:39 - to me okay so that's pretty good now
75:41 - that we're on top of a block we can jump
75:43 - and then we can deal with uh hitting
75:45 - blocks
75:46 - um what do you call this uh horizontally
75:48 - right so that we can't like run into a
75:50 - block and we'll also make the background
75:51 - scroll and then we'll be pretty good
75:54 - we'll have a lot of this tutorial
75:56 - finished
76:00 - I wanted to make us jump yes let's make
76:01 - it jump okay so let's go to our player
76:04 - and let's create a variable here
76:06 - self.jump underscore count is equal to
76:09 - zero now based on the way we've coded
76:11 - this jumping is actually quite easy I
76:13 - can say Define jump
76:16 - self
76:17 - and when we jump all we're going to do
76:20 - is say self.y underscore velocity is
76:24 - equal to the negative of self-dog
76:26 - gravity multiplied by whatever Factor
76:28 - you want in terms of the speed of your
76:30 - jump so I'm going to multiply Gravity by
76:32 - eight the reason I'm doing this negative
76:34 - is that I jump up in the air right so
76:36 - now that I've done this what will happen
76:38 - is as soon as I hit the jump key I'll
76:40 - jump up into the error it's pretty
76:42 - straightforward and the reason that's
76:44 - going to happen is because my y velocity
76:45 - will change and what will bring me down
76:47 - is the fact that inside of my Loop if I
76:51 - go to where Loop is I'm constantly
76:53 - applying downward gravity so what I'm
76:54 - doing is changing my velocity to go
76:56 - upwards and then I'm letting gravity
76:58 - take me down so that's kind of the
77:01 - benefit of how we've coded this jumping
77:02 - is very easy
77:03 - now I'm also going to reset my animation
77:05 - count to zero I'm going to say my jump
77:07 - count plus equals one I'm going to say
77:11 - if the self dot jump underscore count
77:17 - is equal to one this means that I'm
77:19 - double jumping so if the jump counts
77:21 - equal to one when I hit jump that means
77:23 - it's just going to be equal to 2 now
77:26 - actually let me take this sorry and put
77:28 - this down here
77:29 - then I will say self.count is equal to
77:34 - zero
77:35 - yeah I think does that make sense
77:40 - no I want to do it this way sorry
77:42 - okay so what I'm trying to do here is
77:44 - make it so that as soon as I jump I
77:46 - essentially get rid of any gravity I've
77:48 - already obtained so let's say I was like
77:51 - falling and then I landed and then I
77:53 - jumped there would be some gravity on me
77:55 - keeping me on the ground so I want to
77:57 - remove that gravity so that when I jump
77:59 - up it's not in uh the factor it's like
78:01 - it's not taken into account and then
78:03 - I'll start applying the gravity after
78:05 - I've jumped hopefully that makes a bit
78:07 - of sense but this should say
78:09 - fall count so as soon as I jump I'm
78:11 - resetting the fall count to be equal to
78:13 - zero so that any gravity I've
78:15 - accumulated I'm removing but I'm only
78:18 - doing that if this is the first jump I'm
78:20 - making because for the second jump I
78:23 - want you to have to time it based on
78:25 - like when you're jumping right so if you
78:27 - jump a second time close to when you
78:30 - jump the first time you will jump higher
78:32 - than if you jumped at like the peak of
78:34 - your jump when your gravity would be the
78:35 - highest okay I don't know if that makes
78:37 - sense but just just follow along here
78:38 - this I messed with this before this
78:40 - works trust me all right so we have
78:43 - jumping now I think that's all we really
78:46 - need for jumping
78:48 - um yeah that seems good to me so now if
78:50 - we want to jump let's make it so when we
78:51 - hit space we jump so we can do that
78:53 - inside of handle move
78:55 - actually I'm not going to do a handle
78:57 - move I'm going to do it here in the
78:59 - event Loop and the reason for this is
79:01 - that if I do it in handle move what's
79:03 - going to happen is if I press the jump
79:04 - key and I hold the jump key down I'm
79:06 - going to keep jumping a bunch of times I
79:08 - don't want to do that I just want to
79:09 - jump once when I hit the key and then I
79:12 - have to release the key and press it
79:13 - again to jump this tells me if I'm
79:15 - holding down the key what I'm going to
79:17 - do in here tells me if I released the
79:19 - key yeah you'll see
79:21 - um but yeah this is this is how I do it
79:22 - so I'm going to say if event DOT type is
79:25 - equal to pygame Dot key down I'm going
79:29 - to say if event dot key is equal to Pi
79:33 - game
79:34 - dot k underscore space
79:37 - and
79:38 - my player dot jump count is less than
79:42 - two so I'm going to allow double jumping
79:44 - right so I'll have two jumps then I'm
79:46 - going to say player dot jump
79:49 - okay
79:50 - that should be all we need for jumping
79:52 - so let's try it out and let's see if
79:54 - this works
79:56 - and I can jump
79:58 - and notice I can kind of Run and Jump at
80:00 - the same time now what I'll do now is
80:02 - add uh like falling and jumping
80:05 - animations because obviously it looks
80:06 - kind of weird right now when I'm jumping
80:09 - but there you go we can jump nice
80:11 - okay so let's add the uh the animations
80:13 - now so if we go to update Sprite all we
80:17 - need to do here is we can say if
80:20 - self Dot
80:23 - and actually I need to refer to my cheat
80:25 - sheet here because this is a bit more
80:27 - complicated than I thought okay I'm
80:28 - going to say if not self if self.y
80:30 - underscore velocity does not equal zero
80:33 - then what I will do is say if self dot
80:37 - jump count equals equals one
80:40 - then I'm going to say my Sprite sheet is
80:43 - equal to jump
80:45 - I'm going to say l if self
80:47 - dot jump count
80:49 - equals equals two then my spreadsheet
80:52 - is equal
80:54 - to double jump
80:56 - now this is actually going to be if my
80:57 - velocity is less than zero which means
80:59 - I'm moving up
81:01 - now the next one that I want to add is I
81:03 - want to say if and actually these are
81:05 - all going to be L IFS
81:07 - well not that one but this one I'm going
81:10 - to say elif myself.y underscore Val is
81:14 - greater than zero this means I'm moving
81:15 - down then my Sprite sheet should be
81:17 - equal to fall
81:20 - okay
81:21 - so this is handling regular jump and
81:23 - double jump and this is telling me if
81:25 - I'm falling let's try it now
81:28 - and let's see what happens when I jump
81:31 - okay so it's kind of glitching a little
81:33 - bit uh the reason this is happening I
81:35 - believe is because we are applying
81:37 - gravity even while we're on the ground
81:40 - so my y velocity
81:42 - is always greater than zero and then
81:44 - stops being greater than zero that's
81:46 - greater than zero again so I will show
81:48 - you how to fix this all right so
81:50 - actually the way that I'm going to fix
81:51 - this is a bit of a hack but it's it's
81:55 - gonna be good it'll work here so I'm
81:56 - actually going to say if myself the Y
81:58 - velocity is greater than
82:01 - self
82:02 - Dot
82:04 - gravity
82:06 - times two now the reason I'm going to do
82:08 - this for fall is so that I don't
82:11 - immediately start glitching into this
82:13 - false State when I have a really low
82:15 - amount of gravity being applied to me
82:16 - when I've gone off the block and then
82:18 - I've fallen down to the block so let me
82:20 - show you what I mean by just kind of
82:21 - kind of writing the code here so you can
82:23 - see that what happens is when I hit the
82:25 - block when I collide with it it's going
82:27 - to reset my gravity count and then I'm
82:29 - going to kind of Spawn to the top of the
82:31 - block so when I'm on the top of the
82:32 - block I'm going to be slowly falling
82:34 - down to the block then I'm going to hit
82:36 - the block when I hit the Block it's
82:37 - gonna do the same thing it's going to
82:38 - bring me to the top reset my gravity
82:40 - account so what was happening before is
82:41 - that we would go to the top of the block
82:44 - and then our gravity would increase a
82:46 - tiny bit right it would increase to be
82:48 - one pixel per second or something along
82:49 - those lines which would mean we were
82:51 - falling so then we were falling we hit
82:53 - the block and then it reset it so it
82:54 - kept glitching between the two states so
82:56 - what I've done is just made it so we
82:57 - have to have a significant amount of
82:59 - gravity before it starts showing that
83:00 - fall state so now it doesn't look
83:02 - glitchy on the screen as I'm jumping
83:04 - around
83:06 - and you can see that what actually
83:07 - happens is when I jump and I get to the
83:09 - peak of my jump you can see that it
83:10 - starts the falling State because now my
83:14 - velocity has changed directions right
83:16 - now I'm going down
83:17 - okay so now we have jumping now we have
83:19 - running around and colliding with blocks
83:21 - done quite a bit actually the next thing
83:23 - I want to do is make it so that objects
83:25 - move on the screen then we will do a
83:27 - horizontal collision and then we will
83:29 - pretty much be done after I add kind of
83:32 - that like fire uh state right or that
83:34 - let's call it trap something like that
83:39 - okay so we want to do scrolling
83:41 - background scrolling background is
83:42 - actually fairly easy the way that we do
83:44 - a scrolling background is we simply
83:46 - offset every single thing that we're
83:48 - drawing on the screen by a certain
83:49 - amount so any object that we have we
83:52 - don't change its position at all we just
83:53 - change how we're drawing it on the
83:55 - screen so it doesn't affect any of our
83:57 - Collision all it affects is what's seen
84:00 - right so what's happening in the
84:01 - background is we may be colliding at a
84:03 - really far position to the right we're
84:05 - showing the position currently on the
84:07 - screen
84:08 - you see what I mean but what this
84:10 - involves
84:11 - is having some offset X which I'm going
84:13 - to say is equal to zero now the way that
84:15 - I want to have it and I'll just
84:16 - illustrate here is that when I'm on the
84:19 - screen I only start scrolling the
84:21 - background when I get close to the edge
84:22 - so like here right it would start
84:24 - scrolling whereas if I'm in the middle
84:25 - and I'm kind of moving like this I don't
84:27 - want it to scroll the background until I
84:29 - get to the edge oh also notice you can
84:31 - double jump here I kind of forgot to to
84:32 - mention that part
84:34 - um so I'm going to implement that where
84:36 - essentially once we reach a certain
84:37 - boundary then the screen will start
84:39 - scrolling
84:41 - all right so how do we do this well we
84:43 - can do it just directly inside of our
84:46 - Loop here and we're going to do it here
84:48 - we're going to say if the player.rect
84:52 - dot X
84:54 - minus the offset X
84:56 - plus the player.rect dot width and
84:59 - actually now that I think of this we're
85:01 - just going to do this we're going to say
85:02 - if the player.rect dot right which will
85:06 - account for the width minus the offset X
85:10 - is greater than or equal to
85:13 - the width
85:16 - minus a variable that I'm going to write
85:18 - in a second which is scroll area
85:21 - width
85:22 - and the blair.x underscore velocity is
85:26 - greater than zero
85:28 - then we're going to say
85:30 - offset underscore X and this is going to
85:34 - be plus equals the player dot x velocity
85:39 - all right let me just write this
85:41 - variable then I'll explain how this
85:42 - works because we also have to do the
85:44 - other side so I'm going to say scroll
85:45 - area width is equal to 200
85:47 - what that means is that when I get to
85:49 - 200 pixels on the left or 200 pixels on
85:52 - the right of the screen I start
85:53 - scrolling okay so here what I'm doing is
85:56 - I'm checking if I'm moving to the right
85:57 - that's what this checks if my x velocity
85:59 - is greater than zero that means I'm
86:01 - moving to the right
86:02 - and this is checking if my character is
86:06 - right on the screen
86:08 - like if it's crossed a specific boundary
86:11 - so I take whatever the right position of
86:13 - my player is which could be very far off
86:16 - the screen
86:17 - I subtract whatever offset we currently
86:21 - have so if we're offsetting everything
86:22 - by 100 pixels for example I subtract
86:25 - that so I know where I'm actually
86:27 - showing the character on the screen and
86:29 - I say if that's greater than the width
86:31 - minus the scroll area width which means
86:33 - I'm at say 700 pixels something like
86:35 - that on the right side of the screen
86:36 - then I'm going to offset the screen by
86:40 - whatever the velocity was that my player
86:42 - just moved to the right so that will
86:44 - make it look like I'm scrolling now we
86:46 - can say or
86:49 - and do the exact same thing for the left
86:51 - side so I'm going to say if player Dot
86:53 - rect
86:54 - dot left
86:56 - and this is actually going to be
86:58 - is going to be plus the offset I gotta
87:00 - check if it's Plus or if it's minus no
87:02 - it's going to be minus again minus the
87:03 - offset X is less than or equal to the
87:06 - scroll area width
87:08 - and my player dot X underscore Val is
87:12 - less than zero
87:13 - then I want to do this now let's move
87:16 - this down on the screen a bit I'm just
87:18 - going to add some parentheses so that my
87:20 - condition is
87:22 - correct here
87:26 - okay so I think that should be good
87:27 - again I'm checking to the left and to
87:29 - the right side if I'm moving to the left
87:31 - I want to check if I'm at that boundary
87:33 - if I'm checking to the right or if I'm
87:35 - moving to the right story I want to
87:36 - check if I'm at that boundary and then I
87:37 - increment my offset X now all I have to
87:40 - do to account for this is add an offset
87:43 - X to my draw function and draw every
87:45 - single object offset by this x so I'm
87:48 - going to go here and say offset
87:50 - underscore X and now just to all of my
87:53 - draw functions I'm going to pass
87:57 - offset X
87:59 - offset underscore X I'm going to go to
88:02 - all my draw functions and I'm going to
88:03 - add this
88:06 - offset X and what I'm going to do is
88:08 - just subtract
88:09 - the offset X from the X position I'm
88:12 - drawing everything out so we say minus
88:13 - offset X and we'll take in
88:16 - the offset underscore X
88:18 - okay now the reason this works if I move
88:20 - to the left my offset X is going to be
88:22 - negative which means everything is going
88:24 - to push to the right side because we're
88:26 - adding to the position for it if I move
88:28 - to the left side or sorry if I move to
88:30 - the right side the offset X is going to
88:31 - be positive which means everything is
88:33 - going to move to the left so it has a
88:35 - scrolling background effect
88:37 - let's just run it though and see if it
88:39 - works then I can fix it if it doesn't
88:42 - okay so as I start running here you can
88:44 - see that now the floor is going to start
88:46 - going with me once I reach this boundary
88:48 - however
88:49 - on this side right like when I'm in the
88:51 - middle is not doing anything I have to
88:52 - get to a certain boundary which is kind
88:54 - of invisible on the screen and then it
88:56 - starts scrolling with me which is what I
88:58 - wanted to do and then notice if I jump
89:00 - here boom I fall off the platform
89:05 - let's do collision with blocks in the
89:08 - horizontal Direction
89:10 - so to do that I'm just going to add a
89:12 - block here so I'm actually going to make
89:14 - a list
89:15 - I'm going to say objects is equal to
89:17 - Asterix floor now if you've ever seen uh
89:21 - like kind of dot dot dot in JavaScript
89:23 - that's what this does in Python it just
89:25 - essentially breaks this floor into all
89:27 - its individual elements and passes them
89:29 - inside of this list so imagine it if me
89:32 - just writing this here that's what it's
89:34 - doing
89:35 - and then I'm going to pass another block
89:37 - and for this block I'm going to place
89:39 - this at
89:41 - let's do zero and then for the Y this is
89:46 - going to be the height of the screen
89:49 - minus the block size times two
89:52 - now the reason I'm multiplying this by
89:54 - two is so that I get it a bit higher on
89:56 - the screen
89:58 - so that we can kind of run into it
90:00 - horizontally and I'm going to pass my
90:02 - block size
90:03 - so I'll just see now I want to go and
90:06 - rather than drawing my floor
90:08 - want to pass objects
90:11 - and same here with handle move on to
90:13 - pass objects
90:14 - so let me run this
90:16 - so now you can see that I have that
90:17 - block there right
90:19 - now notice that when I hit the block I
90:21 - kind of go to the top of it and the
90:23 - reason I go to the top of the block is
90:25 - because right now I'm only handling my
90:26 - vertical Collision so when I hit the
90:29 - block I have a little bit of gravity
90:30 - because remember there's always some
90:31 - gravity on me when I'm on the floor and
90:33 - so it thinks that I've hit the top of
90:34 - the block so it spawns me on the top of
90:36 - the block so we need to make it now so
90:38 - that when you hit the Block in the
90:39 - horizontal Direction it kind of Pops you
90:41 - off of it so that it doesn't think
90:43 - you're hitting the top of the block or
90:45 - the bottom of the block alternatively
90:46 - which you'll see in a second and in fact
90:48 - let me add one more block to show you uh
90:50 - hitting our head on the Block
90:52 - so let's add another block
90:54 - let's make this at say block size
90:57 - multiplied by three and then for the
91:01 - height let's do times four
91:04 - okay now we have another block let's see
91:07 - where this guy is now I can show you
91:09 - that I can hit my head on the Block
91:10 - right and I can't kind of go
91:12 - above it
91:15 - okay anyways we have that let's do our
91:17 - horizontal Collision
91:19 - so the horizontal Collision
91:21 - is a bit weird to implement the idea
91:25 - behind this is that since we're using
91:27 - our Sprite Collide mask we want to make
91:31 - sure that if we collide with a block
91:32 - horizontally we move ourselves off of
91:35 - that block so that it doesn't think that
91:38 - we're colliding with it in the vertical
91:39 - Direction now you just saw that happen
91:41 - we hit the block it thought that we were
91:43 - hitting it like the top of the block so
91:45 - it put us on the top of the block
91:46 - because that's what this line does right
91:48 - here so in our horizontal Collision we
91:51 - essentially need to check okay by moving
91:54 - in this direction are you going to hit
91:55 - the block if you are going to hit the
91:57 - block we want to prevent you from moving
91:59 - in that direction so that you don't
92:02 - hit it collide with it and then we like
92:04 - spawn to the top of it
92:05 - so let me write it and I'll explain to
92:07 - you how it works but it's just very
92:09 - important that we check the horizontal
92:10 - Collision first then once we check that
92:13 - we check the vertical Collision because
92:15 - we only want to check vertical Collision
92:17 - if we are not colliding with a block
92:19 - horizontally
92:21 - or if we haven't already handled or if
92:23 - we have already handled the horizontal
92:25 - Collision again the idea is we don't
92:27 - want to be thinking that we're hitting
92:29 - the block on the top when really we hit
92:31 - it on the left or the right side so we
92:33 - got to check that first
92:34 - so I'm going to make a function I'm
92:35 - going to say define collide
92:37 - I'm going to take player objects a
92:41 - displacement X like that now I'm going
92:44 - to say player.move
92:46 - and I'm going to move my player in the
92:48 - displacement X Direction and 0 in the y
92:51 - direction the reason I'm doing this is I
92:53 - want to check if with the current
92:55 - velocity that my player has
92:57 - if
92:58 - now the reason I'm doing this is I want
93:00 - to check if my player were to move to
93:03 - the right or if they were to move to the
93:04 - left would they hit a block that's
93:06 - that's what I'm checking essentially by
93:08 - moving the player preemptively
93:10 - so now what I need to do is say
93:12 - player.update now the reason I need to
93:14 - call that update and let's go here to
93:16 - dot update is because I need to update
93:17 - the rectangle in The Mask before I check
93:19 - for Collision so again what I'm doing is
93:22 - I'm preemptively moving my player to
93:23 - where they would be moving if they're
93:25 - going left or right I'm updating their
93:27 - mask and their rectangle and then I'm
93:29 - going to say four object
93:32 - in objects if pygame dot Sprite dot
93:37 - Collide mask
93:39 - and then I'm passing my player
93:42 - and my object so this is why I needed to
93:44 - update my mask and my rectangle so I
93:46 - move my player I update it and then
93:48 - using that updated mask I check would I
93:50 - be colliding with an object now I'm
93:53 - going to say
93:54 - collided
93:55 - object
93:57 - is equal to none
94:00 - I've got to spell collided correctly
94:02 - if I am then I'm going to say collided
94:05 - and this is just going to be object
94:09 - is equal to obj
94:12 - then I'm going to break okay then I'm
94:14 - going to say player.move and I'm going
94:17 - to move them back
94:19 - and then I'm going to say
94:21 - player.update
94:24 - okay and then I'm going to return the
94:26 - collided object
94:28 - okay so what I'm doing right I'm moving
94:30 - my player I'm updating the mask I'm
94:32 - checking if they would collide with
94:34 - something if they were to move in that
94:35 - direction then if they did okay I get
94:38 - that Clyde object it doesn't matter if
94:40 - they do or they don't after I check this
94:41 - Collision I have to move them back to
94:43 - where they originally were so I have to
94:45 - reverse the movement
94:47 - and then update the mask again
94:49 - then a return collided object
94:51 - okay again moving checking if we hit
94:54 - anything either way moving back to where
94:56 - we were before this is preemptively
94:58 - tracking before we allow them to move
94:59 - into a block
95:01 - all right now what we need to do is use
95:03 - this function uh to allow us to move
95:07 - left or right or to disallow us from
95:09 - moving left or right so I'm going to say
95:10 - Collide underscore left is equal to
95:12 - collide
95:14 - player objects and then negative player
95:18 - Vel then I'm going to say Collide
95:20 - underscore right is equal to collide
95:24 - player objects and then player and then
95:29 - I'm going to say and not Collide left
95:33 - and not Collide right
95:36 - again what we're doing here is we're
95:38 - checking if we should be able to move
95:40 - left or if we should be able to move
95:41 - right uh based on our current position
95:43 - that's why I make that preemptive
95:45 - movement and then here I only let you
95:47 - make the movement if that movement does
95:49 - not cause you moving into a block or
95:51 - colliding with one
95:53 - now that we have that that should
95:54 - actually handle our horizontal Collision
95:57 - that's actually all we need
95:58 - all right so let me run this code and
96:01 - let's see so I'm here okay obviously
96:03 - that's still working and you can see
96:05 - that I can't go through the block now
96:07 - let's go here and actually I'm getting a
96:10 - bit of a bug on the right side okay so
96:12 - that time it worked but it's a little
96:14 - bit glitchy and I have a feeling it has
96:16 - to do with the animation count of me
96:19 - running because it's only sometimes when
96:21 - I'm running and I hit the block that it
96:23 - spawns me up here so I'm just going to
96:25 - do another little hack here and I'm just
96:28 - going to multiply this by two both of
96:30 - them here the reason for this being that
96:33 - I'll just make it so there's a little
96:34 - bit of space between the block
96:36 - and that way me changing the Sprite
96:39 - isn't going to affect if I collide with
96:41 - the object or not because remember the
96:43 - Sprites kind of shift to the left or to
96:45 - the right a little bit so just by adding
96:46 - this multiplied by two it should make it
96:49 - so that I'm never going to be colliding
96:51 - left or right it will make it so as a
96:52 - bit of space see how there's a bit of
96:53 - space between the block now but that's
96:55 - okay because now I'm never going to have
96:57 - that Collision bug
96:59 - um where it's going to spawn me to the
97:01 - top
97:01 - and really you could probably just add
97:03 - one or two pixels but you can see that
97:05 - that kind of fixed it right there
97:07 - okay so now we have collision with
97:09 - blocks we have a scrolling background we
97:12 - have double jumping
97:13 - I think that the last thing that we need
97:17 - to add here is the fire thing right kind
97:20 - of that trap where you hit it and you
97:21 - kind of Flash and then once we've done
97:23 - that will pretty much be done the
97:24 - tutorial
97:28 - all right so let's write our class for
97:30 - representing our fire
97:33 - so I'm going to say class fire this is
97:36 - going to inherit from object as well and
97:39 - this is going to be animated right we're
97:41 - going to have animated fire
97:42 - so this will take a bit more work but I
97:44 - think it'll be worth it it looks pretty
97:45 - cool on the screen
97:46 - so I'm going to take X Y width and
97:49 - height
97:50 - and then I'm going to call my super
97:52 - initializer so super
97:55 - dot underscore squared knit self x y
98:00 - with
98:01 - and height
98:03 - okay and then for the name of this I'm
98:05 - actually going to call it fire remember
98:06 - that we can pass a name the reason I'm
98:08 - adding a name to the object is so that I
98:10 - can determine when I collide with the
98:12 - object if it's fire and if it's fire
98:14 - then I want to do something right
98:16 - okay so for self.fire I'm going to use
98:18 - our load Sprite sheets function for
98:20 - directory one this is going to be traps
98:22 - and for directory two this is going to
98:25 - be fire
98:26 - now if we go here to trops you can see
98:28 - that fire is one of our traps so we have
98:30 - hit off on okay now there's also a bunch
98:34 - of other traps right so you can you can
98:36 - pick a different trap if you want like
98:37 - you could pass this blink one or
98:39 - whatever the thing with these ones is
98:40 - that they have uh some more animations
98:43 - so there's a bit more logic you need to
98:44 - handle for them so that's why I'm going
98:46 - with fire because it's a pretty simple
98:47 - one to do
98:48 - now up here for fire I'm again gonna
98:50 - have my animation delay so let's make
98:54 - that equal three
98:56 - and now let's specify our image so let's
98:58 - say ourself.image is going to be
99:00 - self.fire
99:02 - off we're going to start with it off
99:04 - and then zero okay then I'm going to say
99:08 - self.mask is equal to pygame dot mask
99:12 - Dot from surface self Dot
99:15 - image like that
99:17 - okay then I need to set an animation
99:19 - count so I'm going to say my animation
99:21 - underscore count is equal to zero just
99:24 - like we did for our player and I need to
99:26 - set myself dot animation underscore name
99:29 - which for now is going to be equal to
99:31 - off
99:32 - okay now I'm going to make a few
99:34 - functions my first function is going to
99:36 - be on or my first method and I'm going
99:37 - to say self dot animation name is equal
99:40 - to on if we look at fire we see we have
99:43 - hit off on we're not going to use hit
99:45 - we're just going to use off and on
99:47 - okay now we're going to have off
99:51 - self.animation name
99:53 - is equal to off okay and then we'll have
99:58 - our Loop we'll say Define Loop self and
100:01 - inside of our loop we're going to do a
100:02 - very similar thing to what we did inside
100:04 - of our player Loop in fact so similar
100:07 - that I can copy pretty much all of this
100:09 - right here so let's copy all that
100:12 - and let's paste that here now for update
100:16 - rather than actually just calling an
100:18 - update method we'll just copy
100:21 - the stuff from the update method here
100:22 - and just paste it down
100:24 - okay and rather than self.sprite
100:27 - we're going to change this to image and
100:30 - I actually think that once we remove the
100:32 - direction here this is all that we need
100:35 - for our um
100:39 - all right so now we just need to make a
100:41 - few changes we're going to get rid of
100:42 - this Sprite sheet name and rather than
100:44 - Sprite sheet name we're going to say
100:45 - self dot animation name
100:49 - and now we should actually be good to
100:52 - just use this so let me space this out a
100:54 - bit we get our Sprites okay this isn't
100:58 - going to be self that Sprites no it's
100:59 - not gonna be self-destrates it's gonna
101:01 - be self.fire which is this okay really I
101:04 - probably should call this something else
101:05 - but
101:06 - fire is going to represent all of our
101:08 - fire images okay so I'm using this to
101:11 - get my different animations
101:13 - I'm getting the animation name that I'm
101:15 - currently playing so either on or off
101:16 - and then I'm saying my Sprite index is
101:19 - equal to self.animation count
101:21 - divided by the self.animation delay mod
101:24 - the line of Sprites same as what we had
101:27 - before my image is equal to Sprites at
101:28 - Sprite index and then I increment the
101:30 - animation count update my rectangle and
101:32 - update my mask which is important for
101:34 - the collision and I'm good now last
101:37 - thing I want to do here
101:39 - is I want to just check if my self dot
101:41 - animation count is greater than actually
101:45 - if this divided by myself dot animation
101:48 - delay is greater than the line of
101:50 - Sprites
101:52 - now the reason I want to do this is so
101:54 - that my animation count doesn't get too
101:56 - large now you'll notice in my player
101:58 - class I actually didn't do this now that
102:00 - was intentional because if you do this
102:02 - then it kind of messes up how the double
102:04 - jump works you can do it if you want but
102:06 - you'll see that it kind of messes with
102:07 - things and with our player we're
102:10 - constantly resetting the animation
102:12 - account when we jump or when we go left
102:13 - or when we go right so that value
102:15 - doesn't really get too large but here
102:17 - for our fire since it's just static like
102:19 - it's just sitting forever what will
102:21 - happen is the animation count if we
102:22 - never change it back to zero we'll get
102:24 - to an extremely large number which can
102:26 - kind of lag our program so what I want
102:28 - to do is just make it smaller right so
102:30 - if it goes beyond what the actual
102:33 - animation
102:34 - um what do you call this is the line of
102:36 - the Sprites are then I want to set this
102:38 - to zero it's important I divide it by
102:40 - the animation delay though because if
102:41 - I'm dividing it here I need to divide it
102:43 - here before I set it back to zero
102:46 - okay so now we have fire I think that's
102:48 - actually all we need for fire so now we
102:49 - just need to add it to our objects so
102:51 - let's create it let's say
102:55 - fire it's equal to Fire and what do we
102:57 - need to pass for fire we need X Y width
102:59 - and height so we can pick where we want
103:02 - to put this
103:04 - um where do I want to put my X and Y
103:07 - okay for now let's go 100 and let's go
103:11 - height minus the block size and then I
103:15 - don't know how tall my fire is going to
103:17 - be I've got to see how big I want to
103:19 - make this let's make it say 64.
103:23 - and then we'll go 32 64 here
103:27 - okay so if we look at fire
103:29 - let's quickly have a look here and go to
103:31 - off for example or on
103:34 - the size of this is 32 by 64. okay
103:38 - that's what the size is and you need to
103:40 - pass that uh correctly to the fire class
103:43 - otherwise it won't load the image
103:44 - properly
103:45 - so we take our height minus our block
103:48 - size minus 64 which will put us on top
103:51 - of a block
103:52 - now I will put this at yeah 100 is fine
103:54 - for now for the X and yeah 32 with 64
103:58 - height there we go we have our fire now
104:01 - I'm just going to say fire.on I'm just
104:02 - going to turn it on we'll just leave it
104:04 - on forever uh you can turn off
104:05 - programmatically if you want and then
104:07 - inside of objects I'll just place my
104:09 - fire
104:10 - now that I've done that it should just
104:12 - show up on the screen when I run my code
104:15 - so I got an issue let's see what the bug
104:16 - is here of course the output is not
104:19 - showing up correctly it says and it
104:20 - takes
104:21 - from five to six positional arguments
104:24 - where seven were given
104:26 - uh okay
104:28 - I see the issue here
104:30 - let's go back to our
104:32 - fire and we don't want to pass self
104:35 - let's remove self okay let's run this
104:39 - uh list index out of range self.fire off
104:41 - zero
104:43 - hmm okay I'm wondering why that's giving
104:46 - us an issue we have off here so that
104:48 - should have been okay so let's go here
104:51 - and let's print self.fire and let's see
104:55 - why it's giving us this uh this bug here
104:57 - all right so I've determined the issue
105:00 - and the issue is that I passed the
105:01 - incorrect size here it's actually 16 by
105:04 - 32. so I was passing too large of a size
105:07 - and that's why it wasn't giving us the
105:08 - correct number of images so let's change
105:10 - this now and run and now we should be
105:13 - okay and there we go now we have fire uh
105:16 - but however it is off now the reason
105:17 - it's off is because we didn't call the
105:20 - loop method on fire so let's fix that I
105:23 - can also get rid of the print statement
105:24 - that I put here that I don't need
105:26 - anymore
105:27 - okay so let's go down to Main and where
105:31 - we have player.loop let's call fire.loop
105:34 - and is asking for the FPS
105:36 - I don't know if I took that in my Loop
105:39 - here
105:41 - no I don't need the FPS for that so
105:43 - let's get rid of that
105:44 - okay now let's call it and it should
105:46 - start being on
105:48 - uh fire object has not shoot Sprite okay
105:51 - let's go fix that error my apologies
105:55 - fire we have Sprite somewhere here that
105:57 - we don't want self.sprite there's gonna
105:58 - be self Dot image and self Dot
106:02 - image all right start with that let's
106:05 - run it now
106:07 - and there we go we now have a moving
106:09 - fire and notice that
106:11 - I can kind of be on top of the fire
106:13 - right so I can collide with it and it's
106:15 - like Pixel Perfect Collision pretty much
106:17 - when I'm hitting it
106:20 - so now the last thing we need is to just
106:22 - make it so we go into that kind of hit
106:24 - State when we do hit the fire that's
106:26 - actually pretty easy to do we just need
106:28 - to add a kind of state to our player to
106:31 - know if we're hit or not so we're going
106:32 - to say self.hit is equal to false
106:36 - we also want to hit count
106:39 - because we're going to only be flashing
106:41 - for a certain amount of time then we're
106:43 - going to have a method here to find
106:46 - hit
106:47 - self
106:49 - .hit equals true
106:53 - and self.hit count
106:55 - is equal to zero then we're going to go
106:58 - in Loop and before our update Sprite
107:01 - we're going to say if
107:03 - self dot hit
107:04 - then self dot hit count
107:08 - plus equals one and then we're going to
107:10 - say if self dot hit count is greater
107:14 - than and we can just pick some value but
107:17 - let's say FPS multiplied by two which is
107:19 - going to be two seconds then the self
107:22 - dot hit
107:24 - is equal to false
107:26 - then we go here into our update Sprite
107:29 - and we say
107:30 - actually at the top here if self.hit
107:35 - it's important you put this at the top
107:36 - by the way so make sure you put it here
107:38 - then we are going to say the Sprite
107:41 - sheet is equal to
107:44 - hit
107:45 - great then we want to now determine if
107:48 - we actually got hit so we do that from
107:50 - our Collision functions which are going
107:54 - to be here
107:55 - all right so we have Collide left we
107:58 - have Collide right and we're going to
107:59 - have
108:00 - vertical
108:03 - collide
108:04 - now what we're going to do is we're
108:06 - essentially going to Loop through all of
108:08 - these objects and we're going to see if
108:11 - we hit fire now the way we'll know if we
108:13 - hit fire is by looking at all the
108:15 - objects that were returned here and it
108:17 - will tell us well if if we hit fire or
108:19 - not right it's because we can look at
108:21 - the name of the object and if the name
108:22 - of the object is fire then we know we
108:24 - hit fire so I'm going to say
108:27 - to check is equal to collide left
108:32 - Collide right and asterisk vertical
108:34 - Collide now I realize that inside of
108:36 - here I only returned one object whereas
108:39 - inside of here I returned all the
108:40 - objects I was colliding with vertically
108:42 - really we should probably be returning
108:44 - all of them from here as well but I
108:46 - think this is still going to work so
108:47 - we'll just leave it how it is for right
108:49 - now so I'm going to say 4 obj into
108:52 - underscore check these are all the
108:54 - objects we collided with remember I'm
108:56 - going to say if to underscore check
108:59 - and to underscore check Dot name
109:04 - is equal to fire then player.hit
109:09 - is able to trip
109:10 - okay
109:12 - that is all we need actually I'm going
109:13 - to say player.hit I want to call the
109:15 - method I don't want to set it equal to
109:16 - true so what we're doing here is looking
109:18 - through all the objects we collided with
109:19 - if any of them are fire then we will put
109:22 - hit on the player the reason I'm doing
109:24 - this first if to check is because these
109:27 - could be none right we could have no
109:29 - objects we collided with so I need to
109:30 - make sure I handle that case before I
109:32 - try to access name on an object that
109:34 - isn't defined
109:35 - all right let's run the code and let's
109:37 - see
109:38 - and player has no object no attribute
109:40 - hit count okay so let's go to player
109:45 - and let's go to hit count
109:47 - and let's make that equal to zero I
109:48 - guess I forgot to assign that all right
109:50 - let's try this now uh list object has no
109:52 - attribute name okay
109:55 - interesting
109:57 - uh let's see here
110:01 - okay all right so I'm using two check
110:03 - when I need to be checking obj
110:06 - so let's fix that and run the code
110:11 - Bool object is not callable okay
110:13 - player.hits aha so let's call this make
110:17 - hit
110:18 - it's because I have an attribute with
110:20 - the same name as my method so it's
110:22 - accessing the attribute when it should
110:24 - be accessing the method so I'm just
110:25 - going to say make underscore hit and now
110:27 - that should fix the problem for us
110:30 - run the code and there we go now it
110:34 - looks like I'm always being hit right
110:36 - now
110:37 - that of course is a bug
110:40 - so hit is equal to false
110:42 - let's check our hit count it's because
110:45 - if self.it so if the hit count plus
110:47 - equals one if self-doh hit count is
110:49 - greater than
110:51 - self.he equals false
110:53 - maybe we need to reset our hit count as
110:55 - well
110:56 - okay and there's probably a bug
111:01 - here let's scroll down
111:04 - keep scrolling
111:06 - with our fire so we have to check if obj
111:10 - and obj and a name equals equals fire
111:12 - player.make hit
111:14 - okay
111:16 - I'm not sure what the bug is let me run
111:18 - this again
111:20 - and yeah it seems like we start out in
111:22 - the hit state so maybe it's an issue in
111:25 - here
111:27 - let's have a look here if self dot hit
111:31 - spreadsheet equals hit but we are we hit
111:34 - right away for some reason it's making
111:37 - us hit immediately okay let me have a
111:39 - look here guys and I'll be right back
111:40 - alright so I've realized I made a silly
111:42 - mistake here I actually had this
111:44 - collided objects append outside of this
111:47 - if statement that was causing all kinds
111:49 - of bugs and issues for me I think I was
111:51 - doing some print debugging so let me get
111:53 - rid of that here uh anyways I just moved
111:55 - it back now so that it's in the correct
111:57 - location so now if I re-run this
112:00 - now we should see that
112:02 - when I hit the fire it puts me into kind
112:04 - of this hit State last two seconds and
112:07 - then it ends
112:08 - all right so with that said guys I think
112:11 - that's pretty much gonna wrap up this
112:12 - video
112:13 - this showed you how to create a
112:15 - platformer how to do animations how to
112:17 - do Sprites how to do a scrolling
112:19 - background obviously there's a ton of
112:21 - stuff that can be added to this game but
112:23 - I really want to leave that to you
112:24 - obviously I could spend hours days
112:27 - months working on a game like this but I
112:29 - think this is a solid enough base to
112:31 - really give you guys a good foundation
112:33 - to go out there and create something
112:34 - pretty cool obviously there's all kinds
112:36 - of assets that I will leave in the
112:38 - GitHub that you can use I have all kinds
112:40 - of other Pi game tutorials that you may
112:42 - want to reference if you want to learn
112:44 - about menus sound effects
112:46 - um points scoring all of that kind of
112:49 - stuff you guys just go on my channel
112:51 - search Pi game tutorial you will see a
112:53 - bunch of them those will show you how to
112:55 - do a ton of other things that you know
112:57 - you may want to add to this game so I
112:59 - hope you guys enjoyed this this was a
113:01 - ton of work as always the code will be
113:03 - in the description if you did enjoy make
113:05 - sure to leave a like subscribe to the
113:07 - channel consider supporting me by
113:09 - purchasing something like programming
113:10 - expert I hope to see you in another
113:12 - YouTube video