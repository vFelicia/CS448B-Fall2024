00:00 - hello everybody and welcome to the third
00:02 - video in this series where we will start
00:04 - actually working on our project and
00:06 - building out part of the back end now as
00:08 - a reminder the project we're going to be
00:10 - building is a rock paper scissors
00:12 - challenge application what I want to do
00:14 - right now is just hop over to the
00:16 - Blackboard whiteboard drawing tablet
00:17 - whatever you want to call it and give
00:19 - you a little bit of a highle overview of
00:21 - the project architecture just so that as
00:23 - we start going through the code you have
00:24 - a better sense of exactly what it is
00:26 - that we want to do now let's just start
00:29 - with the kind of a objective of the
00:30 - project we're going to have two players
00:32 - or potentially multiple players but for
00:34 - now we can just stay with two and these
00:37 - players want to play Rock Paper Scissors
00:39 - against each other now one player needs
00:41 - to initiate something called a challenge
00:44 - well that's what we'll call it so I'll
00:45 - just represent that with C the other
00:47 - player then needs to accept the
00:48 - challenge and then these two players
00:50 - need to reveal what it is that their
00:52 - answer is right so whether rock paper or
00:55 - scissors now the challenging part comes
00:57 - in making sure that one player does not
00:59 - have an advantage over the other player
01:02 - when they reveal these answers so just
01:03 - quickly recap player one which could be
01:06 - this guy creates some kind of Challenge
01:08 - and then player two who we can call this
01:10 - guy will accept the challenge so we have
01:13 - challenge created challenge accepted now
01:16 - once the challenge has been created and
01:18 - it's been accepted by another player at
01:20 - this point both players should have
01:22 - already submitted what it is that they
01:24 - want their answer to be so in this case
01:26 - maybe this guy does rock and this guy
01:28 - does scissors now if that's the case we
01:31 - know that player one is going to win the
01:32 - issue is though if player one were to
01:35 - create the challenge and submit Rock
01:37 - immediately and we were to just store
01:39 - that normally on the blockchain player 2
01:41 - would always be able to win by looking
01:44 - at what is stored on the blockchain for
01:46 - this particular challenge remember that
01:49 - any data we put on the blockchain is
01:51 - completely visible and transparent to
01:53 - anyone so we need to do this in a little
01:55 - bit of a different way so I'm just going
01:57 - to walk through how that process is
01:58 - going to work and this is going to
01:59 - really inform how we go about writing
02:01 - this backend which I won't lie to you is
02:03 - a little bit complex but it's all kind
02:05 - of part of the tutorial to show you how
02:07 - this works so the basic idea is that we
02:09 - need both player one and player two to
02:12 - make a commitment to a specific decision
02:15 - so whether rock paper or scissors
02:18 - however we don't want that commitment to
02:20 - be revealed to the other player so what
02:22 - we're going to do is use a little bit of
02:24 - a hashing technique which is very
02:26 - popular in cryptography let's say player
02:29 - one decides that they want to choose
02:31 - Rock now they're the ones that are
02:33 - actually creating this challenge so I
02:35 - say okay I'm going to create a challenge
02:36 - I want my decision to be Rock so what
02:40 - they're going to do is with this rock
02:42 - decision here they're actually going to
02:45 - append to this a secret code or
02:47 - something that we refer to as a Nots now
02:51 - a not is just some kind of random number
02:53 - we could say that this number is
02:54 - something like
02:56 - 173 now this secret number right here
02:59 - the the player is going to store they're
03:01 - going to keep track of and it's kind of
03:02 - like their password now what they're
03:04 - going to do is they're going to take
03:05 - this whole value so whatever their
03:07 - decision is in this case it's rock plus
03:09 - some random number and they're going to
03:11 - pass it through something known as a
03:13 - hash function now what the hash function
03:15 - is going to do is it's going to spit out
03:17 - some random value that we don't know how
03:21 - it was generated so we're essentially
03:23 - going to get this kind of random string
03:25 - and this random string is essentially
03:27 - the encoding of the their choice and
03:30 - their random number now just to simplify
03:34 - this quickly the only way that we'll be
03:37 - able to get this same random number is
03:40 - if we were to pass in this exact input
03:43 - that we have in the hash function so
03:45 - what that means is that this kind of
03:47 - value right here so their choice plus
03:50 - their random number is the only possible
03:52 - input that's going to lead to this
03:54 - output we'll talk more about this in
03:56 - depth in one second now the idea is
03:58 - we're going to store this value on the
04:00 - blockchain which is the hash of their
04:02 - choice and their random number otherwise
04:05 - known as their password so we take this
04:07 - value and we store this on the
04:09 - blockchain now that that's stored on the
04:11 - blockchain they've effectively committed
04:13 - that this is their choice Rock however
04:16 - they have not revealed that choice to
04:18 - player two because all player two is
04:20 - going to see is this hash so now what
04:23 - will happen is player two will do the
04:24 - exact same thing they'll have some
04:25 - decision maybe they go ahead and say
04:27 - okay I want this to be Rock and then
04:30 - they choose some random number something
04:32 - like
04:33 - 373 now same thing here they store their
04:35 - random number over here obviously these
04:37 - numbers would be much larger we're just
04:38 - using small ones for now they generate a
04:41 - completely different hash so maybe
04:43 - something like a b C1 2 three just a
04:46 - random example and then they submit this
04:49 - hash to the blockchain at this point in
04:51 - time both players have stored their
04:53 - secret password and they've made what
04:55 - we're going to call a commitment which
04:57 - is associated with this challenge now
04:59 - that these commitments are on the
05:01 - blockchain they've effectively locked in
05:03 - their answer but neither player knows
05:05 - what the other player's answer was
05:07 - because they don't have access to this
05:09 - secret code so now what we're going to
05:12 - do is once both players have submitted
05:14 - their values so let's just imagine we
05:16 - have kind of a check mark here and a
05:18 - check mark here indicating that we've
05:20 - made the decision from player one and
05:21 - we've made the decision from player two
05:23 - each player in turn or in whatever order
05:25 - they want is going to reveal their
05:27 - answer now the way they'll reveal their
05:29 - answer is actually by doing the opposite
05:32 - of what they did when they committed to
05:33 - it what that means is they're going to
05:36 - take their secret code so value like 173
05:39 - and they're going to take their decision
05:40 - so I think this player I forget what we
05:42 - did but let's say it was scissors
05:43 - doesn't really matter okay they're going
05:45 - to take these two values and they're
05:47 - actually going to submit these to the
05:48 - blockchain now what's going to happen is
05:50 - on the back end we're going to take the
05:53 - hash of these two values and we're going
05:56 - to check to make sure it matches what
05:58 - they sent us before so we're going to
06:00 - say okay we've got some string that
06:03 - we've stored which is your commitment
06:04 - which is the hash of your decision now
06:07 - that both players have made their
06:08 - decision we're going to take the hash of
06:11 - whatever you tell us your decision
06:12 - actually was and your secret number and
06:15 - we're going to see if that matches the
06:16 - hash that we stored if it did that means
06:19 - that you have now revealed your answer
06:21 - because you've actually submitted this
06:23 - data to the blockchain which is your
06:25 - answer and we verified that this answer
06:27 - is the same as what you originally shows
06:30 - again I'm going to elaborate more on
06:31 - this but that's the basic idea now both
06:33 - players are going to do that and when
06:34 - both players do that that will
06:36 - effectively reveal their answer again I
06:37 - forget what we did but let's say this
06:39 - guy was scissors and this guy was Rock
06:41 - then we know rock wins so it's a
06:43 - two-step process they start by
06:46 - committing what their answer will be and
06:48 - kind of hiding this secret code which
06:50 - would allow us to reveal their answer
06:52 - once both players have made this
06:54 - commitment now it is safe to reveal the
06:56 - answer because these players can't
06:58 - change their commitment they can only
07:00 - essentially reveal what it was so now we
07:03 - go through the reveal process and what
07:05 - we do is we actually submit both of
07:07 - these values to the blockchain where
07:09 - it's then verified and we say okay this
07:12 - was the same as what you originally told
07:13 - us so now we're going to Mark the player
07:15 - one chose scissors same thing here with
07:18 - player two we take the values so rock
07:20 - and 373 we submit those to the
07:23 - blockchain we make sure this matches
07:25 - what they originally submitted by
07:26 - checking the hashes of these values and
07:28 - since it does match we say we have
07:30 - scissors versus Rock and well we know
07:33 - rock wins I'm hoping this makes a little
07:36 - bit of sense but this is how we do a
07:38 - little bit of kind of security on the
07:40 - blockchain and how we can reveal answers
07:42 - and store data without actually
07:44 - revealing what the answer is on the
07:46 - blockchain before we want to reveal it
07:49 - again the reason we need to do this is
07:51 - we can't have one player submit their
07:53 - answer before the other player because
07:55 - if they do that then we're going to know
07:57 - what their answer is and we can always
07:59 - win so what we do instead is we submit a
08:02 - kind of a secret string that has our
08:04 - answer encoded inside of it but that we
08:06 - can only reveal once both players have
08:10 - submitted that secret string so we have
08:12 - kind of secret string one right so here
08:15 - and secret string 2 and then once these
08:17 - are both submitted now the players will
08:20 - tell us what their secret string was and
08:22 - we'll be able to verify that what
08:23 - they're telling us is actually what it
08:25 - was so both players have decided without
08:28 - seeing the other players answer and now
08:30 - they will reveal their answers and we
08:32 - can end the game okay that's the
08:35 - architecture here now what that means is
08:37 - that we're going to have a little bit of
08:39 - logic that obviously can do this hashing
08:40 - from both the front end and the back end
08:42 - and each player just needs to store
08:44 - their secret token for each challenge
08:46 - that they're participating in we'll go
08:48 - through all of this and it will make a
08:49 - lot more sense but that is the security
08:52 - implementation for this project which I
08:54 - actually think is quite cool and shows
08:56 - you quite a lot about how we can make
08:58 - some more advanced systems so let's hop
09:00 - over to the computer now start coding
09:02 - some stuff out we'll work mostly on the
09:04 - back end then in future videos we'll
09:06 - handle the front end and do all of the
09:08 - interactivity all right so we're back on
09:09 - the computer now and what we're going to
09:11 - do is just set up a new folder where
09:12 - we're going to do all of our work from
09:14 - so I just have opened the same directory
09:16 - that we set up in the previous video
09:18 - which is the rollups example now we're
09:20 - going to work inside of here just to
09:21 - make our life a bit easier so I'm going
09:23 - to open up my WSL terminal notice that
09:26 - inside of this terminal I am inside of
09:28 - the rollups example directory what I'm
09:30 - going to do is I'm simply going to copy
09:32 - the ERC or sorry the echo python
09:35 - directory and I'm just going to make a
09:37 - new directory with a different name and
09:39 - we'll start working inside of there for
09:40 - our project so what we can do here is CP
09:44 - hyphen R which stands for recursive and
09:47 - then Echo dpth and then the directory we
09:50 - want to call this so I'm going to say
09:52 - rock paper scissors like that and then
09:54 - I'm going to put a slash and go ahead
09:56 - and hit enter now if I type l plus we
09:59 - should see that we have a rock paper
10:00 - scissors directory so now we can CD into
10:03 - rock paper scissors and we can go ahead
10:05 - and build this application now to do
10:08 - that let me just pop open my guide again
10:12 - I always keep this open whenever I'm
10:13 - working just so I have all of the
10:15 - commands so notice I'm inside of the
10:17 - rups example and I'm inside of the new
10:19 - directory we just copied which is rock
10:21 - paper scissors and what I'll do now is
10:23 - I'll just take this command and I will
10:25 - paste it in here and I will build all of
10:27 - the docker containers and
10:30 - images okay that is built now if I want
10:33 - I can go ahead and start my local node
10:34 - I'm not going to do that this second
10:36 - because we don't need this started right
10:37 - away but that's the basic idea okay so
10:40 - let's close that up and now if we go
10:42 - here we should see that we have a rock
10:44 - paper scissors directory and we've got a
10:46 - few files okay so we have echo. py uh we
10:50 - have pretty much everything that was
10:51 - inside of the other directory what I'm
10:55 - going to do is go to echo. and I'm just
10:57 - going to rename this file to main.py
11:00 - just cuz I'd prefer it to be called main
11:02 - I think that makes a bit more sense I'm
11:04 - then going to go into the docker file
11:06 - and actually says copy dot dot okay
11:08 - that's good so we'll just leave that as
11:10 - it is I thought we were going to need to
11:11 - change that so fortunately we don't need
11:12 - to change that okay we have main.py we
11:15 - can kind of leave this as is I'm just
11:16 - going to get rid of this huge header
11:17 - comment so it doesn't block up our code
11:20 - and we're actually going to make a new
11:21 - python file now this new python file is
11:24 - going to be called challenge. piy and I
11:27 - want to begin by coding out a few
11:28 - different class classes that are going
11:29 - to help us with the implementation of
11:31 - our back end now these are just normal
11:33 - python classes there nothing crazy going
11:35 - on here and once we have this we'll then
11:37 - go back and kind of code the caresi
11:39 - components which will make this a bit
11:41 - more clear so I'm going to go to the top
11:43 - of my program and I'm going to import
11:44 - hash lip now we're going to use this
11:46 - just for the hashing operation that I
11:48 - talked about previously don't worry when
11:50 - we get to that point I'll slow down a
11:51 - lot and explain it to you we're also
11:53 - going to import time like this actually
11:56 - don't remember if we need time or not uh
11:58 - actually I don't think we do for what
11:59 - I'm going to do here so I'll leave that
12:01 - and I'm going to create a few classes
12:03 - now the first class is going to be
12:04 - called move now this is going to
12:06 - represent uh all of our different rock
12:08 - paper scissors moves now we want to just
12:10 - use integers to represent them rather
12:12 - than strings so I'm going to type none
12:14 - is equal to zero I'm going to type rock
12:17 - is equal to 1 paper is equal to two and
12:20 - scissors is equal to 3 just so we have
12:22 - an encoding for our different moves so
12:24 - we're saying if we don't have a move
12:25 - we'll just encode that with zero if we
12:27 - chose rock paper or scissors that'll be
12:29 - 1 two or three respectively next I'm
12:32 - going to create an initialization here
12:34 - so I'm going to say Define a nit I'm
12:36 - going to take in self I'm going to take
12:37 - in a commitment and I'm going to say
12:39 - move is equal to Zer now what I'm going
12:43 - to do is just say self.
12:46 - Commitment if we can get the
12:48 - autocomplete going here is equal to comp
12:51 - commitment sorry and self. move is equal
12:55 - to move now the idea here is that we're
12:57 - just going to have a class that will
12:58 - store the commitment and the finalized
13:01 - move for each of our players uh
13:03 - participating in a challenge so the
13:05 - commitment is going to be the secret
13:08 - string right and the move itself will
13:10 - actually be what the move is from this
13:13 - commitment but remember when we first
13:15 - create the challenge and accept it we're
13:16 - just going to have the secret string and
13:18 - it's not until the players reveal their
13:20 - move that we're going to actually know
13:21 - what their move is okay and we're just
13:24 - going to create a class method here so
13:26 - we're going to say class method and this
13:28 - is going to be Define move uncore 2core
13:31 - string and we're going to take in our
13:33 - class and we're going to take in a move
13:36 - and what this is going to do is simply
13:38 - return the string version of the numeric
13:41 - move okay so we're going to say
13:43 - cs. none is associated with none we're
13:48 - going to say cs. Ro is associated with
13:52 - rock we're going to say cs.
13:56 - paper is associated with paper notice
13:59 - I'm creating a python dictionary here by
14:01 - the way you'll see why we want to do
14:02 - this in a second and then CLS do
14:05 - scissors is scissors I'm then going to
14:08 - put my index or in this case key
14:10 - operator and I'm going to put move now
14:13 - what this will do is it'll take in a
14:14 - numeric move that's between zero and
14:16 - three it will then look for the
14:17 - corresponding value associated with the
14:19 - key in the dictionary so I have none
14:21 - which is zero Rock which is one paper
14:23 - which is two scissors which is three
14:24 - associated with a string when I access
14:26 - the index this means we will return a
14:28 - string and sorry not index but key okay
14:31 - so that is our move class pretty
14:32 - straightforward now we're going to write
14:34 - the challenge
14:36 - class now this is where things get a bit
14:38 - more complicated but this is where it's
14:40 - nice to be working in a language like
14:41 - python because we don't need to know the
14:43 - corresponding solidity code to actually
14:45 - write the complex logic we need we can
14:47 - write it in Python which I imagine most
14:49 - of you are better at than solidity at
14:50 - least I know I am so inside of here
14:53 - we're going to create a knit as well and
14:55 - this challenge is what's going to store
14:56 - a lot of the information we need for an
14:57 - individual Rock paper scissors Challenge
15:00 - and keep in mind we can have multiple
15:01 - challenges which is why we're creating a
15:03 - class so that we can have different
15:05 - instances of challenges now the first
15:07 - thing we need when we create a challenge
15:09 - is the creator of this challenge we want
15:11 - to know their address so we know what
15:13 - player is playing against what other
15:14 - player we also going to want to have an
15:16 - ID for this challenge so we know what
15:18 - the identifier is and how we can access
15:20 - it we're then going to want to have the
15:22 - commitment of the Creator okay so
15:24 - whoever first creates the um challenge
15:27 - will submit a commit so that's kind of
15:29 - the Creator's
15:30 - commitment okay so instead of here we're
15:33 - going to say self. Creator address is
15:36 - equal to the Creator address of the
15:38 - challenge we're going to say self.
15:41 - opponent address is equal to none now
15:44 - just like we have the Creator we're
15:46 - going to have the opponent so we have
15:47 - like player one and player two I'm
15:48 - saying Creator would be player one
15:50 - opponent is player two when we first
15:52 - create a challenge it's open-ended we
15:53 - don't know who the opponent is going to
15:55 - be so we mark this as none we're then
15:57 - going to say self do commitments now
16:00 - this is going to be a dictionary that's
16:02 - going to store the commitments and
16:03 - really the moves for each of our players
16:06 - so right away we're going to say self.
16:09 - Creator address is going to be
16:10 - associated with a move which is the
16:13 - commitment from that player so what
16:15 - we're doing is saying okay we want to
16:17 - make a new challenge to make a new
16:19 - challenge we need the Creator address
16:20 - the ID of the challenge which we'll look
16:21 - at in a second and the commitment from
16:23 - the player who made that challenge we
16:25 - want to store all of these commitments
16:27 - so we can access them later so we make a
16:29 - dictionary we have the key which is
16:31 - equal to the address of the Creator or
16:34 - the address of whatever player it is in
16:36 - this Challenge and we associate that
16:38 - with an instance of this move class
16:40 - which will store for us not only the
16:41 - commitment but eventually what that
16:43 - player's finalized the move is so there
16:46 - we go we make self. commitments we're
16:48 - going to say self. ID is equal to
16:50 - underscore ID if you wonder why I did
16:52 - underscore id id is a reserved keyword
16:54 - in Python so it's better to use
16:56 - underscore before just to kind of get
16:58 - rid of that reserved keyword this of
17:00 - this
17:01 - variable okay lastly we're going to say
17:04 - self. winner address is equal to none
17:09 - and I remembered why we wanted time so
17:11 - I'm going to go back and import time
17:13 - here we're going to go here and say
17:16 - self. created at is equal to time.time
17:20 - just so we can store when this challenge
17:22 - was actually created okay so this is how
17:26 - we initialize a challenge we get the
17:28 - Creator we get an ID and we get some
17:30 - commitment now there's a few more steps
17:33 - we need to go through so once we have a
17:35 - challenge we need someone to be able to
17:36 - accept the challenge right so to accept
17:38 - the challenge we're going to add an
17:39 - opponent to the challenge so I'm going
17:41 - to make a method called add opponent and
17:45 - when we have that opponent we want the
17:46 - address of the that opponent and we want
17:48 - the commitment of that oppon opponent
17:50 - sorry when they accept the challenge so
17:53 - we take in the address and the
17:54 - commitment and we say self. opponent
17:56 - address is equal to the address address
17:58 - of our new opponent and we say self.
18:01 - commitments at the
18:04 - address is equal to a move and then we
18:08 - store what the player's commitment kind
18:10 - of secret string actually is so very
18:12 - similar to what we did up here but now
18:14 - we're just adding it into the
18:15 - commitments
18:17 - dictionary okay so here is where it gets
18:20 - a bit more complicated we are now going
18:23 - to write the function that will reveal a
18:26 - player's commitment okay let's go ahead
18:29 - and write this we're going to say define
18:30 - reveal and we're going to take in self
18:33 - address move and non now remember non is
18:37 - that secret number that the player is
18:39 - going to store on their client so
18:41 - they're going to store it themselves and
18:43 - they're only going to submit it once
18:45 - both players have um made their
18:48 - commitments right so once the challenge
18:49 - has been accepted essentially either
18:51 - player in any order can now reveal their
18:53 - move so what I'm going to do here is I'm
18:54 - just going to start by saying if not and
18:59 - this is going to be self. commitments
19:01 - doget and then self. opponent address
19:05 - then I want to raise an exception here
19:07 - so I'm going to say raise exception and
19:09 - I'm going to say a
19:11 - opponent has not committed now the
19:15 - reason I'm doing this is I just want to
19:16 - make sure that the player who created
19:18 - the challenge is not able to reveal
19:21 - their move until they have someone
19:23 - accept their Challenge and make that
19:25 - corresponding commitment so that's what
19:27 - I'm doing here just to make sure I'm
19:28 - checking that all right so now that we
19:29 - have that what we're going to do is we
19:31 - are actually going to generate a hash of
19:35 - the secret key and the move that the
19:38 - player has submitted and we're going to
19:40 - verify that that matches with their
19:42 - commitment string so to do this we're
19:45 - first going to have to write a function
19:47 - here so we're going to say Define
19:49 - generatore hash now this is going to be
19:52 - a static method because it doesn't
19:54 - belong to the instance it belongs to the
19:57 - class and and we are going to say for
20:00 - Generate hash that we are going to take
20:03 - some input and we are going to return
20:06 - the hashlib do
20:10 - sha256 and this is going to be the
20:13 - input. dcode sorry not decode
20:17 - Dot
20:19 - incode and thenex digest don't worry too
20:23 - much about exactly what this is doing
20:25 - but we're using the hashing algorithm
20:27 - known as Shaw 2 56 which is a very
20:29 - popular and common algorithm we are
20:31 - taking the input which is going to be
20:32 - some kind of string we are encoding that
20:35 - to a hexadecimal value and then we are
20:38 - getting the digest otherwise known as
20:40 - the hash from this function okay so that
20:43 - is what generate hash does now what
20:45 - we're going to do is we're going to say
20:47 - the reveal uncore hash is equal to
20:51 - challenge which is the name of our
20:52 - class. generate hash and we're going to
20:56 - take the Nots and we're going to add the
20:58 - move to it both these values Will Be
21:00 - Strings sory this I know I said it was a
21:02 - number you'll see why this will be a
21:03 - string in a second but either way
21:05 - they're going to be strings and if we
21:06 - wanted to really be sure we could
21:08 - convert this to a string or we could
21:10 - convert the move to a string it doesn't
21:11 - really matter anyways we're going to
21:14 - take the reveal hash here and we're
21:16 - going to say if the and we need to
21:19 - actually write this first we're going to
21:21 - say committed uncore move is equal to
21:24 - self. commitments doget and we going to
21:28 - get the commitment from this address and
21:31 - we are going to say if the committed
21:34 - move do commitment does not equal the
21:39 - reveal hash then that means they tried
21:41 - to reveal an answer that was not their
21:43 - original commitment so we're going to
21:44 - raise an exception and we're going to
21:46 - say that the move does not match the
21:52 - commitment okay so this is the main
21:54 - security thing right when they first
21:56 - create or accept the challenge we take
21:57 - in that secret string that secret string
22:00 - should be able to be generated by taking
22:02 - their secret number and their move and
22:05 - hashing it so now what we ask them to do
22:07 - is okay submit your secret number and
22:08 - sub submit your move when they submit
22:10 - both those values we take them and we
22:13 - hash them and if they equal what they
22:15 - originally submitted to us that means
22:17 - they submitted the correct answer if not
22:19 - that means they submitted something that
22:20 - was not their original commitment okay
22:24 - so now once they've revealed their
22:25 - answer we can say self. commitments
22:28 - address is equal to a move we're just
22:32 - going to say the committed move do
22:35 - commitment and actually now that I think
22:37 - about it we don't need to do it like
22:38 - this we can say self do commitments add
22:40 - address. move is equal to and this will
22:44 - be the int of the move that they
22:48 - submitted so again we verifi that this
22:51 - move is correct it's going to be 1
22:52 - through three so either 1 two or three
22:54 - but remember when we first create this
22:56 - move we don't actually instantiate this
22:58 - so it's equal to zero so now that
23:00 - they've revealed their move we store the
23:02 - move inside of the move class which
23:04 - essentially means everyone now will be
23:05 - able to see what that is okay then we
23:09 - can print something like reveal complete
23:13 - just so we have some logging so we'll be
23:14 - able to actually see that um in our
23:16 - output actually I don't think that's
23:18 - even going to log so for now I'm going
23:20 - to get rid of that I don't think we need
23:21 - that okay now that we have the reveal
23:25 - that's kind of the hard part but there's
23:26 - a few more methods that we want to run
23:28 - just to wrap this up so first of all I
23:30 - just want to have a method called both
23:33 - revealed now what this is going to do is
23:35 - simply just return if both players have
23:37 - revealed their move because we need uh
23:39 - both of them to reveal their move before
23:41 - we generate a winner for this game so
23:43 - we're going to say the opponent move is
23:45 - equal to self. commitments at the self.
23:48 - opponent address okay move and we're
23:52 - going to say the Creator
23:55 - move is equal to self. commitment at the
23:58 - self. Creator address. move and we are
24:02 - simply going to return the opponent move
24:07 - does not equal move. none and the
24:12 - Creator move does not equal move. none
24:16 - so all this is saying is okay both
24:18 - players have revealed their answer and
24:20 - we know that's the case if they don't
24:22 - have a move equal to none so that means
24:24 - they have a move right okay now we are
24:28 - going to write another one here which is
24:31 - Define
24:32 - has
24:34 - opponent
24:36 - committed and what we can actually do to
24:38 - check if the opponent has committed is
24:40 - exactly what we did up here so I'm just
24:43 - going to grab
24:45 - this and I am simply going to return
24:50 - that this does not equal none and then
24:53 - I'm going to use this function here so
24:55 - I'm going to say where is this
25:00 - if self. has opponent committed and
25:04 - we'll actually put the not here so if
25:06 - the opponent has not committed then
25:08 - we'll raise this exception I'm just
25:09 - making sure we don't have duplicated
25:10 - code by kind of fixing up some of these
25:11 - methods okay now lastly we're going to
25:14 - say
25:16 - Define evaluate uncore winner and this
25:20 - is going to take in self and what this
25:22 - is going to do is figure out who the
25:24 - winner of the game is okay so first of
25:28 - all let me copy this code here to get
25:31 - the opponent move and the Creator move
25:32 - because we're going to need that so what
25:34 - we need to check here is every possible
25:36 - winning case for rock paper scissors
25:38 - there's a few ways to do this but we can
25:40 - essentially write it in about six if
25:42 - statements bear with me here the first
25:44 - one is going to check if Rock beat
25:47 - scissors okay so we're going to say if
25:50 - the Creator move is equal to move. rock
25:54 - and the opponent move is equal to move.
25:59 - scissors then we can say the self.
26:02 - winner address is equal to the self.
26:05 - Creator address right because they
26:08 - won otherwise so L if the Creator move
26:12 - is equal to move. scissors and the
26:15 - opponent move is equal to you guessed it
26:18 - move. Ro then the self. winner address
26:21 - is equal to the self. opponent address
26:24 - because they chose Rock player chose
26:25 - scissors next we're going to check if
26:27 - scissors beat Paper so we're going to
26:30 - say else if the Creator move is equal to
26:35 - move. scissors and the opponent move if
26:41 - we can type this correctly is equal to
26:44 - move. paper then we're going to say the
26:47 - self. winner address is equal to the
26:51 - self. Creator
26:53 - address okay let's scroll up otherwise
26:57 - if the Creator move is equal to
27:00 - move. paper and the opponent move is
27:05 - equal to move. scissors then the self.
27:08 - winner address is equal to the self.
27:12 - opponent address okay last one this
27:16 - is
27:18 - paper beats
27:21 - Rock okay apparently I can't type that
27:24 - very well we're going to say l if the
27:26 - Creator move
27:28 - is equal to
27:29 - move. paper and the opponent move is
27:34 - equal to move. ro then the self. winner
27:38 - address is equal to the self. Creator
27:41 - address otherwise if the Creator move is
27:45 - equal to move. paper and the opponent
27:49 - move is equal to move. ro I did this in
27:53 - the wrong way so let's fix these around
27:56 - make this rock rock this is very manous
27:59 - to type out okay get rid of this then
28:04 - that means the opponent one so self.
28:06 - winner address is equal to self.
28:08 - opponent address okay chances are I
28:09 - messed this up but that's fine and then
28:11 - we're going to return the self. winner
28:13 - address okay now notice that I didn't
28:17 - handle any draws the reason I didn't
28:19 - handle any draws is because if the
28:21 - winner address is equal to none that
28:23 - means no one won and hence we can infer
28:26 - that that is a draw so I don't need to
28:28 - explicitly say oh the game was a draw I
28:30 - just don't declare a winner and if I
28:31 - don't declare a winner it means it was a
28:33 - draw okay so that is it for all of the
28:36 - code we needed here so we have evaluate
28:38 - winner has the opponent committed have
28:40 - both players revealed we have our
28:42 - generate hash we have our reveal we have
28:45 - our add opponent and we have our
28:47 - initialization and then of course we
28:48 - have our move class now we're going to
28:50 - use all of this from the back end so
28:53 - that's why I wanted to write this first
28:54 - so that we have this file kind of
28:56 - handled and now we can just use all of
28:58 - these methods that we've written now
29:00 - keep in mind all of this code will be
29:01 - available from the link in the
29:03 - description in case you get lost or in
29:04 - case for some reason something's going
29:06 - wrong you can just go ahead and copy it
29:08 - now we're going to go into
29:10 - main.py okay so in main.py what I want
29:13 - to begin by doing is essentially
29:16 - defining all of the different types of
29:18 - operations that this code is going to
29:20 - handle now this is how you should begin
29:22 - when you're writing any kind any kind of
29:24 - decentralized application whether it's
29:26 - with solidity or Cartesian you want to
29:28 - essentially figure out what's known as
29:29 - the protocol and the protocol is what
29:32 - different operations can be performed
29:34 - now remember that we have advance and we
29:37 - have inspect now let's just start with a
29:40 - comment and we want to start by figuring
29:42 - out okay what is going to advance the
29:46 - state all right what type of operations
29:49 - are going to require a transaction so
29:51 - that they'll be finalized and secured on
29:53 - the blockchain that allow us to modify
29:55 - the state well the first thing is going
29:57 - to going to be create challenge right
30:01 - first thing we need to do next thing is
30:03 - going to be to accept the challenge and
30:06 - then the last one is going to be to
30:08 - reveal our answer these are the three
30:10 - things that we need to do create a
30:12 - challenge accept the challenge and
30:14 - reveal that's really the core logic
30:15 - those are the three operations someone
30:17 - can submit to advance the state now we
30:20 - also have
30:22 - inspect now inspect allows us to get
30:24 - some specific data and inspect the state
30:26 - there's a bunch of things we could write
30:27 - here but what we can actually do just to
30:29 - simplify things quite a bit is just to
30:32 - get all of the challenges that are
30:34 - currently active right or just get all
30:36 - of the challenges in general we can make
30:38 - this more advanced if we want but really
30:39 - what we want to do is create challenges
30:41 - accept challenges reveal and then we
30:42 - want to get them we want to view all of
30:44 - those challenges we can again write some
30:46 - more specific inspect States if we
30:48 - wanted to get one challenge or get what
30:50 - uh challenge one players in ETC but for
30:52 - now we're going to keep it nice and
30:53 - simple and we're just going to use these
30:55 - four types of operations so what what we
30:57 - want to do is we want to essentially
30:59 - stub these out or write the functions
31:01 - that are going to handle these four
31:03 - operations now notice we have handle
31:05 - inspect and handle Advance we'll get
31:06 - into those in a second but for now we're
31:08 - just going to stub our functions so
31:10 - we're going to say create Challenge and
31:13 - we're going to put pass we're then going
31:15 - to say
31:17 - Define except
31:20 - challenge okay and pass and then define
31:24 - reveal and pass and Define
31:28 - get
31:31 - challenges and oops this needs to go
31:33 - here pass okay so we now have the four
31:36 - main functions that we're going to want
31:38 - to call now notice I've got this thing
31:39 - called handlers might look a little bit
31:41 - complicated but I promise you it's not
31:42 - too complex what this actually does if
31:45 - we view down here is it gives us access
31:48 - to the function associated with either
31:50 - advancing or inspecting the state so We
31:53 - Begin Again by defining okay what type
31:55 - of operation are we performing is an
31:56 - advanced or is an inspect so we actually
31:59 - get that by viewing the request type and
32:01 - this gives us access to a function
32:03 - object we then call that function object
32:05 - with the data associated with this
32:07 - specific rollup that's what's happening
32:09 - here with these handlers now we're going
32:11 - to do the exact same thing Within These
32:13 - functions for the different handlers
32:15 - we'll have for our specific methods so
32:18 - what I'm going to do is write some more
32:19 - handlers I'm going to say Advan method
32:24 - handlers okay and inspect
32:27 - method handlers and we're going to use
32:30 - the exact same kind of type of
32:31 - architecture or um design pattern here
32:34 - so for our Advanced method we have three
32:37 - different operations we could perform we
32:38 - could do a create challenge right which
32:41 - will be associated with creating a
32:43 - challenge because that's the function
32:44 - that will handle that type of request we
32:46 - then have
32:47 - reveal that will be associated with our
32:49 - reveal function and we then have accept
32:53 - challenge which will be associated with
32:55 - our accept challenge function function
32:57 - now let's go to inspect for inspect it's
32:59 - nice and easy we just have get
33:01 - challenges which will be associated with
33:03 - get challenges so we've just kind of
33:05 - mapped a string which is really the type
33:07 - of request we're going to handle to the
33:09 - function that's going to handle that
33:11 - request so actually sorry before we do
33:13 - that I realize we've got some code here
33:14 - that I don't want to just delete because
33:16 - we are going to use it uh but I want to
33:19 - utilize it to write some helper function
33:21 - so my apologies but we're going to do
33:22 - things a little bit different I'm going
33:24 - to make a new file here and I'm going to
33:27 - call this utility. piy or
33:30 - U.P now inside of U.P I'm just going to
33:33 - paste in two functions that are very
33:35 - simple that allow us to do some encoding
33:37 - and decoding so we can actually read
33:39 - what's going on so I'm just going to
33:40 - paste these in here very straightforward
33:42 - string to hex and hex to string feel
33:44 - free to pause the video and type them
33:46 - out or you can type them out as I
33:48 - explain what they do so anytime we
33:50 - receive data inside of our kind of
33:54 - main.py file here so like data payload
33:56 - and all this stuff that we're going to
33:57 - look at later it's going to come in as
33:59 - hexad decimal encoded now that's not
34:02 - very useful to us because I mean I don't
34:04 - know about you but at least me I can't
34:05 - read heximal data so what I want to do
34:07 - is I want to convert that to a string so
34:09 - the second function that we have here
34:10 - simply takes in some heximal data and it
34:13 - just converts it into a string for us so
34:15 - it says byes stop from hex this actually
34:17 - just gives us a string hex to string we
34:20 - then have string to hex which does the
34:21 - complete opposite takes a string and
34:23 - converts that into hex heximal data
34:25 - that's because anytime we do data
34:27 - exchange here so sending receiving it
34:29 - needs to be in hexadecimal but it's just
34:31 - within our own code we want to be
34:33 - working with strings and kind of
34:34 - printing out strings and logging strings
34:36 - because that's what we're used to using
34:38 - so we just have these two helper methods
34:39 - string to hex and hex to string that
34:41 - help us do those conversions so what
34:43 - we'll do now is we'll just import those
34:45 - from our main code that we can use them
34:47 - so we're going to say from util import
34:50 - string to hex and import hex to string
34:53 - and while we're at it we can say from
34:54 - challenge import challenge and import
34:57 - move cuz we'll use those classes in a
34:59 - minute now the reason I wanted to do
35:01 - those now is because you can see here
35:03 - that we have some code that adds notice
35:06 - and that adds a report now eventually
35:08 - we're going to need that so we might as
35:09 - well write some utility functions that
35:11 - will allow us to do these quite easily
35:13 - so we're going to say Define addore
35:15 - report now remember the report is just
35:17 - some diagnostic information kind of a
35:19 - log of what happened so we'll just take
35:21 - some output that we want the report to
35:23 - be and by default it could just be an
35:24 - empty string now for the report
35:27 - we're going to take all of this stuff
35:29 - here okay and we're going to paste it
35:32 - inside now we don't need all of this and
35:34 - we're going to modify it a bit but the
35:35 - first thing we're going to do is we're
35:36 - going to say loger doino adding notice
35:39 - and we're just going to add to this
35:41 - whatever the output is so we can see
35:42 - what that is now for our actual notice
35:46 - okay we're going to have payload and
35:48 - then what we're going to do is we're
35:50 - going to take string to hex and this is
35:54 - going to be our output because the
35:55 - output is going to be of type string but
35:57 - we need to convert it to a hexadecimal
35:59 - before we put it in the notice so we say
36:01 - Okay payload is associated with the
36:03 - string to hex like that okay then we're
36:06 - going to have our response the response
36:08 - is going to the roll up server plus SL
36:11 - notice that's just the endpoint and then
36:14 - the Json is simply going to be the
36:15 - payload that we have right here and then
36:17 - we can print out receive notice status
36:19 - blah blah blah with body content this
36:22 - okay great so that is adding a report
36:25 - now we want to add a notice and actually
36:28 - I just realized this is adding a notice
36:31 - it is not adding a report so I messed
36:33 - this up a little bit fortunately we can
36:35 - change this quite easily so rather than
36:38 - add
36:39 - report just make this add notice and
36:43 - rather than output I'm just going to
36:46 - call this data and I am going to make it
36:49 - mandatory here and I need to change this
36:52 - now a bit so rather than that we're
36:54 - going to put data in an F string just
36:56 - because the the type of our data here
36:58 - may not necessarily be a um what do you
37:01 - call this a string
37:03 - type okay um anyways I think this is
37:06 - fine for now adding notice data payload
37:08 - string to hex I'm getting a little bit
37:10 - confused but I think that is okay all
37:14 - right next we're going to do our ad
37:16 - report so
37:18 - Define add report and this time we'll
37:21 - take output equal to an empty string now
37:24 - we're going to copy this code right here
37:27 - okay we're going to put this inside of
37:29 - add report so now we can say add
37:32 - report
37:34 - plus the output we can create our report
37:38 - this time for the report we'll say
37:40 - string to hex and then our output and
37:44 - then I think that all of this is
37:46 - actually fine so I think these functions
37:47 - are actually exactly the same except
37:48 - one's notice one's report and I think I
37:50 - was just getting a bit ahead of myself
37:52 - on how this worked but anyways you have
37:53 - ad report and we have ADD notice that's
37:55 - fine so what we will do do now is going
37:57 - to handle advance and handle inspect and
37:59 - start calling the correct function based
38:02 - on the type of data we're receiving now
38:05 - I understand this is a little bit
38:06 - confusing so I just want to go all the
38:07 - way down here and kind of explain how
38:09 - we're going to handle this so we're
38:11 - writing our own decentralized
38:13 - application and as you've noticed here
38:15 - we're pretty much designing the protocol
38:18 - which is the way in which we want to
38:20 - interact with this application now we
38:22 - can interact with this any way we want
38:24 - and we can send any type of data and
38:25 - receive any data that we want now I want
38:28 - to use Json data because this is data
38:31 - that we're probably most familiar with
38:32 - it's just like a python dictionary so
38:34 - what I'm going to expect is that I will
38:38 - receive a Json object inside of my
38:41 - rollup data now this Json object I
38:45 - expect to have a key method and the key
38:47 - method should specify one of the
38:50 - appropriate methods so create
38:52 - challenge like this okay this is what
38:55 - I'm expecting
38:57 - uh to accept as my data now this method
39:00 - will tell me what the user wants to do
39:02 - creating a challenge revealing a
39:04 - challenge accepting a challenge or
39:06 - getting challenges so I want you to keep
39:08 - that in mind as I write the next bit of
39:10 - code here the data that this back end
39:12 - will accept will be a Json object that
39:15 - will contain the key method it may
39:17 - contain some other Keys as well but for
39:19 - now method is what we're focused on okay
39:23 - so if we go inside of handle Advance now
39:25 - which is the one we can write first
39:27 - the first thing we need to do is we need
39:29 - to parse the data we received as a Json
39:32 - object so to do that we're going to say
39:35 - payload is equal to Json which we need
39:38 - to
39:39 - import okay so let's import Json like
39:42 - this load s this stands for load string
39:47 - then we're going to take the hexadecimal
39:49 - data and we're going to convert this to
39:52 - a string now again I know a little bit
39:55 - confusing with me here in in fact I'm
39:57 - going to delete this cuz this is not
39:58 - going to be helpful to us right now I'm
40:01 - saying payload is equal to json. loads
40:03 - now the data that's inside of the
40:05 - payload which is what we're actually
40:07 - sending to the back end is going to be
40:09 - heximal so I start by converting that
40:11 - heximal value into a string value now
40:14 - what we get is essentially a string
40:16 - which is Json data what we want to do
40:19 - though is we want to take that string
40:21 - and we want to convert that to a Json
40:22 - object or in this case a python
40:24 - dictionary so we can utilize it just
40:26 - like a python dictionary so that's what
40:28 - we're doing but the thing is this could
40:30 - fail because we might not actually be
40:32 - receiving Json data if someone sends us
40:34 - something invalid so I'm just going to
40:36 - do a try accept and I'm just going to
40:39 - return reject here when you return
40:42 - reject you're essentially indicating
40:44 - that an error occurred that's all we're
40:46 - doing okay so we're saying okay try this
40:48 - generate a payload if the payload
40:50 - doesn't work we're just going to return
40:51 - reject um and kind of indicate hey
40:54 - whatever you tried to do here did not
40:56 - work work okay now if we did actually
40:58 - load the payload what we want to do is
41:01 - get the method that's stored inside of
41:03 - that python dictionary so we're going to
41:05 - say method is equal to payload doget and
41:08 - then method okay now what we'll also get
41:11 - at the same time is the sender now the
41:13 - way we get the sender is we say data
41:16 - metadata and then message sender now
41:20 - again what we're passing here data which
41:23 - we'll look at down here right so roll up
41:25 - request data is it's going to contain a
41:26 - bunch of different Keys there's some
41:28 - more documentation that shares with you
41:29 - everything but it's going to have a
41:30 - payload which is what we want and it's
41:32 - also going to contain who sent this so
41:34 - what address actually sent this request
41:36 - so that's what we're looking for
41:37 - message. sender so we have the sender
41:40 - now what we can do is we're going say
41:42 - logger dotinfo and we can just put an F
41:45 - string here and we could say received
41:50 - Advance
41:52 - request data and then we can log the
41:55 - payload which now will be in an object
41:57 - format that we'll be able to actually
41:59 - read There we go okay now that we've
42:02 - done that we just want to check this
42:04 - method and make sure this method is
42:06 - inside of the request Handler so what we
42:09 - can do is say Handler is equal to
42:14 - advance method handlers doget and then
42:18 - we can attempt to get the method now if
42:19 - we say if not Handler so essentially
42:23 - that means if we did not have this
42:25 - method inside of the ADV handlers what
42:27 - we can do is add a
42:29 - report okay and we can say invalid
42:33 - method indicating to the user hey this
42:35 - was invalid and we can return the string
42:38 - reject because well this didn't work
42:41 - otherwise what we will do is we will
42:44 - return the Handler and we will call this
42:48 - with the
42:50 - payload and the sender okay so this is
42:53 - handle Advance we are loading in our
42:55 - Json data data we are getting the method
42:57 - that the user wants to call as well as
42:59 - the sender of this message we then are
43:02 - making sure the method is valid if it is
43:04 - we're going to call that method by
43:06 - looking at the associated Handler right
43:08 - so we're going to call that function and
43:10 - we're going to pass that function a
43:11 - payload and the sender okay so now what
43:15 - we can do is we can just kind of fill in
43:17 - these three functions here and we can
43:18 - just generate something like a report
43:20 - inside of here just so that we can
43:22 - actually test if this is working using
43:24 - our frontend console so what we're going
43:26 - to do for all of these is we're going to
43:28 - say payload
43:30 - sender payload sender because that's
43:32 - what we want to receive and payload
43:35 - sender we're going to
43:38 - return accept Okay so we're going to
43:40 - return that from all of
43:43 - them okay and for now we are going to
43:47 - say what is this generate report or what
43:50 - is this make reports what did I call
43:52 - this add reports okay only one I didn't
43:55 - try add report and we're just going to
43:57 - say create challenge like that for this
44:01 - one this will be accept challenge this
44:03 - is just for testing purposes so we can
44:05 - actually run this code and this is going
44:07 - to be reveal challenge okay so now we
44:10 - have everything handled and kind of
44:11 - hooked up for advancing obviously
44:14 - there's some more stuff that we need to
44:15 - write but the core logic is kind of
44:17 - there in terms of taking the request and
44:19 - rooting it to the correct location which
44:21 - is what we just set up so now that we've
44:23 - done that we'll pretty much repeat that
44:25 - process and do the same thing for the
44:28 - inspect so for inspect we can really
44:30 - just copy all of this and we'll just
44:33 - modify it a little bit so go to handle
44:35 - inspect okay we're going to load in our
44:38 - payload we don't actually care about the
44:41 - sender and we're going to change this to
44:43 - say received and this is going to
44:45 - be inspect request now rather than
44:49 - Advance this is going to be inspect
44:51 - method handlers and then here for the
44:54 - Handler we will we'll just call this
44:57 - with our payload okay so that's pretty
44:59 - much it that's the exact same thing for
45:01 - inspect we get the payload we get the
45:04 - method we make sure the method is valid
45:06 - for the inspect request type if it's not
45:09 - we have a report otherwise we do the
45:13 - Handler now for get challenge that means
45:15 - that we're going to have to take in some
45:17 - parameter mean we don't have to we
45:19 - actually could not pass the payload if
45:20 - we don't care about it so we can just do
45:22 - this Candler and now we don't actually
45:24 - need to take anything inside of our get
45:25 - chck es okay so that's all hooked up
45:28 - let's do the same thing here and return
45:33 - accept and let's add a report that says
45:36 - get
45:38 - challenges okay everything is hooked up
45:41 - we have all of the routing done let me
45:42 - just zoom out a bit so you guys can read
45:44 - more of it at once kind of slowly scroll
45:47 - through and you can pause it if you need
45:48 - to have a look at it again remember all
45:50 - of this code will be available from the
45:52 - link in the description and we haven't
45:54 - changed any of this we've just been kind
45:56 - of handling routing our different
45:59 - requests so now that we've got that we
46:01 - want to actually run our code and we
46:03 - want to try this out to see what happens
46:05 - and if our requests are being routed
46:06 - successfully sorry about the sudden cut
46:08 - there guys anyways now that we have all
46:11 - of this code ridden what we want to do
46:13 - is start setting up the environment so
46:15 - we can actually execute and just do a
46:16 - bit of testing now that'll wrap up this
46:18 - video but let's get everything running
46:20 - just so we know it's working so first
46:22 - things first make sure you have Docker
46:23 - desktop running okay if you don't have a
46:25 - running none of this stuff is going to
46:26 - work so make sure you have that running
46:28 - in the background then what we're going
46:29 - to do is open up our WSL window but
46:32 - first we're going to make a modification
46:34 - uh to a few files here so if we look at
46:37 - entrypoint dopy orsh sorry you can see
46:39 - that we have echo. py now that was the
46:42 - name of the file we changed to main.py
46:44 - so we're just going to change this to
46:45 - say main.py now we're going to go into
46:49 - our dap. Json and we're just going to
46:52 - list all of the Python files that we
46:53 - have now so rather than just Echo it's
46:55 - going to be
46:56 - main.py
46:58 - U.P and challenge. piy these are the
47:01 - files that we need to copy in for our
47:02 - code to work so we're going to put those
47:04 - three here so those should be the only
47:06 - modifications that we need to make again
47:08 - in dap. Json and entrypoint.sh now we're
47:12 - going to go over here and start setting
47:14 - some stuff up now I'm just going to open
47:16 - up my developer guide here because this
47:17 - is always quite helpful so first thing
47:19 - we got to do is work on our node now for
47:21 - our node we need to build the project so
47:24 - that we have all of the correct doer
47:26 - containers so I'm going to copy this
47:27 - command Docker build X bake load I'm
47:30 - going to paste that here in rock paper
47:32 - scissors okay so going to go ahead and
47:34 - hit enter give that a second and this
47:36 - should build all of the necessary
47:38 - containers we need and you should see
47:40 - this run without error if you are
47:42 - getting any errors here make sure that
47:44 - you change those files I just showed you
47:46 - so we copied in all the correct files to
47:48 - the image now if you're still having
47:50 - issues with this what I would recommend
47:52 - you do is ensure that you tore down your
47:54 - containers correctly and that you
47:56 - cleared any of the cache that you have
47:58 - in Docker a lot of times what will
48:00 - happen is Docker will actually cach some
48:02 - previous containers volumes Etc and when
48:05 - you try to run this command it will use
48:07 - some of those containers and there'll be
48:08 - some mistakes because they weren't spun
48:10 - up or torn down correctly so what you
48:12 - can do is simply go to your Docker
48:14 - desktop you can view all of the
48:15 - different containers and then you can
48:17 - delete any of the ones that currently
48:19 - exist as well as deleting any of the
48:21 - volumes then you can rerun the command
48:23 - and you should be good to go before you
48:25 - do that you can also just run the
48:26 - command that takes down all of the
48:28 - containers so the docker composed down
48:31 - command the one that is in the cartei
48:33 - guides that are linked in the
48:34 - description okay now that we've built
48:36 - that we're just going to spin up uh the
48:38 - test node right so we're going to copy
48:40 - that command we used in the previous
48:41 - video just make sure the uh what do you
48:44 - call it here the line breaks are correct
48:46 - so we'll fix that one should spin
48:48 - everything up and we just want to make
48:50 - sure this runs and give it a second um
48:52 - so it doesn't have any errors right so
48:53 - it's deploying all the contracts okay
48:55 - okay looks to me like that is fine now
48:59 - in our other terminal
49:00 - window so let's bring one up here we're
49:03 - going to start uh initializing our
49:05 - virtual environment now you may have
49:06 - copied the virtual environment already
49:09 - if you didn't copy the virtual
49:10 - environment from the previous video
49:11 - you're going to need to make a new one
49:12 - so let me just open up the guide here on
49:16 - the left hand side of my screen and you
49:18 - can see that to make a new virtual
49:19 - environments this command if you already
49:21 - have it though so if you LS and again
49:24 - it's not going to show it cuz that's a
49:25 - dott but there is a uh venv folder right
49:28 - so if you see that in your vs code you
49:30 - don't need to remake it and what you can
49:32 - do is just activate it so I'll copy the
49:34 - command here to activate the virtual
49:36 - environment if that doesn't work then
49:37 - make the virtual environment first with
49:39 - this command then install the
49:41 - requirements we should already have them
49:42 - installed because we have the same
49:44 - virtual environment and now we can
49:46 - create or spin up our backend so what
49:48 - we're going to do is copy everything but
49:49 - not the echo. piy and then for the file
49:53 - it's going to be main.py right we don't
49:55 - want to run Echo up high we want to run
49:57 - main upy because that's what's going to
49:59 - actually execute our code so let's go
50:00 - ahead and hit enter there that should
50:02 - spin up our server and yeah we can see
50:05 - that it's running here okay so now that
50:08 - we have that what we can do is go into
50:10 - vs code and we can start using the
50:13 - frontend console to just send some
50:15 - requests to the server so that we can
50:17 - make sure that our code is working and
50:20 - we're just testing the routing at this
50:21 - point in the next video we'll get into
50:23 - some more of the deep logic so from the
50:25 - rollups example directory we're going to
50:27 - go to the front-end console okay let me
50:29 - just clear that remember that we want to
50:32 - type yarn just to install everything so
50:35 - I already did this in the previous video
50:36 - but type yarn we're going to get
50:38 - everything installed and then once it's
50:40 - installed I will show you how we can
50:42 - send some inputs and some inspect
50:44 - requests and just make sure that we're
50:45 - getting the correct reports and outputs
50:47 - okay so what we can do is just open up
50:49 - the guide here and for the guide it
50:52 - shows us how to do this so yarn start
50:54 - input send and then we can send
50:56 - something like a payload so I'm going to
50:58 - copy this into here okay let's make this
51:02 - a little bit larger and for the payload
51:05 - we actually want to put a string which
51:08 - is the Json data now we need to be a
51:10 - little bit careful here because the
51:11 - quotation marks can mess this up but I'm
51:13 - going to put double quotation marks
51:15 - actually I'm going to put single
51:16 - quotation marks sorry I'm going to put
51:18 - an object because we're going to send
51:19 - Json and I'm going to specify My Method
51:22 - now make sure you're putting this inside
51:23 - of Double quotation marks because we're
51:25 - essentially writing what the string is
51:28 - that we're going to send over uh to this
51:30 - back end now we'll know quite quickly if
51:31 - it's not working but we're going to put
51:33 - method and for the method we will go
51:35 - with create unor challenge like that
51:39 - okay now notice we have double quotes
51:41 - inside of the single quotes go ahead and
51:43 - hit enter give this a second we should
51:45 - see it popping up here on the right hand
51:48 - side uh once it actually gets sent
51:50 - through all right so we got an error
51:51 - here from the front end console now I
51:53 - think that just has to do with my
51:54 - quotation marks so I'm I'm just going to
51:55 - put double quotation marks and I'm going
51:57 - to start putting some Escape characters
51:59 - here just bear with me for a second
52:01 - because sending Json is not really
52:02 - supported in the front end console but
52:04 - we're trying to do it for testing we'll
52:06 - write our own kind of tool later but I
52:08 - just want to see if this is going to
52:09 - work now and actually send the Json over
52:12 - and I'll kind of do a few attempts okay
52:13 - so it looks like that did work it says
52:16 - sending method and transaction input
52:19 - zero added however we did not see
52:21 - anything appear over here okay there we
52:23 - go we just got it received Advanced
52:24 - request dat method create challenge
52:27 - adding report create challenge receive
52:28 - report status sending finish okay so
52:31 - that means that worked I just wanted to
52:32 - test the communication here and to kind
52:35 - of explain how this worked we had our
52:37 - double quotation marks which is the
52:38 - string we then put inside of here our
52:40 - Json data and I just escaped the double
52:43 - quotation marks with an escape character
52:45 - which is the backslash okay so by using
52:48 - that sorry is it back slash forward
52:50 - slash I forget which one you call this
52:52 - but whatever this direction slash is we
52:54 - escaped the these double quotation marks
52:56 - so we able to embed double quotes inside
52:58 - of these double quotes for our Json data
53:00 - okay so that was one now other than
53:03 - create challenge we want to test All Our
53:05 - Roots so we're going to test accept
53:07 - challenge okay so this is going to be an
53:09 - input send that over give this a second
53:12 - and we should see it respond to this in
53:14 - a minute okay and there you go accept
53:17 - challenge came in now we want to test
53:20 - reveal so let's go here and test the
53:24 - reveal
53:26 - and then next we will do an inspect
53:28 - request and we will test the um what do
53:31 - you call it the get challenges okay so
53:33 - input to added give this a second to
53:36 - respond and there you go we got reveal
53:39 - okay incredible now that we have that we
53:41 - can have a look at some of the notices
53:43 - or the reports that have been created so
53:45 - again we can go back to our guide here
53:47 - we have yarn start notice list but I
53:49 - believe we can also replace this with
53:52 - report so we'll say yarn start report
53:55 - list see if that gives us a list of
53:57 - reports if I type that in correctly all
53:59 - right I was getting some weird error
54:00 - there cuz my typescripts all messed up
54:02 - on my computer anyways for you guys that
54:04 - should have worked but I'm going to type
54:05 - yarn start
54:09 - inspect Das Dash payload and then we'll
54:13 - do kind of a similar situation here
54:15 - where we have
54:17 - method get uncore challenges don't worry
54:21 - too much about this tool guys I'm just
54:22 - using this for testing purposes we're
54:24 - not going to use this in the production
54:26 - application obviously it's just kind of
54:27 - a debugging tool but if I send this I
54:30 - think this should work if we send the
54:31 - payload correctly and it returns to us
54:34 - get challenges and would give us any
54:36 - reports or whatever that we're generated
54:38 - you can see here it says received
54:39 - inspect request data get challenges
54:41 - there you go and there's one report that
54:44 - has get challenges inside of it okay
54:47 - anyways that is it for this video I just
54:49 - wanted to get the core of the back end
54:51 - done a lot of the communication finished
54:53 - so this way in the next video we can
54:55 - handle the logic in those functions and
54:57 - then start working a bit on the front
54:58 - end and kind of getting that set up and
55:00 - stubbed so we can then wrap that up in
55:02 - the video after that anyways I hope you
55:04 - guys enjoyed so far if there are any
55:06 - questions or if you're having trouble or
55:08 - if for some reason you need to reference
55:09 - the code please you can look at the
55:11 - links in the description we have the
55:12 - cartei Discord server and you can
55:14 - obviously reference all of the complete
55:16 - code anyways I will see you guys in the
55:18 - next
55:19 - [Music]
55:24 - video
55:26 - w