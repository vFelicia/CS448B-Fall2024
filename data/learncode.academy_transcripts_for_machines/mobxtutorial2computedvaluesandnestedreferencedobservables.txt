in this video we're going to take a deeper dive into mobx and how you actually use mobx in a real application by building out this to do's application so let's start by actually printing these todo's out we have this to do store again that's giving us two really basic todo's all they are is strings at this point so let's go ahead and make a ul with lis for that we won't really mess with css but we'll get it going for this example with the ul and list then i'm going to go ahead and pull those todo's out of my props i'm going to go and map those to list so there we are our todo's are now showing up so let's go ahead and get this filter going one great feature of mobx is we can actually real time react to computed values so if we were to filter this list by whatever this value is that would be a computed value and that's extremely easy to do in mobx let's start by getting the input going to actually real time set this filter for us let's go ahead and print that filter here we'll pull it in now let's go get an input that will real time set that filter for us there we go so on change we're going to fire this dot filter so let's set that up and this will be extremely simple and there we have it so now we're going to have a ul and we're automatically going to be able to change that and that will set the filter you can see there we go our filter is setting let's go and wrap this and maybe a div just to clean it up a little bit for now there we go so you can see that our filter is automatically setting so let's go ahead and set a computed value now and to do that we simply import computed from mobx computed then will fire very lazily whenever it's needed to fire so let's go ahead and make an observable or a computed value and this is a get filtered to dose so whenever our data changes filter to do's will go ahead and compute a new value and we can just kind of basically check the filter and filter out all the to do's so i'm going to do a case insensitive check if it matches loosely our filter then let's go ahead filter them out so let's go and filter the todos now let's say if there is no filter at all so if there's no filter then we're going to say that that's okay we have not set a filter yet or if it matches the filter so there we go if no filter is set or if it matches the filter then our results will show so let's go ahead and save that and now our todo list will get an additional value called filtered to do's which is essentially to this react component no different than the todo's array itself so i can simply print out the filtered to do's instead there we go that's reloaded and let's see if it works yep if i do m it works if i do ch it filters out so now our to do's are filtering let's go ahead now and clear out this filter which we no longer need to see and in its place let's add an input that will allow us to create a new to do so we are going to do create new and let's uh set our create new up here and all we have to do is filter out we only want to create if key press 13 which is enter has been pressed so if and let's clear out our value once we create a todo so now we're calling the create to do method on our mobx store let's go and add that create to do method there we go now we have a second input on the page and let's see if we add a new to do to the list when we hit keypress 13. yes it does excellent so now we have an input that's real time adding stuff to our list and we have a filter let's only view the tests let's only view milk excellent that is working as well so now let's go ahead and add maybe some check boxes and a little bit more value to the to do store and this will get into the concept of nested stores or nested observable objects from mob x so for to do's we have the to do store but we want to make this an array of observable to do objects that have more than just a text string they need to have a state whether they're checked or not and they also probably need to have an id so to do this we're going to actually create a to do type so let's go and create a class of to do this could be done in another file but to keep things simple i'm just going to add it right here and it's going to have some observable values on its own so let's make an observable value id and complete and then a constructor for it and then real time we'll go ahead and create an id which we'll just use date now to kind of simulate an id that way it'll get a timestamp for an id that way it'll be unique and it'll automatically be false by default so then all we have to do is instead of pushing a value we can just push a new to do with a value and we'll just clear out this to do's list now and now let's see what happens and now it'll work or the store portion will work you can see that if i add tests in test one they're not showing up because i'm adding them to the store but now the store is inheriting an array of objects so to map these out to an li i simply need to do to do dot value and they will all work just fine now test test one test two or test three um we'll also at this point want to add a key to our to do's li so there's a unique key for each one react needs this i probably have a react warning yep you can see i have a warning here each child needs a unique key prop so let's go and add that key and that's where our todo id will come in handy since the id will never change excellent that warning is gone well let's make sure it's gone yep that warning is gone and let's go ahead and add a checkbox why don't we and let's go and set the value to to do dot complete and let's also set checked to to do complete so there we go now any new to do should automatically reflect the state of its object up here of its observable object so let's go ahead and test this out okay it looks like it's doing good to verify this let's make the default to be true so now all of our new to todo's should automatically be checked okay very cool that's working so now let's go ahead and set a change method to automatically change that and kind of as a little hacky quick way i'm going to bind it to this and i'm also going to pass to do as the first argument in there so the first argument will be to do here so toggle complete we'll get the todo of whatever was clicked now if you don't like this way of doing it you could also just totally pass in the id or you could even print the id here on the input element but it's in my opinion just as simple and is not going to cause any problems to pass it in this way so let's go to do dot complete equals the opposite of its complete status now it's important to note here that if you don't like the coupling of the todo list right here to the todo store you can see that i'm manually changing the todo right here what i could definitely do is do something that's more along the lines of actions with mob x whereas instead of changing the complete item within this component i could fire off a to do complete or a to do toggle complete action pass off the id and something else outside of this module outside of this react component could handle that action and update the store as a third party action so you can still definitely do flux style actions in mob x if you like that abstraction but for something that's not as complex as what we're dealing with here or for something that's as simple as we're dealing with it really doesn't need to have that level of abstraction so let's test this out and can we change it yes we can so let's go and change this to be false now and let's add one more feature now that we can complete some items let's make a little button to clear those completed items and let's say clear complete and so we're just going to basically fire this.props.store.clearcomplete of course i can actually clear that out a little bit and just import clear complete which doesn't exist let's go ahead and create that now and i'm going to automatically bind it using an arrow function so that way it is bound to this it will always fire within correct context and i can't really change this dot to use one of the differences one of the big differences between observable arrays and plane arrays uh they act almost the same in every way except for i can't erase it i can't just point to a new object because then the reference is actually messed up we have lost all our reactivity at that point so what they do is they give you a replace method so i can call todo's replace which can now replace it with a new set of todo's so i can go ahead create the new complete or incomplete set of todo's so if the to do's are not complete they're going to end up in this array and i can replace it right here so let's go ahead and test this out now we can go test test one test two and if i hit clear complete nothing happens and let's check a few as complete and the other two go away about the only thing i need to do now is my filtering is i assume to be broken yes everything breaks because if you'll remember my todo is not a simple string now it's got a value so to do dot value i'll need to update that my filtering should be working again now if i say two yep now we're good and there you have it we've added quite a few features in a matter of minutes to our todo list it was extremely easy to do mobx made it really really fun and look at how little code we have what is this we have 35 lines of code in our components and we have somewhere around 30 lines of code between our to do class and our to do store class this is the joy of mobx you simply get a lot of work done for the amount of time you put into it hope you enjoyed these lessons have a great day