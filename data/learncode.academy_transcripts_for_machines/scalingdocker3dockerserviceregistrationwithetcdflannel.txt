okay so we have our coros cluster running and we can now use Fleet to run multiple copies of our web apps and this brings us to kind of the biggest difficulty that a lot of developers have when moving to a Services microservices architecture is oh my goodness this IP address for web 2 could change if this machine dies Fleet is going to reschedule web 2 over here so now web 2 has a brand new IP address and a brand new Port so how do I handle that and we basically need to bring in service Discovery that's really two phases to be solved is Service registration you know uh so eted is basically going to be our Hub the internal eted it's going to be our Hub we're going to register that these Services exist and our running and then engine X our load balancer is going to query eted and discover those services and kind of watch that for for changes so whenever Services arrive or depart engine X is going to reload its configur ation and restart itself uh so let's handle that first step of Service registration to do that coros gives us a great tool called flannel um and you see in the cloud config file we've started flannel here and what flannel is going to do is it's going to give a unique IP address to every single Docker container that runs um and it's going to be an internal IP address like a 10.0 do IP address so it's only accessible to Services running in this coros cluster it's not going to be accessible outside which also solves another cool problem for us uh when some app runs we don't have to expose any public ports anymore we only have to expose internal ports to my Docker container uh so right now our SU app at service is doing a an uppercase P which says Hey expose all the ports that my node sample app is exposing and create a dynamic port for them uh that's accessible public let's kind of just go through this real quick um so let's I can list units I have nothing running so let's go ahead and start uh sum app at one through four so let's get four copies of SU app running here great still got those area messages I need to look into what those are uh so fleets control list units great I've got four of them running on four different machines um and so let's go ahead and SSH into this guy have that handle it for me and I'll do a Docker PS so that's automatically it's exposing Port 3000 which is getting mapped to 32770 externally that is available uh to anyone that has access to this coreos cluster which if you remember on digital ocean is everybody in the world uh because these are all public of course you can fix that with with IP tables uh but a cool thing is is using flannel we're not even going to have to do that anymore uh but let me show you real quick uh so if I were to kill this node let's say I were to go to digital otion and just send the power off signal to this machine anything running on that machine flannel would reassign to another machine really quickly pretty much as soon as it noticed that that service died uh but then they'd have a new IP address and they certainly have a new Docker report as well um so what flannel does is flannel actually assigned this guy an internal IP address so let me go ahead and grab that out let's go Docker exec uh sum app one I'm going to run a command within sum app one and I'm just going to run IP address list so you can see if I look at my ethernet zero I've got this IP address that has been given to me so now I can just ping this port 3000 actually I'll just ping it yep it's working um and then let me go to a different machine and let's see Fleet control list units I'm going to go to a completely different machine a completely different container some app at three and let's get into that app let's go Docker exec it I want to do an interactive terminal and we're going to go into SU app 4 so I'm going to open up a bash terminal basically within my suap 4 container wh did I do the wrong one yep I did at three so suap 3 is the container that's running on this machine okay there we go now I'm in suap suap 3 now let's do a curl let's actually curl this IP address Port 3,000 because we don't even care about an externally exposed IP address and there you go I've got my HTML document from my other web service running on my other container uh the two things that are great about flannel is one we don't have to use Docker Link at all so if you're familiar with Docker link Docker link you know you can link two containers together and it'll set a bunch of environment variables that tell you all how to talk to them uh but now we don't even have to worry about that we just have to register each web service with its accessible IP and the port is always going to be 3,000 on any of our web containers so how do we actually register this come on let's get to the meat and potatoes here let me get out of here so there's basically two ways to register this one we are going to register this to etsd internally so we're going to use ETD control and we're just going to set a key and then other services can get a key or they can watch it uh so the the two ways of doing this is you can either have your SU app service actually handle this so so in this case I'm running a node.js application that node.js application could automatically register its IP address and Port 3000 to eted all I have to do is kind of give it um I just have to mount the eted control as a volume within the container but it's not really the best practice for a service to handle its own registration um what you want to do instead is a sidekick service so we're going to create a suap discovery service and this will kind of link to every instance of a web service and then it will run alongside and it can monitor the service for us and when the service goes up or down we're going to either add or remove a key from eted so here's what that file looks like it's got a description we're going to announce sum app one we're going to bind to SU app one and then we're going to start up after whop we're going to start up after SU app one has started and then we have this Fleet uh configuration here which says it's a machine of sum app one so that means whenever we start stop sum app one then it's automatically going to start and stop some app Discovery at one so that means basically once we've kind of loaded up this service we don't have to manually control it anymore it will automatically be a slave of some app one so here's what that's doing if you're good at bash script you're going to see that it's basically just going to run a loop every 45 seconds it's going to run ETD control set this key right here Services SU app Upstream SU app one and it's going to run this Docker inspect command and get the IP address of SU app one I'll show you that command real quick let's do that SSH again so I can just run Docker inspect we're going to get the network settings and IP address from SU app 3 there's the IP address so it's just going to get that IP address add Port 3000 to it and then it's going to give it a timeout of 60 seconds so this key is going to expire after 60 seconds but we're going to heartbeat update this thing every 45 seconds and then if this service ever stops then we're going to remove that key from etcd okay simple enough let's go ahead and submit this uh SU app Discovery at so we're submitting this to Fleet control and then uh let's go ahead and start four copies of it so we do have to kind of create these either by doing a fleet control start or Fleet control load um let me show you what just happened too if I go Fleet control list unit files we only submitted one unit file and that was the discovery at file and whenever you create a new number from a dis from an at file then it what it does is it actually clones that file uh so you have a copy of it so these copies did not exist until I ran Fleet control load or Fleet control Start If I had not run those there'd be no companion Services there'd be no Sidekicks for these all there would be is a sidekick for this guy right here which we never actually run so I had to do a run or a start to create those sidekick files and from now on whenever I do a sum at one service start or stop then it will automatically start or stop its companion as well and if you'll notice the companion service also got loaded on the exact same machine so uh sidekick one got put on the same IP address as some app one sidekick two got put on the same IP as some app 2 and so and so so basically they're linked as far as Fleet is concerned this service and this service are coupled together uh so let's go do Fleet control list units we've got them running so they're all running uh let's go ahead and ssh in and see what etsd looks like so ety D LS recursive so these are all my ETD keys and you'll see that it is now created a Services folder with some app in it upstream and we've got four upstreams that are set let's go ahead and look at one of these there we go so that's an IP address for some app 3 some app 2 some app one and some app four so now we can spin up an engine X instance that watches this folder right here and when anything changes it reloads itself hopefully you got this you this is the one of again this is the most complicated piece um understanding Service registration to me is the toughest part uh service Discovery is a lot easier than Service registration uh so let's go ahead and move on to service Discovery and engine X