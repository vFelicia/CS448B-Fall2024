in this series we are going to be covering databases that every developer should try out and test run and have a little bit of experience with most developers these days have experience with mysql postgres perhaps mongodb and redis but there are some other ones that are really great that are out there and in this video we are going to cover a rongodb also called a rangodp depending on who you talk to for the rest of this video i'll probably call it a rongodb but from the best i can tell there is no right or wrong so orangodb is a really cool really unique database it's a multimodel database which means you can use it as a graph database which we'll cover a little bit more later about what graph databases mean for those of you guys who haven't used graph databases before it can also be a document database like replacing a mongodb type of database and it could also be a key value store database replacing something like redis all with one query language you can use any or all features at any point in time speaking of the query language the query language for orangutb is really nice usually when i hear of some new database with a new query language i have this kneejerk reaction that i don't want to use it or learn it who needs to learn another query language but aramgdb their query language is really easy to pick up very enjoyable to use and it's based on coding it's based on how it feels when you're coding you take an array you filter you map you sort and that's kind of how it is we'll dive more into that later on you also get everything you expect uh out of a rangodb or rongodb uh that you'd expect out of a modern database it scales easily it clusters easily it runs seamlessly in docker it also has a really great ui right out of the box so you can start using it within seconds it also has some really cool features you might not expect to see it can be used for search in a really powerful way allowing it to operate kind of like as an elastic search replacement and it also has this builtin fox javascript framework so you can build node.js microservices straight onto the database layer itself which means you can get some really cool performance benefits it can allow you to do things like make a rest api that the database layer serves so you don't even need a backend for small apps so that feature alone is really really interesting and really cool and it can fulfill a lot of small scale use cases and some largescale niche use cases that large companies may actually have it can also do geospatial searches so if you want to search for any items within a polygon shape it can natively do some searches like that which is really cool so enough talk let's get into this and actually have some fun with a rongodb we're going to start by spinning up an instance in docker so as long as docker is installed on your machine this will work really easy you just do docker run and then we're going to add a few arguments here e orango no office means we're going to disable authentication no usernames or password this is just local playing around we're going to expose port 8529 which is that port and we're going to call it test orangodb let's go ahead and run this guy and tada we are running so now i can actually go localhost port 8529 and there we go we are instantly into their ui it's really nice we can see our collections views which are kind of elastic search search type of things graphs which are how we want to build any graphs we can natively build graphs on top of our data so let's go ahead now and add our first collection add some data in there and show you how the query language works let's create a collection called friends and you can see that we have two options for types document or edge we'll get into edge a little bit later because that's a graph database feature and there we go we have a friends collection now i can go over here to queries we can actually insert some records it's pretty simple just say insert add any json you want and then you can pick into which collection so i'm going to do name you notice i don't actually have to make it official json and wrap everything in quotes that's really nice because it's a lot more annoying to have to wrap every single key in quotes so i'm going to insert will into friends hit command and enter and i've run my query i can come back over here and i have my first friend named will which is me so let's insert some new people here bobby let's create john apparently all my friends are dudes that's fine jake so we just inserted a bunch of people we can go back to this collection and there we go we've got a bunch of people created already so now how do we actually return some of these documents let me look at some of these ids here if i go here i can see that their key each person got a unique key i did not specify a key so each person got a key key is basically like id would be in a relational database you can specify a key which gives you basically the ability for key value storage but when you do not specify a key one is randomly generated for you so we've got 501 we've got 514 so i can actually now return just a document 501. and you can see it pulled back document 501 i can view it in json there there is 501 i can also say what was it 514 is that correct yeah 514 i can also get 514. i can also do an array and get several i can return two documents super simple i can also iterate through if i want to actually do say like a where query friends where name is will that i can go for friend in friends and this is where it really starts feeling like code i can return friend which is going to give me basically every friend because i didn't really do anything i didn't do any filtering or anything like that but i can easily do some filtering where friend name is will and so now i'm just going to find will and so you can see where i could do where friend age is greater than 15 which i haven't put the age in there but you can easily do all the stuff you do and it just feels like code which is really really nice let's say we have a collection called states that has all the states in the country and i wanted to also join that i could go for state in states and then i could do filter where friend dot states this would be assuming that i actually set a state you know the state that the friend lived in equals states dot key and then there you go i can automatically that would be underscore key wouldn't it then i can filter wherever the state is and i can also return anything i want i can return a javascript object or friend.name i can just return a few values that i want or i can return say maybe the whole friend and also something else you can basically do it if you can think it in code you can take care of it here so let me actually do a little example of how that return object works if i just return friend then i'm going to see the entire json object of each person now if i actually create an object and add friend in there then it's going to treat it as if you're doing es6 and then friend equals the entire friend object this is a little bit more nesting going on and i can add some actually just add my own pretend value if i want now each person gets both a friend and a foo bar value so you can really customize how that output works without having to mess with the application layer which is really really nice because lots of times this kind of decorating and laying out the data would happen at the application layer okay let's use this as a key value store now let's create a collection we'll call it sessions it's document as well let's say that we're collecting user sessions and we want to take care of that so i'm going to insert i don't know ip address or logins i don't really know what we'd want to do for sessions let's say logins one into sessions but we actually are tracking this with a session key so we can specify that key i'll just call it a b c d e let's pretend that's some big old long hash and there we go we've actually inserted a b c d e so now we can go fetch it whenever we want i can go get a b c d e whenever i want to and you can see that it has logins equals one so now i'm essentially using it like redis i'm setting keys explicitly and then i can fetch them knowing that they exist so this is how you would use it for a key value store simply just by specifying key that's all you have to do super nice let's look into the graph database features and i'll also cover just a little hint of how graph databases work and some of the cool things that you can do with graph databases that you just simply cannot do with relational databases okay so in a graph database you really have two types of data you have collections which are documents which we've been creating and then you have lines between those so picture them circles and lines all laid out in this huge graph each document is a circle and each line is like an event that connects one thing to another uh you could think of it in plain flights where flights connect one airport to another you can think of it as bitcoin where there's transactions that happen between one account in another account so those lines are called edges so let's go and create an edge collection here and we'll call it i don't know high fives dash fives so friends can now high five each other if we were to actually create something there's really two things that matter most if you're going to create a document i'm going to go ahead and manually create a document here you see we have this from and this to then optionally a key and then you can add any additional values that you want so the things that are hard required is it has to come from a document and go to another document i have to high five somebody i can't just high five nobody so as long as you specify that from in that two and you can add anything else you want you're creating an edge so i'm going to go into queries right now let's go insert from although i don't know anybody's ids let me go back here and look up some ids again uh 501 514 i should have remembered that by now let's have will high five bobby here so there we go um will is now highfiving bobby but we can also add any other values we want so we can say maybe uh hand coverage right how good of a high five was this was this one of those awkward ones where we're not sure if we should high five again or not uh yep it was 0.3 there we go we have now inserted a high five into the high fives collection let's go check it out there it is you can see that i've high fived from here to here and we have some really awkward level of hand coverage let's go insert some more high fives uh who else do we got here we've got 514 and 517 let's go and create that one let's have 5 14 high 5 5 17. let's say this was a much better one of those less awkward ones tada and now we've actually created some things so you can actually go into this graphs view which is super useful you can actually visualize the data that's in your database we're going to look at all high fives from friends to friends and then edge definitions are going to be the high fives so we're gonna look up any high fives from friends to friends now this could be any product sales from a person to a certain product or from a person to a certain vendor or store if you think about it there's a lot of ways we might want to visualize data but in this case we only have high fives and friends so this will take just a second and there we go you can see that 501 high five to 514 and 514 also high fived 517 so at this point we can actually start doing some pretty interesting searches i can say hey tell me anyone that 514 has high fived today i could also say hey tell me anyone that has high fived fort 514 today or i could also say hey tell me anyone that i've highfived that has also highfived someone else or is also highfived 517 you can go all the way down the train of things or you could say hey tell me anyone that is eventually high fived 517 in that chain let's go maybe maximum of five points of connection between me and that other person or if you have a whole lot of data sets you could query really easily tell me anybody that have high five today that has purchased a product on amazon.com and that product has gotten a rating of at least uh four stars and someone who rated it has also highfived the president of ukraine and you can do queries like that and it's native in graph uh we'll show you just how easy stuff like that is so now let's actually do a query it's going to be really similar to what we've been doing we're going to go for friend in and then we're going to do this tricky thing 1.1 so only one degree of separation right somebody i have personally high fived in outbound so this means a high five that i have sent off right it comes from me to someone else that's gonna who do i actually want to see if i've we're actually looking outbound from me so let's find will here 501 shouldn't memorize that by now and then high fives and we'll return friend oh and i made a mistake i forgot that i shouldn't have named this high dash fives that's a big problem uh because it's gonna look at it like it's subtraction going on so let's just change this to high fives i'm going to rename my collection high fives no dash at all now i can come over here high fives return friend and tada we can see that i have high fived bobby so i have this one outbound high five to bobby now if i change this from one to two you'll see i actually have two results i high five bobby but bobby high fived john so with a chain of events that's two away i've essentially chain highfived two people now bobby and john i've kind of got two degrees of separation from john one degree of separation from bobby i can also change this from two to two so anybody they've only chained high five man this this is so hard to say anybody that i've only chain high fived with two degrees of separation you can see only john i high fived bobby bobby high five john so bobby's not in this list because i'm only looking at two degrees of separation away not one to two degrees of separation so you can easily do some really interesting queries on the data i can also do inbound here and let's see who 517 has gotten any inbound high fives from he's gotten one inbound from bobby and he's two degrees of separation away gotten one inbound from will so you can also see if i change this from one to one then he's only going to get a high five from bobby it's native in graph databases to search on degrees of separation and things that would be really really complex with lots and lots and lots of joins take that example i said before anyone that i've high five that has bought an amazon product that has gotten five ratings that has a reviewer that is also whatever that's pretty complicated to do in a relational database that's extremely native to do in a graph database you just set up your objects which would be products and would be people and then you have some actions between them you have purchases you have reviews you have high fives and it's pretty simple to traverse all those actions and connect them to all those different objects graph databases are extremely cool for solving a lot of very tricky data set problems so that is your high level of how you use orangodb as a multimodel database working with documents working with key value stores and working with graphs so now let's look into some of its other awesome features let's go on to search i've gone ahead and i have added a movies collection and i have uploaded a json file of the movie lens database it's movie lens if you want to google for this data set so i have the whole movie lens data set here which is many many movies and i want to actually search them i want to search their titles and i want to do it in a quick elastic search kind of way so the way that i can do this is i can actually create a view let's go and create a new view let's call it movies view and you can see that it's automatically created a few defaults for me um that's stuff that i shouldn't have to mess with at least not right away out of the box about the only thing we have to do is we have to add some data to the links the links are the collections that we want to be able to search on you can actually have this one search view search multiple collections or just one collection the multiple collections is obviously very very helpful as lots of times when people are searching they'd be searching movies or actors or genres or any of that stuff and they want to do it all with one search so we're going to add multiple links we're going to add movies and we're going to add friends there we go we've added the friends collection you can see for an analyzer we picked text english we've included all fields and then movies as well analyzer text english and included all fields so now we can go ahead hit save and it is going to then parse through our collections make sure that that is all ready to go tada and we are good to go now we can run queries against our view itself and search friends and movies at the same time we can simply go for results of course you can call result whatever you want in movies view let's go ahead and do a search so there we go we are searching uh whoops doc dot name so anything where the name contains this or any of these values let's return the results whoops not doc it's called results and tada you can see that it returned a friend so if i change this to title title includes will then i'm going to see all the movie titles that have the word will in them i can also do uh i can also copy and paste this search phrase and do an or so i can search where titles contain will or where names contain will and now you can see i'm going to get a friend and i'm going to get a whole bunch of movies in my results set so i can search either or and instantly with simple little queries could search dozens of results set so you can see with just a few little moments of setup i can have a lot of what you get out of elasticsearch right out of the box you can get a whole lot more complicated than this but this is a nice overview of what you can do with search features okay one more feature i want to cover on this high level overview is the ability to add node.js microservices straight onto the database layer i think it's a really cool feature let's go to services and let's go ahead and click upload but we don't have anything to upload we need to go and make our service and then zip it up and upload it so i'm going to go to my code editor and i'm going to create two files i'm going to make manifest.json and i'm also going to create index.js you can call it whatever you want and then in manifest.json let's just go ahead and add a couple things so that is all i need to add in the manifest.json which engines it should run on and what our main entry point is which is index.js the rest of it from here is doing some nodejs so i'm going to create really quickly a basic router for you and then we'll show you how that works okay here is a basic router for the fox framework and as you can see it looks a lot like express.js i've done a few imports here let's grab the database let's grab the friends collection and let's create our router and then i can just do this which is a lot like express really the biggest gotcha is you have to do synchronous operations you cannot do async operations there's good reasons why it's in the documentation but if i just do git friends you can see that i'm going to send all the friends back so now all i have to do is zip this up let's go select these two files compress these two items and now i can actually drag it and upload it and have my first service going my mount point will be friends we're good to go and now i can go to this url here i'm just going to copy db system up to db system and i can go friends and now i actually have an http endpoint that is going to access my microservice i can get friends i can post friends i can i can do about whatever i want in this microservice i can make it to where when you send me a document i can parse it and normalize it and do a whole bunch of stuff and then save it across five different collections the sky is really the limit it's a true node.js microservice that you can do just about whatever you want in here and off the top of my head the the two best use cases for these fox micro services would be small projects where you don't want to have to build out a server back end you want the database authentication to be able to work across your api authentication you just have a small thing you need a few rest end points you can add them straight on top of the database layer and call it a day also on these larger use cases graphql can actually be pretty networking expensive sometimes and so if you add the graphql layer to the database layer it can save a lot of networking with the joining and the normalizing of data so those are two use cases that pop onto my head right away for what you could use this fox microservices feature for but there's a whole lot of things i'm sure you could do with these micro services in orangodb so that pretty much covers it we've got this multimodel db that can handle documents it can handle key value store it can handle graph it can handle search it can handle custom services you even have some data visualization tools built in in the form of graphs it's almost like a swiss army knife database i mean you install this you can get a lot without installing any other databases it's pretty pretty cool i really enjoyed i think you guys should mess with it at least know the basics of it know how to use it so you know that it's a tool in your tool belt that you can go for hope you enjoy this tutorial and have a phenomenal day you