in this video we're going to use a store pattern to abstract our data out of a single component into a shared file that multiple components can interact with it's going to help our application scale forward because while putting all the data inside of component data object might work well for a todo list soon you find yourself in scenarios where different components all want to access the same data and you don't want to have to pass it down through props over and over and over again and get complex let me show you a simple example here i'm i'm basically rendering three components here navigation friends and components navigation's gonna put the count of friends right here then this is obviously our friends list and we also want the count of friends down here um so right now we have friends list being populated right here in the friends component so for the navigation and footer to be able to get this information we'd have to take this data and we'd have to move it up to the app level and then we'd also have to pass it down through vbind into friends navigation and component which while that works for an application this size if you imagine a larger application that's a whole lot of passing down props and data and this is for a tiny bit of data if you get a lot of data it's just this top level view component would just be massive so that does not scale that does not work well so what we're going to want to do is we're going to actually create a separate store as many separate stores as we want to so that way all this data can live in a file outside of the view components that way our view components kind of act like a view level and then all the data can live somewhere else so we're going to do is we're going to go ahead and create a stores folder and inside of that let's go and create a friends store so there's our friend store now we can go ahead and go const friend store equals this is just going to be a plain old javascript object that we're going to export and i created it and then exported it for a reason because i want to be able to access it in here so we're going to do our data and then we're also going to do our methods and so methods in here could be some reusable methods like say add friend let's go and create some friends data here we'll do different data so we know that we're pulling it so we've got two friends and then add friend might receive a name and then we can go friend store dot data dot friends push so we'll just push that name onto the stack so that's kind of a way that you could then interact with it so that's why i defined friend store up here and then exported it that way it just makes it easier on my methods i can reference friendstore.data.friends so there's my one reusable method add friend and there's my data that can be shared by many components so i've created my friend store now we can come to our friends components and we can actually import that so now you can either just call this friendstore which will be friendstore.data because you'll remember we are referencing this now we don't want to reference the entire friend store in our data because this this isn't really data so friend store is now friend store.data and we can now go friend store dot friends and that will work now we're getting bobby and billy instead of whoever jack and john whoever the other guys were um and then here we're calling this add friend method so this can now go friendstore dot methods dot add friend and so this one i'll add a friend to the friends object and friend store which should be good and now that works and what's great about this is now we can do this exact same thing on all the other components other components can now access friend store there's no messy passing in of props uh i don't really care where friend store comes from or who all has access to it i just know that i need to have access to friend store and then i also need access to that data so let's go back here we're in the footer now we don't need that new friend so now i can say right here and now i have four friends five friends you can see that it dynamically updates just fine because it is listening to that object that friend store.data object it binds to it and is reactive to changes on it um that's super simple and then it's basically the exact same level of complexity to add that to the navigation there we go we're importing friend store we're spitting out friend store and now we can in the header as well we can spit out the length of friends we have up here um you could make a button down here that would trigger more actions against the friend store and the friend store components would all update so that's kind of how you can go with a store model a store pattern and we can also create multiple stores let's call this a different store i don't know tweet store call tweet singular to be consistent and we'll call this tweets uh whatever at this point it's a little overkill but we can take that tweet store and any other component can import the tweet store as well we can now import the tweet store we can set the tweet store here and so a component can now bind to multiple different stores it can add methods that interact with multiple different stores and what's great is is i don't actually have to have any of the logic for adding a friend here all i'm doing is i'm calling the logic of add friend all that logic can be reusable and live in friend store so that's kind of how you use a store pattern when you have to start scaling out the data of a view application you