all right we're going to be covering generators which are one of the most exciting yeah I'm just going to be honest they are hands down the most exciting and Powerful feature of the next version of JavaScript which is es6 harmony you can start using it now using Google traceur I'm going to put the link or I guess the name right there you can figure it out it's so easy to use um but generators are hands down a game changer I know that that's a big statement to say but it is completely true it took me a while to realize that they were a game changer cuz when you look at the specs of what a generator technically is at first it doesn't really seem like that useful of a thing um and then you have a light bulb moment and everything starts changing for you so I'm going to show you technically what a generator is how to code with it how to use it and then what that light bulb moment is and why it's going to change so much of the way JavaScript is programmed so here's a basic generator basically the only is it's got the star which is how you define it as a generator and then you can yield things you can set yield points and basically what a generator is if you were to Define it very simply it's a pausable function or an iterable function you can start running the function and then when you get to your yield it will actually stop running the function while JavaScript continues doing everything it's it's doing this function has paused and yield sits between the value you yielded and what it's passing on to the variable basically yield sits between here and what the rest of JavaScript is going to do when you continue your function because you know JavaScript basically runs right to left uh right to left right to left so you yield one uh let's go ahead and move on to this example um I'm going to run my gen which is the name of my function and store it as gen when I run it nothing really happens it just gets it set up nothing has started firing yet in my function until I run gen. next and then it runs until the first value has been yielded so here you can see value one done false um and then it's going to wait at this yield point until I run gen next again and so then it's going to return value two see there you go I yielded the the number two and then next time it's going to yield the number three and then the next time it's going to yield undefined uh because it ran the next the rest of the function and there's no more yields and it's going to say done true so now I'm done if I were to foolishly try to run next again it would error because you can't call next on a Clos generator so that's basically what it is you can pause it and yield stuff and it doesn't seem very useful yet does it um and there's actually a problem with my code here is this is going to console log undefined undefined undefined undefined because these values weren't set to anything remember when I said Yi field sits between here and here well basically whatever it's going to wait for something to be passed to the next gen next function so right now I'm not passing it anything so I yielded one out but when you resumed the function you didn't give me anything to pass back in so one is now undefined so to make this code work I'd have to yield one so I pass one out here and then I'm passing one back in to so now one does equal one and then two and then three so now it will console log one 2 3 um and I could actually if I were to yield 45a so basically ignore what you passed me I'm just going to pass in random stuff then one is now going to equal four and two is going to equal five and three is going to equal a and so because that's what I passed into the next functions so that's a generator um see pointless it's it's not let's say and here was my Lio moment let's say there's smart code that wraps a generator uh let's say you pass a generator to a smarter function that looks for promises if you don't know what promises are you need to pause right now and watch a video um that I'm going to put in the description my previous video on JavaScript promises um and then come back to here so let's say we had a smarter piece of code here and you were to pass it to generator say my gen and it would run that and get it ready to run uh and then it would run gen next and it would get that yielded value if that yielded value was a promise which this is a this is really dumb smart code you wouldn't check this way but you I'm just kind of saying say yielded value had a then method then it would wait for that yielded value that promise to resolve and it would pass that resolved promise into your gen next function so so then you could write code that actually did something like this so you can actually run code that said API friends so run API friends yield is going to see oh that's a promise I'm actually going to wait till that promise resolves and then I'm going to actually pass the resolved value of that promise back on to one so if API friends returns something like uh John you know just I don't know let's just say it returned a string of John then one would equal John whenever This Promise resolved ah super cool so now I can actually do something like this get friends get profile get tweets and it's going to run this wait for it to complete pass it into here and then run the next thing and now my code looks like it's just normal synchronous code but it's actually asynchronous code happening over the span of I don't know 20 seconds 20 20 hours it doesn't really care it's just waiting for all these things to fire back as successful oh my goodness that's super cool so how do I actually get this smart wrapping code there's multiple libraries out there right now that already provide it for you Bluebird co Q um if you're working on the browser side client side I'm going to say go bluebird um if you're working on node.js the backside I'd say go with Co um Q is actually already provided in angular so if you're using angular Q is the promised library that's baked into that U but you can do this you can run promise if you're using Bluebird promise. Co routine so here we go tweets equals yield get tweets and then I'm going to console log it that's it I got the tweets and I console logged them uh let's say I needed to do three things in order I need to get the tweets then I need to get the profile then I need to get friends well here you go it's going to wait for this on the yields pass it in then it's going to wait for for this yield pass it in going to wait for this yield pass it in when all three are successful it's going to fire them into here oh my goodness that is so cool uh but you can do even cooler things you can configure Bluebird uh to be able to yield objects of promises or arrays of promises I have an array of promises here uh so I can do an object here I can yield tweets and profile and it's going to run them both simultaneous ly wait for them both to succeed um and then it's going to pass them both into Data as tweets and profile and then I can console log data. tweets and I can console log data. profile by the way all this code I'm going to put into a gist and put that link in the description so you can access this code and see it um but you can also using um the new destructured syntax and es6 since you're probably already using Tracer um tracer sure however the French would pronounce that word correctly um you can use destructured syntax which means you can go there a b equals um 10 11 and what that's going to do is variable a equals 10 variable b equals 11 coffee script does that if you guys have used coffee script so I can say variable tweets profile equals yield and give it an array of these two guys and then I can just console log tweets and profile it is so cool it is so useful um I hope you guys love generators as much as I do I'm already using these things in production on several little projects and am so excited about them hope you have a great day and enjoy the rest of your JavaScript life