in this video we are going to talk about react state management and my favorite way to do it which is using mob x reacts lights use local observables we're going to take this flat app that we have right here we're going to actually give it some state and turn it into a real app very very quickly here's my two cents by the way on state management if you have a very simple app or a single component that has state that only affects that component use react use state unless that state starts getting a little complex even for one component pretty much any other use case use mobx react lights use local observable hook you're going to save yourself a ton of time you're going to enjoy your life a lot better it's easier to test it's easier for everything if you do have an app with extraordinary complexity redux might be something you want to move to maybe this can handle a lot of complexity but you really usually if you need redux what you should probably ask yourself first is can i break this app up into micro apps within one app that i'll manage a much simpler state much simpler event structures that then persist to a backend or persist to local storage or something so that way i have basically a bunch of micro apps that are much easier to work on i think the days of having this enormous monolithic front end react app with super complex state and event sequences most of the time that's just not necessary and it's a bad design pattern it's kind of a little bit more of a smell there are use cases where you need enormous complexity but lots of the time you can carve out individual micro front ends within your one big front end so off of that soap box let's get into having some fun let's turn this thing into an actual app so to use use local observable you basically are going to import two things you're going to import observer from mobx react light and you're also going to import use local observable now that i've got those in all i do is i wrap my actual function with observer after export defaults we wrap the function in observer come all the way down here add my closing parens and then you can use the use local observable hook so now we have to do store to do store is an observable object so anytime anything inside of it changes our component is going to rerender as long as it is wrapped in observer this is the number one thing that people make a mistake of if they start using mob x is that if you're not wrapped in observer your component is not going to change even when you change these values so let's say i could make a a test value here and a test method to change that value so there we go i've added a name of will and then anytime i run this change name function it will actually set it and that's all it takes so let's actually make use of this in a little test here all right so i've gone ahead and clicked this and i've reloaded my page over here and so now i am spitting out the to do store name and if i click the button definitely not will then of course i click it over and over and over again and it's always going to change it to the exact same thing but that's as complex as it is you set values in your local observable observable object and then anytime you want an action what would be considered an action that changes the data just add a method on that object this method could do a set timeout it could load asynchronous data it doesn't really matter it functions just like standard javascript and whenever this method mutates a value on the object your component's going to rerender whether it mutates it now or whether it mutates it three seconds from now now you can see that i've added a set timeout to it so if i click this it's going to definitely not will and then in three seconds it's going to do some hardcoded name it just works it just works all the time you don't have to worry about any creepy stale closures or anything like that that you oftentimes run into when you're using use state and react so let's go and actually figure out how we're going to connect this to our to do store app and have some fun we probably should make a to do's array now this is going to by default be an observable array observable arrays are exactly like normal arrays in terms of how they function although mobx does give you three very cool methods on it they give you dot clear dot uh let's see remove that's very very useful i can remove one item from there and they also give you dot replace which allows you to replace that with an entire new array besides that they are completely normal arrays so let's go and create a really quick delete to do method there you go that's all we're going to have to do to actually remove a to do from the array if if we are passed to to do we can say hey remove this object which will be an object in there let's go and create some first few objects and then wire this hardcoded data up to those actual objects there we go i made my first one we're going to need some sort of id so that way they can have a unique key and react a title whether or not they're pinned you can see we've got some pinned items here which is i guess the star is favorited could be also something else we call it uh is complete that'll give it a little scratch out and then is editing is false if we click on it then we're gonna change it to is editing and show an input box instead of a span field and then if we delete it then it's just going to trash it it's going to remove it from the todos array so we don't need it is deleted let's go ahead now and wire some of these up here all right what we've done is we're mapping the todo's out here we're spitting out the title and we're also going to spit out some buttons that just have emojis in them and they're going to fire these three methods toggle complete delete to do and toggle pin now we've already created delete to do let's see if that works yep it goes away nice so then if i refresh that's going to come back let's go and add a toggle complete method and a toggle pin method which will be stupid simple yeah if it's uh we're just gonna say hey is complete is the opposite of whatever is complete is right now and we'll do the same thing for pin and now check this out this is a very important thing so i've saved my file this hot loading has happened over here and if i check right here toggle complete i'm actually going to get an error hey toggle complete is not a function well clearly it is i added it over here on the left why is that the case if if the concept of hot reloading versus live reloading is new to you what just happened is is my component code down here hot reloaded but my state of my application did not reload and that is a very very good thing let's say i'm coding and i click 30 things to get my ui into a specific state i want it right i've clicked 30 things which mutated this store 30 different ways and now i've got my state and i just want to come down here and all i want to do is add an exclamation to the title right well that should happen but i shouldn't have to reclick the 30 things to get this state in some complex state in order to view my exclamation mark so what hot reloading does is on file changes your react markup will reload but your store will not reload until you refresh so i've got the old store that did not have these two methods in it that is what right now is in memory over here and any state changes that i've made so if i ever change the store i have to refresh the browser to get that that's a good good thing what it means is that if i trash this okay now i have state right my to do store has the to do deleted and i can go ahead and delete this title i can do a bunch of things and you notice my todo my todo is still gone because i've deleted it so if i want that to do back i just reload and then i've got my new store done so that's what hot reloading is a lot of people forget about the differences between live reloading and hot reloading live reloading would just refresh the page when a file change happens now but that does not happen here when a file change happens really only this code changes or or should i say everything that is not in this hook changes so that's important as you're working with mob x you're going to get a lot of those if you're not aware of what's going on so i've toggled my complete here i should be able to do this yep it's toggling but we're not noticing it because what i have to do is i have to create a complete class i have two css classes here one called complete complete is going to strike through it's just a visual thing and then i also have pinned and pinned is going to make it look dark pins should always be at the top and they should have that pinned class so what i need to do is now make this class name dynamic if my todo is complete then we're going to strike through yes we're good to go awesome and then later on i can add that pinned as well if we're pinned so in order to do that i'm going to filter out my todo's list using some helper methods some computed functions i can use a getter here and i can only return the todo's that are pinned and then i'm also going to make a getter function for unpinned to do's and then instead of mapping uh all the todo's i'm going to map the pinned todo's and then later down here i'm going to map the unpinned to do's i should make this all reusable code but i'm going to be lazy for the sake of this video forget about it so now the pins to do's are going to map up top the unpinned todo's are going to map down below you can see i've got that same error unpin to do is it doesn't know anything about it if i refresh my page it knows about it now and i'm going to make sure my pinned todo's always have a pinned class now i should be able to yes pin it unpin it sweet and if i add a new one let's do a create button that's going to be super easy to do create on click okay the create function is super super easy we're just going to push something onto the array and it's going to have a title it's going to have that it's pinned to false complete false but it's going to be editing true so that's fun we're going to get to add our editing here so now i should be able to create yippee i can create a whole bunch of them and let's go ahead and say that if our title or if we are editing that we don't show a span we show an input instead methods there we go and i'm also going to have a click event to just the span mode so if you're not editing and you click on the span then we're going to kick into editing mode okay now we should be able to kick anything into edit mode yes we can and we've got our name there and if we click away we are updating our name yippee that is complete so now we can click we can undo we can pin we can create some more things test 45 wow nice big leap there let's pin some of these let's unpin some of these let's trash this let's trash this and i think our app is done it was just a few minutes using use local observables is a ton of fun so where do we go from here right this thing's getting pretty big we could abstract this out in a really cool way here as it is just a plain javascript object we can import this let's go and create a stores folder in our project and let's create a todo's store i'm gonna capitalize it because it is not an instance it is something an instance is made for there you go i've just copied all of my logic and check this out for testing if we want to test our logic oh how simple will this be it is literally just a plain javascript object that's all it is now let's go back over here and we're going to import to do store and everything should still work just fine yep everything still works just fine nothing's wrong also if we want to now test our ui think how simple this will be we can inject any prefabricated state of the to do store right we can inject something that has 30 to do's we can inject something that has no to do's we can do whatever we want to do and we should expect that our ui will behave a certain way based on this thing right here being injected super super super cool it makes it really easy to test your logic versus your display layer just effortlessly uh really this is this is the pattern that people should be using another thing that you can do is you can go over to your app layer let's go to my app.js which is next js assuming you have some top level app component you could create a store right here you could create an app store use local observable then you could pass that through with the react context so then i have this like app store context that is getting passed down through my entire application and then i can come over here and i can use context and i can pass in the app store context if you don't understand how to do use context uh go ahead and look at the react documentations for use context and now i can modify app store just like i could anywhere else i could have 30 stores that are available on the app level and pull those in with context whenever i need them and whenever i don't it keeps the testing of things very very simple it allows this thing to be tested based on any app state on any to do state it just makes your life happy and as you can see in just a couple minutes we were able to build out this todo app so that's use local observable that's why it's my default it just makes your life happy and simple i encourage you guys to go test it out try it on some applications you don't have to overhaul your entire application to use it in just a few places it's it's a great tool it's what i encourage people to use as their default state management for react you