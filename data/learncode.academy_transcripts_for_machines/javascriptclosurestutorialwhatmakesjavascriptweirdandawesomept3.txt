all right let's get into some of the weightier issues of JavaScript here um now that you kind of know about the first class functions and why code looks the way it does event driven environment these are all kind of things that are created because of the event driven environment and so let's go ahead and look into uh what closures are in this video this is a very misunderstood and and oftentimes perceived as very complex thing to JavaScript that really isn't that complex of an idea if you if you think about it from the right perspective um let's look at it from an event driven environment perspective so um here we go on document ready function we want to alert a I'm going to go there a equals 1 so this function runs when the document is ready sets up this listener and this is going to be the only guy running when the button is clicked the problem is is this function already ran created a and it's done the function is finished but we don't want a to disappear because this function has to access it in order to alert it JavaScript notices this it notices that there's what's called a reference to something that is in a different scope um and so it keeps uh it keeps this variable a alive uh the textbook definition of a closure is something that retains State and scope after it executes so after this function executes it's going to remember the state I.E it's going to remember that variable a exists and that variable a equals 1 um and scope which we'll get into in the next one because that's a video all on its own but it's going to remember that this exists so anytime later on this function that references a has access to it um and so let's go ahead and see if this works here I'm going to go save every time I click it it's able to alert one and it's also able to modify it I can go A++ which if you're new is a fancy way of saying AAL a + 1 um so now it should alert to yep so now a exists it's been modified a now equals two if I click it again it's going to change a to three and it's going to alert it again so this a is in a closure this whole function ran uh but then all the variables of the function are saved off in memory land um and they're accessible by this guy as long as I exist so as long as this event listener for button exists a is stored in JavaScript memory it's a closure that JavaScript will not let go of as long as there is a reference to a so this is also where the JavaScript is really good at taking care of memory and the garbage collection cleaning it up but this is kind of your first introduction to what a memory leak is a memory leak is when you have maybe say a lot of variables in memory that you don't need anymore uh let's say this button is gone we don't need this button click event to happen anymore uh then we're actually going to want to go button off click that's going to unbind it that listener is gone there's no more no longer a reference uh this function is gone it's removed there's no longer a reference to a and so JavaScript will garbage collect this entire function this whole area here all the variables everything can now get trashed the memory can be freed up because JavaScript is smart enough to know that it's not necessary anymore there's no more code listening to it it can be garbage collected um and unless you do that I mean it's really not a big deal in most applications unless you get to really huge huge JavaScript applications uh because honestly remembering that a equals 1 is nothing uh you can do that a thousand times over and chrome does not care your browser is not going to get bogged down by a thousand tiny little variables um but that is what it means that's what a closure is a function ran uh the function executed it's done executing it's not ever going to execute again um and then is going to remember that there are references to certain VAR variables so it will keep those variables alive in a memory place that is called a closure if that makes sense that's what a closure is and let's get on now to scope and context