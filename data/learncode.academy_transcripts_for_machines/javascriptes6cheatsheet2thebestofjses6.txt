all right we're continuing with es6 so this is video two if you missed a video one you know you want to watch that first but doesn't really matter because this is new stuff so another great feature with es6 is block scoping at first it doesn't seem all that useful but then the more you use it the more you appreciate it so kind of us how scoping works now miniature scoping lesson where I equals one if I were to make a function here and go there B equals one well now this variable is in its own scope so after that function you know console.log B nothing happens because B was not finding scope so but if you were to do a block so this is function scoping then block scoping is like an if statement so there's no function going on this is within the block so if I define ver B equals two well now B is going to console.log to B has been defined basically it hoists it and then down here sets B equals to two that's exactly what's happening right now it's defining a variable in the scope and then changing that so what block scoping does is it allows us to use let and let define something within a block is really all there is to that so the two places you pretty much use blocks are if statements if else statements and loops you know for loops you know I don't know I'll just say 20 we're looping 20 times I'll say the the time of that so we're looping through 20 times each time we can now create a new B variable that is new for that loop and gets destroyed after that loop so it's only used within this block so that's that's actually really nice as a general rule when you're coding es6 it's just simple to remember let is the new there you really don't need to use ver most of the time unless for some strange reason you want to define a variable in this block in this if block that needs to now be accessible outside of this block which is pretty much a bad idea anyway because you probably should be defining there be up there if you're going to do that and then changing b22 that's kind of more the correct way of coding that so start using let instead of air that gets you 80% of the way and then there's also this new Const foo equals one constant is exactly the same as let so allow shouldn'ts it's exactly the same it's the same as let in that it's block scope so bar equals two and I try to log bar nope get an error bar is not defined because it's outside now if I change this to vert bar well now bar is going to be two because there is function scoped but changing this to constant is again block scoped and constants cannot be overwritten so if I were to and then try to change bar to bar equals three and get an error that doesn't work now if it's an object you can't change it to a different thing but you can't change that object so if I say bar a equals one and that's got a one left that I said to then I can change that so I can mutate bar somewhat as an object still I choose to call all my objects constants because you know anymore we're really starting to realize as JavaScript developers that mutating a value most of the time is something you don't want to do you want to define most values as constants actually so I'm starting to use Const as my default and then should there be some reason where I need to mutate a value well then I'll change it to let so it's kind of like this visual indicator oh that's let this value is going to get changed later on so that's actually kind of a really good practice that me and my team have found is use constants for everything absolutely everything everything is a constant and then you shouldn't usually have to change values of things and if you do have to change value well then you see let and when you see let it's kind of like this little pop in your eye okay this value is going to change for some reason I need to be aware of the fact that this is going to change that's kind of a good practice we found there let's see next let's talk let's do classes can't believe in and mention this yet so classes are a huge deal for JavaScript to have now it's not necessarily huge functionality it's just that every other language pretty much speaks in terms of classes so you know for those you guys you may not know it which shouldn't be most developers but you know you could do function parents and so this is your constructor and then you'd have to go parents dot prototype dot foo equals function you know so adding you're adding your functions that way just really not that bad but now you can actually go class parents and then I can go constructor and then I can actually go foo bar then I can go over parents equals new parents parent foo do some things and then also with ex7 which so if you're using babel you can transpile es7 just find I'm not sure if tracer does it or not you can also define some static class properties which is me a seven thing I can go age equals 34 and then parent age equals 34 so that's also nice you can add some static properties that was not a part of the initial es6 spec to have properties or static properties I can also go static foo and then parent is actually going to that's going to be parents dot foo is going to be that method so that's also kind of nice which again capital P parent that is foo going on here not lowercase P parent which is this so the reason I call that parent is because then you can extend things which is nice you don't have to have some sort of little utility method that you write yourself child e extends parents just as you'd expect it to be I get my own constructor can't call super which is going of course call that guy and then I can add my own fubar Bozz so I can go a new child and then child can do Bozz or child can do foo because I've inherited all them actually child can't do food because that static child can do Bar there we go and so that's kind of your es6 classes and then let's go ahead and look at let's go look at arrow functions I like arrow functions there's also generator functions which are the huge new functionality so this adds a lot of new power to JavaScript a lot of new powers especially in how you handle async I have a video that's dedicated to generator functions I'll put the links to that in the description because they're a little complicated to understand the first time around they're simple but they're complex so I'll leave you those links let's look at arrow functions arrow functions arrow functions at first seem just like a new syntax for writing functions but the more you use them the more you very much enjoy them and the more you understand some of their intricacies so if I was to say very few equals a function and then we're just going to return a plus B there we go so you can write this as an arrow function and you can go very foo equals a B arrow and then I can return a plus B so at first it doesn't seem like that big of a deal if I want to convert this function to an error function I just delete function add an arrow okay well that's kind of groundlevel it looks a little bit cleaner a little less typing but then there's actually some more things that they add for you so it's it's mostly found very helpful when you're passing functions as arguments so do something with a and B as a callback right so we're going to do something there well that definitely clean sup I call back their return a plus B so if I was to convert this to an arrow function I could really make this a oneliner and it gets a lot cleaner so that's nicer now it's a little bit more visual CoffeeScript did a good deal with this this seems to be a cue that they took from CoffeeScript which was nice and then there's also what's called implicit returns and this is only applies to oneliner so if there's a oneliner I'm able to drop these curly braces and whatever is here automatically gets returned so I can just do a plus B so this is the exact same as what I had going on there ah now we're starting to really see some clean stuff so again I can do with brackets return a plus B or if I'm dropping those brackets I if I'm keeping it to one line I can drop those brackets and drop that semicolon and it's just going to automatically return a plus B so that's very cool also if you're on a oneliner and you only have one argument I can drop these parentheses and I can just return a plus one or a plus plus so now it's gotten a lot cleaner so if I just want to make a function that increments things like say I want to map something 0 1 2 I don't want to increment all these I can map these as Val there you go so now that's going to give me 1 2 3 so that's really nice it really is useful for things like mapping for filtering sorting lots of those underscore j/s methods very very useful to do arrow functions in there and then there's one more thing that's very very it can be tricky you can forget that it does this and that is it's a it automatically binds context to this it's called lexical context binding and so kind of how this would work is if you ever do a function you want to bind it to this let's see I just actually do it code out an example you're very module equals my age is 30 I just actually 34 but whatever then Fu's some function and this is going to console.log this dot H okay that's going to work just fine it's going to say you know console.log 30 so if I run module foo it's going to automatically log 30 but then let's say I do a set timeout I want to time that out and one second later console.log this dot age well that's not going to work because now this is a completely different anonymous context and I no longer have access to this that age so you know you used to have to fix that by then binding this which just really feels janky but that's kind of how you'd have to do that or you'd have to code the function out somewhere else and find the function so that arrow functions automatically do bind this so that right there is the exact same thing so now this within this function automatically points to module it points to the context that you're in so that's something that's very important to be aware of because if you're say I'll use jQuery as an example I'm doing some thing with jQuery and you give it an arrow function well now you have overridden jquery's value of this so you can't do this anymore because normally jQuery would set the value of this to be you know your event handler or if you're using an event binder an event listener that's something you got to be aware of you probably would want to use function instead because you need jquery's this value or you really need that Dom event listeners value you do not want this to be whatever the value of this is so whatever the value of this is here is going to be the value of this for an arrow function in here so that's something that's very very important so lexical binding so that's a very important thing that goes on with arrow functions let's look into but once again that's that's extremely helpful the vast majority of the time it is extremely helpful for this to be bound to whatever is outside of it so most of the time I feel like that's what you want to happen last but not least let's look into es6 modules so module systems you know you're probably using require my module there you go and so how my modules defined inside is going to be module exports dot two equals function you know there's that and then of course you're going to export bar and then to import these later you know in another file you've got to go over my module equals require my module and then you've got to go there foo equals my module dot foo blah blah blah and so to do this now you could just change this to imports foo or import my module may I can't type this one import my module from my module so that's what you would do in node or if you're using require.js browser fire web pack so that's actually a lot cleaner these really stand out as I'm not your code I'm an import so these at the top of the file they do have to be at the very top of the file so way down in the file you cannot do an import these have to be at the top but it's nice this syntax really stands out as just it just feels correct at the top and you can also do structure this so I could I could go foo bar from my module so now I'm not actually importing the my module variable I'm just defining two variables in my scope foo in bar so that's really nice I'm finding this very useful for libraries like lodash so I could load in each and I can load an omit from lodash and that really helps with more functional programming styles I can then somewhere in my code just omit omit some key so that's really really nice if you're using a library like lodash just pulling the things you need right up front feels very very cool and then you can also in your code how you would actually write your module different if you wanted to is you could just do I guess your third way of exporting things is you could actually just replace module exports with a function itself so so then all of module exports is replaced with this function so how you would recode this with es6 modules is you would actually just go exports export default function or you can actually just export any any variable as its name so export function foo so that's actually kind of exporting foo which can be imported as foo and then you can also export bar or I could export their foo equals three which is very nice so I'm defining this variable in here and I'm also exporting that variable so then I can import food which would be three here I can import bar which is method you can also do some add stuff as foolish so that's going to console.log three because I'm exporting foo and I'm importing food as foolish and console logging foolish so this just really cleans things up it's it's a syntax that I feel like JavaScript needs now that it's more modular at first I didn't really care about the export default oh yeah then if you want just to do my module say my module needs to be you know the whole thing then I can just do export I already showed you that export defaults that can be some whole module that you export there but I already showed you that so you don't need to see it again and I like this syntax a lot like I said I really like this really like being able to D structure out what you need from the very top so that's kind of my take on es6 so far I'm loving it love and love and loving it love and using it and I guess one more useful thing if you had a chance to look at the generators video this will make sense if you didn't look at the generators video yet this will not make any sense at all but you can do what's called async functions especially if you're using Babel j/s to transpile then they do what's a called async functions so you could do a sinc function and that's basically a generator function so whenever you define an async function it's a generator function and anywhere inside instead of doing yield you can do awaits so it's called the async await syntax so I can await some some promise like say jQuery dot gets since everybody knows jQuery they're friends equals some sicom slash friends so we're going to go ahead and get that I only have one friend and then I can console.log that as if it's already been received so async functions are basically converts them into generator promises generator functions that return a promise so then I can actually this whole function now returns one promise that is then able that's kind of the short of it but if you look into Babel j/s async functions are very very cool especially if you're doing a whole lot of async stuff like a node or something like that very useful so that's es6 in a nutshell hope you enjoy the videos have a great day