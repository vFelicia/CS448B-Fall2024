okay we're on the home stretch we basically have our whole App working the way we want to within the coros cluster uh these guys are we can run as many web instances as we want Dynamic load balancing is taking place we have one problem left to solve and that's that just like our app instances we don't know the IP addresses and the port numbers of our enginex load balancers because they're going to change all the time if we need to run three of them or if this one dies and gets scheduled over here it's going to have a new IP address and a new port number uh so we need to add two other things to complete the picture we need something static we need a fixed IP address that we can run DNS to so let's say we're doing mysite.com um I added a host entry for subdomains on mysite.com to point to this IP address right here uh which is this IP address this is going to be a DNS so in digital ocean my DNS for my site.com is going to point to this IP address um and then this guy port 80 which is HTTP and Port 443 for S uh for SSL are going to automatically load balance between all of our enginex instances we're going to create subdomains so say some app can be accessible by some app. my.com and if we add I don't know say a forms app then forms. then we all our forms load balancers will be accessible by forms. mysite.com or maybe there will be a path so mysite.com form fors will automatically point to our forms load balancers so that's what's going to happen up here and we're going to basically do the same fix we did for our app service Discovery is we're going to have our enginex load balancers register themselves to an etsd registry that this guy can watch with confd and reload himself so the exact same thing uh just a slightly different take on it um what we're doing is we're going to create our own ETD registry a new one because it's a bad practice for any anything outside of this core cluster to reference the internal ETD registry that's a bad practice so we don't want to use this one we want to use one that's outside of our core cluster uh that our engine X load balancers can watch so we're going to create ideally you'd create a cluster of them so there's failover you know three five or seven uh in this case I'm just going to do one and then also ideally you don't want one copy of engine X being your gateway to your whole app because if that goes down your whole app goes down um the ways around that is you'll share the same IP address uh with keep alived so you actually run two copies of this and uh one guy gets the IP traffic and if he goes down that IP address points to the fail over one um on AWS on Amazon that's called I believe a elastic IP because everything to Amazon is elastic uh they call it a oh what do they call it for digital ocean flexible IP or something like that um so they've got different names for all the services almost everybody except for Rackspace has that uh virtual IP that you can share um and you can look up how to do it on each of those services for this example to make it really easy um I'm going to create this registry and I'm going to make it public so we can actually look at it with our web browser you do not want this publicly accessible though uh because you don't want anybody to be able to write files to your ETD registry and have your application load balancer try to reconfigure itself that's a really terrible idea um but I'm going to actually make it public so we can watch it um so what I did is I spun up a core OS machine that's kind of act as our ET and our engine X for this example we'll just make it really quick and dirty uh let's go SSN core at uh Docker PS I ran ETD I just kind of ran the the docker Etsy image and so that automatically is publicly exposed to Port 2 379 so I can go to this IP address Port 2379 that's my IP address uh and then V2 keys and you see I've got a subdomains kind of key folder set up right there so any subdomains that show up in there I want to create an engine X that load balances between them we've kind of already solved that problem with conf d for engin X load balancer uh Docker image that we've created so we're going to copy this we're just going to make a couple little changes to it one in our uh in our engine X toml we're going to watch a different key structure cuz we're talking to a different eted registry we're not talking to this registry now we're going to talk to this registry uh so we're going to instead of looking at Services some app Upstream we're just going to watch subdomains and that's it and for our example our engine X template looks a little different whereas before we always just proxied into app which was an upstream of multiple servers which is what you should be doing um we're just always going to in this case just proxy pass to one fixed server cuz again for my example here I'm assuming you never have one more than one load balancer for each app now for this example so there we go do a Docker build do a Docker push uh in this case I did a Docker build and dock Docker push I called it will r/ engin X DNS there we go and so that's going to get one thing all I need to do is I just need to give it my etsd um let me show you confd watch only only variable I need is where how do I access eted as long as I know how to access ETD everything else is kind of configured in the toml here I'm watching the subdomains key uh so let's go ahead and run this container and we should be good so Docker run we're going to run it as a Damon in the background we're going to expose Port 80 internal to a fix Port 80 external because it's getting HTTP traffic uh and then we can also do Port 443 if we're doing supporting SSL um I'm giving it ETD and ETD is running in this case on my same machine IP address which is this guy here so that would be a cluster somewhere else but 2379 and name is DNS and we're just going to run will R Stern if I could spell my own name engine X DNS there you go so that's running it's configuring itself right now um and now all we need to do is we just need to uh now have our load balancer register itself because remember uh this guy's got to register itself to the ETD registry so to do that is very simple I just added an exec start post we can really do two things we can either um add a sidekick service that does this for us just like we did with our SU app service or you can do it this way which is the sidekick service would be a better way of doing it but to show you the other way I can just do an exec start post so after my load balancer starts up I'm going to do a put to that there's my IP address again I'm going to put to etsd I'm going to register myself as some app and I'm going to give it my public IP address and my public Docker port and these are kind of those clunky commands to sniff out my IP address and to sniff out my Docker Port there might be cleaner ways of doing these I'm not the most awesome person in the world at gripping stuff out but these two commands are basically going to send my port number and my IP address um I'm not registering you remember from flannel everybody has this internal IP address that's not going to work because that's going to be internal to the coreos cluster um what I've got to do is I've got to do an IP address that is internal to um that is my publicly accessible IP address um so I'm going to do this IP address here and then I'm also going to do the docker Port that that's exposed to now if this is on the same subnet that I might be able to do that flannel IP address and automatically do Port 80 uh but in this instance I'm just going to do the IP address of the coreos node I'm on and then the automatically created Docker Port gosh that's a mouthful I'm register in myself that's all it is people I'm registering myself and here's the command look into it more if you want so I've actually already submitted this new service definition to Fleet and I've restarted that so if I actually go Keys recursive true you can see there's my submission and what I used 15 sentences to tell you is I submitted the IP address and the port number so I could go straight to this if I wanted to and you can see it's load balancing between 1 2 three and four excellent so that's the direct IP address and port number to this guy and then he should have picked up on that by now and created a subdomain called I think I called it sua yep he should have created a subdomain called sua Su app. mysite.com there we go that is now automatically generated DNS again I have a host entry on my computer I added so every subdomain from mysite.com comes to this IP address so there you go that's it we've wrapped it up we have completed the circle um and that's it so this is the only guy that actually has any kind of public IP address everything else is hidden we don't need to access etsd in the browser like I just did um and there you go hopefully the series helped you out um love to hear any feedback on it there are services that you can use in place a lots of these things you don't have to use core OS you can use um Apache mesos you don't have to use eted you can use uh gosh what's hashy corpse got console there's many other ways to do that there's other ways to do the DNS portion but this is a way to do it so have a great day and enjoy docker