With timestamps:

00:00 - hey guys in today's video we're going to
00:02 - be going over cs50 problem set to caesar
00:05 - so make sure to subscribe to the channel
00:07 - if you haven't already because i'm going
00:08 - to be posting cs50 solutions every
00:10 - single week
00:12 - let's jump straight into caesar now
00:14 - okay
00:15 - so the point of caesar is actually to
00:17 - encrypt some text based on the user's
00:19 - key
00:21 - what does that mean
00:22 - so let's say a user runs the program
00:24 - right the program is called cesar with
00:27 - dot slash caesar
00:29 - that means the user has chosen the key
00:31 - to be one so what does that mean
00:34 - so if the user types the letter a
00:36 - our program would need to print out the
00:38 - letter b
00:40 - so depending on the key so the key is
00:41 - one so a prints out b because we need to
00:44 - convert a to b we need to skip one step
00:46 - based on the key okay
00:48 - so similarly b is converted to c and c
00:51 - is converted d right it just moves one
00:53 - step
00:54 - based on the key so let's say the user
00:56 - types dot slash caesar two
00:59 - so now the key is two
01:01 - so if the user types in the letter a we
01:03 - need to print out the letter c right in
01:05 - other words is the plain text what the
01:07 - user types in
01:09 - and c is the cipher text or what our
01:11 - program prints out
01:13 - okay and so on and so forth he can be
01:15 - any number right this is just examples
01:17 - so our program needs to prompt the user
01:19 - for plain text right would they type
01:21 - whatever they want and then we convert
01:23 - it to ciphertext
01:25 - based on the key
01:27 - right
01:28 - okay so let's just give an example here
01:30 - let's use user types in dodge slash c01
01:34 - and for the play text they type in abc
01:37 - so our cipher text we need to print out
01:40 - bcd okay
01:42 - and notice here how it's case sensitive
01:44 - so capital a turns into capital b
01:47 - lowercase b turns into lowercase c and
01:49 - uppercase c turns into uppercase d okay
01:52 - so the case still remains
01:55 - and also if you notice here for the
01:56 - first time we've not had this in preview
01:59 - in previous problem sets
02:00 - is that the key is not a normal input so
02:03 - we don't use get string okay
02:06 - rather it's actually on the command line
02:08 - itself so in previous problems that's
02:10 - what we used to do is just run like dot
02:12 - slash scrabble dot slash readability but
02:14 - over here we run dot slash caesar one or
02:18 - dot slices or whatever the key is right
02:21 - so that's why we now have a command line
02:23 - argument
02:24 - so rather than using int main void like
02:26 - we used to do in the previous problem
02:27 - sets we now run this int main in rxc
02:31 - string arc v because we now have taken
02:33 - input on the command line rather than
02:35 - just leaving it void
02:37 - okay so i hope that makes sense so far
02:39 - and now there are two conditions for the
02:41 - command line argument right what are
02:43 - they so first what is what does argc
02:45 - mean
02:46 - rec is an int and it's actually how many
02:49 - arguments there are okay
02:52 - so argc so the first argument here is
02:54 - the dodge caesar
02:56 - and the second argument in this example
02:58 - is one okay so argc is equal to two
03:02 - okay so the first condition is that arg
03:04 - c always has to equal to two
03:06 - dot slash caesar is the first arg c
03:09 - and the second one is the number right
03:11 - the key
03:12 - so for example we can't have
03:14 - a dot slash caesar one space one because
03:17 - that doesn't make sense right that we
03:18 - don't know what the key is so that's why
03:20 - rxc always has to be equal to two
03:22 - and y so in this case rc is three right
03:25 - that's less than one one so that doesn't
03:27 - make sense
03:28 - and it can't be one rxc can't be one
03:30 - either because then it'll just be dot
03:31 - slash caesar that's the first argument
03:34 - so it always has to be rxc is equal to
03:36 - two dot slash caesar and the key two
03:39 - arguments
03:40 - and the second condition
03:42 - is that argv one must only contain
03:44 - digits okay
03:46 - so why is that
03:48 - uh
03:49 - let's take an example over here arc v0
03:51 - is dot slash caesar right so that's fine
03:53 - arc v1 must only contain digits because
03:56 - let's say the user types in dot slice
03:58 - user x
03:59 - but we don't know what the key is right
04:00 - it doesn't make sense
04:02 - or let's say they type in dot sizes are
04:03 - 1x right that doesn't make sense either
04:06 - so our v1 must contain only digits okay
04:10 - so those are the two conditions and if
04:13 - it doesn't fulfill these conditions both
04:14 - these conditions have to be fulfilled
04:16 - otherwise we need to print
04:18 - usage dot slash user key
04:21 - which basically is just telling the user
04:23 - how to use the program successfully okay
04:26 - how to use the program correctly
04:29 - so let's try to put this whatever we
04:30 - learned into code and it should be
04:32 - simple enough right
04:34 - so
04:36 - if
04:37 - we knew the first one is rc needs to be
04:39 - 2.
04:40 - so if rc is not equal to we need to
04:42 - print the error message and return one
04:44 - right quit the program
04:46 - so if rxc is not equal to 2 and how do
04:49 - we say that
04:51 - we actually said by using exclamation
04:53 - mark and equal to
04:54 - so this just means if rtc is not equal
04:56 - to 2
04:58 - what should we do
04:59 - we want to print the error message which
05:01 - tells the user how to use the program
05:04 - print usage dot slash user key
05:06 - and we also want to exit right we want
05:08 - to return one okay
05:10 - the second condition
05:12 - is
05:13 - argue one must only contain digits
05:16 - and over here we actually need to use a
05:18 - loop
05:19 - why do we need to use a loop because we
05:21 - actually need to go through every single
05:22 - character of argue one and determine
05:25 - whether or not it's a digit
05:27 - okay
05:28 - so
05:29 - again so let's say it was just uh dot
05:31 - slices or one x if we didn't use a loop
05:34 - it would just check for the first
05:35 - character
05:36 - whereas we need to actually go through
05:38 - entire rv one and check one by one is
05:39 - this character digit is this character
05:41 - digit or not okay
05:43 - so that's why we need to use a loop
05:45 - so
05:46 - we can use a for loop right and by this
05:48 - point we know how to use for loops from
05:50 - all the previous problem sets so let's
05:52 - say end i equal to zero let's set an
05:54 - index and set to zero
05:57 - and i
05:58 - needs to keep on going as long as i is
06:00 - less than the length of
06:02 - arc v1 right
06:04 - so i is less than sterling
06:08 - arc v1
06:09 - right
06:11 - i plus plus
06:13 - which basically means go through the
06:15 - entire arc v1
06:17 - one at a time starting from zero and
06:20 - what do we need to check for
06:22 - if it's a digit then we need to print
06:24 - the same error message
06:25 - but how do we actually check whether or
06:27 - not something is a digit
06:29 - well it turns out
06:31 - there is a formula
06:33 - called is there's a function called is
06:35 - digit right
06:36 - and again we wouldn't know this this is
06:38 - not common knowledge it's not common
06:39 - sense you would know this uh because
06:42 - first of all it's in the cs50
06:43 - explanation right and also by just
06:45 - playing around with the cs50 manual
06:46 - learning different functions things like
06:48 - that
06:49 - okay
06:50 - so we need to check if it's a digit
06:51 - right and this is under the header file
06:53 - called ctype.h
06:56 - so let's include that
06:57 - and also if you remember from the
06:59 - previous
07:00 - problem sets sterlin is actually under
07:03 - the header file called string.h right
07:07 - so for to use sterling we use string.h
07:09 - as well
07:10 - okay so we've used those header files
07:13 - so
07:14 - if is digit right so we need to check
07:17 - whether or not it's a digit
07:19 - uh according to this arc v1
07:22 - so if
07:24 - it's not a digit then we want to return
07:26 - an error and quit
07:27 - so again if exclamation mark is digit
07:32 - arc v1
07:34 - i
07:36 - right
07:38 - what do we need to do
07:40 - we want to print again the exact same
07:41 - thing as we printed before
07:43 - users
07:44 - we need to print the error message as
07:45 - well as return one
07:48 - okay so i hope that makes sense so far
07:50 - right we fulfilled the two conditions
07:52 - because
07:53 - as we said rc needs to be equal to two
07:56 - so if it's not two then quit the program
07:58 - and print this error message
08:01 - and arg v1 needs to only have digits
08:04 - right so we loop through the entire rv1
08:06 - one character at a time
08:07 - and if it's not a digit
08:09 - then
08:10 - print this error message and quit the
08:12 - program right so we've reached here so
08:14 - far
08:16 - but now we we know logically that the
08:18 - formula to convert
08:21 - plain text to ciphertext is actually
08:24 - plain text plus
08:27 - key
08:29 - plain text plus key will give you cipher
08:30 - text right this makes sense
08:32 - so let's say a plain text was a well
08:35 - like what the user types unless the user
08:36 - types in a and a key of one
08:39 - we have to print out the cipher text
08:40 - which in this case would be b
08:43 - right so that makes sense so far
08:45 - um but again so we we know that key
08:47 - needs to be an int right the key needs
08:49 - to be an integer so that we can use we
08:51 - can make a formula out of it to later
08:53 - convert plain text into ciphertext
08:56 - but
08:57 - if you notice here
08:59 - our v
09:00 - which is where the key is rv1 is
09:02 - actually a string right
09:05 - so it's a digit
09:06 - but it's considered a string so let's
09:08 - say the key is one
09:10 - well it's still a digit number one but
09:12 - rather than counting it as an integer
09:13 - where we can do mathematical functions
09:15 - with it it's counted as a string
09:18 - okay so we need to convert the key into
09:20 - an integer so that we can do math with
09:22 - it right
09:23 - okay
09:24 - so okay so in this example here dot
09:26 - classes are one
09:28 - one is a string okay even though it's a
09:30 - digit it's still a string it doesn't
09:31 - count the computer doesn't count it as
09:32 - an end because arc v is a string
09:36 - so we need to convert it to an integer
09:38 - right
09:39 - so let's see if there's a function to
09:41 - convert a string into an integer
09:43 - and it turns out there is and again this
09:44 - is not common knowledge whatsoever right
09:46 - uh
09:47 - you need to know this by either reading
09:49 - cs50s explanation or by just going
09:52 - through the manual and figuring it out
09:53 - yourself
09:54 - so it runs out of this function called a
09:56 - to i
09:57 - which converts strings to an int right
09:59 - that's the definition here
10:00 - and that's under the header file
10:02 - standard lib.h okay
10:04 - i'm just gonna include that
10:07 - okay
10:08 - so we know we need to have a key right
10:10 - we have a key but now we need to convert
10:12 - the key into an integer
10:14 - so let's just make an end let's call it
10:16 - in k for key right just to make it
10:18 - easier to remember
10:20 - a to i
10:21 - which is just convert string to integer
10:25 - arg v1 right
10:28 - so we defined a variable called k which
10:30 - is an integer
10:31 - and now
10:32 - we assign the value of the key as an
10:34 - integer into k okay so k for key just to
10:37 - make it simple
10:39 - and now what do we need to do
10:41 - well now we need to actually prompt the
10:42 - user for some plain text and how do we
10:44 - go ahead how do we go about doing that
10:47 - very simple it's been there since
10:48 - problem set one which is just using the
10:50 - get string function right
10:52 - so string plain text to get some string
10:56 - from the user
10:57 - get string right this is to get a string
10:59 - from the user
11:01 - uh let's say plain text
11:05 - okay
11:07 - okay and now we want to print out the
11:09 - cipher text okay
11:12 - so get string plain text and we want to
11:13 - print
11:15 - with cipher text
11:18 - and then we actually now we need to use
11:20 - the formula and everything to get the
11:22 - actual cipher text so what we've done is
11:24 - prompted the user for plain text and
11:26 - then print out ciphertext and they print
11:28 - out the actual ciphertext so print out
11:30 - the word ciphertext colon and then the
11:32 - actual ciphertext
11:34 - okay
11:35 - so now first things first as we know
11:37 - from scrabble
11:39 - and even readability
11:41 - we know that
11:42 - uh different keys
11:44 - according to ascii
11:46 - the lower case and uppercase are they
11:48 - have different values right
11:50 - so if you remember actually uppercase a
11:52 - has an ascii value of 65 whereas lower
11:55 - case it has a has an ascii value of 97
11:59 - right so we know that over here
12:02 - according to our program it needs to be
12:03 - case sensitive right
12:05 - so we can already determine somehow that
12:07 - we need to treat uppercase letters and
12:08 - lowercase letters are differently
12:10 - because they have different ascii
12:11 - positions or ascii values
12:13 - so
12:14 - okay so we know that so now what we need
12:17 - to do is we actually need to make a loop
12:19 - to go through the entire a plain text
12:21 - one character at a time and convert it
12:23 - to ciphertext right
12:25 - so let's first of all let's go ahead and
12:26 - make the loop
12:28 - and again let's use a for loop again we
12:29 - should be very familiar with for loops
12:31 - at this point we should be comfortable
12:32 - manipulating them
12:33 - so let's make another integer let's call
12:35 - it j because we've already used i over
12:37 - here
12:38 - so if j equal to zero
12:40 - keep on going as long as j is less than
12:43 - the
12:44 - stirling of what this time strata of the
12:46 - plain text
12:49 - and j plus plus
12:52 - okay so what this for loop means just
12:55 - set and make a variable called j
12:58 - index it to zero
12:59 - keep on going as long as j is less than
13:01 - the plaintext as long as the less than
13:04 - the length of the string of the
13:05 - plaintext right
13:07 - and j plus plus which just means go one
13:08 - at a time
13:10 - okay so so far this makes sense
13:12 - and our first instinct here right and my
13:15 - first instinct here so there's no shame
13:16 - in that is
13:17 - printf
13:19 - and what do we want to do we just want
13:20 - to print the character and what
13:22 - character we want to print
13:23 - we just want to print plain text right
13:26 - plain text j
13:28 - plus k
13:30 - and this is what makes logical sense for
13:31 - everyone right
13:33 - so you the cipher text you want to print
13:35 - the ciphertext right
13:37 - so it placeholder c so we're going to
13:39 - print the ciphertext which so far what
13:41 - we think logically is just
13:43 - plain text whatever that is
13:45 - plus k which is the key right so let's
13:46 - say it was a
13:49 - let's say the plaintext was a and the
13:50 - key of one well then we would want to
13:52 - print out b right we want to print the
13:54 - singular letter b character
13:56 - so this makes sense
13:58 - but there's actually a flaw with this
14:00 - because
14:01 - let's take a look here
14:03 - what if
14:04 - someone typed the letter z okay which is
14:06 - very common right
14:08 - so let's say someone type the letter z
14:10 - capital z and that has an ascii value of
14:12 - 90
14:14 - right and let's see someone just put a
14:15 - key of one symbol
14:18 - so
14:18 - that it would convert it to whatever is
14:20 - ascii position of 91 right z which is 90
14:24 - plus 1 according to our formula here
14:28 - so 90
14:29 - plus 1 would give us 91.
14:32 - but what is actually in the ascii
14:33 - position of 91 what is the ascii value
14:35 - of 91. well we don't know right i mean
14:38 - it's probably a comma or an exclamation
14:40 - mark or some other random character
14:42 - whereas what we don't we don't want to
14:44 - print that random character
14:46 - if someone prints out the letter z and
14:47 - has if someone inputs the letter z and
14:49 - has a key of one we actually wanted to
14:52 - loop back over to a
14:54 - right
14:55 - so if if it's a z with a key of two we
14:58 - wanted to loop back over to b
15:00 - right we want to loop back over the
15:01 - alphabet essentially rather than just um
15:05 - printing out some random character in
15:06 - ascii going over the bounds right going
15:08 - overbound
15:09 - so
15:10 - what do we need to do here
15:12 - well so we know that this doesn't work
15:14 - because we can go overbound with this
15:16 - right
15:17 - so what we need to do is actually
15:20 - and again if you've done scrabble this
15:22 - might come a little naturally to you and
15:24 - i hope you've done scrabble if you
15:25 - haven't go go back and watch that video
15:27 - first do readability and then only come
15:29 - to caesar okay
15:32 - so how do we get this plain text plus
15:35 - key
15:36 - to loop back over
15:38 - once it goes past z so there are a few
15:40 - simple steps
15:42 - so the first step is
15:44 - reset the values so that the alphabet
15:46 - starts from zero rather than 65
15:50 - right and this is very similar to what
15:51 - we did in scrabble so we need to set a
15:54 - we need to send a back to position zero
15:57 - okay
15:59 - and then we need to do mod 26 okay so
16:01 - for those of you that haven't come
16:02 - across this mod function
16:04 - it's basically saying whatever the
16:06 - remainder is take that as an int
16:08 - and that's the value of the mod
16:10 - okay
16:11 - so
16:12 - so that mod over here the the function
16:15 - of it is actually to loop back to make
16:17 - it a loop
16:19 - okay so mod 26 so when it reaches over
16:22 - 26 characters we wanted to loop back to
16:23 - the beginning okay we want to loop back
16:25 - to zero
16:27 - so actually 26 mod 26 gives us 0 because
16:30 - there's no remainder when you divide 26
16:32 - by 26 right just a simple quick
16:34 - explanation of one mod is
16:36 - 26 mod 26 is zero because 26 divided by
16:39 - 26 gives zero remainder whereas 28 mod
16:43 - 26
16:44 - gives you two because when you divide 28
16:46 - by 26 the remainder is two because
16:48 - that's a real quick explanation of what
16:49 - mod is
16:50 - um
16:52 - so basically so first we reset the
16:54 - values to zero
16:55 - and then we do mod 26 so that it loops
16:57 - over it doesn't go over bounce right
17:00 - and after that we need to bring it back
17:02 - to its original ascii value
17:04 - okay
17:06 - so
17:07 - this okay so this might be a little bit
17:09 - confusing at first let's go straight
17:10 - into an example here
17:12 - so this is the function we came up with
17:16 - right minus 65 to bring it back to zero
17:19 - mod 26 to loop over
17:22 - and then we said we want to also
17:24 - plus 65 to bring it back to its original
17:26 - ascii value
17:29 - okay so why is this right what how does
17:32 - this make sense
17:34 - so let's say someone input the letter
17:36 - capital z okay
17:38 - and capital z as we know has an ascii
17:40 - value of 90 right so let's just take
17:42 - that as an example
17:43 - someone puts in the letter z
17:46 - so z minus 65
17:49 - would give us a 90 minus 65 which is 25
17:52 - and let's just say the key was one right
17:54 - so the key was one so 90
17:58 - plus a minus 65 which is 25
18:02 - plus the key which is in this example as
18:04 - it's one
18:05 - that'll give us 26 right 90 minus 65 25
18:08 - plus 1 26.
18:11 - now 26
18:12 - mod 26 would give us 0
18:15 - right
18:17 - and then we'd add back the 65
18:20 - so that it prints out the letter a
18:22 - so when uppercase z
18:24 - is a plain text our ciphertext would now
18:27 - print out whatever is the ascii position
18:29 - of 65 which is the capital a right
18:32 - okay so might be thinking why do we need
18:34 - to add back the 65 because otherwise
18:37 - it would be
18:38 - a 90 right capital z minus 65 which is
18:43 - uh 25
18:44 - plus 1 which is 26. now 26 mod 26 would
18:49 - give us zero so to print whatever is the
18:51 - ascii position of 0 which we don't want
18:53 - that we want to print whatever is the
18:54 - ascii position of 65 which is a so
18:57 - that's why we need to add it back and
18:59 - back to 65.
19:01 - so plain text minus 65 to set the
19:04 - alphabet back to zero plus k obviously
19:06 - converted to ciphertext
19:09 - mod 26 so that it loops back over
19:11 - whenever it goes over the 26
19:13 - and then plus 65 to bring it back to the
19:16 - original ascii value
19:17 - right so i hope that explanation makes
19:19 - sense uh rewind the video and watch it
19:21 - again if it doesn't
19:23 - right but hopefully it does make sense
19:25 - right
19:27 - so
19:29 - for j
19:31 - okay and this is only for capital
19:33 - letters right because a is capital 65.
19:36 - so if it's a capital letter
19:40 - and again here
19:41 - uh we don't really want uh
19:45 - we don't really want to deal with ascii
19:47 - and all that again
19:48 - so we know from the previous exercises
19:50 - that we can just write is upper
19:52 - for uppercase characters so if is upper
19:57 - plain text
19:59 - j
20:00 - then we want to print this right
20:07 - so hopefully everything makes sense so
20:09 - far so we go to the loop and if it's
20:11 - upper
20:12 - then if it's an uppercase letter then we
20:14 - use this formula
20:16 - what happens if it's a lowercase letter
20:18 - well we know we already know how to do
20:22 - it f is lower right this from the
20:23 - previous um
20:26 - uh previous problem sets rather than
20:28 - saying ask rather than putting the ascii
20:29 - values and everything we can simply do
20:31 - is lower
20:32 - so if plain text
20:36 - is a lo if it's a lowercase letter what
20:38 - do we need to do
20:40 - well something very similar to this
20:43 - but because
20:44 - uh lowercase it doesn't start at 65 it
20:46 - starts at 97 right
20:49 - we want to minus it by 97 to bring it
20:51 - back to its original position and then
20:53 - add back 97 so it goes back to its
20:55 - original ascii position
20:57 - so it's exactly the same formula as for
20:59 - the upper case so we can just copy and
21:01 - paste that right
21:03 - print xj minus 97 plus k
21:07 - and bring it back to 97 right
21:10 - so hopefully everything makes sense so
21:11 - far if you don't understand the logic
21:14 - here please rewind the video watch it
21:15 - again i'm sure you'll get it eventually
21:17 - it's it's tough to wrap your head around
21:19 - because our initial instinct is just
21:20 - cipher text is plain text plus key right
21:23 - but we need the mod to loop over and we
21:25 - need to bring it back and everything so
21:27 - keep that in mind
21:28 - okay
21:29 - so if it's if it's an upper case then do
21:31 - this if it's a lowercase letter then do
21:33 - this and
21:35 - so they tell us over here
21:36 - that we want to keep all um anything
21:39 - that's not letter like let's say it's a
21:41 - number or a
21:43 - or a full stop exclamation mark whatever
21:45 - is punctuation we're going to leave it
21:47 - as it is okay
21:49 - so let's say
21:51 - plaintext is ab50
21:53 - we want the ciphertext to be with the
21:55 - key of one let's say we want the cipher
21:57 - text to be bc50 so a plus one b b plus
22:00 - one is c but the 50 should remain as it
22:03 - is right
22:04 - and full stops exclamation marks
22:06 - everything should remain as it is so we
22:08 - only want to manipulate the letters okay
22:11 - so over here we've done if it's an
22:13 - uppercase letter then do this if it's a
22:15 - lowercase letter then do this
22:17 - now else if it's anything else
22:20 - if it's not a letter basically
22:23 - if it's not an uppercase letter or a
22:24 - lowercase letter then what do we want to
22:26 - print we want to just print it as it is
22:28 - right we don't want to do anything fancy
22:30 - so we just want to print the character
22:32 - as it is again we use a placeholder c
22:36 - and we just want to print it out as it
22:38 - is so we don't make any changes over
22:39 - there okay
22:42 - okay so everything here makes sense so
22:43 - far all right
22:45 - uh if it's an uppercase through this
22:46 - lowercase with this and if it's anything
22:48 - else other than an uppercase or a
22:49 - lowercase letter which means if it's a
22:50 - number or punctuation or blah blah print
22:52 - it as it is
22:54 - okay
22:56 - and then after that we just want to
22:57 - print a new line right so ciphertext it
22:59 - will print out the ciphertext as it is
23:01 - and then we just want to print out a
23:02 - quick new line
23:04 - print
23:05 - f
23:07 - and we just want to print a new line
23:08 - simply there
23:13 - and
23:14 - okay
23:16 - okay
23:17 - so let's see if our code is correct
23:22 - oh
23:25 - okay we forgot to close our for loop
23:27 - here that would give us an error later
23:29 - on the program okay
23:31 - so
23:32 - first of all let's compile our program
23:34 - makes
23:34 - easier and a few errors here
23:40 - percent see okay so it's an error on
23:42 - line
23:43 - 33.
23:49 - okay i closed the bracket too early here
23:51 - i needed to actually
23:53 - open a bracket here
23:57 - okay
23:58 - so the error was that i didn't put the
24:00 - brackets right
24:02 - it's also hold down so let's make caesar
24:05 - okay it compiles let's run dot slash c01
24:09 - key of one okay ask me for the plain
24:11 - text that's good sign
24:14 - plain text let's say is a
24:16 - okay ciphertext b that's okay sounds
24:18 - good so far
24:20 - let's say dot slash caesar
24:23 - okay gives me an error
24:25 - oh but uh prompts me again
24:27 - on the same line that that doesn't look
24:28 - very nice
24:30 - so let's just put over here start a new
24:32 - line when you give the error message
24:34 - that's backslash n
24:38 - okay that's mixed either once again
24:40 - dot slash caesar
24:42 - okay uses user key okay gives me the
24:44 - error message
24:45 - c02 let's say
24:47 - a becomes c okay that's a good sign so
24:50 - let's go ahead and check our code now
24:53 - check 50 okay copy and paste it
24:56 - hopefully everything's correct right
24:58 - we've gone through this whole thing and
24:59 - everything seems to be correct uh
25:01 - hopefully it is and by the time we're
25:02 - waiting for this guys please make sure
25:04 - to subscribe because we'll be posting
25:05 - videos every single week make sure to
25:07 - leave a like on this video if it helped
25:09 - and
25:10 - yeah uh let's go ahead let's do the cs50
25:12 - course together guys we can get through
25:14 - it i know we can
25:16 - let's just go ahead and wait for our
25:17 - results we've done everything correctly
25:20 - hopefully everything i've said today
25:21 - makes sense by the way guys um this one
25:23 - is a little bit complicated kind of wrap
25:24 - your head around the logic of the mod
25:27 - um if you want me to make a separate
25:29 - video just explaining mod so that this
25:31 - whole problem becomes clear let me know
25:33 - and i'll go ahead and make a video just
25:34 - about that
25:35 - and over here
25:37 - everything is correct guys okay so thank
25:39 - you so much for watching
25:41 - if you have any questions leave in the
25:42 - comments down below and answer every
25:44 - single question
25:45 - and that's all for today
25:47 - thanks guys bye david

Cleaned transcript:

hey guys in today's video we're going to be going over cs50 problem set to caesar so make sure to subscribe to the channel if you haven't already because i'm going to be posting cs50 solutions every single week let's jump straight into caesar now okay so the point of caesar is actually to encrypt some text based on the user's key what does that mean so let's say a user runs the program right the program is called cesar with dot slash caesar that means the user has chosen the key to be one so what does that mean so if the user types the letter a our program would need to print out the letter b so depending on the key so the key is one so a prints out b because we need to convert a to b we need to skip one step based on the key okay so similarly b is converted to c and c is converted d right it just moves one step based on the key so let's say the user types dot slash caesar two so now the key is two so if the user types in the letter a we need to print out the letter c right in other words is the plain text what the user types in and c is the cipher text or what our program prints out okay and so on and so forth he can be any number right this is just examples so our program needs to prompt the user for plain text right would they type whatever they want and then we convert it to ciphertext based on the key right okay so let's just give an example here let's use user types in dodge slash c01 and for the play text they type in abc so our cipher text we need to print out bcd okay and notice here how it's case sensitive so capital a turns into capital b lowercase b turns into lowercase c and uppercase c turns into uppercase d okay so the case still remains and also if you notice here for the first time we've not had this in preview in previous problem sets is that the key is not a normal input so we don't use get string okay rather it's actually on the command line itself so in previous problems that's what we used to do is just run like dot slash scrabble dot slash readability but over here we run dot slash caesar one or dot slices or whatever the key is right so that's why we now have a command line argument so rather than using int main void like we used to do in the previous problem sets we now run this int main in rxc string arc v because we now have taken input on the command line rather than just leaving it void okay so i hope that makes sense so far and now there are two conditions for the command line argument right what are they so first what is what does argc mean rec is an int and it's actually how many arguments there are okay so argc so the first argument here is the dodge caesar and the second argument in this example is one okay so argc is equal to two okay so the first condition is that arg c always has to equal to two dot slash caesar is the first arg c and the second one is the number right the key so for example we can't have a dot slash caesar one space one because that doesn't make sense right that we don't know what the key is so that's why rxc always has to be equal to two and y so in this case rc is three right that's less than one one so that doesn't make sense and it can't be one rxc can't be one either because then it'll just be dot slash caesar that's the first argument so it always has to be rxc is equal to two dot slash caesar and the key two arguments and the second condition is that argv one must only contain digits okay so why is that uh let's take an example over here arc v0 is dot slash caesar right so that's fine arc v1 must only contain digits because let's say the user types in dot slice user x but we don't know what the key is right it doesn't make sense or let's say they type in dot sizes are 1x right that doesn't make sense either so our v1 must contain only digits okay so those are the two conditions and if it doesn't fulfill these conditions both these conditions have to be fulfilled otherwise we need to print usage dot slash user key which basically is just telling the user how to use the program successfully okay how to use the program correctly so let's try to put this whatever we learned into code and it should be simple enough right so if we knew the first one is rc needs to be 2. so if rc is not equal to we need to print the error message and return one right quit the program so if rxc is not equal to 2 and how do we say that we actually said by using exclamation mark and equal to so this just means if rtc is not equal to 2 what should we do we want to print the error message which tells the user how to use the program print usage dot slash user key and we also want to exit right we want to return one okay the second condition is argue one must only contain digits and over here we actually need to use a loop why do we need to use a loop because we actually need to go through every single character of argue one and determine whether or not it's a digit okay so again so let's say it was just uh dot slices or one x if we didn't use a loop it would just check for the first character whereas we need to actually go through entire rv one and check one by one is this character digit is this character digit or not okay so that's why we need to use a loop so we can use a for loop right and by this point we know how to use for loops from all the previous problem sets so let's say end i equal to zero let's set an index and set to zero and i needs to keep on going as long as i is less than the length of arc v1 right so i is less than sterling arc v1 right i plus plus which basically means go through the entire arc v1 one at a time starting from zero and what do we need to check for if it's a digit then we need to print the same error message but how do we actually check whether or not something is a digit well it turns out there is a formula called is there's a function called is digit right and again we wouldn't know this this is not common knowledge it's not common sense you would know this uh because first of all it's in the cs50 explanation right and also by just playing around with the cs50 manual learning different functions things like that okay so we need to check if it's a digit right and this is under the header file called ctype.h so let's include that and also if you remember from the previous problem sets sterlin is actually under the header file called string.h right so for to use sterling we use string.h as well okay so we've used those header files so if is digit right so we need to check whether or not it's a digit uh according to this arc v1 so if it's not a digit then we want to return an error and quit so again if exclamation mark is digit arc v1 i right what do we need to do we want to print again the exact same thing as we printed before users we need to print the error message as well as return one okay so i hope that makes sense so far right we fulfilled the two conditions because as we said rc needs to be equal to two so if it's not two then quit the program and print this error message and arg v1 needs to only have digits right so we loop through the entire rv1 one character at a time and if it's not a digit then print this error message and quit the program right so we've reached here so far but now we we know logically that the formula to convert plain text to ciphertext is actually plain text plus key plain text plus key will give you cipher text right this makes sense so let's say a plain text was a well like what the user types unless the user types in a and a key of one we have to print out the cipher text which in this case would be b right so that makes sense so far um but again so we we know that key needs to be an int right the key needs to be an integer so that we can use we can make a formula out of it to later convert plain text into ciphertext but if you notice here our v which is where the key is rv1 is actually a string right so it's a digit but it's considered a string so let's say the key is one well it's still a digit number one but rather than counting it as an integer where we can do mathematical functions with it it's counted as a string okay so we need to convert the key into an integer so that we can do math with it right okay so okay so in this example here dot classes are one one is a string okay even though it's a digit it's still a string it doesn't count the computer doesn't count it as an end because arc v is a string so we need to convert it to an integer right so let's see if there's a function to convert a string into an integer and it turns out there is and again this is not common knowledge whatsoever right uh you need to know this by either reading cs50s explanation or by just going through the manual and figuring it out yourself so it runs out of this function called a to i which converts strings to an int right that's the definition here and that's under the header file standard lib.h okay i'm just gonna include that okay so we know we need to have a key right we have a key but now we need to convert the key into an integer so let's just make an end let's call it in k for key right just to make it easier to remember a to i which is just convert string to integer arg v1 right so we defined a variable called k which is an integer and now we assign the value of the key as an integer into k okay so k for key just to make it simple and now what do we need to do well now we need to actually prompt the user for some plain text and how do we go ahead how do we go about doing that very simple it's been there since problem set one which is just using the get string function right so string plain text to get some string from the user get string right this is to get a string from the user uh let's say plain text okay okay and now we want to print out the cipher text okay so get string plain text and we want to print with cipher text and then we actually now we need to use the formula and everything to get the actual cipher text so what we've done is prompted the user for plain text and then print out ciphertext and they print out the actual ciphertext so print out the word ciphertext colon and then the actual ciphertext okay so now first things first as we know from scrabble and even readability we know that uh different keys according to ascii the lower case and uppercase are they have different values right so if you remember actually uppercase a has an ascii value of 65 whereas lower case it has a has an ascii value of 97 right so we know that over here according to our program it needs to be case sensitive right so we can already determine somehow that we need to treat uppercase letters and lowercase letters are differently because they have different ascii positions or ascii values so okay so we know that so now what we need to do is we actually need to make a loop to go through the entire a plain text one character at a time and convert it to ciphertext right so let's first of all let's go ahead and make the loop and again let's use a for loop again we should be very familiar with for loops at this point we should be comfortable manipulating them so let's make another integer let's call it j because we've already used i over here so if j equal to zero keep on going as long as j is less than the stirling of what this time strata of the plain text and j plus plus okay so what this for loop means just set and make a variable called j index it to zero keep on going as long as j is less than the plaintext as long as the less than the length of the string of the plaintext right and j plus plus which just means go one at a time okay so so far this makes sense and our first instinct here right and my first instinct here so there's no shame in that is printf and what do we want to do we just want to print the character and what character we want to print we just want to print plain text right plain text j plus k and this is what makes logical sense for everyone right so you the cipher text you want to print the ciphertext right so it placeholder c so we're going to print the ciphertext which so far what we think logically is just plain text whatever that is plus k which is the key right so let's say it was a let's say the plaintext was a and the key of one well then we would want to print out b right we want to print the singular letter b character so this makes sense but there's actually a flaw with this because let's take a look here what if someone typed the letter z okay which is very common right so let's say someone type the letter z capital z and that has an ascii value of 90 right and let's see someone just put a key of one symbol so that it would convert it to whatever is ascii position of 91 right z which is 90 plus 1 according to our formula here so 90 plus 1 would give us 91. but what is actually in the ascii position of 91 what is the ascii value of 91. well we don't know right i mean it's probably a comma or an exclamation mark or some other random character whereas what we don't we don't want to print that random character if someone prints out the letter z and has if someone inputs the letter z and has a key of one we actually wanted to loop back over to a right so if if it's a z with a key of two we wanted to loop back over to b right we want to loop back over the alphabet essentially rather than just um printing out some random character in ascii going over the bounds right going overbound so what do we need to do here well so we know that this doesn't work because we can go overbound with this right so what we need to do is actually and again if you've done scrabble this might come a little naturally to you and i hope you've done scrabble if you haven't go go back and watch that video first do readability and then only come to caesar okay so how do we get this plain text plus key to loop back over once it goes past z so there are a few simple steps so the first step is reset the values so that the alphabet starts from zero rather than 65 right and this is very similar to what we did in scrabble so we need to set a we need to send a back to position zero okay and then we need to do mod 26 okay so for those of you that haven't come across this mod function it's basically saying whatever the remainder is take that as an int and that's the value of the mod okay so so that mod over here the the function of it is actually to loop back to make it a loop okay so mod 26 so when it reaches over 26 characters we wanted to loop back to the beginning okay we want to loop back to zero so actually 26 mod 26 gives us 0 because there's no remainder when you divide 26 by 26 right just a simple quick explanation of one mod is 26 mod 26 is zero because 26 divided by 26 gives zero remainder whereas 28 mod 26 gives you two because when you divide 28 by 26 the remainder is two because that's a real quick explanation of what mod is um so basically so first we reset the values to zero and then we do mod 26 so that it loops over it doesn't go over bounce right and after that we need to bring it back to its original ascii value okay so this okay so this might be a little bit confusing at first let's go straight into an example here so this is the function we came up with right minus 65 to bring it back to zero mod 26 to loop over and then we said we want to also plus 65 to bring it back to its original ascii value okay so why is this right what how does this make sense so let's say someone input the letter capital z okay and capital z as we know has an ascii value of 90 right so let's just take that as an example someone puts in the letter z so z minus 65 would give us a 90 minus 65 which is 25 and let's just say the key was one right so the key was one so 90 plus a minus 65 which is 25 plus the key which is in this example as it's one that'll give us 26 right 90 minus 65 25 plus 1 26. now 26 mod 26 would give us 0 right and then we'd add back the 65 so that it prints out the letter a so when uppercase z is a plain text our ciphertext would now print out whatever is the ascii position of 65 which is the capital a right okay so might be thinking why do we need to add back the 65 because otherwise it would be a 90 right capital z minus 65 which is uh 25 plus 1 which is 26. now 26 mod 26 would give us zero so to print whatever is the ascii position of 0 which we don't want that we want to print whatever is the ascii position of 65 which is a so that's why we need to add it back and back to 65. so plain text minus 65 to set the alphabet back to zero plus k obviously converted to ciphertext mod 26 so that it loops back over whenever it goes over the 26 and then plus 65 to bring it back to the original ascii value right so i hope that explanation makes sense uh rewind the video and watch it again if it doesn't right but hopefully it does make sense right so for j okay and this is only for capital letters right because a is capital 65. so if it's a capital letter and again here uh we don't really want uh we don't really want to deal with ascii and all that again so we know from the previous exercises that we can just write is upper for uppercase characters so if is upper plain text j then we want to print this right so hopefully everything makes sense so far so we go to the loop and if it's upper then if it's an uppercase letter then we use this formula what happens if it's a lowercase letter well we know we already know how to do it f is lower right this from the previous um uh previous problem sets rather than saying ask rather than putting the ascii values and everything we can simply do is lower so if plain text is a lo if it's a lowercase letter what do we need to do well something very similar to this but because uh lowercase it doesn't start at 65 it starts at 97 right we want to minus it by 97 to bring it back to its original position and then add back 97 so it goes back to its original ascii position so it's exactly the same formula as for the upper case so we can just copy and paste that right print xj minus 97 plus k and bring it back to 97 right so hopefully everything makes sense so far if you don't understand the logic here please rewind the video watch it again i'm sure you'll get it eventually it's it's tough to wrap your head around because our initial instinct is just cipher text is plain text plus key right but we need the mod to loop over and we need to bring it back and everything so keep that in mind okay so if it's if it's an upper case then do this if it's a lowercase letter then do this and so they tell us over here that we want to keep all um anything that's not letter like let's say it's a number or a or a full stop exclamation mark whatever is punctuation we're going to leave it as it is okay so let's say plaintext is ab50 we want the ciphertext to be with the key of one let's say we want the cipher text to be bc50 so a plus one b b plus one is c but the 50 should remain as it is right and full stops exclamation marks everything should remain as it is so we only want to manipulate the letters okay so over here we've done if it's an uppercase letter then do this if it's a lowercase letter then do this now else if it's anything else if it's not a letter basically if it's not an uppercase letter or a lowercase letter then what do we want to print we want to just print it as it is right we don't want to do anything fancy so we just want to print the character as it is again we use a placeholder c and we just want to print it out as it is so we don't make any changes over there okay okay so everything here makes sense so far all right uh if it's an uppercase through this lowercase with this and if it's anything else other than an uppercase or a lowercase letter which means if it's a number or punctuation or blah blah print it as it is okay and then after that we just want to print a new line right so ciphertext it will print out the ciphertext as it is and then we just want to print out a quick new line print f and we just want to print a new line simply there and okay okay so let's see if our code is correct oh okay we forgot to close our for loop here that would give us an error later on the program okay so first of all let's compile our program makes easier and a few errors here percent see okay so it's an error on line 33. okay i closed the bracket too early here i needed to actually open a bracket here okay so the error was that i didn't put the brackets right it's also hold down so let's make caesar okay it compiles let's run dot slash c01 key of one okay ask me for the plain text that's good sign plain text let's say is a okay ciphertext b that's okay sounds good so far let's say dot slash caesar okay gives me an error oh but uh prompts me again on the same line that that doesn't look very nice so let's just put over here start a new line when you give the error message that's backslash n okay that's mixed either once again dot slash caesar okay uses user key okay gives me the error message c02 let's say a becomes c okay that's a good sign so let's go ahead and check our code now check 50 okay copy and paste it hopefully everything's correct right we've gone through this whole thing and everything seems to be correct uh hopefully it is and by the time we're waiting for this guys please make sure to subscribe because we'll be posting videos every single week make sure to leave a like on this video if it helped and yeah uh let's go ahead let's do the cs50 course together guys we can get through it i know we can let's just go ahead and wait for our results we've done everything correctly hopefully everything i've said today makes sense by the way guys um this one is a little bit complicated kind of wrap your head around the logic of the mod um if you want me to make a separate video just explaining mod so that this whole problem becomes clear let me know and i'll go ahead and make a video just about that and over here everything is correct guys okay so thank you so much for watching if you have any questions leave in the comments down below and answer every single question and that's all for today thanks guys bye david
