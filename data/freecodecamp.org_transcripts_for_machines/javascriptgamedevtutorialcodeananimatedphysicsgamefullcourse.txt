Frank dwark is back with a new JavaScript game tutorial featuring interesting physics and AI mechanics he's included custommade royaltyfree assets for you to use and they'll guide you step by step to create a polished and responsive browserbased game what makes a perfect game detailed handcrafted visuals fantasy environments and a wide variety of animated characters or is it more about the game mechanics physics for interactions and AI to make the creatures feel alive what is this special ingredient in game development recipe in this class we will dive deep into the secrets of JavaScript web animation and frontend web development let's try to discover what makes a great game and how we can build it from start to finish using just our own JavaScript code with no Frameworks and no libraries this class is for beginners but some basic knowledge of frontend web development is required to get them maximum value let's go I'm giving Olay a ton of free game art with this class I hope you like it we will control the blue ball its job is to protect hatching eggs from waves of hungry enemies player can position all the game objects by pushing them around we can push the ax and hatchlings to safety or we can push the enemies out of the way while building this project I will show you how to use HTML CSS and plain vanilla JavaScript to implement many important web animation and game development techniques we will apply physics to make game objects interact with each other we will learn how to restart our game by pressing a button how to control FPS of the whole game how to trigger periodic events we will apply Mouse controls learn how to manage and animate 8directional Sprite sheets we will trigger and animate particles when a certain event happens and much more let's take it step by step to make sure we really understand the code and by the end of this class you will have all the skills you need to build your own games and animation projects I create an IMG element with an ID of overlay The Source will be overlay.png you can download all project art Assets in the resources section below there are individual images and Sprites as I'm using them in this class as well as a bonus folder with source files where each game object comes split into high resolution pieces you can edit and animate so if you want you can mix and match combine them with art I gave you for other classes where we are using this mushroom Forest theme and you can create your own unique game environments all the art in this class is copyright free feel free to download them modify them and reuse them in your own projects in any way you want I'm already giving you all art you will need to follow this course but for those of you who want to take it further if you have a graphics editor like Photoshop you can for example color shift the images to create even more visual variety character source files can also be raked and animated in 2D Sprite tools like dragon bones or spine check out the source files and use them however you want it's my gift to you as a thank you for spending your time with me so we have a basic setup in index.html and style CSS canvas defaults to this small size of 300 X 150 pixels if I set its size with CSS I would be setting only its element size and that would stretch my drawings HTML canvas has actually two sizes element size and drawing surface size that can be set independently I want both sizes to be the same to prevent any distortions so I will size my canvas with the JavaScript here I wrap everything inside load event listener because we will use a lot of art assets and I wanted to make sure all my images are fully loaded and available before any JavaScript code runs first we need to point JavaScript towards our canvas element using get element by ID we save that reference in this custom variable I call for example canvas then I take that variable and from it I call build in get context method passing it 2D as context type argument this will initialize a builtin object that holds all canvas properties and drawing methods we can now call them from this CTX variable so as I said before I want to set canvas size both element size and drawing surface size to the same value we can do it like this canvasa dot width is 1280 pixels and canvas height is 720 pixels now the full background artwork I prepared for you is revealed perfect I wanted to ride this game as objectoriented code base to make it more modular we will have a class for player and another class for game to manage all the game logic the main brain of this code base we will also need animation Loop to draw and update our game over and over to create an illusion of movement game class Constructor will expect a reference to Canvas element as an argument like this inside we convert it into a Class Property and we will need with property and the value will be this dot canvas from line 15 DOT with like this this will give us 1280 pixels as we set it up on line four we do the same thing for this dot height we are taking a reference to Canvas element and we are setting the width and height of our game to be the same as the width and height of canvas we will finish this setup by connecting this canvas argument to this canvas variable a little bit later when we create an instance of our game class using the new keyword we will get there soon I'll show you before we do that I also need the player to have access to width and height properties of our game because the player needs to know for example when it moves outside the game area and so on I will give it access to the entire game class and all its properties and methods by passing it a reference to this game class as an argument like this inside we convert it to A Class Property keep in mind that I'm not creating a copy of game object when I create player objects in JavaScript are so called reference data types so this dot game here on line 9 doesn't create a copy it just points to a space in the memory where our main game object is stored all the code inside a class Constructor gets triggered when we create an instance of a class using the new keyword we will do that in a minute I want our code base to automatically create player when we create an instance of our main game object so I can do this inside the class Constructor I create a property called this dot player and I set it to new player like this I can see that player class Constructor on line 8 expects game as an argument so I pass it this keyword since here we are inside that game class this keyword here refers to the entire game object here on line 18 we are creating an instance of player class and we are saving it as a desktop player property on the game class structuring our code like this will automatically create player when we create game we create an instance of game object like this custom variable I call for example game and I set it equal to new game on line 14 I can see that the game class Constructor expects canvas as an argument so I pass it canvas variable from Line 2. This variable will get converted to a class property and the width and height of the game area will be extracted from it as we plant let's check if everything worked by console login this game variable nice I can see the correct width and height properties and we have an instance of player class in there as well this is one of the ways how you can organize and connect your objects in an objectoriented JavaScript code base keep in mind that the order in which we Define the classes matters Javascript file is read line by line from top to bottom JavaScript classes are hosted but they are not initialized until that particular line is right so player class needs to be defined before it's used a very good idea would be to split our JavaScript into individual modules and Import and Export our classes between files as needed for this project I will write all the code in a single Javascript file to keep it as beginner friendly as possible using JavaScript modules would require us to run this code through a local server it wouldn't run The Code by simply opening index HTML file in a web browser anymore if you are more experienced it will be very easy for you to finish the project with me and then if you want you can split individual classes into separate modules yourself this class is for beginners so let's focus on object oriented principles and animation techniques a function that sits on an object is called a method player will need a draw method to draw and animate it it will expect context as an argument to specify which canvas we want to draw on we will connect this context argument to our CTX variable from line 3 when we call this draw method a little bit later I will show you I wanted to draw a simple Circle at first representing our player to draw a circle on canvas we take context and we call begin path to tell JavaScript we want to start drawing a new shape and we want to close previous shape if there are any then we call builtin Arc method which expects at least five arguments it expects X and Y coordinates of the center point of the circle its radius start angle in radians measured from the positive xaxis and end angle where the arc ends again in radians measured from the positive xaxis there is an optional sixth argument for counterclockwise if we don't Define it it will default to false which means that the arc will be drawn clockwise so start angle is zero radians and end angle is mastered pi times two it's a full circle now we can choose to call fill to fill the shape with color or stroke just to outline the shape or we could use both we will do that soon how do we actually draw the player on canvas now on the game class I create a method I call for example render this method will draw and update all objects in our game it expects context as an argument inside I take this dot player from line 23 and through this reference we access the draw method on player class we just defined from Line 11. This method contains the code to draw a circle representing the player I can see it expects context as an argument so I pass it along this context we passed to the render method now I can take this game variable that holds an instance of the entire game class and from there I call render and I pass it to CTX from line three that CTX will be assigned a variable name context here and it will be passed along to draw method on player class we are drawing a black circle representing the player it's here maybe you can't see it so let's give it different X and Y coordinates to move it instead of hard coding all these values I want to create properties on the player class and then use those here we will need X and Y coordinates for player position but because in this class we are learning about position and hitboxes and character images that can have very different shapes and sizes I will have to create property for X and Y position of player hitbox and I will need to have a different X and Y property for player Sprite sheet image it will make more sense as we build it I want to be very explicit with my variable names to make it absolutely clear which value is the position of the Collision box and which value is the position of a Sprite sheet so instead naming these properties just X and Y I will name them Collision X and collision Y X and Y position of the Collision hitbox of the center point of the Collision Circle all objects in our game today will have circular hitboxes because I wanted to show you how to make them push and slide along each other I want the starting position of the player to be exactly in the middle of the game area so Collision X will be this dot game from line 9 and from that property I will extract with from line 23. and in the middle so terms of 0.5 Collision y will be the same this Dot Game dot height times 0.5 now I can use these values as X and Y arguments but to Canvas Arc method like this now we can move the player around by changing values of collision X and collision y properties we will also need a property called Collision radius which will Define the size of this circular player hitbox I use it here inside the arc method as well default fill color is always black I can override it here by setting canvas fill style property to White like this instead of filling the shape with color we could also just stroke it Again by default line width of stroke is one pixel and the color is black I set the line with 2 3 pixels and I set stroke style to White notice I'm defining these canvas properties outside of any class or method I do that on purpose because this code will only run once on the initial page load you can't always do that if you have multiple objects with different fill Styles and stroke colors in that case you would have to Define these properties inside the draw method and switch between them over and over the problem with that is that the draw method will be called 60 times per second and change in kind of a state like this could get performance expensive it's a good idea to structure your code in a way where you change kind of a state as little as possible and when I say canvas State I mean anything from transforms to changing colors of fill style and stroke style that's why I put this code here instead of placing it directly inside the draw method to make it run as little as possible while still applying the colors and settings as I need them I can also call Phil here so now we are filling and stroking the same path defined by Arc method I want the fill to be white but I want it to be slightly transparent canvas has a global Alpha property to set opacity of the shapes we are drawing the problem is that when I set Global Alpha to a different value everything drawn after that will be semitransparent I want the transparency to only apply to the fill color of player Collision Circle to limit certain kind of a settings only two specific draw calls we can wrap that drawing code between save and restore builtin canvas methods then if I set Global Alpha to 0.5 it will affect only that specific draw in action in our case it will only affect the fill of this circle so save method creates a snapshot of the current canvas State including its fill style line width opacity as well as Transformations and scaling if we are doing that then I can do any changes to that kind of a state I want in this case I just set opacity to 0.5 this fill call will be affected by that changed opacity and then we call Restore restoring all canvas settings to what they were when we first called its Associated save method for that reason this stroke will not be affected by reduced opacity save and restore methods allow us to apply specific drawing settings only to selected shapes without affecting the rest of our canvas drawings I want to move the player around using Mouse we already know that the code inside the game class Constructor will be executed at the point where we create an instance of this class using the new keyword we are taking advantage of that by automatically creating an instance of player class here we can actually run any JavaScript code in here I can even put event listeners here to make sure they are automatically applied when I create an instance of game class I create an event listener for Mouse down event when Mouse button is clicked the code inside this callback function will run I test it by just console login the word Mouse down if I save changes because I'm already instantiating this class online 46 this event listener is automatically applied now when I click on canvas control lock is triggering nice callback function on event listener also generates an event object that contains all kind of information about the event that just happened to get access to that object we just need to give it a variable name you can name it whatever you want but the convention is usually event or E let's consolock this event I click on canvas and I see it here I inspect it you can see it contains a lot of information about that Mouse click for example we see X and Y coordinates of that click here there are many other properties that tell us which Mouse button was pressed and many other things I want to take the coordinates of the click and save them as properties on the main game object and from there we will be able to access them from our player object as well I create a new property on game class called this.mouse it will be an object with X property with default value of this dot width times 0.5 and Y will be distal height times 0.5 so the middle of canvas horizontally and vertically we will also want to monitor when the mouse button is pressed down initially it will be set to false if I consolok e.x and e.y you can see we are getting X and Y coordinates as we click around canvas the problem is that the coordinates are from the top left edges of the browser window I would like to measure the click coordinates from the top left corner of canvas instead so when we click here in the top left corner of canvas we get X and Y 0 0. for that we can use a different property on this autogenerated event object called offset X which will give us horizontal coordinate of the click on the target node in our case the target node the target of the click is canvas element now you can see the values get very close to zero as I click close to the edge of canvas I could also add the event listener just to the canvas element itself rather than the entire browser window object if I click closer to the top left corner we are getting values close to zero zero perfect probably it would make sense if I use this dot canvas property here from line 31 instead since we are inside a class and we have the reference to Canvas available here so now we are getting coordinates of the click measured in pixel distance from the top left corner of canvas we resize the browser window this is working well I want to save these click coordinates inside our custom Mouse property so that they are available to other objects in our code base such as the player inside the mouse down event listener I take that this.mouse.x property from line 36 and I set it equal to e dot offset X this.mouse.y will be e dot offset y I create another console log and I will log these newly updated Mouse properties when I click on canvas we get an error that says cannot set properties on undefined setting X on line 43. it's telling me that I can't set X property on something that is undefined for some reason this.mouse is undefined when accessed from inside event listener it is because when this callback function on event listener runs it forgot it was originally defined inside this game class Constructor it forgets what this keyword stands for this is expected to make the event listener remember where it was first defined where it sits in the lexical scope of our code base we can simply use es6 Ro function here instead one of the special features of es6 Ro functions is that they automatically inherit the reference to this keyword from the parent scope Arrow functions remember where in the code base they were originally declared lexically and they adjust their disk keyword to point to the correct object to the parent object now this.mouse.x and this.mouse.y are correctly updating to the new values making the current Mouse coordinates available all over our code base whenever they might be needed later I delete the console logs when Mouse down event happens I set pressed from line 38 to true I copied this event listener this one will be for Mouse up event when the mouse button is released everything here will stay the same and reset pressed to false I also create an event listener for Mouse move event let's console log it to check yeah that's working let's make the player move I create a custom method I call update inside I set Collision X from line 14 to the current Mouse exposition and collision y will be the current Mouse y position like this to run this code we actually need to call the update method I will call it from inside render down here I delete this console log if we want to see any Movement we need to be calling render over and over so let's put it inside the animation Loop here I call builtin request animation frame a method which sits on the browser window object but we can also call it directly like this if we want I pass it animate the name of its parent function to create an endless animation Loop now I need to call animate to actually start the animation when I move Mouse over canvas we get Trails I only want to see the current animation frame so between every loop I use builtin clear rectangle method to clear the old paint I want to clear the entire canvas area from coordinates00 to canvas with canvas height now the player sticks to Mouse as we move it around canvas perfect I want to create a line between Mouse and the player to clearly show the direction in which the player will move inside the draw method on player class we start a new shape by calling begin path move 2 method will Define starting X and Y coordinates of the line in this case I wanted the line to start from the coordinates of the player object line 2 method will set the end in X and Y coordinates of the line in this case it would be X and Y coordinates of the mouse then we call stroke to actually draw the line this works but since the player is always able to catch up with mouse cursor so fast we can barely see the line let's give player speed speed X horizontal speed initially I set it to zero speed y vertical speed also initially sets to zero inside update method we will calculate speed X first I set it to hardcoded one pixel per animation frame and I increase player Exposition by horizontal speed that worked I also do it for vertical position there are two ways we can make player follow the mouse one way would be to Simply take the difference between the current Mouse position and the player position on horizontal xaxis and set that difference as horizontal speed and we also do that for vertical movement now the player position is correcting for the difference by the entire amount of that distance so it makes the movement instant what if I make it move only by the 120th of the difference between player and mouse position per animation frame horizontally and also vertically I create class properties for DX this stands between Mouse and player horizontally and Dy vertical distance I replace those values here it's easier to read this way I don't want the player to follow all the time as we move Mouse over canvas I won't only when we click somewhere or when we hold Mouse button down and move around inside Mouse move event listener I say only update X and Y Mouse position if Mouse is pressed now I can click around to make the player move to that location or I can drag that point around while holding Mouse down perfect the problem with this technique is that the speed is not constant player moves very fast at first because 1 20th of the distance is at first a big chunk when they are far apart but as they get closer 1 20th of that distance becomes smaller and smaller amount of pixels to be traveled per animation frame you might want this particular motion for your project but for the game we are building today I wanted the player to move at a constant speed we will have to use the second technique for that inside update method I calculated the distance we already have DX the distance between Mouse and the player horizontally we also have DUI the distance between Mouse and the player vertically we want to calculate the distance between these two points we can do that by calculating hypotenuse the longest side of this imaginary right triangle we can use Pythagoras Theorem formula or in JavaScript we have this builtin mastered hypotenuse method this method will calculate the length of the longest side for us if we pass it to other sides of the triangle as arguments keep in mind it expects DUI first and DX second which might be a bit unexpected if you never saw this before horizontal speed is the ratio between DX horizontal distance between Mouse and the player and the actual distance same with speed y it will be the ratio between the distance on vertical yaxis and the actual distance between the two points as a backup when some of these values are undefined at first we say or zero like this we are dividing horizontal and vertical distance these sides by the actual distance represented by the longest side of a right triangle DX and d y is always a smaller number than the distance because the distance is hypotenuse the longest side for that reason the values we get as speed X and speed y will be somewhere between 0 and 1. that will give us the correct direction of movement at a constant speed there is much more to be said about this technique but for now this is all we need to know I'll get back to this now the player is moving at a constant speed towards the mouse I can have a speed modifier I set it to 5 for example I use it down here and I multiply speed X and speed y by that modifier after we add the speed modifier the player Circle will actually never stay still anymore it will be swinging back and forth in this case by 50 pixels because the speed modifier pushes it too far in both directions I can fix it by saying only move the player when the distance between Mouse and the player is more than speed modifier else set speed X to Zero and speed y to 0 as well this works perfect so we covered one simple and one more advanced technique to make the player move towards the mouse now it's time to add solid randomized nonoverlapping obstacles I create a class I call obstacle Constructor will expect the game as an argument and inside I convert that reference to a class property same as before it will be pointing towards the main game object and we need it here because through this reference we have access to game width and height Mouse positions and some other properties we will be adding later we will have access to all these values from inside obstacle class through this.game reference from line 54. as I explained before all the objects in our game will have a circular collision hitbox and a separate rectangular Sprite sheet for that reason I will be calling these properties with a very descriptive names to make sure it's very clear what's happening when we are moving and animating everything later Collision X the center point of collision circle of each obstacle will be a random value between 0 and the width of the game that width is coming from line 62 here and we are accessing it through this Dot Game reference we created online 54. we will also need Collision y vertical center point of collision area Circle it will be a random value between 0 and game height this value Collision radius will be 60. we will also need a draw method that expects context as an argument I want that Circle that represents hitbox area of each obstacle to look the same as the circle representing the player so I take the drawing code from up here just for the circle so this code block I copied and I paste it down here this code will work here because the same as with the player we gave our obstacles properties called Collision X Collision Y and collision radius we will also need the same naming on all these properties between different object types in case we want to have a reusable Collision detection function I will show you how to use that one later it's simple anyway here we have a code to draw a circle with a radius of 60 pixels with 50 opacity wide fill and white fully visible full opacity stroke this obstacle class here is a blueprint we will use it to create individual obstacle objects the actual logic to create and manage these objects will be down here inside the main game class which is the main brain of our code base I create a property called this dot obstacles it will be an array that holds all currently active obstacle objects it will start as an empty array at first the number of obstacles will be for example 5. I create a custom method on our game class I call for example init initialize its job for now will be to create five randomized obstacle objects and put them inside obstacles array we just defined inside I create a for Loop it will run five times because we set number of obstacles to 5 up on line 76. each time it runs it will take this dot obstacles array from line 77 and on it it will call builtin array push method push method adds one or more elements to the end of an array and it Returns the new length of the array I will pass it new obstacle like this the new keyword will look for a class with the name obstacle and it will trigger its class Constructor up online 53 I can see that obstacle class Constructor expects the game as an argument down here init method sits inside that game class so I pass it this keyword which here represents the entire game object with all its properties and Associated methods making all of these available from inside obstacle class now icons look a game and I can see obstacles array is completely empty to fill it all I have to do is call init method we just wrote like this now I can see the array contains five obstacle objects I double check to make sure all properties have values if you see undefined in any of these it means there is a problem in your code base all is good here same as I'm drawing and updating the player from inside game render method here I would like to draw all five obstacle objects on canvas I take obstacles array from 77 we already know that it contains five objects and that each of these objects was created using our custom obstacle class from ion 52 so they all have access to this draw method we defined on line 59 so here inside render I take that obstacles array and I call builtin array for each method the for each method executes a provided function once for each array element first we need to Define a variable name which will be used within this for each method to refer to individual objects in that array I will call each object obstacle so for each obstacle object in obstacles array I call their Associated draw method from line 59. on line 59 I can see that it expects a reference to context as an argument to specify which canvas element we want to draw on it's along this context that was passed to the parent render method nice we are drawing one player and one two three four five randomly positioned obstacles I go up here and I make the obstacles a bit larger every time I refresh browse the window they get positioned randomly somewhere within the canvas area because that's how we Define their position on lines 55 and 56. what if I want to make sure that the obstacles never overlap like this and maybe to take it even further since these will be solid obstacles that player can't move through and has to walk around them I would also like there to be a minimum spacing between them and also between the edges of the game area just to make sure all the creatures that will soon be crawling here don't get stuck and can eventually find their way automatically around each obstacle it's actually easier to implement all of that than you might think but we have to take it step by step and explain a couple of Tricks we can use here to achieve that inside init method we are simply adding five randomly positioned obstacles right now I have to delete this we will need to structure this code a bit differently here so first I want to make sure the obstacles don't touch that they don't overlap like this we could also adjust the number of obstacles to be the maximum number of circles possible that can fit into a certain area without any two of them overlapping sometimes we call this circle back in so let's write a very simple Circle backing algorithm here I will use the basic technique where you just try to place circles at random positions many times and only those that don't collide with already existing circles will actually be turned into obstacle objects and drawn this is also called a Brute Force algorithm it's not very smart it just tries over and over many many times I will create a lead variable called attempts it will be my safety measure we will count how many times we tried to draw a circle and we will give up after a certain number of attempts the Assumption being that there must have already been enough opportunity entities to place the obstacles I will use a while loop you have to be careful with this one if you create an infinite while loop you will slow down your browser and you will need to restart it very old computers might even freeze if you use while a loop wrong new browsers can usually deal with it my goal here is to randomly Place circles over and over and before we actually turn that circle into obstacle object we check if it overlaps with existing circles only if it doesn't overlap we add it into the obstacles array I want this while loop to run as long as optical's array length is less than number of obstacles less than five we defined that array here and number of obstacles was defined here as a backup I also set a secondary condition only continue running this while loop as long as attempts is less than 500. this is important because if I set radius of an obstacle to be a very large number or I set number of obstacles to be so large that they can't physically fit into the available area we would get an endless while loop but with this secondary condition JavaScript will just try 500 times and if by that time they couldn't find placement for all the obstacles it will give up think 500 attempts is more than enough every time the loop runs we have to increase attempts by one for our safety backup plan to work every time this while loop runs we create a temporary object I call for example test obstacle it will be equal to the new obstacle and I pass it again this keyword as an argument as we did before let's consolock this test obstacle nice we have 500 test obstacles in console now you can see they have Collision X Collision Y and collision radius properties as they should my goal now is to take this temporary test obstacle object and compare it against every other obstacle in obstacles array of course at first this array is empty so the first obstacle should always be placed without issues the second test obstacle will compare itself with the first one that's already in the array and so on so for each obstacle in obstacles array I will run a circle Collision detection formula Circle Collision detection in JavaScript is quite simple we basically need to calculate the distance between the two Center points of those two circles then we compare the distance between two Center points with the sum of the radii if the distance is less than radius of circle 1 Plus radius of circle 2 they overlap if it's exactly the same the circles are touching if the distance is more then the sum of radii there is no Collision we already did this when measuring the distance between player and mouse this time the two points we want to measure the distance in between is the center point of obstacle Circle one and center point of obstacle Circle 2. so again we are creating this imaginary right triangle where DX is the difference between two points horizontally Dy is the difference between the two points vertically and the actual distance is the hypotenuse of that triangle so here we use Pythagoras Theorem formula or a builtin method hypotenuse method passing it to DUI first and DX second so now we know what is the distance between the two Center points sum of radii is a radius of circle one in this case radius of test obstacle and the second one is the radius of whatever obstacle object inside obstacles array we are currently cycling over as we said if the distance is less than sum of radii how will I do this outside the for each method I create a flag a lead variable I call overlap and initially I set it to false if the distance is less than sum of radii we set overlap to true because Collision was detected outside the for each method if overlap is still false after we created test obstacle and after we compared it using Collision detection formula with every other existing obstacle in the array if it doesn't collide with any of them and overlap a variable is still false after all these checks only then we take obstacles array and we will push this test obstacle that passed our checks into the array now when I refresh the game five obstacles will be randomly positioned and they will not be overlapping because those that do overlap are discarded and only nonoverlapping circles are used because I have my safety measure here on line 108 and we always stop this while loop when we reach 500 attempts I can actually go up here and I can set the number of obstacles to a large number that I know will never fit our code will just place as many obstacles as possible and then it will stop trying we know this is working because if I keep refreshing my project over and over we never see overlap in circles I mean no obstacles overlap with each other player can overlap at this point with obstacles we don't care about that right now I set the number of obstacles to 10. now let me show you how we will be attaching images to the circular collision hitboxes and how to position the image in relation to the hitbox so that it makes Visual sense and creates an illusion that this is not flat canvas but a threedimensional environment where the player can actually walk around these obstacles you can download all project art Assets in the resources section Below in index.html I create another image element with an ID of obstacles and Source will be obstacles.png that image is a Sprite sheet we will randomly cut out one of these frames for each obstacle object I don't really want to draw the actual image element so I hide it with CSS inside obstacle class Constructor I create a new property I call this dot image I point it towards that obstacle Sprite sheet using get element by ID like this let's set the number of obstacles to one for now inside the draw method on obstacle class I call builtin canvas draw image method this method needs at least three arguments the image we want to draw so this dot image from line 58 and X and Y coordinates where to draw it I will draw it at this dot Collision X and this dot Collision Y at first doing this will simply draw the entire image Sprite sheet and the top left corner of this Sprite sheet will be starting from the center point of obstacle Circle because this is how by default images and circles are drawn on HTML canvas if I refresh the project our new obstacle is positioned randomly somewhere on canvas I created this Sprite sheet for you so I know that individual frames are 250 pixels wide I save that value as Sprite width variable Sprite height will also be 250 pixels if you are using a different spreadsheet you can get the width by dividing the width of the entire Sprite sheet by the number of columns and the height is height of the Sprite sheet divided by the number of rows in case we want to add scaling later I will also create independent width and height properties for now they will be equal to Sprite width and Sprite height because I sized the Sprite frames to the exactly same size as I want them to be drawn in the game draw image can also accept optional fourth and fifth arguments defined in the width and height the entire image will be squeezed or stretched to the area we defined by these values it will look like this what I actually want to do is to crop out one of these 12 obstacles and draw only that one at the size of 250 times 250 pixels for that I need to use the longest version of draw image method that expects 9 arguments those nine arguments are the image we want to draw Source X Source y Source width and Source height of the area we want to crop out from the source image and destination X destination y destination with and destination height to Define where on destination canvas I want to place that cropped out piece of image onto so if I pass it 0 as a source X and 0 as Source height and Sprite with Sprite height like this as Source width and Source height I need to spell width correctly so now we are drawing the top left frame in our Sprite sheet as I said before I will set separate X and Y position for the Sprite sheet there are multiple different ways to do this I can just simply position the image directly on top of collision X which is the center point of collision Circle minus the width of the image times 0.5 this will Center the image horizontally exactly over the Collision Circle to actually apply this I need to use Sprite X as destination X property passed to draw image method here be careful when passing arguments to draw image method the order in which you pass these arguments is very important okay if I refresh the page I can see it's been correctly centered horizontally I do the same thing for sprite y and I use it as destination y property passed to draw image method now the spreadsheet is directly on top of the Collision Circle I set Collision radius to a smaller value I want this small Collision area to be positioned at the base of the plant where the stone is because that will be the solid area that's touching the ground that our game characters will have to walk around since our Sprites are set size of 250 times 250 pixels I can actually use a hardcoded value here plus 40 we'll move it up minus 40. minus 50. minus 60 minus 70. yes this seems all right I said that the number of obstacles to 10. what if I want to make sure that not obstacles so don't overlap but also that there is a additional minimum 100 pixel space in between so that they are more evenly spaced out around the available game area as well as allowing enough space in between the obstacles so the game characters can easily walk around them I create a helper variable I call for example distance buffer and I set it to 100 pixels like this then I include the distance buffer here in sum of radii to apply this buffer in between obstacles when we are placing them nice to make sure this is working I increase distance buffer to 150 pixels that should make it even more apparent yeah so this is how we can easily control obstacle spacing I also want to make sure that obstacle Sprite images are entirely drawn within the game area and not partially hidden behind the edges I could have done this inside obstacle class Constructor when defining these values initially or I can also just do it here since we are not drawing that many obstacles and their positions are calculated only once on the first page load anyway I make sure the left edge of obstacle Sprite sheet is more than zero so it's not hidden behind the left edge of canvas at the same time I make sure that the right Edge is not hidden so Sprite X must be less than the width of the game area minus the width of the obstacle nice when I refresh the page I can see horizontally obstacles are always fully visible for vertical position I want to check the image but at the center point of collision a circle more than zero vertically will not be enough I want to Define an area that is reserved for this background artwork I don't want to Grant obstacles to appear over this area I create a property called top margin I guess a desktop area is around 260 pixels of height let's check here yes 260 looks alright because I want to make sure the base of the obstacles doesn't overlap with this top area but I don't mind if the top of the obstacle Sprite sheets overlaps like this because this looks like the obstacle plant is standing in front of the background Forest View so this is fine I will also check if the center point of obstacle Collision area circle is less than the height of the game area I want some margins I can for example create a helper variable that's equal to Collision radius of the test obstacle times two I replaced this hardcoded value with this.top margin property we defined plus I want to give it some additional top margin so that characters and special enemies can squeeze in between obstacles and game boundaries when walking across the game field horizontally from right to left I will also account for the margin from the bottom of the game area to create some space there we wrote code that automatically places obstacles in our game World these obstacles never overlap and their correlation areas are placed to allow enough space in between them this will make the next steps much easier because we need enemies and friendly NPCs to be able to automatically walk around them using very simple artificial intelligence we have different images for obstacles but right now we are drawing only the first top left frame at coordinate 0 0. we can crop out different areas from the obstacles Sprite sheet horizontal crop area will start from the position we pass as Source X argument to draw image method here zero times Sprite width is this Frame one times Sprite width will be this Frame two is this one three is this one back to zero to select from which row we are cropping we use Source y argument here again we multiply row number by the actual height of individual Sprite frames so zero times Sprite height is this one times Sprite height is this now we are on Row 2 and there is no Row 3 because we start from row zero images are drawn and cropped from the top so instead of hard coding these values that are currently set to 0 0 let's turn them into class properties for cloud Authority and easy control this.frame X will determine which column we are on in our obstacle Sprite sheet if I do a random number between 0 and 4 this will not work there is no column 1.74 for example we need integers numbers without decimal points so I wrap it in my third floor to round the random value generated by Mazda random to the closest lower integer this code will give me either 0 or 1 or 2 or 3. so one of our Sprite columns when we multiply these integers by the width of a single Sprite frame and we pass that value as a source X argument to draw image method we are defining horizontal cropping coordinate that worked perfect I will do the same for frame Y which will determine Sprite row we have only three rows this line of code will give me integers either 0 or 1 or 2 corresponding to the number of rows we have available in our obstacle Sprite sheet now we can replace this hardcoded 0 with this dot frame y so Source y argument passed the draw image method will be this dot frame y times this dot Sprite height I will do that in a second random values in frame X and frame y combined will give us random image out of these 12 available obstacles each obstacle object will have random frame from this Sprite sheet assigned to it I will finish this a bit later on the main game object I create a method I call check Collision I want this to be a reusable utility method that takes object a and object B and it will compare them and check if they are collided or not we will be able to use this all over the code base wherever Collision detection between two circles is needed the way I'm building my game all characters and objects will have a circular Collision area which will be a solid base that nothing can walk through and everything will react and walk around everything using this we can also push things around I will show you to check collision between two circles we have Circle A and A Circle B here we need to check DX first the distance between the center point of Circle A and the center point of Circle B on horizontal xaxis this reusable method will work only if all objects involved have properties with same name and conventions so we will make sure we name X and Y positions on each object as Collision X and collision y I'm using this overly descriptive property names so that it's very clear when X and Y coordinates relate to Collision area Circle and when they relate to image Sprite sheet positions this is a tutorial so I want things to be very clear and easy to understand we will also need a DUI the difference between the center point of Circle A and the center point of Circle B on the vertical yaxis then we want to know the distance between these two Center points so hypotenuse the longest side of this imaginary right triangle right angle 90 degrees is here and this is the distance Pythagoras Theorem formula or alternatively builtin method hypotenuse method and we pass it Dy first and the X as the second argument to determine whether or not there is a collision We compare distance between these two Center points with radius of Circle A Plus radius of Circle B I will save this value as a custom variable I call for example sum of radii so if this tense is less then sum of radii we know the circles Collide if the distance is the same as the sum of radii circles are touching if the distance is more than the sum of radii we know there is no Collision this function will simply return true if there is collision and false if there is no Collision let's use our custom check Collision function up here inside update method on player class we check for collision between player and obstacles we have a one player object and multiple obstacle objects so to compare all we will call for each on obstacles array which holds all currently active obstacle objects I will call each object in the array with a helper variable name obstacle and I will console log check Collision method we just defined we know it expects circular object a and circle object b as arguments to compare the distance of their Center points to the sum of their radii so I pass it this which means this player object as Circle 1 and obstacle we are currently cycling over with this for each method as Circle B keep in mind that this reusable check Collision method can only compare objects that have Collision X Collision Y and collision radius properties defined in their class Constructor so I will make sure I keep the same name and conventions for all objects in the game we are building today as the player moves we are getting false and true in the console seems like this is working let's actually only console log the word Collision when collision between player and obstacle is happening now it's even easier to see that our code is working perfect inside render method I will draw obstacles first so behind and player after it so it will be drawn on top what if I want to also resolve our collisions what I mean is if player collides with an obstacle I don't want it to be able to walk through it like this I want the player Circle to be pushed one pixel back away from the obstacle Circle in the direction that points directly away from the center point of the obstacle this simple thing will make the obstacle solid and the player will actually slide around the obstacles and it will create nice physics let me show you I'm already calculating everything I need for that inside our custom check Collision method but this function currently returns only true or false I need this reusable method to return more values so that we can use them inside player class to calculate Collision resolution Vector functions and methods in JavaScript can return one value like this but they can also return an array that contains multiple values I want to return true or false Collision status as the first element in the array element with an index of zero we also want to return the distance we are calculating on line 127 we will also need some over ADI from line 128 and we will need DX and Dy from lines 125 and 126. so now our custom check Collision method not only checks if Collision is happening or not it also gives us other values from calculations that happened along the way it's important that we remember the order in which we are returning these values element with an index of 0 is Collision status true or false element with an index of 1 is the distance sum of radii is index 2 DX is index 3 and d y is index 4. I will just copy that array that gets returned here and I comment it out just so I can see it as a helper reference now I want to take each of these values and save them as separate variables so that we can use them to calculate Collision resolution here and push to player in the correct direction away from the obstacle it's currently colliding with I will use something called restructuring assignment let's just write it and I will explain it when we see the whole thing I say let variable is this array and it is equal to check collision between this player object and the obstacle that for each method is currently cycling over I have to replace this first expression with a variable name I want to call it I want to call it Collision it will be that true or false value depending on the distance between Circle Center points so if this is true there is Collision if this is false there is no Collision the structuring assignment syntax is a JavaScript expression that makes it possible to unpack values from arrays or properties from objects into distinct variables I'm basically saying here create five variables for me the first variable called Collision is the array returned when we call check Collision method between displayer and obstacle index 0 distance variable is that array index 1 and so on the structuring assignment does this automatically behind the scenes it creates these five variables and pairs them with the values that sit at these indexes in the array returned by check Collision method this might be a bit strange if you never saw it before JavaScript destructuring is a good thing to get familiar with modern Frameworks use it a lot I'm basically just taking the array returned by check Collision method and I'm assigning each value to its separate variable name so that I can use them here so here we are inside update method on player class we are cycling through obstacles array comparing player with each obstacle object if there is collision between player and obstacle if Collision variable is true we consolock AAA this works I want to create a vector kind of a small line between 0 and 1 pixels in length that line will point in the direction in which we want the player to be pushed to resolve the circle Collision to make sure that colliding player and obstacle repel each other causing the player to slide along the radius of the obstacle rather than going directly through it horizontal Vector will be the ratio between DX distance between player and obstacle center point on the horizontal xaxis and the actual distance between these two points we calculated before using check Collision method because DX will always be less than distance because distance is hypotenuse it's always the longest side of the imaginary right triangle unit X will always be a value between a 0 and 1 because we are dividing smaller value by a large value unit y will be the ratio between d y the distance between Center points on the vertical yaxis and they are actual distance between the two Center points again it will be a value somewhere between 0 and 1. this could also be negative values depending on how our objects sit in relation to each other on horizontal and vertical axes so actually unit X and unit y will be a value between 1 and plus 1. if I consulate unit X and unit y we can see these values the combination of these two values being added to players horizontal and vertical position for each animation frame will make it move in a certain direction and certain speed away from the center point of the obstacle I do that by taking player Collision Exposition the center point of players Collision Circle to push it outside the radius of the obstacle it is colliding with I move it horizontally to the position of center point of obstacle circle plus the sum of radii of player Circle and the obstacle circle plus one additional pixel outside times that unit X ratio to give it the right direction away from the obstacle's center point we do the same thing vertically center point of player Collision Circle will be moved to the position of collision center of obstacle circle plus sum of radii of obstacle and player circle plus 1 pixel times unit y to give it the right direction of the push I am trying to explain this in a very beginner friendly way but don't worry if it's still a bit unclear this is an important technique and every time you use it you will feel more and more familiar with this code eventually it will click for you how it works all you have to understand here is that this code is pushing the player one pixel outside the Collision radius of the obstacle in the direction away from the center point this is how you create very simple but very effective physics simulation in your game try to move the player around this feels very good doesn't it suddenly our obstacle circles turned into solid impossible objects well done if you followed all the way here this is the main trick we are using today for our physics game I adjust the speed modifier to a smaller value we learned how to make the player move towards a mouse or towards a specified point in a 2d space and how to make it navigate its way automatically around solid obstacles this is a powerful technique and you can do with it more than you can imagine we will explore some of that today hope you're having fun I prepared a special 8directional player Sprite shoot for this class you can download it in the resource section below I will include some alternative colors probably mine is blue too much to mushrooms in my game art I will hide it with CSS here inside player class Constructor I create a reference to that image using get element by ID and I save it as this.image property inside our custom draw method I take context and I call builtin canvas draw image method that we already used before we already said that the draw image method needs at least three arguments the image we want to draw and X and Y where to draw it this will just draw the entire Sprite sheet we can pass it width and height to squeeze the entire Sprite sheet into that specified area we actually don't have these properties defined Sprite with the width of a single frame will be 255 pixels Sprite height is 255 as well then we create separate width and height properties to allow the potential if we want to introduce it later now we are squeezing the entire Sprite sheet into the area of one Sprite frame you probably already know that we will need the longest version of draw image method where we add Source X Source y Source width and Source height these values will first crop out a portion of the image in our case a single Sprite frame after that we draw that frame at the position defined by the last four arguments to draw the top left frame at coordinate 0 0 is simple we just did it with obstacle Sprite sheet Source X Source y 0 0 to define the beginning of cropping rectangle and Sprite width and Sprite height as Source width and Source height arguments to Define its size now we see only one frame I will calculate position of sprite sheet image in relation to Collision X and collision Y coordinates of player hitbox in these two separate properties just for clarity so keep in mind these properties Define the center point of player Collision Circle these two properties will Define the top left corner of sprite sheet frame image we are currently drawing to represent the player on canvas Circle coordinates are from the center point rectangle and image coordinates are from its top left corner and image and rectangle goes towards right bottom depending on its width and height from there we have to consider this when writing the following code Sprite X will be positioned in relation to Collision area it will be Collision X the center point of collision Circle minus half of the width of player frame like this I need to use Sprite X inside the draw image method as destination X argument here and for this to work we need to recalculate this value every time Collision X updates so I need to put this inside the update method here and I also do it for sprite Y which will be Collision y minus the half of player height I can delete it here and I use Sprite y property here as a destination y argument past the draw image method now it's positioned on top I actually want this Collision Circle to match the little shadow on the ground below the player as closely as possible because that's the contact point we will use when interacting with other objects in our game since the player is fixed pixel size I can offset it by a hardcoded value if we were scaling our characters in this game I would use a relative value here minus 100 moved the player image up so this is all right for now same as we did with obstacles Sprite sheet I want to navigate within our Sprite sheet by swapping from frame to frame horizontal navigation is handled by multiplying Sprite width by an integer representing the column in the Sprite sheet passed as Source X argument here when we cycle through this we will animate individual directions individual animation Loops to swap between directions in the spreadsheet the way our specific Sprite sheet is organized today we have to multiply Sprite height by an integer representing Sprite row you can see row 0 is player facing upwards away from us Row 1 is top right two is the player facing right three is bottom right 4 is facing down towards the camera Row 5 in our Sprite sheet is the player facing bottom left 6 is facing in left I think you get the idea I put these integers into class properties frame X for horizontal Sprite navigation frame y for vertical I replace these hardcoded values with my new variables and now I can change what frame we are currently cropping out from the player Sprite sheet by giving different values to frame X and frame y I want to change frame y the row we are currently animating from the Sprite sheet which will determine where the player is facing I want that to depend on the current angle between Mouse and the player on the position where they are currently in relation to each other for this we have a builtin method called mass.atan2 returns an angle in radians between the positive xaxis and a line projected from 0 0 towards a specific point we will use it to calculate the angle between the player and mouse cursor and based on that angle we will select which Row in the Sprite sheet we want to animate so that the player is always facing in the direction it is moving towards the mouse cursor we will need DX and d y so I move them up here so these values calculated the distance between the player and mouse cursor horizontally and vertically keep in mind that it makes a difference if you use Mouse first or the player first in this calculation I already wrote this code here before without thinking we would use it for this so we might have to adjust to it a bit I will show you exactly what I mean Master datan 2 expects DUI first and DX as the second argument I will consult angle we are calculating and I can see it is changing and the values are from a minus 3.14 minus Pi 2 plus 3.14 plus pi this checks out because we know that full circle is 2 pi approximately 6.28 radians which converts to 360 Degrees I will repeat that method A10 2 returns an angle in radians between the positive xaxis and a line projected from 0 0 towards a specific point because I'm using Mouse first and the player position second when calculating DX and d y I'm getting values from a math.a time to where the current Mouse position represents point zero zero and player position is the point we are projecting a line towards for the purposes of a nice visual it would work much better if player was the static 0 0 center point but I will leave with others and from the values I'm getting in the console I will create this graph with breakpoints in radians it was actually easy to make because I just needed one value as an anchor and I knew the whole area is from 3.14 to plus 3.14 and we have eight player directions so each slice was 6.28 divided by 8. anyway you don't necessarily have to understand all of this right now when we have the full code you can play with the values which will hopefully bring more clarity it took me a while of using math but atan 2 before I fully understood so if this is your first time seeing it don't put too much pressure on yourself if I pause the screen this is the point zero zero this is the line projected towards another point and master data and 2 gives us an angle in radians between this positive xaxis and this line so by using this console log to get an anchor point so that I can see which angle values we are getting I constructed this helper visual which I will now use to correctly swap player rows in our Sprite sheet to make the player always face the mouse if angle is less than 1.17 set frame y to zero I will copy this a few times minus 0.39 is frame y 1 plus 0.39 is frame Y2 1.17 radians is frame Y3 1.96 is frame y4 let's see hmm so far this is working great I think we got it I can delete the console log 2.74 is frame 5. this area is a bit weird as the circle ends and starts I have to say if angle is less than minus 2.74 or if angle is more than plus 274 I want to use frame Y6 if angle is less than minus 1.96 frame Y is 7. pay attention to brackets here minus and plus values and less than operators if you are getting any unexpected Behavior make sure all of this code is the same as mine it's easy to make a small mistake here and break your code accidentally for this to work for all directions I have to adjust it a bit I can for example take these lines and put them here because with else if statement it matters which one is checked first sometimes I reduce the player speed modifier to 3 so we can clearly see how it turns while destined now we can turn the player in all eight directions perfect we will learn more about sprite animation later in the class for now I'm happy with this physics game where we are placing Collision areas at the base of each object we want to be able to quickly swap between the view where these Collision areas are visible and invisible it will help us to tweak the physics and gameplay elements as we are developing them while giving us an easy way to check how the changes we just made will be visible for the player who will not see these hitboxes I want to create a debug mode by pressing letter D on the keyboard we will toggle all helper Collision elements on and off on the main game class I create a property called this dot debug and initially I set it to true down here where we placed our event listeners I create another one we will listen for key down event let's just console event object when I select canvas by clicking on it and then I press any keyboard key we get this Auto generated keyboard event object inside we have a property called key you can see I pressed letter R so the key that was pressed sits inside e.key property I say if e dot key is a d set debug property from line 123 to its opposite value so if it's currently true set it to false if it's false set it to true this way pressing the same key letter D will toggle debug mode on and off I tested by console login this dot debug I press D over and over and in console I see it switches between true and false perfect I remove the console log up here inside the draw method on obstacle class I say if this dot game.deback is true only then draw the Collision area Circle now I can press letter D to show and hide them that works well I want to do the same for the player if this dot game.deback is true only then draw the Collision Circle and also the line between the player and the mouse in this case positioning and size of the hitboxes is not perfect yet but we do have all the logic in place now great job I can make a collision radius of each obstacle smaller to better match the part where it touches the ground we have different obstacle types here the mushroom and this big carnivorous plant should probably have different Collision circles which can easily be done but for now I'm happy with this you can see that the Collision formula we wrote before is all we need to give the player very simple path finding ability it will just walk around obstacles automatically and since we placed obstacles in a way that there are always spaces in between it's unlikely that the player will get stuck I can also see I'm only getting the first four obstacle images which reminds me to go here to line 108 and include randomized frame y value as Source y argument in obstacle draw image method now I'm randomly getting one of all 12 obstacle images you can play with this end position and size your hitboxes differently if you want I'm happy with what we did so far I wanted to make sure the player can't walk so high that it's above this background artwork area let's create some horizontal boundaries first point of player Collision circle is less than x coordinate 0 plus Collision radius set it to zero plus Collision radius so when the left edge of the circle is touching the left edge of canvas area don't allow it to go any further left I want to do the same thing for the right Edge of course we can delete this zero plus here and here if the center point of player Collision circle is more than the width of the game minus the radius of player Collision Circle make sure it can't go any further right nice vertical boundaries if Collision Y is less than vertical coordinate zero plus top margin we defined to be 260 pixels from the top plus Collision radius make sure that the player can't go any more up that works nice this is what I wanted again we can delete 0 plus here and here bottom boundary that's simple if Collision Y is more than the height of the game minus Collision radius make sure it stops there like this that works if I make player Collision radius smaller than obstacle radius because of the margin we defined while positioning obstacles there will always be a place for a player to squeeze between obstacles and the edges of game area there is not so down here I increase that margin they should do it you can compare your code with in progress source code I will include to download in a project section Below in multiple points during this class as we progress with our project I can see the bottom of the Sprite sheet is being cut off on the lower rows it's because the height of a single frame is actually 256 pixels now it's fixed in Visual Studio code editor I select the view word wrap to make the code break to another line if it cannot fade if it's too long I want to set FPS for the entire game because with my previous project a lot of you mentioned that games run too fast on your game in high refresh rate screens request animation frame a method we are using here will automatically adjust itself to screen refresh rate so for normal screens that would be around 60 frames per second but on some of the new gaming screens that people use that speed would be double or maybe not exactly double but much faster we will calculate Delta time the amount of milliseconds that passed between each call of request animation frame and we will only allow the game to serve the next animation frame when a specific number of milliseconds has passed we can calculate the Delta time down here inside our custom animate function first I Define last time outside the function like this initially I set it to zero this variable will always hold a reference or the amp from the previous animation Loop so that we can compare it with the current timestamp and the difference between them will be Delta time request animation frame has two special features as we said it will automatically try to adjust itself to the screen refresh rate in most cases 60 frames per second it will also automatically generate a timestamp for us that we can use and it will pass that timestamp as an argument to the function it calls in our case animate imagine it's passing the timestamp here like this automatically it's Auto generated all we have to do to use it is to assign it a variable name here I will call it timestamp spelled like this be mindful of Laurel and uppercase letters when defining your variable names in JavaScript it matters let's just console log this autogenerated timestamp variable that request animation frame is giving us just to see what format it is in you can see it gives us milliseconds since the first animate was called one second is a thousand milliseconds so here I can literally see that the game started 9 10 11 12 13 seconds ago I delete this console log we know we have access to the current timestamp so let's use it to calculate Delta time it will be the difference between the timestamp from this animation Loop and the timestamp from the previous animation Loop Delta time is the number of milliseconds it took our computer to serve the next animation frame once we used last time to calculate Delta time we assign it to the current timestamp this way the current timestamp can be used in the next animation loop as the old timestamp for the very first animation Loop last time will be zero but after that it will always hold the value of the tab step from the previous animation frame so that we can compare it with the value of timestamp from this currently running animation frame and that difference between them is Delta time so let's consolow Delta time to see if it worked my Delta time is around 16.6 milliseconds thousand milliseconds divided by 60 is 16.6 so this checks out I wonder how many of you got the same Delta time and how many of you got a different number if you have a high refresh screen your Delta time will be a much smaller number if you have an old computer that is struggling to animate our game your Delta time might be much higher if you have a second to write your Delta time in the comments so we know if most people get the same or very different values than me it will help me to better optimize my future courses if I scroll up in the console to the very first timestamp you can see that the first two values of Delta time are none not a number it is because the very first timestamp is undefined because only on the second Loop this timestamp value gets Auto generated by request animation frame the first Loop is not triggered by request animation frame it's triggered by this line so in the beginning when we say that Delta time is undefined minus 0 here we get none not a number it automatically fixes itself as the loop runs but these two initial not a number of values could break your code that depends on Delta time unless you account for it with some kind of or statement for example the easiest way to fix this is to pass 0 here as the timestamp for the first animation loop from the second Loop the value will become the auto generated downstamp because after that animate will be called by request animation frame as you can see we get numbers here and there are no nonvalues anymore perfect I delete this console log so let's use Delta time to set frame rate of our game we will need some helper variables FPS frames per second will be for example 20. timer will count over and over from zero towards a specific value when it reaches that value it will trigger the next animation frame and it will reset back to zero interval will be that breakpoint value that when reached will reset timer it will be a thousand milliseconds one second divided by FPS this will give us the amount of milliseconds needed to achieve this specific FPS we will manage this Frame handling logic down here inside render method if timer is more than interval do something at the same time keep increasing timer by the value of delta time over and over so when timer accumulated enough Delta time enough milliseconds that its value is more than interval we will animate the next frame we will also reset timer back to zero so that it can count again for the future frame update I will take all this code and I put it inside the if statement like this we are using Delta time value on line 173 that value will be passed as an argument to render method up here and inside animation Loop we are calculating Delta time here and we will pass it to render like this okay so something is happening the reason everything is blinking is that we are deleting old paint all the time but only redrawing our game when timer reaches interval cut this clear rectangle from here so now we are not clear in old paint at all and everything is animating at 20 frames per second and everything is leaving trails and I will clear old paint only when we are ready to redraw the next updated game frame here so context clear rectangle from chlorine at 0 0 two distort with desktop height to clear the entire game area one optimization would be to draw our game on multiple canvas elements and only clear the portions of cannabis that actually updated that way we wouldn't have to redraw everything all the time for now this will work fine you should be able to see a slow down ingame animation speed because we are setting FPS here to 20 to make it even more obvious maybe I only want to animate 5 frames per second 30. 40. 50. 60. I'm setting fps to 60 frames per second but we are not actually animating our game at 60 FPS because every time I reset timer back to zero there is some leftover Delta time I am not accounting for so even though I say 60 the actual FPS is a bit lower I can go down and I can account for that leftover Delta time but maybe I want to keep this code base lightweight maybe I don't want to make JavaScript to do even more calculations over and over so while keeping this in mind I will know that I have to set fps to a slightly higher value here to actually get something around 60 FPS if I set this to 70 I think we get smooth enough movement and we are not making JavaScript calculate leftover Delta time which would slightly increase how performance demanding our game is I just thought of this now I'm not sure which is a better solution I will leave my code like this for now but I guess the right solution here will be up to everyone's personal preference feel free to discuss this in the comments I will consider your feedback in my future projects now that we know how to control animation speed of our game using Delta time the game will run at a similar speed on every machine even for those of us who are using High refresh rate screens I want to add eggs that can be pushed around to include even more physics in our game those eggs will be hatching into creatures after a specific timer has passed and player's job will be to protect the creatures that hatch the eggs can be pushed around by enemies but they won't be destroyed the challenge for the player is when they hatch enemies will eat the hatchlings so player's job in our game will be to position the X to protect them or to push enemies away from the path of the newly hatched creatures The larva that comes from each egg will always try to crawl into safety and hide in the bushes inside the mushroom Forest at the top this will introduce a lot of player choice and player options into our game while using physics we implement it I got an idea for this game a mechanic while watching a nature documentary where little baby turtles are hatching on the beach and trying to get to the Sea for safety in our game we control the Blue bull its job is to protect the hatchlings by pushing eggs larvas and enemies around this game is all about physics and positioning I will have a custom class I call for example egg Constructor will expect a reference to the main game object as usual to make sure EK class has access to many important properties held on the game object X will be part of the game physics so I need to make sure I Define separate X and Y coordinates for Collision Circle Center Point and for the Sprite sheet let's start with Collision X property it will be a random value between 0 and the width of the game area Collision y will be between 0 and game height like this Collision radius for example 40 pixels this dot image will be document.getelementbyid and the ID is act in index.html I actually have to create that image element as always images can be downloaded in the resources section below I hide it with CSS here I'm keeping the same name and conventions across my objects it's a good practice so Sprite width will be 110 pixels and Sprite height is 135 width and height will be set to these same values in our game every object has Collision X and collision y properties that represent the center point of collision area Circle even player and obstacles have the properties named like this so that we can use reusable Collision detection method to implement our physics to everything same goes for sprite X and Sprite y properties those represent the top left corner position from which the object's image will be drawn Sprite X of egg image will be Collision X plus half of the width of the egg image to Center the image over Collision Circle horizontally Sprite y will be Collision y plus half of image height we might have to adjust this a bit later because vertically we want the Collision area to be at the base of the egg not in the middle we'll get to that soon draw method will expect context as an argument as usual we call draw image and this time we just need three arguments the image we want to draw and X and Y coordinates where to draw it if we were scaling we would also include optional width and height arguments like this but I'm giving you all the images in the same size we are drawing them in game so it's actually not necessary as with all game objects we are not only drawing the image representing the object we are also drawing Collision Circle if debug mode is active since we are keeping the same naming conventions for properties all over our code base we are making our life easier I can just copy this entire code block and use it here so we are drawing X image and if debug mode is on we are drawing Collision area yes probably it's a good idea to put this code in a reusable method since we are using the same code to draw Collision circles for everything I might do that later for now I want to create a method that will periodically add a new egg into our game on the game class we will have an array that will hold all currently active egg objects I will also have another property called number of eggs or Max X describes it even better we will only be adding new x to the game until the total is less or equal to Max x value inside render method here we will handle the logic to add X periodically we already did it we did periodic event in this code base where we use the Delta time and triggered new game frame only when a certain interval value was reached we will actually do the same thing here we will need some helper variables for that egg timer will go from 0 to X interval value then it will add a new egg and it will reset so that it can count again we are operating with Delta time so milliseconds I want to add a new X let's say every 500 milliseconds down here I will check if egg timer is more than egg interval we add a new egg by calling this method from line 220. inside there I just take the X array I call builtin array push method and I will push one new instance of our custom egg class in there as usual we know that the egg glass expects the game as an argument so I pass it this keyword because we are inside that game object here so if egg timer is more than egg interval we call add egg we will also reset egg timer back to zero so that it can count again towards the next egg else we keep increasing egg timer by Delta time which we are already passing here to render method from before I console log this.x to see if the objects are being added sorry this will just create an endlessly growing array I need to create additional condition here only add new X as long as the length of X array is less than Max X that's better I inspect one of the egg objects I need to make sure all the properties have values if for example I have undefined as Collision x coordinate my X wouldn't be drawn on canvas because JavaScript wouldn't know where to draw them I see values on everything this looks great inside render method I would also like to draw my X I just copy this line and I adjust it for each element in X array we will call it egg and we will call draw method on it perfect now we are getting some visuals which will make it even easier for us to tweak the details and polish it the first thing I notice is that all the eggs are added almost instantly even though I said I want one egg every 500 milliseconds if I increase egg interval to one second here I can see that something is wrong with my code I know the problem must be inside this code block and it's because egg timer is more than egg interval and only then add a new egg we need to use this comparison operator here sorry about that typo you probably noticed it already before now it works we get one New Egg add it every one second as long as we have less than 10x I can also see that the egg images are positioned outside the Collision circles I change this plus to minus here and also here now that's better I want to adjust the X Sprite sheet in relation to its Collision circle plus 35 will move it up minus 35 will move it down minus 30. I want it to match the bottom of the image as closely as possible but also I don't want the Collision Circle to be too tall because I want the player to be able to walk behind the egg without pushing it to have this illusion that our game area is in 3D and that it has some depth even though in reality it's just a flat surface we will do more to enforce this in a moment now I want to create a margin to make sure the X appear certain minimum distance from the edges of the game area so that we can get the player between the egg and the edge to push it anywhere we want I want the margin to be let's say Collision radius times 2. the initial X position of collision Circle will be a random value starting from left from that margin value we just defined and game width minus that margin down here I set X interval to 100 milliseconds and I want 50x just to get a better idea where they can possibly spawn in our game we have that left margin I wanted but I can see that the eggs are too far to the right Edge so here I increase that right margin like this yeah I'm happy with this the eggs are now always fully visible horizontally with some extra space left and right between the edges of the game area vertically I will do something similar but the random position needs to start below the top margin area we defined earlier I don't want any X in front of this background artwork the way Master random works I just pushed the range from here to here I also need to narrow the range down by reducing the span of random values we get so game height minus top margin now X can appear from here to here I will reduce the randomized value by margin to give it some space at the bottom like this perfect if you are a beginner math at random can be unintuitive it's actually very simple it can just take some practice so here I'm saying set Collision y property to a random value starting from Top margin here because we're going from the top and the range of random values is game height minus that margin minus this other margin so X can appear anywhere between here and here vertically I set interval to 500 milliseconds and Max X to be for example 10 for now this means we will get an egg appear every half second until the total count is 10. this is a physics game so we wanted the player to be able to push the X around to move them out of the way of incoming enemies or to position them strategically to give the larva that will hatch from it the best chance of survival in this game I choose that X will be indestructible enemies will just push the X out of the way if they Collide but the larva that hatches will be eaten if anime catches it so positioning and pushing the X around is very important let's give the X some Physics I give each egg an update method inside we will create a temporary helper array called Collision object this will contain all objects in our game that X will interact with we will check for collision between each egg and this object so we will need player here this dot game.player like this and of course we need the solid obstacles in here I want all these elements to be on the same level in Collision object array we have player object here and we will spread obstacles array into Collision object array using spread operator like this spread operator allows us to quickly expand elements in an array into another array I will actually call this Collision object with an s I will call for each on it for each of these objects so in this case for player and all individual obstacles we have here I want to use this check Collision method we defined on line 225. if you remember it takes object a and object b as arguments and it returns an array that gives us true or false for Collision this stands between two Collision Circle Center points some of their radii and horizontal and vertical distance between the two Center points I copy this array I paste it up here and again we will use the structuring to quickly Define these five variables using a single line of code I need a variable name here so I will call the first one Collision true or false whether the echo lights with player or any obstacle we did this before I want these to be lead variables and they will be equal to this.game.check collision between this egg because we are inside update method on egg class and one of the objects in collisions object array so as the for each method runs we are running check Collision method between this egg and each element in this array and we are getting five variables that tell us more details about position and collision of these two objects we are comparing if Collision is detected we will actually use all these values to calculate how far and in which direction we want to push the egg horizontal direction of the push will be the ratio between DX the horizontal distance between the two Center points and the distance hypotenuse of that imaginary right triangle because DX is a side of that triangle and the distance is hypotenuse the longest side we are dividing a smaller value by a large value because of that unit X will be something between 1 and plus one DX can be positive or negative unit y vertical push direction will be the ratio between d y and distance now we will use this to move the egg we are inside a code block that will only run if egg is colliding with player or any of the obstacles so when Collision happens we take Collision X of the egg and we push it one pixel outside of the radius of the object it is colliding with so Collision X of the object the center point plus one extra pixel to move the egg outside of collision area so this is how far and the horizontal direction of that move will be defined by multiplying it by unit X which as we said can be positive or negative we also need to move the colliding egg vertically collision center point Y of the egg will be Collision y of the object it's colliding with Plus radius of egg Plus radius of the object plus one extra pixel so that in the next Loop Collision is false terms vertical Direction defined by unit y notice that here we are detecting collision and I am a moving Collision X and collision y of the egg based on the position of the obstacle this is just my choice and doing this will make the egg move and all these elements will be solid in that interaction when interaction happens egg will move player and obstacles will remain solid they will not be pushed by the egg down here we call draw method on each egg we also want to call this new update method we just wrote Let's test it we are pushing Collision circle of this egg I need to make sure that Collision area and Sprite stick together the simplest way would be to take this code that positions Sprite X and Sprite Y in relation to Collision X and collision Y and I will call it inside update method I can remove the values here and now we can push the X using player and they will also Collide and slide around our mushrooms and plants around the solid obstacles the eggs don't interact with each other this is just my choice I want the X to overlap so that a skilled player can push multiple eggs kind of hurt them together and push all of them at the same time this choice will also keep our code simpler because we are learning we are drawing everything on a single canvas element so the draw order of our game objects what is drawn behind and what is up front will depend on the order in which we call draw methods on each object from inside render method here right now I draw obstacles so mushrooms and plants then I draw X so X are drawn on top of obstacles as you can see here and then we draw the player player is drawn on top of everything else if I take the X and draw them first they will always be drawn behind the obstacles and behind the player and here we can see that it doesn't really make visual sense I wanted to create an illusion of depth fake 3D or maybe two and a half D objects that are low should be up front as we move up objects drawn on that vertical Baseline should be drawn behind for example this egg should be drawn in front of this plant not behind find it we can't really achieve that if we draw all X then all obstacles and then the player we need to adjust our code a little bit I will have to put all these objects into a single array and I will sort that array based on vertical coordinates let me show you what I mean I create a new property on the main game class I will call it game object at first this will be an empty array in a side render method I will take a game object and I will use spread operator to expand the entire X array inside I will also expand the entire obstacles array in here and I will add the player now we are holding all the game objects in a single array this array will be recreated every time render method ticks good optimization tip here would be to only do this operation when vertical coordinate of any element changes or when we add or remove an egg I will repurpose this code block and instead of calling for each method on X array I will call it on this new game object array for each element in the array I will assign it a temporary variable name for example object for each object in game objects array call their Associated draw and update methods for this to work it's important that all objects we add into game objects array online 217 have a draw and update methods defined on their classes otherwise the code would break because JavaScript wouldn't be able to find that method so we are calling draw and update on all game objects on all X on all obstacles and on the player that means I can now delete these lines of code typo here I spell the game objects with an s now we draw the first obstacle and then we get an error we call the draw on the first obstacle and when we try to call update on it we get a type error that says object dot update is not a function I go to my obstacle class and you can see as I said we have draw method here but there is no update method we are asking JavaScript to call a method that doesn't exist on this object I will create an update method here inside that method we could for example animate Sprite sheets of these plants and mushrooms every time the player collides with them or something maybe I will add some interactive obstacles later for now we will leave this method empty now it's working and we are calling draw and update on all X all obstacles and on the player alternatively I could have also solved the lack of update method on obstacles by some kind of if else statement down here there are always multiple ways to do something feel free to discuss how you would approach this different clay maybe we will get some better Solutions in the comments that I might use in future classes I appreciate when you give me feedback on my code and when you suggest improvements okay so now we are calling draw and update as we cycle through game objects which means X are drawn first obstacles are on top of X and player is drawn last on top of everything if I change the order of these elements here the player is drawn behind now then X and obstacles are on top of everything so now we can understand how the layering works it depends on the order in which we call draw method on each object to draw our game objects in the order that makes Visual sense I can now sort game objects array based on each object's vertical position I take game object array and I call builtin array sort method this method sorts the elements in an array and it Returns the same array now sorted by default if we call it without passing it any arguments it will just convert array elements into Strings and it will sort them based on their Unicode values we don't really want that so we will pass it an argument this optional argument we can pass to array sort method is a compare function a custom function that defines some logic it defines some specific sort order we want this special function will take two arguments element a and element B all elements in the array in our case in game objects array will be represented by this A and B and used in this logic we Define here I can do return like this and I want to sort the elements in ascending order based on the value of each object's Collision y property so we are sorting based on the vertical center point of collision circle area alternatively we could also sort by the bottom of sprite image which would be sorted by the value of sprite y plus Sprite height sort method can be complicated to understand if you are a beginner all you have to understand here is that I'm putting all my elements into game objects array then I'm calling builtin sort method on that array and I'm organizing these elements based on their vertical position it doesn't work now because I'm creating array I'm drawing and then I'm sorting I need to sort the elements after I created the array but before I draw them so like this perfect now this egg is drawn in front of the plant but if I use the player to push it up the X vertical position becomes less than the vertical position of the plant now the egg is drawn behind the plant this is one simple way how you can draw elements in a 2d game in a way that makes more visual sense it is a very powerful technique to add to your coding toolkit do you have any questions leave a comment you don't have to do the following thing I will do now I set X interval to 20 milliseconds and Max X will be 150 just testing if there are any problems we need to solve as I move through them the physics seems very good it's all working well having so many eggs for testing also gives me a pretty good idea where they might potentially spawn they appear in the area we specified with large top margin and smaller margin from left bottom and right we got X nice job coders I set interval to thousand milliseconds one egg every second and Max X will be 20. since we have this Collision formula in place If egg appears on top of obstacle or the player it gets automatically pushed outside its Collision radius I remove this control lock on line 237 we have our game world we have randomized solid obstacles we have Mouse controlled player character that can move in eight directions and we have X that spawn in specific interval on top of that everything collides and reacts to everything we can make so many different games with this let's add enemies I create a custom class I call for example anime as usual Constructor will take a game as an argument and we convert that reference to a class property we do that to get an easy access to all properties sitting on the main game class from inside anime class through this.game reference we need to keep the same name and conventions here so Collision radius 30 pixels Collision X Center Point of collision Circle will be the right edge of canvas this.game.width a collision y will be a random value between 0 and the game height value coming from here speed X horizontal speed will be a random value between 0.5 and 3.5 you can download anime image in the video description at first we will start with a static single frame ID will be told Source will be told.png I hide it with CSS because we want to draw it with the JavaScript on canvas this dot image property will be get element by ID and the ID we gave it was told Sprite with in this case 140 pixels and Sprite height is 260. I will also create width and height properties and we will Define Sprite X and Sprite y positions of the Sprite sheet image which will be positioned in relation to Collision Circle coordinates raw method will take context as an argument builtin draw image method and because the image file I'm using is already the same resolution as the size I want to display it in the game I only need to pass it three arguments the image I want to draw and X and Y where to draw it I will also copy Collision Circle visual that will appear only when debug mode property is set to True only when debug mode is active I just copy and paste it here since that code is the same for all our objects update method in there I want enemies to move to the left in the minus Direction on horizontal xaxis by speed x a value we defined online 179 so we are moving enemies to the left if the right edge of the Sprite sheet is hidden behind the left edge of canvas we can set its X position back to game width so that it can walk left across the screen again we will also randomize its vertical y position to get the enemies walking in different Lanes so I will have enemies that walk from right to left and then they reset and walk again alternatively I could have also created new anime objects over and over and Destroy them discard them when they move off screen the code would be simple but reusing objects by resetting their position rather than creating new ones and discarding them later is a good optimization technique always reuse your objects and reset their positions if you can rather than creating new ones using the new keyword to create a new object is more expensive than resetting existing object on the main game class I create a custom method I call for example at enemy up here we will have an array that will hold all currently active anime objects whenever add enemy runs it will push new anime object into enemies array upon line 174 I can see that anime class Constructor expects game as an argument so I pass it this keyword because here we are inside this game class doing this I'm just passing a reference that points to a space in memory where game object is stored I'm not creating a copy of game object each time I create a new enemy init method will run just once to initialize our game and set everything up inside we are already creating obstacles we will also create enemies in here for Loop that will run let's say three times and each time it runs it will call add enemy method we just defined icons to lock this dot enemies and as expected it contains three anime objects I inspect one of them just to make sure nothing is undefined which could be a problem all is good here I can delete the console log it's a good idea to always check your objects and arrays with console logs as you build your project step by step to catch potential bugs and typos in time to draw and update enemies I just have to expand enemies array into game objects using the spread operator we did that before I see only Collision hitboxes I need to give some values to Sprite X and Sprite y so that the JavaScript knows where to draw the images position of the Sprite will be moving as Collision circles move so I put that code inside update method let's first center it then we offset it Sprite X is Collision x minus half of sprite width like this Sprite Y is Collision y minus half height I want the Collision circles to match the shadow on the ground below our floating enemies as closely as possible we need to adjust image positions vertically minus 40. minus 60 what about minus height Plus 40. I can enable and disable debug mode to show and hide hitboxes by pressing letter D we have enemies coming from right to left and then reset in I want them to reset all the way behind the right Edge so we don't see them just pop into existence so we reset them to game.width plus width of anime and on top of that another game with times 0.5 to give each one A different random delay why is this here I delete that just for testing let's increase the speed resetting them at a random offset behind the right Edge works well maybe that's a bit too fast I need to restrict their vertical positions let's say start from the top margin and from there a random range between 0 and game height minus top margin I copy this value to be used as the initial Collision X position inside the Constructor and I take this new Collision Y and I use it inside reset check in update method this will not work because up here on line 176 I'm using this dot width but it's not defined until later here on Line 183 the order here matters I just take these two lines and I put them here now we have enemies walking from right to left in a correct Corridor and reset in behind the right Edge this way we can reuse the same enemies over and over unless I decide we want to add some other features like allowing player to destroy enemies or something like that we will see again you don't have to do this part I'm just testing our code so I create 30 enemies having so many enemies gives me a better idea how they reset and I can spot any potential issues faster everything seems to be working well this would be a very dangerous Forest luckily for our hatchling creatures the final game will not have swarms of enemies like this unless you want to create a periodic wave of enemies like this as one of the gamer mechanics the player has to prepare for and avoid we can do so many things in terms of game design here I'm just giving you the tools and techniques and showing you some of my ideas feel free to expand this game with your creative ideas when the course is finished let's go back to three enemies right now the enemies are just flying through the forest without interacting with anything first I want them to react to solid obstacles and the player we already have code that does that inside update method on egg class I can literally use the same code block and put it inside update method on anime class this will make enemies treat obstacles and player as solid impossible objects and they will slide around them we are inside update method on enemy class and we are passing anime as object a and player and obstacles as object B and here we are saying adjust position of a based on position of B player and obstacles will be solid and dominant in this interaction and enemies will be pushed around them this simple Collision checkin will also create a very basic artificial intelligence as you can see enemies are walking from right to left across the game area and they are automatically slide in and avoiding obstacles and the player because they avoid the player in this way we can also use the player to push enemies around same as we can push the ax around I adjust enemy speed if I add X into Collision objects array on anime class X will also become solid impossible obstacles for the enemies and enemies will have to walk around them it might be a good thing depending how you're designing your game but the way I want my game to be I actually want to remove the X from here instead I go up to egg class and inside update method I will add enemies to Collision objects here this will make the X object a passed to check collisions method and enemies will be solid impossible object B enemies will push the X around if I do it this way we implemented a lot of features so I will leave the source code from this stage in the resources section below you can download it and compare it with your files if you are coding along hope you're having fun I go down here between egg and enemy classes and I create a new class I call for example larva I want eggs to have a hidden timer and after a certain time interval each egg will hatch into a smaller larva that larva will try to hide in the forest and our job as a player is to protect it by pushing it closer to the safety zone or by pushing enemies away from it Constructor on larva class will be a little bit different because I want each larva to appear at the same position as the egg it hatched from so we will pass it a reference to the main game object as usual but also we pass it X and Y coordinates now I convert all these arguments into class properties I need to name these X and Y coordinates Collision X and collision y these variables will be involved in Collision detection so we need to name them the same as we did other objects in our physics game so that we can use our reusable check Collision method on these as well and involve these larva hatchlings in the game physics Loop we will also need Collision radius here let's say 30 pixels for now you can download larva image in the video description I added here with an ID of larva and Source larva.png it's a Sprite sheet with two frames on this row we have a bold larva and this one has some fluff behind the neck just to give it some visual variety the fluff makes more sense if you know what these hatchlings turn into when they are adults I bring the larva image into the project using get element by ID like this width and height of a single frame now Sprite width is 150 pixels Sprite height is 150 pixels as well if you are a beginner I strongly suggest you follow my code exactly and use the same images I'm using when the project is complete it will be easier to make your own custom changes changing the code as you go while following this tutorial is not a good idea unless you are an experienced JavaScript developer making your own changes before the project is complete will make it harder to debug we will also need Sprite X and Sprite Y coordinates of the Sprite sheet image each larvae will need to draw and update methods as usual draw method will take context as an argument inside we call builtin draw image and we pass it image we want to draw and and why coordinates where to draw it I want each larva to be moving up towards the safety of the mushroom Forest this open area is full of enemies and it's very dangerous speed y vertical speed will be a random value between 1 and 2 for example we defined Sprite X and Sprite y properties that determine where the Sprite sheet will be drawn but because they will have to move every time larva moves I need to be updating them over and over from inside update method Sprite X will be Collision x minus half the width Sprite y will be Collision y minus half the height I hide this image with CSS we give it an ID of larva so we have a class we can use as a blueprint to create a larva every time an egg hatches let's write egg hatching logic we will need two helper variables hatch timer will go from zero to hatch interval it will count milliseconds so let's say I want the egg to hatch after 5 000 milliseconds after 5 Seconds Insight update method we handle collisions in this area and down here we will handle hatching if hatch timer we just defined is more than hatch interval we do something else we keep increasing hatch timer by Delta time counting and accumulating milliseconds Delta time will be passed to update method up here on line 159. this update method will receive it here inside render we calculated Delta time value before inside animation Loop Delta time contains the number of milliseconds that happened between this animation frame and the previous animation frame so hatch timer is accumulating this Delta time milliseconds between frames if hatch timer is more than hatch interval we will delete the egg and we will replace it with a larva hmm up here I create a property called marked for deletion down here we set marked for deletion to true I can be checking and removing the smart for deletion objects for every animation frame but it might be a little bit more efficient to only restructure our arrays when something gets actually marked so here we will call a custom method I will call for example remove game objects down here on the main game class I will Define that method so far we are only marking X for deletion so whenever this method runs I will take the entire X array and I will call builtin array filter method on it array filter method will just create a copy of this array but that new filtered array will only contain elements that pass the check provided in the Callback function the check in this case will be I only want X array to contain elements that have marked for deletion property set to false if anything has marked for deletion set to true it will be filtered out of the X array this is socalled es6 fat Arrow function syntax I'm saying take elements in X array one by one assign each one a temporary variable name object and on each of these egg objects check if they are marked for deletion property is false exclamation mark means false if marked for deletion on this egg is true that egg will be filtered out of this new array and this new filtered array is assigned to the original X array and it overrides it hmm am I over explaining again let's consolock this.game.x to see if x are being removed and added yes this is working perfect when we are in debug mode I want the hatch timer to be visible as a number floating above each egg inside the draw method here I call builtin fill text method this method needs at least three arguments text we want to draw and X and Y coordinates where to draw it I need to change font size rather than changing font size every time draw method runs on each egg I will set it up here on line 10 on the first page load this is a powerful optimization technique font is a part of kind of a state and frequent changes to Canvas State can affect performance define canvas properties such as fill style line width stroke style and font in a code block that runs as little as possible ideally don't do this in a method that runs 60 times per second on multiple objects at the same time although in some cases it might be unavoidable all I'm saying here if you can set canvas properties on the first page load like this all this code will run only once I set canvas font to 40 pixels helvetica I could have also defined canvas font here in this draw method but as I said that line of code would run 60 times per second on each active egg that's a lot of operations that can be easily avoided by doing what I just said hatch timer is this ridiculous number with so many digits after the decimal point let's clean this up I create a helper variable called display timer in here we will format that number a bit before we draw it I can for example take hatch timer and call builtin to fixed method JavaScript to fixed method converts a number to a string and it rounds the string to a specified number of decimals I actually want 0 decimals I just want to see the milliseconds I used a display timer variable here to actually draw it I can adjust vertical position of the text Maybe by Collision radius like this up here I will set text align to Center this will align the timers and X horizontally nice I want to push the timers even further up above the eggs maybe even more let's go with 2.5 instead of milliseconds I just want to see the seconds so I close hatch timer in Brackets and multiply it times 0.001 now this is more readable we can see number of seconds above each egg let's make each egg hatch after three seconds nice when the egg hatches it gets removed by the filter method on the main game class I create a property called hatchlings and at first I set it to an empty array whenever an egg hatches we will push new larva into this array up here on line 190 I can see that larva expects game and X and Y coordinates so when an egg hatches I take this to the game.hatchlings array and I push new larva inside I pass it this Dot Game and I pass it X and Y coordinates of this egg that it hatched from I removed this console log inside render method I use spread operator to expand hatch links into game objects array so that they can be sorted drawn and updated perfect we are making progress now that we can see what our hatchlings look like we can go up to larva class and clean this up first we will check if the larva moved to safety they are safe as soon as they reach this mushroom and bushes area where they can hide so if Collision Y is less than this dot game.top margin if larva moved past this point we can set marked for deletion on it to true we will delete that larva because we don't want to draw it anymore and we will call remove game objects online 350 inside remove game objects method I do the same thing we did for x filter the hatchlings array and if any larva object in this array has marked for deletion properties set the true filter it out just to check I will console log game objects every time we remove a neck or a larva I get an error and it's because this needs to be this.game.removegame objects because that method sits on our main game class I want to draw Collision circles on hatchlings I copy this code block from enemy class and I just paste it here because our classes have the same name and conventions on their properties it's easy to reuse code like this right now we are drawing the entire Sprite sheet for each larva I want to crop out just a single frame from coding at 0 0 2 this.spruit and this dot Sprite height and we want to draw that cropped out image at position Sprite X Sprite Y and we need to give it width and height like this nine arguments I want to position a larva Sprite sheet image in relation to its Collision Circle I try minus 50. yes that will work I want the Collision Circle to align with the bottom of its body I think that will make the most visual sense when interacting with game environments and characters I remove this console log on line 362. larva Sprite sheet has two frames but we are drawing just the top one let's randomize that frame y will be a random value between 0 and 2 and since there is no row 1.5 for example we need integers whole numbers without decimal points so I wrap this in mastered floor this line of code will give us either 0 or 1 because my other floor will round the value down to the nearest lower integer frame X will be always zero until later in the class where I give you Advanced Sprite sheet for animation we will use frame x times Sprite width here as Source X argument passed to draw image method and we also need to Define source y Source X and Source Y coordinates combined will determine which area of the Sprite sheet we are cropping from Source y will be frame y times Sprite height nice since frame Y is randomized to be either 0 or 1 some hatch links use Sprite image from row 0 and some use the other one from row 1. collision between hatch links and game objects will be handled here I go up here inside update method on egg class and I copy this code block we will make some changes to it but most of it will be the same so we might as well copy it so we don't have to write all of that again I paste it down here inside update method on larva class I will remove enemies from Collision objects because enemies will have a different type of interaction so larva will automatically avoid player and obstacles and we can also use the player to push larva around like this which will be an important game mechanic collision with enemies will be handled down here I take enemies array and I call for each on it for each anime object I will call them anime for example for each one of them call this callback function basically I want to say if this larva and this anime we are currently cycling over with this for each method collide one way to easily check if two game objects Collide is to use our custom check Collision method again I want to check collision between this larva we are inside larva class and each individual enemy as this for each method runs we know that our custom check Collision method returns an array of values it gives us Collision distance sum of radii DX and Dy here I only want the first argument Collision which will be true or false depending on whether or not this larva and this anime Collide check Collision returns an array and I want Collision status true or false I want the first element in the array so index 0 like this so here we are using destructuring to extract all five individual variables from check Collision method here I am directly accessing just the first value with index 0 because I don't need the other ones the reason I don't need these other values when larva and enemy Collide is because there will be no pushing around and no physics The larva will just get eaten so I set marked for deletion on this larva object to true I will also call remove game objects to filter that larva out of the hatchlinks array I will also keep track of how many hatchlings we lost in this custom variable this.game that lost touch links will be increased by one and here where we check if larva moved the safety of the mushroom Forest we increase score by one so if we protect larva by positioning X pushing enemies away or by pushing larva towards the forest if larva successfully hides in the bushes we get one score point if larva gets eaten lost touch links variable will increase by 1. down here on our main game class we created these properties score will be initially set to zero and lost hatchlings also initially set to zero I can use console logs or something like that to check if the code we just wrote works but we need that text displayed to the player anyway so down here we will draw game status text again we will use builtin canvas fill text method which expects the text we want to draw and X and Y coordinates where to draw it I want to draw the word score at coordinates 25 horizontally and 50 vertically problem we have right now is that I want this text to be left aligned and if you remember the text above X the timer is Center aligned I will have to isolate this fill text call by wrapping it between save and restore builtin canvas methods then I can set text align to left and I call Restore save and restore methods work together and we use them when we want to apply specific settings only to a certain draw call on canvas without affecting the rest of our project I save canvas State I set text align to left which will affect only this fill text call where we draw score and then restore method will reset all canvas settings to what they were when save was called in this case it will only revert text the line back from left to Center I hope that makes sense this is a very useful technique especially if you want to scale and rotate your canvas drawings I do that in some other classes for example in my creative code in fractal class if you want to know more about it now score is left aligned and timers above X are Center aligned perfect I adjusted the text to draw I want to say score colon space in quotes plus this dodge core variable to make it Dynamic now as hatchlinks move to safety and height in the forest we can see our score increases in debug mode I also want to be able to see lost touch links so if this.game.deback is true I copy this line of code text will say lost plus this dot lost touch links variable actually we are inside game class here so I need to say just this dot debug yes I change vertical coordinate here and now while in debug mode we are also keeping track of how many hatch links were eaten how many hatchlings collided with enemies sometimes the larva hatches quickly and is eaten too fast or sometimes larva disappears very close to the top Edge while enemy is nearby so it might not be 100 clear if it managed to get to the safety or if it was eaten I would like to add an additional visual effect that will help us to make our game clear and easy to read I want to add two types of particle effects when the larva hides in the bushes it will interrupt a swarm of fireflies that were sitting on the branches and they will fly up in the air when player sees those fireflies they know that larva is safe if larva gets eaten I will try to come up with a different very distinct particle motion so if there are many game objects in the same area we can still tell what's going on by seeing what type of particles are flying from there I will also use this opportunity to talk about subclassing in JavaScript we will have a parent particle class that will contain all properties and methods shared between all particle types this is a socalled parent class also called a superclass Firefly extends this particle class this is a child class also called a subclass we will also have a class I call spark that extends particle class like this we have one parent class and two child classes child classes will automatically inherit properties and methods from the parent class which will save us some called repetition let's write the code and talk about it a bit more as we go along the parent particle class Constructor will expect game X and Y position because fireflies and Sparks will always fly out from the position where the larva disappeared and let's add one more for example color here maybe I want one particle type to be gold and another one blue depending on where in our code base was that particle created I will show you what I mean I convert all these arguments into class properties as usual I'm saying take color that was passed as an argument here and save it as color property on this instance of particle class you know how this works by now radius will be a random value between 5 and 15 but I wrap it in Master Floor to only allow integers so no decimal points if we are creating many particles you will notice a big difference in performance when we are using randomized values like this compared to the setting the initial radius to a fixed value of let's say 10 pixels for all particles randomizing object values when creating many object is very performance expensive you can improve your game's performance by trying to avoid Master random as much as possible if you know you will be creating many copies of that particular object I know we will be creating many particles we only have one player object so there it doesn't really matter it gets created once but over the course of our game we will probably create thousands of particles one way to avoid this would be a technique called object pooling you create a pool of particle objects and only draw them and use them when needed when it comes to Performance that would be much better than constantly creating new ones and deleting them speed X will be a random value between 3 and plus 3. this means some particles will move to the right in the positive direction on the horizontal xaxis some particles will move to the left if their speed X is a negative value for vertical speed it will be a random value between 0.5 and 2.5 pixels per animation frame I want to use a little bit of trigonometry to make the particles rotate float and swirl around so we will need an angle value initially I set it to zero VA velocity of angle will determine how fast is that angle value increasing I will show you exactly how to use this in a minute don't worry the a will be a random value between these two very small numbers we will delete particles that moved off screen initially I set their marked for deletion to false draw method will be on the parent particle class as well so it will be shared for all fireflies and all Sparks I want to make sure that changes to kind of a state we make here remain isolated to this particular particle so I wrap the drawing code between save and restore builtin canvas methods we set fill style to this dot color from line 303 I call begin path to start a new shape builtin Arc method will take horizontal Center Point vertical Center Point radius start angle and end angle I want you to draw a full circle so from 0 to math.pi times two method pi times 2 is a value in radians and it converts to 360 degrees it's a full circle we have to use values in radians here when passing them to Arc method then I call fill to fill the path with color and I will also stroke it because in our game everything has this Vector art style with block outlines I want the particles to match it glass Firefly will contain only update method same for spark later when we call draw method on Firefly class since this class extends particle JavaScript will automatically look for draw method and for Constructor on the parent particle class doing this will save us code repetition I don't have to Define Constructor and draw method twice if it's shared for fireflies and for Sparks we can only Define it once on the parent class and the JavaScript will find it it will be inherited fireflies will have unique motion I'm thinking floating up and swaying left and right which is very easy to implement first we will be increasing angle by VA angle velocity for each animation frame then we will increase Collision X by speed X since speed X can be positive or negative they can start going left or right randomly Collision y will be minus equals speed y because I want them to float up in the negative Direction on the vertical yaxis if a firefly moves all the way up and it's hidden above the top edge of game area so if it's Collision y center point is less than 0 minus its radius we set its marked for deletion to true and we will call remove game objects on the main game class I create a property called particles it will be an array and it will hold all currently active particle objects I expand particles into game objects so that they can be sorted drawn and updated inside remove game objects I add one more line of code to filter out particle objects with marked for deletion properties set to True like this let's try to create some particles I will create them up here on larva class in this code block that runs when larva hides in the forest we get a score point and I want a swarm of fireflies to fly out of the bushes I take this.game.particles array and I push one new Firefly inside I remember that particle class Constructor expects four arguments a reference to the main game object as usual so I just pass it this Dot Game along from larva Constructor initial start in X and Y of this particle will be the last X and Y position of the larva we just deleted and color will be red for example just to test it nice we have red particles with white outlines if I want more than one I just create a for Loop let's say I want three fireflies each time foreign color to Yellow let's see what that looks like nice particles need black stroke I can set it inside the draw method on each particle but in this project I'm not using a stroke on many other things I can just set a stroke to Black globally here on line 9. This will be more performance efficient it will also give black Strokes for Collision circles while we are in debug mode but I don't really think it's a problem it might look even better like this fireflies have a very basic left and right upwards motion we are not using that angle we are increasing endlessly on line 327. easy way to make something cycle back and forth is to pass ever increase in angle value to master sign or method cosine method when your code is like this VA by how much angle increases for each animation frame will determine the speed of swaying and this dot speed X will determine the curve the radius how far left and right the motion goes perfect whenever larva successfully hides in the forest we get a score point and we get confirmation by seeing this Firefly effect I want Sparks to look different so that in case that larva and Anime are obscured behind obstacles or something you can still see that the larva was eaten based on the particle effect that happens there in here I will Define a different update method with different code inside so Firefly and Spark are both child classes of the parent particle class they both inherit code in particle class Constructor and they both share its draw method but each one will have a unique update method where we handle motion I will increase angle by angle velocity VA again but I will slow it down so times 0.5 horizontal Position will be minus equals Mass DOT cosine we pass it this ever increase in angle value to map it along a cosine curve and we Define the radius of that curve using speed X Collision y will be minus equals method sine and I pass it the same angle value and radius of the curve is speed y value we go back up to larva class and here if larva collides with an enemy we delete it and I want to create a swirl of particles I will just copy this code block we used to create three fireflies and I copy it here in this case we want to create three Sparks and color will be blue how do I do this now I need to push the larva in front of anime to see what happens when it gets eaten nice we get blue Sparks and some kind of circular motion just for testing purposes I will create Sparks even when larva hides in safety so that the animation happens automatically more often without me having to chase them around I need to see it so that I can adjust the movement what can we do with this I love particles you can do so many different movement patterns so easily for example let's make them shrink if you try to draw a circle using Arc method that has radius less than zero you will get an error so we have to be very careful here I say if radius is more than 0.1 keep reducing radius by a small value that value needs to be less than 0.1 to make sure we can't get below zero also if you remember we are only removing old particles if they move past the top edge of canvas and these swirling particles never do so I need another condition here if radius is less than 0.2 just to be safe set it's marked for deletion the true and call remove game objects method nice this looks interesting I want them to kind of explode to both sides I haven't mentioned it before because it's not necessary to fully understand trigonometry for this course sine and cosine work together to map a circular path if we give them the same values look what happens if I swap sine and cosine all you have to understand about sine and cosine for animation purposes is that if you pass them ever increase in angle value and when you attach these values to vertical and horizontal positions of your object you will get a circle movement the best way to get some clarity is to play with the values try to break it adjust the code and see what happens don't worry about fully understanding trigonometry today it can be complicated for beginners and it takes a while to master I'm drawing 30 particles here to give me a better idea about the motion that happens and if we get any edge cases appear that needs to be accounted for you don't have to do this I recommend using only three particles each time for performance reasons you can see the Sparks are kind of swirly explosions I like it the motion is very different from fireflies I give them yellow color here and I will go back to using fireflies let's see what that looks like so we know how to extend JavaScript class to avoid code repetition we created a parent particle class and two child classes Firefly that indicates to the player that larva managed to hide in the forest by disturbing a swarm of glowing bugs that float away upwards and when larva is eaten by an enemy it will turn into a swirl of magical Sparks that slowly shrink and disappear I will go back to three fireflies here and down here let's create three Sparks or maybe five because they shrink so fast and often they are obscured by obstacles and other game objects we want to make sure they get noticed when they appear I would also like to allow the player to move the eggs to the forest to get score Point immediately I want X to instantly hatch when we push them high enough into the safe area that egg will automatically turn into larva and into fireflies instantly and we will get a score point I can do that up here on line 179 where we check if Hutch timer is more than hatch interval to turn egg into a larva I want this code block to also run if the egg was pushed to safety zone if vertical position Collision Y is less than this dot game.top margin to test it maybe I should increase Hajj interval otherwise these eggs hatch too fast I see an egg here no here and I push it leave me alone okay now here we go it hatched instantly while hatch timer was only 7 seconds I try again with this egg and yes this works and we are also getting score points for that perfect I prepared many different enemies for you you know how we have a single image file with multiple obstacle types I also prepared many different toad skins for you that will play the role of enemies in our game I had a lot of fun making different variations and imagining what types of special abilities and special moves they could have let's say for performance reasons we want to use just a set of static images for enemies we will also animate this later if that's what you want in the final version of the game everything will be animated all the project images can be downloaded from the resources section below as usual I'm giving you all this premium game art for free this course is designed to give you the maximum value possible feel free to use these art assets for your own projects if you want so I bring this Sprite sheet with four frames 4 enemy types into the project ID is told and source is toads.png I hide it with CSS as usual in script.js inside enemy class Constructor we create two helper variables that will help us navigate around the Sprite sheet and crop out one random frame for each enemy object frame X will navigate around the Sprite sheet horizontally and it will be initially set to zero frame y will navigate vertically and it will also start at zero I will need the longest version of draw image method to Define what image I want to draw Source X Source y Source width and Source height to specify which rectangular area I want to crop out from the source image and destination X destination y destination width and destination height to Define where we put that cropped out piece of image on destination canvas 9 arguments in Total Image to draw cropping area and where to put that cropped image let's start by cropping just the top left frame so we crop from coordinates 0 0 to code coordinates Sprite with Sprite height this Sprite sheet has only one column so frame X will stay at zero I want to crop out one vertical frame at random so Source y of the cropping area will be Sprite height pushing the start of the cropping area here giving us this Frame to actually see it I need to use the new image with an ID of toads so to be clear 0 times Sprite height will give us this Frame 2 times Sprite height will crop out this Frame the value we pass is Source y to draw image method will determine where do we start cropping from vertically instead of this hardcoded value we can use frame y now when I give frame y a different value it gives us different enemy types I want each anime object to be randomly assigned to one of these images when it's created so we have four rows math at random times four and if I wrap it in method floor frame y will be either 0 or 1 or 2 or 3. I will also replace Source x with a dis.frame x times Sprite width this will become relevant a bit later when I give you the next Sprite sheet for now let's leave frame X at zero it would also be nice to randomly reassign the image every time enemy moves off screen and resets so we make use of all available images I just randomized frame y here like this to achieve that to quickly test this I increase enemy speed to a random value between 5 and 8 pixels per animation frame enemies are resetting and images are randomly changing every time they reset perfect let's go back to a lower speed I set max X to 5. since we are using static images for enemies at this stage drawing them is very cheap in terms of performance maybe I could increase the number of enemies to 5 as well this is starting to look really good I want to display a winning and losing message on the main game class I create a property I call for example winning score for testing purposes I set it to 5. we will draw winning and losing message down here if score is more or equal to winning score hmm I will wrap it in save and restore to restrict some drawing settings we will use now only to that win or lose message I want to draw a semitransparent layer to indicate the game is over and also to make the message more contrasting against the background so I set fill style to block zero zero zero and 0.5 opacity then we will draw that black semitransparent rectangle over the entire canvas from coordinate 0 0 to the width and height of the game area let's run this code to test it when we reach score 3 we should get that semitransparent layer yes after that rectangle is drawn I will change fill style to White to make sure the text is contrasting against the dark background I set text align to Center we will have a main message in large letters and a secondary message in smaller font I will just Define them like this as lead variables and the values these messages get will depend on how well we played in any case this message will only display after score is more or equal to winning score but let's say if we played well and we lost only 5 or less hatchlings we will get a winning message if we lost more than 5 we will get a losing message the goal of the game is pushing X hatchlings and enemies around to make sure we protect as many as possible so if we play well message 1 will say hmm let's play with words a bit you can write anything you want as a winning and losing message here so if we win the main message in large letters across the screen will say Bullseye and some exclamation marks the secondary smaller message will say you bullied the bullies if we lose the main message will say bollocks secondary smaller message will say you lost plus we will display Dynamic variable value to show how many hatchlings got eaten plus hatchlings comma don't be a pushover this is a physics game about pushing things around we need to learn to push better I'm using a good old string concatenation to construct this Dynamic message even better would be to use template literals here if you are familiar with modern JavaScript syntax now we actually want to draw these messages the large message one will be for example 130 pixels helvetica fill text method will take the text we want to draw message one and X and Y coordinates will be the middle of canvas horizontally and vertically like this the second message will be smaller 40 pixels helvetica fill text will draw message 2 in the middle of canvas as well one more full text call that will say final score space plus we will display the final score value there plus full stop to end the sentence and another sentence will say press R to butt heads again I want to show you how to implement a very simple restart functionality whenever we press letter r on the keyboard I will also draw it in the middle of canvas vertically and horizontally now I have to space those messages out so they are not drawn on top of each other I adjust the vertical position of message 1 by 20 pixels moving it up in the negative Direction on the vertical Y axis message 2 will be plus 30 pushing it down message 3 will be plus 80. let's see what that looks like yes this spacing is much better we have our winning message when score is more than winning score we set the game over to true on the main game object I Define a game over property and initially I set it to false the simplest thing we could do here is to freeze animation when game over happens I can do it for example down here I say only serve the next animation frame if game over is false when the game over becomes true the game will freeze I said winning score to 1 just for testing and it will display winning or losing message and it will freeze like this I go down to line 519 and I delete this bit I would like the game to keep running but we will make new X stop appearing and I will prevent enemies from resetting so they just flow off screen and stay there so whenever game over happens the objects that are already in the game area will just finish the action they are doing but new objects will no longer appear the game will just finish playing out behind the winning or losing message but new X will no longer appear and enemies will stop coming player will still be interactive and we can still move it around in the empty game world how do we implement this it's simple first of all let's say winning or losing message appears and we still have some eggs hatching on larva class we will make sure that we get score points only if game over is false when game over happens hatchlinks will still appear from the remaining X but whatever happens will no longer affect our score points on the enemy class I only want the enemies to reset if game over is false like this when the game over happens enemies will finish their movement across the game area but they will no longer reset to the right so new enemies will stop coming down here we only want to add new X into the game if game over is false when winning or losing message appears the existing X will still finish hatching but new X will stop appearing Let's test it I have a winning message I have some leftover eggs but these hatchlings no longer increase our score we have some remaining enemies but they just slowly move off screen and don't come back again player remains interactive and we can still move it around perfect I want to test the losing message rather than intentionally pushing hatchlings in front of enemies to get eaten I will just manually set lost touch links to 10 here on line 380. yes we get our losing message this is great I set lost touch links back to zero adding a custom font is easy you can choose any font you want I will go to Google fonts they have thousands of fonts available there I want to use this comic book inspired font called bangers I click here to select the font and I click up here which will generate some code I can use to include this font in my project I copy these three link tags and I paste them up here in the head tag in my index HTML file ideally before my custom style sheet so the font is available from there then I copy the CSS rule I use it here in the case of this project I can just apply that font family to all elements you might want to be more specific and only apply it to the canvas element for example now the font is available in our project so up here on line 10. I said canvas font to 40 pixels bangers this will affect the text that the displays score and timers above hatching eggs we also want to set bangers here and here if we want to use it for game over messages let's quickly win the game yes this looks better doesn't it because we use safe and restore here everything I do in this area will remain restricted to game over messages canvas Shadows are performance expensive and some browsers don't deal with it well but if I limit them to this piece of text we will be okay let's try it we need to Define horizontal distance between shape and the shadow it can be a positive or A negative value depending on if you want the shadow to be to the left or to the right Shadow offset y can also be positive or negative it will determine vertical position of the shadow in relation to its parent shape Shadow color will be black we can also Define Shadow blur if we want that one is optional so I will leave it on default 0 which means no blur keep in mind that canvas shadows will only be drawn if Shadow color is set to a nontransparent value and if at least one of the properties Shadow blur Shadow offset X or Shadow offset Y is set to a nonzero value Shadows give the text a nice highlight and make it stand out from the background a bit more I set lost touch links to 10 again just to see the losing message what it looks like with new font and shadows nice this looks great I set close touch links back to zero we have this message here that says press R to butt heads again which means press R to restart the game what I'm about to show you is the simplest way you can Implement restart game functionality on the player class I create a custom method I call for example restart inside I want to set player properties to what they are when a new game starts let's have a quick look what we have here I want the player to move to the initial position we will reset Collision X and collision y we will also make sure that Sprite image moves along with the Collision Circle so I will need these two lines of code so play restart method will move player Collision area and player Sprite sheet back to its starting position we go down here to the main game class and here inside key down event listener I say if key that was pressed is R call restart method on game class like this I defined that method down here and in here we will set all properties to their initial State this will be different from Project to project we just wrote this code base so we are familiar with it and we understand what needs to be changed to restart the game back to its initial State first we will call restart method we just defined on the player class Let's test it I move the player and when I press letter r on the keyboard player will move back to its starting position so far so good we could use a similar technique to give the player an ability to rewind time for example where we just set State and position on X enemies and Hutch links to what it was let's say five seconds ago that might give us some interesting gameplay anyway we wanted to restart the game so up here in the Constructor I check what needs to change I know I will have to reset the contents of my arrays I take obstacles X enemies hatchlings and particles and I set all these back to empty arrays like this I test it okay so when I press R now this happens I need to run init method again to recreate enemies and obstacles since we deleted them yes now when I restart obstacles get regenerated at random positions and we also generate new enemies I can see I also need to reset the current Mouse position I take this.mouse and I set it to these starting values actually so I can just copy this I also resetted this score back to zero and also lost touch links I also need to set game over to false to make sure X keep appearing and enemies keep resetting Let's test it I play I win the game I press R to reset I play I win I reset I play I win seems to be working alright I set winning score to 30. okay I spent some time testing the gameplay and there are a couple more things we can adjust as you know we can enable and disable debug mode by pressing letter d I'm here on our custom larva class I would like our larva Hutch links to interact with X inside update method on larva class I use spread operator to expand X into collisions objects array doing this will make the eggs solid impossible obstacles and hatchlings will have to crawl around them this will make the game a bit more difficult and player will have to get more involved to get the X out of the way to make sure the hatchlings reach safe area as fast as possible sometimes hatchlings can even get stuck between multiple eggs and obstacles and if we don't free them in time they will get eaten by enemies alternatively I can remove X from here I go up to the egg class and inside update method on egg class I will expand hatch links into Collision objects array this on the other hand will make a game easier because not only will the hatchlings be able to push the X out of the way they will also sometimes push the eggs in front of them closer to the safety zone you can choose what you want to do here yourself depending on if you want your game to be easy or more challenging at this point you know this code base well enough so if you want you can take some freedom and adjust the gameplay however you want I also want the Collision circles on hatchlings to better match the Sprite sheet 40 here will work well I think to better align the bottom of collision circles with the bottom of bodies of the hatchlings I want these Collision areas to match the artwork as closely as possible we are in debug mode now but keep in mind that the game is meant to be played with Collision circles hidden when debug mode is Switched Off you can use the same technique to better align Collision circles on enemies with the little shadow on the ground below each enemy I will do that in a minute because the next lesson we will focus on adding new enemy types I will also give you all the character sprite sheets and we will add a lot of animations to this project I had so much fun designing these creatures and making them move I hope you like it I noticed one small Edge case bug when we get game over message and leftover enemies eat some leftover hatchlings lost touch links variables still increases we need to make sure that lost touch links value stays the same after game over message is displayed so I will only run this code block if game over is false this will also make the hatchlings invulnerable under the game over screen if you don't want that you can apply this if statement only to one line of code that increases those hatch links if game over is false lost touch links plus plus in the extended version we will add more features we will animate the player hatchlings and enemies I will give you static and animated Sprite sheets for all these characters you will also get the full source code but not only the final source code but multiple stages as we progress with the project from the base game to the complete fully animated version if you followed along and watch this far you should be really proud of yourself you can let me know by saying I did it in the comment section below I'm looking forward to see what projects you come up with when you combine your knowledge and your creativity I hope you got maximum value today time is the most valuable resource we have thank you for spending your time with me I'll see you soon