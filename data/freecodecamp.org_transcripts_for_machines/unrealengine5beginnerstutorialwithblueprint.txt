In this game dev course varnas games will teach you how to build games with Unreal Engine five, you will also learn how to use the blueprint visual scripting system that makes it simpler to create gameplay elements. Hey, guys, thank you so much for checking this course out. This is going to be a very, very beginner level, Unreal Engine five blueprints only course, we're going to make a simple game called the battery man. So if I play this game, what's going to happen is I have a few batteries present all around the scene, I have to collect these batteries over here. And once that's done, I either go to the new level, or I win the game. So here, this is my second level. And if I collect these batteries, I have my event condition. And I always have a loose condition too. So if I wait it out, if I don't collect any of these batteries over here, and wait for five seconds, I lose the game, I can quit if I want. And if I can retry, we obviously still we have made many too. So we're going over everything in this game, including UI validate taking a look at when conditions and emissions. We're coding everything from scratch, we're using the Third Person template, but we're not using any of their built in movement, we're going to create our own character add our own functionality to these to this character. So it's going to be a game that you have. Hey, guys, and welcome back. Now we will take a look at Unreal Engine five and try to create our own project. So what you have to do is open up your Epic Games launcher. And Epic Games launcher is essentially a poster to Unreal Engine and its marketplace. So if I'm if I let's take a look at the marketplace over here. So the marketplace essentially has all these different high quality assets that I can use. And one thing I love about the marketplace is that has something called the free for the month five, where it chooses five paid assets from the asset store from the marketplace. And it provides the users of Unreal Engine these assets for absolutely free. So that is an amazing feature. And that's why I love the Unreal Engine marketplace. It has a lot of different high quality assets, and even Epic Games, most of it, most of the content Epic Games provides is completely free and you can use it in your game. So try check out the marketplace and use this in your game. It's not cheating, it's actually an amazing thing that you do know how to use other people's assets on your game, because that's how game development actually works. Let's try and see how to install Unreal Engine five. Now, if I open up the games launcher and open this up five part over here, it has my early it says Unreal Engine five early access. Now Unreal Engine five is not complete, which is why it still says it's an early access. But I can download my early access from here. And I can also get the sample project that that they showed in the Unreal Engine five showcase video, which is amazing. But once you're once you're done installing Unreal Engine file, if you go to your library, you will see your Unreal Engine five editor over here and I can open it up. And over here. If you scroll all the way down, if you go to Wall, you have all of the assets that you bought or claim I have all of these assets, all of these are free assets and they're amazing. So try to check the assets out maybe you might like something and make them outfit. Anyways, I can go here and hit launch. And if it takes a while Don't worry, I have my Android version five installed on my HDD just because of how big it is. Usually I have the engine on my HDD and then on my SSD is where I have all of my project saved. So you can do that you can have the same approach or you can do something different it's completely up to you. But that's usually what I do. It takes a it takes a long time to open up Unreal Engine for me, essentially because of because I mean one I'm recording and two because of the fact that for Unreal Engine you need pretty decent specs I have like average specs for example you can see I have a six core CPU and memory when it comes to memory. If you're trying to make a game using Unreal Engine make sure you have at least 16 GB RAM. Don't try to create a game with eight GB it is not going to work out well for you especially if it's going to be a high scale game. And make sure you have a good graphics card. I have two GB RAM so I can barely get through this. But if you if you're trying to if you're purchasing a new laptop or a new computer just for game development, make sure you have a good CPU which is six cores at least or more than six cores. It uses a lot of CPU power. So if I go to processes over here you can see Unreal Engine is hogging up my CPU like crazy. And if I go to my performance again, memory, make sure you have like at least 16 GB RAM, especially on the engine five, you will not be able to get when I swear to God. But anyways, let's go to games. And but we have a lot of these templates over here. So if you want to create a really quick prototype, the best part about Unreal Engine is that you can create prototypes really easily. So if I want to create a first person prototype, I can, instead of creating the movement, the projectile movement, everything from scratch, I can just I can just use the template over here, and it will create it automatically for me. So I have my shooting part, my keyboard, my, my joystick all of them built in, so I don't have to create it from scratch. Now this this is very, very useful when it comes to game jams, necessarily you game jams or competitions, where you are given like a day or two days to create a game. And for those, it's very, very useful. So you can see I have a lot of these different projects, I'm going to be using third person, except we're going to create the animations, the game, whether the movement logic, everything from scratch. So that's what I'm going to use the third person and the reason why I'm using third person. Third Person project and not a blank project is because I have a lot of Unreal Engine provides a lot of animations. And I need these animations in my game, I don't want to make my animations from scratch, which is fine, I'm going to use the third person project. Now under quality patient, I'm going to use change mine to scalable, I'm going to enable static content static content essentially like a bunch of assets Unreal Engine gives for free like textures, materials, particles, etc. Under project name, make sure there's no blueprint, not C++, there is not a C++ close, there is not a C++ course, the next the next course that I'll be releasing, that's going to be a C++ course of the same game. Anyway, so I'm going to name this Batman and create project, this might take a while, especially if it's your first time, this might take a while for me not much. But when it's compiling shaders, that's when it takes a very long time. So if you have, if you have a project that has a lot of different gameplay logic and assets built into it, then it is going to take a very, very long time, especially because it has to compile the shaders. Okay, now now that it's open up, you can see that we have this scene and all everyone opens up the third person scene. This is the default scene over here, I have the the floors, there's a lot of cubes, the character, blah, blah, blah. Let's start to go over all of these one by one. Now I have to place actors tab where I have different confidence or actors that I can add on to my scene, what is an actor, an actor is an object that can be placed on the world. This is an empty act. And I can then add logic to this act over here. Now how this works is that everything that can be placed onto the scene is an actor. So the box trigger is essentially an actor. Look at it this way. A Tesla Model S for example, is a car. It is an electric car, but still a car It derives from a car. That's how this works over here. The Empty Actor is universal everything that can be placed over here as an actor. So this is an actor, this is an actor, but we have different types of actors. So from an actor, something called upon is created upon as an actor that can be processed, processed, meaning it can you can add input actor to this to this point over here, for example, you can move the point like a vehicle etc. Or character is basically attack upon that move around. So this is how the hierarchy works. You have an active force, under this actor, we have a point so the point inherits from an actor, and the character inherits from a point and basically has like mesh collision, etc. Let's talk about collision Shelby, select this third person character and in the World Outliner, you can see that this third person character has been selected. And under world settings, I have my game mode override. We'll take a look at all of this later. But let's go to a Details panel. Underneath this panel, I have my capsule component, which is basically collision. The way collision works in games is that you have a capsule you don't have all these complex collisions, like you know the exact shape of the character that is not going to happen. It's very, very resource hungry. We use simple collisions in our games. And what permissions do is it makes sure it doesn't walk through the stairs over here unless you want to create a ghost. I can move up the stairs I can Jump um solid the collision basically says okay this object is solid, but that does not make collision cannot be you know collision cannot be cannot walk through the wall it definitely can you have different presets. For example, I can save my I can set my collision in such a way that I can move through stairs, but I cannot move through a floor, I can do that, I can definitely do that, all you have to do is select the capsule component. And once you select the capsule component, and in this part over here we have different other we have different attributes essentially like the transform the shape, the navigation, all of that. Now, the transform is universal for every single game engine, we have the location, the rotation and the scale. The red is for the x axis, y is for them in the green is for Y axis and the blue for the Zed axis. You can also see these arrows over here. If I change this red arrow, if I hold this red arrow and like my mouse, you can see that my x axis is getting changed the same for my Y and my said, I can also move two axes at the same time. For example, my Zed oops, okay, that's pretty good. I can move my Zed and my bi axes at the same time. Really, okay, I know what I'm going to move my x and my y, just because it's simple, you can see that my values, the corresponding values also change. So I'm that then when you're trying to place objects, that is you'll sort of have to understand how to change all of these values. Now I can also change the rotation, if I press E, I can change my rotation. So you can see I can go up and down, I can change, for example. Okay, let's let's actually go back. If I, if I change the green part over here, you can see them changing by rotation with respect to my y axis, same goes to the blue and the red does not waste time. And the scale is obviously the size of the character, I'm going to change this back to zero, I don't want a humongous character. Okay, now mine is supposed to be one non zero, if it's zero, it's going to be it's not going to have the x dimension at all, it's going to be a two that it's going to be a two dimensional object, capsule component if I have something called mobility, and this is present for every single object. So for example, if I select my network, the Mac, the star, play Star, essentially, it defines where my player should start, this is for the SS network player starts. So that's for multiplayer. So this capsule, probably under capsule company, if I have if I have something on mobility, it I can basically say if my character should be static, mobile or stationary. If I'm if my character person gets some input and has to move in one of these accesses, or even rotate, I need to make sure that is movable. Over here, I have my animations, we'll be going over all of this later on be recreating this from scratch, I have my mesh, I can select if I want to simulate physics or not. And that gives realistic physics, I can enable gravity or disable gravity. Actually, you know what, try to change all these values and try to see what it does. That's the best way to learn to just explore the explore and try to change all these values. Hopefully you don't break the engine. I have my capsule competence. So I basically have different competence attached to my character. And these confidence have different attributes like my for example, my hair has different attributes by my legs have different attributes, but as a whole person. So that is basically how this works. It as a whole is a third person character and has different components attached to it, a hammer camera, etc. Now, you can see that it says it's inherited over here, it means my if I hover over this, it says my parent classes character, What in hell would I mean by inheriting means this actually a programming concept. And what this means is that the parent class has a set of attributes that I inherit on my child, this is this third person character, this is not this, this inherits from the character class. So you can see the pen class it says the character class and the character class has the capsule component, the mesh, etc. So I don't have to if I create a child of this third person, character, I mean the child of this character class and have all of the all of this melted. Think of this as you think of your parents. If you're if your parents have, let's say, brown eyes, the chances of you having blue eyes is pretty pretty low. So you kind of inherit the genes from your parents, and it's getting passed on to the child. That's how programming works too. And that's why it's so beautiful. Now when it comes to content browser, I have my blueprints and with the content boxes used to navigate through your game files And that's pretty much what it's used for. And I have different folders. This has been created by Unreal Engine automatically because of what template I've chosen. So if I go to blueprints, I have a third person character. Before that, let's first familiarize ourselves with the place actors Part Two, if I go to, I have different tabs over here under place actors, I have my directional light, my point light over here, sport light, all of that just like real life, I can, I can drag drag this value into the scene, and it has automatically selected whatever object I've added, I can change all of these values, for example, I can change the light color to like, an a blue, red, etc, I can change my intensity, I can either make an absolutely bright or very, very dark. So the C D stands for CAD, CAD, do whatever, okay, I don't know, I started physics. But anyways, that's what intensity is for my attenuation radius, that's all of these are physics light concepts. So if you really liked physics, you'd probably be able to recognize all of these different variables over here. Unfortunately, if you want to get really good game development, a little bit of physics, a little bit of math, it is important, because, you know, programming is essentially just math, and physics, but in a very, very practical bill. So did you don't need to know math, physics and all of that. But it does help a lot. You can understand the concepts a lot better, especially when you have to debug something or add a completely new feature. Anyways, let's not waste any more time. And that's create a new level so that we can add our own characters, I mean, our own objects to the scene. The fact if I click on my file, I can go to new level, I'm going to create a default level over here, and it'll automatically ask me to save this model over here. Now, if I press Ctrl S, I can save this on my folder, I'm going to create like click over here create a new folder called scenes. And I'm going to call this level one. Actually, this should be called levels, I used to do this in Unity a lot. It's supposed to be levels in Unity two, three policies. There we go. Okay, I'm going to remove the floor and the Player Start that they actually Yeah, put it over the place, we will add all of this. I have, obviously I have something called atmospheric fog, which variable has a lot of influence on light. But I can also add something called the exponential height fog with, which adds a lot of depth to the map. Actually try to try to explore over here try to add different objects onto your scene, as I said, but we'll be creating something called a landscape over here. So I have something called landscape tab. If I click on this, you have something, okay. All of these clients that you see over here, this is usually called gizmos in game development. This applies for all all game engines, these lines, the basic call gizmos, and they're basically outlines of whatever object you have selected. The reason why I'm painting the landscape and just not adding a cube over here and scaling it is because it is very, very well optimized landscapes are optimized for huge, huge levels. And I'll actually show you why. Over here, if I go to my landscape tab, I can change a lot of different values. But all I'm going to worry about as my section size, I'm going to make the seven to seven chords. So you can see it's seven over here and seven over here, I guess 1234 Yep, there we go. And I am going to create this. Now the reason why I say this is very well optimized is first off, I can change the depth of this landscape and you will see in just a second. Oh, I forgot to add the material, but no probably we can add that later on. It might take a while if especially if it's the first time for to set everything up. But once you've had created this, this wait for a bit okay, you can now see this huge white cursor over here. Let's change the brush size to something small. You can see that I've selected it has automatically selected the sculpt part and I can basically add some depth to this map. For example, I can create mountains over here and if I want to flatten it, I can select the flattened part and then completely flat smoothen this out and flatten this to do the reverse of Actually no. Now this automatically selects the sculpt part here. I can basically create mountains etc. Smoother where it is pretty surface mount is more than sit out. And you can see that the shadows start disappearing. And it's kind of the opposite of sculpt mode. Flatten makes the land as flat as possible. So if I want to, like, add a river over here, I don't know if you guys are aware, but Unreal Engine has this amazing water system. So if I want to add a component, not a river, that doesn't make sense, if I want to add a point over here, I can easily do that. But the reason why I'm using landscape is because let me show you something. Let's actually go all the way. Let's cut this part over here. And let me change the tool strength to like point four. So it's faster, you can see that it does not render the graphics over here, because it does not have to like, I mean, why would I want to render all of my graphics is the depth, the complete height of this graphics over here, when the player is not going to see it? Right? It's all about optimization. Now, this is also one of the reasons why you've seen in many games, if you have some collision issues, for example, if I don't have collision over here, and the player just sort of falls through the map, if you keep falling, you can actually notice that you won't be able to see the top of the level. That is because of the optimization part of this landscape or whatever they using. It applies to a lot different game engines. It was very, very common in Grand Theft Auto, San Andreas, and also cyberpunk. But anyways, that's pretty much why I'm using landscape. So here and also because I can use the the sculpt feature here, let me just, I'm going to add some depth, I'm going to make this look like an actual ground so that it's not completely flat, I find that really boring I hate I hate when objects are completely flat. So I'm just sort of going to do that. And let's, so you can see that it's it's editing something called the height map, the height map essentially adds depth tells the map where how high. The level is, for example, this coordinate my, I have like mountain of some sort. And we here I don't. So that's pretty much what it's doing, we're here. Now if I want to go back to my SELECT mode, I can just simply click on my select modal here. And that is pretty much it. So if I select my landscape, I can change a lot of these values, what I'm gonna do is I'm actually going to create this again, because I didn't show you how to add a material. So when you go to your landscape mode, you can see this material part over here, try to select the ground material. And let's create it again. And it's going to be 77. So that's how you add material. And again, I'm going to add some depth over here, just rub sound and make sure you have you click your mouse and just to wrap this around. Okay, that is awesome. Now they've created the landscape. And also another good part about this landscape mode is that it scales the texture automatically for you so that it's not just, you know, one part of the texture, it sort of scales a lot. So I really, really love that about the landscape. So try to add some lights onto your landscape, try to experiment on your own to change the light, the color of the light or the intensity, whatever you want. And that less and less, I think around the exponential height fog. If I go all the way to the top, I could change the fog density to make this really foggy. I want to give this a sort of Martian like, looks, I'm sort of gonna make that red in color. And yeah, that looks really good. Okay, now, let's get into the coding part. But it's not exactly coding. It's called something called blueprinting. And that's the visual scripting language of Unreal Engine and I absolutely love it. If you go to the Blueprints folder, you can see the third person character that says W tech. Now remember, this does not mean you can completely get away with just blueprints. You will need C++ if you're making a full fledged game and releasing it. Why because blueprints are mostly meant for prototyping and small features. If you if you have if you're trying to make a multiplayer game, for example, you can't get away with blueprints because blueprints is not exactly the fastest programming language. It is also a programming language, but it's not fast. C++ is a lot faster, which is why we're going to create the exact same game game in C++ later on. But that is a different course. This is only going to be blueprints as I explained before. This might seem a little confusing for you, but actually these are two different windows And if I go to my viewport over here, I can see my third person character in action. And I can see my collide, I can see all of my confidence altogether, like the camera, the error component, all of that, let's try to take a look at all of these one by one, they've always taken a look at the capsule component, let's take a look at the arrow confident this basically points towards the points to the front of me to the forward vector, or it points forward all the time. They say look at the mesh, the mesh. Okay, so now we have two different types of mesh in Unreal Engine, whereas the static mesh, and one is in skeletal mesh, the Static Mesh is used for stuff like, let's say, a cube, for example, if I drag this cube over here, you can see I have a static mesh. That's mostly because this cube is probably not going to move and it does not have any extra animations. Like, I mean, what am I going to animate out of cute, maybe I can make this fall, it's a champion, I don't need a skeleton, I don't need something called a skeleton for it. But I have something called the Skeletal Mesh. And this is the complex counterpart for the Static Mesh. A Skeletal Mesh is essentially a mesh with something called a skeleton, the how animations are created is you have something called a skeleton and it's assigned to a particular mesh. And you have the skeleton is of a bone and riddlin. It's almost just like the human, the human skeleton over here. Now, what how animations are created is i You take specific bone, and you sort of change the values. For example, if I rotate this bone over here, activate an animation, I mean this for a second slapping someone, but that's pretty much how animations are created. I manipulate the transform values of this of these points over here, like, okay, not the middle finger, maybe the index finger. And yeah, there we go, I can do that. So that's pretty much what animations, how animations are created. Now you can create animations in Unreal Engine, but I'd suggest you to if you want to learn how to make animations, there are a lot of Blender courses online, by Game Dev TV, or anyways, there are a lot of different there's a lot of Blender courses online, please take a look at it. It's amazing. But this is the skeleton that unreal provides us with, I have something for the camera, boom. Now, if I hover over it, this is the spring arm component. And the spring arm component. Essentially, the reason why we're not adding the camera directly is because if I have a wall behind, and if my if my character is moving behind him, if characters moving back like that, okay hadn't moved the capsule, I've actually moved the mesh, if I keep moving back and the camera moves with it, the camera might flip through the wall, I don't want that I want my camera to sort of move up as the wall as I'm getting closer to the wall, which is what Sprayground is used for it makes sure that you the camera doesn't move through the void. Now the follow camera is that the camera itself and if you want to change the position add rather change the values of the target offset over here. So five, Jesus like maybe 30, I mean 300, you can see moves with respect to the y axis. So I do it that way, anytime. So I'm going to if I want this hire, I can change the socket offset, and then press E change the rotation like that. So that's the way to go when it comes to making a camera system. And they have the character movement. This is a built in component created by and created by Epic Games. And this basically has different menus that you can manipulate, for example, the movement values, let's actually try to change these if I search for my walk speed over here, that's actually search for the maximum walk speed. If I change this to like, let's say 350 over here. And if you want your changes to get saved, you have to make sure you hit on the compile button. And if I press Alt P, you can see that I am walking slower than usual. So I can basically manipulate all of these values. And this is again, you can see that is inherited. So this belongs to the character class. And this character class has all of these inherited so I can read any of these. Let's, let's respect the 600. But anyways, it doesn't matter because we're creating our own character. The Event Graph is where you create your logic. So these are all called nodes. And you can basically drag and drop these nodes over here to create your flow of the code. Don't worry, this is very confusing. We'll be creating all of this from scratch. Okay, and yeah, that's pretty much it for the Event Graph. And if I go to my Construction Script This occurs even before the even before the game starts. So if I want to add some functionality to my game engine, I can do that in the Construction Script. In my event graph, I have my variables button. Let's take a look at the graphs, I can get different graphs. For example, I can create a new graph just a moment, if I want to keep this very, very tidy. But we're not going to do that we have a very simple script, so that's fine. And we have something called variables a variable is okay, I'm going to make a variable that a variable is basically something that can contain a value. Variables can be of different types, floats, integers, integer 64, by double, let's take a look at all of these. A boolean holds a true or false value by the snake bit number, integer is a number bigger than the byte integer 6464. bit number float is a decimal number. So that's like 3.14 10.6 6.9. And double is a big 64 bit floating floating point numbers as far as like 6.999. And and then try and keep going on until six bits of memory. A name is a piece of text, or string is basically any single value that's in quotes. For example, it could be my name, or the the word, the word hello, or the sentence Hello world, that could be a string. A text as well, this is a different type of string used for UI, etc. Name is mostly used for scene names, level names, all of that vector, a vector in physics is basically a value that has a magnitude and direction. So I can say, x is moving at 10 to 10 meters square per second in my in the x direction. So that's a vector. And a vector consists of the X, Y and Zed values to theta is for rotation, and it also has the X, Y and Zed values that are transformed. We've already seen it, it's the rotation, the rotation location and the scale. It is universal for every single game engine. So yeah, that is the basics for the blueprints. Now let's go ahead and create our own character. So I'm going to create a new folder first. And I'm going to call this custom blueprints, because I will differentiate between the ones that Epic Games has created and the ones that I've created. And it's very important to be organized. Now. Okay, trust me on this, every single game developer will ask you to be organized and they themselves will not be organized. This happens all the time. But it is best practices, you're just starting to learn. Try, keep your project as organized as possible. Now, over here, I have my desktop icons, hidden but if I showed you your policy, how old next time, make sure you don't make that mistake, try to organize your folders as much as possible. And custom blueprints, I'm going to create a Blueprint Class, and this is going to inherit from my character. So I'm going to have every single functionality that this character provides. For example, I can walk around, I can add input the code, I have the ability to do that. But I need to make sure I tell my character to move that's like you, you have the intelligence to make game. But you need to learn how to make a game that's pretty much what we're doing over here. So have a character, I can select that. And the naming convention is usually DT underscore the name someone call this battery man. And if I open it up, I don't have the mesh anything. So if I go to my third person character and try to compare it all of these inherited parts, I have them on my VPN disco Batchi. Man, I don't have the mesh because the mesh isn't I mean, I don't have the camera and the spring on component because that is not inherited. So let's actually copy this and add them to our character over here. Oh, actually seems like yeah, we can probably them coffee and paste them over here. So I already have my camera added or you can just say Add Camera and add spring on component etc. Okay, I have my camera, Compile and Save and let's assign our mesh. So if I go to my mesh, I can go to my skeletal mesh. I have only two of these. I have the female and the male. I'm going to use the male mannequin. They're going to bring this all the way to the bottom by 80 units. Actually, let's do 90 Actually, no, I think I think it would be fine over here and press E and let's move that by 90 degrees. And again, that's the Zed axis companion save that style. To run the game, you will notice that I still have my third person character. And if you're still confused as to what character I'm using, you can inject from this character. What does that mean? function, just press f8 in your keyboard. And then you can the game is still running, but I can basically debug the scene over here. Now if you select your third person character, you can see that I'm still using metal first character, my player since pawn. And that sparks a question. How does the game engine know without adding any functionality? How does this know that I am adding I want my third person character to spawn? That doesn't even make sense, right? The reason is because I have something called game modes. If you go to Edit Project Settings, let's take a look at the maps and modes part. Over here, I have something called Game Mode, the game would basically set default values for every single scene. So I can say, no matter what scene I create, I always want my third person character to spawn. And in that scene, I can say for example, if it's the main menu, I can have an override game mode, which says, Okay, for the main menu, don't spawn the character, because that's weird. So I'm going to just have my UI, etc, I don't want my character to respond. So that's how Unreal engine works. So over here, on my default game mode, I'm going to change this value to BP underscore Batman. And now if I press Alt P, I can see over here, but obviously, I don't have any functionality. The reason is, because I have the ability to take input, but I haven't done anything with that input yet. So that's what we're going to add over here. If I go to my event graph, let's actually take a look at all of these events over here, which we haven't seen before. I'm going to remove these. Okay, now, the event claim, let's actually see what this does the event play event, it executes whatever code that's attached to it in the beginning of the game, so only one is going to get executed once and that's when you begin playing the game. Even take it gets executed every single second. And let's actually take a look at an example. If I drag this over here is called the exec node. And I can release it to play to place a new node. And I can just save print string over here. The way this works is, when I call begin play when they implement is called automatically and that time is going to print out the string over here. And I'm just going to say this is they can play compile, and let's play the game, Alt P. And you can see that says this, this is being played. Now, I'm going to add Player Start at the play style essentially defines where my player stood bed, my ventilation stopped the game. So now I don't fall off the map. So notice this is big and played. I'm going to now press Alt and click this button over here. And then move on move this to the bottom, and then drag the event take note over here. Now this can be anywhere. But I'm just I just asked you to get it bring it to the bottom because I want this to be neat. So Compile and Save on dpi. And now you can see that printed every single frame. Now remember, this might be different for every single computer. If my game runs at 60 frames per second, this function will be called 60 frames per second. But in a different person's computer, let's say you have an RTX 13 3080. And your game runs at like 160 frames per second 120 frames per second, then this function will be called at 100 120 frames per second. That is how the tick function works. For unity users. This is like the start and the update functions. Very, very similar. So we're not actually not going to use any of these because what we're going to do is we're going to say if I press my W key or my s or my A or my D, do me move the character and if I press let's say my mouse button, print something out, that's what we're going to say over here. So if I minimize this window, go to Edit Project Settings. I have my input part over here. I have two types of bindings over here. One is the action binding action mapping and once the Axis Mapping action mappings are pretty self explanatory, I just have my spacebar over here. I'm actually not going to bother adding bank our game does not have any jumping mechanics over here so we're not going to add any jump but I'll actually show you how to make your player jump. So this basically says if I if I'm basically if I go back to my blueprint, right like and Jump event. You can see under input action events, I have this jump, and this button, my press my button, press my jump button, do something, press. If I release my jumper do something, I was the jump button. The jump button is my spacebar. And for my gamepad, it's my face, pop, pop bottom. But anyways, I'm going to name all of these Unreal Engine, obviously, it seems like it supports a lot of different consoles, which is awesome. And my access mappings, this gets a little confusing, I'm going to remove everything I'm not going to use again, because it gets very confusing for new developers. So I'm going to do more of these. Now, if I press W, I want to return a value of one, which is basically going forward. If I press S, I want to return a value of minus one. And if I press A, I want to return a value of minus one, if I press do moderate on the value plus one, why? Because take a look at the axis. If you go forward, it's usually positive. If I go backward, it's negative. So to my movement input, I'm basically going to say add one, two, as long as I'm pressing my W button, add one to my movement input. And if I press a it's going to add a value of let's say minus one at that particular direction. So why is it Why is a minus one, well take a look at the x axis. If you look at the x axis, the left part is minus one, the right part is supposed to one. So that's basically how the coordinate system works over here. Turn rate, what we're going to do over here is I'm actually going to delete our turn, rate and turn and our lookup rate over here. And what we're going to do is, instead of this, we're going to call this look tight, and then we'll call this look up, look up is your mouse by direction, it returns a value ranging from minus one and four look right, if I move my mouse in my x direction, it returns a value ranging from bots to one, let's actually see what that does. Now, in my input action, if I press this, I want to print I am jumping. So I can just say control me Compile, Save that go back, I can remove this now, and all failed. If I press space, it says I have sheltered and if I release this, if I go to my release part over here, I it's only going to print this out when I release my important. Okay, now, let's try to bind all of Les I ran in said add some functionality. If I right click and then search for mouse X, make sure you get the event the the events and not the mouse values. So I'm going to get mouse X and mouse vi the events. So let's actually see what I mean by when I say it returns a value ranging from minus one. So what I'm what I can do is from this node, I can print a string. And this is a float, the green part is for float, what this is doing is it's giving an output of or returning a value of a float, which is the axis value. And if I drag this end, it's going to convert a float to a string. If I compile and save, go back, Alt P, if I move my mouse, left and right, actually, that was more sex, yes, so that's going to be left and right, you can see my values are ranging from one to minus one. I mean, that starts from one, if I go right, it's going to be positive, it's going to go if I go left, it's going to be negative, it just keeps adding that value over here. And the same goes you can try this out for more spy, I'm not gonna waste everybody's time trying to do the same thing for most pilots will do the same thing. Okay, so let's actually try to add our mouse movement over here. If I go to my spring arm, I have to make sure it always has used pawn control rotation. why? It's because when I change when I what I'm going to do is I'm going to change the control rotation of the phone. And that's how I'm going to change the rotation of the spring arm which changes the rotation of the camera. Why? Because the camera is the child of a spring arm. What that means is that if I move my spring on the camera is going to change with it just like how a kid follows his or her mom all the time. That's basically how the spring in the painting part works over here. Same way the arrow is a child of the capsule component the mesh is the child of capsule, etc. which means as a moment capsule permanent the mesh moves with it. Okay, so we're going to change something called the yaw and pitch, the pitch is the y axis the yaw is the Zed axis. So with this axis value basically add that value to the Y or the Zed axis. Let's see how to do that. That's dragonoid. And we're going to search for it. If it's the x axis, we're going to add the your to it. Why? Because the x axis, if I'm going to rotate with respect to my x axis over here, that means I'll be rotating it, you know, sideways, I don't want that, right. So I'm basically rotated with respect to the set axes, which is basically left and right. So I can plug in this value over here, copy, I mean, I'm not gonna copy that, I'm just going to do the same thing, but for the pitch over here, so add controller pitch input. Now, keep in mind, if I have this disabled, so all 10 like that, if I don't have an exit node connected, it means this, this function will not get executed, what is the function of function is a chunk of code, which may or may not take an input, and it provides an output based on that by processing it. So you have an input, it processes that input, calculates that does something and then provides an output the output here being the camera, getting the camera rotating on the scene. So if I go back, Alt P, you can now see that I have proper camera movement over here. Now, if your axis is inverted, like for example, if I go up, I want to go down. And if I move down, I want to go up, if I want to do that, all I have to do is go to my project settings again, go to my input part, and I can just change my mouse vide positive one. And if I alt v, now, if I move, if I move up, I mean, it just does the opposite, essentially. Okay. Let's open up the blueprints, again, where we we did this for our mouse, but we need to add movement, obviously, to it. So let's do that. Now let's get on events. So our move forward event was basically binded to the keys W and a I mean, W and S. So let's search for the access event over here. And let's do the same for move right, the X event. So I have the x value over here, for move forward, I'm going to add this axis value to something called the forward vector of the character, the forward vector is basically a vector that defines the forward direction. And here we're going to add this to the right vector. The right vector is essentially the the vector that defines the right direction. So if I right click and add movement, or if I search for this, I need the world direction over here. The whole direction is that basically we get actor. Let's actually get the rotation over here. So if I drag this over here, get rotation, okay, get location, get forward vector. So this is going to get this direction is going to be the forward vector, because we're going to, we're either going to move forward or back. And this takes an input asset rotation. Now, this is a variable, the forward vector is a variable. And it's if I mean, there's a function, the forward vector itself is available, this get forward vector is a function. And this does not have an exec mode, which means it's a pure function, it returns a vector, and I can add that to the world direction, the scalar value is going to be the intensity, which basically whether if I press W, it's going to return a positive value, the press S, it's going to return a negative value. And N rot is basically the rotation, I'm going to get actor rotation here. And so basically, what it's doing is basically doing some complex math, and then saying, Okay, I know what the forward vector is. So move, depending on that direction. Now, the same thing over here, and movement and foot, but there's going to be for the right vector. So get right vector. And we're again going to use the actor's rotation over here. So that's that for our movement. And that's pretty much it. We're done with movement. So if at all fee now, I can move left, right, forward, back, etc. And it works perfectly fine. But my character is still in this V pose, or this T pose. The reason this because I don't have any animations assigned. Before that, let's actually see how to make this neat. Now, okay, the length of this node or this length, the length of this line does not matter. It's not it's not going to affect the speed at all. Just just adding that I was dumb enough to believe the speed was affected. Because of it. Don't be like me, it's not. But always make sure it's neat. Make sure you can see which line which axis, I mean, which way was getting connected to what etc. That is very important. So Compile and Save. Now let's start, let's send a document our code over here. If I select all of this, and press C, I can add something called a comment. This does nothing but it's just for us for our understanding. So I'm just going to say add Movement Input over here, and over here on the screen to see add mouse input here. Now, we're not going to have, we're not going to make a character jump, but in case you want to add the functionality, I'll show you how to do that. If I right click and search for the jump event. So remember, we have an action action event called Jump. Very impressed this I want to start, I want to just jump and jump is a built in function of this character class. So the character automatically starts jumping. And over here, I can say Stop jumping, because I don't want to keep going higher and higher and higher. So all three, I have my jumping over here to person. But I'm not going to bother adding this because I don't want this in my game. But yes, that is that for movement. Now that they've added movement, the next part is to add animations. A lot of people don't like animations. I personally don't like adding animations. But unfortunately, it is a part of game development. So let's dive in on how to do that. For animations, I have a different blueprint that I can add. So I'm going to make content part and new folder. I'm going to call this animations. And let's create something called an animation blueprint. Now the reason why we using an anime Animation Blueprint, not the normal blueprint is because the Animation Blueprint is optimized specially for for blueprints and before animations, and it has a lot of different functions built in. Now, to create an animation blueprint, I have to attach this or assign a skeleton to what we've already seen what a skeleton is. So different animations are made for different skeletons. So make sure we select the YUI for manikin, which is the built in skeleton, press OK, the naming convention is AVP. Oops, again, right click Rename a BP underscore, I'm just going to name this battery man over here. Double click. And now I have my output pose, I have two different graphs. So here I have something called the Adam graph, which basically decides the output post and in the event graph, I can, let's say get the speed of the character and then change the animations based on that. That's what these two graphs to the Event Graph is for all the functionality like um, getting the variables adding values to the variables, etc. The enum graph is to decide the output pose. If I drag a node from here, and search for the run animation plate or person run and compile. Now, this over here takes an input if your if your variable is on the left side, it means it's taking an input. If it on the right side, it means the node is giving an output. So the third person is going to get the animation, use the animation pose as an output. And that output is sent as an input to this output. So here, component save, I had to go to Batman and assign my animation blueprint. So I can either select my animation blueprint and then hit this arrow over here. Or I can just search by a BP underscore batch command. Now Compile and Save. If I run this now, you can see that my animation is getting played continuously. I don't want that I want that idle animations, all of that. I want a different animation for strafing, it just looks really weird. So we're going to create something called a blend space for that. Let's take a look at what blend spaces. So good animation. And so it's for blend space. And again, you have to assign the skeleton. So this will be BS underscore battery man. Okay, now, let's open this up. And this might look a little confusing, but essentially, the Blendspace has the x axis and the Y axis. And depending on the values of this, also a certain animation will be played. For example, let's take a look at the vertical and the horizontal the vertical. I think the vertical is this one over here. Yeah, that's the speed. So that's vertical axis, we're going to name this the speed and in the bottom on the horizontal axis the direction. So based on my direction and my speed, I can play a particular animation. So my minimum speed over here is going to be zero, my maximum axis value over here, my maximum three, the 600. As we set in our movement component, a minimum axis value here is going to be 180. by Paul maximum is going to be first a 180. So Y, first 180. And next 181 80 is usually forward, negative 180 is the complete opposite direction. So that's what we're doing over here. Okay, so basically, what I'm saying is, actually, let's do this with an example search under this Asset Browser source for your idle animation, and drag and drop this at the bottom. What I'm saying here is, if my speed is zero, regardless of my direction, make sure you play the idle animation, I'm pretty sure you can now understand what this is doing. So if my speed is zero, then I'm going to play my idle animation. Now you may understand where to put your run animation, it's going to be all the way at the top. Now, if you hold Shift, and actually sort of move around, you can actually you can preview the animation. So if my speed is set, if my direction is at zero, which is forward, and my speed is at 600, then I'm going to play that animation. And it's slowly trances rate slowly adds the value. So my animation slows down as I go down. And my preview value, if my speed is at zero, regardless of my direction, I'm still going to stay idle. So that's what it does. If my direction is at 90, I want I want to make sure I move left. So let's search for that search going on, experts take a look at all families over here. Okay, so they would usually happens is we have different animations for when the character turns left, and when the character on site. But the animation, the animations that come built in, we unfortunately don't have those animations. So what we're going to do is we're just going to add run over here. And remember, when my direction is at, usually, you'll have also a backward run animation. So when the direction is at minus money at MIT, you usually want your the want to move backwards, so you have different animation for that, and you will add that, respectively. So that's just add this animation, I really don't want to do this. But in our C++ course, I'll make sure we get animations for moving right moving left, actually, let's try deleting the all the other values, let's just have one for moving forward. If I save this, and all be okay, obviously, I need to assign this Blendspace in the animation token, because we still haven't assigned it yet. So if I go to my animation blueprint, I can drag a node and search for Blendspace. So now I can see my Blendspace vs underscore Batman. And this takes in two inputs, one is going to be the direction one is going to be the speed and based on that it will choose an animation, which is what we set. So from here, I'm going to drag and load and promote this to a variable. So it automatically creates a variable called direction and it's a float. And I'm going to promote this to a variable and it's going to be speed, compile, go to my event graph. Now in my event graph, I can get the speed and the direction. So let's see how to do that. Now from tie get pawn owner, what this does is it tries to get the owner of this animation blueprint. So I can now cast this to my BP battery man, why am I doing this, but that's actually that's mainly because I have my point upon is the class but I have to convert my class to my battery man. The way this works is if I go to my BP underscore battery man and add a variable, I'm just going to call this test variable. And I want to get hold of this variable. I can't get this from porn, I can just say get test variable, it does not exist. But if I convert this to a Batman, and then as Batman, if I try get test variable, now I can get hold of the very variable. So we're trying to just localize our localized this pawn to my VPN scope actually, man. So from here, we're going to actually first what we're gonna do is we're going to check to see if we got our foreign owner or not, and that is done using the S valid node. So if I Get my point honor, if if I'm not able to get my point or I can just say, I can just print a string saying I porn on are not valid. Now the reason why we're doing this is because of attorney get a few variables from the point honor the to make sure we have that pawn owner, if not your game is and up your game is going to crash to this the safer way of doing it. If it is valid, what we're going to do is we're going to cast to third cast to PP underscore Batman. And this has an exec node. So obviously this goes to as valid. As Batman, what I'm going to do is we're going to get a variable called get velocity. So the velocity is obviously the speed. But remember, velocity has direction, and magnitude. So from get velocity, we're going to get, we're going to calculate that you're going to get the that we're going to get the vector length, the return value is going to be your speed. So we already we already promoted this to a variable. So we're going to set this variable here. So drag this variable onto your event graph and press Alt, and then you can just drag the return value on to speed which means now the value of the speed is going to be the velocity, the vector of velocity from battery man, we'd obviously set the direction to we're not done yet. So from here, we're going to get actor rotation. And from the rotation, we are going to calculate direction. So obvious for the direction you need to calculate what you need calculate the velocity. So from the velocity, you get something called the direction to that's how vectors work. And again, I'm going to the same direction. And I can set the value. After setting speed, I'm going to set the direction. So the control flow is basically update animation. This is basically going to happen every single frame. From here, it's going to go to S valid, it's going to check if the pawn owners valid, if it is cost to pvns, go battery man. So convert porn to Batman, from here, get the velocity Get Actor rotation, calculate the vector length, calculate the direction, set the speed and then set the direction, we can actually then keep this over here. Now we have the values for speed and direction, all you have to do is go to Anam graph, and you can see that it has already set the direction and the speed. So now Compile and Save, go back. And if you press ALT T, I now have my animations. Obviously, it does look a little weird that if I go left and right, I don't have proper animations. But that's actually going to be actually try to do this on your own search for your left and right animations. Go to your go to this namespace. When your direction is at minus Canadian 180, you want to make sure the character goes backwards. And for left and right animations here, you're going to place your right animation here, you're going to press your left animation and check if it works. And if it does, then you understood how blend spaces work. But we're gonna move on the game. As you've seen at the beginning, the way the game works is you have a lot of different batteries all around the map. And the health of the player keeps decreasing. And you have to make sure you collect all of these batteries. And if you do, then you go to the next level or you win the game. So let's see how to do that. This is where we'll be learning about UI, etc. So that's going to be there's going to be the second part of the course. If I go to my blueprints, method person actually not method freschetta. Obviously, it has to be my AVP underscore Batman, I mean, my btn school Batman over here, we're going to create a new variable called Health. Let's remove this. And let's create a health variable. Over here, I'm going to search for now I'm going to make this a float and compile the default value as the default value. And what's going on with me the default value is going to be 100. Compile and Save. Now, what we're going to do is we're going to get our event tech and every five seconds we are going to reduce the health. How do I do that dragon node and then add a delay over here. What this does is it's basically going to wait for X amount, they're going to wait every five seconds and get this value. So if you Jacqueline's funny on the screen and then hit Ctrl, and then place it you will get, you'll be able to get whatever value your health is. And we're going to subtract. So if I just be, as you can see, if I search for minus, I can subtract a value, and I'm going to subtract a value of mine of five maybe. So once I've subtracted the value, so let's say my health is 100. If I subtract it, the output is going to be 95. And I have set over here, again, set whatever value I've returned. And then once I'm done, I can just do that. Now, basically, every five seconds, I'm going to reduce my health, let's print my health out. Actually, for simplicity, I mean, just make sure it's faster, I'm going to make it every two seconds, and drag and drop health, again, converted into a string and plugged into my friend strength file and save it. Now you can see it's 100, after two seconds, 95. And then it's 9085, etc. So it keeps going down. What I'm going to do is, I am going to add some UI, I'm going to add a health bar so that this is connected to that, I'm going to reduce my health every two seconds, but I'm going to reduce my health by 10, Compile and Save. Now, I have to do something called binding, I'm going to bind this house to my UI. So let's take a look at how to create UI. Under blueprints, I'm going to create a new folder and call this UI. And under UI, you can go to FX, I actually not effects. This is not a user interface. And I'm going to create a Widget Blueprint, the naming conventions W BP underscore whatever name I'm going to call this player UI. So in this, we have something called the designer and the designer, this what the UI is going to look like you can design me, you can basically place all of these objects, and you can make it look like a proper UI, we're going to add something called a progress bar over here. Let's actually scale this about let me make this 500. And I'm going to do something called anchoring. What this means is as I resize my screen, so for example, if I minimize my screen, I want my, I want this to still stay at the top left corner. And if I make it fullscreen, it should move along with the screen. That's what anchoring means. So I'm going to make sure that it's over there. And if I scroll all the way down, under style, I have something called the Fill image. If I, if I'm, if I drop this down, I have something called the 10th. The first image is going to be the actual health over here. So I'm going to make sure my I mean my battery, my battery is going to be green, that actually reminds me how to change this to battery not here. Okay, and make sure you save that here and compile. And over here, our background image, let's just make this actually let's make that black, that's fine. And we have to we have something called the percent. Now the person ranges from zero to one, if it's one is going to be completely filled. If it's zero, it's going to be empty. Let's make the default full. And we're going to do something called binding it. So you see this bind button, and you can select Create Binding. And what we're what we're going to do is we're going to get the health and we're going to set that health to this percentage, we're going to convert the health into percentage, and then we're going to set it over here. So the return value is going to be the percentage that's displayed. So now we can say Get Player Character. And that's going to return whatever character I've possessed the good RBC convert this to my Batman. So once we've done that, as Batman, we can just get our health and get battery. And then we can set that over here. But remember, we have to convert this into percentage because this person is going to be between zero and one. So what we're gonna do is we're going to divide this by 100. Remember by by definition percent means per cent cent is 100. So, we're going to divide this by 100. And then Return it over here, Compile and Save. Now, we have to add this UI on to the screen. To do that, let's go to bed, let's have our begin play, all the UI will be instantiated in being in play. Over here, we're going to create a widget. So we're going to create an object of this player UI. So I need to select which class, that's going to be my WP player UI. And return value, I'm going to add this to Viewport. So it's basically to add this player UI on the viewport and whatever function binding, it's going to make sure it executes all of that code. So now if I play, you can see that my percent bar is slowly decreasing, which is amazing. And it has some amazing decal, too. So it has some animated graphics. So that's very cool. As well, um, Unreal Engine, it does everything for you. And we can now remove this frame string. Now, again, we have to make sure it only reduces the value until it costs zero. And once it goes to zero, I want to kill my player. So to do that, first off, we're going to decrease the value only if my battery is more than zero. So if I drag control, we now can search for the greater than symbol. And if it's greater than zero, only then execute this. But how do we do that? How do we add conditions, we do that by something called a branch. So you can see that red color over here. So if it's more than zero, it's going to return true. If it's less than zero, it's going to return false. So from here, I can create something called a branch. And I can now add this to this branch. Now, if my health is more than zero, then I'm going to execute this. So I'm going to move that to the top. If my health is less than zero, then I'm going to say my player is dead. So that time I'm going to add a retry screen etc. And I'm going to make sure I do not possess this character anymore. But we will see that later on. But let's create a variable. Now. Let's say B is player that's a naming convention for bool boolean values, you make sure it's B is clear that or whatever. And we're going to make sure this Boolean compile, and the default value is going to be false. And if I hold Alt and drag this onto the scene, we can set this to be true over here. Awesome. Now, if player is dead, then obviously, I've lost so I'll use a pull out menu screen menu. And I can either retry the game, or I can play the game again. So that is the basic functionality that we're going to use over here. Once the player is said, what we're going to do is we are going to we have this function called detach from controller pending destroy. What this does is it makes sure your controls don't affect the player once you have detached from once you're dead. So if I wait and wait for it's actually let's let's make that faster, have no patience, I'm going to make that 20 so that as soon as I spawn in like four seconds, I end up dying. So that's there. And now you can see that you can try controlling, but you will notice that your controls don't work. And that's because we have detached from this controller. And we need the animation to stop playing. So we can we can also have another so we can we can either stop our animation like this, but this might not work. Let's try that out. Let me make that funny because I don't want to wait four seconds, Compile and Save. All pay. Now the animations are still playing. So we have to take care of this through the Adam montage. I mean the animation blueprint, we have this variable here is player dead. So we're going to get this variable from our BP battery man. And if it's true, they're going to stop animation. So let's see how to do that. We'll be learning about a new thing called the blend by blue. Yeah, the Blendspace by blue. Okay. Over here in this enum enum graph we've seen before that we have something called a branch. So if the condition is true, do this condition is false to that. Instead, what we'll do is we'll say, just search for both answers blends poses by bool. then post this by blue. Okay, anyways, if so we can pass in a bool value over here. And if it's true, it will do this. If it's false, we'll do something else. Now, if a player is not dead, we want this Blendspace. If the player is there, then we can just, maybe I know, we can play the idle animation over here. And how do we get this value? Same way, we have BP battery man, they can also say get the S is player that and we can promote this to a variable. So promote the variable and bring this all the way to the top and compile. Now I think you can understand the rest, we can just drag and drop this over here. And now it's going to make sure if there's dead then just want to play the idle animation and not do anything because we don't have fuel to run. There we go. That works perfectly fine. And after this, we have to make sure we display our player Lua screen. Now try to do this on your own, it might be a little difficult, but just give it a shot. If you can't, no problems we're going to do anyways, we're going to create a new user interface, we're actually going to create two of them. One is for player when one is for player two is. So we WP underscore. Actually, we don't need a blueprint of Widget Blueprint for when because we're automatically just going to go to the next level. Or we're just going to have it is going to go to the next level. And here we can just name this the BV WPP Lu screen and the designer part. I'm going to add an image first, let's scale this completely, so it fits this handle. And make sure we have this properly aligned. Okay anyways, even if it's oversized no problems, we're going to anchor this to be full screen. There we go. So it's going to be it's going to make sure it's always full screen. And I'm going to change the opacity to I'm gonna change the color to black and the F two like that. That looks fine. We're going to have two buttons now. The first button is basically going to be one sec. Give me a second Okay, the first button what it's going to do is when there's when the the retry part, so retry game, and need to add some text to it. The same button, I can do the cater. And they're going to add this over here. I know it's not exactly aligned, but that's fine. This is going to be quit aim want to quit color and opacity seems just fine for me. Yeah, that's that seems just fine. No problems. Okay, now let's see how to add text to this, all you have to do is search for text and drag and drop it, it's going to automatically pair it make this a child. And either the text block over here are going to save the try game. Or actually usually just as we try. And on the phone, I'm going to change the size to maybe 34. That seems fine. And for quick game again, another text block, they're going to make it 3042. And we can just say quit. Game nation, I'm gonna name this text block to quit text. And this one is going to be retry. And we're going to have a huge block of text over here. And this one, we're going to name it. We're just going to say you do is that's that's pretty much it. Let me make that 80 actually living and textbook I'm just saying I'm just going to say you Louis. Okay, awesome. In my graph, I have to make sure I add functionality to this to these buttons. So if you scroll all the way to the bottom after you've selected the button we have on click and on press, we're going to use the on pressed because it works better for example, if you press enter by mistake it might just end up retrying again, we don't want that we have to make sure we click on the button. So that's why we use on pressed do the same for retry game to I mean for quit game. Not on flick on pressed over here. And for retry, they're going to open We're going to load the level, we're going to load the exact same level. So that level is going to be get level get current level name. Because if it's a different level, if it's level two, then it has to make sure it has, it opens up that level. So get current name ensures it gets the proper level, the level that you're running right now. And we're going to open that level. So it's basically to open the same level, again, all the default settings for quit game, it's literally just one node, quit game. That is it, Compile and Save. Now if I minimize my screen called P, again, we have to make sure we add it to Viewport. So if I go to my blueprints, if my player is that detached from controller pending, destroyed, that's fine. And whatever we did here, we're doing the exact same thing over here. But the problem is, remember, this is on tick. And when we create, when we put this on tick, it means it's going to create the player widget every single frame and add it to Viewport every single frame, which means your game might end up crashing. So we're going to add a note that says do once. This means that it's going to whatever that comes after it's going to do this only once. They're going to burn to make sure we recreate the loo screen widget, and then we're going to Add to Viewport. Now if we compile and save it, let's run the game. And now it says he lose. But the problem is we cannot use our mouse, we can only you know we have to press windows etc. So if you want to show the mouse cursor, get your Player Controller anything related to controls that's present in the Player Controller, and over here, search for cursor. Let's see what we have over here. We have get Show Mouse Cursor Set Show Mouse Cursor. So we can set this by this value is present in the Player Controller, we can set this to true after Compile and Save this and minimize. And we're running around. And now I can see my cursor. If I press retry. It loads the same level again, and I'm losing and blah, blah, blah. So it basically restarts the level. Okay, awesome. We've done all of that. Now let's see how to convert these into functions. Functions are basically blocks of code made into one chunk of an object, which you can call later on. For example, if I right click on all of this collapse to function, collapsing the function fail, let's see why is that okay? Delay cannot be okay, some. Okay, let's just create a test function over here, test function. So this function can have a lot of different functionality. For example, imagine I have 1000 nodes in this graph over here, forgot to even graph if I'm, if I want to call this function again, like in 10 different positions. What if it makes better sense for me to call this function rather than creating those 1000 nodes again, and again, and again, that's going to look very, very dirty, which is why I'd rather put those 1000 function those 1000 nodes in one function, and then I can call this function, and delays cannot be added in a function. So if I right click over here, I can just collapse this to a function. And I can say that use health. And this function we know that reduces health. If I double click on this, it does the exact same thing over here. Now, if you want you can convert this to a function to I'm going to leave it they've done that for now they've made functions for me, we've made a function for it yourself, but I'm going to leave the player death part as it is. But I can maybe add this part to a function. But that depends on you. Or I can just collapse this to a node to collapse to node player deck. So this basically just instill in an 11th graph. It's not it's not a function or anything, but we're just making this part of the code faster. I mean, shorter so that we can find out what's going on. Okay, so now let's create a variable called battery's collected, there should be an integer by, what we're going to do is we're going to have a maximum number of batteries per level. For example, this level will probably have eight different band aid batteries. And once we've collected all batteries, we're going to check if the number of batteries we've collected is equal to the number of patties that are supposed to be collected. And if it is equal, then we can say the player has won the game and move to the next level. Or they can just display when screen but in this case We're going to just move to a new level, and you can add all the other functionalities. So once we've reduced health, this part means the player has not died yet, as you can see over here. So what we'll do is, after releasing the head, we're gonna check to see if the number of batteries we've collected is equal. But actually, we're not going to do this in the player, we're going to do this in something called the Level Blueprint. So if I go to my level effects here on blueprint, and if I hit on Open Level Blueprint, this is a different type of blueprint, it is for the level itself, and it can get access to every single object that's present in the level. And I can add functionality based on that, for example I can get, I can get the character that's present in this level, and then check to see how many back he has collected. And and check to see if the number of batteries I've collected is, you know, equal to the number of get batteries they're supposed to be collected, and then change to the next level. So that started with that. First off, in begin play, we're going to get hold of our BP underscore Batman. So Get Player Character, we're gonna cost it to be fi underscore Batman. So we're gonna, we're going to convert our character to the Batman. And then as Batman, we're going to promote this to a variable, so that we have a reference to our player at all times. And in tech. So now we'll be introducing something else. But before we we start making our Venn conditions, let's actually implement our batteries themselves. So right click, create a new blueprint. And this is going to be an actor, TV underscore battery. If I open this up, I'm going to add something called box. And I'm just going to add, actually, let me just add a cube over here. If I scroll all the way to the bottom, okay, I'm adding a cube, this is going to be my battery, your title, try to try to change the Static Mesh to something else, maybe try to find a battery acid and change the mesh to a battery. But I'm going to leave this as it is, we're going to scale it. So if you want to scale and press our I'm going to make this flat. Something like that. Okay, awesome. Now, what we'll have to do is, let me change the material to maybe I've seen this really cool material that Unreal Engine has, it has this very cyberpunk like texture, there we go. I love this texture. I'm going to make it this. Okay. Now, if we scroll all the way to the bottom, we have a lot of different events. What these events are, is that when the component is hit, do something, when that when someone overlaps the component, do something when an object has ended overlapping, do something. That's basically all these events are. That's what these events do, let's try to take a look at the on component head event called when a component hits something solid. So if this component hits, maybe something solid, like another cube or a player, what is it supposed to do, that's how projectile bullets work in game development to let's try to take a look at on competent head, press on if I click on the plus symbol, I have something called the head component. And the other actor, the other actor is going to be whatever actor that has collided or hit this cube over here. And we're going to cost this to our battery man. No, not the battery, the battery man. So search for battery man. Now if this is true, so if I have cost, if I have hit the battery man, then we're going to get the health. Get the battery. And then we're going to add, maybe let's see, we're going to add an amount that actually let's make this a random value, subtract a node from this and then there should be there should be a node that says random float in range, we're going to we're going to add a value between five and 10. So there's going to return a value of five and have a number, a random number between five and 10. And from battery we're going to set battery again. And then we can drag this in for Compile and Save. Let's see if this works. And I have to obviously destroy this object because I don't want to cheat so I can destroy the actor which means it's going to get deleted from the scene. If I placed this object over here, and move this to the top, maybe we can add some lines This what? Oops, okay, I have to make sure I, the game isn't that difficult for me. So I'm going to change my battery value back to 100, Compile and Save old faith, fam move towards this battery, you can see that my head has increased over here, let me show you again my battery. So you can see it's slowly increased, which is what we're going to do over here. Now, we're going to make sure we keep increasing our battery for our player over here. Let me go back to my BP underscore battery, let me add a light over here, point light. And make sure you raise it to the top because if it's inside the object, you won't be able to see it. And we can make it red in color. Okay, Compile and Save. Now, here comes the interesting part. This is where we make our wind conditions. So over here, once we've added health added, okay, my opponent has been added battery to our battery man, we can add a variable to the batteries the player has collected. So again, get the batteries collected over here. And we obviously have the set of doses set that is collected, I hope this doesn't get too confusing. If you do, then try to make try to do a little bit of math in a in a different project on your own by getting values from a player and casting them. And you will be able to understand them in no time, I'm going to add one to the number of batteries collected. So if I let's say I have three batteries already collected, I'm going to add one to it. So that's going to become four, I'm going to set the batteries collected. And then I'm going to destroy the cube, Compile and Save. Now in my Level Blueprint, I have to make sure I define what is the maximum number of batteries, right. So let's try to do that. Now, right like, we're going to take a look at something called the Game Instance. So let's take a look at Game Instance over here. Now gi underscore battery, man instance citizen all of that. So in this instance, what a Game Instance is that it is an object that persists persists through every single level. So this object will be there in the main level. And then level one, level two, level three, this this is going to persist in every single level. So we can add a few variables that says okay, if it is level one, then make sure the number of batteries is let's say eight. And that will do it has to be 10 etc. Now, this is not the best way to do it. But since this is a very beginner level tutorial, we're not going to go over gameplay, like proper gameplay mechanics. So I'm just going to add a variable here. So level one, then batteries, actually no Max batteries. One. So this indicates for level one, this is the maximum number of batteries are going to make it a float. And let's this let's set this value to eight. Now, if you want another level, let's say level two, you can say Max batteries, two, etc. Now go to the Level Blueprint. And you will have to do this for every single level. But in tech, what we can do is we can right click Get Game Instance, we have to cast this to our battery man instance cost vi battery man instance. And again, we can do this in big and play because we don't want to talk we don't want to cost this every single frame. And then we can promote this to a variable gi battery math. Okay, now from the battery man instance, what we can do is we can get max batteries for one. And then from our battery man, the player itself, we can get get batteries connected. We're going to check if these are equal. Now I forgot to make this an integer. So let's make sure this is an integer to Compile and Save level one that's checked to see if these are equal. So I can if these are equal, then I can basically say so again, we have to create a branch so we're creating a condition over here. So if we create a branch Event Tick, if these two are equal, then I've won the game. So I can just end up opening the next level or again I can I can have a windscreen or whatever match has been opened another scene for this one. And let's call this level, the next level, whatever. For example, this one's going to be level two, you will have to do this for every single game level. But remember in the C++ course, since that's going to be a more advanced course, we will take a look at how to make this a lot more scalable in the sense how to make sure we just add the logic once and we don't have to keep copy pasting our code on and on and on. Now that they've created the Game Instance, we have to make sure we set it in our project settings. So go to maps and modes. And if you scroll all the way down, our default Game Instance has to be gi underscore battery instance, let us create another level over here. So again, new level, there's going to be a default level and save it. We're going to call this level two. And that's pretty much it. I bet we're done with all of our code mechanics. Now, if I play the game, and let's say our maximum is going to be one. So if I open up my Game Instance, over here, my maximum number of entries is going to be one, for example, save the game. And if I play now, we now move to the next level. So that's how we make our vent conditions. Now all you have to do is decorate your level, maybe add a few obstacles, and maybe like a few cubes that distracts the player, maybe trying to make this into a maze, get a few assets from the marketplace and try to make it in such a way that maybe it's like in a spaceship, and the player has to find all the batteries from the spaceship, which would probably look really cool. But now I have five different batteries here. So I'm going to go to my Game Instance, maximum batteries is going to be five over here. Compile and Save, and save it. Okay. Now let's see if this still works. So all fie I'm going to collect, oops, it seems like I have to make sure this is all the way to the bottom. So all the way to the bottom, all the way to the bottom. Okay, all fee. Now let's see. So first, my battery does keep increasing. So that's pretty cool. But okay, I might, I might actually lose this. I'm not really good at games. Okay. Okay, we seem to be we seem to win the game. That's awesome. And yeah, that's pretty much it for our vendor events. Now, let's say your level two is your last event, what you do is in your level two Level Blueprint. So if you open up the blueprint, just have the same condition that as you had in level one, except if it's equal, you create a new widget, your your windscreen, for example. And then you display that windscreen on to the scene. For example, if I go to level two, now, let me actually show you how to do it real quick. So if I go to level two, open my Level Blueprint, now I can try to do this on your own, please don't try to copy what I'm doing. That's fine, I want to show everything because I want to sort of make sure you guys get it on your own. What you do is you will get your Game Instance again, you will cost this two battery instance. And we're pretty much doing the same thing we did before. And remember, if you have level two, your level two Level Blueprint open, you can open your level one level blueprint, it's going to get closed automatically. So we're going to promote this to a variable. And same thing. The same thing happens except it's going to be for our Player Character. So Get Player Character cost to battery man. So basically converting it to battery man and then promote the variable. And then we can get max, I mean get batteries collected. And we can use this to compare. So in our Event deck, what we'll do is we can get these to get batteries man so there's going to be so we have to create a new condition for level two. So all you have to do is Ctrl C Ctrl V, rename this to max batteries to I'm just going to make sure the max battery is just something like one for my level two. So this is equal to the number of batteries are collected, not battery number of patties collected batteries collected If this is true, what's going to happen is I can just print out, I can create a new widget, there's going to be my winning windscreen over here, which is going to basically have a text that says you win the game, and then it can have a quick game. And then over here, we can say cost to, I mean, and to Viewport for time to compile, that it has an arrow here, because the Create Widget class has to be specified. So let's create a new UI element over here. So UI. Actually, let me just let me let me do skaters W, BP underscore wind screen. Now in stuff lose, they can just say, you when. And we're going to load out for retry, we'll load the first level. And actually, let's have the return to main menu part in this vein main menu, and quit game. Yeah, fifth game is going to be the same. Now in the graph, open level four, because we have to make sure we rename everything because we just duplicated it. So for retry Game Over here, we have to make sure this says main menu now. It's just for simplicity's sake. Now when you press the main menu, we want to open up the main menu. So we're going to create a new level called Main Menu, obviously, Compile and Save. Because if I go to level two, I can just create the main screen and make sure you get the Player Controller. So Get Player Controller. Show Mouse Cursor, we're going to set it not get it. So Show Mouse Cursor set it we are going to set this to true, Compile and Save. Now we have the main menu we have the main menu part. And that's pretty much it. So my condition for my second level is going to be two sets need to collect two batteries and I've in the game. So over here, we're going to end up adding batteries again, we'll add two batteries. If I played the game now collected one collected two, and doesn't seem to be working, let's take a look at what's going on. Okay, the reason why I wasn't working was because I got the variable for the first level. So we're going to get batteries over here and make sure we set that now it's going to work. So if I Compile and Save, and again, remember we have to make sure we detach from so okay, if I go back to my battery man, you see we have detached from pending destroy over here, we're going to do the same thing over here. That's because as I move my mouse, I don't want my camera to move to in my windscreen. So let's see, let's actually see if we can get this on our own. So detach from nope, I'm not able to get that get that particular node. So let's see if that's present in our Player Controller. No, it's not present in our Player Controller, which means it should be present in our character itself. detach from controller pending destroyed, there we go. We can do that Compile and Save. So this means we cannot control our player anymore. So once I collect these two batteries, it says you went and again one more problem. This is going on in tech. So we have to make sure we do this only once. We don't want this every frame it's going to crash your game which was about to crash my game. So we have to make sure that only that's done only once. If you want you can make put all of this in a function. And yet we're gonna save this go back OLOFI collect the first one second one, we went quit game and we're done with the game. Awesome. Now, obviously this is not the best way to make a winning condition but if you want to do it, don't worry about making it the best way possible the first time you're trying it. The main the main point is to understand how blueprints work first, and then in the next course that is fine. The next course is going to be a more advanced course where we learn Proper winning conditions, all gameplay principles, etc. Now, we have one more thing remaining. And then we're finally done with this course, which is going to be our main menu. So, in fact, I had to create another Widget Blueprint, W BP underscore main menu over here. And I'm going to add an image again. Let's make this fullscreen and anchored, make sure that's fullscreen. And now, what we're going to do is, well, let me change this to black first, this is going to have two buttons, one is going to be play game one is going to be quit game. That's pretty much it. And I'm pretty sure this is self explanatory. I'm pretty sure most of you guys will be able to do this on your own by now. But if not, no problems, don't feel demotivated, it's completely fine. It's normal. So we're gonna save play game over here. Duplicate this control, actually, yeah, Ctrl W, that's duplicate. And they go, they're going to make this, I'm going to call this quit game. And obviously, you can have another, you can have another button that shows the controls, etc. Over here, that's add some text, text to both play game and do it again, I added it to the image by mistake. So I'm going to remove that there's going to be called play game. This is going to be called load game. And obviously, we want to change the size to like maybe 34. That's not gonna be faking. I'm just gonna quickly over here. And over here, again, go back to the font, make this 34 Compile and Save. How do we tell the editor that whenever we open up a project or the game, we need to make sure it opens this main menu level. To do that go to maps and modes. And you can see your editor startup map and your game default map, what I'm going to do is I'm going to create a new level and make sure it opens up the main menu over there. Now open up a new level. Actually, we don't need to make it a default level, we can just create an empty level over here. And Ctrl S, you can see that it's completely dark because there's nothing in this level, we're going to call this the Main Menu. Over here, what we're going to do is open up your Level Blueprint. Before that we had to add a game mode override because as I said, it doesn't have to add. So if I run this game now, it's going to Okay, all up. If you see it spawns up, it spawns the BP underscore Batchi. Man, we don't want that, obviously. So what we're going to do is we're going to add a game mode override over here, which means for this level alone, it's going to create a different game mode and it's going to use that so under Custom custom blueprints, I'm going to create GM underscore main menu. And over here, under default point, it's going to be none under hard, I'm just going to have all of this normal. Now. Under blueprints Open Level Blueprint, again, we're going to do the same except this might be in vegan play. So Create Widget. And what we're going to create is the main menu and Add to Viewport Compile and Save. Now if I go back to my project settings, scroll over scroll down here I have my editor start up map. I'm going to keep my level selected over here so content levels main menu, I am going to hit this arrow and it's going to automatically assign my main menu now let's play the game. So press Play Game nothing happens that is because we haven't added functionality yet. So if I go to main menu, select this button again scroll all the way to the bottom on pressed you know what to do open level this is going to be level one. And if if I go to quit game on pressed again, you can just quit the game. Now make sure in level two level blue in our windscreen Level Blueprint. It the level is named properly. So that's main menu without a space, Compile and Save. And this is to have a sense playthrough now. So if I alt V three game, I have my HUD, and you may have VLC because of that, okay, there we go. We're going to try to collect all of these on time. And that's level two. And level two, we're going to, we're going to get these two. And now we win the game. And we can quit the game. That is pretty much it. Now we have a tiny little part over here, the animation keeps playing for the animation keeps playing for our well in our level two after we win the game, because we haven't added a win condition in our Animation Blueprint. So what we're going to do is we're also going to add another variable, and this variable is going to be called B has layer one. Now in begin play, I'm going to make sure I set this value to false and make sure this is a bool. So we're gonna change variable type. Close Compile and Save, and make sure we set this to false every single time we start playing the game. Over here, in my Level Blueprint, again, what I'm going to do is in level one, at Save Selected blueprints, Open Level Blueprint. And we have to make sure we get this character from the from the character over here, set. Clear one has player one over here. If it's true, then we can set we can actually we have to set this only in level two, not our level one, because our player hasn't technically won the entire game completely yet. So if I go to level two, open up my Level Blueprint, I have the same thing over here too. Now if I, if I from the battery man, I have to set one just search for has player one, I'm going to double click on this node so that I can redirect this node over here like that. Move it all the way to the end. And then connect this, we're going to set this to true, I'm going to again add another node over here so we can detect it properly said looks a little neat. Compile and Save. Now let's open up our our Animation Blueprint. And open that up. Okay, over here now we're blending spaces wherever blending poses by bool over here. Now, if player is dead, they're going to play the idle animation. But if the player is dead, or if the player has won the game, we're still going to play the idle animation. So over here, we're going to have an all Boolean, what this does is it checks if one of these will so takes into bool values. And if it cannot be stick a lot more can take five, six, etc. But we just need to have these. So we're going to remove, then remove pan over here if the player is dead, or if the player has one, plate, the player dead animation. So to get that cost to Batman, we've already done that. From here, we will get one has clear one. Move this all the way to the bottom. And again, we're going to promote this to available the name is fine. And all the way to the end. There we go. That looks a little neat. AnimGraph place this over here. So if any one of these conditions are true, we're going to play the idle animation. So if I now play the second level one to see now my animations don't play continuously. So I can now quit the game. And that works perfectly fine. Awesome. Now that is pretty much it for this game. Your challenge is to add your own map try to add your own level, go to the marketplace get there a lot of free assets that you can use. Maybe make this into a spaceship and try this out. The only problem now is that unfortunately since Unreal Engine five is still under development, most of the assets are not compatible with the engine. So if I go back to my Epic Games launcher and if I try to add this free asset that I got from the free for the month thingie if I click on show all projects and try to select Unreal Engine five You can see it says asset is not compatible. So what you'd have to do is you'd have to downgrade this project to Unreal Engine five. And then you will have Unreal Engine four and then add the assets. But the problem is you might have a lot of issues after upgrading it back to Unreal Engine five, which is why it is still in early access. Not a lot of assets are still away are available for Unreal Engine five witches. Yes, it is a little disappointing, but at the same time, they've specifically mentioned this engine is an early access. So don't be too worried, you can follow the exact same tutorial that I've showed over here in Unreal Engine four, it's the same functionality, same blueprints, all of them work perfectly fine, it's just that the UI might look a little different. This looks a lot more modern than Unreal Engine four. That's the only difference accurate pretty much fine for now when it comes to at least the basic parts. So this tutorial can be followed in Unreal Engine four, two, so don't worry about that. But thank you so much for watching. I really hope you learned something and I hope you were able to familiarize yourself with Unreal Engine five and game development. If you've completed this course that is amazing tied to add your own functionality to it. If you want to learn C++ stay tuned because I have a C++ course coming very, very soon we're going to create the exact same game but in C++ so that is going to be very, very fun. But thank you so much for watching and I will see you very soon. Bye and good luck.