it really is great to be back I used to live about a mile from here just on the other side of the freeway there used to be a computer industry in Orange County that actually built Hardware built of many computers it's all gone now I guess but you're still here so it's really great to see all of you thank you everybody for helping to set this up and to provide us of this place and thank all of you so much for coming out tonight so I want to do for you tonight a brand new talk I have never done this one before I think it's a really important topic it's a really interesting topic it turns out the way our character codes work has a tremendous impact on how we think about programming and and how this whole professional operates a lot of stuff is implied by the way we handle characters computers are machines that manipulate numbers that's all computers can do that's literally all we can do but by assigning numbers to characters we can do text processing and all this information stuff happens and I'm gonna talk about where this stuff came from I think this is gonna be an interesting talk it's certainly interesting to me I love this stuff and we're gonna be talking a lot about the history of this stuff but I have not been able to figure out how to end this talk and I've done this before I've gone out and I've had a talk and I really like this talk and I go out and I don't know how to end it so I just go to the end and say thank you goodnight knowing that I you know it deserved a WoW finish but I didn't give it one because during the UA or B in the QA I'll get questions and some of the questions will will indicate that I completely failed and trying to describe what this is because the question just completely missed it but sometimes the question will focus me on what the whole thing was about and go yes thank you this is the moral of this story so I'm hoping that will happen tonight so you know I'm counting on you okay you have a part to play so character codes don't start with computer systems they start first with data communications or communications in general just human communication and then data processing and eventually communication and data processing come together in computing so we're gonna start at the very beginning the first character set the morse code designed by a samuel morris an american portrait painter he also had a hobby in electricity and he worked with some partners to develop a telegraph and Morse put together the code that transmitted words across their Telegraph and it's a very very simple code because they're telegraph all I could do was transmitted to States it was either on or it was off so Morris figured out a way to turn that into a communication channel so he has a language that's made up of two symbols dot and dash and we can represent these in binary so a dot is a single one and a dash is three ones and then in order to tell the difference between the dots and the dashes he need to put some zeroes in between them so he's got zero for the particle space that's the small separator between a zero and one and then there's a letter space which will be the space between the letters and then a word space which goes between the words if you're a musician it's easier to think about this musically so you can think of a dot as an eighth note and a dash is a dotted quarter note and then an eighth rest is the particle space a dotted quarter rest is a letter space and approximately a whole rest is the word space so here's an exam four letters representing the Morse code so the letter T is a dash letter eyes two dots letter M is two dashes and an EE is a dot so horse took a look at the frequency of letters in English and chose the most popular letters they have the shortest codes so this is not only a communication code it's also a data compression code it's the first data compression code and it it's a code that works in time most of our codes work in space you know you can think of a word containing some number of bits or even a packet containing some number bits but this is a because it's musical it's all happening in time so remembering the word time will help you to remember these symbols that the consonants are dashes the vowels are dots and the most frequent frequent things like the e will get the shortest code okay so you now know four of the letters in the Morse code in fact I'm going to teach you all 26 letters of the Morse code because you might need it someday you might be trapped in a mine or on a disabled submarine and you're gonna need to be able to get a message out and all you're gonna be able to do is tap on the hole with a rock or something but you'll be able to do it because you're going to know the Morse code okay the fifth symbol is the V which we can get from the V for victory Beethoven's fifth so you all remember Beethoven's fifth symphony begins dahdahdahdah dot dot dot dash okay that's the letter V okay V for five you all know the SOS of the International distress signal its dot dot dot dot dot dot if we break it down into letters the S is three dots and the O is three dashes this is the opposite of the dash is being consonants but you know we got a couple exceptions so you can remember that right so dot dot dot is s dash is Oh a chisel of tricky to remember it's for dots so I recommend you think of the 4h club and and the advisor to the 4h club mr. 4h himself Harry Herbert Hoover Hever okay for the rest of the letters okay so you now know six letters right for the for the next twenty we're gonna have some mnemonics and this is helping em onyx are gonna work so I'll give you a letter and I'll show you the the Morse code for that letter and then I'll have an English word which contains that letter in which the dot corresponds to a vowel and the corresponds to a continent consonant so a is for M everybody got that and everybody understanding a okay let's move on B is for bow B my bow it's it's beautiful isn't it not my friend c is for Coco everybody loves Coco right you love Coco that's why you can remember that c is for Coco this next one is going to be really shocking and upsetting D is for die but because it's so shocking you're gonna remember this one the D is for die e you've already seen he is one of the the time things it's one dot and F is for Fe that's right Luffy everybody say you fee okay so AM Boko code ie goofy everybody with me so far we're learning the Morse code G is for ganoub for programmers that should be a really easy one G canoe G canoe is that outfit that gave us a failed UNIX clone and a software license in which free is not free right everybody knows that one we've already seen h the 4h club Harry Herbert Hoover Hever I we've already seen iii write two dots and I J hey J what do you say hi JJJ you what I JJJ k is for a kit right that's easy kit okay get up maybe yeah K and L is for soothing aloe you can't forget that L 4 L oh of course so canoe 4h III ajjj kit and aloe everybody still with me let's learn some more M we already saw is one of the time letters it and it's good mmm good that's the letter M is good and oh no got it okay we already saw Oh from the SOS P is for Expo you might imagine next year there's going to be a big Expo in which they're going to announce a better mnemonic for the letter P so we're all looking forward to that Q is a bit tricky cuz it's hard to make words out of Q so whenever you have a Q you're likely to have a you after it so we got that pair and we're gonna wrap it in quotes but we don't have quotes so we'll use the letter Q for the quotes because Q is for quote and so we get Q qu q okay got it r is for era this is the era of Morse code are ya okay s we already saw in the SOS and the distress signal we already saw T in the time letters you out o UT out okay we already saw a V Beethoven's fifth I thought but the W is for the wise old owl that's easy to remember w and the owl because he's so wise X X is another hard one but fortunately X rarely happens in English so we're safe but you know it's XO o X you're not gonna remember that but you'll probably be okay then why yuck so you know if there any little kids here I don't see any little kids if there were any little kids the two symbols they're gonna remember tonight are goofy and yuck that's for sure and then finally at the end of everything is Z of course so what comes after zu z zu right that's the end right z zu is the last so you now know Morse code you're not good enough to get an operator's license but you could probably recall this and make a list and then you can tap it out you know you might be on that disabled spaceship and you need to alert the fleet you're gonna be able to do it someone's gonna say my god that's Morse code and we'll be saved okay so moving on the next communications code was the Bedok code which was invented by emil Bedok it was a French calligrapher he wanted to improve on the Telegraph so instead of the operators having to be entering a stream of bits that instead you would have a keyboard that would look like a musical keyboard with five keys on it and you would chord in the letters that you want so you would have to memorize the letters in order to get them in and this keyboard would be attached to a paper tape punch which would produce a string of paper tape with the holes in it and then that could be transmitted there was another guy who came on so if ever heard of baud rates which is yeah the couple the oldtimers going out I remember baud rates bada is usually bit well it actually means bits per second but yeah it's slow is also another meaning so it was named after this guy so Donald Murray who is a news New Zealander improved on the DOE system he came up with a much better keyboard so it had a button for each of the letters and so the operator didn't have to memorize the binary code so you just go punch punch punch punch and he could have picked any keyboard and unfortunately he picked the QWERTY typewriter keyboard the QWERTY typewriter a keyboard is terrible by design in order to try to prevent the jamming of the mechanical keys you know it wasn't completely successful in doing that but that's why it's got that bizarre layout and Murray could have said well we don't need to do that because you know when you push a button we're closing a circuit which is gonna drive some pins through some paper tape so it doesn't matter what order we put the keys in he could have done something rational but he didn't and so we're still stuck with the QWERTY keyboard everywhere this is the first time QWERTY is used in electronic communication and and it's still being used in electronic communication so this is a refinement of the code that those two guys worked on and it became a standard one of the first telegraphy standards this is International Telegraph alphabet number two it was a 5bit code which allows them to encode all of the letters Murray scrambled the codes around in order to reduce wear on the machinery so that instead of optimizing for time he was optimizing for bits where each bit would cause a needle to drive a hole into a piece of paper and those pins would wear out and so in order to reduce wear on the machinery he have the most common codes have the smallest number of bits so for example e is a very popular letter it only has one bit and T is also a very popular letter it only has one bit and since the operators didn't see the codes it didn't matter that they were kind of random then there's a code for space carriage return and line feed two separate codes because that's how his printer worked the most interesting thing that bodo did was he added a couple of shift keys so there's the figure shift and the letter shift so when you're in letter mode you get these codes and when you're in Figure mode you get these codes so that gets you the digits and the special characters which was a really clever idea so they managed to get you know 60 or so characters in just 5 bits and they decided to have 2 codes instead of 1 they could have just had a toggle shift but there was a concern that the telegraph lines were very noisy and if there was a line hit then a shift code get get garbled and that means everything after that is going to look wildly wrong so to make the system a little bit more resilient they have two independent shift codes so the next step happens a bit later the Hollerith code so Herman Hollerith developed a data processing system using punch cards for the 19 or for the 1890 census the US Constitution requires that every 10 years we have a count of everybody so we can figure out how to staff the House of Representatives and it was taking too long to do with pen and paper so Hollerith figured out a way to do a lot of that work mechanically and that turned out to be a big business a number of companies were formed and after a series of acquisitions and mergers in event tolerance company eventually becomes international business machines or IBM and in 1928 IBM wanted to figure out a way to get more information onto the cards because with Hollerith little circular punches they can only get so many characters and they wanted to get more so they came up with a system in which they could get 80 columns on a card each card had 80 columns and twelve rows in which you could punch holes and at the top there was a blank space where you could print stuff with ink so that humans looking at the card could figure out what it said although people who were skilled with this code could actually look at the punches and tell you what it said so they came up with a very straightforward way of encoding the characters so first if in the top line it's called the twelve row or the 12 punch or the X punch or the plus so if there's a punch there then you get a plus sign the next row you get a minus sign and then 0 1 2 3 4 and so on to 9 ok pretty straightforward and they wanted to be able to do letters too so letters are slightly more complicated each letter requires two punches because we've used up all the one punch codes so we use the the plus Rho and the digits one through nine and that gets us the letters A through I and then we do a similar thing with the minus row and the digits 1 through 9 and that gets us J through R and we do a similar thing with the zero row but this time going 2 to 9 to get S through Z this pattern should give you 27 letters but we only need 26 so they needed to drop one of the codes and the code they decided to drop was 0 1 and the reason was that you had two holes with just a tiny little piece of paper between them and there a concern that given the crude machines of the time that they were using metal wire brushes to sense the holes in the cards that it could rip the card which could cause the machine to jam or cause bits of little pieces of paper to accumulate in the machine and eventually catch fire so to avoid that hazard they skipped that code but then you could have threeletter codes or different combinations of two whole codes to do the special characters and unfortunately that never got standardized very well so different machines would have different codes so taking a deck of cards and moving it from one system to another could get really complicated because all the special characters could get misinterpreted so now we finally move into computing when computing starts in the late 40s the first computers have six bit character sets these machines were mostly concerned with computation mathematical computation and so six bit character sets were were fine so this is one that was used at IBM their character set was based on a praetor that they were using with their punch card equipment which they modified in order to work with some of their early computers and so their printer only could print 48 different characters and so they left a lot of these codes blank and they had a few weird characters like like that so what is that I don't I don't know what it is oh it's called a square lozenge I don't know what it means but it was on their punch card equipment and so people would use it because there weren't very many characters available so that meant whatever you really wanted it to be you would use that because that's that's all it is you know they didn't put a plus sign in it which is like I don't understand as so the next step forward is Fortran Fortran is the first really successful programming which kind of changes the world it was also developed at IBM and it gets poured into all of the IBM machines and then everybody else makes their own Fortran systems as well it's the first big programming language and the guys who were designing Fortran couldn't figure out a way to make a programming language out of that so they said we need these additional characters and so they just said if you're going to have Fortran you're gonna have to neat have to get these characters somehow and so IBM said okay we'll try to figure out how in our next printer we can we can add those so in a later version of the there be CDI C code they've added more characters so something that's weird about this you look at the arrangements of a and J ass what they did was they just took the Hollerith code and pushed it into the characters head okay so we have an expectation that each letter is going to be one away from the next one but that's not the case here you know I plus one is question mark not J okay so it's gonna be a little challenging you know write a sort routine for this character set okay and they got some weird characters like these guys so they they created a magnetic tape system to work with this computer and they reserved these four codes has special marks on the tape and they recommended that you never use these codes in your programs because if you try to write those codes to the tape it's going to screw everything up so they picked characters that they thought no one would ever want to use then they had a problem they started selling stuff in Europe and found that this isn't enough letters that you know like in Scandinavia they need three more letters and so they decided well you can take those letters and/or those characters and replace them with letters in whatever country you're in so this kind of begins the I 18n problem that this is where it starts and it took a long long time to fix it now turned out every company had their own character set so for example control data started with the IBM set but kind of changed a little bit because they were more into scientific computing and so they added some characters that they thought people who are programming about numbers we care about things like not equal less than or greater than angle brackets or less than or greater than that's good stuff right another company that was doing brilliant work the Burroughs 5000 series is maybe one of the most interesting architectures ever designed and they're still doing the IBM thing except that kind of straightened it out a little bit at least a comes before s now so that's good and I really like that they put zeros at the top row that means the character code for 0 is 0 does that make sense that absolutely makes sense that's brilliant as a programmer I love Burroughs I that makes so much sense to me and are pretty good my set oh and they got an arrow which is what we should have had for the assignment operator Fortran didn't have this because they just didn't dare to ask for another character and so they were forced to use the equal sign for assignment because they had no other options and we're still doing it it just doesn't make any sense we should be using that re that that makes sense so the US Army is buying lots of computers and you know each of its computers comes from a different company and they all have different character sets and trying to exchange information between all these machines was really really hard so they decided to fix the problem being the government so they created a character set of their own called field data and field data was a 7bit character set which was intended to run on all army computers and that would let them communicate but because it was a and there's some pretty reasonable stuff so they finally fix the alphabet right so it it's all continuous so I like that a lot and it still got some of these weird IBM characters in it but you know that's okay and some of these could be replaced by other characters for and for some reason they they moved all of these characters up to the top half of the seven bit character set and they leaved the left the bottom half of the seven bit character set undefined so there were a number of projects in the army that started working with this character set and they liked it it worked well and they hadn't need for lots of extra characters and there was all this you know 64 characters that weren't being used so they just started using them which was fine for them until the army wanted to make all of these programs work together and they didn't because everybody saw that there was a hard lesson there that you really have to nail stuff down in a standard if you leave too much stuff free then programmers will abuse it as a result you'll lose interoperability or quality or whatever it is you're trying to get so the next big step forward is ASCII anyone heard of ASCII yeah ASCII is a big deal the American Standard Code for information interchange work started in 1963 and ASCII was a joint project between AT&T and IBM and a whole bunch of other parties it was not intended to be a computer character set it was intended to be a network character set or a communication character set but will not only have teletypes on the line but will also have computers on the line using the same code so this is a big step forward initially ASCII was going to be a six bit character code basically they're going to take the bardo idea but add one more bit to double its capacity and they wanted to be able to represent uppercase and lowercase and the way they were gonna do it which i think was completely reasonable was they were gonna borrow the shift idea that was in the Bedok code so they would have shift uppercase and shift lowercase and that would have been brilliant because the way we would deal with case today would be exactly the way we deal with color or underline or italics or anything else small caps it'd just be you know you have a code which represents a letter and will have some other means of saying what glyph we want for that letter but they didn't do that and the reason they didn't do that was again the line noise problem in the telegraph lines that the lines were really noisy we didn't have the error correcting codes that we have now our air correction systems are so good we're not even aware of them anymore but when this was designed line errors were a really big problem and their concern was that if one of these shift characters gets mangled in transmission then the rest of the document is going to look stupid when it's printed out and to deal with that they decided let's change it into a seven bit character set and give each of the letters a separate code which I think was a terrible decision that the reason they did that stopped being necessary a long long time ago but we are still stuck with the consequences so this is the code that they came up with 32 transmission control codes at the top anybody have any idea what those are you might recognize one or two of them most of them are a complete mystery to you but there is still in the code then we've got the digits are lined out pretty nicely it's actually a pretty nice thing they considered interleaving the upper and lowercase characters so you'd have uppercase a lowercase a uppercase B lowercase B so that most things would kind of sort right but they decided it doesn't sort perfectly and rather than try to figure out how you might fix that where you might fix it would be to go back to the 6 bit code they decided let's make it really wrong and you know we'll separate them by 32 so so you're probably curious about what those control codes are tonight for the first time I'm going to tell you what those control codes mean so AT&T insisted on two codes null and del delete so these were for punched paper tape applications so on the punch paper tape zero means there's nothing punched on the tape and one one means there is a punch on the tape so they wanted blank tape to be to have a code that you could recognize and reject so you'd have a liter of blank tape and you'd run that through your tape reader and you'd send it to the other side and the other side would see oh that's just a zero I'm going to ignore it which sounds bizarre in our modern system you know the internet doesn't work that way but that's the world that this code was designed for and then so offline you're editing a paper tape and you make a mistake and you go oops so what you do is you back up the tape and hit the delete button which goes junk and punches out all of the holes and then you can punch the character after it so punching out all the holes means this is a non character ignore this non character so it means the same thing as null but it just happens to have a different code because that's how paper tape works so then there was also a backspace code the the BS code but it did not mean erase the previous character it was not designed for user experience because there were no users there was no experience this was just designed for machines talking to each other so backspace meant moved the print head back one space which meet that's a completely different meaning later programmers said oh look there's a backspace key oh there's a delete key let's figure out what to do with those and the things we do with those now are completely different than what they were intended to be yeah we're in complete violation of the ASCII code in the way we use backspace and delete there are some codes added for operators for teletype operators there was the enquire code which when you sent it to another terminal would cause that terminal to send back a string which would identify the terminals so you know here connected to which sounds bizarre today how could you connect to something without an expectation of who you're talking to and then there's the Bell code which will ring the bell so you go ctrl G and on the other terminal go ding you know so you know adding a meaning now wake up think there was space and there was tab space was necessary because you need the inter word gap a tab was borrowed from manual typewriters manual typewriters had a tab key you press it and it would release the carriage until it was stopped by the next mechanical tab stop unfortunately they didn't indicate any way of specifying how to set a tab stop and they didn't specify what the default tab stops are it just said if you're going to tab this is the code and and they never anticipated what we're doing with this stuff and unfortunately this is a source of conflict we're still arguing should we use tabs should we use spaces it's a colossal waste of time and the debate goes on it will never stop because there is not a clear answer neither side can prove that they're more right than the other side and lacking any way of resolving the conflict it just goes on and the cost continues to grow and grow and grow the value of having these two characters zero we get no value from having two ways of doing this thing at least compared to the cost that it causes so I recommend a different way of resolving this problem which one can we get rid of we can get rid of that one yeah so we should get rid of tab it's not a question of which one is better it's which one can we get rid of that the tab character is an anachronism that should have died with the typewriter all right we've finally settled that okay we have carriage return in line feed again these are because of the way that the teleprinters worked carriage return would move the printhead back to the margin and line feed would roll the paper up one line and they liked having the two codes because the carriage return function was kind of slow because it you have to move a thing down and having the line feed happened just after it gave it a little bit more time to have that because if you then have to print another character before the carriage return gets back you can be printing ghost characters in the middle of the page and that looks stupid so we don't care about that anymore that's not how printers work now but we still have these two codes and there's still an argument about which one should you use people who think about this in terms of user experience will usually say it should be the carriage return because the Enter key used to say return and so you know that's how users think of this the hardware oriented people say line feed is really the way printers want to work they want to advance to the next thing and so you know how do you decide which one to do well there was a committee in the early days of the internet trying to decide which one should we use and they couldn't decide so they came up with the mutually disagreeable compromise which is we'll use both of them which doesn't make any sense that using both of them went out with mechanical teletypes but we're still doing that if you look at the internet standards look at HTTP it still says you have to use both it doesn't both at the same time it just doesn't make any sense we also have form feed which told the printer to eject the current page and put the next page into the printer so you can start printing and a companion vertical tab which is the vertical version of the horizontal tab but again they didn't specify any way of setting a vertical tab stop so it today it doesn't make any sense JavaScript still lets you say backslash of e representing this it doesn't mean anything and just it's pointless there were four device codes in ASCII so that you can control devices and generally that meant controlling the paper tape reader and the paper tape punch so you're telling a per tape reader on it and if the computer wants to start reading it it can send you can turn the reader on and then it'll start automatically sending characters to the computer and if the computer starts getting overwhelmed oh there's too much input they can then tell it to stop and the computer could also turn on the punch so you can start punching your paper tape those codes are still in ASCII then there are codes for dealing with protocols because they imagine that instead of just sending streams that we might actually be sending higherlevel stuff and so this was really new stuff that they were kind of inventing so they imagined that we'd have protocols in which we'll have a start of header and a start of text code and an end of text and an end of block and we'll use those to make packets packets were still a really new idea and then in support of that we have AK the acknowledge code so if you successfully read a packet you'll send it back ACK and if for some reason you couldn't read the whole packet you'll send back nak and there's also the synchronous Idol they anticipated asynchronous mode in which well in a in a circus note mode there's a start bit and a stop bit on each character and that's so you've got an empty stream and then you see a start bit and you go Oh wake up there's a character and you keep getting bits until you get the stop and then you can go back to sleep but there's also a synchronous mode in which the characters go one after another no start bit no stop bit and the problem is how do you know where the character boundaries are because it's just ones and zeros and so they have asynchronous idle so when there's nothing being sent you send this code and on the other side they'll be looking for a pattern of those zeros and ones when they see them they go off that's a character and then they can deal with the rest of it so a packet might look like this you might have a start of text and then the body of the message and then the end of text or you could put a header on it the header might contain an address or some other information which helps you to deal with the packet and using the end of text block you could have really long things and you can get an ACK after each one because it might be too dangerous to try to send something really long because it's guaranteed you're gonna get an ACK so if you send it in smaller chunks then you might get stuff through there are two end codes one was end of transmission so at the end of the session you'd go control D yeah that's the end then we can hang up and and we're finished and there is also end of medium this is something you might put on a tape so you write a tape and at the end you'll write and then to medium code and that means that's the end of the tape then there are a couple of oops codes there's the substitute code that means that if you have a character and you don't know what it is you send the substitute code instead again today the way we think about data communications that doesn't make any sense how can you not know what a character is and still want to send it but you could do that also there's a cancel code if something is coming or if you're sending something side i never mind I'm not going to send the rest of it you can just send the cancel code and and you're done there's escape escape was not what we use it for now escape was for extending the character set they anticipated that the hundred twentyeight characters in ascii might not be enough so escape would allow some way of extending the character set so when you see the escape code that means the stuff that comes after it is going to be interpreted differently one interpretation that was popular for a while was add an eighth bit to the character so that would get you up into the latin one set but so there is an escape key on the teletypes for that purpose but very quickly people realized we're in a program and we want to make the program stop how do we do that you know I've got this escape key let's let's hook that up and we're still using it right escape gets us out of a mode or cancels the dialog or something like that it was never intended for that is intended for enhancing the ASCII set we have data link escape which does a similar thing sometimes it's used for making a control code literal so if you've got some binary data and you want to be sending an end of transmission mark but you don't want to hang up you want it to be treated as data you might put in DLE in front of it but it could also be used to introduce new control codes because they were concerned that 32 control codes were not enough they thought they might want a lot lot more then I told you about the shift codes for uppercase and lowercase they decided not to use them for that but they still put them in the code and so you could shift out meaning it could shift into another character set and then shift back into ASCII another way of growing the code they provided information separators so there's the file separator the group separator the record separator and the unit separator so they did not intend for or I've heard people say that tabseparated data is the way asking intended us to format data and it's not this is how ASCII intended us to format data you have files made up of records made up of groups made up of units of data unfortunately this isn't really how data ended up that sometimes you have records that really want to contain other records you know so this this doesn't work so I should have told them about Jason right because that's what they really should have been doing but I didn't and my excuse is that I was eight at the time and I was doing other things it's just too busy ah yeah so so that's the ASCII set so again they did not intend this to be a computer character set this is just something that computers would use to communicate with each other but a number of manufacturers thought well let's just try to use this as is because then we don't have to translate from our set into their set for one very common use was something that I called half ASCII [Laughter] where you just take 64 characters of it you said you cut out the control codes and the lower case you just subtract 32 from everything and that gets you a nice little six bit character set and there are a number of manufacturers that we're doing stuff like this it it all changed with the microprocessors but we'll get to that in a bit so the next step forward is Unicode Unicode starts in 1991 some very very smart people from Xerox and Apple and other places who have been really struggling trying to make products that worked all over the world and realize we need to figure out what figure out a way to unify the character set so we can just have one product that goes everywhere and so their goal was to make a after set that would serve all of the living languages in the world in 16bits and they came really close to pulling it off but in order to do that they had to do something called Han unification which meant taking or observing that Chinese was the route also of Korean writing and Japanese writing and taking all of all three of those languages putting them into one character said it's too big doesn't fit in 16bit character sets but if you look at how common those languages still are at least in their orthography then we can squeeze it down into sixteen bits and they tried really hard to do that unfortunately they really pissed off the Japanese but they we're not happy about the way that happened so that brings us five years later tina code two and unicode two now has a much more expansive mission they have grown the character set to 21 bits and they now want to encode all languages even dead languages you know so Egyptian hieroglyph hieroglyphics become part of Unicode which is something I like a lot so I like that unfortunately in 2010 we get unicode six and emoji for a while there was a hope that some day we could finish unicode right we'll find all of the languages that have ever existed we'll write them all down and we'll give all the characters codes and we'll be done unicode will never be done there's no way for ever get in front out of emojis so ASCII lives on in unicode the first hundred twentyeight characters of the unicode set are at the ASCII set even though ASCII was not intended to be a character set in unicode was intended to be a character set in computers ASCII is in there including the 32 control codes which you now know are mostly meaningless and completely ridiculous right they they don't serve us anymore and the way this stuff works is really important for example in the C language we use the null character to represent the end of string which is not what ASCII said but that's what C says which means that C would have broken on any of the earlier 6 bit character sets because they did not have a null code they all used 0 for a real code so ASCII changed the way we think about programming of letters and words but there was an even bigger influence than that under the influence of 6 bit character sets there are lots of different hardware architectures with lots of different word sizes but they all seem to have a factor of 3 in them so I saw I worked on carat on machines that had 12 bit characters 18 bit characters 24 I'm sorry 12 bit words 18 bit words 24 bit words 36 bit words 48 bit words 60 bit words the thing all of these machines had in common was 6 bit characters and the reason that worked was because that's what the character sets were and so you could pack some number of characters into a word and it all fit and it was really good and these were great machines and and then it all changed so 7bit ascii cause the ascendance of computer architecture based on eight so IBM took ascii and weirdly mutated it they combined it with their terrible BCD IC code and came up with something a really awful thing called ipsa dick and used that as the character set for the 360 series so that system is based on eight sixteen thirtytwo and all of her machines pretty much since then are based on that the the big change I think happened because of Intel so Intel built a machine called the 8008 which was the design was brought to them by a company in San Antonio called data point they made intelligent terminals and they were making them out of discrete logic and they were difficult to build and they came up with a design for a simple CPU which would have greatly simplified their terminals and they asked Intel if they would build that chip for them which they did so the initial design of that chip was an 8bit machine and the reason it was a bit was so that it could process ASCII that was the intended purpose of the 8008 but that 8008 grows into the 8080 and the 8086 and the pentium and all the crap that comes after and so it's all 64 bits now so if the ascii committee had successfully completed as a 6bit character said 36 bit architecture would have survived and so I think the first microprocessors would have been 12 bit machines not 8bit machines and that would have completely changed the evolution of stuff that the next step up would have been 24 and so a lot of the memory limitation issues that we felt on PCs we could have avoided those four years and then taking the next step up to 32 and today we would be running in 72 bit architecture which I think would be brilliant you know it would have completely changed the way we do internationalization Europe would have moved immediately to 12 bit character sets because 6 didn't work in exactly the same way that Asia moved immediately to 16bit character sets because 8 didn't work and by doing that we would have avoided all of those internationalization problems and then ultimately the world would adopt an 18bit character set which would be the unicode set which would serve everybody and seventy twobit CPUs would be the standard today so that's the end so I'm really looking forward to some excellent questions which will help me figure out what the WoW finish is to this thing so any questions are we learning from our mistakes in this field no now we generally don't do that we will adopt something because it seemed like a good idea at the time and we tend to never revisit it again and so you know as you look down into the history of what we've done and why choices were made and then see where they ended up you know it just you know if we had known where it was going to go we wouldn't have done that but somehow we're still here where we are and we don't recognize that we're still doing that that's just the way we do things yeah yeah what's the path going forward that's a really hard problem I mean I commend with the ASCII committee for doing as well as they did they got a lot of stuff right they were very thoughtful in the way that they approached the problem and they did the best they could where it went wrong I think was not in the ASCII committee it was after again they didn't intend intend for it to be a computer character set the intended to be a transmission code but there were people particularly in the 8bit world who wanted to save the cost of a character translation table you know they wanted to save you know under 28 bytes and if we make that our character set we saved hundred 28 bytes and at the time that seemed like a really good tradeoff but it was only a really good tradeoff for a few years eventually Moore's law changes the economics of memory conservation and that it becomes a really bad idea but again once we lock something into a standard or a standard practice it gets it's virtually impossible to roll it back yeah yeah that's a really good question so you would think so that's a really good thoughtful question I'm afraid I don't have an adequate answer for it but thank you for that question yeah yeah so are there any alternatives to Unicode being considered I don't think so I think Unicode Unicode is likely to be the last character set not you know it's just gonna be the way it is and there are some things about Unicode that I think are extremely commendable that they've done some brilliant stuff and there's other stuff in Unicode where you go you know this is awful like I showed you that substitution code in ASCII the one that says the letter you're looking for it's not here or the code you're looking for it's not here not only is that code now in Unicode Unicode added another one so Unicode has its own substitution code saying when it's not here which go we need zero of those codes right and we've got two of those codes one of the things that was liberating about ASCII was because they've got so many characters they didn't have to be nearly as cautious as ASCII was asking when they were picking the characters to go in that set they made really really hard choices and if we put that one in we can't put that one in you know they didn't put the arrow in because they just couldn't make it fit which was it was actually in there for a while and then it got taken out and replaced I think with the underbar you know so you know this stuff stuff I could anticipate I could think of one thing that might propel the world to consider doing a new character set and that would be something that would try to solve the sorting problem so unicode sorts correctly for virtually no languages right well or at least four languages using the latin set that none of the languages sort correctly we could try to and there is no ordering of the letters that will sort correctly for all languages but we could come up with a sorting which would work for most languages so we could design a character set in which we have a followed by a accent followed by a umlaut and so on we'll just batch them all up you know after i comes i J and then J and then K and so on will just take try to take as many of the European characters as we can and put them into one linear sequence and maybe that becomes a good enough idea that we can say this becomes the basis of a new character set I can't imagine anything else you know I think that would be a problem that would be worth solving and that might get us a new character set but I'm really doubtful I don't think we could pull it off there is so much inertia behind Unicode now I think it's going to be the end yeah is there any way to work in three dimensions and character cells or you can stack them up and that's essentially what Unicode does so in Unicode you've got it stacks them in a couple of dimensions one is you've got planes so you've got the basic plane then you've got sixteen additional planes which are all in the same 16bit set and within the 16bit set you could see that is broken into stacks of 8bit sets so that's a three dimensional character set yeah yeah that's the problem because there are definitely costs but all of those costs have already been accepted so in changing to something better it's really hard because it's obvious that there's going to be new costs in moving to the better system and it may not be immediately apparent to what the benefits are whereas we don't properly account for the costs in the old system so the new system is going to be at a huge disadvantage yeah could there be advantages to compression by altering the character set maybe although some of our our compression codes are our smart codes that learn in our adaptive so they seem to be doing pretty well I don't think we could get much improvement by changing the underlying character set yeah it's more bits yeah so the memory addressing problem we passed 64 bits looks like we're gonna be good for a long long time with that so and 64bit is well so in JavaScript we get essentially 53 bits at least on our integers and that's quite a lot particularly when you compare it to the 32bit architectures and much of JavaScript unfortunately is still 32 bits and there's been some pressure to try to get JavaScript to add a 64 bit thing which I'm very opposed to that if you want extended arithmetic you can write a simple function in JavaScript that gets you extended precision so we don't really need to change the language fundamentally and if you have two number types and if they ever come in contact with each other you're guaranteed to have errors right because values are not yeah that kind of stuff so I'm very unhappy with the floatingpoint system we have in JavaScript it's it's horrible but I can't see that we're going to replace it because again we've accepted all the costs of a floatingpoint system that works really badly and so we're not going to get be able to overlook the costs of moving to something that's going to like add money correctly even though that I think is much more important I think Dex 64 would be great and I highly recommend that Dec 64 be the only number type in the next language but I have no hope that it will ever get a JavaScript JavaScript is whereas Brendan Eich used to say that ship has sunk yeah yeah quantum computing is a completely different thing so you've got these quantum bits which can be in multiple states simultaneously and it's presumed that that leads to the solution of problems which cannot be solved in linear time on conventional hardware but they don't act like bits so there's not a correspondence to bits they're different stuff so even if we do get quantum computing I think it will be used in very specific applications things where you get the benefit of the undecidability in order to solve very hard problems one of the most popular expected application that seems to be breaking of cryptographic systems so which will certainly be problematic but it doesn't appear that it's going to be a platform for generalpurpose computing so I think we'll still have bits for a long long time now a more interesting breakthrough might be trying to figure out the neural stuff that we still haven't figured out how this stuff works yet but we know really well now that it works really differently than digital systems so it may be that eventually we'll figure out how to make neurons and stuff like that and that will work on a completely different principle and who knows what we'll do with that anybody else okay so I think we're done thank you very much so yeah yeah I think thank you I mean like this is amazing thank you guys for coming out stay tuned for more meetups lots to come does everybody know what our JavaScript la YouTube checklist feel like okay does anybody have questions I'm sorry on which side give me a better picture so I can find oh yeah oh great great thank you very much