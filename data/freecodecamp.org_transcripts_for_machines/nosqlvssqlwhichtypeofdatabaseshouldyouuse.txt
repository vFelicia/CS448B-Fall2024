hello everyone here on the free codecamp channel today my name is anu kubo and i'm a software developer as well as course creator online in this online course i'll be talking to you about the differences between the terms sql and nosql when it comes to databases as well as which kind of database you use when and why in this course we are going to go back to basics and look at what exactly a database is and how it's defined we're then going to look at database design and why it's important what a database management system is we'll then look at relational databases followed by an sql crash course we will then move on to look at nonrelational databases followed by sql vs nosql as well as the pros and cons of using relational databases versus nonrelational ones we will finish off with some use cases and then a nosql crash course and don't worry you'll leave this course with a much better idea of when to use what database technology before we dive into the types of databases that exist let's talk about why they matter to your career as a developer data is an important part of it without data computers and even the internet would be a pretty uninteresting place if you are aiming to become an application or full site developer databases are your friend the market today pretty much expects fluency with a relational model but there is an upside here according to stackoverflow's recent surveys nosql skills can really help differentiate you from the pack for example in their 2021 survey the top four top paying database salaries were all nosql databases dynamodb elasticsearch cassandra and redis so go grab a hot beverage roll up your sleeves and let's get started if you think the ranger choices are a little overwhelming now just wait until you get into the universe of javascript programming so what are we waiting for let's get to it by the way this course is brought to you by data stacks if you'd like to follow along with code examples you can sign up for the data such as db free plan and a few clicks if you want a deep dive into relational and nonrelational databases after the course check out the intro to sql course and the introduction to nosql course right here on the free codecamp channel now let's start with taking a moment to go back to basics and talk through what exactly a database is a database is a systematic collection of data in the world of computing this collection of data can be accessed electronically you can access it electronically to get data add data delete data or update data small databases can usually be stored on a file system on a simple storage device this can be something like a sd card a hard drive or a usb larger databases on the other hand while in the past on mainframes or beefy individual servers are usually hosted today on computer clusters or cloud storage a file system is essentially something that lives on a storage device such as a hard drive it defines how files are named stored and retrieved for example imagine you are using your laptop which is a mac and you plug in your storage device or hard drive which contains data into your mac in order to retrieve a file that you put on it now without any kind of file system implemented your max operating system won't be able to find the data that you are looking for it would all be a big mess essentially file systems bring in order this is the same for computer clusters on which large databases are usually hosted on now so far we have looked at the example of one hard drive but what if you have way more data than we can fit on this tiny little hard drive what if you need 10 hard drives what if you need 10 computers or more this is what a computer cluster is you are essentially linking a bunch of computers together across a network to work as one a cluster can be viewed as a single system or in other words one computer clusters can be grouped together under one control plane which is what manages connecting all the computers together and the outside communications fun fact the first computer database was sabre the airline reservation system the process for reservations outgrew the paper card system they used and ibm came up with a new solution in the 1960s to help scale up operations at american airlines so that is how we can store our databases so on a file system for small databases and things such as computer clusters for large databases but what about databases themselves how are they organized this is all down to database design there are many ways a database can be designed heck you could even design your own database if you really wish all you'd need to do is decide on a database model a database model will determine exactly how you want your data to look and not only that but how you want it to interact with other data for example you may have a database model that follows the idea of a table this will mean that all your data has to fit in the structure now if i'm collecting data on how well each student did as a specific subject in terms of grades then a table would be great however what if i also then decide i want to add how much the student enjoyed the subject then this table would not work we would have to redesign our database and perhaps use a different database model perhaps a document model would work better this is why database design is so important and has to be thought of early on in any project here are just some examples of database models as you can see there's a lot we will go into the most popular ones like the relational model document model white column and key value model and how they define the modern database landscape first off though let's talk about how developers interact with these databases a database management system or dbms is a way for us to essentially communicate with our database think of it as a layer or interface between the data and our little fingers on the keyboard it allows us to get existing data create new data update data and delete data from our database we have our data in our database here then we have the dbms and then we have the end user great any given database management system may provide one or more models we'll talk about the multimodal databases briefly at the end and for this tutorial we are going to use a cloud database since they all usually provide a free plan or tier and it's much faster than downloading installing and configuring it then we can just focus on the code and core concepts i use astrodb a lot so i'll be using it since it allows me to create different types of nosql databases in one place then i'm not switching platforms all the time during the course however you don't have to use it there are plenty of other database management systems out there some only deal with one type and some are multimodal which we'll talk about again later on here is a list of some popular dbms you will come across as a developer now i'm going to show you what a typical cloud database experience is like these days to get started with astrodb sign up for free just go ahead and do the process of that by clicking on the sign up to try astra for free button once here i want you to sign up i'm going to go ahead and sign in as i've already created an account for this wonderful here is the dashboard we are on the free current plan which is more than enough for research and development work without being prompted for a credit card so what we're going to have to do is create our first database just go ahead and click the button and it will take you to this page once on here let's name our database something i'm going to call this tutorial as it is for tutorial purposes and the schema name or as apache cassandra calls them key spaces now we're going to create a few key spaces the first one we create is going to be called wide column as it's going to be for creating a wide column database let's go ahead and do that now we're going to select a provider and region again i'm just going to choose the one closest to me so this will be mumbai india and let's go ahead and click create next you'll see this page show up in which we're going to be given all our tokens and necessary things to communicate with our database so here's what it looks like just copy all of this and make sure to keep it somewhere safe for the upcoming tutorial and go ahead and click on the go to database button great at the moment this is pending we are going to have to wait for this to be active before we can use it but as soon as it's active you will see the status change to active so great we know this is active because we can see options such as connect cql and more in the tabs above and we have our first key space which is white column under the word key spaces below we could also add more schema or key spaces as they are called in cassandra which we will be doing later see much easier than downloading installing and configuring it just so you can play with some code most cloud databases are pretty similar in how to create a database so you can start coding straight away wonderful let's move on now that we know how to get set up with our dbms let's get into talking about the different types of databases we could have the first thing we are going to look at is the relational database we are going to do this in order to understand the differences between sql and nosql but to get to that point we still have a little bit of knowledge to cover and what better place to start than looking at the most familiar and most strongly consistent database in my eyes which is the relational database as we now know databases depend on their design and what type of models they use relational databases provide a store of related data tables these tables have a fixed schema use sql or the structure query language to manage data and support asset guarantees in general rdbms assumes you can structure your data and trades off the strongest consistency guarantees and ease of use for ensuring consistency with scalability volume and availability there is a great deep dive on how to design a relational database right here on youtube if you want to learn more popular open source examples here are mysql postgres and mariadb the relational database uses that relational model and looks something like this kind of a table with columns and rows are linked together if we wish usually each table has some kind of theme going on or in other words entity type just like we saw with the grades for our students before in that instance each row has a student and each column was a class topic in relational databases each row has a unique identifier so we can pick it out thanks to this unique identifier we can now also link these rows or students to other tables such as this one which each student's enjoyment level of topic we can even take this one step further to really clean up and take out the names of the students and put them in a third table now all the data we want to be linked is linked thanks to the id number these links are called foreign keys and relational design sounds simple right now i'm going to show you how to create your own using sql for creating clearing and maintaining databases i'm going to be showing you how to do this with some slides sql or the structured query language is a language that became prominent in the late 1970s for managing data and relational database management systems it's worth noting that while ansi sql does indeed define a standard syntax each rdbms has some subtle platform specific considerations some of them in the syntax of the code outside the standard anci sql specifications and some in how the sql query execution engine functions at runtime many also have wholly proprietary extensions for more advanced features now let's see what creating a schema and table in an sql database is like let's try a simple example together here is what the syntax for sql looks like for example to create a student table of grades we would use a statement this statement is create table after this statement we then define what we want to choose to call our table i'm going to choose to call it student grades next we define our columns on this occasion we will define column 1 as the id column 2 as the name column 3 as the subject math column 4 as the subject art and column 5 as the subject geography we also need to find the type that goes into each column for example we can have varchar integer date and much more we are going to define our id column as taking integers our name column as varchar so it takes characters or text and for the other columns we are going to put varchar as well as we want to put 8 out of 10. if you'd like to just put in an 8 however you could choose to use integers instead we can also define a primary key the primary key constraint uniquely identifies each record in a table in this example we will want our id to be that unique identifier primary keys must contain unique values and cannot contain null values finally we put in the semicolon and the statement and press enter great now that we have defined our table let's get to putting data into the table that we have just made to put in data into our table we use two statements insert into and values the full statement would look like this we would use the command insert into and then we will use whatever we decide to call our table in this case it was student grades and then we will rewrite the column names that we want to put data into i'm just going to put in all of them on the next line i'm going to use the values command to insert data into those columns and of course we need a semicolon to end this statement inserted one line into our database but how do we actually look at our database well for this there's a very simple command we use the command select followed by a star which means all from our table called student grades okay so great now let's test it out for this i'm going to use the sql playground on w3schools and all i'm going to do is literally paste in the commands that we wrote before so we need to create a table first so here we are creating a table called student grades with an id name math art and geography column as well as defining our primary key and hitting run sql okay so that has now been added to our database the next thing we need to do is add in our line so add in some data so i'm going to delete this and just use this command so this is going to insert into student grade it's going to insert the id the name of the student the math the art and geography scores so let's run that as you can see changes have been made to the database run row has been affected and now to get the data well we use select all from and whatever we called the table which is student grades and you will see our table with the id the name the score the student got for maths art and geography wonderful so that was a quick crash course about making relational databases using sql let's continue now this is not an sql tutorial i'm simply giving you a very quick crash course and how to use it for the purpose of this tutorial sql has a lot to offer and is a very well thought out language that takes a while to learn if you would like to deep dive into the topic after this course then please do check out some tutorials on this that we have on free coca so we now have a good idea about what a relational database looks like and how we can manage data in it using sql the structured query language but there are also such things as nonrelational databases and there are a few of them we are not going to look at all of them we're simply going to look at the three most popular ones so we are going to look at the wide column database type the document database type that uses the document model and the key value database type which you guessed it uses the key value model all of these nonrelational databases are commonly referred to as nosql databases and whilst you might be thinking ah so they do not use sql the structure query language that we just learnt you would be totally wrong nosql means not only structured query language which allows you to use the language or not use it to get the data and it's considered to be an approach to database management nosql's appearance on the scene is noted as somewhere around the 2000s so if we compare this on a table you will see here that under sql i put an icon to represent a relational database as we can use sql to query relational databases we now know that we can also use sql to query some nonrelational databases or at least the ones that offer relational as a secondary database model and a sql interface anyway nosql uses different query languages for key value document and tabular or white column and so on now when people look at nosql and sql they might be tempted to compare the two but by now we know we can't do this why this is because sql is a database management approach and sql is a query language so two completely different things it might be better going forward to start referring to nosql databases as nonrelational databases so let's go ahead and switch that so we can compare them to relational databases from now on okay great so now that we have that down let's look at the pros and cons of each first off let's look at standardized schema when working with relational databases you can have the benefit of schema being standardized for example imagine i'm working at a pizza restaurant as a chef and each waiter instead of showing people menus for people to pick from started just asking them what kind of pizza they want you would have a huge range of pizzas to make and this would add some level of difficulty to your job in this scenario the menu is built using a pizza schema it comes with a list of wellknown pizzas that people can pick and you can make it's the same with data and relational databases by providing a schema that everyone's familiar with and used to using it makes working with relational databases worldwide a whole lot easier now some people might find this rigidity a con but in general it's viewed upon favorably next up let's look at large user communities another pro we have is that relational query languages such as sql have a larger user community as sql has been around for nearly 50 years it has a strong community of supporters as well as a lot of help and resources out there for learning purposes next up is standardized query language another pro for relational query languages such as sql is that it's considered to be quite an easy language to learn as it uses simple keywords we use these keywords in managing and searching through databases anyone that's worked with spreadsheets can relate to this model as it's often covered in university courses next up we have acid the final pro we have for relational databases is that they tend to be acid compliant which stands for atomicity consistency isolation and durability you will see this acronym pop up a lot this level of compliance keeps tables in sync and guarantees the validity of transactions now let's look at the cons of relational databases first up is difficulty clustering the main cons of traditional databases are that they tend to scale up vertically what this means is that the only way to scale your database is to increase your ram cpu or ssd on your existing server or to migrate to a larger more expensive one altogether you'll need to continually increase hard drive space as your data grows and you'll need faster machines to run evolving and more sophisticated technologies the database vendor you'll use will likely require you to periodically level up your hardware just to run their latest releases in this environment hardware can quickly become outdated each upgrade is expensive and resource intensive most relational database hardware also needs ongoing everyday maintenance next up is data normalization developed at a time when the cost of data storage was high relational databases such as sql ones attempted to negate the data duplication each table has different information and they can be connected and queried using common values however as these databases get large the lookups and joins required between numerous tables can slow things down and be too complex to code and debug next up is schema first sql relational database schemas must be defined before use once in place they are inflexible and modifications are typically difficult and have a wide blast radius affecting both data and application nonrelational databases vary in this respect for example document databases do not require schema up front while they say wide column does for that reason substantial time needs to be invested in upfront planning before the database is ever put into production so it follows that they're only appropriate when all your data is also structured and you don't expect much change either in volume or data type next up is resource intensive scaling as mentioned earlier relational databases normally scale vertically by assigning more resources to the existing hardware investment this can be expensive and time consuming newer relational databases or cloud services aka new sql can horizontally scale a relational sql database through partitioning or sharding make sure to understand how the addition of partitioning or sharding for rdbms affects acid consistency guarantees as it can be different from noncluster deployments remember that all rdbms or relational database management systems are subject to the limitations of cap theorem the moment a network link is introduced now that we have covered the pros and cons of a relational databases let's look at the pros and cons of nonrelational databases first up is continuous availability with nonrelational databases data is distributed across multiple servers and regions so there is no single point of failure as a result nonrelational databases are designed to be more stable and resilient with continuous availability and zero downtime particularly with cloud deployments next up is query speed nonrelational databases are denormalized without worry or data duplication for example in white column databases the information needed for a particular query will often be stored together no joins required this makes lookups easier especially when working with large data volumes it also means nonrelational databases can be very fast for primary key or indexed queries for data without an index however query speed can taper off as nonrelational databases reach high levels of scale without the right data model next up is agility nonrelational databases were developed as large data storage costs were beginning to drastically drop and systems were being distributed and or deployed on the cloud data duplication was no longer a concern nonrelational schema are generally designed to give the developers more control over database integrity and schema as well as tradeoffs between consistency availability and performance there are a variety of different nonrelational approaches acidcompliant databases hide the complexity of a very costly operation and give you no other choices with the approach to trading of consistency for performance also there are times where all those guarantees of the relational models simply aren't truly needed most developers have been conditioned to reach for the high data integrity relational model without challenging themselves to think deeply about where those guarantees are truly needed however understanding the data model now and in the future is arguably the most important thing so future business requirements continue to align with the strengths of the approach you've chosen agility comes in other forms as well for example document databases don't have to have predefined schemas instead they are dynamic with the ability to handle all types of data including structured semistructured unstructured and polymorphic data you can skip upfront database schema definitions and get right to development developers can redefine json document structure anytime and easily add data types and fields at runtime without requiring a schema change all of this makes the nosql approach a great fit for modern agile development teams the flexibility and adaptive nature of nonrelational databases makes them a great fit for organizations that have a variety of data types and expect to continuously add new features and functionality nonrelational databases are not one size fits all unlike the relational databases they aren't constrained to a single normalized data model a single approach to consistency or single approach indexing in their quest for scalability and availability at scale next up we have low cost nonrelational databases scale out horizontally making it cost effective to expand capacity rather than upgrading expensive hardware they can cheaply expand by simply adding commodity service or cloud instances open source nonrelational databases provide affordable options for many organizations they are a good fit for cloud computing and handle extremely large and quickly growing data sets now let's move on to the cons next up is no standardized query language there isn't a standard language to conduct no sql queries some like key value databases are so simple they don't need one other nosql systems even provide direct support for ncsql the syntax used to query data varies for the different types of nonrelational databases but unlike relational databases where there is just one easy to learn language to master nosql has a steeper learning curve sure each relational sql execution engine does certain things a little differently has proprietary extensions and so on but at least syntactically they all have the ansi sql standard syntax in common for example it might be difficult for a developer to quickly get up to speed working on a wide column database if all their prior experience for example consists of building and managing graph databases however there is an emerging trend to start exposing databases as de facto or popular apis it's a helpful alternative for many developers who are able to trade off some level of performance for developer productivity using database api gateways saves on you hard coding what would have otherwise been boilerplate data access code also using apis like rest craftql json grpc may already be familiar to many app developers overcoming some concerns here about standardization next up we have the smaller user community developers have been using nonrelational databases or nosql databases for more than a decade and the community is growing quickly however it's still less mature than the sql community so it could be harder to solve undocumented issues there are also fewer consultants and experts on the nosql side next up let's look at developer skills required flexibility comes with a price with a variety of approaches found in nonrelational databases there's more to learn this as we know is unlike learning how to use sql which is relatively simple even the simplest of nosql queries will still likely require programming experience or possibly to learn an api this means more technical and costly staff like developers or data scientists we need to perform the queries next up is data retrieval and consistency the distributed nature of nonrelational databases enable data to be available faster however it can also make it more difficult to ensure the data is always consistent queries might not always return updated data and is possible to receive unaccurate information with its distributed approach the database could return different values at the same time depending on which server happens to be queried this is one of the reasons some nonrelational databases don't achieve acid level compliance consistency is the c in acid which states that the data must be valid and consistent at the start and end of a transaction instead most nonrelational databases adhere to base consistency models whether e stands for eventual consistency in other words the data will be consistent at some point later on different nonrelational databases vary in their approaches to consistency and transactions so it's difficult to generalize in the real world this is often a very small delay only of a few milliseconds so for many applications that likely won't matter for example social media posts going live or an online shopping cart being updated that won't really matter too much in those situations lower latency and high availability outweighs the value of providing the exact same data at the exact times uses however think of when you make an online stock purchase then it would really matter nonrelational databases value speed and availability over consistency compared to relational databases each project must decide if that aligns with their goals now that we have covered that it's time for a quick crash course and learning about some nonrelational databases for a full tutorial on nosql check out the intro to nosql right here on freecodecamp our quick crash course will include looking at the document database type the key value database type and the wide column database type so let's do it the first one we're going to look at is the wide column database type now as astrodb is built on apache cassandra we're actually going to be using cql or the cassandra query language to demonstrate some of the different approaches to nosql the cql query language is a subset of sql so the basic commands we're using here in this video are exactly the same okay so just so we understand we are going to be using cql the query language which is very similar to sql however we're going to be using to create a nonrelational database and on this occasion the nonrelational database we will be using is a wide column database okay sounds confusing don't worry we're going to go into this in a lot more detail coming up when approaching your databases choices in general it's helpful to understand the models for the concepts behind them that you like to use as points of comparison carnage melon's database of databases provides an excellent much comprehensive technical resource in this regard but pragmatically here's a few important aspects for comparing dbms in the spectrum of nonrelational databases wide column aka column family is sort of in the middle of a spectrum with relational databases on one side and key value on the other on one side you have rdbms or relational database management system and acid dbms with lots of builtin features and performance overhead to the much more simplistic less feature rich but way faster dbms like key value popular open source options here include apache cassandra apache hbase and many others they are often used for operational app database tasks like scaling time series data ecommerce or inventory management content management personalization recommendations fraud detection transaction logging tracking and many other rightintensive infrequent update use cases wide column stores like apache cassandra use the notion of column families a database object that contains multiple columns of related data that are used together similar to traditional relational database management tables within a given column family all data is stored in a row by row fashion such as the columns for a given row are stored together rather than each column being stored separately put another way a column family is the key value pair where the key is mapped to a value that is a set of columns in analogy with the relational databases a column family is a table each key value pair being a row for developers y column tables can present themselves as a row and column table that is familiar and easy to work with in code or apis understanding how the primary key in y column database is different from relational primary keys is essential followed by proficiency in data modeling to learn more about both of these i recommend this course in apache cassandra as an example so using apache cassandra as an example the two biggest differences between y column databases and relational databases are why column has partition and clustering keys relational uses foreign keys recently white column databases are evolving allowing the ability to provide relational style secondary indexes for columns outside and even full asset transactions so the spectrum we just spoke about is changing over time learn more about these secondary indices right here on youtube in the link showing up so to look at this encode cql or cassandra query language is a subset of ansi sql to compare them this is cql select syntax using ebnf notation it is a subset of sql sql also supports binary operators such as inner outer joins union accept intersect nested subqueries and clause having in addition cql restricts what columns can be used in different clauses this is the cql create table syntax using eb and f notation we can learn some more sql basics right here on youtube following the link popping up okay so here we go let's create some tables that store data so in order to do this i'm just going to click the cql tab up here which will bring up our cql console wonderful now just to check this works i'm just going to write show host and that should show us our hosts and next if you want to check the version i'm just going to type the commands show version and then follow with a semicolon to finish off this statement and hit enter now any version will support what we've shown here in the tutorial since we're just showing straightforward basic syntax new commands may be available in newer versions so it might be worth checking what version of cql you are using now the first thing i want to do is just list out all the key spaces that we have in this database so to do this i'm going to use the d e s c command for describe key spaces and just hit semicolon again and that will run that statement and it will bring up all the key spaces that we have in our database so as you can see the wide column key space that we made earlier is here this is the one that we want to use for this part of the tutorial so we need to go into this key space now we can do so using another command which is the use command followed by the key space name which in this case is wide column follow it off with a semicolon to finish this statement and hit enter so as you will see we are now in the wide column key space great so once again this is the key space we made previously and that's what we are in now now once here it's time for us to start you guessed it creating some data creating a table to put in this key space so to do this you guessed it we're going to use the create table command as we saw previously as part of the sql tutorial but we're also going to put if not exists so if that table does not exist i want to create a table and what should we call our table well i'm going to call it pizzas so that is what i have chosen to call my table next up we need to actually define the columns and data types that make up our tables so let's get up our parenthesis and i'm just going to hit enter to start this on a new line so it's more readable and our first column well let's go ahead and call that something i'm going to call it pizza id as this is going to store the pizza id of my pizza and the data type for this i'm going to choose use the data type uuid which is a data type that comes with cql great and next the other column is for the brand of pizza that we're going to have so once again let's call our column something which in this case is going to be brand and i'm going to define the data type to be text so in cql we can just write the word text like so to say that anything in this column must only be text great on to the next column the next column well i just want to store the actual name of the pizza so let's go ahead and call our column name and once again the data set for this is just going to be some text so let's go ahead and define that next up i'm going to show you how to work with an array of things so for this we're going to have an ingredients column let's go ahead and call that ingredients and then if i want to say that i want to only take texts but multiple texts i am going to use the set keyword to do this so we're going to use set and then using these brackets i'm going to put in some text so what i am saying is that the ingredients column will only take an array of texts great so that's another data type that we have just learnt and next well we are actually going to want to define how we search for rows in our pizzas table and i'm going to say that we are going to be able to search for the pizzas by their pizza id and to do this we need a primary key so i'm going to use the primary key command and just pass through the pizza id into parenthesis to make sure that our table knows that this is the value we can search our tables by that will bring back the whole row great and of course finish off the statement with a semicolon and just hit enter so wonderful we have just defined our pizzas table let's just check that has worked so i'm going to use the desc command followed by the key space command and then the key space we want to describe and then we just finish this off and wonderful so there we can see how we have defined our table that is working the next thing i want to do is of course stop putting stuff into the table so let's carry on now to start putting stuff into the table we're going to have to use the command insert into so let's go ahead and use the insert into command and of course we want to insert something into the pizzas table so let's get that up and actually we are going to have to tell this console exactly which columns that we want to put stuff into so i'm just going to pick all of them i'm going to pick the pizza id column the brand column the name column and of course the ingredients column and not finish this off yet i'm just going to create a new line so it's more readable we are next going to use the values keyword in order to insert values into those columns now we can of course write our own unique identifier or we can use a function so i'm going to use a function for this and it will randomly generate a uuid for us so i'm just going to use the function uuid and call it next up well we know that the brand column only takes strings or text so i'm just going to go ahead and put in the string of etzkis as the brand the name is going to be a pineapple pizza so once again we need to specify this as a string as we have said that this column takes text and next up we need the ingredients so to put in the ingredients i'm just going to get up some curly braces this time and make sure that everything we put in here is separated by commas and as text so once again we need to make sure that they are strings so i've just put in pineapple cheese and ham and now we can finish off this statement great now let's check if that has worked to check if this has worked i'm going to use another command yet another command and this time it is select so i'm going to select all this star means all i'm going to select all from the table that we called pizzas and then you guessed it finish this off with a semicolon and that will bring up our table with the data as you will see a unique identifier has been generated for us it's in green this is also the primary key okay as we did specify that when we were describing our table and of course we've got the brand we've got the ingredients and we have the pizza name wonderful shall we put in something else into our table i think we should so to do this i'm actually just going to press the up button this will bring up the last commands that we wrote and i'm just going to get the insert into command up and all i'm going to do is just switch out some of the values so we are going to switch out the brand of the pizza and i'm going to switch that out to be pizza hut again making sure that that is a string of course we can leave the uuid function as it was that will generate a new unique identifier for us the next thing we need to do is change the pizza name so i'm going to change this to be barbecue pizza just like so and on the ingredients i'm just going to switch these up too so we can have a few different while keeping maybe one the same so beef and barbecue sauce great so let's check that has worked once again i'm just going to press the up command to select all from pizzas and tada we can now see two we can see two pizzas in our table this is looking wonderful now before moving on i just want to put one last row in so just bear with me once again i'm just going to press the up button so that we can get up the command that inserts into the table pizzas and once again i'm going to keep the uuid function there so it can generate a new unique identifier for us i'm going to change the brand name of the pizza to make it another notable pizza brand this time is ristorante i'm also going to change the name of the pizza this time to be a broccoli pizza for all of you broccoli fans out there and of course in the ingredients we are gonna have to put some broccoli in there we're also gonna put some mozzarella and let's also put some corn okay so lovely pizza make sure that is all strings and hit enter so now if we get the select all from pizza's command we will see three pieces in there wonderful that's a lot more for us to work with let's move on now i can write a command that will select a certain pizza from the table based on the id and to do this we are going to use these select all from pizzas commands so select all from pizzas but we're not going to use the semicolon we're not going to finish this off quite yet let's make a new line i'm going to use the where command so where is another command where the pizza id so we're getting the column name equals the id of well if we want this pizza right here the pineapple pizza to come back to us so the whole row to come back to us i would just simply grab the unique identifier and hit enter after the semicolon and that will bring back just the pineapple pizza in our table okay so if you ever need to just get one row from your table that is how to do it using the where command just like we did previously great okay so that was a quick crash course in cql please do not be fooled as i said there are so many other commands you can do you can become really complex with these commands here just a few to your disposal we are not going to go into this as i said at the beginning of this tutorial this is just a basic overview so you get the idea between writing relational databases with sql and making a wide column nonrelational database with cqr there are plenty of courses on both of these languages on free codecamp so if you want to take things a step further please refer back to the beginning of this course for the video you need to watch now the next nonrelational database type we're going to look at is the document database type document databases are popular with mobile apps content management games some iot scenarios anywhere where you aren't quite sure how your data is going to be structured they don't require joins as they use hierarchal collections of denormalized data where fields can be indexed popular open source options here are things like mongodb couch base and couchdb so wait i don't have to decide how my data is gonna be structured that sounds great so why wouldn't i use that all the time for everything well ideally data should be as structured as it can be you'll pay a price down the road when you want to join it troubleshoot data type conversion errors and so on more strongly type data and data modeling better defines your app to database interactions which lower overall cost for example data modeling consumes a fraction of the overall developer time in a project and can have a large impact on code quality data modeling catches errors and oversights early when they are easy to fix this is better than fixing errors once the software has been written or worse yet is in customer hands however document or document orientated database types are arguably the easiest types to deal with from the perspective of development because they require no schema in contrast to models like relational and white column that requires schema before they can be used by an application developer before in the table we made so in other words the wide column database we had to define the column that made up our table as part of that upfront schema definition process with document databases we don't have to do any of that as long as our data comes as an object it's fine the objects are made up of keys and values and look like this this is an example of perhaps an item you might find on a todo list the values can be strings numbers booleans arrays or even objects themselves this is called json or javascript object notation and is the most popular format for document database types now a group of documents is called a collection we will not be using the word tables anymore it has now been replaced by collections keep that in mind moving forward now what are we waiting for let's get to it in this next section i'm going to make a collection of pizzas using the document api but why not a query language well using api like rest graphql or json may already be familiar to many app developers so it reduces some of the learning curve now for those of you who haven't heard of the term api let's do a quick crash course an api stands for application programming interface they allow developers to enable technologies to essentially talk with each other and are essential to so many automated services that we rely on today they are behind most apps that we use on a daytoday basis and can shape the information passed between one technology to another they can even connect things such as our cars fridges or pens to the internet apis are everywhere as a developer you might use the twitter api to get live tweets on your site a map api that will allow us to get data from a third party to use in our new delivery app we are building or even use them in a twoway stream to get post or delete data from a customer relationship management system for example there's a reason why these words are popping up and let's go into why in this next section you are going to be seeing these words and using them to communicate with the database you make in this context they are called http request methods the most common are the get request post requests put requests and delete request there are others too but for the sake of the tutorial these are the ones you need to know get essentially gets data and that's it so imagine you have a client or in other words your computer and a server you are on your computer and the url which is where you want to get your data from is on a server the client so once again your computer sends an http get request to the server to retrieve the data we want so here we have a get request or a visualization of a get request the client is requesting that the server gives it the necessary resources that we need then after the server has sent the response so request and response we say that we've got it thank you after the server sends the response it closes something called a tcp or transmission control protocol connection we also have post requests and put requests so here we have a visualization of how the requests would work with post requests so simply sending something to the server and with put requests which are the same we are sending something to the server but essentially with the put request we are sending something to edit something that already exists or in other words overwrite it and of course we also have the delete request which will delete an existing piece of data on the server so to get interacting with our data you will see these different endpoints simply put an endpoint is where a resource lives so with this point here forward slash burgers i could get all my burgers i can also create a new burger and add it to my existing burgers with this endpoint right here forward slash burgers making sure it's a post request to create a new one i can also edit a singular burger i would do so by defining the id of that particular burger in an end point that i have chosen and make sure that this is a put http request and finally the same for delete i would identify the individual data by writing a url that also has the identifier in it and make sure this is a delete http request okay so now that we've got that let's get to actually using this information in practice with a tutorial so once again on the data sags astro dashboard where we can see our key spaces in the tutorial database well we're going to have to create a new key space so let's go ahead and click on the add key space button to the right and then that should bring up a panel in which we can name our new key space so i'm going to name this document so that can show you how to work with document types okay so great if we refresh this it should show up right here under the previous key space that we used now to connect to this well i'm just gonna go to the connect tab and then i'm gonna choose the document api to connect to our key space okay and to do this we actually have some swagger ui to make our life a lot easier and to launch it we just have to click on this url right here okay so this will launch these swagger docs for us and this is super helpful in letting us know what kind of commands we need to write in order to add data get data delete data or edit data okay just by simply filling out some inputs okay so for example if we want to create a collection so in the previous tutorial we essentially made tables this time instead of tables we're going to work with collections okay so replace table in your mind with a collection and let's try it out so there has been a default token given for us however if you want to use your own so the one that you saved at the beginning of this tutorial or if you've lost that and want to try another one you can actually generate a new one so if you go back here and create a new token we're simply going to select a role i'm going to just do admin and generate a token so now we can use the default one or we can use this one so i'm going to copy that and then back in here delete this and just use the one we generated you are free however to just keep the default if you wish so the first input that we can put in is the namespace or in other words key space that we want to put our collection in and we know that this is the nosql document type key space that we have just made so in the docs this is called namespace but for us in data stacks asteroids called the key space this is just a naming difference so keep that in mind and by filling in these two inputs we are now able to write a body that will allow us to name the collection so to do this we need a name as a string as the property and the value is going to be the actual name of the collection which again i'm just going to choose to call pizzas and then once we have that i'm going to click execute great so that has worked we get a 201 response and if we want to do this outside the swagger ui a request url has been generated for us based on the inputs that we used okay great wonderful so we've created our collection the next thing we need to do is add a document to this collection so once again let's select the correct endpoint so this is going to be a post request to the collection that we just created by the collection id and let's try this out so we can populate the inputs to generate a url for us so once again let's just paste in the cassandra token the namespace of the collection that we want to work in is called document and the collection id where we hold our collection pizzas so let's just put that in here and now we can create our document okay so let's go ahead and create our first document i'm going to make this have a key of name and a value of pineapple pizza as a string okay so there we go we're kind of working with the same days that we did before but i'm going to show you why this way of working is different the previous way of working in cql in a bit so let's go ahead and have the brand as well so the brand of this is going to be pizza hut okay so just like so making sure to make all of these strings and make sure to put all the commas in the correct places too we are also gonna have a pizza id so once again a pizza id and this time i'm just gonna put some random numbers as the pizza id just like so so just put in some random numbers too for this tutorial next we're going to have an ingredients key so once again let's get up the word ingredients as a string and this time i'm going to make an array also of text so i'm just going to put in some text however you will note we are not defining that this has to be text anywhere we are not writing a schema okay we're simply putting in a document so now after i put in some things into my ingredients so i'm going to put pineapple cheese and ham and just go ahead and click execute you will see that has worked okay we got a 201 code the response body has generated the document id for this json document okay in case we ever need it and the request url has been generated for us based on the inputs that we put in great wonderful okay so now if i want to bring back all the documents in our pizza collection i would get the get request that will search for documents in a collection let's once again try this out so i'm just going to click on the try it out button populate these inputs so we know that the cassandra token goes here the namespace id well we're working in the nosql document type namespace or keyspace and the collection is called pizzas now if i click execute this will bring back the document that we put in this collection at the moment there is just one document that is the document id that got generated when we successfully put in this document into the collection this is all under data okay but right now we only have one document in here great okay so now why this is different to cql well i'm going to show you now let's go ahead and go back and create a new document so here is the previous pizza that we put in or in other words the json document that we put in now because we haven't defined a schema as in we haven't said what kind of key let's go in here into my object so this time let's just get rid of everything in here okay and start from scratch and this time i'm literally just gonna have one key value pair okay so i'm just gonna have the name of a pizza right because once again we have not defined how many key party pairs have to go in the documents that go into our pizzas collection we literally didn't do any of that we can put anything in our pizzas collection so if i just simply put this and click execute okay so that has worked a document id has been generated for me and now if i go back to getting all the documents in the pieces collection so once again just go back here making sure to use the get request and click execute you will see that's worked now we have two document ids two documents in here okay but two different structures to each one so hopefully you can see why this can be problematic for example if i was to be making a pizza app and decided to perhaps map the brand names onto something the cauliflower pizza would be missing the brand name okay so that is just something to look out for when working with the document type now not only does this apply to you know the keys but also the data types you can put any data type under here because once again we have not specified anything we don't have any schema and of course we can also add new key value pairs so for example i'm just going to do this one more time i'm going to create another new document so let's get our post request to do this to the collection of pizzas and i can just go ahead and add a new key value pair this time i'm going to choose calories so calories is the key as a string and then the value is just going to be 200 okay so not a string and if we click execute you will see that has worked and then if we go back and get all the documents in our pieces collection so once again i'm just going to run execute you will see three completely different document types there is no real sense or logic to this we're just simply chucking stuff in there okay now let's look at one of the other often used nonrelational databases the key value store key value databases are one of the simplest types of nonrelational database popular examples are things like memcache redis or etcd there is no query language native to this model to learn it's highly similar to language level data structure so the key value databases don't need them key value databases are most often used as caches but that's not all they're good for a creative use case fit here can when new valuable performance gains over relational models so let's look at key value databases they look like this you have a key column and then you have a value column you can actually have as many value columns as you wish the most important thing here is that we can retrieve data back to us so an entire row by the key and that is the identifier in this case let's have a quick look at an example rather than switching database platforms we can use a key value trick and implement the key value pattern which is highly similar across databases so let's see how to apply the key value pattern using a graphql api but implemented on a wide column database for example back here on our astra db interface all i'm going to do is create a new key space that we can work in once again i'm just going to click on the add key space button what should we call this key space well let's keep an eye on the previous one so no sql key value type please go ahead and call this whatever you wish this is what i'm choosing to call mine and i'm just going to confirm that great now once that has finished creating itself i'm just going to refresh this page in order for it to show up we can now connect to it this time i'm going to choose to connect our key space using the graphql api just because in the previous section we did it using the document api i'm going to show you how to do it using the graphql api this time in order to start adding a table to our key space i'm going to have to write a mutation using graphql to make our lives easier i'm just going to go ahead and open up the playground which will help us do all of this just go ahead and click on this link right here in order to open up the playground now this playground will essentially help us write our queries and mutations thanks to the documentation provided that auto generates based on what we put in the key space to access this we're of course going to have to put in our cassandra token now we can use the one that has been auto generated for us or if you wish you can replace it with the one that you saved so go ahead and do that or just choose to leave the one that's there as default the choice is up to you then once we have done that we should be able to check out the docs just go ahead and click on the green tab and that will bring up all the documentation that is to our disposal in order to help us write our queries and mutations great the first thing we're going to do is you guessed it create a table this is the mutation we need it is a mutation hence it's on the mutations tab and we're going to use the mutation create table just go ahead and write that on the left in the playground now if we click on the create table mutation in the documentation it will tell us what we can put into our create table mutation in order to create the table the first thing we are going to have to do is this is required because we see a bang here we're going to have to put in the key space name let's go ahead and do that i'm just going to put the key space in the here in parenthesis the key space that we want to work with is of course the key value key space that we created go ahead and put that in there as a string the next thing we need to do here is put in the table name this is also required as you can see here by the bang so go ahead and put that table name in here again as a string we're going to choose to call it pizzas just to be consistent with everything we've been doing so far next what is also required is that we have a partition key this functions as a key in the key value pattern we're implementing here so once again let's write partition key according to the documentation this needs to be an array it needs to be an array so let's go ahead and make this an array the array needs to take a name which is required as a string and also a type we're going to have to define the type that goes in here the type well we actually have all these types to our disposal it's essentially a nice cheat sheet for us but we know that we're going to have to use the type basic of uuid because we've done this a few times already a uuid is what we're going to have with the pizza id it is our choice we can of course have any from the list great once we have defined our table so we define exactly what the table is going to be called and what our partition key is going to be once again this will function as our key in the key value scenario we are also going to have to define some of the values that are going to go into our table which of course played the other value role in the key value pattern i'm going to say that our table here is going to have the value of name the name of this is literally going to be the string name and the type of this is just going to be text we are going to say that our pizza table is going to have a name and it's also going to have a brand we're also going to have another value in here this time i'm going to find the string brand and the type of this the brand is also going to be the type of text great let's go ahead and see if that has worked i'm not going to have all the same columns as we had previously because there is a lot to learn i'm just going to show you the most basic form of creating a table using gql or graphql we're just going to run this and we should see create table true we now know that our table has indeed been created this is all looking fantastic great now that we have defined the schema of our table we're going to add data to the table based on the schema in order to do this we actually need to change the endpoint so what i'm going to do is just change this from graphql schema to graphql forward slash and then my keyspace name just go ahead and do that let's get rid of the mutation we wrote here as well now if we look in the docs you'll see the docs have been updated this is a different endpoint and you will see that the queries have changed we will now see the queries to get the pizzas as well as this you will also see the mutations have changed now i have a mutation in order to add a pizza to my pieces table delete a pizza or update a pizza and the bulk insert pizza into my pieces table is also there wonderful go ahead and insert our first pizza for this again i'm going to choose a mutation the mutation we are going to do is insert pizzas and then we are going to have to write this on the left once again we know this is a mutation so let's use the mutation keyword and now let's use the insert pizzas mutation once again i'm going to get up our parenthesis our doctors are actually helping us do this because it is telling us exactly what we need to do which fields or which values are required and which ones aren't and so on of course the pizza id is required so let's go ahead and put in our pizza id i'm just going to put any random unique identifier in here as a string i'm also going to define the name as that is one of the values that we have defined in our schema the name of my pizza is going to be pineapple pizza just go ahead and put that in as a string it must be a string because we defined that it must be a string we're also going to have a brand which again is going to be a string and in this case i'm going to put dominoes just to check this has worked i'm going to return some values in fact i'm going to return all the values i'm going to return the pizza id and i'm also going to return the name and the brand this is just the return values to see if this has worked okay and everything is working fine we could have just returned one of the values if we wish ah we have an error this is because the pizza id needs to be a certain format the uuid does not take a certain format i'm just going to generate a unique identifier online for us just to make sure the format is okay and just copy it and paste it in here like so and click run great we now know this does work because we're getting the values back we're getting the pizza id back we're getting the name back and we're also getting the brand back this is all looking wonderful great we have officially added a pizza to our pizza table we can also update the pizza that we just added in order to do this once again i'm going to write a mutation i'm going to use the mutation keyword we are going to use update pizzas this time and update pizzas well we're going to have to update the pizza we're going to have to search for it by its unique identifier or in other words the key in this key value scenario let's also pass through the other values we want to change in this example i want to change the name i'm going to pass through the name value and then i'm just going to change it to this time to be watermelon pizza i'm just going to put the string of watermelon pizza in here like so if we don't put in any other values that are associated with this pizza i'm just going to show you what happens at the moment i have missed out the brand and let's just return the values of pizza id once again i'm just going to return value and then open up some curly braces and put pizza id in i'm also going to put the name of course and the brand because those two things are the things that make up my pizza if i click the button you will see i've updated the pizza i've searched for the pizza bites id again your key in this key value scenario and i've updated the name to be watermelon pizza but because i didn't add a brand the brand is simply no it's as if you said hey you didn't put a value for the brand so the band is now null great we are also going to have to add the brand back in so i'm just going to go ahead and put the brown back in as a string dominos that's all i'm doing i'm putting the brand in as dominoes great now if we click run again you will see what our pizza looks like wonderful there's one more mutation i want to show you and that is the mutation to delete a pizza to do this once again i'm going to get the mutation so we can look at the dots i'm going to get the mutation keyword and then i'm going to use delete pizzas once again let's get up our parenthesis so we can pass the value and we want this to be the id so the pizza id i'm just going to pass through the pizza idea like so and i'm gonna paste it in so i'm just paste it in the pizza idea that we created previously so it's now called watermelon pizza i'm just gonna return something that we know this has worked on this occasion i'm just gonna return back their pizza id that's all i'm doing so value pizza id now if we press this button we would have deleted the pizza because the value is returning back so we now know this has worked now if i try search for the pizza by that pizza id i'm going to use a query this time because we're going to search for the pizza in our pizzas i'm going to use the query keyword let's go ahead and get up our kylie braces i'm going to use pizzas because that is what we call the table and then i'm going to search for the pizza by a value we're going to have to open up some parentheses again we're going to use value and then we're going to use some kylie braces to search for the pizza id based on the pizza id we want to search for now i'm going to get up my curly braces and just return back some stuff so we know what is coming back to us this time when we search for the pizza by the pizza id in the pizzas table once again at this time i'm just going to put values curly braces and i want to return back the pizza id of the pizza we are searching for the name and the brand just go ahead and do that and click on the play button you will see nothing comes back this is because we've successfully deleted the pizza with the delete pizza mutation from our pizzas table wonderful this is looking good now i'm just going to do one more thing actually i'm just going to add another pizza first i'm going to show you that even though we are adding this data with gql or the graph query language it is in our database and we can actually access it however we want we can even access it with cql once again this is some good repetition for you i'm going to use the mutation keywords and i'm going to use the insert pizzas mutation and open up my parenthesis in order to enter the values that we want to enter for our pizza we're going to have to give it a pizza id which i'm going to generate so let's write pizza id and then i'm just going to generate a uuid for us later we're also going to have to have the name of the pizza we want to insert on this occasion i'm going to say chocolate pizza because why not as a string we're also going to have to have the brand so let's go ahead and put in a chocolate brand so i'm going to put in lint now we're just going to paste in our generated uuid i just made this one up and let's return the values i'm going to return the value of pizza id name and the brand just to check that this pizza has been inserted and everything works if we go ahead and press the play button we will see that it has worked because the values are returning if we now go into our astra db console i want to check that this has worked using my cql console how do we do this well again this is a great refresher to the cql part of this course first off i'm going to use the desc keyword for describing the key spaces that live in our database you will see there is a key space we need so there it is i'm going to use the keyword use in order to go into this key space use and the key space name followed by the semicolons to finish off the statement and hit enter next up i'm going to check that the schema is the same one that we just wrote in the graphql playground to do this i'm going to use the desc keyword for the described keyword again i'm going to describe the key space to see what schema live in it great you will see there it is there is the schema i made we've got the pizza id we've got the brand and we've got the name this is looking good we even know that the piece id is the primary key wonderful now if we select the pizzas table so if we select everything select keyword all the star means all from the pizzas table tada you will see our chocolate pizza that we added using gq app and we've got the whole table using cql back to us so we can view it in the cql console this is looking wonderful so can most nonrelational databases and even relational databases easily be used in a key value pattern sure however database is used in this way with a key value pattern as a secondary model are different from the key value as the primary or only model for example like in memcache or redis a key value primary system is inherently much lighter weight compared to the other models as they have simpler or smaller footprint runtimes compared to the other nonrelational databases this is why they are so often used for lowlatency highperformance cash use cases applying the key value pattern to say a tabular or wide column database could make a lot of sense assuming the extra functionality tabula brings over key value also makes sense for a majority of the application's code base and use case but there will be a limit to the number of levels deep you can nest key value pairs when applying the key value pattern to document databases such as couchdb and mongodb that store entire documents in the form of json objects you can think of these objects as nested key value pairs unlike tabular databases you can nest key value pairs as much as you want json also supports arrays and understands different data types such as strings numbers and boolean values coming back to the true key value databases like memcache or redis they're a great fit for features like leaderboards or simple data structures in an app that need to be in real time ectd for example is a wellknown key value system built for housing for distributed app configuration data as a service in kubernetes making app or api infrastructure another great use case for the key value database multimodel databases are also quite popular and can perform the role of multiple nosql database models against a single integrated backend both relational and nonrelational databases can be multimodal postgres and cassandra stargate provide json document interfaces atop relational and tabularwide columns respectively there are two main approaches to multi model you can use a polygot database architecture or use a multimodel dvms some examples here are oracle db offering document graph and rdf capabilities making it a multimodel dbms similarly nonrelational systems redis key value store extends its application scenarios with downloadable modules into a multimodel dbms and cassandra added a json document interface with stargate some nonrelational dbms will build an inception process different data in different shapes like orango rendb or cosmos tb now let's finish off the course with a summary of when to use relational and or nonrelational dba messes while no sql databases have many advantages they're not the right choice for every situation sometimes sticking with a tried and true sql database is the way to go summing all up here are some good reasons to use or stay with an rdbms or relational database management system if these are true it may not be worth switching instead augment existing apps with nosql so in other words adding microservices is a perfect opportunity you can mix and match people do it all the time with key value caches and rdbms's try graph for fraud detection wide column or tabular for your app or api or the document database for content management however if you know your operational database needs low latency at high load big or unbounded data sets global or regional deployment or replication flexible data modeling and high availability as well as handling global scale at lower costs one of the available nosql stores is a great choice when you are considering migration for example to a wide column nosql store ensure that you understand the differences between normalized and denormalized data understand your application ui and data access layer code build an entity relationship diagram adapting your data model define your access patterns grouping data together wherever possible design your primary keys and indexes and plan deployment and move data it's a similar story when migrating to a document database you'll need to adapt your data model to documents collections fields and more adapt your application code plan your deployment and move your existing data we've compared sql and nosql databases across several factors and giving you plenty of places to continue your learning spend the time to think about how each would apply to your data profile and use cases and best of luck thanks for watching and see you again soon you