lynn is a software engineer at salesforce and an excellent teacher in this course she will teach you how to solve backtracking problems which are common in coding interviews and challenges hi everyone i'm lin i'm a software engineer hobbyist game developer and recent graduate from the university of chicago welcome to this course on solving backtracking problems whether you are new to coding interviews or already have experience with backtracking problems this is the crash course for you we will learn about an allpurpose template that helps you solve any kind of backtracking problems and we will apply the template to decode problems like the 8 queens problem or the sudoku silver problem this is exactly the template that i use for my code interview problems when i'm developing algorithms for my games or even ones in my research on a nonconvex optimization problem i hope you're excited and let's dive right into this versatile template you can find this template in my github just linked to in the video description below let's start with some keywords and concepts in backtracking problems that will help us understand the template better the first keyword state essentially a backtracking problem is asking you to find valid states take the n queens example that we will solve later in this video an example of a state is just arbitrarily placing n queens on an unbian board for example here we are placing four queens on a 4x4 board on the contrary an example of a valid state requires that the queen are placed in a fashion not they cannot attack each other if you aren't familiar with the rules of chess don't worry the moves of queens are pretty straightforward a queen can move horizontally vertically or diagonally therefore for replacement of the n queens to be valid they can't stand on the same row the same column or the two diagonals so how do we construct a valid state like this well we build up from previous states suppose we're starting from the blank and by end board where no queen is present we can put our first queen arbitrarily wherever we want let's see we put it here then where can we place the second queen you can see now our choices are limited or in background terminology our candidate states are limited because we place the first queen here this entire column this entire row and the two diagonals are now unavailable for new queens let's say we just put the second queen here where it's available next we try to see where we can fit in the third queen our candidates are now more limited because we put the second queen here this column this row and this diagonal is not available so our third queen can only go here finally let's place the fourth queen because this third queen is here it blocks this diagonal and this row and this column leaving our fourth queen to set here great now is this global layout a valid solution such that no queen can attack each other well we've already seen in our checks so like this we have found a valid solution to this end queen problem as a counter example consider if we place the first two queens like this now all these cells marked in red are available and we only have one left for the third queen and nowhere to place the fourth queen this means that this succession of state searches fails to lead to a valid solution and this is pretty much it about states identifying candidates to build the next state and validating a final solution now let's look at how these procedures are defined in our template there are four functions in our template the first three is valid state get candidates search or helper functions the last and most important one so is the entry point to our program the so function is indeed the one that the elite code problem is asking you to write it is responsible for returning the valid solutions let's look at the helper functions one by one this valid state this function takes in a state and returns a boolean it validates whether a state can be used as a final solution in our quiz problem a state is a validate solution if all n queens are placed on the board and none of them can attack each other get candidates this function finds a list of candidates that can be used to construct the next state search this is a recursive function it calls the previous two helper functions and checks if the state is a valid solution to our backtracking problem if it is it records the solution by making a deep copy of the state note that we do need a deep copy instead of a shallow copy because we will continue to modify the state as our search goes but we need a static snapshot of the valid state here this line of return is commented out because depending on the nature of the problem we might need to find all valid solutions or just one if we only need one we can return as soon as we have find it otherwise we continue on until we exhaust all the possible search states continue down here if the state isn't yet a valid solution we find candidates to build the next state recall that candidates return a list of candidates for each one we add the candidate to the state in a quiz problem for instance suppose our state only contains the position of the first queen here we add a candidate position for the second queen now we take this modified state and recurse on it by calling the search method on this modified state if the modified state is valid the solution is recorded like here otherwise the search function fetches candidates for this modified state and recurs further eventually for some state there is no more possible candidate think that example where we cannot place a fourth queen anywhere because all the spaces have been occupied after returning from the recursive search we restore the modified state to the original by removing the candidate from the state again in the queen's example we undo the placement of the second queen and now we only have the first queen as for serve it starts with an empty list of solutions and an empty state a cost search on the state and this list of empty solution search will eventually fill up this list of empty solutions and then return the list of solutions and remember this is the function that the code problem is asking us to write when using this template keep in mind that this is only a template so your helper functions is valid state get candidates then by taking additional parameters search might also return a boolean indicating whether a solution has been found and returned early if there is one and only one valid global solution like in the sudoku problem that we will eventually see this concludes our brief introduction to the template next let's solve the queen's problem handson in lead code here we are only called number 51 the end queen's problem which is a legal heart problem let's first read the problem statement given an integer n we want to return all the distinct solution to the n queens puzzle and we may return the answer in any order and lico has a specific format for us to represent the board for four queens example these are the two valid solutions and here we denote that the first square on the first row is not occupied the second square is occupied by a queen the third one is not occupied the fourth one is not occupied and on the second row the first three squares aren't occupied and the last one is occupied by queen so on and so forth and in the case where n is 1 the queen can only be under a single grid so that's the solution before jumping into the code let's first think about how we may represent this problem logically we might be tempted to represent this board data structure as a 2d array but it's actually a little bit waste of space to do so since no queens can be on the same row or the same column we may just keep a 1d list that tracks the queen's position in each row concretely for this example here on the left for the first row the queen is in the second cell so the first index is one for the second row the index is three since the queen is in the fourth cell and this here is zero this here is two following the same logic for the example on the right the first index is two the second index is zero the third one is three and the last one one because the third cell the first cell the fourth cell and the second cell so this is the way that will represent each state as a 1d list for this backtracking problem now i'm going to grab my template and put it into the code i'm going to move the soap method on top as i already mentioned the silver method is basically the one that the code is asking us to write so for the solve n queens problem we will just be adapting the sole function so solutions is initially an empty list because we may return all the valid solution in any order then my starting state is just an empty list because we haven't placed any of the queens into the board just yet then we call self.search on the state giving it our list of solutions to append to and the parameter n for the n queens after the search is complete we return the solutions let's go ahead and remove this part great now we will write the is valid state function it will take as parameter solve state and n for state to be valid it needs to put all end queens onto the board so if the length of the state is n then we know we have already put all n queens onto the board as for the condition where no queens can attack each other we will handle it in the get candidate function essentially we will only return candidates that land on valid squares that won't be attracted by the previously placed queens so self state and great so here we are constructing candidates based on the state that we are given if there is no state meaning that we are starting from a blank board we may place the first queen anywhere we want so if not state we return all the possible indexes if the state is not empty we find the next position in the state to populate so position is the length of the state if we already place the first queen we want to place the second queen so candidates initially start from all the indices and then we prune down candidates that aren't valid i'm using a set because it's better than walking through a list and set guarantees uniqueness all right let's prone down candidates dot place the queen into a text so for row column in enumerate state we discard the we discard the column index if it's occupied so candy dates got this card recall that our state is recording the column index for each row now we discard the diagonals so distance is the distance between the position and the row index because we're trying to put a queen in the second row now that we have already filled in the first row we want it in a place that cannot be attacked by the first queen diagonally so this one is out of the question and this is column plus distance this one is also out of the question column minus distance and at the very end we return candidates now let's define our recursive search function it should take some states solutions and n we just adapt the template so if self dot is valid state state n we just add it to the solutions and return otherwise if we come down here for candidates in self.candidates state and we recurse because our state is a list and no longer a set we do append candidate and then call self.search state solutions and then and then to restore the modified state back to our original we pop the lost entry right so this here is the only thing that we need to take care of because leak wants us to output strings and here we have is a list of column indexes so let's define some additional helper functions here state to string so state n and we expect the output to be just like here here's how we convert our list of indexes to this output string specified by the code so the return is just a list for i in state because one means that the queen is in the second cell and the other cells are empty we just append the strings for the empty cells as well the string for the queen's concept notes together to get the return value string is this dot meaning the empty square times i plus the queen's position plus the remaining empty cells and red dot pen is great and we return the red and here is the solution at penn state.copy we do state stream and state string is produced by self dot state to string state great let's now run the example code to see how we did all right cool looks like our output is accepted let's submit and see whether we can pass all the test cases great you can see that our runtime is better than almost 70 of the submissions and also some memory usage is better than seven percent of the other submissions we are definitely using some memory because of the recursion but that's totally okay for backtracking problems next we will solve another leaked heart problem called the pseudocode silver problem we are now only called problem 37 the sudoku solver problem which is a hard problem if you don't already know what a sudoku puzzle is you can read the description so a sudoku solution must satisfy all the following rules each of the digits 1 to 9 must occur exactly once in each row and in each column also in nine of the three by three sub boxes of the grid and liquid used the dot character to indicate empty cells so for example here liko want us to write a program that fills out this sudoku puzzle in a valid way the board is represented as a 2d array of strings some maybe numbers some are empty cells and liko wants us to solve the problem and modify the board in place the constraints are that because it's a sudoku problem the shape is 9x9 and each cell is either a digit string or the empty string and it's guaranteed that the input board has only one solution so we may return early before you find only one solution let me copy paste my template and jump into the problem all right so again we adopt the soap function like this because it asks us not to return anything and just modify the board in i think we'll just need to do self.search board and then we can get rid of this so function i'm going to have to define some constants here so the shape is 9x9 the grid length is 3x3 if we are trying to validate the sub boxes and empty is represented as this dot here and all the digit strings are like follows so screen number four number in range one shape plus one so this gives us the strain from one to nine and i'm going to wrap it in a set because the order is not important and i know i'm going to need this when i'm traversing the grid great so let's start by writing the is valid state function so it should take self and the board and check if the board is a valid solution so let's validate all the rows first for row and i'm going to just define some helper function later down so let's do first soft get rows which returns each row of the board one by one if if my row is equivalent to all the digits then it's a valid row otherwise it's an invalid row and the entire board is not valid if not set row is equal to self.digits return false validate similarly we validate the columns because return false and lastly we validate the sub boxes foregrip and self dot get great board and if all the rows are validated all the columns are validated and all the grids are validated without causing this false return early we return true meaning that the board is now a valid solution now let's write get candidates so self board a row and a column i'm using the row and the column because for eight cell i want to know which row and which column it is on to determine what digits have already been used and what are left for us to use as a next state so used digits is a set of digit and i'm going to remove used remove digits used by the same row so used digits dot update self dot get okay bro this is another helper function that i will define later down move digits used by the same column so use digits dot update self dot get paid column four and a column and remove digits used by the same by the by the three by three sub box so use digits dot update get grid at row and column so we need to identify for an arbitrary cell which grid it is on board row call and lastly because we might have already used the empty string here when we are doing the updates we subtract those from our use digits self dot empty is the constant that we defined for the empty string and candidates are just whatever that's left for us to use so the all used ones and that concludes our get candidate function now we are moving on to do search because we only have one single solution we don't need the list of solutions here so self and board we have this valid state so if self dot is valid state board we return true found solution otherwise we find the next empty spot and take a guess so for row index row in enumerate board for column index the actual element in enumerate row if the element is the empty string so soft dot empty for if this is empty find candidates to construct the next string next stage candidate a self dot get candidates for now that we have the row index and column index we pass those in we modify the board in place as the problem instructed us to do so candidate remember that candidate is just one of the digit string and because here our search returns a boolean if one of the search actually finishes that means that the board has been modified in place and our problem is solved so it's solved is now equal to self.search board and just to add some comment here we recurse on the modified board if it's soaked if it's soaked then we just return true meaning that the entire search has completed otherwise we undo the wrong guess and start a new so we make this entry back into the empty string that it was and down here we have exhausted all the candidates but none solves the problem we return false because this is an invalid succession of searches and if no empty spot in the first place then we just return true and we can get rid of this boilerplate code from our template now the structure is pretty much clear and all i need to do is to fill in those hopper functions helper functions for retrieving rows columns and grids so here are my helper functions for retrieving rows columns and grids this is pretty straightforward because our board is just a 2d array and to retrieve the kth row case column or grid other certain row and column indexes we are basically just doing some really smart indexes and sometimes relying on the power of either tools i will post my complete code all my github linked in the description so you can digest those helper functions on your own now let's run the code and see what we get great our output is accepted let's submit and test it against all the test cases awesome with this template we solve two legal heart problems to recap a back checking problem is all about finding valid states to solve for a valid state we identify candidates that satisfy the problem constraint and use them to build upon our current state once a modified state is valid we add it as a final solution now that we have solved two problems handson let's take another look at our template recall that we have these four functions its valid state is a helper function with a boolean return value that validates whether a given state is a funnel solution get candidates is another helper function returning a list of candidates satisfying the problem constraint based on our current state search is a recursive function across the two hopper functions is valid state and get candidates and recurs on itself lastly solve is the function that a legal problem is asking you to write it does nothing fancy other than initializing an empty list of solutions an empty state and calling search on them for more practice problems on backtracking go to leakcode.com and in text search for backtracking this filters out a list of questions that all shares the backtracking idea you see we already solved sudoku solver and n queens if you're looking for a medium hard problem i recommend the subsets problem this is about finding all possible subsets or power sets of a given integer array it is pretty easy to identify a backtracking problem when we are asked to find all possible solutions and may return the solution in any order as you can see in my submission details i solved the subsets problem using the exact template as you go through more and more lead code problems and test how much you understand about the template you will be better prepared to identify a backtracking problem once you encounter one in your coding interviews this concludes our video and the only crash course you ever need for solving backtracking problems on your code interviews for more content like this please subscribe to my youtube channel linksdevelop i also post fun project tutorials and my game development demos on my channel my latest tutorial is about building a discord ai chatbot with the personality of your favorite character using entirely cloudbased technologies and i'm sure you will enjoy it thanks for watching and best of luck prepare for code interviews