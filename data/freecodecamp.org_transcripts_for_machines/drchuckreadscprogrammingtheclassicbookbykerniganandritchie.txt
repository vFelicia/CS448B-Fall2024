dr charles severance is one of the world's most popular software instructors and he's the instructor for this c programming course this course is a little different than some of our other courses dr chuck is going to take you through a classic and important book on c programming you will occasionally have to pause the video to do some assignments to check your comprehension it's going to be a challenge but it will definitely be worth it if you want to have a deep understanding of the c programming language and if you're completely new to programming you may want to watch dr chuck's python for everybody course first welcome to c programming for everybody my name is charles severance and i'm your instructor for this course this course and website is dedicated to learning the classic version of c programming language from the 1978 book written by brian w kernighan and dennis m ritchie this book places the reader in the middle of the 1970s transition from a hardwarecentered computer science to a focus on writing portable and efficient software c was used to develop operating systems like unix minix and linux programming languages like perl python java and javascript and ruby are all written in c software like early tcp networking stack implementations that made the internet possible were written in c and the first web browsers and web servers were written in c writing software in c enabled major advances in computer architecture and performance operating systems compilers and utilities could be recompiled to work on a new hardware platform once we had a c compiler for the new hardware so much software has been written in c over the past 40 years that there's a very good chance that much of the software that you use every day was either written in c or written in a programming language that was written in c so we study c less as a programming language to use on a daily basis and more as the foundation of modern software and computing in many ways c is the technology equivalent of the rosetta stone in that it provides a connection between the programming languages of the past and the programming languages of the present the name cc4e in www.cc4e.com refers to the original unix command cc which was the command that you used to compile your c program cc stood for c compiler and it is featured on the first page of the first chapter of the knrc book programmers like me from the 1970s and 1980s typed cc on unix systems like the att 3b2 to compile and run their first hello world program in c this material is being presented under fair use as we are making use of material from a copyrighted work that is out of print and not broadly available in any format the book is also not available in any accessible format we are making use of this material in a teaching and research context with a focus on studying its contribution to computing history the material is available for free and online to anyone who wants to learn about the history of a c language computing and computer architecture welcome to the course welcome to c programming for everybody my name is charles severance and this is my reading of the 1978 c programming book written by brian kernighan and dennis ritchie at times i add my own interpretation of the material from a historical perspective chapter 0 introduction c is a general purpose programming language it has been closely associated with the unix system since it was developed on that system and since unix and its software are written in c the language however is not tied to any one operating system or machine and although it has been called a system programming language because it is useful for writing operating systems it has been used equally well to write major numerical text processing and database programs c is a relatively low level language this characterization is not pejorative it simply means that c deals with the same sort of objects that most computers do namely characters numbers and addresses these may be combined and moved about with the usual arithmetic and logical operators implemented by actual machines c provides no operations to deal directly with composite objects such as character strings sets lists or arrays considered as a whole there is no analog for example of the pl1 operations which manipulate an entire array or string the language does not define any storage allocation facility other than static definition and the stack discipline provided by the local variables of functions there is no heap or garbage collection like that provided by algol 68. finally c itself provides no input output facilities there are no read or write statements and no wired in file access methods all of these higher level mechanisms must be provided by explicitly called functions i would note that the lack of a heap or garbage collection feature in c is both one of the great strengths of the language and at the same time is likely the reason that the average programmer will never develop or maintain a major c application during their career c provides a simple feature using malloc and free functions that allow a programmer to request a certain amount of memory be allocated dynamically use the memory and then return the memory to the c runtime library for reuse for example to convert a jpeg image to a png image our application will read the jpeg data into memory then convert the image into a png image in memory and then write the png data out to a file we don't know how large the images will be in advance so we request whatever size we need from c and then give it back when we're done the term heap refers to the memory that c manages on our behalf when we need to borrow a bit of memory and give it back later there are a couple of issues with a simple heap implementation first if we forget to call free when we are done with a memory we have created a memory leak and our program will eventually run out of memory and abort c places the onus of giving back any dynamically allocated memory on the programmer modern languages like java javascript and python keep track of when we stop using dynamic memory using a dynamic memory layer that can automatically reclaim the memory the more difficult problem is after a series of calls to malik and free the heap space becomes fragmented and some cleanup is needed this cleanup is called garbage collection efficient memory allocation and garbage collection has been the subject of decades of computer science research the java language has built a number of increasingly effective garbage collection approaches over the years kernighan and ritchie in one simple paragraph define most of the problem as out of scope for the c language which makes it a bit challenging for us to make good use of dynamic memory allocation in c but when we do it properly it performs very well if you are currently using a language like java python or php every time you create a new string through concatenation without thinking about memory allocation remember to appreciate the decades of work by computer scientists that made it easy for you kernighan and ritchie knew that garbage collection was difficult so they left it out of the c language and put it into a run time library back to chapter zero similarly c offers only straightforward single thread control flow constructions tests loops grouping and subprograms but not multiprogramming parallel operations synchronization or coroutines though the absence of some of these features may seem like a grave deficiency you mean i have to call a function to compare two character strings keeping the language down to modest dimensions has brought real benefits since c is relatively small it can be described in a small space and learned quickly a compiler for c can be simple and compact compilers are also easily written using current technology one can expect to prepare a compiler for a new machine in a couple of months and to find that eighty percent of the code of a new compiler is common with existing ones this provides a high degree of language mobility because the data types and control structures provided by c are supported directly by most existing computers the runtime library required to implement selfcontained programs is tiny on the pdp11 for example it contains only the routines to do 32bit multiplication and division and to perform subroutine entry and exit sequences of course each implementation provides a comprehensible compatible library of functions to carry out input output string handling and storage allocation operations but since they are only called explicitly they can be avoided if required and they can also be written portably in c itself again because the language reflects the capabilities of current computers c programs tend to be efficient enough that there is no compulsion to write assembly language instead the most obvious example of this is the unix operating system itself which is written almost entirely in c of 13 000 lines of system code only about 800 lines at the very lowest level are an assembler in addition essentially all of the unix application software is written in c the vast majority of unix users including one of the authors of this book do not even know the pdp11 assembly language i would note that in this preface the authors are carefully explaining the fact that many of the wellestablished programming languages of the 1960s and 1970s like fortran cobalt pascal algol and pl1 were solving many of the use cases that were needed by us programmers by adding syntax to the languages the creators of c and unix were advocating for a more minimal set of programming language constructs and more reliance on calling function in provided runtime libraries to meet programmer use cases it may have seemed a strange approach for experienced programmers in the 1980s but over time it has allowed c to expand to meet a very wide range of programmer needs without requiring major revisions to the core language or compiler back to chapter 0. although c matches the capabilities of many computers it is independent of any particular machine architecture and so with a little care it is easy to write portable programs that is programs which can be run without change on a variety of hardware it is now routine in our environment that software developed on unix is transported to local honeywell ibm and inner data systems in fact the c compilers and runtime support on these four machines are much more compatible than the supposedly ansi standard versions of fortran the unix operating system itself now runs on both the pdp11 and the interdata 832 outside of programs which are necessarily somewhat machine dependent like the compiler assembler and debugger software written in c is identical on both machines within the operating system itself the 7 000 lines of code outside of the assembly language support and the i o device handlers is about 95 percent identical as a note before unix and c if you are running the vendor operating system and writing in the best language for systems like the pdp 11 and inner data 732 the user experience was completely different today we take for granted that we expect to be able to download the same application for windows mac os or a linux system even in the 1970s those that were using unix and c could write code once and move it between two hardware platforms and expect that it would work with no or relatively few changes back to chapter zero for programmers familiar with other languages it may prove helpful to mention a few historical technical and philosophical aspects of c for contrast and comparison many of the most important ideas of c stem from the considerably older but still quite vital language bcpl developed by martin richards the influence of bcpl on c proceeded indirectly through the language b which was written by ken thompson in 1970 for the first unix system on the pdp7 although it shares several characteristic features with bcpl c is in no sense a dialect of it bcpl and b are typeless language the only data type is the machine word and access to other kinds of objects is by special operators or function calls in c the fundamental data objects are characters integers of several sizes and floating point numbers in addition there is a hierarchy of derived data types created with pointers arrays structures unions and functions c provides the fundamental control constructions required for wellstructured programs statement grouping decision making with if looping with termination test at the top using for and while or at the bottom using do and selecting one of a set of possible cases switch all of these were provided in bcpl as well though with somewhat different syntax that language anticipated the vogue for structured programming by several years c provides pointers in the ability to do address arithmetic the arguments to functions are passed by copying the value of an argument and is impossible for the called function to change the actual argument in the caller when it is desired to achieve call by reference a pointer may be passed explicitly and the function may change the object to which the pointer points array names are passed as the location of the array origin so array arguments are effectively call by reference any function can be called recursively and its local variables are typically automatic or created anew with each invocation function definitions may not be nested but variables may be be declared in a block structured fashion the functions of a c program may be compiled separately variables may be internal to a function external but known only within a single source file or completely global internal variables may be automatic or static automatic variables may be placed in registers for increased efficiency but the register declaration is only a hint to the compiler and does not refer to specific machine registers c is not a strongly typed language in the sense of pascal or algol 68 it is relatively permissive about data conversion although it will not automatically convert data types with the wild abandon of pl1 existing compilers provide no run time checking of array subscripts or argument types etc for those situations where strong type checking is desirable a separate version of the compiler is used this program is called lint apparently because it picks up bits of fluff from one's program lint does not generate code but instead applies a very strict check as to many aspects of the program as can be verified at compile and load time it detects type mismatches inconsistent argument use unused or apparently uninitialized variables potential portability difficulties and the like programs which pass unscathed through lint enjoy with few exceptions freedom from type errors about as complete as do for example alcohol 68 programs we will mention other lint capabilities as the occasion arises i would note that separately checking for things that might be wrong into the lint program keeps the c compiler simple and easy to port to a new computer the lint program was naturally a very portable text processing application while there's some overlap between a lint program and a compiler over time there's quite distinct research and expertise in how to lint versus how to compile modern lint programs look at programs in far more detail than most compilers separating concerns of lint and the c compiler also allowed lint programs to use more memory and take more time to execute than compilers since the typical developer might use the compiler many times per day and run lint less often it was nice for the compiler to run quickly and make light use of computer resources we call this idea of building two smaller complementary programs that each specialize in one task separation of concerns and it is an important principle in computer science by keeping each component simple in focus we can more easily build test and verify each component unix and c showed the benefits of taking many small components approach to solve an overall set of problems back to chapter zero finally c like any other language has its blemishes some of the operators have the wrong precedence some of the syntax could be better there are several versions of the language extent differing in minor ways nonetheless c has proven to be an extremely effective and expressive language for a wide variety of programming applications the rest of this book is organized as follows chapter 1 is a tutorial introduction to the central part of c the purpose is to get the reader started as quickly as possible since we believe strongly that the only way to learn a new language is to write programs in it this tutorial does assume a working knowledge of the basic elements of programming there is no explanation of computers of compilation nor the meaning of an expression like n equals n plus one although we have tried where possible to show useful programming techniques the book is not intended to be a reference work on data structures and algorithms when forced to make a choice we have concentrated on the language chapters two through six discuss the various aspects of c in more detail and rather more formally than does chapter 1 although the emphasis is still on working examples of complete useful programs rather than isolated fragments chapter 2 deals with basic data types operators and expressions and chapter 3 treats control flow if else while 4 etc chapter 4 covers functions and program structure external variables scope rules and so on chapter 5 discusses pointers and address arithmetic and chapter 6 contains the details of structures and unions chapter 7 describes the standard cio library which provides a common interface to the operating system this io library is supported on all machines that support c so programs which use it for input output and other system functions can be moved from one system to another essentially without change chapter eight describes the interface between c programs and the unix operating system concentrating on input output the file system and portability although some of this chapter is unix specific programmers who are not using unix systems should still find useful material here including some insight on how one version of the standard library is implemented and suggestions on achieving portable code appendix a contains the c reference manual this is the official statement of the syntax and semantics of c and except for one owns compiler the final arbiter of any ambiguities and omissions from earlier chapters since c is an evolving language that exists on a variety of systems some of the material in this book may not correspond to the current state of developments for a particular system we have tried to steer clear of such problems and warn of potential difficulties when in doubt however we have chosen generally to describe the pdp11 unix system since that is the environment of the majority of c programmers appendix a also describes implementation differences on the major c systems chapter 1 a tutorial introduction let us begin with a quick introduction to c our aim is to show the essential elements of the language in real programs but without getting bogged down in details formal rules and exceptions at this point we are not trying to be complete or even precise we want you to get as quickly as possible to the point where you can write useful programs and to do that we have to concentrate on the basics variables and constants arithmetic control flow functions and the rudiments of input and output we are quite intentionally leaving out of this chapter features of c which are of vital importance for writing bigger programs these include pointers structures and most of c's rich set of operators several control flow statements and a myriad of details this approach has its drawbacks of course most notable is that the complete story on any particular language feature is not found in a single place the tutorial by being brief may also mislead and because they cannot use the full power of c the examples are not as concise and elegant as they might be we have tried to minimize these effects but be warned another drawback is that later chapters will necessarily repeat some of this chapter in any case experienced programmers should be able to extrapolate from the material in this chapter to their own programming needs beginners should supplement it by writing small similar programs of their own both groups can use it as a framework on which to hang the more detailed descriptions that begin in chapter 2. 1.1 getting started the only way to learn a new programming language is by writing programs in it the first program to write is the same for all languages print the words hello world this is the basic hurdle to leap over it you have to be able to create the program text somewhere compile it successfully load it run it and find out where your output went with these mechanical details mastered everything else is comparatively easy in traditional c the program to print hello world is main open parenthesis closed parenthesis open curly brace printf parentheses double quote hello comma space world backslash n double quote close parentheses semicolon close curly brace the modern minimal version of this program needs a bit more syntax we add a single line at the beginning hashtag include space left angle brackets stdio.h right angle bracket pound include stdio.h we have to add that line for the modern program back to the book just how to run this program depends on the system that you're using as a specific example on the unix operating system you must create the source program in a file whose name ends in dot c such as hello dot c and then you compile it with the command cc space hello.c if you haven't botched anything such as omitting a character or misspelling something the compilation will proceed silently and make an executable file called a dot out running that by the command a dot out will produce hello comma world as its output on other systems the rules will be different check with a local expert on modern systems we use the gcc compiler with the dash ansi option to accept the legacy syntax of c so we use gcc space minus ansi space hello.c and to run the resulting a dot out file you usually you need to prepend the local directory because most shell configurations do not include the current path in the paths to search for applications so you need to write dot slash a dot out now for some explanations about the program itself a c program whatever its size consists of one or more functions which specify the actual computing operations that are to be done c functions are similar to functions and subroutines of a fortran program or the procedures of pl1 pascal etc in our example main is such a function normally you are at liberty give functions whatever names you like but main is a special name your program begins executing at the beginning of main this means every program must have a main somewhere main will usually invoke other functions to perform its job some coming from the same program and others from libraries of previously written functions one method of communicating data between functions is by arguments the parentheses following the function name surround the argument list here main is a function of no arguments indicated by open parentheses close parentheses the curly braces enclose the statements that make up the function they're analogous to the due end of pl1 or the begin end of algol or pascal and so on a function is invoked by naming it followed by a parenthesized list of arguments there is no call statement as there is in fortran or pl1 the parentheses must be present even if there are no arguments in the above text the authors were making connections to the popular general purpose programming languages of the time when the book was written it was not all assured that c and c like languages would ever evolve past writing high performance applications like operating system kernels and device drivers by comparing c to these more general purpose languages the authors are trying to plant the seed that c could have value as a general purpose language back to the text the line that says printf parentheses double quote hello comma space world backslash and double quote close parentheses semicolon is a function call which calls a function named printf with the argument hello world printf is a library function which prints the output to the terminal unless some other destination is specified in this case it prints the string of characters that make up its argument any sequence of any number of characters enclosed in double quotes is called a character string or string constant for the moment our only use of the character strings will be as arguments to printf and other functions the sequence backslash n in the string is c notation for the new line character which when printed advances the terminal to the left margin on the next line if you leave out the backslash n a worthwhile experiment by the way you will find that your output is not terminated by a line feed the only way to get a new line character into the printf argument is with backslash n if you try to break it into two lines like printf quote hello world and then just hit the return double quote close parentheses semicolon on a new line the c compiler will print out unfriendly diagnostics about missing quotes printf never supplies a new line automatically so multiple calls can be used to build up an output line in stages our first program could have just as well been written as main open parenthesis closed parenthesis open curly brace printf quote hello quote semicolon printf quote world quote semicolon print f backslash n semicolon and then on a sixth line closed curly brace and it would have produced the identical output note that backslash n represents only a single character an escape sequence like backslash n provides a general and extensible mechanism for representing hard to get or invisible characters among the others that c provides are backslash t for tab backslash b for backspace backslash double quote for double quote and backslash backslash for the backslash itself 1.2 page 8 variables and arithmetic the next program prints the following table of fahrenheit temperatures in their centigrade or celsius equivalents using the formula c equals parenthesis 5 divided by 9 closed parenthesis parenthesis f minus 32. the table contains fahrenheit of 0 celsius of negative 17.8 fahrenheit at 20 celsius of negative 6.7 fahrenheit of 40 celsius of 4.4 and so forth here is the program itself for reference this program is on page 29 of the textbook so it starts with pound include stdio.h to include the standard library then it has a comment that says print the fahrenheit celsius table for f equals zero comma twenty comma dot dot dot comma three hundred close comment main open parenthesis close parenthesis open curly brace int lower comma upper comma step semicolon float far comma celsius lower equals zero semicolon followed by a comment upper equals 300 semicolon followed by a comment step equals 20 semicolon followed by a comment far equals lower and then while open parenthesis far less than or equal to upper closed parenthesis open curly brace celsius equals parenthesis 5.0 slash 9.0 closed parenthesis asterisk open parenthesis far minus 32.0 close parentheses semicolon then a printf statement printf open parentheses double quote percent 4.0 f space percent 6.1 f backslash n close quote comma far comma celsius close parentheses semicolon far equals far plus step and then a closing curly brace to finish the while statement and then a closing curly brace to finish the main statement the first two lines slash star print fahrenheit to celsius table for f equals zero comma twenty dot dot dot three hundred star slash are a comment which in this case explains briefly what the program does any characters between star and star slash are ignored by the compiler they may be used to freely make the program easier to understand comments may appear anywhere a blank or new line can in c all variables must be declared before use usually at the beginning of a function before any executable statements if you forget a declaration you will get a diagnostic from the compiler a declaration considered consists of a type and a list of variables that have that type as in int lower comma upper comma step semicolon float far celsius semicolon the type int implies that the variables listed are integers float stands for floating point i.e numbers which may have a fractional part the precision of both int and float depends on the particular machine that you are using on the pdp11 for instance an int is a 16bit signed number that is one that lies between negative 32 eight and positive thirty two thousand seven sixty seven a float number is a thirty two bit quantity which amounts to about seven significant digits with a magnitude of about ten to the minus thirty eight and 10 plus 38. chapter 2 lists the sizes for other machines i would note that the 1970s was a time of transition in the amount of memory installed in computers the c language int type was 16 bits in the older but more generally available computers like the pdp11 c could be used to write programs like the unix operating system that made efficient use of available memory in particular the 1978 version of c did not require that computers support 32bit integers but 32768 is a pretty small number the size of an integer affected the maximum size of arrays and strings a lot of early c programs use the long type to get at least a 32bit integer capable of representing numbers up to about 2 billion in modern modern computers and databases we tend to choose between 32bit and 64bit integers back to the text c provides several other basic data types besides int and float char is a character a single byte short is a short integer long is a long integer and double is a double precision floating point size of these objects are also machine dependent and details are in chapter 2. there are also arrays structures and unions of these basic types and pointers to them and functions that return them all of which we will meet in due course the actual computation in our temperature conversion program begins with the assignments lower equals zero upper equals 300 step equals 20 far equals lower all ending with semicolon these set the variables to their starting vari values individual statements are terminated by semicolons each line of the table is computed in the same way so we use a loop which repeats once per line this is the purpose of the while statement while parentheses far less than or equal upper close parentheses open curly brace then the body of the loop and then close curly brace the condition in the parentheses is tested if it is true i.e far is less than or equal to upper the body of the loop all of the statements included between the open curly brace and the closed curly brace are executed and the condition is retested if true the body is executed again when the test becomes false i.e far exceeds upper the loop ends and execution continues at the statement that follows the loop there are no further statements in the program so it terminates the body of a while loop can be one or more statements enclosed in braces as the temperature converter or a single statement without braces as in while open parentheses i less than j closed parenthesis i equals two times i semicolon in either case the statements controlled by the while are indented by one tab stop so you can see at a glance what statements are inside the loop the indentation emphasizes the logical structure of the program although c is quite permissive about statement positioning proper indentation and the use of white space are critical in making programs easy for people to read we recommend writing only one statement per line and usually leaving blanks around operators the position of the braces is less important we have chosen one of the several popular styles pick a style that suits you and then use it consistently i would add that with these words the authors triggered a great debate about how to best indent code and use curly braces that continues to this day the intention style used in this book is often referred to as the k and r style it tends to put open braces at the end of statements like if and while to keep code more compact in terms of the number of lines of code the best advice is not to debate at all when you modify someone else's code just imitate the style that they used when they wrote their code back to the text most of the work gets done in the body of the loop the celsius temperature is computed and assigned to the celsius variable by the statement celsius equals open parenthesis 5.0 slash 9.0 close parenthesis asterisk open parenthesis far minus 32.0 close parentheses semicolon the reason for using 5.0 9.0 instead of the simpler looking five slash nine is that in c as in many other languages integer division truncates so that any fractional part is discarded thus five slash nine is zero and of course so would then all the temperatures be zero a decimal point in a constant indicates that it is floating point so that 5.0 over 9.0 is 0.555 repeating which is what we want we also wrote 32.0 instead of 32 even though since far is a float 32 would automatically be converted to flow before the subtraction but as a matter of style it's wise to write floating point constants with explicit decimal points even when they have integral values it emphasizes their floating point nature for human readers and ensures the compiler will see things the way you do as well i would note that for those of you familiar with python before python 3 integer division truncated and returned an integer just like c in python 3 one of the major improvements was that the division of two integers performed the division operation in floating point and returns a floating point result c and python 2 made the choice because of efficiency integer division with truncation especially for 16bit numbers was quite fast in the 1970s computers compared to floating point division that kept the fractional part intact early pdp11 computers did integer division in hardware while all floating point was done with loops and functions so it was far slower if you wanted to write fast code in the 1970s you avoided floating point numbers except for special situations modern computers usually do 64bit floatingpoint operations almost at the same speed as integer division so we don't need to allow programmers to avoid using floating point computations in their code the detailed rules for when integers are converted to floating point are in chapter 2. for now notice that the assignment far equals lower semicolon and the test while far less than or equals upper both work as expected the int is converted to a float before the operation is done this example also shows a bit more of how printf works printf is actually a general purpose format conversion function which we will describe completely in chapter 7. its first argument is a string of characters to be printed with each percent sign indicating where one of the other second third etc arguments is to be substituted and what form it is to be printed in for instance in the statement printf parentheses double quote percent 4.0 f space percent 6.1 f backslash n double quote comma far comma celsius the conversion specification percent 4.0 f says that a floating point number is to be printed in a space at least four characters wide with no digits after the decimal point percent 6.1 f describes another number to occupy at least six spaces with one digit after the decimal point analogous to the f 6.1 of fortran or the f parentheses six comma one of pl1 parts of a specification may be omitted percent six f says that the number is to be at least six characters wide percent.2f requests two places after the decimal point but the width is not constrained and merely percent f says to print the number itself as floating point printf also recognizes percent d for decimal integers percent o for octal percent x for hexadecimal and percent c for characters and percent s for a character string and percent percent for the percent itself each percent construction in the first argument of printf is paired with its corresponding second third etc argument they must line up properly by number and type or else you'll get meaningless answers by the way printf is not part of the c language there is no input or output defined in c itself there is nothing magic about printf it's just a useful function which is part of the standard library of routines that are normally accessible to c programs in order to concentrate on c itself we might we won't talk much about io until chapter seven in particular we'll defer formatted input until then if you have to input numbers read the discussion of the function scanf in chapter 7 section 7.4 scanf is much like printf except that it reads input instead of writing output the balance between building a feature into the language itself and providing it as a function in a library is something that computer language designers struggle with many years later for example in python 2 print was a language element in python 3 one of the nonupwards compatible and somewhat unpopular changes was changing print to be a function many programmers feel that a print statement is a more elegant way to express printing but from a compiler and language design perspective a function call with a variable number of parameters is seen as technically more elegant and flexible with kernighan and richie focused on keeping everything small and portable they opted to keep all input output functionality in libraries the syntax is a little more complex but given how computing has changed in the past 30 years it is the right choice section 1.3 the for statement as you might expect there are plenty of different ways to write a program let's try a variation on the temperature converter this is sample code is on page 11 of the textbook pound sign include less than stdio.h greater than main open parentheses closed parenthesis open curly brace int bar that is f a h r semicolon four open parenthesis far equals zero semicolon far less than or equal to three hundred semicolon far equals far plus 20 close parenthesis printf open parentheses double quote percent 4d space percent 6.1 f backslash n close print a close quote comma far comma open parenthesis 5.0 slash 9.0 close parentheses asterisk open parenthesis far minus 32 close parentheses close parenthesis semicolon this code produces the same answers as the one before but it certainly looks different one major change is the elimination of most of the variables only far fahr remains as an int to show the percent d conversion in printf the lower and upper limits of the step size appear only as constants in the for statement itself the 4 is a new construction and the expression that computes the celsius temperature now appears as the third argument of printf instead of in a separate assignment statement this last change is an instance of a quite general rule in c in any context where it is permission permissible to use the value of a variable of some type you can use an expression of that type since the third argument of printf has to be a floating point value to match the percent 6.1 f any floating point expression can occur there the 4 itself is a loop a generalization of while if you compare it to the earlier while its operation should be clear it contains three parts separated by semicolons the first part far equals zero is done once before the loop proper is entered the second part is the test or condition that controls the loop far less than or equal to 300. this condition is evaluated if it is true the body of a loop in this case a single printf is executed then the reinitialization step far equals far plus 20 is done and the condition is reevaluated the loop terminates when the condition becomes false as with the while the body of the loop can be a single statement or a group of statements enclosed in braces the initialization and reinitialization parts can be any single expression the choice between while and four is arbitrary and should be based on what seems clearer the four is usually appropriate for loops in which the initialization and reinitialization are single statements and logically related since it is more compact than while and keeps the loop control statements together in one place i would note that the syntax of the for and while loop is a feature of c and derived c like languages in modern languages we tend to have two kinds of loop structures determinant and indeterminate the four and the while loop structures in c are both indeterminate because you must read them closely to make sure they are properly constructed and for example are not unintentionally infinite loops an example of a determinant loop is the for each loop in php or the for loop in python the semantics of both of these loops is to iterate all the elements in a collection but since collections are never infinite you can be assured that these determinant loops will not run forever section 1.4 symbolic constants a final observation before we leave temperature conversion it's a bad practice to bury magic numbers or magic constants like 320 or 320 in a program they convey little information to someone who might read the program later and they're hard to change in a systematic way fortunately c provides a way to avoid such magic numbers with the pound sign defined construction at the beginning of a program we can define a symbolic name or symbolic constant to be a particular string of characters thereafter the compiler will replace all unquoted occurrences of the name by the corresponding string the replacement for the name can actually be any text at all it's not related to numbers so this is a sample code on page 13 of the text pound sign include less than stdio.h greater than next line pound define space lower space zero next line pound define space upper space 300 pound define space step space 20. for these pound sign statements i would note that they have to start in the first column the rest of this sample code is the code itself main open parenthesis closed parenthesis open curly brace int far fahr for open parentheses far equals uppercase lower semicolon far less than or equal to uppercase upper semicolon far equals far plus uppercase step then the same print statement printf open parentheses double quote percent 4d space percent 6.1 f backslash n quote comma far comma percent 5.0 9.0 close parentheses asterisk open parenthesis far minus 32 close parenthesis close parenthesis semicolon and then to end the program close curly brace the quantities uppercase lower uppercase upper and uppercase step are constants so they do not appear in declarations symbolic names are commonly written in uppercase so they can be readily distinguished from lowercase variable names notice that there is no semicolon at the end of a pound defined statement since the whole line after the defined name is substituted there would be too many semicolons in the four section 1.5 a collection of useful programs we are now going to consider a family of related programs for doing simple operations on character data you will find that many programs are just expanded versions of the prototypes we discuss here character input and output the standard library provides functions for reading and writing a character at a time getchar fetches the next input character each time it is called and returns the character as its value that is after c equals get char open parentheses close parenthesis the variable c contains the next character of input these characters normally come from the terminal or keyboard but that need not concern us until chapter 7. the function put char open parentheses c close parenthesis is the complement of getchar put chair open parenthesis c close parenthesis prints the content of the variable c on some output medium again usually the terminal or screen calls to put char in printf may be interleaved the output may be a p will appear in the order in which the calls are made as with printf there is nothing special about gachar and putchar they are not part of the c language but they are universally available once again i would note that the authors are making the case that the syntax of the language should not include syntax for input output operations but instead call library functions keeping the compiler small and easy to port new systems was important to the creators of c and even if something like put char was part of the language syntax it would be translated at runtime to call a function programming languages from the 1960s tended to have a small set of use cases read some input run some calculation and then write some output so it seemed like a few language elements would be sufficient to describe all programs but as programs started to make network connections draw buttons on a screen or respond to api calls over the network it would have been difficult to keep expanding the core language syntax for each new use case but it was extremely natural to add new libraries to languages like c with functions to call to accomplish these new use cases file copying given getchar input char you can write a surprising amount of useful code without knowing anything more about input output the simplest example is a program which copies its input to its output one character at a time in outline here's what we do get a character while the character is not the end of file signal i'll put the character we just read and then get a new character converting this into c gives us the sample code on page 14 of the textbook pound includes stdio.h main open parentheses closed parentheses open curly brace int c semicolon c equals get char open parenthesis close parenthesis semicolon while c not equal eof uppercase eof close parenthesis open curly brace put char c c equals get char semicolon close parentheses close curly brace the relational operator exclamation equals means not equal to the main problem is detecting the end of the input by convention getchar returns the value which is a not a valid character when it encounters the end of input in this way programs can detect when they did not get a character and they've actually simply run out of input the only complication which is a serious nuisance is that there are two conventions in common use about what that endophile value really is we have deferred this issue by using the symbolic name eof capital eof for the value whatever it might be in practice eof will be either negative one or zero so the program must be pro seated by the appropriate pound define eof 1 or pounddefying eof0 to work properly by using the symbolic constant eof to represent the value that getcha returns when the end of file occurs we are assured that only one thing in the program defines on the specific depends on the specific value numeric value of eof i would note most of that is incorrect modern c compilers actually define eof in the stdio.h include file so you never define eof in your code in modern c the value of eof is minus one you should just include stdio.h and use predefined eof constant to check for end to file the nuisance of different values for eof was resolved shortly after 1978. continuing with the text we also declare c to be an int not a chair char so that it can hold the value which get char returns as we'll see in chapter two the value is actually an int because it must be capable of representing and defile in addition to all possible characters so the program for copying could actually be written more concisely by experienced c programmers in c any assignment such as c equals get char open parentheses close parenthesis can be used in an expression its value is simply the residual value being assigned to the left hand side if the assignment of a character to the variable c is put inside the test part of a while statement the file copy program can be written as shown in the example code on page 15 of the textbook pound include stdio.h main open parenthesis close parenthesis open curly brace int space c semicolon while open parenthesis open parenthesis c equals get char open parenthesis close parenthesis close parenthesis not equal eof close parenthesis put char c parentheses c close parenthesis semicolon close curly brace the program gets a character assigns it to c and then tests whether the character was the end of file signal if it was not the body of the wireless executed printing the character the while then repeats when the input is end of input is finally reached the wild terminal terminates and so does main this virtual version centralizes the input there is now only one call to get char and shrinks the program nesting an assignment is a test of one of the places where c permits a valuable conciseness it is possible to get carried away and create impenetrable code though a tendency that we will try though that is a tendency we will try to curb it's important to recognize that the parentheses around the assignment within the conditional are really necessary the precedence of exclamation equal not equals is higher than that of equals the assignment operator which means that in absence of parentheses the relational test exclamation equals would be done before the assignment equals so the statement c equals get char parentheses open parentheses close parenthesis not equal eof is equivalent to c equals get char open no sorry is equivalent to c equals open parenthesis get char open press the close parenthesis not equal eof close parenthesis this has the undefined desired effect of setting it is important to recognize that the parentheses around the assignment within the conditional are really necessary the precedence of exclamation equals is higher than that of equals which means that in the absence of parentheses the relational test not equals would be done before the assignment so the statement c equals get char not equal eof is equivalent to c equals open parenthesis getchar not equal eof close parenthesis this has the undesired effect of setting c to zero or one depending on whether or not the call of getchar encountered the end of file more on this in chapter 2. the next program counts characters it is a small elaboration of the copy program this sample code is on page 16 of the textbook pound include stdio.h main open parenthesis close parenthesis open curly brace long nc semicolon and c equals 0 semicolon while open parenthesis get char open parentheses close parenthesis exclamation equal eof plus plus nc semicolon printf double quote percent ld backslash n double quote comma nc parentheses semicolon close curly brace the statement plus plus nc semicolon shows a new operator plus plus which means increment by one you could write nc equals nc plus one but plus plus nc is more concise and often more efficient there is a corresponding operator minus minus to decrement by one the operators plus plus and minus minus can either be prefix operators plus plus c and c or postfix and c plus plus these two forms have different values and expressions as will be shown in chapter two but plus plus nc and nc plus plus both increment and c for the moment we'll stick to the prefix form the character counting program accumulates its count in a long variable instead of an int on a pdp 11 the maximum value of an int is 32 767 and it would take relatively little input to overflow that counter if it were declared as an int in honeywell and ibm c long and int are synonymous and much larger the conversion specification percent ld signals to printf that the corresponding argument is a long integer we again as a note we again see another reference to the fact that the number of bits of the int type is in transition in 1978. the older pdp11 used a 16bit integer to save limited memory on a small almost obsolete computer while later computers from ibm and honeywell have already switched to their int type to be 32 bits this allowed code originally for written for the pdp11 like unix or even the c compiler to be recompiled on the ibm or honeywell with very few changes to cope with bigger numbers you can use a double which is a double length float we will also use a for statement instead of a while to illustrate an alternate way to write a while loop this code is the second sample code on page 16 of the textbook pound include stdio.h main open parentheses closed parentheses open curly brace double nc semicolon four open parenthesis nc equals zero semicolon get our open parenthesis close parenthesis not equal eof semicolon plus plus nc close parenthesis and then a semicolon the semicolon in this case is an empty statement because there's nothing in the body of the of the for loop and at the end we say printf double quote percent dot zero f backslash n double quote comma nc close parentheses semicolon close curly bracket printf uses percent f for both float and double percent.0f suppresses printing of the nonexistent fraction part the body of the for loop here is empty because all the work is done in the test and reinitialization parts of the for loop but the grammatical rules of c require that a for statement have a body the isolated simply semicolon technically a null statement is there to satisfy that syntax requirement we put it on a separate line to make it more visible before we leave the character counting program observe that if the input contains no characters the while or for test fails on the very first call to get char so that the loop program produces zero the right answer this is an important observation one of the nice things about while and four is they are tested at the top of the loop proceed before proceeding with the body if there is nothing to do nothing is done even if that means never going through the loop body programs should act intelligently when hand handed input like no characters the while and the four statements help ensure that they do reasonable things with boundary conditions line counting the next program counts lines in its input input lines are assumed to be terminated by the newline character backslash n that has been carefully appended to every line written out this is sample code on line 17 of the textbook pound includes stdio.h main open parenthesis close parenthesis open curly brace int c comma nl semicolon nl equals zero semicolon while open parenthesis open parenthesis c equals get char open parentheses close parenthesis close parenthesis not equal eof close parenthesis if open parenthesis c double equals single quote backslash n single quote close parentheses plus plus nl semicolon printf double quote percent d backslash n double quote comma nl close parentheses semicolon close curly brace the body of the while loop now consists of an if which in turn controls the increment plus plus nl the if statement tests its parenthesized condition and if true does the statement or group of statements inside braces that follow we have again indented to show what is controlled by what the double equal sign in is the c notation for is equal to like fortrans dot eq dot this symbol is used to distinguish the equality test the question being asked from the single equal sign used for assignment since assignment is about twice as frequently used as equality testing in typical c programs it's appropriate that the operator be half as long a single character can be written between single quotes to produce a value equal to the numerical value of the character in the machine's character set this is called a character constant so for example single quote a single quote is a character constant in the ascii character set its value is 65 the internal representation of the character a of course double single quote a single quote is to be preferred over 65 its meaning is obvious and it is independent of a particular character set these escape sequences that are used in character strings are also legal in character constants so in tests and arithmetic expression expressions single quote backslash n single quote stands for the value of a new line character you should note carefully that single quote backslash n is a single quer character and an expressions is equivalent to a single integer on the other hand double quote backslash n double quote is a character string which happens to contain only one character the topics of strings versus characters is discussed further in chapter two the numeric values that are shown for characters are using the ascii character set the character sets in the 1970s were quite intricate most were eight bits long to conserve computer memory and only support a hundred or so latinlike characters this is why early programming languages use special characters like asterisk and curly brace in their syntax very carefully they needed to choose characters that were commonly available on computer keyboards from different manufacturers modern programming languages like python 3 and ruby store internal string values using the unicode character set so they are all able to represent all the characters in all languages around the world modern languages tend to represent 8bit values in the range from 0 to 256 using a byte or similar type python 2 strings were stored as 8 bit bytes and python 3 strings are stored as 32bit unicode characters moving to unicode was a major effort in the python 2 to python 3 transition word counting the fourth in our series of useful programs counts lines words and characters with a loose definition that a word is any sequence of characters that does not contain a blank a tab or a new line this is a very very bare bones version of the unix utility wc this example is on page 18 in the textbook pound include stdio.h pound define yes 1 pound to find no 0. main open parenthesis close parenthesis open curly brace int c comma nl comma nw comma nc come in word inward equals no l equals nw equals nc equals zero while open parenthesis open parenthesis c equals get char not equal to eof open curly brace plus plus nc if parentheses c double equals quote backslash n quote parenthesis plus plus nl if open parenthesis c double equals single quote space single quote double vertical bar c double equals single quote backslash n single quote double vertical bar c equals equals single quote backslash t single quote close parenthesis inward equals no else if open parenthesis inward equal equal no close parenthesis open curly brace inward equals yes semicolon plus plus nw semicolon close curly brace close curly brace printf open parenthesis double quote percent d space percent d space percent d backslash n double quote comma nl comma nw comma nc close curly brace every time the program encounters the first character of a word it counts it the variable inward records whether the program is currently in a word or not initially it is not in a word which which is assigned the value no we prefer the symbolic constants yes and no to the literal values one and zero because they make the program more readable of course in a program as tiny as this it makes little difference but in larger programs the increase of clarity is well worth the modest effort to write it this way to make it more readable you will also find that it's easier to make changes to programs where numbers appear only as symbolic constants the line nl equals nw equals nc equals zero sets all three variables to zero this is not a special case but a consequence of the fact that an assignment has a value and assignments associate right to left it's really as if we had written nc equals open parenthesis nl equals open parenthesis nw equals zero close parentheses close parenthesis semicolon the operator double vertical bar vertical bar vertical bar means or so the line if open parenthesis c double equals single quote space single quote vertical bar vertical bar c double equals single quote backslash n single quote double vertical bar c double equals quote backslash t quote parenthesis says if c is a blank or c is a new line or c is a tab the escape sequence backslash t is a visible representation of the tab character there is a corresponding operator which is double ampersand for and expressions connected by double ampersand or double vertical bar are evaluated left to right and it is guaranteed that the evaluation will stop as true as true soon as the truth or falsehood for the overall expression is known thus if c contains a blank there is no need to test whether contends contains a new line or tab so these tests are not made this isn't particularly important here but is very significant in more complicated situations as we will soon see i would note that the double vertical bar and double ampersand are the norm for boolean operators in c like languages when a new language was being designed it was really easy to just adopt the c convention for logical operators because while they may seem cryptic millions of software developers were already familiar with the operators in this way the relationship between c and c like languages is like the relationship between latin and romance languages including english back to the text the example also shows the c else statement which specifies an alternative action to be done if the condition part of an if statement is false the general form is if open parenthesis expression close parenthesis statement one else statement two one and only one of the two statements associated with an if then else is done if the expression is true statement one is executed if not statement two is executed each statement can actually be in fact quite complicated in the word count problem the one after the else is an if that controls two statements in braces section 1.6 arrays understanding the capabilities and limitations of c arrays is one of the most important topics in our historical look at the c programming language most importantly the number of elements in an array declaration must be a constant at compile time and the size of an array cannot be adjusted using an array declaration while the program's running this inability to automatically resize c arrays as data is added leads to a class of security laws that are generally referred to as buffer overflow where a program reads more data in that can fit into an array and is tricked to overriding other data or code in compromising an application later in this book we will create dynamic arraylike structures in c using pointers and the standard library cialoc function python has support for a nondynamic arrays buffers python buffers are generally not used except for programmers writing library code that talks to lowlevel code written in a language other than python or talking to operating system things like linux the more commonly used python list and dictionary structures can change their sizes automatically as elements are added and deleted at runtime java has support for nondynamic arrays like c which are given a length at the moment they are created and the array length cannot be increased nor decreased without making a new array and copying all the elements from the first to the second array java does provide list and map structures that automatically adjust their length as data is added or removed java has a class called arraylist which can be dynamically extended but provides arraylike linear access it is a list internally but it can be used like an array externally the underlying technique that is used to implement language structures like python's list is dynamic memory allocation in a linked list structure linked lists are one of the most important data structures in all of computer science we will cover dynamic allocation and implementing data structures in c in chapter 6. for now we will merely examine the syntax of c arrays but keep in mind that allocating an array in c is very different than creating a list in python back to the text let us write a program to count the number of occurrences of each digit of white space characters blank tab and new line and all other characters this is an artificial problem to solve but it permits us to illustrate several aspects of c in one program there are 12 categories of input so it is convenient to use an array to hold the number of occurrences of each digit rather than 10 individual variables actually 12 individual variables here is one version of the program on page 21 in the textbook and i would note that as these programs get larger and larger it is harder and harder for you to just listen to me read them and you have to go look at them in the textbook so i recommend that you go check out the textbook in page 20 and find this actual code found include io dot h main open parenthesis closed parenthesis open curly brace int c comma i comma n white comma n other semicolon int n digit open square bracket 10 close square bracket semicolon and white equals n other equals 0 semicolon 4 open parenthesis i equals 0 semicolon i less than 10 semicolon plus plus i open let me close parenthesis end digit open square bracket i close square bracket equals zero semicolon now we're going to have a loop to read all of our input while double open parentheses c equals get char open parenthesis close parentheses and another closed parenthesis not equal eof close parenthesis if open parentheses c greater than or equal to single quote 0 single quote double ampersand c less than or equal single quote 9 single quote close parenthesis plus plus in digit open square bracket c minus single quote 0 single quote close square bracket semicolon else if open parenthesis c double equals space quote space quote or double vertical bar c double equals single quote backslash n single quote double vertical bar c double equals single quote backslash t single quote close parenthesis plus plus and white semicolon else plus plus in other that if statement was a sort of three branches if checking to see if we were doing a digit a white space character or some other character at the end of the while loop or not the end of the while loop and so we say printf parentheses double quote digits equals double quote close parenthesis semicolon now we'll note in this that there is no new line so we can have these print defs kind of concatenate outward without going to a separate line four parenthesis i equals zero semicolon i less than 10 semicolon plus plus i close parenthesis printf double quote space percent d double quote comma n digit open square bracket i close square bracket close parenthesis semicolon printf open parenthesis double quote backslash n white space equals percent d comma other equals percent d backslash n double quote comma and white comma n other closed parentheses semicolon close curly brace let's go through the code the declaration int in digit open square bracket 10 closed square bracket semicolon declares n digit to be an array of 10 integers array of subscripts always start and 0 in c rather than 1 as in fortran or pl1 so the elements are end digit sub zero and digit sub one dot dot dot end digit sub nine square brackets are the sub this is reflected in the for loops which initialize and print the array a subscript can be integer any integer expression which of course includes integer variables like i and integer constants this particular program relies heavily on the properties of character representation of the digits for example if c greater than or equal to single quote 0 single quote double ampersand c less than or equal to single quote 9 single quote close parenthesis determines whether it's a digit that is if the numeric value of the digit and the numeric value of the digit is c minus double quote 0 double quote this only works if double quote 0 double quote 1 etc are positive and increasing order and there's nothing but digits between 0 and 9. fortunately this is true for all conventional character sets by definition arithmetic involving chars and ends converts everything to int before proceeding so char variables and constants are identically essentially identical to instant arithmetic contexts this is quite natural and convenient for example c minus single quote 0 single quote is an integer expression that gives us a value between 0 and 9 an integer value between 0 and 9 corresponding to the character quote 0 quote to quote 9 quote stored in c and is thus a valid subscript for the ten element array and digit the decision as to whether the character is a digit a white space or something else is made by the sequence if open parenthesis c greater than or equal to quote zero quote double ampersand c less than or equal quote zero quote i quote nine quote close parentheses plus plus end digit open square bracket c minus quote zero quote close bracket semicolon else if c double equals single quote or c double equals single quote backslash n or c double equals single quote backslash t plus plus n white else plus plus and other the pattern if in parentheses condition statement else if parentheses conditions statement else statement occurs frequently in programs as a way to express a multiway decision the code is simply read from the top of the bot to until the bottom until some condition is satisfied at that point the corresponding statement part is executed and the entire construction is finished of course statement can be several statements in closed embraces if none of the conditions are satisfied the statement after the final else is executed if present if the final else and statement are omitted as in the word count program no action takes place there can be an arbitrary number of else if condition statements groups between the initial if and the final else as a matter of style it is advisable to format this construction as we have shown with proper indentation so that long decisions do not march off the right side of the page the switch statement to be discussed in chapter 3 provides another way to write multiway branching that is particularly suitable when the condition being tested is simply whether some integer or character expression matches one of a set of constants for contrast we will present a switch version of this program in chapter three functions in c a function is equivalent to a subroutine or function in fortran or a procedure in pl1 pascal etc a function provides a convenient way to encapsulate some computation in a black box which can then be used without worrying about its innards functions are really the only way to cope with the potential complexity of large programs with properly designed functions it is possible to ignore how a job gets done knowing what is done is sufficient c is designed to make the use of functions easy convenient and efficient you will often see a function only a few lines long called only once just because it clarifies some piece of code so far we have used functions like printf getchar and put char that have been provided for us now it's time to write a few of our own since c has no exponentiation operator like the double asterisk of fortran or pl1 let us illustrate the mechanics of function definition by writing a function power open parenthesis m comma n close parenthesis to raise an integer into a positive power n that is the value of power parentheses 2 comma 5 is 32. this function certainly doesn't do the whole job of exponentiation since it only handles positive powers of small integers but it is best to confuse only one issue at a time here is the function power and a main program to exercise it so you can see the whole structure at once this sample code is on page 23 of the textbook pound include stdio.h main open curly brace int i semicolon for for parenthesis i equals 0 semicolon i less than 10 semicolon plus plus i close parentheses printf double quote percent d space percent d space percent d backslash n double quote comma i comma power open parenthesis two comma i close parenthesis comma power open parenthesis negative three comma i close parenthesis close parenthesis semicolon close curly brace the end of the main now we begin the function power open parenthesis x comma n close parenthesis int x comma n semicolon open curly brace int i comma p p equals one four open parenthesis i equals 1 semicolon i less than or equal to n semicolon plus plus i p equals p times x semicolon return open parenthesis p close parenthesis semicolon close curly brace each function has the same form function name open parenthesis argument list if any followed by argument declarations if any followed by the body of the function which includes declarations and statements the functions can appear in either order and in one source file or two if of course the source file appears in two files you will have to say more to compile and load it when it fall appears in one but that's an operating system matter not a language attribute for the moment we'll just assume that both function functions are in the same file so whatever you learned about c programs running them will not change the function power is called twice in the line printf open parenthesis double quote percent d space percent d space percent d backslash n double quote comma i comma power open parenthesis two comma i close parenthesis comma power open parenthesis negative three comma i close parenthesis close parenthesis each call passes two arguments to the power function which each time returns an integer to be formatted and printed in the expression power open parenthesis two comma i is just an integer as two and i are not all functions produce an integer value and we'll take this up in more detail in chapter four in power the arguments have to be cleared appropriately so their types are known before the beginning of the body of the function this is done by the line int x comma n semicolon that follows the function name the argument declarations go between the argument list and the opening left brace each declaration is terminated by a semicolon the names used for power and for its arguments are purely local to power and not accessible to any other functions other routines can use the same names for their variables without conflict this is also true of the variables i and p within the function the i in power is unrelated to the i in main the value that power computes is returned to main by the return statement which is just as in pl1 any expression must occur within the parentheses a function need not return a value a return statement with no expression causes control but no useful value to be returned to the call caller as does falling off the end of a function by reaching the terminating right curly brace section 1.8 arguments call by value one aspect of c function which may be unfamiliar to programmers who are used to other languages particularly fortran and pl1 in c all function arguments are passed by value this means that the called function is given the values of its arguments in temporary variables actually on a stack rather than their addresses this leads to some different properties than are seen with call by reference languages like fortran and pl1 in which the called routine has handled the address of the argument not its value it may seem strange that the authors are calling so much attention to the fact that function arguments are passed call by value in the very first chapter most modern programming languages like python php or java pass single value arguments by value by default and to pass in an argument by reference you need to do something special like adding the ampersand in the function declaration in php passing by reference was the norm before c and passing by value was the norm after c since modern languages were deeply influenced by and often written in c passing by value is the norm for modern languages it's nice because it isolates the data in the calling code from the called code so the called code can't easily mess with its arguments either intentionally or by mistake and create an unexpected side effect and possibly a bug or security flaw in the calling code it was a bit of work to make pass by value work and see c implements a call stack where a bit of memory is automatically allocated at each function call and c makes a copy of the values in the calling code to pass them into the call code in a way that the calling code can see the values and change their local copies without affecting the values in the calling code the same call stack that made it possible for c function arguments to be passed by value also made it possible for a function to call itself recursively fortran functions could not be called recursively until the 1990 version of fortran if you know your python you know that simple variables like integers and strings are passed by value while structured data like dictionaries and lists are passed by reference i.e the called function can modify its arguments we will later see this in c as well talking about call stacks recursive functions and the fact that arrays and structures are called by reference is jumping ahead somewhat so for now let's just remember the author's point that normal valuable values like integers and floats are passed by value in c back to the text the main distinction is that in c the called function cannot alter a variable in the calling function it can only alter its private temporary copy call by value is an asset however not a liability it usually leads to more compact programs with fewer extraneous variables because arguments can be treated as conveniently initialized local variables in the called routine for example here is a version of power which makes use of this fact this code is on page 24 of the text power open parenthesis x comma n close parenthesis and x comma n semicolon open curly brace int i comma p semicolon for open parenthesis p equals one semicolon n greater than zero semicolon minus minus n close parentheses p equals p times x semicolon return open parenthesis p close parenthesis semicolon close curly brace the argument n is used as a temporary variable and is counted down until it becomes zero there is no longer a need for the variable i as in the previous example whatever is done to end inside the power function has no effect on the argument that power was originally called with when necessary it is possible to arrange for a function to modify the variable in the calling routine the caller must provide the address of their variable to be set technically a pointer to the variable and the called function must declare the argument to be a pointer and reference the actual variable indirectly through it we will cover this in detail in chapter 5. when the name of an array is used as an argument the value passed to the function is actually the location or address of the beginning of the array there is no copying of the elements in the array by subscripting this value the function can access and alter any element of the array in the calling code this is the topic of the next section now i would recommend that you're careful looking at the code samples in the rest of this chapter recall that in c array sizes do not grow and shrink dynamically at all after they're allocated the authors statically allocate character arrays capable of handling up to 1 000 characters long their code works but it is somewhat brittle so look at the next two sections as examples of c syntax with many important concepts about character strings stored as arrays and calling patterns when passing arrays to functions as parameters that but not exactly the best practice when handling dynamically sized data back to the text probably the most common type of array in c is an array of characters to illustrate the use of character arrays and functions to manipulate them let's write a program that reads a set of lines and prints the longest the basic outline is simple enough while there's another line if it's longer than the previous longest save it and its length and at the very end print the longest line the outline makes it clear that the program divides naturally into pieces one piece gets a new line another checks it another saves it and then the rest controls the process since things divide so nicely it'd be it would be well to write them that way too accordingly let's write first a separate function called getline to fetch the next line of input this is a generalization of getchar to make the function useful in other contexts we'll try to make it as flexible as possible at the minimum getline has to return a signal but possible end of file a more generally useful design would be to return the length of the lan line or zero if the end of file is encountered zero is never a valid line length since every line has at least one character even a line containing only a new line has length one i would note that here in chapter one we have changed the book's original use of the function name getline to get underscore line in the code examples because it conflicts with stead the stdio.h that defines getline as a library function in this chapter the authors are providing examples around function naming and linking in later chapters code samples will simply use the builtin git line without an underscore to read an input when we find a line that is longer than the previous longest it must be saved somewhere this suggests a second function copy to copy the new line to a safe place finally we need a main program to control getline and copy here is the result the sample code for this is on page 26. and it's a bit long so you might want to show take a look at the sample code in a browser pound include stdio.h pound define max line 1000 main open for an enclosed paren open curly brace int len semicolon which is the current line length int max semicolon which is the maximum length we've seen so far char line open square bracket max line close square bracket semicolon a character array that's the current input line and then char save open square bracket max line close square bracket semicolon which is a character array that has the longest line where we're going to save it onto the code max equals zero while open parenthesis open parenthesis len equals get line open parenthesis line comma max line close parenthesis close parenthesis greater than zero if len is greater than max open curly brace max equals len to save it and then copy line comma save close curly brace if open parenthesis max greater than zero i.e there was a line print f open parenthesis double quote percent s double quote comma save close curly brace to end the main program now we're in the first function get line open parenthesis s comma limb close parenthesis char s open bracket close bracket semicolon since it's being passed in as an argument we don't need to know the length of it and the next argument is int lim semicolon so getline takes a character array of unknown length and a limit that tells us the length of the character array open curly brace int c comma i semicolon four open parenthesis i equals zero semicolon i less than lim minus one double ampersand parenthesis c equals get char open parentheses close parenthesis close parenthesis not equal e o f and double ampersand c not equal single quote backslash n back single quote semicolon plus plus i and in the body of the loop it's s open square bracket i closed square bracket equals c from now on i'll read that s sub i equals c at the end of the loop we say if open parenthesis c double equals single quote backslash n single quote close parenthesis open curly brace s sub i equals c plus plus i close curly brace s sub i equals quote backslash zero quote semicolon return open parenthesis i close parenthesis semicolon close curly brace and that's the end of the get line function and now we're on to the copy function copy open parenthesis s1 s2 close parenthesis the purpose of this function is copy s1 to s2 assume that s2 is big enough the declaration is char s1 open square bracket close square bracket comma s2 open square bracket close square bracket a note these arrays have a size we just don't know what they are and we hope that they're large enough the body of the copy function starts with open curly brace int i semicolon i equals zero while open parenthesis open parenthesis s two sub i equals s one sub i close parenthesis not equal single quote backslash zero single quote plus plus i close curly brace to end the copy function main and getline communicate both through a pair of arguments and a returned value in getline the arguments are declared by the lines char s open square bracket close square bracket semicolon int lim semicolon which specify that the first argument is an array of unknown length and the second is an integer the length of the array s is not specified in getline since it's determined in main getline uses return to send a value back to the caller just as the function power did some functions return a useful value others like copy are only used for their effect and return no value getline puts the character backslash 0 the null character whose integer value is zero at the end of the array it's creating to mark the end of the string of characters this convention is also used by the c compiler with a when a string constant like double quote hello backslash n double quote is written in a c program the compiler creates an array of characters containing the characters of the string and adds a backslash zero at the end to terminate it so that functions such as printf can detect the end so that would lead to an array that has h e l l o backslash n backslash zero so it's a five character array with a new line which is a sixth character and then backslash zero which is an actual character again we don't know the arrays don't know their length and so you use the backslash 0 as the indicator of the end of a string the percent s format specification in printf expects a string represented in exactly this form if you examine copy you will discover that it too relies on the fact that its input argument s1 is terminated by backslash zero and it copies this character backslash zero into the argument output argument s2 all of this implies that backslash 0 is not part of normal text it's merely a marker it is worth mentioning in passing that even a program as small as this one presents some sticky design problems for example what should maine do if it encounters a line which is bigger than its limit getline works properly and then it stops collecting when the array is full even if no new line has been seen by testing the length in the last character returned main can determine whether the line was too long then cope with it as it wishes in interest of brevity we have ignored this issue there is also no way for a user of getline function to know in advance how long an input line might be so getline checks for overflow on the other hand a user of the copy function already knows or should be able to find out how big the strings are so we have have chosen not to add error checking to it section section 1.10 scope external variables the variables in main line save etc are private or local to main because they are declared within main no other function can have direct access to them the same is true of the variables in the other functions for example the variable i in getline is unrelated to the i in copy each local variable in a routine comes into existence only when a function is called and disappears when the function is exited it is for this reason that such variables are usually known as automatic variables following terminology in other languages we'll use the term automatic henceforth to refer to these dynamic local variables chapter 4 discusses the static storage class in which local variables do retain their values between function invocations because automatic variables come and go with function in invocation they do not retain their values from one call to the next and must be explicitly set upon each entry if they are not set they will contain garbage as an alternative to automatic variables it is possible to define variables which are external to all functions that is global variables which can be accessed by name by any function that cares to this function is rather like fortran common or pl1 external because external variables are globally accessible they can be used instead of arguments to communicate data between functions furthermore because external variables remain in existence permanently rather than appearing and disappearing as functions are called and exited they retain their values even after the functions that set them are done an external variable has to be defined outside of any function this allocates actual storage for it the function also must be declared and each function that wants to access it this may be done either by an explicit extern declaration or implicitly by context to make the discussion concrete let's rewrite the longest line program with line save and max as external variables this requires changing the calls declarations and bodies of all three functions this sample code is on page 29 of the textbook and it's pretty long but i'll read it for you pound include stdio.h pound define max line 1000. and we're still outside of main char line open bracket max line close bracket semicolon char save open bracket max line semicolon int max semicolon those are our three global variables starting the main main open friend close paren open curly brace intlen extern int max so we're saying that this is an integer but it's also not to be allocated inside of main extern char save open square bracket close square bracket the line length the length of the save array is defined above so we don't need to define it here max equals zero semicolon while double parenthesis land double left parenthesis len equals get line parenthesis greater than zero parenthesis if parenthesis len greater than max open curly brace max equals len copy open parenthesis no parenthesis semicolon no parameters to copy because it's going to simply talk to the global variables close curly brace after the loop finishes we say if open parenthesis max greater than zero then printf open parentheses double quote percent s double quote comma save close parenthesis semicolon close close curly brace and that is the end of the main so now we have the getline function which is specialized to deal with external variables okay so we start get line open parentheses close parenthesis no parameters open curly brace int comma c comma int c comma i semicolon these are local variables extern char line open curly brace closed curly brace semicolon this is the our reference inside of getline to the global variable line four open parenthesis i equals 0 semicolon i less than max line minus 1 max line minus 1 max line is a predefined constant at compile time for i less than max line 1 double ampersand parenthesis c equals get char open parenthesis close parenthesis close parenthesis not equal eof double ampersand i.e and c not equal single quote backslash n single quote semicolon plus plus i lines sub i equals c that's the for loop that in effect reads characters one at a time and puts them in line after the for loop we say if open parenthesis c double equals single quote backslash n single quote close parentheses open curly brace line sub i equals c plus plus i close curly brace this ensures that we append the new line to the function line sub i equals single quote backslash zero backslash that's semicolon the that's the string termination character return i return open parenthesis i close parentheses this is the length that getline is returning and then close curly brace to end the getline function and then we have the copy function and it's again it takes no parameters copy open parentheses close parenthesis curly brace and i extern char line open bracket close bracket comma save open bracket close bracket semicolon i equals 0 while parentheses open parenthesis open parenthesis save sub i equals line sub i close parenthesis is not equal quote backslash zero quote plus plus i close curly brace for copy so the external variables in main getline and copy are defined by the very first lines in the example above outside of main which state their type and cause storage to be allocated for them syntactically external definitions are just like the declarations we used previously but because they occur outside of any function including outside the main function the variables are external before a function can use or access an external variable the name of the variable must be made known to the function one way to do this is to write an extern declaration in the function the declaration is the same as before except for the added keyword extern in certain circumstances the extern declaration can be admitted omitted if the external definition of the variable occurs in the same source file before it's used in a particular function then there's no need for an extern declaration in the function the extern declarations in main and getline and copy are thus redundant in fact common practice is to place all definition of all external variables at the beginning of the source file and then omit all extern declarations if the program is in several source files and a variable is defined in say file 1 and used in file 2 then an extern declaration is needed in file 2 to connect the two occurrences of the variables this topic is discussed at length in chapter 4. you should note that we are using the words declaration and definition very carefully when we refer to external variables in this section definition refers to the place where the variable is actually created or assigned storage declaration refers to places where the nature of the variable is stated but no storage is allocated by the way there is a tendency to make everything inside an extern variable because it appears to simplify things argument lists are short and variables are always there when you want them but external variables are always there also when you don't want them the style of coding is fraught with peril since it leads to programs whose data connections are not at all obvious variables can be changed in unexpected and even inadvertent ways and the program is hard to modify when it becomes necessary the second version of the longest line program is inferior to the first partly because of these reasons and partly because it destroys the general at generality of two quite useful functions by hardwiring them into the names of the variables they will manipulate section 1.11 summary at this point we have covered what might be called the conventional core of c with this handful of building blocks it's possible to write useful programs of considerable size it probably a good idea if you paused long enough to do so the exercises that follow are intended to give you suggestions for programs of somewhat greater complexity than the ones presented in this chapter after you have this much sea under control it will be well worth your effort to read on for the features covered in the next few chapters are where the power and expressiveness of the language begin to become apparent this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by att but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardwarefirst vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 2 types operators and expressions variables and constants are the basic data objects manipulated in a program declarations list the variables to be used and state what type they have and perhaps what their initial values are operators specify what is to be done to them expressions combine variables and constants to produce new values these are the topics of this chapter section 2.1 variable names although we didn't come out and say so there are some restrictions on variable and symbolic constant names names are made up of letters and digits the first character must be a letter the underscore counts as a letter it is useful for improving the readability of long variable names upper and lower case are different traditional c practice is to use lowercase for variable names in all uppercase for symbolic constants only the first eight characters of an internal name are significant although more may be used for external names such as function names and external variables the number must be less than 8 because external names are used by various assemblers and loaders appendix a lists the details furthermore keywords like if else int float etc are reserved you can't use them as variable names and they must be in lower case i would note that in modern c languages the limitation of the first eight characters of a variable name being unique has been extended in most c variants at least 30 characters of a variable are treated as unique the it character limitation was to reflect the typical limitation of identifier length in assembly language programming and runtime linkers of the time naturally it's wise to choose variable names that mean something that are related to the purpose of the variable and are unlikely to get mixed up typographically section 2.2 data types and sizes there are only a few basic data types in c char which is a single byte capable of holding one character in the local character set and an integer typically reflecting the natural size of integers on the host machine float a single precision floating point and double is a double precision floating point in addition there are a number of qualifiers which can be applied to end short long and unsigned short and long refer to different sizes of integers unsigned numbers obey the arithmetic of modulo 2 to the n where n is the number of bits in an int unsigned numbers are always positive the declarations for qualifiers look like short int x semicolon long int y semicolon unsigned and z semicolon the word in can be omitted in such situations and typically is the precision of these objects depends on the machine at hand the table below shows some representative values on a dec pdp 11 a char is 8 bits on into 16 a short is 16 a char is 32 a float is 32 a double is 64. on a honeywell 6000 which uses ascii character set a char is 9 bits an int is 36 bits as short as 36 bits a char is 36 bits and a float is 36 bits and a double is 32 bits on the ibm 370 which is ebcdic in its character set a char is 8 bits and int is 32 bits as short is 16 bits a char is 32 bits a float is 32 bits and a double is 64 bits and so on the intent is that short and long should provide different lengths of integers where practical int will normally reflect the most natural size of a particular machine as you can see each compiler is free to interpret short and long as appropriate for their own hardware about all you should count on is that short is no longer than long in this table we see that in the mid1970s c was designed to support a range of computer generations the pdp11 was a common previous generation computer that had less memory so variable sizes were kept small the more modern computers in the chart had a bit more memory and could afford to have slightly larger larger sizes the idea of a natural size is the size that could be loaded computed and stored in usually of single machine language instruction you knew as a programmer that when used int the machine code you would generate would not need to include an extra instructions for a simple line of code like x equals x plus one semicolon modern int values in c are 32 bits long and long values are 64 bits long even though modern computers can do 64bit computations in a single instruction using the shorter int type when appropriate can save on memory storage and memory bandwidth using int values interestingly the length of a 32bit int leads to a unix and c problem with dates that is called the year 2038 problem a common way to represent time in unix c programs was as a 32bit integer of the number of seconds since january first 1970. it was quick and easy to compare or add or subtract these second counter dates in code and even in databases but the number of seconds since january 1st 1970 will overflow a 30bit number on the 19th of january in 2038. by now in order to avoid systems in order to avoid problems most systems have converted to storing these number of second values in long or 64bit values which gives us almost 300 billion years until we need to worry about overflowing second timer counters again back when c was developed we had two different character sets and two different character variable lengths the world generally standardized on the ascii character set for the core western characters and the unicode utf8 to represent all characters in all languages worldwide but that is a story for another time for now just think of the char type as also a byte type it is 8 bits in length and can store ascii modern languages like python or java have excellent support for wide character sets in our historical look at c we will not cover wide or multibyte characters also if you look at the float and double types you will see different bit sizes even worse each of these computers in the 1970s did floating point computation using slightly different hardware implementations and the same code run on different computers would give slightly different results and have unpredictable behavior on overflow underflow and other extraordinary floating point operations this was solved by the introduction of the ieee 754 standard in 1985 which standardized floating point format this standardized both the length of the float and the double but also ensured that the same set of floating point calculations would produce the exact same result on different processors 2.3 constants int and float constants have already been disposed of except to note that the usual 123.456 e minus 7 or 0.12 e3 scientific notation for floats is also legal every floating point constant is taken to be double so the e notation serves for both float and double long constants are written in the style 1 2 3 capital l an ordinary integer constant that is too long to fit into an int is also assumed to be a long there is a notation for octal and hexadecimal constants a leading zero on an int constant implies octal and a leading zero x or zero x upper case indicates hexadecimal for example the decimal 31 can be written as 037 in octal and 0x1 f or 0x1 f where f is capitalized in hex hexadecimal and octal constants may also be followed by the letter l to make them long a character constant is a single character written in single quotes as in quote x quote the value of the character constant is the numeric value of the character in the machine's character set for example the ascii character set 0 or quote 0 quote is 48 and an ebcdic quote 0 quote is 240. both quite different from the numeric value zero writing quote zero quote instead of a numeric value like 48 or 240 makes the program independent of the particular value character constants participate in numeric operations just like any other numbers although they are most often used in comparisons with other characters a later section treats conversion rules certain nongraphic characters can be represented in character constants by escape sequence like backslash n for newline backslash t for tab backslash zero for null backslash backslash for backslash itself and backslash quote for single quote etc these look like two characters but they're actually only one in addition an arbitrary byte space bit pattern can be generated by writing single quote backslash and then three digits single quote where the three digits is one to three octal digits as in pound define space form feed single quote backslash zero one four single quote which is ascii for a form feed we mentioned form feed here because in the 1970s we sent much of our output to printers physical printers a form feed was the character we would send to the printer to advance to the top of a new page the character constant quote backslash zero quote represents the character with the value zero quote backslash zero quote is often written instead of zero to emphasize the character nature of some expression a constant expression is an expression that only involves constants such expressions are evaluated at compile time rather than run time and accordingly may be used in any place a constant maybe as in pound define max line 1000 char line open bracket max line plus 1 close bracket semicolon or seconds equals 60 times 60 times hours a string constant is a sequence of zero or more characters surrounded by double quotes as in double quote i space am space a space string double quote or double quote double quote which is a way to show an empty string the quotes are not part of the string but only serve to delimit it the same escape sequences used for character constants apply in strings backslash double quote represents the double quote character technically a string is an array whose elements are single characters the compiler automatically places the null character backslash zero at the end of each such string so programs can conveniently find the end this representation means that there is no real limit on how long a string can be but programs have to scan one to completely determine its length the physical storage required is one more location than the number of characters written between the quotes the following function sterlin taking the parameter s returns the length of the character string s excluding the terminal backslash zero sterling open parentheses s close parenthesis char s open bracket close bracket semicolon open curly brace int space i semicolon i equals zero semicolon while parentheses s sub i exclamation equals quote backslash zero quote close parentheses plus plus i semicolon return parentheses i parentheses semicolon close curly brace be careful to distinguish between the character constant and a string that contains a single character single quote x single quote is not the same as double quote x double quote the former is a single character used to produce the numerical value of the letter x of the machine's character set the latter is a character string that contains one character the letter x and a backslash zero section 2.4 all variables must be declared before use although certain declarations can be made implicitly by context a declaration specifies a type and is followed by a list of one or more variables of that type as in int lower comma upper comma step semicolon char c comma line open bracket 1000 close bracket semicolon variables can be distributed among declaration in any fashion the list above could we could be equally well written as int lower semicolon in upper semicolon in step semicolon char c semicolon char line open bracket 1000 close bracket semicolon the latter form takes more room but it is convenient for adding a comment to each declaration or for subsequent modifications variables may also be initialized in their declaration although there are some restrictions if the name is followed by an equal sign in a constant that serves as an initializer as in char backslash equals single quote backslash backslash single quote semicolon int i equals 0 semicolon float eps equals 1.0 e minus 5 semicolon if the variable in question is external or static the initialization is done once only conceptually before the program starts executing explicitly initialized automatic variables are initialized each time the function they are in is called automatic variables for which there is no explicit initializer have undefined that is garbage values external and static variables are initialized to zero by default but it is a good style to state the initialization anyway we will discuss initialization further as new data types are introduced section 2.5 arithmetic operators the binary operators are plus minus asterisk and slash and the modulus operator percent there is a unary minus but no unary plus integer division truncates any fractional fractional part the expression x percent y produces the remainder when x is divided by y and is thus zero when y divides x exactly for example a year is a leap year if it is divisible by 4 but not by 100 except that years divisible by 4 are leap years therefore if parentheses year percent for equal equal zero and and year percent 100 not equal zero or year percent 400 equal equal zero it's a leap year else it's not the percent operator cannot be applied to float or double the plus and minus operators have the same precedence which is lower than the identical precedence of asterisk slash and percent which are in turn lower than unary minus arithmetic operators group from left to right a table at the end of this chapter summarizes precedence and associativity for all operators the order of evaluation is not specified for associative and commutative operators like asterisk and plus the compiler may rearrange a parenthesized computation involving these thus a plus open parenthesis b plus c closed parenthesis can be evaluated as open parenthesis a plus b close parentheses plus c this rarely makes any difference but if a particular order is required explicit temporary variables might be used the action on overflow or underflow depends on the machine at hand i would note that the above paragraph allows the compiler i would note that the above paragraph allowing the compiler to reorder computations even in the parentheses presence of parentheses is known as the knr c arrangement license as the authors state it almost never makes a difference unless an expression contains a value computed in a function call or is there a pointered lookup to find a value for the computation that might fail the rule was subtly adjusted in the iso version of c but iso c still does not strictly force the order of otherwise commutative operations even in the pr presence of parentheses the good news is that as long as you keep your expression simple you don't have to worry about this rule sometimes the real value of parentheses is to communicate your intentions to the human readers of your code if you are writing code that depends on the order of overflow function calls and pointer dereferences in a single mathematical expression perhaps you should break your expression into multiple statements section 2.6 relational and logical operators the relational operators are greater than greater than or equal less than less than or equal they all have the same precedence just below them in precedence are the equality operators double equals and exclamation equals which have the same precedence relationals have lower precedence than arithmetic operators so expressions like i less than limb minus 1 are taken as i less than open parenthesis limb minus 1 close parenthesis as would be expected more interesting are the logical connectives double ampersand and double vertical bar and an or expressions connected by double ampersand or double vertical bar are evaluated left to right and the evaluation stops as soon as the truth or falsehood of the result is known these properties are critical in writing programs that work for example here is a loop from the input function get line which we wrote in chapter one for parenthesis i equals zero semicolon i less than lim minus one double ampersand parenthesis c equals get char open parenthesis close parenthesis close parenthesis not equal single quote backslash n single quote double ampersand c exclamation equal e o f semicolon plus plus i close parenthesis s sub i equals c clearly before reading a new character it is necessary to check that there's room to store the array so the test i less than lim minus 1 must be made first not only but if this test fails we must not go on and read another character similarly it would be unfortunate if c were tested against eof before getchar was called the call must occur before the character c is checked against dof the precedence of double ampersand and is greater than that of double vertical bar or and both are lower than the relational inequality operators so expressions like i less than limb minus one double ampersand parenthesis c equals char open print close paren close paren not equal single quote backslash n single quote double ampersand c not equal eof needs no extra parenthesis but since the parentheses of not equals is higher than assignment parentheses do need to be added in open print c equals get char open print close paren close print not equal backslash n to achieve the desired result let's take a brief digression one of the great debates of the 1970s was how to use structured programming to avoid any use of goto statements that lead to completely unreadable spaghetti code structured code was easier to read debug and validate structured code advocated for if then else else if while do loops and do while loops where the loop exit test was at the top or the bottom of the loops respectively there was a move from flowcharts with lines boxes and arrows to to structure programming techniques like nashi schneiderman diagrams that you did used nested boxes to emphasize the structured nature of the code the proponents of each approach tended to approach the problem based on the language they used algol and pascal programmers were strong advocates of structured programming and those languages had syntax that encouraged the approach fortran programs had decades of flowchart use and style flowchart style thinking intended to avoid full adoption of structured programming kurdian and ritchie chose a middle path and made it so that c could support both approaches to avoid angering either side of the structure programming debate one area where the structured code movement kept hitting a snag was implementing a loop that reads a file and processes data until it reaches the end file the loop must be able to handle an empty file or no data at all there are three ways to construct a read and process until eof loop and none of the approaches are ideal the loop constructions that you can do are a top tested loop with prime a priming read before the loop a bottom tested loop with a read as the first statement in the loop and then if then else is the rest of the body of the loop a top tested infinite loop with a priming read and a middle test and exit and a top tested loop with a side effect read in the test of the loop which is the way that kernighan and ritchie chose to document in this chapter all of this serves to explain the syntax while open parenthesis open parenthesis c equals get char open paren close print close parenthesis not equal eof close parenthesis open curly brace body of the loop close curly brace this construct is a topped tested loop which most programmers prefer and it folds the priming read and puts its value inside the variable c but since the getchar might also return eof we need to check if we actually receive no data at all and need to avoid executing the body of the loop or exit the loop if eof were defined as zero instead of minus 1. the loop could have been written while open parenthesis c equals get char open paren close paren close parenthesis open curly brace body of the loop close curly brace now the get jar function returns a character or zero and the test itself is looking at the side effect or residual value of the assignment statement to decide to start and or continue the loop body the problem with using zero is end of file if you are reading a binary file like jpeg data a zero character might make perfect sense and we would not want to incorrectly end the loop because of a zero character in input data that does not end a file so we get the double parentheses syntax the side effect call to getchar and test the return value within the while test i'm quite confident that this is far more detail that you wanted here in chapter two but as it is as good a time as any to understand how much thought goes into a programming language how it is designed and documented by the time we finish chapter 3 and look at the break and continue statements which are in languages like python and java you will see that this 50 year old structured programming debate debate is still unresolved in the minds of many software developers back to the book the unary negation operator logical negation operator converts a nonzero or true operand into zero in a zero or false operand into one a common use of exclamation which we often call bang is in constructions like if open parenthesis exclamation point in word close parenthesis rather than if open parenthesis inward equal equals zero it is hard to generalize about which of these two forms is better construction like exclamation inward read quite nicely as if not in word but more complicated ones can be hard to understand section 2.7 type conversions when operands of different types appear in expressions they are converted to a common type according to a small number of rules in general the only conversions that happen automatically are those that make sense such as converting an integer to a floating point in an expression like f plus i expressions that don't make sense like using a float in a subscript are disallowed first chars and inst may be freely intermixed in arithmetic expressions every chart in an expression is automatically converted to an end this permits considerable flexibility in certain kinds of character transformations one is exemplified by the function a to i which converts a string of digits into its numeric equivalent a to y open parenthesis s close parenthesis char s open bracket close bracket semicolon open curly brace int i comma n semicolon n equals zero four parenthesis i equals zero semicolon s sub i greater than or equal to quote zero quote double ampersand s sub i less than or equal to double quote nine quote semicolon plus plus i close parentheses n equals 10 asterisk n plus s sub i minus single quote 0 single quote semicolon return open parenthesis and close parentheses semicolon close curly brace to end the function as we discussed in chapter 1 the expression s sub i minus quote 0 quote gives the numeric value of the character stored in sub i because the values 0 1 etc form a continuously increasing positive sequence positive sequence another example of the card chart in conversion is the function lower which match a single character to lower case for the ascii character set only if the character is not an upper case letter lower is returned unchanged here's a function lower open parentheses c closed parenthesis int c semicolon open curly brace if open parenthesis c greater than or equal to quote capital a quote double ampersand c less than or equal to quote z quote uppercase z parenthesis return open parenthesis c plus quote lowercase a quote minus quote uppercase a quote close parentheses semicolon else return c this works for ascii because the corresponding upper and lowercase letters are a fixed distance apart as numeric values and each alphabet is contiguous there is nothing but letters between a and z this latter observation is not true of the ebcdic character set on ibm 360 370 architectures so this code fails on such systems it converts more than letters there is one subtle point about the conversion of characters to integer the language does not specify whether character where the variables of type char are signed or unsigned quantities when char is converted to an int can it ever produce a negative number unfortunately this varies from machine to machine reflecting differences in architecture on some machines for instance a char whose left most bit is one will be converted to negative integer using sign extension on others a char is promoted to an in by adding zeros at the left end and is thus always positive the definition of c guarantees that any character in the machine standard character set will never appear to be negative so these characters may be used freely in expressions as positive quantities but arbitrary bit patterns stored in character variables may appear to be negative on some machines yet positive on others the most common occurrence of this situation is when the value negative 1 is used for eof consider the code char c semicolon c equals get char open print close paren semicolon if open print c double equals eof close paren dot dot dot on a machine which does not do sign extension c is always positive because it returns a char yet eof is negative as a result this test always fails to avoid this we have been careful to use int instead of char for any variable which holds a value returned by the function getchar the real reason for using int instead of char is not related to any questions of possible sign extensions it is simply that getchar must return all possible characters so that it can be root used to read arbitrary input and in addition a distinct eof value thus its value cannot be represented as a care char but must instead be stored as an int as an aside since the book was written before the getchar function was standardized the text is somewhat vague in this section shortly after the book was published getchar was put into the stdio.h library and declared to return an integer so as to accommodate all possible characters and the integer 1 value to indicate the end file the above code would be better written with c declared as an integer intc semicolon c equals get char open paren close paren semicolon if open print c double equal eof close paren dot dot while the conversion from char to int may or may not have sign extension and yes it still depends on the implementation 50 years later the conversion from into char is predictable with the top bits being simply discarded if you're using the library function get s to read a file line by line we don't need to worry about this conversion since git s returns a pointer to a character array i.e a string it indicates that reach has reached end of file by returning the null pointer i.e there is no more data to give back to the textbook another useful form of automatic type conversions is that relational expressions like i greater than j and logical expressions constructed by double ampersand and double vertical bar and and or respectively are defined to have the value 1 if true and 0 if false thus the assignment is digit equals c greater than or equal to quote 0 quote double ampersand c less than or equal to quote 9 quote sets the variable is digit to 1 if c is a digit and 0 if it's not in the if test of a in a test part of an if while or four true just means nonzero implicit arithmetic conversions would work much as expected in general if an operator likes c or asterisk for multiplication which takes two operators i.e a binary operator if it has operated operands of different types the lower type is promoted to the higher type before the operation proceeds and the result is the higher type more precisely for each arithmetic operator the following sequence of conversion rules is applied char and short are converted to int and float is converted to double then if either operand is double the other is converted to double and the result is double otherwise if either operand is long and the other is converted to long the result is long otherwise if either operand is operand is unsigned the other is converted to unsigned and the result is unsigned otherwise the operands must be int and the result isn't note that all float values in an expression are converted to double all floating point arithmetic in c is done in double precision conversions take place across assignments the value of the right side is converted to the type of the left which is the type of the result a character is converted to an integer either by sign extension or not as described above the reverse operation into char is well behaved excess high order bits are simply discarded thus in int i semicolon char c semicolon i equals c c equals i the value of c is unchanged and this is true whether or not sign extension is involved if x is float and i is int then x equals i and i equals x both cause conversions float to end causes truncation of any fractional part double is converted to float by rounding longer ins are converted to shorter ones by or to charge by dropping excess high order bits since a function argument is an expression type conversions also take place when arguments are passed to functions in particular char and short become int and float becomes double and that is why we have declared function arguments to be int and double even when the function is called with char and float finally explicit type conversions can be forced also we call it coerced in any expression with a construct called the cast in the construction open parenthesis type name close parentheses expression the expression is converted to the named type by the conversion rules above the precise meaning of cast is in fact as if the expression were assigned to a variable of the specified type which is then used in place of the whole construction for example the library square root sqrt expects a double argument and will produce nonsense if inadvertently handed something else so if n is an integer sqrt open parenthesis open parenthesis double close parenthesis n close parenthesis converts n to double before passing it to sqrt note that the cast produces the value of n in the proper type the actual content of n is not altered the cast operator has the same precedence as other unary operations as is summarized in the table at the end of this chapter section 2.8 increment and decrement operators c provides two unusual operators for incrementing and decrementing variables the increment operator plus plus adds one to its operand the decrement operator minus minus subtracts one we have frequently used plus plus increment variables as in if open parentheses c equals equals single quote backslash n single quote closed parenthesis plus plus nl semicolon the unusual aspect is that plus plus and minus minus may be used either as prefix operators ie before the variable as in plus plus n or postfix after the variable n plus plus in both cases the effect is to increment n but the expression the residual value of the expression plus plus n increments n before using its value while n plus plus increments and after its value has been used this means that in a context where the value is used not just the effect plus plus n and n plus plus are different if n is 5 then x equals n plus plus semicolon sets x to 5 the old value but x equals plus plus n semicolon sets x to 6 the new value in both cases n becomes 6. the increment and decrement operators can only be applied to variables an expression like x equals open parenthesis i plus j close parenthesis parenthesis plus plus is illegal in a context where no value is wanted just incrementing effect as in if open parentheses c double equals single quote backslash n single quote close parenthesis and l plus plus semicolon choose prefix or postfix according to taste but there are situations where one or the other is specifically called for for example consider the function squeeze s comma c which removes all occurrences of the character c from the string s squeeze open parenthesis s comma c close parenthesis char s open bracket close bracket semicolon int c semicolon open curly brace int i comma j semicolon for parenthesis i equals j equals zero semicolon s sub i not equal to single quote backslash zero single quote semicolon i plus plus close parentheses if open parenthesis s sub i not equal to c close parenthesis s sub j plus plus close parenthesis equals s sub i and outside the for loop totally s sub j equals backslash quote s sub j equals quote backslash zero quote semicolon close curly brace each time a nonc a character other than what's in the variable c occurs is copied into the current j position and only then is j incremented to be ready for the next character this is exactly equivalent to if open parenthesis s sub i not equal to c close parenthesis open curly brace s sub j equals s sub i semicolon j plus plus semicolon close curly brace another example of a similar construction comes from the getline function we wrote in chapter one where we can replace if open parenthesis c double equals quote backslash n quote close parenthesis open curly brace s sub i equals c semicolon plus plus i semicolon close parenthesis by the far more compact if parentheses c double equals quote backslash end quote close parentheses s sub i plus plus equals c semicolon in a third example the function stir cat concatenates the string t to the end of the string s stir cat does assume that there's enough space in s to hold the combination here's the code stir cat open parentheses s comma t close parenthesis char s open bracket close bracket comma t open bracket close bracket semicolon open curly brace int i comma j semicolon i equals j equals 0 semicolon while open paren s sub i not equal single quote backslash zero single quote close paren i plus plus in this we'd find the end of s while open parenthesis open parenthesis s sub i plus plus equals t sub j plus plus close parenthesis not equal backslash zero close parentheses semicolon that code copies the rest of t into s close curly brace as each character is copied from t to s the postfix plus plus is applied to both i and j to make sure they are in position for the next pass through the loop section 2.9 bitwise logical operators c provides a number of operators for bit manipulation these may not be applied to float or double ampersand is bitwise and vertical bar is bitwise inclusive or carrot is bitwise exclusive or less than less than is left shift and greater than greater than is right shift and tild is one complements and it's a unary operator the bitwise and operator ampersand is often used to mask off some set of bits for example c equals n ampersand 0 1 7 7 sets to 0 all but the lower 7 bits of n the bitwise or operator is used to turn bits on x equals x vertical bar mask sets to 1 the x bits that are set to one in mask you should carefully distinguish the bitwise operator ampersand and vertical bar from the logical connectives double ampersand and double vertical bar which imply left to right evaluation of a truth value for example if x is 1 and y is 2 then x single ampersand y is 0 while x double ampersand y is 1. think about that for a moment the shift operators less than less than and greater than greater than perform left and right shifts respectively of their left operand by the number of bit positions given by the right operand thus x less than less than 2 shifts x left by two positions filling the vacated bits with zero this is the equivalent to multiplication by four right shifting an unsigned quantity fills the vacated bits with zero right shifting a sine quantity will fill the sine bits arithmetic shift on some machines such as pdp 11 and with and with zero bits logical shift on other the unary operator tilled yields the ones complement of an integer that is it converts each one bit into a zero bit and vice versa this operator typically finds use in expressions like x ampersand tilled 077 which masks the last six bits of x to zero note that x ampersand tilde 0 7 7 is independent of word length and is thus preferable to for example x ampersand 0 1 7 7 7 0 0 which assumes that x is a 16 bit quantity the portable form involves no extra cause since killed zero seven seven is a constant expression and thus evaluated at compile time to illustrate the use of sum of the bit operators consider the function get bets open parenthesis x comma p comma n which returns the right adjusted n bit field of x that visit begins at position p we assume that position 0 is at the right end and that n and p are sensible positive values for example get bits open print x comma 4 comma 3 close print returns the three bits in bit positions 4 3 and 2 write adjusted here we go with the code get bits open print x comma p comma n unsigned x comma p comma n semicolon open curly brace return open parenthesis open parenthesis x greater than greater than open parenthesis p plus 1 minus n close parenthesis close parenthesis and ampersand tild open parenthesis till 0 less than less than in closed parenthesis close parenthesis semicolon close curly brace x greater than greater than parenthesis p plus one minus n close parenthesis moves the desired field to the right end of the word declaring the argument to be x declaring the argument x to be unsigned ensures that when it is right shifted vacated bits will be filled with zeros not sign bits regardless of the machine the program is run on tilde zero is all one bits shifting it left n bit positions with tilde 0 left shift tilde 0 less than less than n creates a mask with the zeros in the right most n bits and ones everywhere else complementing that with tilled makes a mask with ones in the right most bits bitwise operators may seem unnecessary for modern computers but if you look at the internal structure of tcpip packets the values are packed very tightly into the headers in order to save space c made it possible to write portable tcpi implementations on a wide range of hardware architectures bitwise operators also play an important role in encryption decryption and checksum calculations modern languages like java and python support bitwise operators following the same patterns that we established in c so that things like tcpip and encryption algorithms can also be implemented in these languages by defining these operators it kept software developers from needing to write nonportable assembly language to implement these lowlevel features in operating systems and libraries section 2.10 assignment operators and expressions expressions such as i equals i plus 2 in which the lefthand side is repeated on the right can be written in the compressed form i plus equals 2 using an assignment operator like plus equals most binary operators operators like plus that have a left and right operand have a corresponding assignment operator op equals where op is one of plus minus asterisk for multiplication slash for division percent for modulo less than less than left shift greater than greater than right shift ampersand bitwise and carrot exclusive or vertical bar bitwise or if e1 and e2 are expressions then e1 operand equals e2 is equivalent to e1 equals e1 operand e2 except that e1 is only computed once note the parentheses around e2 x star equals y plus 1 is actually x equals x times parenthesis y plus 1 close parenthesis rather than x times y plus 1. as an example function bit count counts the number of one bits in its integer argument here's the code bit count open parentheses in close parenthesis unsigned and semicolon open curly brace into b four open parenthesis b equals 0 semicolon and exclamation equals 0 semicolon n greater than greater than equal 1 close parenthesis if open parenthesis in ampersand 0 1 close parenthesis b plus plus semicolon return open print b close print semicolon curly brace quite apart from its conciseness assignment operators have the advantage and that they correspond better to way the way people think we said we say add 2 to i or increment i by 2 not take i add 2 and put the result back in i thus i plus equal to in addition for a complicated expression like yy val open bracket yypv open bracket p3 plus p4 close bracket plus yypv open bracket p1 plus 2 p2 close bracket close bracket plus equals 2 the assignment operator makes it code easier to understand since the reader doesn't have to check painstakingly that too long expressions are indeed the same or wonder why they're not an assignment operator may even help the compiler to produce more efficient code we have already used the fact that the assignments statement has a side effect value and can occur in expressions the most common example is while open parentheses open parenthesis c equals get char open parenthesis close parenthesis close parenthesis exclamation equal eof close parentheses and then the rest of the loop assignments using other assignment operators plus equal minus sql can also occur in expressions although it's a less frequent occurrence the type of an assignment expression is the type of its left operand section 2.11 conditional expressions the statements if parentheses a greater than b close parentheses c equals a semicolon else z equals b semicolon of course compute z in the maximum of a and b the conditional expression written with a ternary operator which is question mark and colon provides an alternate way to write this and similar constructions in the expression e1 question mark e2 colon e3 the expression e1 is evaluated first if it is nonzero true then the expression e2 is evaluated and that is the value of the conditional expression otherwise e3 is evaluated and that is the value only one of e 2 and e 3 are evaluated thus to set the z to set z to the maximum of a and b we say z equals parentheses a greater than b close parentheses question mark a colon b and this implements z equals max of a and b it should be noted that the conditional expression is indeed an expression and can be used just as any other expression if e1 and if e2 and e3 are different types their type of the result is determined by the conversion rules described earlier in this chapter for example if f is a float and n is an end then the expression parentheses n greater than zero closed parenthesis question mark f colon n is of type double regardless of whether n is positive or not parentheses are not necessary around the first expression of a conventional expression since the precedence of question mark colon is very low just above assignment they are advisable anyway however since they make the condition part of the expression easier to see the conditional expression often leads to succinct code for example this loop print prints n elements of an array 10 per line with each column separated by one blank and with each line including the last terminated by exactly one new line here's the code four parentheses i equals zero semicolon i less than n semicolon i plus plus close parentheses printf open parentheses double quote percent 6d percent c double quote comma a sub i comma open parenthesis i percent 10 double equal 9 or double vertical bar i double equal n minus 1 close parenthesis question mark single quote backslash n single quote colon single quote space single quote close parenthesis semicolon a new line is printed after every tenth element and after the nth and all elements are followed by one blank although this might look tricky it's instructive to try to write it without the conditional expression section 2.12 precedence in order of evaluation the table below summarizes the rules for precedence and associativity of all operators including those which we have not yet discussed operators on the same line have the same precedence rows are in order of decreasing precedence so for example asterisk slash and percent all have the same precedence which is higher than that of plus and minus parentheses square brackets the arrow operator and the dot operator are first with the right left to right associativity next precedence is exclamation tilled plus plus minus minus single minus the cast multiplication bitwise and size of with left with right to left associativity then multiplication division and modulo with left right associativity then plus and minus with left to right associativity then left shift which is less than less than and right shift which is right greater than greater than with left to right associativity then logical operators less than less than or equal to greater than or greater than or equal to with left to right associativity then comparison double equals not equal exclamation equal left to right then we have some bitwise operators the bitwise and with left to right associativity then the bitwise exclusive or with left right associativity which is a carrot then the single vertical bar which is bitwise or with left to right associativity then we have amber sand ampersand which is and the logical and left to right associativity then double vertical bar which is the logical or with left to right associativity then the ternary operator which is question mark and colon with right to left associativity then the assignments equals plus equals minus sets equals etc with right to left associativity and then the comma which we'll cover in the next chapter with left to right associativity the operators dash greater than and dot are used to access members of structures they'll be covered in chapter six along with size of in chat and then in chapter five we'll discuss asterisk indirection and ampersand address of note that the precedence of the bitwise logical operators ampersand carrot and vertical bar falls below double equals and exclamation equals that this implies that bis bit testing expressions like if parentheses parentheses x ampersand mass close parenthesis equal equals zero close parenthesis must be fully parenthesized to get proper results as mentioned before expressions involving one or more of the associative and commutative operators like multiply plus bit y z end bit lies orbit li and bitwise exclusive or can be rearranged even when parenthesized in most cases this makes no difference whatsoever in situations where it might explicit temporary variables can use to force a particular order of evaluation c like most languages does not specify in what order operands of an operator are evaluated for example in a statement like x equals f open parentheses close parentheses plus g open parentheses close parenthesis semicolon f may be evaluated before v g or vice versa thus if f or g alters an external variable that the other depends on x can depend on the order value of evaluation again intermediate results can be stored in temporary variables to ensure a particular sequence similarly the order which function arguments are evaluated is not specified so the statement printf open parentheses double quote percent d space percent d backslash n double quote comma plus plus n comma power open parenthesis two comma n close parentheses close parentheses is wrong it can and often does produce different results on different machines depending on whether or not n is incremented before power is called the solution of course is to write plus plus n semicolon printf open parentheses double quote percent d space percent d backslash n double quote comma n comma power open parenthesis two comma n close parentheses close parenthesis function calls nested assignment statements and increment and decrement operators cause side effects some variables change as a byproduct of the evaluation of an expression in any expression involving side effects there can be subtle dependencies on the order in which variables taking part in the expression are stored one unhappy situation is typified by the statement a sub i equals i plus plus the question is whether or not the subscript is the old value of i or the new value the compiler can do this in different ways and generate different answers depending on its interpretation when side effects i.e assignment to actual variables takes place is left to the discretion of the compiler since the best order strongly depends on machine architecture the moral of this discussion is writing code which depends on the order of evaluation is a bad programming practice in any language naturally it is necessary to know what things to avoid but if you don't know how they are done on various machines that innocence may help to protect you the c verifier lint will detect most dependencies on order of evaluation i would add that the real moral of the story is to use side effect operators very carefully they are generally only used in idiomatic situations and then use it written using simple code the authors are happy to tell you everything that you can do and see in great detail and they are also suggesting that just because you can do something does not mean that you should do something remember that a key aspect of writing programs is to communicate with future human readers of your code including you reading your own code in the future with modern day compilers and optimizers you gain little performance by writing dense or obtuse code write the code describe what you want done and let the compiler find the best way to do it one of the reasons that a common senior project in many computer science degrees was to write a compiler is to make sure that all computer scientists understand that they can trust the compiler to generate great code this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 3 control flow the control flow statements of a language specify the order in which the computations are done we have already met the most common control flow constructions of c in earlier examples here we will complete the set and be more precise about the ones discussed above 3.1 statements and blocks an expression such as x equals zero or i plus plus or printf open paren dot dot dot close paren becomes a statement when it is followed by a semicolon as in x equals zero semicolon i plus plus semicolon printf open parentheses something closed parentheses semicolon in c the semicolon is a statement terminator rather than a separator as it is in algol like languages the braces the curly braces open curly brace and closed curly brace are used to group declarations and statements together into a compound statement or block so that they are syntactically equivalent to a single statement the braces that actually surround the statements of a function are one obvious example braces around multiple statements after an if else while or four are another variables can actually be declared inside any block we will talk about this in chapter four there is never a semicolon after the right curly brace that ends the block ah see how do i love thee let me count the ways quote by dr chuck with homage to elizabeth barrett browning the humble semicolon is why spacing and line ends do not matter in c and c like languages it means that we as programmers can focus all of our white space and line ends on communicating our intent to humans this freedom is not an excuse to write obtuse code or dense code for example see the obfusicated pearl contest but instead freedom to describe what we mean or use spacing to help us understand or maintain our code we can take a quick look at how a few other c like languages that came after c treat the semicolon java is just like c in that the semicolon terminates statements python treats the semicolon as a separator like alcohol allowing more than one statement on a single line but since python treats the end of a line as a statement separator you generally never use semicolon in python but for people like me who automatically add a semicolon when typing code too fast at least python ignores the few semicolons i mistakenly add to my code out of habit javascript treats the semicolon as a separator but since javascript ignores the end of the line it's treated as white space semicolons are required when a block of code consists of more than one statement when i write javascript i meticulously include semicolons at the end of all statements because any good programmer can write c in any language back to the text 3.2 if else the ifl statement is used to make decisions formally the syntax is if parentheses expression parentheses statement 1 else statement 2 where the else part is optional the expression in parentheses is evaluated if it evaluates to true that is the expression has a nonzero value statement one is done if it is false the expression is zero and there's an else part statement two is executed instead since an if simply tests the numeric value of the expression certain coding shortcuts are possible the most obvious is writing if open parentheses expression instead of if open parenthesis expression not equal zero close parenthesis sometimes this is natural and clear other times it's cryptic because the else part of an if else is optional there is an ambiguity when an else is omitted from a nested if sequence this is resolved the usual way the else is a cl associated with the closest closest previous else list if for example if open parenthesis n greater than zero closed parenthesis if open parenthesis a greater than b close parentheses z equals a semicolon else z equals b the else with the z equals b goes with the inner if as we have shown by the indentation in the above example if that's not what you want braces must be used to force the proper association if n greater than zero open curly brace if a greater than b z equals a semicolon closed curly brace else z equals b this ambiguity is especially pernicious in situations like if open parenthesis n greater than zero for open parenthesis i equals 0 semicolon i less than n semicolon i plus plus closed parenthesis if open parenthesis s sub i greater than 0 close parentheses open curly brace printf string dot parenthesis semicolon return open parenthesis i close parenthesis semicolon close curly brace else and this is where it's wrong printf open parenthesis error and is zero closed parenthesis semicolon the indentation in the above example shows unequivocally what you want but the compiler does not get the message and associates the else with the inner if this bug can be very hard to find by the way notice that there is a semicolon after z equals a in if open parenthesis a greater than b close parenthesis z equals a semicolon else z equals b semicolon that is because grammatically a statement follows the if and an expression like z equals a is always terminated by a semicolon section 3.3 else if the construction if open parenthesis expression close parentheses statement else blank if open parentheses expression close parentheses statement else if open parenthesis expression close parentheses statement else statement occurs so often that it's worth a brief separate discussion the sequence of ifs is the most general way of writing a multiway decision the expressions are evaluated in order if any expression is true the statement associated with it is executed and this terminates the whole chain the code for each statement is either a single statement or a group of statements in phrases the last else handles the none of the above or default case where none of the other conditions was satisfied sometimes there is no explicit action for the default in that case the trailing else statement can be omitted or it may be used for error checking to catch an impossible condition to illustrate threeway decision here is a binary search function that decides if a particular value x occurs in the sorted array v the elements of v must be in increasing order the function returns the position a number between 0 and n minus 1 if x occurs in v n minus 1 if not this sample code is on page 54. it is the first example on page 54 in the book binary open parenthesis x comma v comma n close parenthesis int x comma v open square bracket close square bracket comma n semicolon open curly brace int low comma high comma mid semicolon low equals zero semicolon high equals n minus one semicolon while open parenthesis low less than or equal to high close parenthesis open curly brace mid equals open parenthesis low plus high close parenthesis slash 2 semicolon if open parenthesis x less than v submid close parenthesis high equals mid minus 1 semicolon else if open parenthesis x greater than v sub mid close parenthesis low equals mid plus one else return open parenthesis mid close parenthesis semicolon close curly brace closing the while and then return open parenthesis 1 close parentheses semicolon close curly brace to end the function the fundamental decision in this code is whether x is less than greater than or equal to the middle element v submit at each step this is a natural for elsa i would note that in the above examples the else and the if in c are two language constructs that are just being used idiomatically to construct a multiway branch or else if pattern with indentation that captures the idiom if we are pedantic about the indentation above the of the above sequence we would be separating the else and if and indenting each succeeding block further as follows with brackets or added for clarity if open parenthesis expression close parentheo parentheses open curly brace statement close curly brace else open curly brace if open parenthesis expression close parenthesis open curly brace statement close curly brace else open curly brace and now we're quite indented at this point if open parenthesis expression close parentheses open curly brace statement closed curly brace else open curly brace statement close curly brace close curly brace glows curly brace java and javascript keep the else and if as separate language elements and document their idiomatic usage and indentation just like c but in python life is a single keyword in a new language construct that achieves the same idiom as shown below if open parenthesis expression close parentheses colon block lf open parenthesis expression close parenthesis colon block alif if lf parentheses expression parentheses colon block else colon block the c java javascript and python idioms thankfully look the same when the idiomatic indentation is used even fortran 77 supports elf the else if construct to implement multiway logic section 3.4 switch the switch statement is a special multiway decision maker that tests whether an expression matches one of a number of constant values and branches accordingly in chapter one we wrote a program to count the occurrences of each digit white space and all other characters using a sequence of if else if else here's the same program with a switch this is the first example program on page 55. pound include less than stdio.h main open parentheses closed parenthesis open curly brace int c comma i come n white comma n other comma n digit open square bracket 10 close square bracket a 10 element array and white equals and other equals 0 for i equals 0 i less than 10 i plus plus and digit sub i equals 0. while parentheses parenthesis c equals get char open paren close paren close paren not equal e o f close paren switch open parentheses c close parenthesis open curly brace case quote zero quote colon case quote one quote colon case quote two qu quote colon case quote three quote colon case quote four quote colon case quote five quote colon case quote six quote colon case quote seven quote colon case quote eight quote colon case quote nine quote colon end digit sub c minus quote zero quote close bracket plus plus break now that that bit of code right there was to take all the of zero through nine and guide it to the line of code that incremented the particular element of the end digit array by one continuing after the break semicolon case quote space quote colon case quote backslash end quote colon case quote backslash t quote colon and white plus plus semicolon break default colon and other plus plus colon break semicolon close curly brace print f open parenthesis double quote digits equals double quote close parenthesis semicolon 4 open print i equals 0 i less than 10 i semicolon i plus plus close parenthesis printf open parenthesis percent space percent d close double quote comma end digit sub i close parenthesis semicolon printf quote backslash n white space equals percent d comma other equals percent d backslash n double quote comma and white comma n other closed parenthesis semicolon close curly brace the switch statement evaluates the integer expression in parentheses in this case the character c and compares its value simultaneously to all the cases each case must be labeled by an integer or character constant or constant expression if a case matches the expression value execution starts at that case the case labeled default is executed if none of the other cases is satisfied default is optional if there isn't if it isn't there and none of the cases matches no action at all takes place cases in default can occur in any order cases must all be different the break statement causes an immediate exit from the switch because the cases serve as labels after the code for one case is done execution falls through to the next unless you take explicit action to escape break and return are the most common ways to leave a switch a break statement can be used to force an immediate exit from a while four and do loops as well as will be discussed later in this chapter falling through the cases is a mixed blessing on the positive side it allows multiple cases for a single action as with blank tab or new line in this example but it also implies that normally each case what must end with a break to prevent falling through to the next falling through from one case to another is not robust being prone to disintegration when the program is modified with the exception of multiple labels for a single computation fall throughs should be used sparingly as a matter of good form put a break after the last case in this case default although it's logically unnecessary someday when another case gets added at the end this bit of defensive programming will save you uh the switch statement what is there to say i think that the switch statement was added to c c to compete with the earlier fortran computed go to statement or just to keep low level assembly language programmers from switching into assembly language to implement the concept of a branch table the authors spend most of the previous section apologizing for the switch statement so you should perhaps take this as a hint and never use it there are very few situations where a branch table outperforms a series of this if then else checks and those are likely deep in a library or operating system code programmers should only use switch if they understand what a branch table is and why a branch table is more efficient for the particular bit of a program they're writing otherwise just use elsif and do the readers of your code a favor 3.5 loops while and four we have already excounted the while and for loops in while open parenthesis expression close parentheses statement the expression is evaluated if it is nonzero the statement is executed and the expression is reevaluated this cycle continues until the expression becomes a zero at which point execution return resumes after the statement the for statement four open parenthesis expression one semicolon expression two semicolon expression three closed parentheses statement is equivalent to expression one semicolon while open parenthesis expression two closed parenthesis open curly brace statement expression three semicolon close curly brace grammatically the three components of the four are expressions most commonly expression one and expression three are assignments or function calls and expression two is a relational expression any of the three parts can be omitted although the semicolons must remain expression if expression one or expression three is left out it is simply dropped from the expansion if the test expression two is not present it is taken as permanently true so the code for open parenthesis semicolon semicolon closed parenthesis open curly brace dot dot close curly brace is an infinite loop presumably to be broken by some other means such as a break or a return whether to use while or for is largely a matter of taste for example in the code while open parentheses open parenthesis c equals get char open paren close paren close parenthesis equal equal quote space quote or c equal equal quote backslash end quote or c equal equal quote backslash t quote close parentheses semicolon skipping white characters there is no initialization or reinitialization so a while seems more natural the four is clearly superior when there is simple initialization and reinitialization since it keeps the loop control statements close together and visible at the top of the loop this is the most obvious in 4 open paren i equals 0 semicolon i less than n semicolon i plus plus close paren which is the c idiom for processing the first n elements of an array the analog of a fortran or pl1 do loop the analogy is not perfect however since the limits of a for loop can be altered within the loop and the controlling variable i retains its value when the loop terminates for any reason because the components of the four are arbitrary expressions for loops are not restricted to arithmetic progressions nonetheless is bad style to force unrelated computations into a four it is best reserved for loot control operations as a larger example here is another version of the a to i function for converting a string to its numeric equivalent this one is more general it copes with optional leading white space and an optional plus or minus sign chapter 4 shows a to f which does the same conversion for floating point numbers the basic structure of the program reflects the form of the input skip white space if any get the sign if any get the integer part and convert it each step does its part and leaves a clean slate for the next the whole process terminates on the first character that would not be part of a number this is the first example on page 58 of the textbook a to i open paren s close paren which is going to convert s to an integer char s open square bracket close square bracket semicolon open curly brace int i comma n comma sine semicolon 4 i equals 0 s sub i equal equal quote space quote or s sub i equals equals quote backslash end quote or s sub i equals equals backslash quote backslash t quote semicolon i plus plus semicolon skip white space this is a for loop with an empty loop body sine equals one semicolon if s sub i equal equal plus or s sub i equal equal quote minus quote close parenthesis sine equals and here we use a ternary operator open parentheses s sub i plus plus equal equal quote plus quote close parenthesis question mark 1 colon minus 1 semicolon for open parentheses n equals 0 semicolon s sub i greater than or equal to quote 0 quote and s sub i less than or equal to quote 9 quote i plus plus close parenthesis n equals 10 times n plus s sub i minus quote 0 quote semicolon return open parenthesis sine times n close parenthesis semicolon close curly brace to end the function the advantages of keeping loop control centralized are even more obvious when there are separate several nested loops the following function is a shell sort for sorting an array of integers the basic idea of the shell sort is that in early stages far apart elements are compared rather than adjacent ones as in simple interchange sorts this tends to eliminate large amounts of disorder quickly so later stages have less work to do the interval between the compared elements is gradually decreased to 1 at which point the sort becomes an effectively an adjacent interchange method this sample code is the second example in page 58 of the textbook shell open parentheses v comma and close parenthesis int v open square bracket close square bracket comma n semicolon open curly brace int gap comma i comma j comma temp four open paren gap equals n divided by two semicolon gap greater than zero semicolon gap slash equals to close parenthesis 4 open parenthesis i equals gap semicolon i less than n i plus close parenthesis 4 and now we're 3d nested in the for loops 4 open parenthesis j equals i minus gap semicolon j greater than or equal to 0 and v sub j greater than v sub j plus gap semicolon j minus equals gap close parenthesis open curly brace temp equals v sub j v sub j equals v sub j plus gap semicolon v sub j plus gap equals temp semicolon just a swap of v and v b sub j plus gap p sub j and v sub j plus cap close curly brace and that close the inner innermost for loop and and then the next closed curly brace closes the function there are three nested loops the outermost loop controls the gap between the compared elements shrinking it from n over two by a factor of two each pass until it becomes zero the middle loop compares each pair of elements that is separated by cap the innermost loop reverses any elements that are out of order since gap is eventually reduced to one all elements are eventually ordered correctly note that the generality of the 4 makes the outer loop fit the same form as the others even though it is not an arithmetic progression one final c operator is the comma which most often finds use in the for statement a pair of expressions separated by a comma is evaluated left to right and the type and value of the result are the type and value of the right operand thus in a for statement it is possible to place multiple expressions in the various parts for example to process two parallel indices this is illustrated in the function reverse which reverses the function string in place this code is from page 59 of the textbook and it is the first example on page 59. pound include less than string.h greater than reverse open paren s close paren char s open square bracket close square bracket semicolon open curly brace int c comma i comma j for open parenthesis i equals zero comma j equals stirling sub s minus one semicolon i less than j semicolon i plus plus comma j minus minus close parenthesis open curly brace c equals s sub i s sub i equals s sub j semicolon s sub j equals c semicolon close curly brace close curly brace to end the function the commas that separate the function arguments variables declarations etc are not comma operators and do not guarantee left to right evaluation section 3.6 loops do while the while and for loops share the desirable attribute of testing the termination condition at the top rather than at the bottom as we discussed in chapter one the third loop in c the do while tests at the bottom after making each pass through the loop body the body is always executed at least once the syntax is as follows do statement while open parenthesis expression close parenthesis semicolon the statement is executed then the expression is evaluated if it is true statement is evaluated again and so on if the expression becomes false the loop terminates as might be expected do while is much less used than while in four accounting perhaps five percent of all loops nonetheless it is from time to time valuable as the following as in the following function i to a which converts a number to a character string the inverse of a to i the job is slightly more complicated than it might be thought at first because the easy methods of generating the digits generate them in the wrong order we've chosen to generate the string backwards and then reverse it this is the first sample code on page 61 page 60 of the textbook i to a open parenthesis n comma s close parenthesis char s open square bracket close square bracket semicolon int n semicolon open curly brace int i comma sine semicolon if open parenthesis open parenthesis sine equals n close parenthesis less than zero close parenthesis n equals minus n semicolon that's a bit of a complex if i would say there it has an assignment statement that both copies n into sine and then evaluates as to whether or not it's less than zero the n or sign is less than zero because it's a side effect assignment statement for the residual value but the net result is sign contains n and then it's negated um then n is made positive so continuing i equals 0 semicolon do open curly brace s sub i plus plus equals n modulo 10 plus quote 0 quote semicolon close curly brace while parenthesis parenthesis n slash equals 10 close parenthesis greater than zero close parenthesis semicolon if open parenthesis sine less than zero close parenthesis s sub i plus plus equals quote dash quote or minus sign semicolon s sub i equals quote 0 quote semicolon in a sense to terminate the string and then we call the function reverse reverse open parenthesis s close parenthesis semicolon close curly brace the do while is necessary or at least convenient since at least one character must be installed in the array s regardless of the value of n we have also used braces around the single statement that makes up the body of the do while even though they are unnecessary so the hasty reader will not mistaken mistake the while part for the beginning of a while loop i would note that it's important for any language to provide top tested loops and bottom tested loops but don't feel bad if you write code for years and never feel like a bottom tested loop is the right way to solve a problem you're facing it is usually rare to write a loop that you insist will run once regardless of its input data section 3.7 break it is sometimes convenient to be able to control loop exits other than by testing at the top or the bottom the break statement provides an early exit from a for while or do just as it does from the switch statement a break statement causes the innermost enclosing loop or switch to be executed immediately the following program removes trailing blanks and tabs from the end of each line of input using a break to exit from a loop when the rightmost character is nonblank nontab is found this example code is on page 61 of the textbook and it is the first example on that page pound include less than stdio.h pound define max line 1000 main open parenthesis close parenthesis open curly brace int n semicolon char line open bracket max line close bracket semicolon while open paren open paren n equals get line open paren line comma max line close paren close brand greater than zero close brand open curly brace while open cur open parenthesis minus minus n greater than or equal to zero close parenthesis if open parenthesis line sub n not equals a quote space quote and line sub n not equal quote backslash t quote and line sub n not equal quote backslash end quote close parenthesis break line sub n plus one equals quote backslash zero quote semicolon printf double quote percent s backslash n double quote comma line close parenthesis semicolon close curly brace to end the while and then close curly brace to end the main getline returns the length of the line the inner while loop starts at the last character of line recall that minus minus n decrements end before using the value and scans backwards looking for the first character that is not a blank tab or new line the loop is broken when one is found or when n becomes negative that is when the entire line has been scanned you should verify that this is the correct behavior even when the line contains only white space characters an alternative to break is to put the testing in the loop itself while open parenthesis open parenthesis n equals get line open parenthesis line comma max line close parenthesis close parenthesis greater than zero close parenthesis open curly brace while open paren minus minus n greater than equal to zero and open for n line sub n equal equal quote space quote or line sub n equals quote backslash t quote or line sub n equals quote backslash n quote close paren close paren semicolon dot dot close curly brace this is inferior to the previous version because the test is harder to understand tests which require a mixture of and or not and parentheses should generally be avoided 3.8 continue the continue statement is related to break but less often used it causes the next iteration of the enclosing loop for a while or do to begin in the while and do this means that the test part is executed immediately in the four control passes to the reinitialization step control by the way continue applies only to loops not to switch a continue inside a switch statement inside of a loop causes the next loop iteration as an example this fragment processes only positive elements in the array a negative values are skipped 4 open paren i equals 0 semicolon i less than n semicolon i plus plus close paren open curly brace if open paren a sub i less than 0 close paren continue this line skips the negative elements and then the rest of the body of the loop taut is will run only for the positive elements of the loop and the loop finishes with a close curly brace the continue statement is often used when part of the loop that follows is complicated so that reversing a test and indenting another level would nest the program too deeply it's time for a bit of an aside now that we have seen the break and continue language structures in c that also have made it into c like languages and learned about middle tested loops it is time to revisit the structured programming debate and the need for priming operations when a program must process all data until it finishes and still handle the there is no data at all situation in the previous chapter the author somewhat skirted the issue by using a top tested while loop and a side effect statement with residual value that was compared to eof to decide when to exit the loop int c colon while open parenthesis open parenthesis c equals get char open paren close paren close parenthesis not equal eof close parenthesis open curly brace process your data close curly brace and just for fun now that we do know about the for loop let's rewrite this loop as a for loop to make sure we really understand how for loops work in c semicolon for friend c equals get char open print close print semicolon c not equal eof semicolon c equals get char open print close paren close paren curly brace process your data close curly brace for the for loop now you will almost never see a read all characters until eof written this way because because it is not the way knr told us knr told us to reuse a while loop for this but the for loop formulation is probably clearer to many than the while formulation especially to a reader who's not familiar with the assignment side effect idiom commonly used in c in particular the four formulation does not require that the assignment statement has a residual value of the value that was assigned the first part of the four is a priming read the second part of the four is a top text tested exit criteria that works both for no data and after all data has been read and processed and the third part of the four is done at the bottom of the loop to advance to the next character or encounter eof before going back to the top and doing the loop test the call to get char is done twice in the for formulation of the read all available data loop and while we don't like to repeat ourselves in code it is a if it is a small and obvious bit of code perhaps this code is more clear with a bit of repetition so with all this is background you can take this page of the document and sit down with a friend at a coffee shop and debate as long as you like about which is the better formulation for the read all available data but if at that coffee shop you asked dr chuck's opinion neither of these is ideal because in the real world we build data oriented loops that usually do a lot more than get one character from standard input my formulation of a data loop will upset the structured programming purists and probably upset kernighan enrichy as well but i write code in the real world so here is my version int c semicolon while open paren one close print open curly brace c equals get char if open friends c double equals eof close paren break process your data and then close curly brace to end the loop and if i wanted to skip blanks and new lines i could use both break and continue further angered angering the structured programming purists int c semicolon while open parenthesis one closed parenthesis open curly brace c equals get char open parenthesis close parenthesis semicolon if open parenthesis c equal equal eof close parenthesis break if open parenthesis c equal equal quote space quote or c equal equal quote backslash end quote close parenthesis continue then process your data close parenthesis i use this middle tested approach because usually the data i am processing is coming from a more complex source than the keyboard and i don't want a function with two to three parameters stuck inside of a sine side effect statement in a while test and also sometimes you want to exit loop not just based on the return value from the function but instead based on the complex structure that came back from the function itself as these data processing loops get more complex the middle tested loop is a tried and true pattern even kernighan and ritchie point out its benefits above and with that i have now triggered endless coffee shop conversations about the best way to write a data handling loop section 3.9 go to's and labels c provides the infinitely abusable goto statement and labels to branch to formally the goto is never necessary and in practice it is almost always easy to write code without it we have not used go to in this book nevertheless we will suggest a few situations where goto's might find a place the most common use is to abandon processing in some deeply nested structure such as breaking out of two loops at once the break statement cannot be used directly since it leaves the only the most inter innermost loop thus four open parentheses.close parenthesis four open parenthesis.close parenthesis open curly brace do some stuff if open parenthesis disaster close parenthesis go to error semicolon close curly brace dot dot dot dot dot and then error colon and then clean up the mess this organization is handy if the error handling code is nontrivial and if errors can occur in several places a label has the same form as a variable name and is followed by a colon it can be attached to any statement in the same function as the go to another example consider the possibility of finding the first negative element in a twodimensional array multidimensional arrays are discussed in chapter five one possibility is four open parenthesis i equals zero semicolon i less than n semicolon i plus plus close parentheses four open parenthesis j equals zero semicolon j less than m semicolon j plus plus close parenthesis if open parenthesis v sub i sub j less than zero close parenthesis go to found other one and then you handle and you keep going and then found colon include is where it comes to uh jumps to code involving a go to can always be written without want but though perhaps at the price of somewhat repeated tests or an extra variable for example the array search becomes found equals zero four open parenthesis i equals zero semicolon i less than n ampersand ampersand exclamation found semicolon i plus plus four open parenthesis j equals zero semicolon j less than m ampersand ampersand exclamation found semicolon j plus plus found equals v sub i sub j less than zero if found continue else not found although we are not dogmatic about the matter it does seem that go to go to statements should not should be used sparingly at if at all i would add before we leave control flow i need to say that i agree with structured programming experts as well as kernighan and ritchie in that the goto is universally a bad idea there are a lot of little details that make them a real problem things like how the stack works in function calls and how code blocks happen and patching the stack up correctly when a go to happens in the middle of a deeply nested mess you might be tempted to use a go to when you want to exit multiple nested loops in a single statement break and continue only exit the innermost loop the authors use this example above but are quite lukewarm when describing it as the use of go to usually if your problem is that complex putting things in a function and using return or adding a few if statements is a better choice the dr chuck middle tested loop data processing solves this because the loop is always the innermost loop also as new languages were built the concept of exceptions became part of language design and was by a by far more elegant solution to a path of some deeply nested code that just needs to get out so most of the time you think the goto might be a good idea you should lean towards a throw catch pattern to make your intention clear it is one of the reasons why we prefer languages like java or python over c when writing general purpose code this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 4 functions in program structure functions break large computing tasks into smaller ones and enable people to build on what others have done instead of starting over from scratch appropriate functions can often hide details of operation from parts of the program that don't need to know about them thus clarifying the whole and easing the pain of making changes c has been designed to make functions efficient and easy to use c programs generally consist of numerous small functions rather than a few big ones a program may reside on one or more source files in any convenient way the source files may be compiled separately and loaded together along with previously compiled functions from libraries we will not go into that process here since the details vary according to the local system most programmers are familiar with library functions for input and output like get char input chart and numerical computations like sine cosine and square root in this chapter we will show more about writing new functions 4.1 basics to begin let us design and write a program to print each line of input that contains a particular pattern or string of characters this is a special function of the unix utility program grap for example searching for the pattern the in the set of lines now is the time for all good men to come to the aid of their party we'll produce the output now is the time men to come to the aid of their party the basic structure of the task falls neatly into three pieces while there's another line if that line contains a pattern print it although it's certainly possible to put the code for all of this in one main routine a better way is to use the natural structure to advantage by making each part a separate function three small pieces are easier to deal with than the one big one because irrelevant details can be buried in the functions and the chance of unwanted interactions minimized and the pieces might even be useful later in their own right while there is another line is getline a function we wrote in chapter one and printed is printf which someone has already provided for us this means that we need to only write a routine which decides if the line contains an occurrence of the pattern we can solve that problem by stealing a design from pl1 the function index s comma t returns the position or index in the string s where the string t begins or 1 if s doesn't contain t we use 0 rather than 1 as the starting position in s because c arrays always begin at position 0. when we later need more sophisticated pattern matching we only have to replace index the rest of the code can remain the same recall that because the modern stdio.h defines a getline function whenever the book writes this function to teach a feature of functions we rename it to get underscore line given this much design filling in the details of the program is straightforward here's the whole thing so you can see how the pieces fit together for now the pattern to be searched for is a literal string in the argument of index which is not the most general of mechanisms we will return shortly to a discussion of how to initialize character arrays and in chapter 5 we will show how to make the pattern a parameter that is set when the program is run this is also a new version of getline you might find it instructive to compare it to the one in chapter one pound include stdio.h pound define max line 1000 main open parenthesis closed parenthesis open curly brace char line open square bracket max line close square bracket semicolon while parentheses get line open parenthesis line comma max line close parenthesis greater than zero close parenthesis if open parenthesis index open parenthesis line comma double quote the double quote close parenthesis greater than or equal to zero close parenthesis printf open parenthesis double quote percent s double quote comma line close parenthesis semicolon and a close curly brace to finish the main function next function is get line get line open parenthesis s comma limb close parenthesis char s open square bracket close square bracket semicolon available c equals get char open frame close paren close paren not equal e o f double ampersand c not equal double quote backslash n double quote semicolon plus plus i close parentheses s sub i equals c that loop basically read until it found a new line or end of file if open parenthesis c double equals quote backslash end quote close parenthesis open curly brace s sub i equals c plus plus i semicolon close curly brace closing the f s sub i equals quote backslash zero quote semicolon to terminate the string properly return open paren i close paren semicolon to return the length of the line and then close curly brace to finish the getline function and now the new code index open parenthesis s comma t close parenthesis char s open square bracket close square bracket comma t open square bracket close square bracket semicolon i would note that when we are declaring a character array and we don't give the length of the array that means that we're inside of a function the length of the array exists but it was from the callings calling code so char s open square bracket close square bracket t open square bracket close square bracket semicolon means parameters s and t are strings of some length and we will use backslash 0 to know when that length is done beginning the code in index with an open curly brace int i comma j comma k semicolon and then we have two nested for loops four open print i equals zero s sub i not equal to quote backslash zero quote semicolon i plus plus open curly brace four j equals i comma k equals zero semicolon t s t sub k not equal to backslash zero and double ampersand s sub j double equals t sub k semicolon j plus plus k plus plus semicolon if open print t sub k double equals quote backslash zero quote close paren return open paren i close paren semicolon close curly brace return open paren minus one close paren semicolon curly brace each function has the form name argument list if any in parentheses argument declarations if any open curly brace declarations and statements if any close curly price as suggested various parts may be absent a minimal function is dummy open paren close paren open curly brace closed curly brace which does nothing a do nothing function is sometimes useful as a placeholder during program development the function name may also be preceded by a type if the vert function returns something other than an integer value this is the topic of the next section a program is just a set of individual function definitions communication between the functions is in this case by arguments and values returned by the functions it can also be via external variables the functions can occur in any order in the source file and the source program can be split into multiple files so long as no function is split the return statement is the mechanism for returning a residual value from the called function to its caller any expression can follow return return open parentheses expression close parentheses the calling function is free to ignore the return value if it wishes furthermore there need there is no need to have an expression after the return in that case no value is returned to the caller control also returns to the caller with no value when execution falls off the end of the function by reaching the right closing brace it is not illegal but probably a sign of trouble if a function returns a value from one place and no value from another place in any case the residual value of a function which does not return one is certain to be garbage the c verifier lint checks for such errors the mechanics of how to compile and load a c program which resides on multiple source files vary from one system to the next on the unix system for example the cc command mentioned in chapter one does the job suppose that three functions are in three files called main.c getline.c and index.c then the command cc main.c getline.c index.c compiles the three files and places the resulting relocatable object code in files main.o getline.o and index.o and loads them all into an executable file named a dot out if there is an error say in main.c that file can be recompiled by itself and the result loaded with the previous object files with the command cc main.c getline.o index.o the cc command uses the dot c suffix versus the dot o suffix naming convention to distinguish source files from object files i would note that this cc example exactly as the authors wrote it does not quite work as described in modern c compilers if you want to compile your source code and leave the compiled object code around after the compile you add the minus c option to the compiler column modern c compilers generally do accept multiple files with either dot c or dot o suffixes and conv combine them into a runnable application section 4.2 functions returning nonintegers so far none of our programs has contained any declaration of the type of a function this is because by default a function is implicitly declared by its appearance in an expression or statement such as while open paren get line open paren line comma max line close paren greater than zero close print if a name which has not been previously declared occurs in an expression and is followed by a left parenthesis it is declared by context to be a function name furthermore by default the function is assumed to return an int since char promotes to int in expressions there is no need to declare functions that return char these assumptions cover the majority of classes including all of our examples so far i would add that's not true quite true anymore in modern c languages you are required to provide a type for each function if you leave off the type for a function declaration at a minimum you will give us get a stern warning message but sometimes functions do not intend to return anything at all and so the void type was invented to indicate that a function returns nothing the rule of requiring a type on a modern function definition in c even if it's void allows the compiler to check to make sure all of your return values in a function match the expected return type back to the text but what happens if a function must return some other type many numerical functions like square roots sine and cosine return double other specialized functions return other types to illustrate how to deal with this let us write and use the function a to f which converts its argument string s to its double precision floating point equivalent a2f is an extension of a to i which we wrote versions of in chapters two and three it handles an optional sign and decimal point and the presence or absence of either the integer or fractional part we note that this is not a high quality input conversion routine it takes doing everything takes a bit more space than we care to use here in this book first a to f must declare the type of the value it returns since it's not int because float is converted to double in expressions there is no point in saying that a to f returns float we might as well make use of the extra precision and thus declare it to return double the type name precedes the function name like this double a to f open parenthesis s close parenthesis char s open square bracket close square bracket open curly brace double val comma power int i comma sine semicolon for i equals zero semicolon s sub i double equals quote space quote or s sub i double equals quote backslash end quote or s sub i eq double equals quote backslash t quote semicolon i plus plus semicolon that skips the white space sine equals one if s sub i double equals quote plus quote or s sub i double equals quote minus quote sine equals and now we're going to use a ternary operator here paren s sub i plus plus close bracket double equals quote plus quote close paren question mark 1 colon minus one semicolon and that basically tells us it it makes sine be one or negative one based on the presence or absence of a plus or minus for val equals zero semicolon s sub i greater than or equal to quote zero quote double ampersand s sub i less than or equal to double quote nine quote i plus plus close paren val equals 10 times val plus s sub i minus quote zero quote semicolon what this is doing is multiplying the current value by 10 in effect shifting it left and then adding in that new lower empty spot the digit that we're encountering which is somewhere between the character 0 and the character 9. continuing if parentheses s sub i double equals quote dot quote close parentheses i plus plus four open parenthesis power equals one semicolon s sub i greater than or equal to quote zero quote double ampersand s sub i less than or equal to quote nine quote semicolon i plus plus open curly brace val equals 10 times val plus s sub i minus quote zero quote again shifting the number to the left as its as we encounter characters power star equals 10 semicolon close curly brace return open parenthesis sine times val over power close parenthesis semicolon close curly brace second and just as important the calling routine must state that a to f returns a nonend value the declaration is shown in the following primitive desk calculator barely adequate for checkbook balancing which reads one number per line optionally preceded by sign and adds them all up printing the sum after each input this example is from page 70 of the textbook pound include stdio.h pound define max line 100 main open parenthesis close parenthesis open curly brace double sum comma a to f open parenthesis close parenthesis semicolon char line open square bracket max line close square bracket semicolon sum equals zero while open parenthesis get line open parenthesis line comma max line close parenthesis greater than zero close parenthesis printf quote backslash t percent.2f backslash n comma sum plus equals a to f open parenthesis line close parenthesis close parenthesis semicolon close curly brace that code used the plus a plus equals side effect operator and merge the call to a to f right into the parameter of the second parameter of printf the declaration double sum a to f open parentheses close parentheses says that sum is a double variable and that a to f is a function that returns a double value as a mnemonic it suggests that sum and a to f parenthesis dot dot are both double precision floating point values unless a to f is explicitly declared in both places c assumes it returns an integer and you will get nonsense answers if a to f itself and the call to it in main aren't typed inconsistently with this with in the same source file it will be detected by the compiler but if as is more likely a to f were compiled separately the mismatch would not be detected and a to f would return a double which maine would treat as an end and meaningless answers would result lind catches this error given a to f we could in principle write a to i to convert a string to an integer in terms of it int a to i open parentheses s close parentheses char s open square bracket close square bracket semicolon open curly brace double a to f open parenthesis close parenthesis semicolon return open parenthesis a to f close parentheses s close parentheses close parentheses semicolon close curly brace note the structure of the declarations in the return statement the value in the expression in return expression is always converted to the type of the function before the return is taken therefore the value of a to f a double is converted automatically to int when it appears in a return since the function a to i returns an end the conversion of a floating point value to in truncates any fractional part as we discussed in chapter two more on function arguments in chapter one we discuss the fact that function arguments are passed by value that is the called function receives a private temporary copy of each argument not its address this means that the function cannot affect the original argument in the calling function within a function each argument is in effect a local variable initialized to the value with which the function was called when an array name appears as an argument to a function the location of the beginning of the array is passed elements are not copied the function can alter elements of the array by subscripting from this location the effect is that arrays are always passed by reference in chapter 5 we will discuss the use of pointers to permit functions to affect nonarrays in calling functions a bit of a digression since including array as an argument passes the location or memory address of the array into the function the function cannot can change the items in the array using array subscripts in particular the array contents are not copied when an array is passed into a c function when we get destructs in a future chapter we will find that the content of structs also are passed using the address of the entire struct so structs are passed by reference as well when thinking about past by reference or pass by value remember that a char variable is a single item similar to int and passed by value i.e is copied in c strings are arrays of characters so they are passed by reference python follows this design for the same efficiency reason as c normal single variables like int or float are copied before being passed into a function and therefore passed by value collections like list or dict are passed into functions by reference so the contents can be changed within a function python strings are not technically copied when being passed into a function but the way assignments happen in python make it seem like strings are passed by value since they can never be modified you can learn more with a bit of web research but the easy way is to imagine in python that strings are passed by value with a clever trick to avoid requiring a copy for every function call php follows the same pattern of passing numbers and strings by value and passing arrays as reference php passes strings by value without recover without requiring a copy again using clever runtime code because in java javascript and php strings are objects of course which we haven't discussed much yet those languages can make sure that strings act as if they were passed by value and not passed by reference the way they are always passed in c c made decisions on its run time based on getting the maximum performance out of the hardware of the 1970s at the expense of making it too easy to write code that overwrites memory and leads to corrupted programs that have dangerous and undefined behavior languages like php java and javascript add a small amount of runtime overhead to do things like store the length of an array and make sure we programmers don't over reference the array and overwrite random bits of our program's code or data the creators of c placed more priority on speed and efficient use of memory than safety it is like driving an autom automobile in the rain without abs automatic braking system it is fast but dangerous and should be reserved by highly skilled and very careful programmers and drivers and those drivers should probably be on a race course by the way back to the text by the way there is no entirely satisfactory way to write a portable function that accepts a variable number of arguments because there is no portable way for the called function to determine how many arguments were actually passed in a given call thus you can't write a truly portable function that will compute the maximum of an arbitrary number of arguments as will the max functions that are built in to fortran and pl1 it is generally safe to deal with a variable number of arguments if the called function doesn't use an argument that was not actually supplied and if the types are consistent printf the most common c function with a variable number of arguments uses information from the first argument which is the formatting string to determine how many other arguments are present and what their types are it fails badly if the caller does not supply enough arguments or if types are not what the first argument says it is also nonportable and therefore must be modified for different programming environments alternatively if arguments are of known types it is possible to mark the end of the argument list in some agreedupon way such as a special argument value often zero that stands for the end of the arguments interestingly modern languages like python php and java go to great lengths to make variable length argument lists work predictably and portably the syntax for variable length argument lists in these language can be a bit obtuse at times but at least it's allowed documented reliable and portable section 4 external variables a c program consists of a set of external objects which are either variables or functions the adjective external is used primarily in contrast to internal which describes arguments and automatic variables defined inside functions external variables are defined outside any function and are thus potentially available to many functions functions themselves are always external because c does not allow functions to be defined inside other functions by default external variables are also global so that all references to such a variable by the same name even from functions that are compiled separately are references to the same thing in as this sense external variables are analogous to fortran common or pl1 external we will later see how to define external variables and functions that are not globally available but instead only visible within a single source file because external variables are globally accessible they provide an alternative to function arguments and return values for communicating data between function any function may access an external variable by referring it to by name if the name has been declared somehow if a large number of variables must be shared among functions external variables are a more convenient and efficient than long argument lists as pointed out in chapter 1 however this reasoning should be applied with some caution for it can have a bad effect on program structure and lead to programs with many data connections between functions a second reason for using external variables concerns initialization in particular external arrays may be initialized but automatic ie internal arrays may not we will treat initialization near the end of this chapter the third reason for using external variables is their scope and lifetime automatic variables are internal to a function they come into existence when the routine is entered and disappear when it's left external variables on the other hand are permanent they do not come and go so they retain values from one function invocation to the next thus if two functions must share some data yet neither calls the other it is often most convenient if the shared data is kept in external variables rather than passed in and out via arguments let's examine this issue further with a larger example the problem is to write another calculator program better than the previous one this one permits plus minus asterisk and slash and equals equals will print our answer because it is somewhat easier to implement the calculator will you use reverse polish notation instead of in fixed notation reverse polish notation is the scheme used by for example hewlettpackard pocket calculators in reverse polish notation each operator follows its operators operands an infix expression like open parenthesis 1 minus 2 close parentheses c star open parenthesis 4 plus 5 close parenthesis equals is entered as 1 2 minus 4 5 plus star equals parentheses are not needed in reverse polish notation the implementation is quite simple each operand is pushed onto a stack when an operator arrives the proper number of operands two for binary operators are popped the operator applied to them and the result is pushed back onto the stack in the example above one and two are pushed then replaced by their difference negative one next four and five are pushed then replaced by their sum nine and then the product of negative one and nine which is negative nine replaces them on the stack and then the equal sign operator prints the top element without removing it so intermediate steps in a calculation can be checked the operations of pushing and popping a stack are trivial but by the time error detection and recovery are added they're long enough so it's better to put each in a separate function than to repeat the code throughout the whole program and there should be a separate function for effects fetching the next input operator or operand thus the overall structure of the program is while next operator or operand is not into file if it's a number push it else if it's an operator pop operands do the opera operation and push the result else error the main design decision that has not yet been discussed is where the stack is that is what routines access it directly one possibility is to keep it in main and pass the stack and current stack position to the retrains that push and pop it but maine doesn't need to know about the variables that control the stack it should only think about pushing and popping so we have decided to make the stack and its associated information external variables accessible to push and pop but not to main translating this outline to code is easy enough the main program is primarily a big switch on the type of operator or operand this is a more typical use of switch than the one shown in chapter 3. this sample code is from page 74 of the textbook pound include stdio.h pound define maxop 20 pound defined number quote zero quote this is going to be a single we found a number and pound to find two big quote nine quote a signal that the string is too big main open parenthesis close parenthesis open curly brace int type semicolon char s open square bracket max op close square bracket semicolon double opt 2 a to f open parenthesis close parenthesis comma pop open parenthesis close parenthesis comma push open parenthesis close parenthesis semicolon while open parenthesis open parenthesis type equals get up open parenthesis s comma max op close parenthesis close parenthesis not equal e o f close parenthesis switch open parenthesis type close parenthesis open curly brace case number colon note that number is a predefined constant above push open parenthesis a to f open parenthesis s close parenthesis close parenthesis semicolon break case quote plus quote colon push open parenthesis pop open paren close paren plus pop open for n close paren close paren semicolon break semicolon case quote asterisk quote colon push open paren pop open paren close paren asterisk pop open paren close paren close paren semicolon break semicolon that was the multiplication case quote minus quote colon op 2 equals pop open for n close paren push open paren pop minus op2 close print semicolon break semicolon that was subtraction case open print slash close paren colon op 2 equals pop open paren semicolon if up to not equal 0.0 push open print pop open paren close print slash opt2 close paren semicolon else printf double quote zero divisor popped backslash n double quote close paren semicolon break case quote equal quote colon printf open paren double quote backslash t percent f backslash n double quote comma push open paren pop open friend close paren close paren close friend semicolon so to print it we pop it and push it and then print the residual value of the push function the next line is break semicolon case quote c quote colon clear open paren close print semicolon break semicolon case too big colon print f double quote percent dot 20 s space dot dot dot is too long backslash n double quote comma s close paren semicolon break semicolon default colon print f open paren double quote unknown command percent c backslash n double quote comma type open print close print semicolon break semicolon close paren close curly brace to finish the switch statement and then close curly brace to finish the main so now we're going to have a separate file that has some of these functions defined this file is on page 75 of the textbook this file will be compiled separately but then later linked all together with the main program but we're going to define push pop and clear in this file pound include stdio.h pawn define maxval 100 maximum value that would be the maximum value of our stack the maximum size of our stack maximum depth of our stack now we are declaring variables outside of any function these are the external variables int sp equals zero double val open square bracket max val close square bracket semicolon and so those variables are external variables and they're outside of all of the functions but we can use them in any function and there's just one copy no matter what function we're using it so now we define our functions double push open paren f close paren double f semicolon open curly brace if open paren sp less than max val close paren return open paren val open square bracket sp plus plus close square bracket equals f close paren semicolon else open curly brace printf double quote air colon stack full backslash n double quote closed paren semicolon clear open paren close print semicolon return open print zero close paren semicolon close curly brace to finish the else and then close curly brace to finish the double function the push function and now we define the pop double pop open print close paren open curly brace if open paren sp greater than zero close paren return open paren val open square bracket minus minus sp close square bracket close curly brace semicolon else open curly brace printf open paren double quote error colon stack empty backslash n close quote close double quote close paren semicolon clear open paren close paren semicolon return open print zero close paren semicolon close curly brace to finish the else and then close curly brace to finish the double and the last function we're going to define is the clear function which is quite simple clear open paren close paren open curly brace sp equals zero semicolon close paren i would note that just read this one carefully they're very good at using side effect operators and side effect assignments and to keep this code very simple and succinct and you really have to understand a lot of the other stuff that you've covered in the book up to this point back to the text the command c clears the stack with the function clear which can also be used by push and pop in case of error we'll return to get op in a moment as discussed in chapter one a variable is external if it is desi defined outside the body of any function thus the stack and stack pointer which must be shared by push pop and clear are defined outside the three functions but if main itself does not refer to the stack or stack pointer their representation is carefully hidden thus the code for the equal operator must use push open print pop parentheses parentheses close parenthesis close parenthesis semicolon to examine the top of the stack without disturbing it notice also that because plus and multiplication are commutative operators the order in which the popped operands are combined is irrelevant but for the minus and slash operators the left and right operands must be distinguished this example code above shows why it's important to remember the k and r c arrange rearrangement license as it applies to operators that are associative and commutative if the code for the minus operator were written written push open paren pop open print close print minus pop open print close paren close print semicolon there is no guarantee that the left pop will run before the right pop and since these functions access global variables and have side effects it is important to force the compiler not to rearrange the order of the function calls to force the evaluation order the code is broken into two statements op2 equals pop open print close print semicolon push open open paren pop open paren close paren minus op2 close paren semicolon now you might think that the lesson here is that the k rc arrangement license which was done to allow optimization and performance is a bad idea but the more important lesson is that writing low level utility functions like push and pop that use global variables and have side effects is a dangerous pattern in any programming language section 4.5 scope rules the functions and external variables that make up a c program need not all be compiled at the same time the source text of the program may be kept in several files and previously compiled routines may be loaded from libraries the two questions of interest are how are declarations written so that variables are properly declared during compilation and how our declarations set up so that all the pieces will be properly linked or connected when the program is loaded the scope of a name is the part of the program over which the name is defined for an automatic variable declared at the beginning of a function the scope is the function in which the name is declared and variables of the same name in different functions are unrelated the same is true of the arguments of the function the scope of an external variable lasts from the point at which is it is declared in a source file to the end of that file for example if val sp push pop and clear are defined in one file in the order shown above that is intsp equals zero double val open square bracket maxval close square bracket semicolon double push open print f close paren open curly brace dot dot close curly brace double pop open print close paren open curly brace dot dot dot close curly brace clear open paren close paren open curly brace dot dot dot close curly brace then the variables val and s p may be used in push pop and clear simply by naming them and no further declarations are needed on the other hand if an external variable is to be referenced before it is defined or it is defined in a different source file from the one in which it's being used then an extern declaration is mandatory it is very important to distinguish between the declaration of an external variable and its definition a declaration announces the property of the variable its type its size etc a definition also causes storage to be allocated if the lines int sp semicolon double val open square bracket maxval close square bracket semicolon appear outside any function they define the external variables sp and val and cause the storage to be allocated and also serve as the declaration for the rest of that source file on the other hand the lines extern int sp extern double val open square bracket close score bracket semicolon declare for the rest of the source file that sp is an int and val is a double array whose size is determined and allocated elsewhere but they do not create variables or allocate storage for them there must be only one definition of an external variable among all the files that make up the source program other files may contain extern declarations to access it there may also be an extern declaration in the file containing the definition any initialization of an external variable goes only with the definition array sizes must be specified with the definition but are optional with the extern declaration although it is not a likely organization for this program val and sp could be defined and initialized in one file and the functions push pop and clear defined in another then these definitions and declarations would be necessary to tie them together in file 1 we would see int sp 0 semicolon double val open square bracket max val close square bracket semicolon and then in file 2 x turn in sp semicolon x turn double val open square bracket close square bracket semicolon double push open print f close paren open curly brace dot dot close curly brace double pop open frame close paren open curly brace dot dot dot close curly brace clear open friend close paren open curly brace dot dot dot close curly brace because the x turned declarations in file two lie ahead and outside the three functions they apply to all one set of declarations suffices for all of file 2. for larger programs the pound include file inclusion facility discussed later in this chapter allows one to keep only a single copy of the extern declarations for the program and have that inserted in each source file it's as it's being compiled let us now turn to the implementation of getup the function that fetches the next operator or operand the basic task is easy skip blanks tabs and new lines if the character is not a digit or a decimal point return it otherwise collect a string of digits that might include a decimal point and return number a single signal that a number has been collected the routine is substantially complicated by an attempt to handle the situation properly when the input number is too long get up reads digits perhaps with an intervening decimal point until it doesn't see anymore but only stores the ones that fit if there was no overflow it returns number in the string of digits if the number was too long however getup discards the rest of the input line so the user can simply retype the line from the point of error it returns too big as the overflow signal this example code is from page 78 of the textbook and you can view it at www.cc4e.com code page 78 get up open friend s comma lim close paren char s open square bracket close square back at semicolon int lim semicolon open curly brace int i comma c semicolon while open paren open paren c equals get ch open paren close paren close paren double equals quote space quote or c double equals quote backslash t quote or c double equals quote backslash end quote close paren semicolon skip all the blanks if c is not equal quote dot quote and open paren c less than quote zero quote vertical bar vertical bar c greater than quote nine quote close paren close paren return s return open paren c close paren s sub zero equals c four paren i equals one semicolon open paren c equals get chart open paren close paren close print greater than or equal to quote zero quote and c less than or equal to quote nine quote semicolon i plus plus inside the for loop if i less than limb s sub i equals c if open for n c double equals quote dot quote close paren open curly brace we begin to collect the fraction if open print i less than limb close paren s sub i equals c four open paren i plus plus c equals get char open paren close paren close paren greater than or equal to quote zero quote ampersand ampersand c less than or equal to quote nine quote semicolon i plus plus closed paren if open prime i less than limb close paren s sub i equals c close curly brace to close the if statement where we're collecting the fraction if open paren i less than limb close paren open curly brace this means the number is good ungetch is ch open friends c close paren semicolon s sub i equals quote backslash zero quote semicolon return open paren number close print and recall that number is a predefined constant close curly brace else open curly brace if it's too big we're going to skip to the end of the line while open paren c not equal quote backslash end quote and c not equal eof open paren c equals get char open for enclosed paren semicolon s sublim minus one equals quote backslash zero quote semicolon return too big semicolon close curly brace to finish the if and then close curly brace to finish the function recall that too big is a constant that indicates that we've read too much back to the text what are get ch and unget ch well it is often the case that a programming reading input cannot determine that is read enough until it is read too much one instance is collecting characters that make up a number until the first nondigit is seen the number is not complete but then the program has read one character too far and that is a character it is not prepared for the problem would be solved if it were possible to unread the unwanted character then every time the program reads one character too many it could push it back on the input so that the rest of the code would behave as if it never been read fortunately it is easy to simulate ungetting a character by writing a pair of cooperating functions getch delivers the next input character to be considered ungetch puts the character back on the input so the next call to get ch will return it again how they work together is simple unget ch puts puts the pushed back characters into a shared buffer a character array gets the ch reads from the buffer is there's anything there and then it calls get char if the buffer is empty there must be an index variable which records the position of the current character in the buffer since the buffer and index are shared by get ch and unget ch and must retain their values between calls they must be external to both routines thus we can write getch and ungetch and their shared variables as follows this is on page 79 of the textbook you can see the code at www.cc4e.com code and go to page 79 pound include stdio.h found to find buff size 100 char buff open square bracket buff size close square bracket semicolon int buff p equals zero semicolon those are the external variables outside any function here's the first function get ch open friend close paren open curly brace return open parenthesis open parenthesis buff p greater than zero close parenthesis question mark buff open square bracket minus minus buff p close square bracket colon get char open paren close paren close paren semicolon close curly brace to finish the get ch function the unget ch function pushes a character back on input ch open paren c close paren into c semicolon open curly brace if open paren buff p greater than buff size printf open prin double quote unget ch colon too many characters backslash n double quote close paren semicolon else buff open square bracket buff p plus plus close square bracket equals c semicolon and then close curly brace to finish the ungetch function we have used an array for pushback rather than a single character since the generality may come in handy later section 4.6 static variables static variables are a third class of storage in addition to the x turn and automatic that we've already met static variables may either be internal or external internal static variables are local to a particular function just like automatic variables are but unlike automatics they remain in existence rather than coming and going each time the function's activated this means that internal static variables provide private permanent storage in a function character strings that appear within a function such as the arguments of printf are internal static an external static variable is known within the remainder of the source file in which it's declared but not in any other file external static thus provides a way to hide names like buff and buff p in the get ch unget ch combination which must be external so they can be shared yet which should not be visible to users of get ch and unguess ch so there's no possibility of conflict if the two routines are compiled in one file as in static char buff open square bracket buff size close square bracket semicolon static int buff p equals zero semicolon get ch open frame close paren open curly brace dot dot close curly brace unget ch open paren c close paren open curly brace dot dot dot close curly brace then no other routine will be able to access buff and buff p in fact they will not conflict with the same names in other files of the same program static storage whether internal or external is specified by prefixing the normal declaration with the word static the variable is external if it's defined outside of any function and internal if defined inside a function normally functions are external objects their names are known globally it is possible for a function however to be declared static this makes its name unknown outside the file in which it's declared in c static connotates not only permanence but also a degree of what might be called privacy internal static objects are known only inside one function external static objects variables or function are are known only within the source file in which they appear their names do not interfere with variables or functions of the same name in other files external static variables and functions provide a way to conceal data objects and any internal routines that manipulate them so that other routines and data cannot conflict even inadvertently for example getch and ungetch form a module for character input and pushback buff and buff p should be static so they're inaccessible from the outside in the same way push pop and clear form a module for stack manipulations val and sp should also be external static 4.7 register variables the fourth and final storage class is called register a registered declaration advises the compiler that the variable in question will be heavily used when possible register variables are placed in machine registers which may result in smaller and faster programs the register declaration looks like register int x semicolon register char c semicolon and so on the in part may be omitted register can only be applied to automatic variables and the formal parameters of a function in this latter case the function declaration looks like f open paren c comma n close paren register int c comma n semicolon open curly brace register int i semicolon and then dot dot close curly brace in practice there are some restrictions on register variables reflecting the realities of the underlying hardware only a few variables in each function may be kept in registers and only certain types are allowed the word register is ignored for excess or disallowed declarations and it is not possible to take the address of a register variable a topic that will be covered in chapter 5. the specific restrictions vary from machine to machine as an example on the pdp11 only the first three registered declarations in a function are effective and the types must be int char or pointer as a quick aside the description of the details of the implementation of the register modder modifier on the pdp11 is a delightful peek into how the c compiler generated runtime code on that particular system in the 1970s as compilers have become more sophisticated the compiler could decide which variables to keep in registers far better than the programmer could and since how variables would be allocated to registers might be different on different hardware architectures the register indication is generally ignored by modern c compilers so you should probably never use it in your code as a matter of fact i wrote the following sample c program and compiled it with the minus capital s option so i could see the generated assembly language with and without the register declaration with optimization there was no difference between the code generated with or without the registered declaration the reason the generated assembly code was identical once you take a look at it was regardless of the use the register keyboard was that the c optimizer on my arm based computer in 2022 realized the best way to implement the code was to keep both of the variables in registers because the loop code was so simple and the cpu in my computer has plenty of registers and optimized any loading and storing of the data for these variables right out of the program in 1978 the authors likely included the register function as a feature to convince the experienced assembly language programmers that they should write all but the lowest lowest level code in c so write a little tiny bit in c and then i mean write a little tiny bit in assembly language and write everything else in c so here's an example that's not in the textbook it's on page 81 if it were in the textbook you can see this code at www.cc4ed code page 81 and this is code that i wrote to play with the register keyword to mostly convince myself it was pointless to use it but here we go pound include stdio dot h int main open prime close print open curly brace int compute semicolon register end enter semicolon scanf open for n double quote percent d close quote comma ampersand compute close parenthesis semicolon printf open parenthesis double quote compute space percent d backslash n double quote comma compute close parenthesis semicolon four open print iter equals zero semicolon enter less than one thousand semicolon iter plus plus close parenthesis open curly brace compute equals open parenthesis compute times 22 close parenthesis times seven if compute greater than one thousand compute equals compute modulo one thousand close curly brace printf open paren double quote compute space percent d backslash n close quote comma compute semicolon close curly brace now some of these i wrote this code in a way that tries to convince the uh the the optimizer that i'm actually going to use these values that's why i read the value from input as compared to a constant it would actually optim the optimizer so so so smart that it would just eliminate all the constant calculations so but that's my sample playing with register section 4.8 block structure c is not a block structured language in the sense of pl1 or algol in that functions may not be defined within other functions on the other hand variables can be defined in a block structured fashion declarations of variables including initializations may follow the left brace that introduces any compound statement not just the one that begins a function variables declared this this way supersede any identically named variables in outer blocks and remain in existence until the matching right race for example if open parentheses n greater than zero close parenthesis open curly brace int i semicolon declare a new i four open parenthesis i equals 0 semicolon i less than n semicolon i plus plus close parenthesis and dot dot the rest of the for loop and then a closed curly brace for the if the scope of the variable i is in the true branch of the if this i is unrelated to any other i in the program block structure also applies to external variables given the declarations int x semicolon f open parenthesis closed parenthesis open curly brace double x semicolon dot dot dot close parenthesis then within the function f occurrences of x refer to the internal double variable outside of f they refer to the external integer this is same is true of the names of formal parameters for example in z semicolon outside of any function f open parenthesis z close parenthesis double z semicolon open curly brace dot dot close curly brace within function f z refers to the formal parameter not the external variable section 4.9 initialization initialization has been mentioned in passing many times so far but always peripherally to some other topic this section summarized some of the rules now that we have discussed the various storage classes in absence of explicit initialization external and static variables are guaranteed to be initialized to zero automatic and register variables have undefined or garbage values simple variables not arrays or structures may be initialized when they are declared by following the name with an equal sign and a constant expression int x equals one semicolon jar s quote equals single quote backslash single quote single quote semicolon a constant of a single character that is a single quote itself long day equals 60 times 24 semicolon which is the minutes in a day for external and static variables the initialization is done once conceptually at compile time for automatic and register variables it is done each time the function or block is entered for automatic and register variables the initializer is not restricted to being a constant it may in fact be any valid expression involving previously defined values even function calls for example the initializations of the binary search program that we wrote in chapter 3 could be written as binary open parenthesis x comma v comma n close parenthesis int x comma v open square bracket close square bracket comma n semicolon open curly brace int low equals zero semicolon and high equals n minus one semicolon and in mid followed by the rest of the function and then close curly brace instead of initializing these as the first executable statements and we would do this with binary open paren x comma v comma n close paren int x comma v open square bracket close square bracket comma n semicolon open curly brace int low comma mid comma high semicolon low equals 0 semicolon high equals n minus 1 semicolon and so forth in effect initializations of automatic variables are just shorthand for assignment statements which form to prefer is largely a matter of taste we have generally used explicit assignments because initializers and declarations are harder to see automatic arrays may not be initialized external and static arrays may be initialized by following the declaration with a list of initializers enclosed in braces and separated by commas for example the character counting program of chapter 1 which originally was main open parentheses closed princely open curly brace int c comma i comma n white comma n other int n digit open square bracket 10 close square bracket semicolon n white equals n other equals zero four open parenthesis i equals zero semicolon i less than ten semicolon i plus plus closed parenthesis and digit sub i equals 0 and then the rest of the code followed by a closed curly brace finishing main this could be written instead using initializers as follows int and white equals 0 semicolon int and other equals zero semicolon int n digit open square bracket 10 close square bracket equals open curly brace zero com zero comma zero comma zero comma zero comma zero comma zero comma zero comma zero comma zero close curly brace ten zeros in a row and separated by commas and in braces and then the main code is simply main open paren close paren open curly brace in comma c comma i and then the rest of the main code close curly brace the idea is is that with the initializers and with the external variables outside of the main function you do not need to initialize them even with a for loop in the beginning of the main program these initializations are actually all unnecessary since they're all zero anyways but it's a good form to make them explicit anyway if there are fewer initializers than the specialized size the others will be zero it is an error to have too many initializers regrettably there is no way to specify the repetition of an initializer nor to initialize an element in the middle of the ray without supplying all the intermeaning intervening values as well character arrays are a special case of initialization a string may be used instead of the braces in commas notation as in char pattern open square bracket close square bracket equals double quote th e double quote semicolon this is a shorthand for the longer but equivalent char pattern open square bracket close square bracket equals open curly brace single quote t single quote comma single quote h single quote comma single quote e single quote comma single quote backslash zero single quote close curly brace semicolon when the size of an array of any type is omitted the compiler will compute the length of the array by counting the initial initializers in this specific case the size of pattern is four three actual characters plus the terminating backslash zero i would note that the primary difference between c and c influence like languages like java php and javascript this key is that c strings are character arrays while in the other languages strings are objects these string objects do have inside themselves an array of bytes or characters but they also keep track of things like the length of the string and provide functionality like extract a substring in the methods in these objects in c there is a set of library functions that perform string operations like compare two strings while cut string comparison is built into the string objects in each of the other languages strings as character arrays allow programmers to build very fast lowlevel code in libraries and operating systems but to write the code well you need to understand what is really going on at the low level section 4.10 recursion c functions may be used recursively that is a function may call itself either directly or indirectly one traditional example involves printing of a number as a character string as we mentioned before the digits are generated in the wrong order low order digits are available before four high order digits but they have to be printed in the other way around there are two solutions to this problem one is to store the digits in an array as they are generated and then print them in reverse order as we did in chapter 3 with eye to a the first version of print d follows this pattern this is sample code on page 85 of the textbook you can view the sample code at com www.cc4e.com code page 85 example one pound include stdo dot h print d open paren and close paren in open curly brace char s open square bracket 10 close square bracket semicolon and i semicolon if parenthesis n less than 0 parenthesis open curly brace put char open prin single quote dash single quote close paren semicolon n equals minus n semicolon close curly brace i equals zero semicolon do open curly brace s sub i plus plus equals n modulo 10 plus quote zero quote which gets the next character while parentheses parenthesis equal 10 close parenthesis greater than zero close parenthesis semicolon then we reverse the string while open print minus minus i greater than equal to zero close paren put char open paren s sub i close paren semicolon close curly brace to end the print d function the alternative is a recursive solution in which each call of print d first its calls itself to cope with any leading digits then prints the trailing digit after that call returns this is an example on page 85 of the textbook in its example pound include stdio.h print d open paren n close paren int n semicolon open curly brace int i semicolon if open friend n less than zero close paren open curly brace put chair open paren single quote dash single quote close paren semicolon n equals minus n semicolon close curly brace to finish the if if open paren open print i equals n over 10 close print not equal 0 close print print d open print i closed paren semicolon that's the recursive call and after the recursive call comes back we do put char open paren n modulo 10 plus single quote 0 single quote close paren semicolon close curly brace to end the print d function when a function calls itself recursively each invocation gets a fresh set of all the automatic variables quite independent of the previous set thus in print d 123 the first print d has n equals 123. it passes 12 to a second print e then prints three when that one returns in the same way the second print d passes one to a third which prints it and then prints 2. recursion generally provides no saving in storage since somewhere a stack of values is being processed or has to be maintained nor will it be faster but recursive code is more compact and often much easier to write and understand recursion is especially convenient for recursively defined data structures like trees we will see a nice example in chapter 6. as an aside ah recursion recursion recursion recursion is a beloved concept in computer science it is often taught early in most programming courses because it is just so cool most examples are sadly like computing factorial or the example above converting an integer to a string and they're not good uses a recursion actually but when you do finally find yourself in need of traversing a treebased structure like an xml document or parsing a mathematical expression with parentheses recursion is the ideal solution so the problem in a sense is not recursion but when it is taught and what examples are used interestingly kernighan and ritchie include the correct warning about using recursion when it is not the best solution in the above text and it bears another read back to the book recursion generally provides no saving in storage since somewhere a stack of values is being processed or has to be maintained nor will it be faster but recursive code is more compact and often much easier to write and understand recursion is especially convenient for recursively defined data structures like trees we will see a nice example in chapter 6. i couldn't have said it better section 4.11 the c preprocessor c provides certain language extensions by means of a simple macro preprocessor the pound defined capability which we have used is the most common of these extensions another is the ability to include the entire contents of other files during compilation file inclusion to facilitate handling of pound defines and declarations among other things c provides a file inclusion feature any line that looks like pound include space double quote file name double quote is replaced by the contents of the file name the quotes are indeed mandatory often a line or two of this form appears at the very beginning of each source file to include common pounddefined statements and extern declarations for global variables pound includes may be nested pound include is the preferred way to tie declarations together for a large problem and in a large program it guarantees that all the source files will be supplied with the same definitions and variable declarations thus eliminating a particularly nasty kind of bug of course when an include file is changed all the files that depend on it must be recompiled macro substitution a definition of the form pound define yes one calls for a macro substitution of the simplest kind repeat replacing a logical name by a string of characters names in the pound of fine have the same forms as the c identifiers the replacement text is arbitrarily normally the replacement text is the rest of the line a long definition may be continued by pasting a backslash at the end of the line to be continued the scope of the name defined with pound define is from from its point of definition to the end of the source file names may be redefined and a definition may use previous definitions substitutions do not place take place within quoted strings so for example if yes is a defined name there would be no substitution in printf open paren double quote yes double quote close paren since implementation of pound define is a macro prepass not part of the compiler proper there are very few grammatical restrictions on what can be defined for example alcohol fans can say pound define then and then nothing pound define begin open curly brace pound define end semicolon close curly brace and then write approximate algo if paren i greater than zero close paren then begin a equals one semicolon b equals two end it is also possible to define macular macros with arguments so the replacement text depends on the way the macro is called as an example define a macro called max like this pound define max open paren a comma b open paren open paren a close paren greater than open paren b close print question mark open parent a closed paren colon open paren b close paren close paren now the line x equals max open paren p plus q comma r plus s close paren semicolon will be replaced in the preprocessor by the line x equals open paren open paren p plus q close paren greater than open paren r plus s close paren question mark open paren p plus q close print colon open paren r plus s close paren close print semicolon this provides a maximum function that expands into inline code rather than a function call so long as the arguments are treated consistently this macro will serve for any data type there is no need for different kinds of macs for different data types as there would be with functions of course if you examine the expansion of max above you will notice some pitfalls the expressions are evaluated twice it is bad if they involve side effects like function calls increment operators or perhaps push and pop like we've used before some care has to be taken with parentheses to make sure the order order of evaluation is preserved consider the macro pound defined square open paren x close paren equals x times x when it is invoked as square open paren z plus one close paren there are even some purely lexical problems there can be no space between the macro name and left parenthesis that introduces the argument list nevertheless macros are quite valuable one practical example is the standard io library to be described in chapter 7 in which git char and put char are defined as macros obviously put chart needs an argument thus avoiding the overhead of a function call per character profit process other capabilities of the macro processor are described in appendix a as a bit of a long aside in this section we are talking about the preprocessor it's probably a good time to talk a bit about why we use this terminology for those of you with a computer science degree from back in the day many of you wrote a compiler as a senior project just like i did building a compiler was a great project because part of the goal of computer science is to understand the technologies that make programming process possible from the language syntax down to the hardware the compiler that translates our source code into machine code is an essential part of the technology stack that we use early compilers for languages like the early fortran variants tended to be translators they just translated code one line at a time from a highlevel language to assembly language you could think of early fortran programs in the 1950s and the 1960s as just more convenient ways to write assembly language for programmers that knew assembly language you always needed to be aware of assembly language and the translation that it was going to write fast fortran programs were small and optimization was done at the fortran level often leading to some hard to understand code by the mid1970s programming languages were based on parsing theory and we used what is called a grammar to define the language kernighan and ritchie kept io statements out of the c language to keep its formal definition i.e its grammar as simple as possible as these new languages emerge they allowed for more theoretical and powerful approach to converting source code to machine language the theoretical advances in compiler and language design meant that parts of the compiler might be reusable across multiple programming languages each language could have its own syntax and grammar rules and they could be plugged into the compiler and poof you would have a new programming language it got to the point where unix system unix systems had a tool called yak which stood for yet another compiler compiler you would give it a grammar for your new language and it would make a compiler for you as a matter of fact the javascript language that was created in 10 days back in 1995 was possible because brendan ike had a lot of experience with compiler generators he defined a grammar for javascript and generated his first compiler part of what made a compiler generate generator possible is the idea of a multistep compiler or the tasks of a compiler were broken down into a series of simpler and more welldefined steps here are the steps of a typical c compiler in the 1970s first a preprocessor step that takes c code with syntax like pound define and pout include as its input and produces raw c code output with o's instructions processed and or expanded the preprocessor processor was a c to c transformation next a parser step that took the raw c code applied the grammar to the language and created what is called a parse tree think of the tree as a hierarchy of statements grouped into blocks grouped into functions etc of things like a loop or just one node in a parse tree after that a code generation would turn the parse tree into some kind of simplistic portable internal code that expanded things like loops and ifthenelse statements into code after that a code optimization that looked at the internal code and moved things around eliminating any redundant computations say don't compute the same things twice this step is why the authors make such a big fuss about how there are times where c might do things in a slightly different order in an expression even in the presence of parentheses remember the knrc arrangement license back in chapter 2 that rule removes constraints on the compiler's optimization step so it can generate the most efficient code i would note that all the steps up to this point did not depend in any way on the actual machine language of the system that they were running on this meant a preprocessor parser code generator and code optimizer could literally be written in c and used on any architecture the final step is a code generator that takes the optimized intermediate code and generates the actual assembly and machine language for the processor for fun you can add the minus capital s parameter to your c compiler and see the resulting assembly language output for your system if you look at the machine language generated on intel or amd processor and compare it to the machine language on an arm processor it will look very different because all but the final compiler steps did not depend on the computer where the program is being run you could actually create a c compiler on a new computer architecture by writing a code generator on the new computer then running all but the last step of the compiler on one computer then copying the internal code generated by the compiler to the new compiler and running the code generation step on the new computer then you actually have a working c compiler on the new computer and the first step is usually to recompile the c compiler itself from source code to produce a fully native c compiler on the new computer that can compile all the rest of the c code you have including possibly the mostly portable elements of the unix operating system on the new compiler yes describing how to cross compile and bootstrap a c compiler onto a new computer hardware architecture can give you a headache if you think about it too much but this notion of bootstrapping a c compiler onto a new architecture was an important technique to move c and then unix to a wide range of very different computer architectures we see this in action as the unixlike mac os operating system over the past 20 years was delivered initially on a motorola 68 000 family processors then on powerpc processors and then on intel processors and most recently on armbased processors built by apple using the software portability patterns that come from c and unix and described by kernighan and ritchie in this book apple now makes their own hardware that can be tuned and evolved over time as their operating system and their applications requirements dictate the use of a grammar by the way is to define a programming language is one of the reasons that syntax errors are so obtuse the compiler is not looking at your code like a human it is following a very set of simple rules to parse your code and it's stuck with something logical and gives you a message like unexpect unexpected statement block or constant on line 17 and the error is nowhere near line 17. modern compilers are more sophisticated of course than the steps above but these steps give you a sense the compiler does many things to make it so your code can actually run very efficiently and given that kernighan and richie were building a programming language c a more mostly portable operating system written in c unix and a mostly portable c compiler written in c some of their innovative work and research into compiler design finds it its way into this book so we have a section in this chapter called the c preprocessor so here we are at the end of chapter four and it's a good time to talk about the word address up to this point in the book if you count them the word address has been used 10 times without a precise definition beyond the notion that data is stored in memory and the address of the data is where the data is stored in memory in the next chapter this notion of the address where the data is stored becomes very real and tangible as we explore pointers as well as the ampersand and asterisk operators up to now an experienced javascript php or java programmer can view c as just another set of similar syntax rules with a few quirky runtime bits but in the next chapter we will deeply explore the concept of data allocation and location it turns out that every programming language pays a lot of attention to data allocation and location but the runtime environments of modern languages work very hard not to expose you to those details just because modern languages hide the difficult bits from us it does not mean that those languages solve the problem using magic eventually the problem needs to be solved and that is why the compiler and lowlevel runtime elements of language like php javascript and java are usually written in c so the builders of those languages can solve the difficult data storage and allocation problems for you this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a software centered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 5 pointers and arrays before we start chapter 5 a quick note from your narrator from time to time i have been adding some of my interpretation to this book but i won't be adding anything to this chapter i think that sections 5.1 through 5.6 contain some of the most elegantly written text in the book the concepts are clearly stated and the example code is short direct and easy to understand pointers are the essential difference between c and any other modern programming language so pay close attention to this chapter and make sure that you understand it before continuing this chapter is as strong now as it was in 1978 and so without further ado we read and listen as kernighan and ritchie teach us about pointers and arrays a pointer is a variable that contains the address of another variable pointers are very much used in c partly because they are sometimes the only way to express a computation and partly because they usually lead to more compact and efficient code than can be obtained in other ways pointers have been lumped with a goto statement as a marvelous way to create impossible to understand programs this is certainly true when they are used carelessly and it is easy to create pointers that point somewhere unexpected with discipline however pointers can also be used to achieve clarity and simplicity this is the app aspect that we will try to illustrate section 5.1 pointers and addresses since a pointer contains the address of an object it is possible to access the object indirectly through the pointer suppose that x is a variable say int and that px is a pointer created in some as yet unspecified way the unary operator ampersand gives the address of an object so the statement px equals ampersand x semicolon assigns the address of x to the variable px px is now said to point to x the ampersand operator can be applied only to variables and array elements construct like ampersand open paren x 1 close paren and ampersand 3 are illegal it is also illegal to take the address of a register variable the unit the unary operator asterisk treats its operand as the address of the ultimate target and accesses that address to fetch the contents thus if y is also an int y equals star p x semicolon assigns to y the contents of whatever px points to so the sequence px equals ampersand x semicolon y equals star px semicolon assigns the same value to y as does y equals x it is also necessary to declare the variables that participate in all of this int x comma y semicolon int star px semicolon the declaration of x and y is what we have seen all along the declaration of the pointer px is new int star px semicolon is intended as a mnemonic it says that the combination star px is an end that is if px occurs in the context star px it is equivalent to a variable of type int in effect the syntax of the declaration for a variable mimics the syntax of expressions in which the variable might appear this reasoning is useful in all cases involving complicated declarations for example double a to f open parenthesis close parenthesis comma star dp semicolon says that in a particular expression a to f open friend close friend and star dp have values of type double you should also note the implication in the direction declaration that a pointer is constrained to point to a particular kind of objects pointers can occur in expressions for example if px points to the integer x then star px can occur in any context where x could y equal star px plus 1 sets y to 1 more than x printf open parenthesis double quote percent d backslash n double quote comma star px close paren prints the current value of x and d equals square root open paren open paren double close paren star p x close paren produces in d the square root of x which is coerced into a double before being passed to square root in expressions like y equals star px plus 1 the unary operators star and ampersand bind more tightly than arithmetic operators so this expression takes whatever px points at adds one and assigns it to y we will return shortly to what y equals star open paren px plus one close paren might mean pointer references can also occur on the left side of assignments if px points to x then star px equals zero sets x to zero and star px plus equals one increments it as does open paren star px close paren plus plus the parentheses are necessary in this last example without them the ink expression would increment px instead of what it points to because unary operators like star and plus plus are evaluated right to left finally since pointers are variables they can be manipulated as other variables can if py is another pointer to int then py equals px copies the contents of px into py thus making py point to whatever px points to section 5.2 pointers and function arguments since c passes arguments to functions by call by value there is no direct way for the called function to alter the variable in the calling function what do you do if you really have to change an ordinary argument for example a sorting routine might exchange two out of order elements with a function called swap it's not enough to write swap open parentheses a comma b close parentheses semicolon where the swap function is defined as and this is sample source code on page 91 of the textbook and you can see it at www.cc4e.com code this is a wrong swap by the way this this is showing you the code that you're not supposed to do swap open paren x comma y close paren int x comma y semicolon open curly brace int temp semicolon temp equals x x equals y semicolon y equals temp semicolon close curly brace because of call by value swap can't affect the arguments a and b in the routine that called it fortunately there is a way to obtain the desired effect the calling point program passes pointers to the values to be changed the call is swap open parentheses ampersand a comma ampersand b close parentheses semicolon since the operator ampersand gives the address of a variable ampersand a is a pointer to a in swap itself the arguments are declared to be pointers and the actual operands are accessed through them so the correct code is on page 92 swap open paren px comma py close paren int star px comma star py semicolon open curly brace int temp semicolon temp equals star px semicolon star px equals star py semicolon star py equals temp semicolon and closed curly brace one common use of pointer arguments is in functions that must return more than a single value you might say that swap actually returns two values the new values of its arguments as an example consider a function getint which performs a free format input conversion by breaking a stream of characters into integer values one integer per call getint has to return the value that it found or an end to file signal when there is no more input these values have to be returned as separate objects for no matter what value is used for eof that could also be a value of the integer one solution which is based on the input function scanf that we will describe in chapter seven is to have get in to return eof as its function value it finds end of file and other any other return value singles a normal integer the numeric value of the integer it found is returned through an argument which then must be a pointer to an integer this organization separates the end of file status from the returned numeric value the following loop fills an array with integers by calls to getint int n comma array open print size close paren semicolon for n equals zero n less than size double ampersand get int open paren ampersand v close print not equal eof semicolon and plus plus close parentheses array sub n equals v each call sets v to the next integer found in the input notice that is essential to write ampersand v instead of v as the argument to get int using plane v is likely to cause an addressing error since getint believes that it's been handed a valid pointer getint is an obvious modification to a to i which we wrote earlier the sample code is on page 93 of the textbook and you can see this sample code at dot www.cc4e.com slash code pound include stdio.h getint open paren pn close print int star pn semicolon open for open curly brace int c comma sign while open print open print c equals get ch open praying close paren close print double equals quote space quote or c double equals quote backslash n quote or c double equals backslash t quote close paren semicolon this loop we've done before and it skips the white space sine equals one semicolon if open paren c double equals quote plus quote or c double equals quote minus quote close paren open curly brace equals open parenthesis double equals quote plus quote close paren question mark 1 colon 1 semicolon c equals gut ch to advance the character semicolon and then close curly brace that those four lines record the sign now four star pn equals zero c greater than or equal to quote zero quote and c less than or equal to quote 9 quote colon semicolon c equals get ch open paren close paren close curly brace star pn equals 10 times star pn plus c minus quote zero quote star pn star equals sine if open paren c not equal to eof close print on get ch open paren c close paren semicolon return c throughout get int star pn is used as an ordinary int variable we have also used getch and ungetch as described in chapter four so the one extra character that must be read can be pushed backed on to the input section 5.3 pointers and arrays and see there is a strong relationship between pointers and arrays strong enough that pointers and arrays should really be treated simultaneously any operation which can be achieved by array subscripting can also be done with pointers the pointer version will in general be faster but at least to the uninitiated somewhat harder to grasp immediately the declaration int a sub 10 defines an array a of size 10 that is a block of 10 consecutive objects named a sub 0 a sub 1 dot dot a sub 9. the notation a sub i means the element of the array i positions from the beginning if p a is a pointer to an integer declared as int star pa then the assignment pa equals ampersand a sub zero sets pa to 0.2 the zeroth element of a that is pa contains the address of a sub zero now the assignment x equals star pa will copy the contents of a sub 0 into x if pay a points to a particular element of array a then by definition pa points to the next element nope if pa points to a particular element of an array a then by definition pa plus 1 points to the next element and in general a minus i points to i elements before p a and p a plus i points to i elements after thus if p a points to a sub zero star parentheses pa plus 1 closed parenthesis refers to the contents of a sub 1. pa plus i is the address of a sub i and star print and star open paren pa plus i is the contents of a sub i these remarks are true regardless of the type of the variables in the array a the definition of adding one to a pointer and by extension all pointer arithmetic is that the increment is scaled by the size of the storage of the object that is pointed to thus in pa plus i i is multiplied by the size of the objects that pa points to before being added to pa the correspondence between indexing and pointer arithmetic is evidently very close in fact a reference to an array is converted by the compiler to a pointer to the beginning of the array the effect is that the array name is a pointer expression this has quite a few useful implications since the name of an array is a synonym for the location of the zeroth element the assignment pa equals ampersand a sub zero can also be written as p a equals a rather more surprising at least at first sight is the fact that a reference to a sub i can also be written as star open paren a plus i close paren in evaluating a sub i c converts it to star open paren a plus i close paren immediately the two forms are completely equivalent applying the operator ampersand to both parts of this equivalence it follows that ampersand a sub i and a plus i are also identical a plus i is the address of the ith element beyond a as on the other side of this coin if p a is a pointer expressions may use it with a subscript p a sub i is identical to star open paren pa plus i close print in short any array and index expression can be rewritten as a pointer and an offset and vice versa even in the same statement there is one difference between an array name and a pointer that must be kept in mind a pointer is a variable so pa equals a and pa plus plus are sensible operations but an array name is a constant not a variable constructions like a equals pa or a plus plus or p equals ampersand a are illegal when an array name is passed to a function what is passed is the location of the beginning of the array within the call function this argument is a variable just like any other variable and so an arrayname argument is truly a pointer that is a variable containing an address we can use this fact to write a new version of stirlin which computes the length of the string the sample code is on page 95 of the book and you can see it in www.cc4e.com code page 95. int stirlin open paren s close prin char star s semicolon open curly brace int n semicolon four open parenthesis n equals zero semicolon star s not equal quote backslash zero quote semicolon s plus plus close paren n plus plus return open print and close paren semicolon close curly brace incrementing s is perfectly legal since it's a pointer variable s plus plus has no effect on the character string in the function that called sterlin but merely increments the stir lens private copy of the address as the formal parameters in a function definition char s open square bracket close square bracket semicolon and char star s semicolon are exactly equivalent which one should be written is determined largely by how expressions will be written in the function when an array name is passed to a function the function can at its convenience believe that has been handed either an array or a pointer and manipulated accordingly it can even use both kinds of operations if it seems appropriate and clear it is possible to pass part of an array to a function by passing a pointer to the beginning of the subarray for example if a is an array f open friend ampersand a sub 2 close print and f open paren a plus 2 close print both pass to the function f the address of the element a sub 2 because ampersand a sub 2 and a plus 2 are both pointer expressions that refer to the third element of a within f the argument declaration can read f open paren array close paren int array open bracket close bracket semicolon dot dot dot or f open paren array closed paren and star array semicolon so far as f is concerned the fact that the argument really refers to part of a larger array is really of no consequence section 5.4 address arithmetic if p is a pointer then p plus plus increments p to point to the next element of whatever kind of object p points to and p plus equals i increments p to the point i elements beyond where it currently does these and similar constructions are the simplest and most common form forms of pointer or address arithmetic c is consistent and regular in its approach to address arithmetic its integration of pointers arrays and address arithmetic is one of the major strengths of the language let us illustrate some of the properties by writing a rudimentary storage allocator but useful in spite of its simplicity there are two routines alec open paren and close paren returns a pointer p to n consecutive character positions which can be used by the caller of alec for storing characters free open paren p close print releases the storage thus acquired so it can later be reused these routines are rudimentary because the calls to free must be made in the opposite order to the calls on alec that is storage managed by alec and free is a stack or last in first out the standard c library provides analogous functions which have no such restrictions and in chapter 8 we'll show how improved versions as well in the meantime however many applications really only need a trivial alec to dispense little pieces of storage of unpredictable sizes at unpredictable times the simplest implementation is to have alec hand out pieces of a large character array which we will call alec buff this array is private to allocan free since they deal in pointers and not array indices no other routine need know the name of the array which can be declared as external static that is local to the source file containing allocan free and invisible outside it in practical implementations the array may well not even have a name it might be obtained by asking the operating system for a pointer to some unnamed block of storage the other information needed is how much alec buff has been used we use a pointer to the next free element called alex cp when alec is asked for n characters it checks to see if there is enough room left in alec buff if so alec returns the current value of alec p ie the beginning of the free block and then increments it by n to point to the next free area free p merely sets alec p to p if p is inside alec buff this next code example is on page 97 of the textbook you can see the code at www.cc4e.com code pound include stdio.h to find null zero it's a pointer value for in the error report pound define alec size 1000 the size of the available space static char alec buff open square bracket alex size close square bracket semicolon static chair char star alec p equals alec buff next free position initialized to the start of the array char star alec open paren and close paren return a pointer to n characters int n semicolon open curly brace if alec cp plus n less than or equal to alec buff plus alec size close paren open curly brace meaning we have space alex cp plus equals n return alex cp minus n close parenthesis semicolon close curly brace else if there's not enough room return open paren null close paren semicolon close curly brace free open paren p close print this function will free the storage pointed to by p char star p open curly brace if open paren p greater than equal to alec buff and p less than alec buff plus alex size alex cp equals p close curly brace some explanations in general a pointer can be initialized just as any other variable can though normally only meaningful values are null discussed below or an expression involving the address of a previously defined data of the appropriate type the declaration static char star alex cp equals alec buff defines alex cp to be a character pointer and initializes it to point to alec buff which is the next free position when the program starts this could also have been written static char stala star alex cp equals ampersand alec buff subzero semicolon since the array name is the address of the zeroth element whichever is more natural the test if open paren alec p plus n less than or equal to alec buff plus alex size checks if there's enough room to satisfy a request for n characters if there is the new value of alec p would be at most one beyond the end of alec buff if the request can be satisfied alec returns a normal pointer notice the declaration of the function itself if not alec must return some kind of signal that there's no space left c guarantees that no pointer that validly points to data will ever contain a zero so a return value of zero can be used to signal an abnormal event in this case no space we write null instead of zero however to indicate more clearly that this is a special value for a pointer in general integers cannot be meaningfully assigned to pointers but zero is a special case tests like if open for n alec p plus n less than or equal to alec buff plus alex size and if open paren p greater than or equal to alec buff and p less than alec buff plus alex size shows several important facets of pointer arithmetic first pointers may be compared on certain circumstances if p and q point to members of the same array then relations like less than greater than equal etc work properly p greater than q is true for example if p points to an earlier member of the array than q the relations double equals and not equals exclamation equals also work any pointer can be meaningly compared for equality or inequality with null but all bets are off if you do arithmetic or compu comparisons with pointers that point to different arrays if you're lucky you get obvious nonsense on all machines if you're unlucky your code will work on one machine but collapse mysteriously on another second we've already observed that a pointer and an integer can be added or subtracted the construction p plus n means the nth object beyond the one p currently points to this is true regardless of the kind of object p is declared to point at the compiler scales n according to the size of the objects p points to which is determined by the declaration of p for example on the pdp 11 the factors are one for char two for int and short and four for long float and dub and float and eight for double pointer subtraction is also valid if p and q point to members of the same array p minus q is the number of elements between p and q this fact can be used to write yet another version of sterlin sterling open for n s close paren char star s semicolon open curly brace char star p equals s semicolon while star p not equal backslash a single quote backslash zero single quote close paren p plus plus semicolon return open print p minus s close paren semicolon close curly brace in its declaration p is initialized s that is to point to the first character in the while loop each character in turn is examined until backslash zero at the end is seen since backslash zero is zero and since while tests only whether the expression is zero it is possible to omit the explicit test and such loops are often written as while open paren star p close paren p plus plus semicolon because p points to characters p plus plus advances p up to the next character each time and p minus f's gives the number of characters advanced over that is the string length pointer arithmetic is consistent if we'd been dealing with floats which occupying more storage than chars and if p were a pointer to a float p plus plus would advance to the next float thus we could write another version of alec which maintains say floats instead of chars merely by changing char to float throughout alec and free all the pointer manipulations automatically take into the account the size of the object pointed to so nothing else has to be altered other than the operations mentioned here adding or subtracting a pointer in an integer subtracting or comparing two pointers all other pointer arithmetic is illegal it is not permitted to add two pointers or to multiply or divide or shift or mask them or add float or double to them section 5.5 character pointers and functions a string constant written as double quote i am a string double quote is an array of characters in the internal representation the compiler terminates the array with the character backslash zero so programs can find the end the length in storage is thus one more than the number of characters between the double quotes perhaps the most common occurrence of a string constant is arguments to functions as in printf open paren double quote hello comma world backslash n double quote when a character string appears like this in a program access to it is through a character pointer what printf receives is a pointer to the character array character arrays of course need not be function arguments if message is declared as char star message then the statement message equals double quote now is the time double quote semicolon assigns message to a pointer to the actual characters this is not a string copy only pointers are involved c does not provide any operators for processing an entire string of characters as a unit in the language we will illustrate more aspects of pointers and arrays by studying two useful functions from the standard i o library to be discussed in chapter 7. the first function is stir copy open paren s comma t which copies the string t to the string s the arguments are written in this order by analogy to assignment where one would say s equals t to assign t to s the array version is first stir copy open paren s comma t close paren char s open square bracket close square bracket comma t open square bracket close square bracket semicolon open curly brace int i semicolon i equals zero semicolon while open paren open for n s sub i equals t sub i close paren not equal quote backslash 0 quote close parenthesis i plus plus semicolon close curly brace you'll note in that while statement that there is a copying of the actual characters as an assignment and then the side effect of the result of that assignment is compared to the new line at the end of string which terminates the while loop for contrast here is a version of stir copy with pointers and this is on page 100 of the textbook and you can see all the code in the textbook at www.cc4e code and again this is example number two on page 100. stir copy open paren s comma t close paren char star s comma star t semicolon open curly brace while open paren open paren star s equals star t close prin not equal single quote backslash zero single quote close print open curly brace s plus plus comma semicolon t plus plus semicolon close curly brace close curly brace to end the function because the arguments are passed by value stir copy can use s and t in any way it pleases here they are conveniently initialized pointers which are marched along the arrays a character at a time until the backslash terminates then t has been copied to s in practice their copy would not be written as we showed above a second possibility might be and this is the third example on page 100 of the textbook stir copy open vern s comma t close paren char star s comma star t semicolon open curly brace while paren paren star s plus plus equals star t plus plus close prin not equal quote backslash zero quote close paren semicolon curly brace this moves the increment and s and t into the test part the value of star t plus plus is the character that t pointed to before t was incremented the post fix plus plus doesn't change t until after this character has been fetched in the same way the character is stored in the old position of s before s is incremented the character is also the value that is compared against backslash zero to control the loop the net effect is that the characters are copied from t to s up to and including the terminating backslash zero as the final abbreviation of this solving this problem we can observe that the comparison against backslash zero is redundant so the function is often written as and now this is the first sample code on page 101 of the textbook stir copy open paren s comma t close paren char star s comma star t semicolon open curly brace while open paren star s plus plus equals star t plus plus closed paren semicolon curly brace although this may seem cryptic at first the notational convenience is considerable and the idiom should be mastered if for no other reason then you will see it frequently in c programs the second routine is stir comp open for n s comma t which compares the character strings s and t and returns negative zero or positive according to as s is lexigraphically less than equal to or greater than t the value returned is obtained by subtracting the characters at the first position where s and t disagree this is the second example on page 101 of the textbook which you can see at www.cc4e.com code stir comp open paren s comma t close parent char s open square bracket close square square bracket comma t open square bracket close square bracket semicolon open curly brace int i semicolon i equals zero semicolon while s sub i double equals t sub i close paren open print s sub i plus plus double equals single quote backslash zero single quote close paren return zero return open paren s sub i minus t sub i close paren semicolon close curly brace the pointer version of stir comb is the first example on page 102 of the textbook stir comp open paren s comma t close paren char star s comma star t open curly brace 4 open paren semicolon star s double equals star t semicolon s plus plus comma t plus plus close paren if open for n star s equal equal single quote backslash zero single quote close paren return open print 0 close paren return open print star s minus star t close paren semicolon close curly brace since plus plus and minus minus are either prefix or postfix operators the combination of star and plus plus and minus minus occur although less frequently for example star plus plus p increments p before fetching the character that p points to star minus minus p decrements p first section 5.6 pointers are not integers you may notice in older c programs a rather cavalier attitude towards copying pointers it has generally been true that on most machines a pointer may be assigned to an integer and back again without changing it no scaling or conversion takes place and no bits are lost regrettably this has led to the taking of liberties with routines that return pointers which are then merely passed to other routines the requisite pointer declarations are often left out for example consider the function stir save open paren s close paren which copies the string s into a safe place obtained by a call to alec and returns a pointer to it properly this should be written as this is the first example on page 103 of the textbook you can see the sample code at www.ccfree.com code pound include stdlib.h char star serv stir save open print s close paren save a string somewhere char star s semicolon open curly brace char star p star alec open paren close paren semicolon if open paren open paren p equals alec open paren sterling open paren s close paren plus one close paren close print not equal null close paren stir copy open paren p comma s close paren semicolon return open paren p close paren semicolon curly brace in practice there would be a strong tendency mistaken tendency that is to emit declarations this is the example 2 on page 103 pound include stdlib dot h stir save open paren s close paren open curly brace char star p semicolon if parentheses parentheses p equals alec open paren sterlin open paren s close print plus one close print close print not equal no close paren stir copy open paren p comma s close paren semicolon return open paren p close print semicolon this will work on many machines since the default type for functions and arguments is int an int and pointer can usually be safely assigned back and forth nonetheless this kind of code is inherently risky for it depends on the details of the implementation and machine architecture which may not hold for the particular compiler you use it is wiser to be complete in all declarations the program lind will warn of such constructions in case they creep in inadvertently section 5.7 multidimensional arrays in general rectangular multidimensional arrays are used in computational programs like a weather simulation and were a way back in the day to write c code that could accept fortran multidimensional arrays as parameters so that computational or statistical libraries can be written in c arrays of pointers are a better mapping to the typical operating system in string manipulation use cases that are more the core of c applications we also call these ragged arrays because each row can be a different length this also works well as data is dynamically allocated in c as compared to the more static allocation approach that's typical in fortran's multidimensional arrays now to the textbook c provides for rectangular multidimensional arrays although in practice they tend to be much less used than the arrays of pointers in this section we will show some of their properties consider the problem of date conversion from the day of the month to the day of the year and vice versa for example march 1st is the 60th day of a nonleap year and 60 first day of a leap year let us define two functions to do the conversions day of year converts month and day to the day of the year and month day converts the day of the year into the month and the day since this ladder function returns two values the month and day arguments will be pointers month day open parenthesis 1977 comma 60 ampersand m comma ampersand d close parentheses sets m to three and d to one which is march first these functions both need the same information a table of the number of days in each month 30 days half september et cetera since the number of days per month differs for leap years and nonleap years it's easier to separate them into two rows of a twodimensional array rather than try to keep track of what happens in february during computation the array and the functions performing the transformations are as follows this is example number one on page 104 of the textbook and you can see the code at www.cc4e.com code static int day tab open paren to close print open paren 13 close print equals open curly brace open curly brace 0 comma 31 and then a number of numbers close curly brace comma open curly brace 0 comma 31 29 and then a bunch of numbers close curly brace close curly brace semicolon day of the year open paren year come a month come a day int year come a month comedy semicolon open curly brace int i comma leap semicolon leap equals 0 year modulo 4 double equals 0 and year modulo 100 not equal 0 or year modulo 400 equals equals 0 semicolon for open paren i equals one i less than month i plus plus close paren day plus equals day tab open square bracket leap close square bracket open square bracket i close square bracket semicolon return open paren day close paren semicolon close curly brace then the month day function month day open paren year come a year day come a p month come a p day close paren int year come a year day star p month comma star p day semicolon open curly brace int i come a leap semicolon leap equals year percent four double equals zero and year percent 100 not equal zero or year percent 1400 double equals zero for i equals one year day greater than date tab open square bracket leap close square bracket open square bracket i close square bracket semicolon i plus plus close parenthesis your day minus equal day tab open square parenthesis open square bracket leap close square bracket open square bracket i close square bracket semicolon star p month equals i p day equals year day semicolon close paren the array day tab has to be external to both day of year and month day so they can both use it date tab is the first two dimensional array we've dealt with in c by definition a twodimensional array is really a onedimensional array each of which elements is also an array hence subscripts are written as day tab open square bracket i close square bracket open square bracket j close square bracket rather than day tab open square bracket i comma j close square bracket as in most languages other than this a twodimensional array can be treated much the same in the same way as other languages elements are stored by rows that is the rightmost subscript varies fastest as elements are accessed in storage order an array is initialized by list of initializers and braces each row of a twodimensional array is initialized by a corresponding sublist we started the array day tab with a column of 0 so that month numbers can run from the natural 1 to 12 instead of 0 to 11. since space is not a premium here this is easier than adjusting indices if a 2 dimensional array is to be passed to a function the argument definition declaration in the function must include the column dimension the row dimension is irrelevant since what is passed in as before it is a pointer this is in this particular case it's a pointer to objects which are arrays of 13 ins thus the array day tab if it's to be passed to a function f the declaration would be f open friend date tab close paren int day tab open square bracket 2 close square bracket open square bracket 13 close square bracket semicolon open curly brace dot dot dot close curly brace the argument declaration in f could also be int date tab open square bracket close square bracket open square bracket 13 closed square bracket semicolon since the number of rows is actually irrelevant it could also be seen as int open print star day tab close print open bracket 13 closed bracket semicolon which says that the argument is a pointer to an array of 13 integers the parentheses are necessary since the brackets have higher precedence than asterisk without parentheses the declaration int star day tab sub 13 close square bracket semicolon is an array of 13 pointers to integers as we shall see in the next section section 5.8 pointer arrays pointers to pointers since pointers are variables themselves you might expect that there would be uses for arrays of pointers this is indeed the case let us illustrate by writing a program that will sort a set of text lines into alphabetic order than a strippeddown version of the unix utility sort in chapter three we presented a shell sort function that would sort an array of integers this same algorithm will work except that now we have to deal with lines of text which are of different lengths and which unlike integers can't be compared or moved in a single operation we will need a data representation data structure that will cope efficiently and conveniently with variable length text lines this is where an array of pointers enters if the lines to be sorted are stored and in one long character array maintained by alec perhaps then each line can be accessed by a pointer to its first character the pointers themselves can be stored in an array two lines can be compared by passing their pointers to stir comp when two out of order lines have to be swapped or exchanged the pointers in the pointer array are exchanged not the text lines themselves this eliminates the twin problems of complex storage management and high overhead that would go with moving the text of the actual lines the sorting process involves three steps read all the lines of input sort them and then print them in order as usual it's best to divide the program into functions that match this natural division with the main routine controlling things let us defer the sorting step for a moment and concentrate on the data structures and the input in output the input routine has to collect and save the characters in each line and build an array of pointers to the lines it will also have to count the number of input lines since that information is also needed for sorting and printing since the input function can only cope with a finite number of input lines it can return some illegal line count like negative 1 if too much input is presented the output routine only has to print the lines in order in the order in which they appear in the array of pointers this next code segment is actually a combination of three successive sample code segments uh starting on page 106 of the textbook and it's pretty complex so you might be best it might be best for you to see them on www.cc4e.com slash code line 106 example one okay pound include stdio.h pound includes string.h pound define lines 100. the maximum lines of support to be sorted main open paren close paren char line ptr open brick ombud square bracket lines close square bracket semicolon int n lines which is the number of lines read if open paren open paren n lines equals read lines open paren line ptr comma lines close praying close paren greater than or equal to zero close paren open curly brace sort open paren line ptr comma n lines close paren write lines open print line ptr comma n lines close paren semicolon close curly brace else print f open paren double quote input too big to sort backslash n close double quote close paren semicolon and close curly brace to end the main program this next routine is actually from page 107 of the textbook but we combined them into one pound defined maxland1000 readlines openpren line ptr comma max lines close paren char star line ptr open square bracket close for a square bracket semicolon this is an array of pointers to characters an array of pointers pointers being you know long like four bytes characters being generally one byte int max line semicolon open curly brace int len comma n lines semicolon char star p star alec open print close paren comma line open square bracket max lane close square bracket semicolon so just to recall alec is a function we do we did later i mean did earlier that allows us to allocate uh some text of a varying length and then lines so maxlen is a place that we're going to read each line into beginning the code of read lines n lines equals zero while open paren open paren len equals get line open paren line comma max len close paren close friend greater than or equal to zero close paren if open print n lines greater than equal to max lines close paren return open paren minus one close paren semicolon else if open print open paren p equals alec open paren len close paren close paren double equals null close paren return minus one so those two tests basically make sure that we don't get too many lines and that we have enough space in our al dynamic data area that alec is managing for us so continuing with the if we're at the else opens curly brace line sub len minus one equals quote backslash zero quote semicolon stir copy p comma line close paren semicolon line ptr sub n lines plus plus equals p semicolon close curly brace that finishes the else segment return n lines semicolon and close curly brace to finish the read lines function now at a high level we're reading a line into a allocated automatic variable line and then we are calling alec to get another cop place to copy that line then we're making a copy of that line and then we are remembering the pointer to the beginning of that line in line ptr and that's the essence of it okay write lines open paren line ptr comma n lines close paren char star line ptr open square bracket close square bracket semicolon again an array of pointer characters int n lines semicolon which is the number of character pointers in line ptr open curly brace int i semicolon four paren i equals zero semicolon i less than n lines semicolon i plus plus close paren printf open paren double quote percent s backslash n double quote comma line ptr sub i close paren semicolon close curly brace a simple loop that goes through the array of character pointers and then prints each one out using printf the main new thing is the declaration for line ptr char starline ptr sub open square bracket lines close square bracket semicolon says that line ptr is an array of lines elements each element of which is a pointer to a char that is line ptr sub i is a character pointer and star line pr ptr sub i accesses a character since line ptr itself is an array that was passed to right lines it can be treated as a pointer exactly in the same manner as our earlier examples and the function can be written instead as right lines open paren line ptr comma n lines close paren char starline ptr open square bracket close square bracket semicolon int and line semicolon open curly brace while open paren minus minus n lines greater than or equal to zero close paren printf open paren double quote percent s backslash n double quote comma star line ptr plus plus close paren semicolon that code by the way was on page 108 example one of the textbook starline ptr points initially to the first line but each increment of line ptr advances it to the next line while n lines is counted down with input and output under control we can proceed to sorting the shell sort from chapter 3 needs minor changes the declarations have to be modified and the comparison operation must be moved into a function but the basic algorithm remains the same which gives us some confidence that it will still work and this is the second example on page 108 of the textbook and you can see this example at www.cc4e.com code start sort open paren v comma n close paren char star v open square bracket close square bracket semicolon and and semicolon open curly brace so we're getting an array of pointers to the beginnings of lines and how many of those pointers matter and the rest of it is shell sort with the stir comp being used to do the string comparison so it's a three nested for loop with a simple if test in it so here we go open curly brace for the sort function int gap comma i comma j semicolon char star semicolon and that's a pointer to a character four open paren gap equals n over two slash i mean semicolon gap greater than zero semicolon gap slash equals two close parenthesis 4 i equals gap semicolon i less than n semicolon i plus plus close parenthesis for open paren j equals i minus gap semicolon j greater than or equal to zero semicolon j minus equals gap close paren open curly brace so that's sort of the shell part of the shell sort and now we have to do our comparison if open paren stir comp open print v sub j comma v sub j plus gap close paren less than or equal to zero close paren break and note that that's only breaking the third deep for loop which it just goes and then runs the next iteration of the second for loop now we do the swapping temp equals b sub j semicolon v sub j equals a v sub j plus gap semicolon v sub j plus gap equals temp now that's just swapping pointer values so the the strings that are pointed to by these two pointers v sub j and v sub j plus gap if they're out of order we're going to swap the pointers in the array and move them so that if you then go through like we did in write lines earlier then um they come out in order but we literally read the data once we copy it once into the its final destination using alec alec and stir copy but once we sort it which is the most complex part of the calculation we're only moving the pointers back and forth so the sort is very efficient and requires no extra memory than what we had before the sort so that's really nice and it sorts in place so back to the text since any individual element of v which is an alias to line pointer ptr is a character pointer temp could also should also be one so one can be copied to the other we wrote the program about as straightforwardly as possible so as to get it working quickly it might be faster for instance to copy the incoming lines directly into an array made by read lines rather than copying them into line and then to a hidden place maintained by alec but it's wiser to make the first draft of something easy to understand and worry about efficiency later the way to make this program significantly faster is probably not by avoiding an unnecessary copy of the input lines just instead replacing the shell store sort by something quicker and better like quick sort is much more likely to make a real difference that matters in chapter one we pointed out that because while in for loops test the termination condition before executing the loop body even once they help to ensure that the programs will work at their boundaries in particular with no input it's illuminating to walk through the functions of the sorting program checking what happens if there is no input text at all section 5.9 initialization of pointer arrays consider the problem of writing a function month name open paren and close paren which returns a pointer to a character string containing the name of the mf month this is an ideal application for an internal static array month name contains a private array of character strings and returns a pointer to the proper one when called the topic of this section is how that array of names is initialized the syntax is quite similar to the previous initializations this is sample code from page 109 of the textbook which you can see at www.cc4e.com code char star month name open paren close print so the return value for this function is a character pointer int n semicolon open curly brace static char star name open square bracket close square bracket equals open curly brace quote illegal month quote comma double quote january double quote comma double quote february double quote comma and so forth down to double quote december double quote close curly brace semicolon the body of the function is one line return open paren open paren n less than 1 or n greater than 12 close paren question mark name sub 0 colon name sub n close paren semicolon close curly brace the declaration of name which is an array of character pointers is the same as line ptr in the sorting example the initializer is simply a list of character strings each assigned to the corresponding position in the array more precisely the characters of the i string are placed somewhere else and a pointer to them is stored in name sub i since the name size of the array name is not specified the compiler itself counts the initializers and fills in the correct number section 5.10 pointers versus multidimensional arrays newcomers to see are sometimes confused about the difference between a twodimensional array and an array of pointers such as name in the example above given the declarations int a open square bracket 10 close square bracket open square bracket 10 close square bracket semicolon and int star b open square bracket 10 close square bracket semicolon the usage of a and b may be similar in that a sub 5 5 and b sub 5 5 are both legal references to a single integer but a is a true array all 100 storage cells have been allocated and the conventional rectangular substrip calculation is done to find any given element for b however the declaration only allocates 10 pointers each must be set to point to an array of integers assuming that each does point to a 10 element array then there will be 100 storage cells set aside plus the 10 cells for the pointers thus the array of pointers uses slightly more space and may require an explicit initialization step but it has two advantages accessing an element is done by indirection through a pointer rather than by a multiplication and an addition and the rows of the array may be of different lengths that is each element of b need not point to a 10 element vector some may point to two elements others may point to 20 and some to none at all although we have phrased this discussion in terms of integers by far the most frequent use of arrays of pointers is like that shown in month name to store character strings of a diverse lengths section 5.11 command line arguments in environments that support c there is a way to pass command line arguments or parameters to a program when it begins executing when main is called to begin execution it is called with two arguments the first conventionally called arg c is the number of command line arguments the program was invoked with the second arg v is a pointer to an array of character strings that contain the arguments one per string manipulating these character strings is a common use of multiple levels of pointers i would note that back in 1978 the two largest bodies of c code were likely the at t unix kernel itself and unix utilities like grep ls or the login shell so writing an operating system was fresh on the mind of the authors while writing this book these topics find their way into the text of this book in a sense a likely second order goal of the book was to train programmers that might learn c and then might help build and maintain unix the 1978 edition of this textbook fits nicely into a series of att bell labs technic reports like the portability of c programs in the unix system written by stephen c johnson and dennis m ritchie published in the bell system technical journal volume 57 number six part two july through august 1978 pages 2021 through 2048. you can see this one online if you search for it back to the textbook the simplest illustration of the necessary declarations and use is in the program echo which simply echoes its command line arguments in a single line separated by blanks that is if the command echo hello comma world is given the output is hello comma world by convention arg v sub 0 is the name by which the program was invoked so argc is at least 1. in the above example argc is three and args arc v sub zero arc v sub one and args v sub two are echo hello comma and world respectively the first real argument is arc v sub 1 and the last is arg v sub rxc minus 1 and if argc is 1 there are no command line arguments after the program name this is shown in the source code to echo and this source code is on page 111 of the textbook and you can see this source code at www.cc4e.com code pound include stdio.h pound includes string.h main open paren argc comma arc fee close paren int argc semicolon char star argv open square bracket close square bracket semicolon open curly brace int i semicolon for open paren i equals one semicolon i less than rxc semicolon i plus plus close paren print f open paren double quote percent s percent c double quote comma arg v sub i comma open paren i less than r c minus one close paren question mark single quote space single quote colon single quotes backslash n single quote close parenthesis semicolon close curly brace to end it since argv is a pointer to an array of pointers there are several ways to write this program that involve manipulating the pointer rather than indexing an array let us show two variations and this is the example number two on page 111 of the textbook pawn include stdio.h pawn includes string.h main open paren rxc comma argv close paren int argc semicolon char star argv open square bracket close square bracket semicolon open curly brace while open paren minus minus arg c greater than zero close paren printf open paren double quote percent s percent c double quote comma star plus plus arg v comma open paren rxc greater than one close paren question mark single quote space single quote colon single quote backslash n single quote close paren semicolon close curly brace since arc v is a pointer to the beginning of an array of argument strings incrementing it by one plus plus rv makes it point to the at the original array arc v sub one instead of arc b sub zero each successive increment moves it along to the next argument star arc v is then the pointer to that argument at the same time argc is decremented and when it becomes zero there are no arguments left to print another version the third version on page 111 of the textbook pound include stdio.h pound includes string.h main open paren arg c com argv close paren int argc semicolon char star arc v open square bracket close square bracket semicolon open curly brace while open paren minus minus arg c greater than zero close paren print f open paren open paren argc greater than one close paren question mark double quote percent s blank double quote colon double quote percent s backslash n double quote comma star plus plus arg v close paren semicolon close curly brace this version so shows that the format argument of printf can be an expression just like any of the others this usage is not very frequent but worth remembering as a second example let's make some example enhancements to the pattern finding program from chapter 4. if you recall we wired the search pattern deep into the program and this is an obviously unsatisfactory arrangement for flexible code following the lead of the unix utility grep which stands for the generalized regular expression parser let us change the program so that the pattern to be matched is specified by the first argument on the command line this is example one on page 112 of the book which you can see at www.cc4e.com code pound include sddio.h pound includes string.h upon define max line 1000 main open paren arg c comma arg v close paren int r c semicolon char star arc v open square bracket close square bracket semicolon open curly brace char line open open square bracket max line close square bracket semicolon if open paren argc not equal to close paren printf double quote usage colon find pattern backslash n double quote close paren semicolon else while open pren getline open print line comma max line close paren greater than zero close paren if index open paren line comma arg v sub 1 close paren greater than or equal to 0 close paren printf open paren double quote percent s double quote comma line close paren semicolon close curly brace the basic model can now be elaborated to illustrate further pointer constructions suppose we want to allow two optional arguments one says print all the lines except those that match the pattern the second says precede its print each printed line with its line number a common convention for c programs is that an argument beginning with a minus sign introduces an optional flag or parameter if we choose minus x for accept to signal the inversion and minus n number to request line numbering then the command find space minus x space minus n the with the input now is the time for all good men to come to the aid of their party should produce two comma for all good men optional arguments should be permitted in any order and the rest of the program should be insensitive to the number of arguments which were actually present in particular the call to index should not refer to arg v sub 2 where a single flag argument and to arc v sub 1 when there was no single flag furthermore it's convenient for users if option arguments can be concatenated and as in find space dash nx space the here is the program and this program is on page 113 of the textbook and it is complex enough that i suggest that you take a look at it at www.cc4e.com code it's it's about 35 lines long the commentary on the program hopefully now you're watching looking at it arc v is incremented before each optional argument and argc is decremented if there are no errors at the end of the loop arg c should be 1 and star argv should point to the point to the pattern note that star plus plus arc v is a pointer to an argument string open paren star plus plus arc v close paren open square bracket zero square square bracket is its first character the parentheses are necessary for without them the expression would be star plus plus open paren arg v sub subzero close paren which is quite different and wrong an alternate valid form would be star star plus plus arg v section 5.12 pointers to functions in c a function itself is not a variable but it is possible to define a pointer to a function which can be manipulated passed to functions placed in arrays and so on we will illustrate this by modifying the sorting procedure written earlier in this chapter so that if the optional argument minus n is given it will sort the input lines numerically instead of lexographically a sort often consists of three parts a comparison which determines the ordering of any pair of objects an exchange which reverses their order and a sorting algorithm which makes comparisons and exchanges until the objects are in order the sorting algorithm is independent of the comparison and exchange operations so by passing different comparison and exchange functions to it we can arrange to sort by different criteria this approach is taken in our new sort the lexigraphic comparison of the two lines is done by stir comp and swapping by swap as before we'll also need a routine num comp which compares two lines on the basis of numeric value and returns the same kind of condition indication as stir comp does these three functions are declared in main and pointers to them are passed to sort sort in turn calls the functions via pointers we have skimped on error processing processing for arguments so as to concentrate on the main issues this sample code is from page 115 of the textbook which you can view at www.cc4e.com code pound include stdio.h pawn include string.h pawn defined lines 100 main open paren rxc comma arg v close current int argc semicolon char star arg fee open square bracket close square bracket semicolon open curly brace char star line ptr open for open bracket lines close square bracket semicolon this is the pointers to the text lines so we're going to be reading in the lines saving them and keeping an array of the pointer and then we're going to sort that way int n lines semicolon int stir comp open paren close print comma num comp open paren close paren which are comparison functions and swap open paren close print semicolon int numeric equals zero and this is going to be one if it's a numeric sort first we parse the arguments if open paren arg c greater than one ampersand ampersand arg v sub one sub zero equal equal quote minus quote and arg v opens bracket one close bracket open bracket one close bracket double equals quote end quote close paren numeric equals one if open paren open paren n lines equals read lines open paren line ptr comma lines close paren close paren greater than or equal to zero close paren open curly brace if open paren numeric close paren sort open print line ptr n lines num comp comma swap close paren semicolon else sort open print line ptr comma n lines comma stir comp comma swap close paren write lines line pr ptr comma n lines close paren close curly brace else print f open paren double quote input too big to sort backslash n double quote close paren semicolon stir comp num comp and swap are addresses of functions since they're known to be functions the ampersand operator is not necessary in the same way that it is not needed before an array name the compiler arranges for the address of the function to be passed the second step is to modify our sort function and this is the first example on page 116 of the textbook sort open paren v comma n comma comp comma e x c h exchange close paren char star v open square bracket close work square bracket semicolon that's our pointer array of pointers int and semicolon int open friends start comp close paren open print close paren comma open paren star exchange close paren open prayer and close paren semicolon that declared the type and the fact that these are pointers to functions it's a little more complex here in the called code open curly brace int gap comma i comma j semicolon and now we're going to do the three nested for loops for the quick sort no shell sort um and then the only really change is in the code checking to see if the uh two items pair of items are out of order and then what we do so four open paren gap equals n over two semicolon cap greater than zero semicolon graph gap slash equals two close paren for open print i equals gap semicolon i less than n semicolon i plus plus closed paren four open paren j equals i minus gap semicolon j greater than or equal to zero semicolon j minus equals gap close paren open curly brace and now here starts the different code if open print open print star comp close print open paren v sub j comma v sub j plus gap close paren less than or equal to zero close paren break open print star ex exchange close prin open print ampersand v sub j comma ampersand v sub j plus gap close paren semicolon close curly brace for the for loop and then close curly brace for the sort function and so really all we're doing is we're checking the order of the two items b sub j and b sub j plus gap and if they're out of order i.e less than or equal to zero i mean greater than or equal to uh greater than zero then we just exchange them with the provided exchange function and so the key thing here is it looks exactly like the previous time we wrote this code except we're calling the pointer to the comparison function and the pointer to the exchange function which is makes this flexible so it can handle different kinds of data back to the textbook the declaration should be studied with some care int open paren star comp close paren open paren close paren says that comp is a pointer to a function that returns an int the first set of parentheses are necessary without them int star comp open prank close paren would say that comp is a function returning a pointer to an end which is a quite different thing the use of comp in the line if open paren open paren star com close paren open print v sub j comma v sub j plus gap close print less than or equal to zero close paren is consistent with the declaration comp is a pointer to the function and star comp is the function and open paren star comp close paren open paren v sub j comma v sub j plus gap close paren is the call to it the parentheses are needed so the components are correctly associated we've only we've already shown stir comp which compares two strings here is num comp which compares two strings on a leading numeric value this is sample code from page 117 of the textbook which you can see at www.cc4e.com code numcomp open paren s1 comma s2 close paren char star s1 comma star s2 semicolon open curly brace double a to f open frame close paren comma v1 comma v2 v1 equals a to f open paren s1 close paren semicolon v2 equals a to f open print s2 close paren semicolon if open paren v1 less than v2 close print return open print 1 else if open print v1 greater than v2 close paren return open print 1 close paren semicolon else return open paren 0 close paren semicolon close curly price the final step is to add the function swap which exchanges the two pointers this is adapted directly from what we presented earlier in the chapter swap open paren px comma py close paren char star px open square bracket close square bracket comma star py open square bracket close square bracket semicolon open curly brace char star temp semicolon temp equals star px semicolon star px equals star py semicolon star py equals temp semicolon close curly brace there are a variety of other options that can be added to the sorting program some make challenging exercises this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardwarefirst vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 6 structures a structure is a collection of one or more variables possibly of different types grouped together under a single name for convenient handling while we talk about data structures and how to use them in every language this section is about understanding how software developers carefully control the low level shape of their data items to solve their problems when you first learn about the c struct keyword you might think it's equivalent to a python dict a dynamic key value store like a php array java myapp or javascript object but nothing is further from the truth these other languages provide us with easy to use data structures where all the challenging problems are solved this chapter tells or told the creators of python php java and javascript how to solve the complex problems and build convenient and flexible data structures which we now all use in those objectoriented languages one way to look at this code in this chapter is to think of it as a lesson on how one might build python's list and dict data structures if the code in the chapter takes you a little while to figure out mentally make a note of thanks for all the hard work that modern languages invest to make their high level data structures flexible and easy to use back to the textbook the traditional example of a structure is a payroll record an employee is described as a set of attributes such as name address social security number salary etc some of these in turn could be structures a name has several components as does an address and even a salary structures help organize complicated data particularly in large programs because in many situations they permit a group of related variables to be treated as a unit instead of separate entities in this chapter we'll try to illustrate how structures are used the programs that we will use are bigger than many others in the book but are still of modest size section 6.1 basics let us revisit the date conversion routines of chapter 5. a date consists of several parts such as the day month and year and perhaps the day of the year and the month name these five variables can all be placed in a single structure like this struct date open curly brace in day semicolon in month semicolon in int year semicolon and year day semicolon char mun name open square bracket for closed square bracket semicolon curly brace semicolon the keyword struct introduces a structure declaration which is a list of declarations enclosed embraces an optional name called the structure tag may follow the word struct as with date here the tag names this kind of a structure and can subsequently be used as shorthand for the detailed declaration the elements or variables mentioned in a structure are called its members a structure member or tag and ordinary ie nonmember variable can have the same name without conflict since they are always distinguished by context of course as a matter of style one would normally use the same names only for closely related objects the right brace that terminates the list of members may be followed by a list of variables just as for any basic type that is struct open curly brace dot dot dot close curly brace x comma y comma z semicolon is syntactically analogous to int x comma y comma z semicolon in the sense that each statement declares x y and z to be variables of the named type and causes space to be allocated for them a structured declaration that is not followed by a list of variables allocates no storage it merely describes a template or the shape of the structure if the declaration is tagged however the tag can be used in later definitions of the actual instances of the structure for example given the declaration of date above struct date d defines a variable d which is a structure of type date an external or static structure can be initialized by the following by following its definition with a list of initializers for the components struct date d equals open curly brace 14 comma 7 comma 1776 comma 186 comma double quote j u l double quote close curly brace semicolon a member of a particular structure is referred to in an expression by construction of the form structure name dot member the structure member operator dot connects the structure name in the member name to set leap from the date in structure d for example leap equals d dot year modulo four double equals zero and d dot year modulo 100 not equal to zero or d dot year modulo 400 double equal zero semicolon or to check the month name if open paren stir comp open paren d dot mun name comma double quote aug double quote close paren double equals zero close paren dot dot or to convert the first character of the month named lower case d dot mon name sub zero equals lower open paren d dot name sub zero close paren semicolon structures may be nested a payroll record might actually look like struct person open curly brace char name open square bracket name size close square bracket semicolon char address open square bracket adder size close square bracket semicolon long zip code semicolon long ss number semicolon double salary struct date birth date semicolon struct date hire date semicolon close curly brace semicolon the person structure contains two dates if we declare emp as struct person amp semicolon then emp.birthdate.month refers to the month of birth the structure member operator dot associates left to right section 6.2 structures and functions there are a number of restrictions on c structures the essential rules are that only operations you can perform on a structure are to take its address with ampersand and access one of its members this implies that structures may not be assigned or copied to as a unit and that they cannot be passed or returned from functions these restrictions will be removed in forthcoming versions furnace destructures do not suffer these limitations however so structures and functions do work together comfortably finally automatic structures like automatic arrays cannot be initialized only external or static structures can this prediction was indeed accurate modern c compilers do support the copying of a structure with a single assignment statement given that a c structure is just a fixed length block of memory it's easy easy to generate machine code to copy it a key bit to remember that when the c structure is copied it is done as a shallow copy a shallow copy copies the values of the variables and the pointers in the structure but does not make copies of any data which the pointers point to a structure that contains other structures i.e not pointers to structures and those structures are shallow copied as well back to the text let us investigate some of these points by rewriting the date conversion functions in the last chapter to use structures since the rules prohibit passing of a structure to a function directly we must either pass the component separately or pass a pointer to the whole thing the first alternative uses of de avere which as we wrote in chapter 5 d year day equals day of year open for n d year comma d dot month comma d dot day close paren semicolon the other way is to pass a pointer if we've declared higher date as struct date higher date semicolon and rewritten day of year we could then say higherdate.year day equals day of year open paren ampersand higher date close paren semicolon to pass a pointer to higher date to day of year the function has to be modified because its argument is now a pointer rather than a list of variables this example code is on page 122 of the textbook and you can see it at www.cc4e.com code struct date open curly brace int day semicolon int month semicolon in ear semicolon int year day semicolon and mun name open square bracket four close spread square bracket semicolon closed curly brace semicolon static int day tab open square bracket two close square bracket open square bracket 13 close square bracket equals open curly brace open curly brace zero come at 31 come at 28 come a 31 come a 30 come at 31 come with 30 come a 31 31 come a 30 come a 31 come a 30 31 close curly brace comma and then another list just as long as that co with a closed curly brace and a semicolon that just initialized the lookup table for the days in each month now on to the function day of year open paren pd close paren struct date star pd semicolon open curly brace and i come a day come a leap semicolon day equals pd minus greater than day semicolon leap equals pd minus greater than year percent for double equals zero and pd minus greater than year percent 100 not equal to zero or pd minus greater than year percent 400 double equal zero semicolon four open paren i equals one semicolon i less than pd minus greater than month semicolon i plus plus close paren day plus equals day tab open square bracket leap close square bracket open square bracket i close square bracket semicolon return open paren day close paren semicolon close curly brace the declaration struct date star pd says that pd is a pointer to a structure of type date the notion exemplified by pd minus greater than year i think i'll call that at this point pd right arrow because that's really what it is it's the minus greater than looks like an arrow to the right so i'm going to call it right arrow but it's really two characters pd right arrow year is new if p is a pointer to a structure then pd right arrow member of structure refers to the particular member the operator right arrow is a minus sign followed by a greater than since pd points to the structure the year member could also be referenced as open paren star pd closed paren dot ear but pointers to structures are so frequently used that the right arrow notation is provided both as a convenient shorthand the parentheses are necessary in open paren star pd close paren dot ear because the precedence of the structure member operator dot is higher than the pointer lookup operator asterisk both right arrow and dot associate to left from left to right so p right arrow q right arrow mem and emp dot birthdate dot month r open paren p right arrow q close paren right arrow mem and open parent emp dot birth date close paren dot month for completeness here is the other function month day rewritten to use the structure this is the first example on page 123 of the text which you can look at the source code at www.cc4e.com code i won't read the struct and the date the destruct date definition in the struct in static in day tab definition we'll just go month day month day open paren pd close paren struct date star pd semicolon open curly brace end i comma leap semicolon leap equals pd right arrow year percent four double equals zero and pd right arrow year percent 100 not equal to zero or pd right arrow year percent 400 double equals 0 semicolon pd right arrow day equals pd right arrow year day four open print i equals one semicolon pd right arrow day greater than day tab subleap sub i semicolon i plus plus close paren pd right arrow day minus equals day tab subleap sub i semicolon pd right arrow month equals i semicolon close curly brace the structure operators right arrow and dot together with parentheses for argument lists and square brackets for subscripts are the top of the precedence hierarchy and then thus bind very tightly for example given the declaration struct open curly brace int x int star y semicolon close curly brace star p semicolon then plus plus p right arrow x increments x not p because the implied parenthesization is plus plus open paren p right arrow x close paren parentheses can be used after the binding open paren plus plus p right arrow x increments p before accessing x and open paren p plus plus close paren right arrow x increments p afterward the last set of parentheses is unnecessary in the same way star p right arrow y fetches whatever y points to star p right arrow y plus plus increments y after what after accessing whatever it points to just like star s plus plus open paren star p right arrow y close paren plus plus increments whatever y points to and star p plus plus right arrow y increments p after accessing whatever y points to section 6.3 arrays of structures structures are especially suitable for managing arrays of related variables for instance consider a program to count the occurrences of each c keyword we need an array of character strings to hold the names and an array of integers to hold the counts one possibility is to use two parallel arrays keyword and key count as in char star keyword open square bracket n keys close square bracket semicolon int key count open square bracket n keys close square bracket semicolon but the very fact that the arrays are parallel indicates a different organization is possible each keyword entry is really a pair char star keyword semicolon int key count semicolon and there's an array of the pairs the structure declaration struct key open curly brace char star keyword semicolon int key count semicolon close curly brace key tab open square bracket n keys close square bracket semicolon defines an array key tab of structures of this type and allocate storage to them each element of the array is a structure this could also be written struct key open curly brace char star keyword semicolon int key count semicolon close curly brace semicolon struct key key tab open square bracket and keys close square bracket semicolon since the structure key tab actually contains a constant set of names it's easiest to initialize it once and for all when it's defined the structural initialization is quite analogous to the earlier ones the definition is followed by a list of initializers and closed embraces struct key open curly brace char star keyword semicolon int key count semicolon close curly brace key tab open square bracket close square bracket equals open curly brace double quote break comma 0 comma double quote case comma 0 comma double quote char comma 0 comma and so forth down to double quote unsigned double quote comma 0 comma double quote while double quote comma 0 closed curly brace semicolon these initializers are listed in pairs corresponding to the structure members it would be more precise to enclose initializers for each row or structure in the braces as in open curly brace double quote break double quote comma zero close curly brace comma open curly brace double quote case double quote comma zero close curly brace comma and so forth but the inner braces are not necessarily when the initializers are simple variables or character strings and when all are present as usual the compiler will compute the number of entries in the array key tab if the initializer is present and the open square bracket close square bracket is left empty the keyword counting program which begins with a definition of key tab the main routine reads the input repeatedly by calling a function get word that fetches input one word at a time each word is looked up in key tab with a version of binary the binary search function we wrote in chapter three of course the list of keywords has to be given in increasing order for this to work here is the first example on page 125 of the textbook you can see this at www.cc4e.com code pound include stdio.h pound define max word 20 pound defined letter quote a quote main open prem close paren open curly brace int n comma t semicolon char word open square bracket max word close square bracket semicolon while open paren open print t equals get word open paren word comma max word close paren close paren not equal eof close paren if open friend t double equal letter close paren if double open paren open paren n equals binary open paren word come a key tab comma n keys close paren close paren greater than or equal to zero close paren key tab sub n dot key count plus plus four open paren n equals zero semicolon and less than n keys semicolon and plus plus if open open paren key tab sub n dot key count greater than zero close paren print f double quote percent for d space percent s backslash n double quote comma key tab sub n dot key count comma key tab sub n dot keyword close paren semicolon and then a closed curly brace to finish main binary to find the word in the in the table binary open paren word comma tab comma n close paren char star word semicolon struct key tab open square bracket close work square bracket semicolon int n open curly brace int low comma high comma mid comma cond low equals zero semicolon high equals n minus one semicolon while open paren low less than or equal to high close paren open curly brace mid equals paren low plus high close paren over to semicolon if open paren open paren conned equals stir comp open paren word comma tab comma open square bracket mid close square bracket dot keyword close print close friend less than zero close paren hi equals mid minus one semicolon else if open paren con greater than zero close paren low equals mid plus one semicolon else return open paren mid close paren semicolon close curly brace to finish the while and then return open paren minus one close paren semicolon close curly brace and that's really a rewrite of the binary function from the earlier part where we're just taking the keyword and count and and look in and looking up in the array but then using the dot keyword to find the actual keyword back to the text we'll show function get word in a moment for now it suffices to say it returns letter each time it finds a word and copies the word into its first argument the quantity n keys is the number of keywords in key tab although we could count this by hand it's a lot easier and safer to do it by machine especially if the list is subject to change one possibility would be to terminate the list of initializers with a null pointer and then the loop along key tab just runs until the end is found but this is more than as needed since the size of the array is completely determined at compile time the number of entries is just the size of key tab divided by the size of the struct key c provides a compile time op unary operator called sizeof which can be used to compute the size of any object the expression size of open paren object close paren yields an integer equal to the size of the specified object the size is given in unspecified units called bytes which are the same size as a char closed paren the object can be an actual variable or an array or structure or the name of a basic type like int or double or the name of a derived type like a structure in our case the number of keywords is the array size divided by the size of one array element and this computation is used in a pound define statement to set the value of n keys pound define n keys open paren size of open or print key tab close print divided by size of open paren struct key close paren close paren now for the function get word we have actually written a more general get word than is necessary for this program but it is not really much more complicated get word returns the next word from the input where a word is either a string or of letters or digits beginning with a letter or a single character the type of the object that is is the returned function as a function value it is the letter if the token is a word eof render file or the character itself if it's nonalphabetic this sample code is on page 127 of the textbook which you can see at www.cc4e.com code pound define letter quote a quote pound defined digit quote zero quote get word open paren w comma limb close paren char star w colon semicolon int lim semicolon open curly brace int c comma t semicolon if open paren type open paren c equals star w plus plus equals get ch open paren close paren close paren not equal letter close print open curly brace start w equals quote backslash zero quote semicolon return open for nc close paren semicolon close curly brace that if statement has got some stuff going on in it you might want to look at it very closely while open paren minus minus limb greater than zero close paren open curly brace t equals type open friend c equals star w plus plus equals get ch open paren close paren close point semicolon if if open friend t not equal letter and t not equal digit close paren open curly brace unget ch open paren c close paren semicolon break semicolon close curly brace star open paren w minus one close paren equals quote backslash zero quote semicolon return open paren letter close paren semicolon close curly brace close curly brace that that example code has a lot of stuff about pointers and incrementing pointers and dereferencing pointers etc so take a good look at that code back to the text get word uses the routines get ch and unget ch which we wrote in chapter 4. when the collection of alphabetic of an alphabetic token stops get word has gone one character too far that call to unget ch pushes that character back on the input for the next call getword calls another function called type to determine the type of each individual character for input here is a version that's only for ascii this code is the second example on page 127 of the textbook at www.cc4e.com code type open paren c close paren in c semicolon yeah open curly brace if open paren c greater than or equal to quote a quote and c less than or equal to quote z quote or c greater than or equal to quote uppercase a quote and c less than or equal to quote uppercase z quote close paren return letter semicolon else if open paren c greater than or equal to quote zero quote and c less than or equal to quote nine quote close paren return open friend digit close paren semicolon else return open paren c close paren semicolon close curly brace the symbolic constants letter and digits can have any values that do not conflict with nonalphanumeric values and eof the obvious choices are quote a quote and quote zero quote get word can be faster if calls to the function type are replaced by references to the appropriate array type the standard c library provides macros like is alpha and is digit which operate in this manner section 6.4 pointers to structures to illustrate some of the considerations involved with pointers and arrays of structures let us write a keyword counting program again this time using pointers instead of array indices as an aside i would note that it's a classic early assignment in any programming language to do a word frequency program here is a python program from my python for everybody course to count words from an input stream handle equals open open parenthesis single quote romeo dot txt close single quote comma quote r quote close parenthesis words equals handle dot read open print close print dot split open friend close paren counts equals dict open paren close paren four word in words colon counts subword equals get open paren word comma zero close paren plus one print open parent counts close paren this section in this book implements a less general word counting program in c the code depends on several functions from earlier in the book and the code below is pretty complex where the programmer only has access to lowlevel language without powerful and easytouse data types like python's list or dict it is likely that keto van rossen read this book took a long look at this code and designed the dick data structure in python so the rest of us can write a data parsing and word frequency programming program in the above six lines of code without worrying about dynamic memory allocation pointer management string length and a myriad of other details that must be solved when you're solving this program in c since python is open source you can actually look at the c code that implements the dict object in a file called dict object dot c it is almost 6 000 lines of code and includes other files or utility code there thankfully we only have to write one line of python to use it counts equals dict open friend close paren we will leave the complex bits to the c programmers that build and maintain this section is not showing us how to use the python dict object rather it is showing how one would build a dick like structure using c so continuing with section 6.4 pointers to structures the external definition of key tab do not need to change but main and binary do need modification this is example on page 129 of the textbook and that is available at www.cc4e.com code pointer version of counting c keywords main open paren close paren open curly brace int t semicolon char word open square bracket max word close square bracket semicolon struct key star binary open paren close paren comma star p semicolon while open paren open paren t equals get word open paren word comma max word close paren close paren not equal e o f close paren if open print t equal equal letter close paren if open paren open paren b equals binary open paren word comma key tab comma n keys close paren close paren not equal null close paren p right arrow key count plus plus for p equals key tab p less than key tab plus n keys semicolon p plus plus close parenthesis if open paren p right arrow key count greater than zero close paren printf open paren double quote percent for d space percent s backslash n double quote comma p right arrow key count comma p right arrow keyword and now we look at the binary search struct key star binary open paren word come tab comma n close paren char star word struct key tab open square bracket close square bracket semicolon int n open curly brace int cond semicolon struct key star low equals ampersand tab sub zero semicolon struct key star high equals ampersand tab sub n minus one semicolon struct key equals mid while open paren low less than or equal to high close paren open curly brace mid equals low plus high minus low divided by 2. if open paren open for n cond equals stir comp word comma mid right arrow keyword close print close paren less than zero close paren hi equals mid minus one semicolon else if close print con greater than zero close paren low equals mid plus one semicolon else return open paren mid close print semicolon close curly brace to finish the while and then return open paren null close paren close curly brace there are several things worthy of note here first the declaration of binary must indicate that it returns a pointer to the structure type key instead of an integer this is declared both in main and in binary if binary finds the word it returns a pointer to it if it fails it returns null second all the accessing elements of key dab is done by pointers this causes one very significant change in binary the computation of the middle element can no longer be simply mid equals paren low plus high close paren divided by two because the addition of two pointers will not produce any kind of useful answer even when divided by two and is fact illegal this must be changed to mid equals low plus open paren high minus low close paren divided by two which sets mid to the point to point to the element halfway between low and high you should also study the initializers for low and high it is possible to initialize a pointer to the address of a previously defined object and that is precisely what we have done here in main we wrote four open paren p equals key tab semicolon p less than key tab plus n keys semicolon p plus plus close paren if p is a pointer to a structure any arithmetic on p takes into the account the actual size of the structure so p plus plus increments p by the correct amount to get to the next element in the array of structures but don't assume that the size of a structure is the sum of the sizes of its members because alignment requirements for different objects potentially may cause holes in the structure finally an aside on program format when a function returns a complicated type as instruct key star binary open paren word comma tab comma n close paren the function name can kind of be hard to see and or find with a text editor alternately another style is sometimes used on two lines now struct key star on the first line in binary open paren word comma tab comma n close paren the spacing is mostly a matter of personal taste pick the form you like and hold to it section 6.5 selfreferential structures before we start this section a slightly longer aside from your narrator up to now i've resisted the temptation to augment the book with my own bits of code but we have reached the single point in the book where i feel that there is too big of a conceptual leap between two sections so i'm going to add some of my own narrative between sections 6.4 and 6.5 the rest of this chapter talks very nicely about binary trees and hash tables both essential lowlevel data structures in computer science and both excellent ways to understand pointers and how c can be used to build data structures like the python dictionary however the authors skip separately describing the structure of a dynamic dynamically constructed linked list which is the first and foundational collection data structure in computer science it should be understand be understood before moving to tree and hash map structures linked lists form the foundation of the python list object java array object php numeric key arrays and javascript arrays the linked list can be dynamically extended and items can be added in the middle efficiently as well as being pushed or popped on or off the front or back of the list linked lists are used also to implement cues as well as other aspects of operating system i will attempt to mimic the author's writing style in this new section of the book i'll write some sample code using a more modern dialect of c so it's easier to run on a modern compiler section 6.5.1 linked lists bonus content suppose we want to read a file and print the file in reverse order we don't know how many lines will be in the file before we read the file so we can't simply use an array of pointers to strings and character arrays like lines in a sense we need a dynamic array that grows as we encounter new lines when we reach the end of the file we then just loop through our stored lines from the end to the beginning so we can print them out in reverse order one solution is to make a data structure called a doubly linked list of character strings in addition to each line of data we will store a pointer to the previous line and the next line as well as well as a pointer to the first item we add to the list and then we'll call this the head of the list and then the most recent item we've added to the list which we'll call the tail of the list we will see a singly linked list as part of the hashmap data structure in a following section a single link list can only be traversed in a forward direction a doubly linked list can be traversed either forwards or backwards given that our linked list of strings will keep expanding as we get new lines we avoid hard coding array sizes like pound define maxlen1000 in the previous chapter we were building a program to sort a file going back to the description of a line in our doubly linked list it is clearly a structure with three components struct l node open curly brace char star text semicolon struct l node star prev semicolon struct l node star next semicolon close curly brace this recursive definition of l node might look chancy but it's actually quite correct it is illegal for a structure contained to contain an instance of itself but struct l node star prev declares preeve to be a pointer to an l node not an l node itself we'll write this code in a more modern c dialect using modern memory allocation i o routines provided by the standard c library this code is on page 130 of the textbook available at slash www.cc4e.com pound include stdio.h pound include std live.h pawn includes string.h pound define max line 1000 this is the length of the line not the number of lines struct l node open curly brace char star text semicolon struct l node star preview semicolon struct l node star next semicolon close curly brace semicolon now we have our main program to print the lines in reverse and we will use int main open paren close paren because we're coding in a modern dialect of c open curly brace struct l node star head equals null semicolon struct l node star tail equals null semicolon char line sub max line semicolon while open paren f get s open paren line comma max line comma s t d i n close paren not equal null close print open curly brace char star save equals open print char star close prin malloc open prin sterlin open print line close paren plus one close paren semicolon stir copy save come align struct l node star new equals open paren struct l node star close paren malloc open paren size of struct l node close paren close paren semicolon new right arrow text equals save new right arrow next equals null new right arrow preview equals tail and tail equals new if head equals equals null close paren head equals new semicolon close curly brace to finish the while now we'll print it all out four open paren struct l node star current equals tail semicolon current not equal to null semicolon current equals current right arrow prev close parenthesis open curly brace printf open paren double quote s close double quote comma current right arrow text close paren semicolon close curly brace to finish the four and then close curly brace to finish the main interestingly if we wanted to print the list in forward order or if we did have only a singly linked list our loop would look as follows four open paren struct l node star current equals head semicolon current not equal to null semicolon current equals current right arrow next closed paren open curly brace printf open paren double quote percent s double quote comma current right arrow text close paren semicolon close curly brace in general we use the variable names head tail and current as well as next and pre or similar names when writing code that builds or uses a linked list or so other programs will quickly understand what we are talking about after a while reading a for loop to traverse a linked list becomes as natural as reading a for loop that progresses through a sequence of numbers sections 6.5.2 binary trees suppose we want to handle the more general problem of counting the occurrences of all the words in some input since the list of words isn't known in advance we can't conveniently sort it and use a binary search yet we can't do a linear search for each word that has arrived to see if it's already been seen the program would take forever more precisely what is the expected running time and it would grow quadratically with a number of input words how can we organize the data to cope efficiently with a list of arbitrary words our solution is to keep the set of words seen so far sorted at all times by placing each word into its proper position in the order as it arrives this should this shouldn't be done by shifting the words in a linear array though that takes too long instead we will use a data structure called a binary tree the tree contains one node per distinct word each node contains a pointer to the text of the word a count of the number of occurrences of the word a pointer to the left child node and a pointer to the right child of node no node may have more than one at more than two children it might have only zero or one the nodes are maintained so that any node in the left tree contains only words that are less than the words at the node and the right tree only contains words that are greater to find out whether a new word is already in the tree one starts at the root and compares the new word to the word starting at that node if they match we found it if the new word is less than the tree word the search continues down the left otherwise the right child is searched there is no child in the required direction then the word is not in the tree and in plaque in fact the proper place for it to be is the missing child this search process is inherently recursive since the search for many node uses a search from one of its children accordingly recursive routines for inserting and printing will be the most natural going back to the description of a node is clearly a structure with four components struct t node open curly brace char star word int count semicolon struct t note star left semicolon struct t node star right semicolon closed curly brace this recursive declaration of a node might look chancy but actually it's quite correct it's illegal for a structure to contain an instance of itself but struck t node star left semicolon declares left to be a pointer to a node not a node itself the code for the whole program is surprisingly small given the handful of supporting routines that we've already written these are get word to fetch input and alec to provide space for squirreling the words away the mahin routine simply reads words with getword installs them in the tree with tree this is the first example on page 131 of the textbook which you can see at www.cc4e.com code pound include stdio.h pound defined max word 20 pound defined letter single quote a single quote main open paren close paren open curly brace struct t node star root comma star tree open print close paren semicolon char word open square bracket max word close square bracket semicolon and t semicolon root equals null while open paren open parent t equals get word open paren word comma max word close print close paren not equal eof close paren if open paren t double equal letter close paren root equals tree open paren root comma word close paren semicolon tree print open paren root close paren semicolon close curly brace tree itself is straightforward a word is presented by main to the top level root of the tree at each stage that word is compared to the word already stored at the node and is percolated down either to the left or right subtree by a recursive called a tree eventually the word either matches something already in the tree in which case the count simply is incremented or a null or pointer is encountered indicating the node must be created and added to the tree if a new node is created tree rent turns a pointer to it which is installed in the parent node this is the example on page 132 of the textbook at wwe code pound includes string dot h struct t node open curly brace char star word semicolon int count semicolon struct t node star left semicolon struct t node star right semicolon close curly brace semicolon struct t node star tree open paren p comma w close paren we're going to install w at or below p struck t node star p semicolon char star w open curly brace struct t node star t alec open paren close paren semicolon char star stir state stir save open for n close paren semicolon int conned semicolon if open paren p double equal null close paren open curly brace we've got a new word p equals t alec open print close paren to make a new note p right arrow word equals stir save open paren w close paren semicolon p right arrow count equals 1 p right arrow left equals p right arrow right equals null close curly brace else if open paren open print con equal stir comp w comma p right arrow word close paren close paren double equals zero close paren p right arrow count plus plus indicate that we've seen the word one more time else if open paren conned less than zero close paren lower will go into the left part of the tree p right arrow left equals tree p right arrow left comma w close paren semicolon else p right arrow right equals tree open friend p right arrow right comma w close paren semicolon return open paren p close paren semicolon close curly brace and that's a bit of code it's not much and it's beautiful recursion is happening the return p at the very end is really really important because we're kind of always overriding it but we're okay so um the overriding works its way back up to the recursion because it's recursive it's using pointers away we go back to the text storage for the new node is fixed by a routine called t alec which is an adaptation of the alec we wrote earlier it returns a pointer to a free space suitable for holding a tree node we'll discuss this more in a moment the new word is copied to a hidden place by stir save the count is initialized and the two children are made null this part of the code is executed only at the edge of the tree when a new node is being added we have unwisely for a production program omitted error checking on the values between returned by stir save and t alec tree print prints the tree in left sub tree order at each node it prints its left subtree all the words less than this word then the word itself then the right subtree all the words greater if you feel shaky about recursion draw yourself a tree and printed with tree print it's one of the cleanest recursive routines you can find this example code is on page 133 of the textbook which you can see at www.cc4e.com code i won't read the struct node code just tree print tree print open paren p close paren struct t node star p semicolon open curly brace if open paren p not equal to null close parend curly brace open curly brace tree print open paren p air right arrow left close paren semicolon printf percent 4d space percent s backslash n double quote comma p right arrow count comma p right arrow word sum print close parenthesis semicolon tree print open print p right arrow right close paren semicolon close curly brace for the if and then close curly brace for the tree print function again i agree with the authors and that is one of the cleanest and most beautiful and most applicable uses of recursion that you will probably ever see in all your career i'm not a fan of recursion in all uses cases but you really can't do this any other way well back to the text practic as a practical note if the pre tree becomes unbalanced because the words don't arrive in random order the running time of the program can grow too fast as a worst case if the forwards are already in order this program does an expensive simulation of linear search there are generalizations of the binary tree notably 2 3 trees avl trees and i would add balanced binary trees which do not suffer from this worst case behavior but we will not describe them here before we leave this example it's also worth a brief digression on a problem related to storage allocators clearly it's desirable that there only be one storage allocator in a program even though it allocates different kinds of objects but if one allocator is to process requests for say pointers to chars and pointers to struck t nodes two questions arise first does it meet the requirement of most real machines that objects of a certain types must satisfy alignment restrictions for example integers must often be located uneven addresses second what declarations can cope with the fact that alec necessarily returns different kinds of pointers alignment requirements can generally be satisfied easily at the cost of some wasted space merely by assuring ensuring the allocator always returns a pointer that meets all alignment restrictions for an example on the pdb11 it is sufficient that alec always returns an even pointer since any type of object may be stored at an even address the only cost is a wasted character on the odd length requests similar actions are taken on other machines thus the implementation of alec may not be portable but its usage is the alec of chapter 5 does not guarantee any particular alignment in chapter 8 we'll show how to do the job right as an aside by now you know that when the authors mentioned the pdp11 they are sharing some aspects of the challenge of making c work on previous generation computers with short memory words and small amounts of memory and at the same time making them work well on the incoming generation of computers with larger words and more memory the research thought and care that went into making sure the c code was portable across multiple generations of computer hardware is on display in the previous paragraph the question of the type declaration for alec is a vexing one for any language that takes its type checking seriously in c the best procedure is to declare that alec returns a pointer to char and then explicitly coerce the pointer into the desired type with a cast therefore if p is declared as char star p semicolon then open paren struct t node star close paren p converts it into a t node pointer expression thus t alec is written as t node star t alec open paren close paren open curly brace char star alec return open paren open print struct t node star close print alec open paren sizeof open prin struct t node close prin close paren close print this is more than is needed for current compilers but represents the safest course for the future i would add that these concerns that the authors mentioned in this section are also nicely resolved in modern c compilers in the nc version of c they introduce the notion of the void type the void type indicates the lack of a type much like null is used to indicate not a valid pointer or not a flying toy in 1978 because the chart type was generally the most native type on any system it was often used as the generic pointer needed to return memory from an allocation function in modern c we use pointers to void and then cast the returning pointer to be a pointer to whatever struct or other data we just allocated if we were writing alec the alec routine in this book using modern c it would return a pointer to white the 1978 version is char star alec open paren close paren and the modern version is void star alec open paren close paren we've left the book alone we haven't used void throughout the book but it is a testament to the foresight of the authors that all the pointer casting code in this book still works today the same regardless of whether the memory allocation functions return char or void pointers to the allocated data sections 6.6 table lookup as an aside in this section we finish our quick tour of the implementations of the three core data structures in computer science one the linked list two the tree and three the hash map as described in this section a singly linked list is also part of a hashmap implementation so you can compare it to the doubly linked list code introduced in the earlier bonus section 6.5.1 this section is worth understanding well because not only is it an excellent review of pointers and structures but also because one of the most common questions on a facetoface programming interview is draw a hashmap on the whiteboard and explain how it works this is an easy question if you study and understand this section of the book and almost impossible if you have not in some ways this section is the most intricate data structure that's described in the book it is why it is so popular in coding interviews chapters 7 and 8 talk about lots of practical things like input output of the unix operating system elegant data structures and their use are core concepts in computer science understanding them highlights the difference between a good programmer and a computer scientist in a sense understanding how a hashmap is the secret handshake of computer science and it is the secret handshake because of this book and this section of this book written back in 1978 and used in a course that the person interviewing you may have took when they were in college hash maps were difficult for them to understand back then and so if you understand the concept then you must be solid so i hope you pay close attention to this section and remember the handshake back to the text in this section we will write the innards of a table lookup package as an illustration of more aspects of structures this code is typical of what might be found in the symbol table management routines of a macro processor or a compiler for example consider the c pound define statement when a line like pound define yes one is encountered the name replacement text the name yes and the replacement text one are stored in a table later when the name yes appears in a statement like inward equals yes semicolon it must be replaced by one there are two major routines that manipulate the names and replacement texts install open paren s comma t close paren records the name s and replacement t in the table s and t are just character strings lookup open paren s close print searches for s in the table and returns a pointer to the place where it was found or null if it wasn't there the algorithm used is a hash search the incoming name is converted to a small positive integer which is then used to index into an array of pointers an array element points to the beginning of a chain of blocks describing the names that have the hash value and if it is null then no names have hashed to that value a block in the a block in the chain is a structure containing pointers to the name the replacement text and the next block in the chain a null next pointer marks marks the end of the chain struct and list open paren char star name semicolon char star def semicolon struct endless star next semicolon close curly brace semicolon the pointer array is just pound define hash size 100 static struct and list star hash tab open square bracket hash size close square bracket semicolon the hashing function which is used by both lookup and install simply adds up the character values in the string and forms the remainder modulo the array size this is not the best possible algorithm but it has the merit of extreme simplicity hash open paren s close paren char star s semicolon open curly brace int hash val four open curly brace hash val equals zero star s not equal quote single quote backslash zero single quote semicolon close paren hash val plus equals star s plus plus semicolon return open paren hash val modulo percent hash size close paren semicolon close curly brace as an aside hashing functions are one of the foundational notions in computer science hashing functions are used for everything from high performance inmemory structures organizing databases data digital signing network packet checksums security algorithms and much more the above text is a really great example of a really simple hashing function you should understand this simple presentation well so that when you encounter a more complex implementation or use of hashing you can fall back on this text to understand that at its core hashing is a very simple concept so much of this chapter is a succinct example of some of the most powerful concepts in computer science please don't look at the eight code lines of code above and think i got that and just jump to the next bit this chapter is showing you the way of the master programmer wax on wax off be patient slow down and enjoy your time here back to the text the hashing process produces a starting index in the array hashtag if the string is to be found anywhere it will be in the chain of blocks beginning there the search is performed by lookup if lookup finds the entry already present it just returns a pointer to it if not it returns null here's the code struct and list star lookup open paren s close paren char star s semicolon open curly brace struct and list star np semicolon for open paren np equals tab sub hash open paren s close paren close square bracket semicolon np not equal null semicolon np equals np right arrow next close parenthesis if stir comp open print s comma np right arrow name close paren double equals zero return open print np close paren semicolon return open print null close print semicolon close curly brace install uses lookup to determine whether the name installed is already present if so the new definition must supersede the old one otherwise a complete newly new entry is created install returns no if for any reason there's no room for a new entry struct and list star install open friend name common death close paren jar star name comma star def semicolon open curly brace struct endless star np comma star lookup open print close brand semicolon char stir save comma star alec open print close paren semicolon int val semicolon if open paren open paren np equals lookup open paren name close paren close print double equal null close paren open curly brace i.e it's not found np equals open paren struct end list star close paren alec open paren size of open paren star np close paren close paren semicolon np equals null return null that means the allocation failed if open paren open paren np right arrow name equals stir save open paren name close print close paren double equals null close paren return open paren null close paren semicolon hash val equals open paren np right arrow name close brand semicolon np next equals tab open square bracket hash val close for bracket second semicolon hash tab open square bracket hash valve close spur bracket equals np semicolon we're actually pushing these new ones to the head of this singly linked list and so those last two statements push the the most recent top of the list forward and then replace with the new one at the top of the list the list does not stay in any order so we have a closed curly brace to end all that if for the not found code close curly brace else this is the already code click already their code free open paren np right arrow def close paren semicolon free the previous definition that's the string part of the the the pound define if open paren np right arrow def equal stir save open paren def close print close print equals null close print return open paren null close paren semicolon return open print np close print semicolon close curly brace so that last bit there was to if you have a pound define with the same keyword and a different later you have it later a different uh definition you can replace the definition so that last bit was replacing the definition again this code is a pretty intricate it's really both the hash table and a singly linked list going on at the same time so take a close look at this on page 136 of the book stir save merely copies the string given its argument to a safe space obtained by a call to alec we've showed this code in chapter five since calls to alec and free may occur in any order and since alignment matters the simple version of alec is just not adequate here see more in chapters 7 and 8. as an aside one of the reasons that the authors make vague forwardlooking statements we know that they talk about dynamic memory is that largescale memory management in a programming language is still a subject of active research 40 years later back in 1978 it was absolutely not a settled topic you can see this when the authors build a simple nonproduction memory allocation scheme with their own alec and free routines backed by a fixed length static extern array of characters dynamic allocation is essential to writing competency programs but it is likely that the production grade dynamic memory support was still somewhat nonportable when the book was written so they used simple selfcontained implementations in this book modern dynamic memory support is through the mala c alec and free functions in the standard library these functions request dynamic memory blocks from the operating system and manage those areas on behalf of your c code on unix and unixlike systems the memory allocation layer asks the underlying operating systems for blocks of memory through the sbrk interface even with virtual memory programmers must carefully manage their use of dynamically allocated memory because memory is never unlimited section 6.7 fields when storage space is at a premium it may be necessary to pack several objects into a single machine word one especially common use is a set of single bit at flags in applications like compiler symbol tables externally imposed data formats such as interfaces to hardware devices also often require the ability to get at pieces of a word as an aside we are going to go now from low level programming to even lower level programming the unix operating system is written in c and unix needs to have for example an implementation of the internet protocol so it can be connected to the internet one of the most important internet protocols is the transmission control protocol tcp in order to implement tcp you need to send very precisely formatted data across the network the data is very tightly packed in order to save precious network bandwidth the exact format of a tcp header is described in the tcp wikipedia page if you look at the header you will find that it bits 96 through 99 tcp expects a four bit integer that defines the data offset exactly what this data means is less relevant unless you're actually writing the tcp implementation but it does demonstrate that we need to control our data layout at times on a bit by bit basis this section covers how we can use struct to build up a tcp header in c which can be parsed and set without using masking and shifting operations with hardcoded numbers the section below is simpler than constructing a valid tcp header using a carefully packed struct but it does lay the groundwork for these more complex situations now back to the text imagine a fragment of a compiler that manipulates a symbol table each identifier in a program has certain information associated with it for example whether or not it's a keyword whether or not it's external and or static and so on the most compact way to encode such an information is a set of onebit flags in a single char or int the usual way this is done is define a set of masks corresponding to the relevant bit positions as in pounddefying keyword 01 pounddefine external 02 and pound defined static 0 4. the numbers of course must be powers of 2 so that the shifting works then accessing the bits become a matter of bit fiddling with shifting masking and complementing operators which were described in chapter 2. certain idioms of fear appear frequently flags vertical par equals external vertical bar static turns on the external and static bits and flags while flags ampersand equal tilled open paren external or static closed paren semicolon turns them off and if open paren open print flags ampersand paren external vertical bar static close paren close print equal equal zero dot dot dot is true if both bits are off although these idioms are readily mastered as an alternative c offers the capability of defining and accessing fields within a word directly rather than by bitwise logical operators a field is a set of adjacent bits within a single int the syntax of field definition and access is based on structures for example the symbol table palm defines above could be replaced by the definition of three fields struct unsigned is keyword colon one semicolon unsigned is extern colon one semicolon unsigned is static colon 1 semicolon closed curly brace flags this defines a variable called flags that contains three 1bit fields the number following the colon represents the field width in bits the fields are declared unsigned to emphasize that they are really unsigned quantities individual fields are referenced as flags.is keyword flags.is extern etc just like other structure members fields behave like small unsigned integers and may partic participate in arithmetic expressions just like the other integers thus the previous examples may be written much more naturally as flags is underscore extern equals flags is static equals one semicolon turn the bits on flags is extern equals flags is static equals one semicolon to turn the bits on flags dot is extern equals flags dot is static equals zero turns them off and if open paren flags dot is extern double equals zero and flags dot is static double equals zero close paren dot dot to test them a field may not overlap an int boundary if the width would cause this to happen the field is aligned to the next in boundary fields need not be named unnamed fields with a colon and width only are used for padding the special width 0 may be used to force alignment to the next int boundary there are a number of caveats that apply to fields perhaps the most significant fields are assigned left to right on some machines and right to left on others reflecting the nature of different hardware this means that although fields are quite useful for maintaining internally defined data structures the question of which end comes first have to has to be carefully considered when picking apart externally defined data other restrictions to bear in mind fields are unsigned they may only be stored in ins or equivalently unsigned they are not arrays and they do not have addresses so the ampersand operator cannot be applied to them section 6.8 unions a union is a variable which may hold at different times objects of different types and sizes with the compiler keeping track of the size and alignment requirements unions provide a way to manipulate different kinds of data in a single area of storage without embedding any machine dependent information in the program for example again from a compiler symbol table suppose constants may be ins floats or character pointers the value of a particular constant must be stored in a variable of the proper type yet it is most convenient for table management if the value occupies the same amount of storage and is stored in the same place regardless of its type this is the purpose of a union to provide a single variable which can legitimately hold one of several types as with fields the syntax is based on structures union u tag open curly brace int ival semicolon float f val semicolon char star pval semicolon closed curly brace uval the variable uval will be large enough to hold the largest of these three types regardless of the machine it is compiled of compiled on the code is independent of hardware characteristics any one of these types may be assigned to uval and then used in expressions so long as the usage is consistent the type retrieved must be the type most recently stored it is the responsibility of the programmer to keep track of what type is currently stored in the union the results are machine defendant dependent if something is stored as one type and extracted as another type syntactically members of a union are accessed as union name dot member or union pointer right arrow member justice for structures if the variable you type is used to keep track of the current type start in uval then one might see code as if open paren you type double equals int close paren printf paren double quote percent d backslash n double quote comma uval dot ival close parent semicolon else if open paren you type double equal float close paren print f open paren double quote percent f backslash n double quote comma u val dot f val close paren semicolon else if open paren you type double equals string close paren print f double quote percent s backslash n double quote comma u val dot p val close paren semicolon else printf open paren double quote bad type percent d and you type backslash n double quote comma you type close paren semicolon unions may occur in structures and arrays and vice versa the notion for accessing a member of a union in a structure or vice versa is identical that to that for nested structures for example in the structure array defined by struct open curly brace char star name semicolon int flags semicolon and you type semicolon union open curly brace int ival semicolon float f val semicolon char star p val semicolon close curly brace u val semicolon close curly brace sim tab open square bracket end sim close square bracket the variable i val is referred to as sim tab sub i dot u val dot ival and the first character of the string p val by star sim tab sub i dot uofl.pival in effect a union is a structure in which all the members have offset zero the structure is big enough to hold the widest member and the alignment is appropriate for all types in the union as with structures the only operations currently permitted on unions are accessing a member and taking the address unions may not be assigned to pass to functions or returned by functions pointers to unions can be used in a manner identical to pointers to structures as it aside the above limitations on unions are just no longer accurate like structures modern c compilers can assign the contents of the union to another union variable you can also pass unions into functions by value and receive a union as the return type of a function the storage allocator in chapter 8 shows how a union can be used to force a variable to be aligned on a particular kind of storage boundary section 6.9 type def c provides a facility called typedef for creating new data type names for example the declaration type def space int space length semicolon makes the name length a synonym for end the type length can be used in declarations cast etc in exactly the same ways int can be length len comma maxlen semicolon length star lengths open square bracket close four bracket semicolon similar the declaration type def char star string semicolon makes string a synonym for char star or a character pointer which then may be used in declarations like string p comma line ptr open square bracket lines close square bracket comma alec open paren close paren semicolon note that the type being declared in a typedef appears in the position of a variable name not right after the word typedef syntactically typedef is like the storage class extern static etc we've used uppercase letters in these examples to emphasize the names a more complicated example we could make typedefs for the tree nodes shown earlier in the track chapter typedef struct t node open curly brace char star word semicolon hint count semicolon struct t node star left semicolon struct t node star right semicolon close curly brace tree node comma star tree ptr this creates three two new type keywords called tree node which is a structure and tree ptr which is a pointer to the structure then the routine t alec could become tree ptr t alec open paren close print open curly brace char star alec open print close paren semicolon return open paren open paren tree ptr close print alloc open print size f open paren tree node close print close paren closed brand semicolon closed curly brace it should be emphasized that a typedef declaration does not exactly create a new type in any sense it merely adds a new name for some existing types nor are there any new semantics variables declared this way have exactly the same property as variables who whose declarations are spelled out explicitly in effect typedef is like defined except that since it's interpreted by the compiler it can cope with textual substitutions that are beyond the capabilities of the c macro preprocessor for example typedef int open paren star pfi close print open for enclosed print semicolon creates the type pfi to mean pointer to a function returning integer which can be used in context like pfi stir comp comma num comp comma swap in the sort program in chapter 5. there are two main reasons for using typedef declaration the first is to parameterize a program against portability problems if type defs are used for the data types which may be machine dependent only typedefs need to change when the program is moved one common situation is to use typedef names for various integer quantities and then make an appropriate set of choices of short int and long for each host machine the second purpose of type defs is to provide better documentation for a program a type called tree ptr may be easier to understand than one declared only as a pointer to a complicated structure finally there's always the possibility that the futures a compiler or some other program such as lind may make use of the information contained in typedef declaration to perform some extra checking on the program this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardwarefirst vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 7 input and output input and output facilities are not part of the c language so we've deemphasized them in our presentation thus far nonetheless real programs do interact with their environment in much more complicated ways than those we've shown before in this chapter we will describe this standard io library a set of functions designed to provide a standard i o system for c programs the functions are intended to present a convenient programming interface yet reflect only operations that can be provided on most modern operating systems the routines are efficient enough that users should seldom feel the need to circumvent them for efficiency regardless of how critical the application finally the routines are meant to be portable in the sense that they will exist in compatible form on any system or c exists and that programs which confine themselves to facilities provided by the stated library can be moved from one system to another essentially without change we will not try to describe the entire io library here we are more interested in showing the essentials of writing c programs that interact with our operating system environment section 7.1 access to the standard library each source file that refers to the standard library function must contain the line pound include stdio.h near the beginning the file stdio.h defines certain macros and variables used by the i o library the use of angle brackets less than and greater than instead of the usual double quotes directs the compiler to search for the file in a directory containing the standard header information in unix this is often somewhere like slash user slash include furthermore it may be necessary when loading the program to specify the library explicitly for example on the pdp11 unix system the command to compile a program would be cc source files etc dash ls capital s where dash l capital s indicates loading from the standard library section 7.2 standard input and output catch our input char the simplest input mechanism is to read a character at a time from the standard input generally the user's terminal or keyboard with getchar getchar returns the next input character each time it's called in most environments that support c a file may be substituted for the terminal by using the less than config convention if a program prog uses get char then the command line prog less than infile causes probe to read infile instead of the terminal or keyboard the switching of input is done in such a way that prog is oblivious to the change in particular the string less than infile is not included in the command line arguments in argv the input switching is also invisible if the input comes from another program by a pipe mechanism the command line other probe vertical bar prog runs two programs other prog and prog and arranges for the standard input for prog to come from the standard output of other prog cat char returns the value eof when it encounters endtofile on whatever input is being read the standard library defines the symbolic eof constant to be 1 with a pound defined in the file stdio.h but test should be written in terms of eof not negative 1. so is to be independent of the specific value for output put char open paren c close paren puts the character c on the standard output which is also by default the terminal or screen the output can be directed to a file by using greater than if probe uses put char prog greater than out file will write the standard output onto outfile instead of the terminal on the unix system a pipe can also be used prog vertical bar another prog puts the standard output of prog into the standard input of other prog again prog is not aware of the redirection output produced by printf also finds its way to the standard output and calls to put char and printf may be interleaved a surprising number of programs read only one input stream and write only one output stream for such programs i o with getchart putchar and printf may be entirely adequate and is certainly enough to get started this is particularly true given file redirection in a pipe file for connecting the output of one program to the input of the next for example consider the program lower which maps input to lower case this is an example on page 145 with a textbook that you can see at www.cc4e.com code pound include stdio.h pound includes c type dot h main open print close paren open curly brace int c while open paren open paren c equals get char open paren close paren close print not equal to eof close paren put char is upper open paren c close paren question mark two lower open paren c close paren colon c close paren semicolon close curly brace the functions is upper and two lower are actually macros defined in c type dot h the macro is upper tests whether its argument is an uppercase letter returning nonzero if it is and zero if it's not the macro two lower converts an uppercase to lowercase letter regardless of how these functions are implemented on a particular machine their external behavior is the same so programs that use them are shield shielded from the knowledge of their character set to convert multiple files you can use a program like the unix cat to collect files cat file1 file2.verticalbar lower greater than output and thus avoid learning how to access files from a program the cad example is presented later as example code in this chapter as an aside the standard io library functions getchar and put char can actually be macros and thus avoid the overhead of a function call per character we'll show this how this is done in chapter 8. section 7.3 formatted output printf the two routines printf for output and scanf f4 input which we describe in the next section permit translation to and from character representations of numerical quantities they also allow generation or interpretation of formatted lines we've used printf informally throughout the previous chapters here is a more complete and precise description printf open paren control com arg1 comma card 2 etc close paren printf converts formats and prints its arguments on the standard output under this under the control of the string control the control string contains two type of objects ordinary characters which are simply copied to the output stream and conversion specifications each of which causes conversion and printing of the next successive argument to printf each conversion specification is introduced by the character sense sign and ended by a conversion character between the percent and the conversion character there may be a minus sign which specifies left adjusted of the left adjustment of the converted argument in its field a digit string specified a minimum field width the converted number will be printed in a field at least this wide and wider if necessary if the converted argument has fewer characters than the field it will be padded on the left or right if the left adjustment indicator's been given to make up the field width the padding character is normally blank in zero if the field width is specified with a leading zero this zero does not imply an octal field with a period which separates the field width from the next digit string a digit string that specifies the precision which specifies the maximum number of characters to be printed from a string or the number of digits to be printed to the right of the decimal point of a float or a double a length modifier the letter l which indicates that the corresponding data item is along rather than an end conversion characters and their meanings are d the arguments converted to decimal notation o the argument is converted to unsigned octal notation without a leading zero x the argument is converted to unsigned hexadecimal notation without the leading 0x u the argument is converted to unsigned decimal notation c the argument is taken to be a single character s the argument is a string characters from the string are printed until a null character is reached or the number of characters indicated by the present precision specification is exhausted e the argument is taken to be a float or a double and converted to decimal notation of the form optional minus sign m dot nnn capital e plus or minus xx where the length of the string of the ends is specified by the precision the default by precision the default precision is 6. note that the precision does not determine the number of significant digits printed in the f format g says use percent e or percent f which ever is shorter and nonsignificant zeros are not printed if the character after the percent is not a conversion character the character is simply printed thus percent may be printed as percent percent most of the format conversions are obvious and have been illustrated in the earlier chapter one exception is the precision field as it relates to strings the following table shows the effect of a variety of specifications in printing hello comma world which is 12 characters we put colons around each field so you can see its actual width colon percent 10 s colon colon hello world colon it's 12 characters long and so we get 12 characters printed because we haven't really told it to strictly limit that colon percent minus 10 s colon colon hello comma world colon no extra spaces again 12 characters are used even though if we said 10 it expands it to 12 and the fact that it's left justified seems how we're printing more than the width of the field doesn't make any difference colon percent 20 s colon colon eight spaces then hello comma world colon eight spaces are put in on the left because it by default is right justified colon percent minus 20 s colon prints colon hello comma world and then eight spaces and then colon we've told it to left justify so the eight spaces are added to fill it out to 20 spaces after hello world colon percent 20.10 s colon gives us colon and then 10 blanks and then hello comma w o r colon now in this case we've told it we really only want 10 characters from the string and so the the ld is truncated percent minus 20.10 s colon hello comma w o r and then 10 spaces and it's less justified so the ten spaces are at the end right before the colon colon percent dot 10 s colon colon hello comma wor colon so now the overall field that's printed is exactly 10 characters and it is the leftmost 10 characters warning printf uses its first argument to decide how many arguments follow and what their types are it will get confused and you will get nonsense answers if there are not arguments enough arguments or they are of the wrong type as an aside formatted output is difficult the design of c printf was inspired by the earlier format statement in fortran and alcohol in order to compete with those languages c needed to ship with solid support for formatted output the approach chosen by c percolated into c like languages php and java simply have a function called printf that mimics most of the c formats python has evolved its approach to formatted output over the years an early initial solution had a syntax that used percent to provide c like formatting there was also a format method on the string object for example x equals 421.34 print open paren double quote x is percent 7.2 f double quote percent open paren x comma close paren close paren that uses the percent operator and sends a tuple but the syntax of percent seven point two f is the same another option is print open paren double quote x is open curly brace y colon 7.2 f close curly brace double quote dot format open paren y equals x close paren close paren this sends a set of key value pairs and it's a little clunky the latest and least clunky way to do it in modern python is what we call f strings and the code is print f double quote print open paren f double quote x is open curly brace x colon 7.2 f close curly brace double quote close paren but even after all this evolution much of this output formatting still traces its design inspiration from the nc printf capabilities back in 1978. formatted input scanf the function scanf is the input analog of printf providing many of the same conversion facilities but in the opposite direction scanf open paren control com arg1 comma r2 etc close paren scanf reads characters from standard input interprets them according to the format specified in control and stores the results in the remaining arguments the control argument is described below the other arguments each of which must be a pointer indicate where the converting corresponding converted input should be stored the control string usually contains conversion specifications which are used to direct interpretation of input sequences the control string may contain blanks tabs or new lines we call these white space characters which are ignored ordinary characters not percent which are expected to match the next nonwhite character space character of the input stream conversion specifications consisting of the character percent an optional assignment suppression character asterisk and an optional number specifying the maximum field width and a conversion character a conversion specification directs the conversion of the next input field normally the result is placed in the variable pointed to by the corresponding argument if assignment suppression is indicated by the asterisk character however the input field is parsed but then simply skipped no assignment is being made an input field is defined as a string of nonwhite space characters extent it extends to either the next white space character or until the field width if specified is exhausted this implies that scanf will read across line boundaries to find its input since new lines are white space the conversion character indicates the interpretation of the input field the corresponding argument must be a pointer as required by the call by value semantics of c the following conversion characters are legal d a decimal integer is expected on input the corresponding argument should be an integer pointer o an octal integer at with or without a leading zero is expected on input the corresponding argument should be an integer pointer x a hexadecimal integer with or without the leading zero x is expected in the input this corresponding argument should be an integer pointer h a short integer is expected in the input the corresponding argument should be the point a pointer to a short integer c a single character is expected the corresponding argument should be a character pointer the next input character is placed at the indicated spot the normal skip over white space characters is suppressed in this case to read the next nonwhite space character use percent one s s a character string is expected the corresponding argument should be a character pointer pointing to an array of characters large enough to accept the string and turn the terminating backslash zero which will be added f a floating point number is expected the corresponding argument should be a pointer to a float the conversion character e is a synonym for f the input formats for floats is an optional sign a string of numbers possibly containing a decimal point and an optional exponent field containing an upper or lower case e followed by possibly a signed integer the conversion character d o and x may be preceded by l the letter l to indicate that a pointer to a long rather than end appears in the argument list similarly the conversion characters e or f may be preceded by the letter l to indicate that it's a pointer to a double rather than a float in the argument list for example the call int i float x char name open square bracket 50 close square bracket close a semicolon scanf open parenthesis double quote percent d space percent f space percent s double quote comma ampersand i comma ampersand x comma name close paren semicolon with the input line 25 space 54.32 e minus 1 space thomson we'll assign the value 25 to i the value 5.432 to x and the string thompson properly terminated with a backslash 0 to name the three input fields may be separated by as many blanks tabs and new lines as desired the call int i semicolon float x semicolon char name open square bracket 50 close square bracket semicolon scanf double quote percent to d space percent f space percent star d space percent to s double quote comma ampersand i comma ampersand x common name close parentheses with input 56789 space 0 1 2 3 space 4 5 a 7 2 will assign 56 to i 7 89.0 to x skip over 0 1 2 3 and place the string 45 in name the next call to any input routine will begin searching at the letter a in these two examples name is a pointer and thus must not be preceded by an ampersand as another example the rudimentary calculator of chapter 4 can now be written with scanf to do the input put conversion this is example code on page 150 the textbook which you can see at www.cc4e.com code pound include stdio.h main open paren close paren open curly brace double sum comma v semicolon sum equals zero while open paren scanf open paren double quote percent l f double quote comma ampersand v close parenthesis not equal eof close parentheses printf open parenthesis double quote backslash t percent.2f backslash n double quote comma sum plus equals v close parenthesis semicolon close curly brace scanf stops when it's in when it exhausts control string or when some input fails to match the control specification it returns as its function residual value the number of successfully matched and assigned input items this can be used to decide how many input items were found on end to file eof is returned note that this is different from zero which means that the next input character does not match the first specification in the control string the next call to scanf resume searching immediately after the last character already returned a final warning the arguments to scanf must be pointers by far the most common error is writing scanf open paren double quote percent d percent comma n close paren semicolon instead of scanf open paren double quote percent d double quote comma ampersand n close paren semicolon section 7.5 in memory format conversion the functions scanf and printf have siblings called scan f and s printf which perform the corresponding conversion but operate on a string instead of a file the general format is s printf open paren string comma control comma arg one comma r two dot dot close paren s scan f open paren string comma control comma arg one comma r two et cetera close paren sprint s print f formats the arguments in arg1 arg2 etc according to control as before but it places the result in a string instead of on the standard output of course string had better be big enough to receive the result as an example if the name is a character array and n is an integer then s printf open paren name comma double quote temp percent d double quote comma n arg2 etc these arguments must be pointer the call scanf open paren name comma double quote temp percent d double quote comma ampersand n close parenthesis semicolon sets n to the value of the digits following temp in name section 7.6 file access as inside the next two sections do a nice job of covering file input and the notion of the standard error with simple sample code but the authors are also making a subtle point about unix and how the design of c makes it easy to build unix utilities by the end of section 7.6 we see a 29 line program that is pretty much a complete implementation of the core functionality of the unix cat command part of the philosophy of unix was to build commands that are each simple building blocks that can be composed using standard input standard output redirection as well as pipes these next two sections are a gentle celebration of the design principles that underlie the unix operating system also while we're talking about the linkage between c and unix there is a unixrelated easter egg earlier in the chapter see if you can find it bonus points if you already noticed it the programs written so far have all read the standard input and written the standard output which we have assumed are magically predefined for a program by the local operating system the next step in i o is to write a program that accesses a file which is not already connected to the program one program that clearly illustrates the need for such operations is cat which concatenates a set of name files onto standard output cad is used for printing files on a terminal and is a general purpose input collector for programs which do not have the capability of accessing files by name for example the command cat x dot c y dot c prints the contents of the files x dot c and y.c on the standard output the question is how to arrange for the named files to be read that is how to connect the external names the user that the user thinks of to the statements which actually read the data the rules are simple before it can be read or written the file has to be opened by the standard library function f open f open takes an external name like x dot c or y dot c does some housekeeping and negotiating with the operating system some details of which do not need to concern us and returns an internal name which then must be used for subsequent reads or rights of the file the internal name is actually a pointer called the file pointer to a structure which contains information about the file such as the location of a buffer the current character position in the buffer whether the file is being read or written and similar users don't need to know the details because part of the standard i o definitions are obtained from stdio.a and it's a structured definition called file the only declaration needed for a file pointer is exemplified by file star f open open paren close paren comma star fp semicolon that says that fp is a pointer to a file and f open returns a pointer to a file note that file is a type name like int not a structure tag it's implemented as a typedef details on how all this works on the unix system are given in chapter eight the actual call to f open in a program is fp equals f open open paren name comma mode close paren semicolon the first argument of f open is the name of the file as a character string the second argument is the mode also a character string which indicates how one intends to use the files allowable modes are read are write w or append a if you open a file which does not exist for writing or appending it is created if possible opening an existing file for writing causes the old constants to be discarded trying to read a file that does not exist is an error and there may be other causes of error as well like trying to read a file when you don't have permission if there is any error f open will return the null pointer with a value of null which for convenience is also defined in stdio.h the next thing needed is a way to read or write the file once it is open there are several possibilities of which get c and putsy are the simplest getc returns the next character from a file it needs the file pointer to tell what file thus c equals getc open paren fp close paren places in c the next character from the file referenced by fp and eof when it reaches end of file put c is the inverse of get c put c open paren c comma f p close paren puts the character c on the file fp and returns c like getchar and putchar gets the input c may be macros instead of functions when a program is started three files are automatically opened and file pointers are provided for them these files are the standard input the standard output and the standard error output the corresponding file pointers are called stdin sddi out and stder normally these are all connected to the terminal but stdn and std out may be redirected to files or pipes as described in section 7.2 getchar and putchar can be defined in terms of getc put c std in and std out as follows pound define get char open for n close paren get c open paren stdin close paren pound define put char open paren c close paren put c open for n c comma std out close paren for formatted input or output files the function f scan f and f printf may be used these are identical to scanf and printf save that the first argument is a file pointer that specifies the file to be read or written the second string is the control the second argument is the control string with these preliminaries out of the way we are now in a position to write the program cat to concatenate files the basic design is one that has been found convenient for many programs if there are command line arguments they are processed in order if there are no arguments the standard input is processed this way the program can be used standalone or part of a larger process this example is on page 153 of the textbook and you can see it at www.cc4e.com code pound include stdio.h main open paren argc comma argv closed paren int argc semicolon char star argv open square bracket close square bracket semicolon open curly brace file star fp comma star f open open chrome close print semicolon if open paren rxc double equals one close paren there is no standard there's no arguments so we're going to copy the standard input file copy open paren stdin close paren semicolon else while open paren minus minus rxc greater than zero close paren if open paren open paren fp equals f open open paren star plus plus arc v comma quote r quote close paren close paren double equals null close paren open curly brace print f open print double quote cat colon can't open space percent s backslash n double quote star comma star r v close paren semicolon break semicolon close curly brace else open curly brace file copy open paren fp close paren semicolon f close open paren fp close print semicolon close curly brace for the if then else and then close curly brace for the main and now we have the file copy function we're going to open read all the contents of a file pointer and send it to standard output file copy open paren fp close paren file star fp semicolon open curly brace int c semicolon while open paren open for n c equals get c open paren fp close print close paren not equal eof close paren put c open paren c comma std o ut close paren semicolon close curly brace the file pointers std in and std out are predefined in the i o library as the standard input and the standard output they may be used anywhere an object of type file star can be they are constants however not variables so don't try to assign to them the function f close is the inverse of f open it breaks the connection between the file pointer and the external name that was established by x f open freeing the file pointer for another file since most operating systems have some limit on the number of simultaneously open files a program may have it's a good idea to free things when they're no longer needed as we did above in cat there's also another reason for f close on an output file it flushes the buffer in which put c is collecting output fclose is called automatically for each open file when a program terminates normally section 7.7 error handling stder and exit the treatment of errors in the previous implementation of cat is not ideal the trouble is that if one of the files can't be accessed for some reason the diagnostic is printed at the end of the concatenated output that is acceptable if the output's going to a terminal but it's really bad if it's going to a file or some other program via pipeline to handle this situation better a second output file called stderr is assigned to the program in the same way that stdin and std out are if at all possible output written on stderr appears on the user's terminal even if the standard output is redirected let's revise cat to write its error messages onto the standard output file this is really only a couple of lines of code different between the example on page 153 this is the example on page 154 of the textbook which of course you can see at www.cc4e.com code pound include stdio.h pound include stdlib.h open paren argh c comma arc v close paren int argc semicolon char star arc v open square bracket close square bracket semicolon open curly brace file star fp comma star f open open paren close paren semicolon if open for n r c double equal one close paren here we have no arguments file copy open paren s t d i close parent semicolon else while open paren minus minus argc greater than zero close paren if open paren open paren fp equals f open open print star plus plus arg v comma double quote r double quote close paren and close for n double equal null close paren open curly brace f print f open paren std e r r comma double quote cat colon can't open percent s backslash n double quote comma star r v close paren semicolon exit open paren one close brand semicolon close curly brace else open curly brace file copy open paren fp close paren semicolon file close open print fp close paren semicolon close curly brace to finish the if and then exit open paren zero close paren semicolon close curly brace to the uh change the finish the main and file copy we is the same from the previous so this program signals errors two ways the diagnostic output produced by fprintf goes to stderr so it finds its way to the user's terminal instead of disappearing down a pipeline pipeline or into an output file the program also uses the standard library function exit which terminates execution when it's called the argument of exit is available to whatever process called this one so the success or failure of the program can be tested by another program that uses this one as a sub process by convention a return value of 0 signals all as well and various nonzero values signal abnormal situations exit calls fclose for each open output file to flush any buffered output then calls a routine named underscore exit the function underscore exit causes immediate termination without any buffer flushing of course it may be called directly if desired section 7.8 line input and output the standard library provides a routine f git s which is quite similar to the getline function we've used throughout the book the call fcds open paren line comma max line comma fp close paren reads the next input line including the new line from the file fp into the character array line at most max line minus 1 characters will be red the resulting line is terminated with backslash zero normally f cades returns line on end to file it returns null our getline returns line length and zero friend to file for output the function f put s writes a string which need not contain a new line to a file f put s open paren line comma fp close paren to show there's nothing magic about the functions like f get s and f put s here they are copied directly from the unix standard io library this code example is on page 155 of the textbook which you can view at www.cc4e.com code char star f get s open paren s comma n comma iop close paren char star s semicolon in n semicolon register file star iop semicolon open curly brace register int c semicolon register char star cs semicolon cs equals s semicolon while open paren minus minus n greater than zero double ampersand open paren c equals get c open paren iop close print close paren not equal eof close paren if open paren open paren star cs plus plus equals c close print equal equal quote backslash n quote close paren break semicolon star cs equals quote backslash zero quote semicolon return open paren open paren c double equals e o f and c s double equals s close paren question mark null colon s close paren semicolon close curly brace the function f put s is as follows f put s open paren s comma iop close paren register char star s register file star iop semicolon open curly brace register int c semicolon while open paren c equals star s plus plus close paren put c open for n c comma iop close paren semicolon close curly brace section 7.9 some miscellaneous functions the standard library provides a variety of functions a few which stand out is especially useful we've already mentioned the string functions sterlin stir cpy stir cat and stir comp here are some others character class testing and conversion several macro rows perform character tests and conversions the function is alpha open paren c close print returns nonzero if c is alphabetic zero if not the function is upper open paren c close paren is returns nonzero if c is upper case zero if not is lower open paren c close paren is nonzero if c is lower case is zero if not is digit open paren c close paren is nonzero fc is a digit zero if not is space open friends c close paren is nonzero if c is blank tab or new line zero if not two upper open paren c close paren convert c to upper case two lower open parenthesis close paren convert c to lower case those all worked on single characters on get c the standard library provides a rather restricted version of the function ungetch which we wrote in chapter four it's called ungetc ungetc open paren c comma fp close paren pushes the character c back onto the file fp only one character of pushback is allowed per file unget c may be used with any of the input functions in macros like scan f get c or get char system call the function system open paren s close paren executes the command in the character string s then resumes the execution of the current program the contents of s depends strongly on the local operating system as a trivial example on unix the line system open for end double quote date double quote close paren semicolon causes the date program to be run it prints the time and date of the day on unix storage management the function c alec is rather like the alec we have used in previous chapters see alec open paren n comma size of open paren object close paren close paren returns a pointer to enough space for n objects of the specified size or null if the request cannot be satisfied the storage is initialized to zero the pointer has the proper alignment for the object in question but it should be cast to the appropriate type as in char star c alec open friend close paren semicolon int star ip semicolon ip equals open paren int star close paren c alec open paren n comma size of open paren int close paren close paren semicolon c free open paren p close print free space pointed to by p where p is originally obtained by a call to see alec there are no restrictions on the order in which space is freed but it is a ghastly error to free something not obtained by calling seahawk chapter 8 shows the implementation of a storage allocator like c alec in which the allocated blocks may be freed in any order this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications chapter 8 the unix system interface the material in this chapter is concerned with the interface between c programs and the unix operating system since most c programs are on unix systems this should be helpful to a majority of the readers even if you see on a different machine however you should be able to glean more insight into c programming from studying these examples this chapter is divided into three major areas input output file system and a storage allocator the first two parts assume a modest familiarity with the external characteristics of unix chapter 7 was concerned with a system interface that is uniform across a variety of operating systems on any particular system the routines of the standard library have to be written in terms of the i o facilities that are actually available on the host system in the next few sections will describe the basic system entry points for i o and uni on the unix operating system and illustrate how parts of the standard library can be implemented with them but as an aside the dual nature of c and unix has been on display throughout the book and while this chapter is called the unix system interface in a sense it's less about unix in itself and very much about why c is such a great programming language let me explain before unix and c became the norm operating systems and operating system utilities those commands were used interactively and batch jobs were quite often written in the assembly language of the computer which it was supporting often there were not welldocumented api calls between utilities in assembly language and the assembly language which implemented the operating system smart vendor programmers would just look at the operating system code and write their utility code to work with it this section shows that a language that has features like structures arrays pointers a preprocessor and unions was sufficiently rich so that we could document all the intricate interfaces with an operating system using a relatively high level language and then we could write our utility code like cat in a highlevel language as well in this chapter the authors are almost shouting quit using assembly language to build your operating system and utility code further they are showing us examples designed to answer the question that might come from programmers used to the old ways like can we do x y z and c the author's emphatic answer in the increasingly intricate code samples is c is not a toy language that's only something used by a few att computer scientists in a research lab if you're doing serious system stuff that needs maximum performance and readability and reliability use c this chapter shows c in all its glory and shows why it was such an important language to enable the world of technology we have 40 years later at the end of the chapter we'll talk a little bit about see how c enabled the creation of easier to use programming languages and why it was so important to invent c inspired languages like python ph g and and php and java once c became the established systems programming language section 8.1 file descriptors in the unix operating system all input and output is done by reading or writing files because all peripheral devices even the user's terminal are files in the file system this means that a single homogeneous interface handles all communications between a program and peripheral devices in the most general case before reading or writing a file it is necessary to inform the system of your intent to do so a process called opening the file if you're going to write on a file it may also be necessary to create it the system checks for your right to do so does the file exist do you have permission to access it and if all is well returns to the program a small positive integer called the file descriptor whenever i o is to be done on the file the file descriptor is used instead of the name to identify the file this is roughly analogous to the use of read open paren five comma dot dot dot and write open paren six comma dot dot dot in fortran all information about an open file is maintained by the system the user refers to the file only by the file descriptor since input and output involving the user terminal is so common special arrangements exist to make this convenient in the command interpreter the shell runs a program it opens three files with files descriptors 0 1 and 2 called the standard input standard output and standard error output all of these are normally connected with a terminal so if a program reads file descriptor 0 and writes to file descriptors 1 and 2 it can do terminal i o without worrying about opening the files the user of the program can redirect input output to and from files with less than and greater than for example probe less than in file greater than out file in this case the shell changes the default assignments for file descriptors 0 and 1 from the terminal to the named files normally file descriptor 2 remains attached to the terminal so error messages can go there similar observations hold if the input or output is associated with a pipe in all cases it must be noted that the file assignments are changed by the shell not the program the program does not know where its input comes from nor where its output goes so long as it uses file 0 for input and 1 and 2 for output section 8.2 low level i o read and write this lowest level of i o in unix provides no buffering or any other services it is in fact a direct entry into the operating system all input and output is done by two functions called read and write for both the first argument is a file descriptor the second argument is a buffer in your program where the data is to come from or go to the third argument is the number of bytes to be transferred the calls are and read equals read open paren fd comma buff comma n close brand semicolon and written equals write open paren ft fd comma buff comma n close paren semicolon each call returns a byte count which is the number of bytes actually transferred on reading the return the number of bytes returned may be less than the number of number asked for a return value of zero bytes implies end to file and negative one indicates an error of some sort for writing the return value is the actual number of bytes written it is generally an error if this isn't equal to the supposed number that was asked to be written the number of bytes to be written read or written is quite arbitrary the two most common values are 1 which means 1 character at a time or unbuffered and 512 which corresponds to the physical block size on many early peripheral devices this ladder size will be most efficient even but even a character at a time i o is not inordinately expensive putting these facts together we can write a simple program to copy its input to its output the equivalent of the file copying program written for chapter one in unix this program will copy anything to anything since input and output can be redirected to any file or device this example is on page 161 of the textbook which you can view at w www.cc4e.com code pound include standard stdio.h pound defined buff size 512. this is the best size for pdp 11 unix modern computers it probably should be larger main open print close print open curly brace char buff open square bracket buff size close square bracket semicolon int n semicolon while open paren open paren n equals read open paren zero comma buff comma buff size close paren close paren greater than zero close paren right open paren one comma buff comma n close paren semicolon close curly brace if the file size is not an exact multiple of buff size some read will return a smaller number of bytes to be written by write the next call after that read will return zero it is instructive to see how read and write can be used to construct higher level routines like get char and put char for example here is a version of get char which does unbuffered input this is the second example on page 162 of the textbook pound include stdio.h pound define cmask0377 and this is a mask an octal mask to make sure characters are greater than zero get char open paren close paren open curly brace char c semicolon return open paren open paren read open paren 0 comma ampersand c comma 1 close print greater than 0 close print question mark c ampersand c mask colon e o f semicolon close curly brace c must be declared char because read accepts a character pointer the character being returned must be masked with 0 3 7 7 to ensure that it's positive otherwise sign extension might make it negative the constant 037 is appropriate for ascii and the pdp11 but not necessarily for every other machine the second version of get char does its input in big chunks and hands out the characters one at a time this is the first example on page 162 of the textbook which you can see at www.ccf code pound include stdio.h pound define cmask0377 pound define buff size 512. now we do the buffered version of get char get char open friend close paren open curly brace static char buff open square bracket buff size close square bracket static char star buff p equals buff semicolon static int n equals zero semicolon those variables are static so that they they are long lived and exist from call to call the beginning of the code if open paren n double equals 0 close print open curly brace n equals read open paren 0 comma buff comma buff size close paren semicolon buff p equals buff semicolon close curly brace return open paren open paren minus minus n greater than equal to zero close paren question mark star buff p plus plus ampersand c mask colon eof close print semicolon close curly brace section 8.3 open create close unlink create is not created it's create without the e so i'll just call it creat for now other than the default standard input and output and error files you must explicitly open files in order to read or write them there are two system entry points for this open and create open is rather like the f open discussed in chapter seven except that instead instead of returning a file pointer it returns a file descriptor which is just an int int fd semicolon fd equals open open paren name comma rw mode close paren semicolon as with f open the name argument is a character string corresponding to the external file name the access mode argument is different however rw mode is a zero for read one for right and two for read write access open returns negative one if any error occurs otherwise it returns a file valid file descriptor it is an error to open a file that does not exist the entry point create is provided to create new files or to rewrite old ones fd equals create open paren name comma p mode close paren semicolon returns a file descriptor if it was able to create the file name and negative one if not if the file already exists create will truncate it to zero length it is not an error to create a file that already exists if the file is brand new create creates it with the protection mode specified in the p mode argument in the unix file system there are nine bits of protection information associated associated with each file controlling read write and execute permission for the owner of the file for the owner's group and for all others thus a threedigit octal number is the most convenient format for specifying permissions for example zero seven five five specifies read write and execute permission for the owner and read and execute permission for group and for everyone else to illustrate here a simplified version of the unix utility cp a program that copies one file to another the main simplification is that our version only copies one file and does not permit the second argument to be a directory and this example code is on page 163 of the textbook which you can see at www.cc4e.com code found include stdio.h pound include std live.h pound defined buff size 512 pound defined p mode 0 6 4 4 rw read and write for owner read for group and others int open paren arg c comma arg v close paren the format will be we're going to have two files copy file one file two int argc semicolon char star arc v open square bracket close square bracket semicolon open curly brace int f1 comma f2 comma n semicolon char buff buff size semicolon if open paren arg c not equal to three close paren error open paren double quote usage colon cp from 2 double quote common null close paren semicolon if open paren open paren f1 equals open open paren arg v sub one comma zero close print close paren equal equal minus one close paren error open for n double quote cp colon can't open percent s double quote comma arg v sub 1 close paren semicolon if open paren open paren f2 equals create open print arc v sub 2 comma p mode close paren close paren equal equal minus 1 close paren air open friend quote cp colon can't create percent s double quote comma arg v sub 2 close paren semicolon while open paren open print n equals read open paren f1 comma buff comma buff size close paren close print greater than zero close paren if open paren write open print f2 comma buff comma n close paren not equal and close paren air open paren double quote cp colon right ear double quote comma null close paren semicolon exit open paren zero close paren semicolon close curly brace that's the end of the main program the error routine is going to print the error message air open paren s1 comma s2 close paren char star s1 comma star s2 semicolon open paren printf open paren s1 comma s2 close paren semicolon printf double quote backslash n double quote close paren semicolon exit open paren 1 close paren semicolon close curly brace there is a limit on the number of files which the program may have open simultaneously according any program which intends to process many files must be prepared to reuse file descriptors the retain close breaks the connection between a file descriptor and an open file and frees the file descriptor for use with some other file termination of a program by exit or return from the main program closes all open files the function unlink open print file name close print removes the file name from the file system section 8.4 random access seek and lseek file i o is normally sequential each read or write takes place at a position in the file right after the previous one when necessary however a file can be read or written in any arbitrary order the system call lseq provides a way to move around in a file without actually reading or writing lseq open paren fd comma offset comma origin close paren semicolon forces the current position in the file whose descriptor is fd to move to the position offset which is taken relative to the location specified by origin subsequent reading or writing will begin at that position offset is a long fd and origin are ints origin can be 0 1 or 2 to specify that the offset is to be measured from the beginning from current position or from the end of file respectively for example to append to a file seek to the end before writing l seek open print ft comma 0l comma 2 close print semicolon to get back to the beginning i.e rewind to the beginning l seek open paren fd comma 0l comma 0 parentheses semicolon note that the 0l argument could also be written as open parent long close paren 0. with lseq it's possible to treat files more or less like large arrays at the price of slower access for example the following simple function reads any number of bytes from any arbitrary place in a file get open paren fd comma pause comma buff comma n close paren int fd comma n long pause semicolon char star buff semicolon open curly brace l seek open parenthesis fd comma pause comma 0 close paren semicolon return open paren read open paren fd comma buff comma n close paren close paren semicolon close curly brace in preversion 7 unix the basic entry point to the i o system is called seek seek is identical to lseq except that its offset argument is an int rather than a long accordingly since pdp 11 integers only have 16 bits the offset specified for seek is limited to 65535 for this reason origin values of 3 4 and 5 cause seek to multiply the given offset by 512 which is the number of bytes in one physical block on a 11 and then interpret origin as if it were 0 1 or 2 respectively thus to get to an arbitrary place in a large file requires two seeks the first one selects the block then one which has origin equal to one and then moves to the desired desired byte within the block once again we see c in unix straddling a major improvement in computer hardware in 1978. the natural name for a function to randomly move around a file would be seek but in early versions of unix seek took an integer as the offset but on small word computers like pdp11 have an integer that can't represent a large number so seek used a complex set of rules to handle larger files the only logical thing was to have the offset be along and then for upwards compatibility make a new function called lseq that we use to this day section 8.5 an example implementation of f open and get c let us illustrate how some of these pieces fit together by showing an implementation of the standard library routines f open and get c on the pdp 11. recall that files in the standard library are described by file pointers rather than file descriptors a file pointer is a pointer to a structure that contains several pieces of information about the file a pointer to a buffer so the file can read in large chunks count of the number of characters left in the buffer a pointer to the next character position in the buffer and some flags describing read write mode and the file descriptor the data structure that describes a file is contained in the file stdio.h which must be included by pound include in any source file that uses routines from the standard library it is also included by functions in that library in the following excerpt from the pdp11 stdio.h names which are intended for use only by functions of the library begin with underscore so they are less likely to collide with the names of a user program as a side note i won't read the underscores because they confuse your understanding so the underscores are there in the code you can look at it online but i'm not going to read the underscores so this is basically some definitions for stdio.h pound define buff size pawn define and file 20. type def struct io buff open curly brace char star ptr int cnt semicolon char star base semicolon int flag semicolon int fd semicolon close curly brace file semicolon extern file iob open square bracket end file close square bracket semicolon pound define stdin open paren ampersand iob sub zero close paren pawn define std out open paren ampersand iob sub one close paren pound define std air open paren ampersand iob sub 2 close print pawn define read 01 pound define right o2 pondifying unbuff 04 pound define big buff zero one zero upon define eof zero two zero pondifying air zero four zero pound defined null zero pawn define eof open prin minus one close paren upon define gets e open paren p close paren open paren minus minus open paren p close paren right arrow cnt greater than or equal to zero question mark star open paren p close paren right arrow ptr plus plus ampersand zero three seven seven colon fill buff open paren p close print close print palm define get char open paren close friend get c open paren std high n close paren pound define put c open parent x comma p close paren open paren minus minus open paren p close paren right arrow cnt greater than or equal to zero question mark star open paren p close paren right arrow ptr plus plus equals open paren x close print colon flush buff open paren open paren x close paren comma p close print close paren pound define put char open paren x close paren put c open paren x come std out close paren the f c in macro normally just decrements the counts advances the pointer and returns the character we do this in a very long defined continued by a backslash if the count goes negative however get c calls the function fill buff to replenish the buffer real initialize the structure contents and return a character a function may present a portable interface yet itself contain nonportable constructs cat c masks the character with zero three seven seven which defeats the sign extension done by the pdp 11 and ensures that all characters will be positive although we will not discuss any details we've included the definition of put c to show that it operates in much the same way as getsy calling a function flush buff when its output buffer is full the function f open and fill buff can now be written most of f open is concerned with getting a file opened and positioned at the right place and setting the flag bits to indicate the proper state f open does not allocate any buffer space this is done by fill buff when the file is first read you can look at this sample code from page 167 at www.cc4e.com code i won't read it here because it's pretty long and intricate so you'll have to go watch it online or view it online back to the text the function fill buff is rather more complicated the main complexity lies in the fact that phil buff attempts to permit access to the file even though there may not be enough memory to buffer the i o if the space for a new buffer cannot be obtained from cat c alec all is well if not filbuff does unbuffered i o using a single character stored in a private array the first call to get c for a particular file finds a count of zero which forces a call a fill buff if phil buff finds that the file is not open for reading it returns eof immediately otherwise it tries to allocate a large buffer and failing that a single character buffer setting the buffering information in flag appropriately once the buffer is established phil buff simply calls read to fill it and sets the count and pointers and returns the character at the beginning of the buffer subsequent calls to fill buff will find a buffer already allocated the only remaining loose end is how everything gets started the array iob must be defined initialized and initialized force stdin std out and std err file iob open square bracket and file close square bracket equals open curly brace open curly brace null comma 0 common null comma underscore read comma 0 comma close curly brace comma and that's the standard in the next one is open curly brace null comma 0 common null comma underscore right comma 1 comma close curly brace comma and that's the standard out definition the the sub 1 position and then the next one is open curly brace null comma 0 common null comma underscore right vertical bar underscore on buff comma 2 close print and that is the standard error entry close curly brace semicolon the initialization of the flag part of the structure shows that std standard in is to be read standard out is to be written and standard out is to standard error is to be written unbuffered section 8.6 example listing directories i would note that the sample code in section 8.6 shows how we can write applications like ls to interact with directories in a unix file system however the code in this section is not portable to modern unix systems so we'll leave the code as it is in this section it's a good idea to read the code and get an outline of how to work with directories on unix if you want to write code to handle directories you'll need to consult more modern documentation given the complexity of the code in this section we are not going to include it in the copy of this book in this particular media similarly section 8.7 example a storage allocator consists of a lot of really complex code and so we will leave that for you to see online at www.cc4e.com book slash chap08.md dynamic memory is hard modern languages like python ruby and java give us high level objects like strings lists and dictionaries these structures automatically expand and correct contract and can be copied into a temporary variable used and then discarded modern languages depend on efficient memory allocation a problem when dynamic memory is heavily used is a fragmentation of the free space you can get to the point where you have plenty of memory but each of the free memory areas is so small that you can't allocate a new memory block when this happens the runtime implementations of these systems run a step called garbage collection where everything pauses and free areas are moved around to make sure that the free memory is in a few large contiguous areas rather than many small noncontiguous areas language developers have been improving garbage collection algorithms for the past 40 years and there is still much work to do now that the authors have established all the reasons that make see the ideal portable systems programming language which i hardly agree with it's time to talk about where c comes up short as a general purpose language for those of us not working on the source code to linux the most challenging aspect of c is the lack of dynamic structures that we can use without the need to carefully allocate use without the regard to the length of dynamically allocated memory and not worry about calling c free every single time we call c alec if a programmer without strong programming skills a good understanding of a testing regimen and a proper defensing defensive programming attitude is let loose in c they will invariably write poor code their c code will make poor use of resources run the system out of memory or produce code that is riddled with security holes and bugs that seem to randomly appear a decade after c emerged and became popular guido van rossum designed a language called python it was one of a number of languages that was built using c and added an objectoriented layer that greatly simplified writing programs that used dynamic memory and added guard rails so programmers did not unintentionally write dangerous or insecure code the key valueadd features that make python more appropriate for general purpose programming are the string object list object and dis dict object that handle all aspects of creating and using variables and collections of variables the book has one foot note unix is a trademark of bell laboratories but of course there's more actually the trademark for unix is no longer owned by at t it is owned by the open group but that is a story for another day the unix story arc includes att unix berkeley software de distribution which we call bsd sun microsystems minix linux the open software foundation unix international and others the short version of that story is that at t unix was poised to take over the world as an open source product long before the words open source were ever spoken at t should have and could have defined open source and changed everything by the early 1980s except for a few at t intellectual property lawyers it took over a decade for computer science to pivot away from a nearly exclusive focus on c and a t unix the linux operating system was open source from its inception and became the standard barrier for unixlike operating systems and continues to be the way most of us encounter quote unix it is almost certain that the computer that served this media to you runs linux but that is a story for another time in 1978 unix and c were in their glory days and showed the entire computer science field and technology industry the right way forward from that point forward hardware could evolve independently from software with the systems programming language and operating systems patterns sorted the previous 40 years have seen an amazing innovation in hardware capability and performance this 1978 c programming book by brian w kernighan and dennis m richie was the big bang moment for modern computing and computer science we owe them a debt of gratitude for making whatever we do today possible if you have made it to the end of this chapter in this book as your narrator i would like to congratulate and thank you it has been an honor to record and narrate a book of such historical significance for you cheers this work is based on the 1978 c programming book written by brian w kernighan and dennis m ritchie their book is copyright all rights reserved by at t but is used in this work under fair use because of the book's historical and scholarly significance its lack of availability and the lack of an accessible version of the book the book is augmented in places to help understand its rightful place in a historical context amidst the major changes of the 1970s and 1980s as computer science evolved from a hardware first vendorcentered approach to a softwarecentered approach where portable operating systems and applications written in c could run on any hardware this is not the ideal book to learn c programming because the 1978 edition does not reflect the modern c language using an obsolete book gives us an opportunity to take students back in time and understand how the c language was evolving as it laid the groundwork for a future with portable applications you