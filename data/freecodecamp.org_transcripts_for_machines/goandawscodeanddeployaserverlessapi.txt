The Gold programming language can be used to deploy serverless stacks to AWS in this course. Akhil Sharma will teach you how to code and deploy a complete serverless stack with basic CRUD functions on AWS using go. This is a complete serverless stack. Right, so you're using DynamoDB serverless, you're using lambda serverless again, and then we'll be using API gateway again, serverless. Now API gateway helps us enables anybody across the world to interact with our lambda function, right. So we'll be deploying all these three things. From the AWS console, right, we'll be using the AWS console, and then we'll make settings for all these three things. And we'll deploy all of this. And anybody across the world can use our lambda function. So this is more like a real world scenario. So I'm in a terminal now. And you don't really have to keep this project in your go route. Because it's Golang. One point 12. And anyways, they had, you know, go mod in it, which we're going to do anyways, out here, go modern, it takes care of everything. I mean, you don't have to really do anything manually. Alright. So here, we will say, we will make a directory first we will say, Go server less, and YT. Alright, and we'll cd into this. Go serverless tack YT. For yt is basically YouTube, I'm making this project for YouTube specifically. Alright, and here, I'll say go mod in it. And which is basically github.com/akil/go server less. So that's my project. It's initialized go mod for me, go mod is basically like my package json file. If you're from a Java background, it will have all my dependencies for me, you know, easily listed out. So now what I can do is I can just open this project up, and code editor, which is VS code, in my case, just as a pointer, right, I'm using windows inside Windows, I have something called as WsL. Inside that I'm using Ubuntu 20.04. And I use multiple different versions of open to write Stan this for this particular video I'm using over in 20.04. And in my open 20.0. For instance, I have VS code setup. Alright. Now, I don't want to install a lot of extensions for calling because I know when I'll start typing, I'll start writing a lot of code. I'll make some mistakes, right with Golang. I'll make some mistakes, but I will fix them. But don't worry, I don't have extensions, because I don't want to like start, you know, ballooning up my instance. Because this is just one of the instances that I use. On my Windows PC. For over two, I have, like 1015 different versions of Uber, right. So if you need to go line, by the way, main.go file is your main file right in the project. And this is how you start to main.go file, you say package main and you say import. And because you'll import some packages, right? Not everything you'll have. Inside go Lang go. Lang is very modular, you have to install a lot of external packages, and a lot of, you know, packages that come with coal, and you have to specifically tell that, you know, this package from cola. And so the the third party packages that we'll be using will be mostly around lambda. Alright, so we'll talk about them in a while. And then the most important thing here will always be func main, because that's your entry point into the program, right, the func main. Now, before I start writing anything in main.go file, what I'll do is I'll just try and create, like a very simple project structure, I need the build folder, right, because I'm going to keep my build of this entire project in my build folder. And that's, I'm going to zip it up, and then I'm going to keep take that zip file to my lambda, sorry, my AWS lambda console. Alright, so that's why I need the build folder. And I need my CMD folder, because that's where I usually keep my main not sorry, not in the build, but in my CMD folder, I keep my main.co file. Alright, and then you will have a package folder. So if you work with Golang, before this, like the very standard kind of structure, right, nothing, nothing new. So package will, as you already know, will have handlers, right handlers to handle the API's. And then you will have I'll have a folder for user. I'll explain to you why I'm doing that. And then I have a very simple validation functions where I'll keep that in a folder called validators. validators. Sorry. That's it. Yeah, so in validators, I will have just one little file of Pedley like five, six lines of code, I think. It's just going to be as email valid just to check if my email is valid for the user. And here in my user, I'll have a file called user.co. Alright, and my handler That's where my main logic resides. So this is a very short, very small project handlers, I'll just have two files, I'll have API response.go, because I need this file for my API gateway, I'll build it, you'll understand what it is. And then it's handlers.co. Right? Now, my user.go file is kind of a combination of my models, and my, almost like my controllers as well, you know, so I have handlers. But you know, user.go file will have a lot of code, which kind of which talks my database, alright, directly talk to my database. So I'll have those models like those structs as well, at the same time, we'll have model functions, those. So database functions at the same time, I'll head over to your main go file. And func main, I think what I'll do is I'll start with this place, right, once I was taught, get environment AWS region. So AWS region is very important, because that's where your lambda will go and set. Right. So with AWS, if you've worked with AWS a lot, you know that he has different regions, right. So my particular AWS is considered configured with India, which is Asia Pacific South one. So if you have been using the CLI and setup is, it'll be amazing. Otherwise, also, I don't think you should have a problem, right. But just try and just try and set up a CLI. It's very easy, just a five minute process. And it will be very simple for you to follow along with all of my other videos as well, because in my other videos, it's a prerequisite. So how do you create a session? So you will say session dot new session. Now, if I'm calling this old, who is here, right, so I need to have us here. That's the package, right? And if I'm calling session here, session is something that AWS lambda gives me, AWS gives me sorry, so I'll say github.com/now. Looking at the documentation for the AWS packages, at the same time, you can do that otherwise, in case you're the type of person who wants to, like know exactly which package you're installing, because I'm that type of person, I want to install any extra packages, right. So if you're like me, you, you might want to open up, just like I've done, you might want to open up the AWS SDK, it's called so I'll say AWS slash AWS SDK for go, you want to, we want to open up the documentation. And here you'll see it will just slash session. Alright, and to create the new session, you will say AWS dot config and the bracket which will be curly braces bracket, you will say region, AWS taut string and say that you'll pass the region alright. Alright, right. And then, as you know, with all everything to do with Golang, whenever we haven't, we get two things usually right, we get the thing that we're looking for, which is the earpiece session which will come from the session function, right, or sorry, the new session function, which is a part of the session package that we have here. And we get the error. So with go Lang, you have to like keep handling errors, and this is a very neat and clean way of handling errors because at every stage you know where that is coming from and you can handle it there itself. So if there's an error just return right and I want to create a variable called Dinah client which for my DynamoDB and dot new and how you create a new client will say AWS session perfect which you just created out here. So you've created the session and then we'll say lambda dot start and handler. So this you may not understand right now not a problem. So firstly, we want DynamoDB How do you get DynamoDB you get it like this, it'll say github.com/aws/aws SDK go slash service slash Dynamo DB. Alright, so you have session you have DynamoDB and you want AWS itself and the first place we will say github.com slash AWS SDK co slash class. To get this lambda function or sorry, the lambda package, which has the Start function, you need the Start function, or you will do is you'll say github.com/aws/aws Lambda go slash lambda. Cool. So far, so good. That's what I needed, you know. And I need something called as the handler, which we'll talk about. Okay, for now, I'm creating a constant called table name. Stable name is lambda user. I'll say lambda in go user. And now it's time to create my handler, which is this basically. So I'm passing by handler there. In my handler, what I'm doing is, I have a request. Basically, I accept some things right. And this function, and I return some things, and it has some definition. So what does it accept? It accepts events dot API, Gateway proxy. requests. So you're wondering what's events? Right? So events is basically what? Go Lang. lamda will give us so I'll come here. And I'll say github.com/aws/aws, lambda go slash events. Perfect. And the other thing that this accepts is star events dot API. Okay, to a proxy response. Sorry, I meant that this it accepts a request, returns a response. I'm not sure what I said actually, before that. What I'm trying to say here is that, you know, this is a function that accepts something and it turns something, obviously accepts requests, obviously returns a response, right? No complication there. That's what you want to do. And what you will do here is you will switch the HTTP method. So you'll say switch, insert request dot HTTP method. So what are the methods that you have you have get POST, PUT and DELETE? That's all you have. So for every single different history method, we want to call a different function. How do you do that? So you'll say switch. So we've already switched, right? We already switched. It's like, it's 830 here, so I'm kind of sleepy. I usually get sleepy at 11pm. But somehow, I am sleepy earlier, because I woke up really early. I've joined this martial arts class that that, you know, gets me to wake up at 5am these days. So so you'll have something called as handlers. Right? And where will those handlers come in from it's basically these handlers that you want to import. So which are basically your own creation, your you know, the handlers or your own creations will say github.com/kill/go server less, righty slash packets slash handlers. Cool. So you're saying to go Lang is that this is my project github.com/search Go to go serverless whitey? And say that I have a folder called package instead of I have a package called handlers. Right? And handlers the file. On top of that file will say package handlers and it belongs to the handlers folder, then go Lang understands, okay, this is what we're talking about. Alright. That's the format. I mean, though, the folder name and the package name have to be the same. Just letting you know, in case you didn't know that. I mean, I'm pretty sure you knew that, but I'm just making sure right. So you have requests table name and Dinah client Right, so you sent this to this function called handlers dot get user, which we'll work on in a while. So that was your case get. Now you have more cases, right you have, depending on the HDB method, so you have post, you will have put, and you'll have Delete. For post, you'll see return handlers dot create. User. Again, you'll pass request comma, table name, comma Dyna client. For put you'll pass written, and lawyers dot update user request comma, sorry, request comma, table name, comma, diner client. And for delete, process two handlers dot delete user. And same thing as you pass the same things comma, Dinah client. And after delete, you will just give it a default. If you work with case switching case statements, you obviously know this default, right? And try to keep the orientation same. It won't affect it. But just as a good habit, you know, I mean, I don't do it many times. But I try to do it these days. Alright. So by default, you want to call this function called unhandled. Method, which is again in your handlers file or handlers package. And this is the entire picture. I mean, I don't think we're missing anything. We have the OS package down here, we have events lambda AWS session DynamoDB. Yeah, there's one more package. Actually, if you look at the AWS SDK, document, then you want to import it was SDK, go slash, service slash DynamoDB slash Dynamo DB I face. Just keep these packages. And what I think we should do is we should just say go mod tidy. So we'll get us all the package that we've just talked about. And usually, like many times I do this at the end of the end of the video, right? But this time, I'm just doing it beforehand itself, because many people they can start freaking out, Hey, you're installing all these packages? If not, you've not run the command go might go more tidy. Or you're making so many mistakes, man while typing. Why don't install some extensions, I've explained to you why don't why don't install extensions, right. So, so with Golang, I mean, what happens is that, you know, we usually come from JavaScript kind of a background, and then we think that, oh, you know, if you're making all these mistakes, and the complete program will crash, and it will be difficult to solve it with go Lang. Golang is very different from other programming languages, right? Make as many mistakes as you want. And once you run the program, Golang will really handle everything for you will tell you which line, what's the problem, it's quite intelligent. Right? It's not like your regular other programming languages like JavaScript. So here, one thing that we missed out was to create the data client in the first place, right, so the client has in the variable, and the defining the type of variable the data client is, so what type of time they will be. That's why we will use this or maybe ifs, right, we'll say dot Dynamo. Dynamo DB. API. Just make sure you get this right. All right. So that's your main file, your main file is complete. And now you want to start handling handlers. So here, since these two files belong to the same folder, call handlers. We wanted to both to be package handlers. Right? So we'll say, package handler yours. Right. That's clear. Now, I'm hoping and after writing the package, you say import and then you have your main function for in this case, this the main function of this file is called API response, accepts some things, return some things and has a function definition. What does it accept accepts status, which is int and body, which has an interface. What does it return? It returns the event start, API gateway proxy response, comma error. All right. For importing, you'll say and coding slash JSON github.com/aws/headress, lambda Gqo slash events. Okay. All we're doing with this is basically defining the response, right? So we'll say response is equal to events dot API gateway response. And the response, you're just setting the headers. Pretty standard. Because the way we're going to set up these headers are something that we've already seen so many times. It's basically content type and application JSON. So we're saying that we're returning JSON from our lambda function, write nothing out of the ordinary. So we'll say response dot status code is equal to status. And so basically, you're like 400, or 300, or something like that. And then you'll say String body comma JSON dot Marshall. So you're, if you've been with Golang, you already know it's marshalling and marshalling and marshalling sorry, is Golang, doesn't understand JSON on its own. So it needs the help of JSON marshalling, which is part of this encoding slash JSON package. And so whenever you send some JSON, from postman into post postman, or maybe terminal, wherever you send some JSON, it basically we want coolant to understand it, and also the information that Golang produces for it to become JSON, and send it as a response that also needs, you know, help, go Lang itself with boats. So that's what's called marshalling and unmarshalling. There are hundreds of videos about it. On YouTube, you can check it out, nothing fancy or nothing complicated. You have to do that in, you know, almost all the other languages, right, which are not JavaScript, which is like basically, Java and Python, all these languages, you have to do something like that, right? Because any language that's not JavaScript does not understand JSON, by default, because JSON is JavaScript Object Notation. So this is your API response to go. Alright, that's it. I mean, there's nothing much going on here in this file. But the other file in handlers, package handlers, this is where we're going to spend some time because obviously, there will be a lot going on here, right. So the main functions that usually will be there will be based on our main go file. So main, go File requires get user function, create user, update, user, delete user and anonymous method. unhandled method, sorry. So these are the functions that obviously that you need to create, right? So we'll say get user. And he will say Create User. He will say Update user and delete users. Update user and delete user. Alright, so here. The last function that we want to keep here is unhandled. Method. Right? So for let's say, if somebody uses the patch method, because we're handling, get POST, PUT, delete, if somebody uses patch, then we'll say that, hey, it's not handled, right. So we'll say unhandled method, except some things return some things and so, function definition. Alright, so this is, in general, this is how your handles file is going to be like. And what we can do is we can work on our is email validated, valid file So we'll say package validators. And there's a package that you get with go Lang. It's called regular expressions. And we're just creating a simple function where we just saying if the email is valid or not, right, really simple. All it does is accepts an email string. And returns a Boolean, like, true or false. We'll take a variable called Alex email, we'll use the like expression, regular expression package. And if you look at the regular expression documentation, like I have in front of me, go to the Golang official documentation and check out dragon regular expression package, I highly recommend you to open it if you want, because that's what I've done out here, in my other screen will use the function called must compile. And I'm going to copy and paste a regular expression string here. You don't really need to understand what this does, you just get it directly from the documentation. But if you really want to know, basically, you're just checking if you know the numbers are between A to Zed A to Z, and zero to nine, that kind of stuff, right? That's all it's doing. And it's also checking for at at symbol. Right. But obviously, if it's anywhere, it needs to have an ad, right. So those kind of things, just basic email validation check is happening out there, do check out the regular expression document if you want to really understand what this regular expression does, alright. But if you want to save time, just copy and paste it like I just did. And now we want to check the length of email. If email, if another female doesn't three, or length of email is more than 254 or Arex, email variable, not match string. Then you'll just return false. Right, so this returns either true or false. If these conditions are not met, then you return false otherwise, you return true, that means everything is fine. And email is valid. Right? Obviously, if this is not proper, it's not working properly. If length is more length is less, we'll say that the email is not valid. Otherwise, I will say to you can change these numbers as you want. But I've kept them to be three and 254. All right, change it on your test. So now we'll go to our user.go file. And we'll just add a very 10,000 feet level, I'll just set up this file. Now what I want should happen is that for my handlers, like domain control, you know what that will go to the main file to our, you know, to this function, basically. And this function is calling the Get User function and create user function update user. And all these functions are, as you know, mentioned in the handlers, right. And from the handlers from handlers, you will call the functions in your user.go file. And these functions will be actually the database functions that actually talk to the database, right. So every function that you have here, except for the unhandled method, because it doesn't do much, these four crud functions that we have, they have an equivalent function in your user.co file, a complete like one to one function in your user go file that talks to the database. Alright, so let's do that. Let's create those functions. So firstly, as you know, when we start off a file, we import some things. And then here, I'll also want to define some variables, some errors that I want to define. So the functions that I want to have here and my user.go file, which will have one to one relationship with these four functions, the first function will be called I'll call it fetch user. So that means is my Get User function gets called My handlers. And this function will call in my user.go file, the fetch user function, which directly gets the user from the database itself, the database, in this case being DynamoDB. Alright, so it accepts some things, return some things and has a function definition simple. The second function I want to have is for getting multiple users actually, so I'll say func fetch users. Similarly, will look very similar. Then I want to have a create function. So we'll have create user and then it has update user you just have to keep looking here and then creating these functions. Then you have the law as well as delete user, right, so you will come here right, if it doesn't get deleted, then you don't have to return anything specific special, you can just return an error. That's why from the return here is just an error. Right? And that's about it. So we have managed to one functions, all of these, but one extra function is there is just fetch users. Alright, so we'll see where to get where to use it. So from a 10,000 feet perspective, this is your user.go file, and this is your handlers file. So what we'll do is we'll start with Nora handlers function, and then at the same time, we'll start working on our user.co functions. And here, you'll all obviously, import some things, right. The first thing that I need is net slash HTTP. Then I need my lambda event. So I'll say github.com/ad/aws, lambda go slash events. Now, it's possible that I'm importing these, but you're not understanding why I'm importing these. So you might get confused. So now there are two ways to do it. One is when I'm actually writing the code, and then I use this events packet somewhere, and then I come in come up and you know, import it. Or I know, you know which ones I need. So I'll just import them right in the beginning itself. So they can use them later on. So I'm just doing this. So try not to get confused, because we'll actually be using these packages in just like two, three minutes. Don't worry, you know why we are importing them, we will reuse it. So please be patient. Slash AWS. Right. So these are the same package that we already use in our main.go file. And we'll say github.com/aws/check it go slash service slash, no DB slash Dynamo DB I face. Great. One thing that I need here, because I would want to call these functions, like I told you, right, I want to call this function. So that's why I want to import this user package and my handlers file. How would I do that? I would say github.com/achill/go, server less writing slash package, slash user. So inside package inside the user package, we've inputted it here. Alright, and then before I get started, these functions I want define a very variable called error method not allowed. Is equal to method not allowed? And why do I need to create this? Because firstly, we'll be working on this function unhandled method, right? So that's why you want to call this function. So here, this returns and event API gateway event. So it will say API, Gateway proxy response, comma, error. Right, so we will send response from here, or it will send an error. And here we'll say return pay API response, the response that you want to send is HTTP dot. When we say HTTP, we are talking about the history package Nesta history package, alright, status. Method, not allowed comma. Header method not allowed, which we have just defined together, right? That's what you're saying. So you're saying that we have, you know, something for get post put in place, but we don't have something for patch, so patch or any other method that somebody wants to use. So if you get something like that, like an unhandled handle method, so you'll send a response saying that, hey, this meter is not loud. Alright. And I want to create another variable, but it's actually a struct, right? So it's an error body. And I'll be using it a lot so just bear with me as to why I'm creating it. This struct has a variable called error message, string. Error comma, omit empty. Now for your get user. You have he accepts something and you turn something Before I get user, what do you accept? What do you what does the function get you get a request right from postman, the request that you get is part of a savings packet. So you can say events dot API gateway request, comma table name, which is string, comma, Dyna client, dot Dynamo DB API. And what does it return? returns the response, obviously. So we'll say events, dot API gateway, proxy response, comma, Irish. Straightforward. And actually, this, these two things, right, was going to accept and was going to return is going to be used by all of the functions. So what you do is you just copy and you just paste it here for CREATE USER for update user, as well. And for delete user as well. Awesome. So we've done a lot of heavy lifting. Now, I want to start working on the function definitions for these all these functions. Right, so the first thing that you'll say is email, request dot query, string parameters. So if you've guessed, what's happening here is you want to get the user but by using the email ID of that user. So for my request, you will have your query string parameters, which will pass an email and that we're going to capture in a variable called email. And then we will check the length. So we'll say if length of email is greater than zero, then you'll get a single user. So we'll say user dot fetch user, which we've just created together, right? We have not created the definition. But you know which function I'm talking about. It's in my user package, which has been imported here already. So fetch user is going to take the email, table name and donor client. And I'm going to capture this in the result, or the when there's going to be an error. And if there's an error, I'll handle the error. So I'll say if error not equal to nil. Return API response has to be dot, status, bad request. Comma, or body. So everybody's a struct that I've already defined. And in our body, I want to pass AWS dot string error dot error. And otherwise, you'll say hello, DB dot, everything is okay. So we'll say status. Okay? If everything goes well, and you'll pass the result from this function. Now if if you want multiple users, you'll say user dot fetch users say same thing, they will name a client. And what you will do is, you will again, use result and error to capture the values coming from this function. And if there's an error, and you'll check if error is not equal to nil, you will return the API response, saying HTTP dot status, bad request because there's an error, right? And you'll send the error body, just like we did earlier error body is a struct that we've already defined. That's the error body that we're sending, which is basically JSON. And here the error body. Inside that, we're going to send, you're going to send a WS dot string, header dot. Got it? But if everything went well, and there was no error, then we're going to return API response and HTTP dot status. Okay. Commerce result So the basic gutsier get user. Now what we can do is we can work on our fetch user and fetch users both of these functions in our user.co file. Or we can work on our CREATE USER function in our handlers. So I think I'll do the former, I'll work on fetch users, and I'll work on fetch user, let me just check if everything is recording, yes, everything is recording perfectly. I just need to keep making sure otherwise, you know, I end up making a long video when nothing has recorded. And that leads to a big problem. Alright, so before I do anything with users, I want to first create a user right. So like I said, this file is a mix of that model file that you usually create, where you define the structure of how the user is going to look like. So I'll say user struct. Email. Now, since this user struct is small, and we don't have multiple stocks, like if this was a e commerce, for example, then you would have had users and orders and you know, all those different like products and so many different stocks, right. So you'd have to have like a model separate Models folder for all these different models. And then you'll have, you'd have, you know, database functions separately, and controllers or something like that, right. But since we don't have that, we have a very small project, which just has users and users all itself, it's a very small struct, because you just have email, first name and last name. You don't have too much here, right, you can combine controllers and models into the same file. Now, email is going to be a string which is going to say JSON. And you say, like this JSON email, because for Gulags purposes, it'll be emailed with a capital E, whereas JSON where it's stored, it's going to be emailed with a small e. So you need to pay a telco like that, you know, there are two versions of it one, the JSON version, the another is the version that Golang understands, because Golang does not understand JSON, as I've already told you. So that's why we also have to use some marshalling and unmarshalling. To get it to understand and interact with JSON. Alright, so you'll have first name and last name. And then what we'll do is we'll create our fetch user function, what does it accept. So if you actually go to handlers, you will see the fetch user function accepts email table name to a client. So we'll say here, email, and table name, which is string. And your Dinah client, which is of type, you already know that dB, I face dot DynamoDB API. And it just returns a user. Obviously, I mean, you fetch user, you return that particular user or return error, if nothing works out. You define a variable called input. And it's of type DynamoDB dot get item input. So we'll have to define the key based on which our database function will run to find that particular user. And you already know that the user will be formed for the database based on the email ID. So we take an email id, you take an email ID, and then we want to find the user that's associated with that email id. Alright, so straightforward. We'll say DynamoDB dot attribute value. And we're going to say email because we want to run a query on email. So email is equal to s equal to AWS dot string, dot, sorry, inside that bracket will pass email. Now the string is a function that is given to us by AWS package Aerospike. It is something that we'll have to import out here. All right. And similarly with the DynamoDB. So we'll have to also import the DynamoDB package. So come here on your import, and firstly called encoding slash JSON, because like I told you Golang does not understand JSON by default. So you'd need encoding slash JSON package to use the marshalling and unmarshal like functions and I need the errors package also. Then I want to get my hands on the events. Now we'll be using it soon. To send responses and the usual ones. As you can see, I need DynamoDB and I need AWS. So let's get those ones. So I'll say AWS slash AWS SDK, go slash AWS and also github.com/aws/aws SDK go slash Dynamo DB. And what I'll also do well also get this particular package. Yeah, let me do that for now. So I'll say github.com/aws/aws is a case called slash service slash, Dynamo. dB slash Dynamo DB. I face. All right. Now coming here, you've already passed this. And after this bracket, you need to specify the table name in which this function is going to run. So we'll use the regular string function again, to pass the table name. And after this bracket, you want to use your data client to finally start getting the item. Input is this basically the query that you created, right and get item is the function that you get an error client. And you will capture that end result an error. So, standard practice, if there's an error, we'll have it on the header soon return nil for the value and will return errors dot new error failed to fetch record. So you must be wondering, Where's What is this error come from? Probably never seen this error, right? Because this is a new error that I've created on my own. How can I create my own errors, I can create my own errors like this. So error failed to fetch record is equal to fail to fetch record. And similarly, I can define any errors that I want in this variable defined as a variable, right? So you've, you know, created a query that is similar to MongoDB, right, you've created a query based on the email, because you want to search for that email so that you can retrieve the user and you've run the function get in get item for DynamoDB. And you've passed the query to it, and you've received that in something called as result or you received an error. If there's an error, you handle the error. But if the result is fine, and nothing really happened, then you would do something right. But before that, we will create a variable called item and it will be basically a new user. And here you will say error is equal to Dynamo DB attribute.on. Martial map. Okay, so DynamoDB attribute is another. By the way, if you have not opened up the DynamoDB and AWS SDK, go, documentation, do that, because I have it open on my other screen, you can do that as well. And then everything will make a lot more sense, because these are actual packages inside that main package. Right? So I'm using those. And once you go through the documentation, you will understand where to use, which one, are you or if you really don't care about that, you can just keep following along with what I'm doing. But I just recommend that you just read it because you know, everything will make more sense. Here I need this package right done, what do we attribute? This is helping me unmarshalling the user. So first, let me write the whole code. So I'll say result, sorry, not here. He'll per record will say result, dot item comma item. And this error if this error is not equal to nil, what we want to do we want to return nil comma, errors dot new error failed to on Marshall record. So you must be wondering what's happening here, right? When you get the data from your DynamoDB using the get item function into result. You want to unmarshal data into an actual user, which the front end can understand as a JSON basically. So you use the user struct and and you don't take that in a variable called item. Right? So item is basically a variable of type user. And then, you know, you want the data that's coming from your result or item, you want that to be unmarshal and brought into item so that now whatever has come as JSON becomes, you know, the type, which is user, which is understood by go Lang, but and it's captured in a variable called item. Right? So I've tried to explain to you every single line, in case you don't understand it, to check out what's marshalling and unmarshalling. Alright. And if you have any, like, if you still have any confusions, you can just put it in the comments below. I'll sort it out for you. But it's nothing very difficult, right, we just taking what's coming from DynamoDB, the JSON, and you're on marshalling it, to make it into a struct, right? Which is of type user, which has email first name, last name, something that can be understood by ko lang. And you're capturing that in a variable called item, which is obviously of type user, right? That's struck that we have defined. This is standard practice, I do this in all my other videos as well, in case you're new to this channel, I have hundreds of videos on ko lang, you can check all of them out. Like literally hundreds of videos on Cola, right? Check them out, build projects with me. And you'll understand very everything very easily. So if everything went well, if there was an error, obviously, you sent nil and you sent the errors. But if everything went well, you'd return the item, and then you will return nil for the error. Now you'd want to also work on the fetch users function, though, plural fetch users function. How do you do that you are passing table name there. As you can see, here, you're passing given him an ANA client. So Duolingo has been passed, which is obviously a type of string to pass 10 Nine, a client which is of type, you already know, Dynamo DB, I face dot DynamoDB API. And you return multiple users. How you doing multiple users, you return basically a slice of users, when users is the struct that you've defined, right? So you're using a struct, you're making a slice of all those users, and then that's what you're returning. I hope that makes sense. If you don't know basics of like, of Kulang, like slices and structs, then I highly recommend you check out the basic tutorials before you get more confused. So I want to use a function by the DynamoDB gives me it's called Scan input. To get access to a table name, which has AWS dot, string, and table name that we are already passing here. Right. And he will say Dinah client, thought scan and you want to scan the input, the query that you just created. So here, as you saw, we had a more elaborate query, because we had to get a particular user with email. But with fetch users, you just getting all the users, you don't have a specific query that, okay, you know, for this email, get a particular user saying, Give me all the users. So you don't have any query as such, you're just passing the table name. So that's when your diner client, but can you just pass the input, that's it. And scan is like get all, you know, you can say that. So if you've used that MongoDB, it's, you have find, find all something like that. Here, you just have scan, find and find one you have in MongoDB. So you just have scan, alright, scan and get it. So you're doing scan to get all the results. And you're going to capture that in a variable called result. And then you will obviously, if you have an error, you know that standard way to handle errors is like this. You'll say return nil for the value when you return an error. She'll say errors dot new error, failed to fetch record. And, again, like we did out here, item will define item, right? The item here is not just a user, it's a slice of users, multiple users because we're getting all the users from our database. And, again, the same thing that we've just done here. We'll do the same thing here. So we'll say or do just copy the whole thing actually. Copy and paste. But there's only one more little change instead of result or item. You'll have result dot items. Because obviously from AWS, you'll get multiple items, multiple users, that's what you're getting. And you're returning your item. And for the error, you're returning. Make sense. So we've done quite a bit, right, we've already done the Get User function and get user function had fetch user and fetch users two functions from your user.co file. Now there are three functions left here, and three functions appear because we've already taken care of the unhandled method function, you don't have to anything more here. So just three functions left here, three functions left here. And all the other files are kind of complete. Right? So if you reach this far, congratulate yourself, because you've come you've come a long way. Right? So now let's start thinking about how our CREATE USER function is going to work. Alright. So for the CREATE USER function, let's let's start building that. There's actually not much happening there. All these functions, right? Create User, update, user, delete user, like, they're all going to look very, very similar. So going to say user, because you know, you want to call the CREATE USER function, the user package, so we'll say user dot create user, which is this function, that's what you're calling, right? And you're passing it three things request, table name, and a client makes sense. Nobody will respond to this function returns, you want to capture that in a variable called error, sorry, result, and you will get an error which will be captured an error. And you know, the process from here, if there's an error, which means error, not equal to nil, you will return API response, HTTP dot, status, bad request, comma, error body and what will be the URL body. Everybody in this case, by the way, is, sorry, the struct that we want to define right? So was there in the body, it's AWS dot string, with a single or sorry, string, e RR dot error. Comma. Okay. And you'll return API response. HTTP dot status created. Comma result. So if that means if there is no error, everything goes well, then you will say he should be dot status created. Alright. And that's about it. That's it, actually, that's your CREATE USER function, there's nothing more to it. Alright. And then for your update user function, very similar. You'll obviously call the user, just like you did here, user dot create, user here, you'll call user dot update user method. So we'll say, update user. And you'll pass three things request, table name and diner client. And you will capture that in result comma, header. And then you'll check again, if error is not equal to nil. return an API response has to be dot again, status, bad request, comma, error body inside the body. Again, the same thing, it was a string or a dot. Alright, but if everything went well, if the user did get updated, then you'll return API response. And you'll say SDP dot status, okay? That everything went well, and you'll return the result. So that means what's happening, these two functions CREATE USER update user is that these two functions are being called. That means a lot of the logic the main logic is going to happen in these two functions, right? Because not much happened in the handlers. Similarly, let's work on our delete user function. Here. You'll say user dot read user, insert request, comma, table name comma Diana client. Here also, though, the only thing you will learn from here is the error, right? If the user didn't get deleted, you will turn the error. You don't need to return the result and result from the delete function. So if the result is not equal to nil, you will return API response. You know by now what we're going to say we're going to say says bad request and we're going to also send the error body which will have AWS dot string And the error itself. But if everything went well, you would want to return the response with status, okay? And you will return nil for the error okay so that's that's about it. And yeah, that's it, I think the entire file is complete. Now, we don't have anything else to do. I've also gone through the AWS SDK documentation, I don't think anything else needs to be done in the handler. So everything looks alright to me. And now we will have to work on our user of go file and all these different functions that exist on a user.go file. For your CREATE USER function, we're all it's going to accept depends on what you're sending from here, which is request a preliminary client. So here, you'll say request, events dot API gateway proxy request, comma table name, which will be string, and then a client, which will be you already know, there might be a face dot nanodegree API. So what is it going to return, it's going to return the user that has been just created, or an error. So here, the first thing that we'll do is we'll create a variable here, which is of type user user being the struct that we will define that means you will have email first name and last name. Alright. So let's start from there. Now we'll use you, why'd we create this variable you is because we want to capture what's coming from postman. So from postman or from let's say, the terminal wherever will send the JSON of the user with the email, first name and last name. And that data needs to be unmarshal into you, so that Golang is able to understand it and also perform any operations on it. So what do you want to do is we want to use the JSON encoding slash JSON package to call the unmarshal function. And what you want to do is you want to pass the request dot body to it. Comma ampersand you if error is not equal to nil, and also here. He called the right syntax for the if statement. And if error is not equal to null, then we'll return nil, and we'll return something for the errors. We'll say error, invalid user data. But we don't have this error here, right? We don't have this error error fail to unmarshal record. We don't have error, invalid user data, we just have error fail to fetch record. That's all we have defined. Now let's define all the other errors. Let me define all the other errors that I'll need in this entire file and the beginning itself. So we'll say error failed to unmarshal record is equal to fail to unmarshal. Record and error and add error and valid user data is equal to and valid user data. invalid email also will be there and valid email is equal to invalid email. Then we'll have good not Marshal item and could not delete item so. Then we'll have could not put item so we'll say Could not Dynamo put item as equal to code not Dynamo put item. And user already exists. user does not exist, or the user does not exist. So why do I need all these errors? Obviously, by now you would have understood, I'll just give you an example that when creating a user, right, if we check if that user already exists, then we don't need to create that user. That's why we need this kind of an error. And if you want, if you're updating a user, then or deleting a user, we can use this, that user does not exist. So I trying to update that user, right? That's why I'm just thinking about all type of error functions, I'll need error statements I'll need. So depending on that, I've just created them. So going back to your create users, right here, now, we will start validating the email. So we'll say validators dot validators is the package that we have created together, right, this one. And the function that we created in that package was his email valid. And you is the variable that you define. And now after unmarshalling, the request that you in the body body is of the request that you got from let's say, postman, or from the terminal as JSON. You captured that in you. So now you can now go Lang can easily understand you because it's unmarshal, right? It's not just one and more, so you can access you dot email. And you can run the validation function on it. So here the spelling is wrong. Should I when is email valid? And you'll return nil, comma, errors, dot new error, invalid email. Right? And how how the reason why I created this error is because I want to see if that user already exists, right? So if the user already exists, then you don't need to create it. So we need to throw an error. So we will check if the user already exists, right? So I won't put that comment, actually, I was just trying to show you. So to check if the user actually exists, you have to run the fetch user function, you will say u dot male comma table name, comma Diana client. And to capture whatever comes from this function in current user, and we won't handle the error, so I'll put a blank there. So if current user is not equal to null, that means there is this user exists, right? If current user is not equal to null, and length of current user dot email is not equal to zero, then you return nil comma, errors dot new error user already exists. And so all of this if the user exists, but if the user doesn't exist, he will just say that user right, so how do you save that? So first, to save that, obviously, whatever you now have in you, you want to start want to start marshaling it right? So that DynamoDB can understand it now. So you will say Dynamo DB, attribute dot Marshall map, you and you'll capture this in AV and you'll check for the error. So if there's an error, we will return nil. And errors dot new error could not Marshal items which you've already defined, we've already defined this error right? And now, you want to start creating your data that you will be sending to DynamoDB. So how would you do that? You'll say DynamoDB dot put Item input item is Av. Comma. table name is AWS dot, string table name. And finally, you'll see Dana client dot put item, and you'll send this input that you've defined here. So yes, missed the is equal to sign by mistake. Similar to fetch users, right, you created this input, and then you call the ANA client function. Similarly, you're doing that the same thing here, you're calling the put item function. And you'll capture that in a blank actors blank variable or, and, or you will get an error from here. And if error is there, then you will just handle it very easily. You'll say return nil, comma, errors dot new error, could not timer put item right here faded this error already. But if everything went well, you just want to return the user are nil. Awesome. So this is your CREATE USER function. And now you're left with update user and delete user. Everything else you've taken care of right, the handlers are go file is complete API responses complete as as an email validator is complete, and may not go as complete. And I think for our user file, we have imported all the packages except for validators. So you need validators. So you'll say github.com, the validators package that you've already created? We talk I'm talking about that one. So we'll say go serverless yt, slash PKG slash validators. It will also check what else am I missing for handlers? I think I've already imported user. And I don't need any more packages. For API response. I don't need more packages. For his email valid, I don't need anything else. My main.go file, probably, I might have missed something. So it has handlers has always even slammed on AWS session DynamoDB DynamoDB is, so everything is proper, based on the AWS SDK, go right, check out this documentation, you will know why I'm importing these packages and how I've used these functions. You already know that because you've been building it with me, alright. Then we'll come here, again, back to our user.co file. And let's start working on the update user function. So what does it accept, accepts request, which is of type events, and thought API gateway requests, comma, table name, which is string comma, Dinah client, which is of type DynamoDB, I face dot DynamoDB. API returns a user the updated user. And, or fine, I mean, or it sends back an error. And we're going to do a lot of things which are going to be very similar to the Create User function, which is basically we create the user. First we created the user, right, which is the variable u, which is of type user. And we're going to unmarshal, just like we did, we're going to unmarshal the request body that you get. So request dot body, comma ampersand you so by mistake, yeah, so I have to close the bracket here, because this is together. And this is this variable view. Okay. And her nautical tunnel, if you don't want to follow along, you can just copy and paste this part, right? I'm not copying and pasting because this syntax might be new to many people. Because it's DynamoDB, kind of working with DynamoDB. So I'm writing everything by hand. If you want to copy and paste, if you're very comfortable with DynamoDB, go ahead and do that. You don't need to, you know, practice along with me. Then you want to fetch the user and see if that user even exists. So you will say your email comma, table name comma, data client. And you want to capture that in current user Adding on a check or the current user. So if current user not equal to nil, is exactly what you did in the create function as well. And length of current user dot email is equal to zero then you'll return nil comma errors dot nao error, user does not exist. So for the CREATE USER function, we were checking for the user associated with that email, because we want to see, you know, that is really exists, we don't want to add that user. But for update, we're doing the reverse, we're checking for that user. Because only if that user exists, we can update the data for that user make sense? And exactly the same things will do, because now you want to start. So now that the user, you know, if the user doesn't exist, will throw an error. But if the user exists, then you want to start updating the table with the new data. How do you do that? Whatever you've unmarshal right now, from JSON to unmarshal, to something that Golang understands, now you want to start marshaling it to something that DynamoDB understands. So you already know what you want to use, you want to use the marshal map function. To pass you to it, because you've just done marshaled. And which packages is a part of so it's part of the Dynamo DB attribute package we will capture it in a variable called AV or we'll get an error. And now we can easily handle the error. So if error not equal to nil, return nil comma, errors dot new error could not Marshal it, this one. Really, really straightforward. Now you just want to create your input item and then you want to just call it and a client function, only two steps remaining. So you will say input is equal to ampersand Dyna, more dB, dot put item input, and the item is equal to Av comma, the table name will be equal to AWS dot string. table name. And the last thing is you'll use Diana client dot put item and you'll pass the input and if error not equal to nil, nil comma errors dot new error could not Dynamo put item return ampersand you come on. Soon now even my update function is complete everything looks okay. And all I want to do now is run the Gomati command to get all of the packages that are not there. So I think it's taking a while I can't find my phone anyways. So while that's happening in the background, we can start working on the delete user function. So as you can see, it's all installed. I had a couple of issues actually. As you can see, and most of the issues were because I had a couple of spelling mistakes here instead of SDK added an S KD you know, so a small small few mistakes I had made. Just make sure you get these tight. You can easily get them on AWS SDK go documentation or if I put a mostly I'll put this code on GitHub. So you can just pick it up from there. Alright, make sense? Just pick it up from there instead of typing in all yourself because I made a couple of mistakes. So it was it was taking a while. But now it's install all these packages. So then your user.go file, everything works perfectly right? Like we don't know if it works perfectly but everything looks perfect to me. And all the packages are in place. All you need to do now is work on your read user function, which is actually the most actually the like the easiest function. So it takes request, events dot API gateway request, comma table name, which is of type string client, which is a type already know, you already know that. Dot DynamoDB API. Alright. So what you want to put in the function definition, you want the email of the user, right? So request dot, query string parameters, and the parameters, email, then you will create your input to the function which is of type DynamoDB. Hen dot, delete item input, item, input star DynamoDB dot attribute. Value. Basically, you're passing the email, and then finding the user and deleting the user with it associated to that particular email. Right? Nothing complicated. So you will say AWS dot string. And you pass email to that. After this, you'll say table name. AWS dot string, pass the table name. And now that you have your input ready, just like we've done all other functions, you take the data client, you call the DynamoDB function, which is delete item in this case, and you pass the input to it. And put basically has your query for deletion, which is the email ID. And you get the error. If there was an error will return errors dot new error could not delete item. Perfect. Otherwise, we just return null, nothing. Basically, that means that the user has been deleted. Now, I'm sure there are a lot of errors. Because I'm not using any type checking extension or any go Lang extension, right. So there will be a lot of errors here. So I need to start solving them one by one before I deploy it to the cloud. So to find those issues, and to fix them, I'll head over my terminal. And I'll head over to the CMD folder and has a co build main.co and starts giving me errors, right? So it says on this file, line number eight. Yeah, I can see the issue, it has to be doubled. Right. That's what makes it the or operator. So you will run the command again. And now you will get all these nice headers that we were expecting, right? And now we want to go start solving them one by one. So starting from line 37, all the way to line 145 too many errors. So when it says too many errors, that means that even after you solve these, it will give you many more errors, right? So this is why I don't really, you know, use extensions, because Because Golang takes care of everything, it tells you which exact line which part, what you're missing, you don't like it's a no brainer, right? You don't have to apply a lot of brains just solve these issues, just like go Lang once you do, and everything will run. So that's why I'm so chilled out all the time, man. So if I go back to your code, on line 37, what could be the issue is that I have not put a comma here and comma here. basic syntax issues, right? That's what it says it says basic syntax issues. Here also you need to put a comma. And let's keep putting commas wherever you know, I think it will need commas so this needs comma here, which is line 58. In my case, you can check it out where you know, it is for you. For CREATE USER again, I'll just put a comma here just to be sure. And I'll put a comma in the input part which is this. Alright, and in the update user function. Again, let's go to the input area. Here I've put the commas or haven't seen any issues here. And for delete, definitely you need to put a comma here as well as here as well as here. So now if we run it, a lot of the errors have gone away, right? And now you have some other errors. There are some syntax errors also, like for syntax errors, and one. This one was that you're not able to refer to this function. So let's try and fix those as well, at the same time. So let's hover over back to our code. Let me see the line first line says 88, line 88, blah, blah, blah, blah, blah, yes, M is small, whereas m should be large. What was I thinking? Am I stupid, you know, that I was not able to? That I didn't make them, you know, large, because obviously, the function is martial map with the capital M. Right? So this just means that no matter how stupid you are, go, Lang takes care of everything, right? So you don't need to be the smartest guy on the planet. So let's look at others stupid mistakes. So 108 comma missing? It's a syntax error. Super simple, right? It's even telling you expecting comma, right? I mean, how obvious can edit statements be? And then people, you know, tell me download this extension? I, I don't have done it an extinction man. Go Lang does everything for me. And missing statement after label wonder if I wonder if I miss you statement after label blah, blah, blah, blah, blah? Yeah, obviously, the physical sign is off. And then 147 147. put a comma here, right after 147. And then unexpected. Yep. Found it. Now let's run it. Now. Let's see some more errors. Yes, so it found some more errors. And now you have to go to Line Number 66, and 76 and 140. But these are not syntax errors. So here, you will have to think a little bit as to why the there's an error there. So head over back to your code on line. 66. Lines 66. Yeah, so it says, let's look at the error it says, cannot use results dot result or items. And something something something to do with this function called on Marshal map. That is because you're receiving items, not item, you're receiving multiple items, right? So you can't use unmarshal map function here, you'll just see use unmarshal list of maps. Super simple, man, super simple. 36, line 76. Alright, it says blah, blah, blah, blah, blah, request dot body. See it says request dot body undefined. And it also says does not have body with capital B. Right? I mean, you don't, you can be the stupidest person on the planet and fix this issue, because you just had to make this be capital. Right? So that's how intuitive go Lang is. And then you go to Line Number 140. Line Number 140. I mean, I can guarantee you that you can't do any like something like this with any other language, right? It says there's a problem with this function, obviously, because there's a spelling mistake here. Parameters. Everything is fixed now. And now let's see. So it gives me another error. It says unmarshal. Just off map is wrong. Yeah, because I made mistake. Again, it should have been unmarshal list of maps, not map. Awesome. So now, now that your user.go file is sorted as an IT first shows you the syntax errors, you've solved them, then you solve the logical errors. And now it's giving you some issues with the handlers file right handles. It's giving you all these syntax errors, we'll solve them and we'll give you some logical errors. We'll solve them as well. And then we're good to go. Right? So we're on the right path. Now let's go back to our code. So whenever your code and start from line 19, line 19, put a comma here, line for it to fall to put a comma here, it was saying it's accepting expecting a comma from you, right? And line 54. Comma, line 59 Blah, blah, blah, blah, blah Pratama. Line 62. 60 and 72 and 66 for comma 32, comma. All right? Now you start getting the real errors, right, the real errors. So, line 22, we just solved this issue on the other file line 22 Because the spelling of parameters is wrong. And now you're going to worry about line nine, line nine. So one thing to notice is that it's line nine, but another file API response would go. So open up the API responded, go file. And here I can see there's an issue. Alright, I've fixed the issue. It was basically to do with those brackets. And now it's starting to show me issues with may not go file, which is what I want. I want to fix the main.go file issues. But on line 44, line 44. Let me see what's happening. Okay, yeah, I can see it, I can see the issue, it's basically all the cases have to be together. And by mistake, I'd written this outside the bracket, also the switch bracket, and I've included inside. So that error should also go away. And now when I do this, it's created the goal build may not go file for me. So let me see if it has Yeah, I can see the main file, I just have to move it here to my build folder. And I've hit the build file, without any issues, no errors, right. So now let's start the deployment process. Before you do anything else, you need to first create a zip file. So you'll just come here it will say zip minus gr M and build slash main dot zip. From build slash main. So build is your folder main is the build that you've created for any folder, and build slash main dot zip will be the zip file using the zip function. Maybe in your Linux, you don't have zip, you'll have to install it using sudo. apt get install zip. So now if we check here, we can see the main dot zip file in my build folder. And now we ready to kind of start uploading it on lambda, or ADA plus lambda. But as remember, as you remember, I told you that I have Windows installed on that I'm running WsL on that I'm running this open too. And on top of that I've built this folder, right? So I need to be able to access this main dot zip file from my windows for my windows to be able to install, like upload it on my AWS code and lambda lambda dashboard. So for that, I'll do something. So to in order to help me to do that, I have to run this command explorer dot exe. Dot. Now hopefully it should open. Yeah, it has it has opened up the Explorer at this location for me, and I'll copy this. I'll put this on my desktop. Awesome. And now I can start to deploy this on my AWS console. So you want to start deploying, but there's one thing I wanted to change is this table name. So I'll keep this table name same as my, the name of my program. Go serverless righty. Okay, just for consistency sake, because we'll have to create this table in DynamoDB. And let me just search. If I was using the other table name, so you'll just control Zed. And we'll just see if I was using this table name anywhere else in any other file. This only place there's only one place I was using it. So here's the table name has to be changed. It will say go server less writing. Okay, and now is when we start deploying. So log into your console and head over to lambda. You have to just create function go server less writing server using Golang one point x I think we'll have to change the execution roles create new role from AWS policy demo This option is what you have to select, and the roll name, go serverless, righty execute from the templates, you have to choose Simple micro service permissions create function successfully created, right? Now you want to change the handler. So as you know, our main, the file that we'll be uploading is called the main file. That's what our build is called right. So we'll have to change the handler to mean upload the zip file and upload it, go back to AWS and go to DynamoDB. Can you will click on Create Table Table names table name is what you selected here go server less whitey. Simple, right? Because we've kept everything the same name so and primary key. So it says enter the partition key name, I think this is the primary key here is the primary key. The primary key in our case is email. Which is string, obviously. And everything else is same. And we can just create the database active, it's now active. So now we can proceed to the next stage, which is configuring your API gateway. So head over to your API gateway. Create API. Now to build a REST API. Protocol, let's test select new API here. And now you want to put the API name, which is cool. Server less ID. And you then create the API. From the Actions to create method, select any. And here you'll select integration type lambda function. And check this use lambda proxy integration. And you have the name of the lambda function here, which is go serverless YT. And you have to also have to ensure this is checked default timeout. Now we need to deploy our API. So from actions deploy API select new stage, stage name of staging and deploy. So this is your URL that you get here. Which we will be using right now to test. So let's test it out. I'm, I'm expecting some errors to be there. But not a problem. Let's clear our screen. And first, we'll have to build this command. So just give me a second. So here are my four commands. And obviously, this is post which is creating a user this is get all users get a particular user by email ID. And this last command is for update. Now we can use postman or you can you just use curl which are the same thing right? And you set your header header and you tell it was the request which is post and the data that you send which is email which is my email address, my name my last name and this is the the unique link that I just got this Link is the unique link that I just got from my invoke URL. Okay, so I'll post these, I'll post this command somewhere, how do I post it? Now? Okay, so I'll do is I'll upload this project on GitHub, and then in the description, I think I'll just post these commands so that you can just copy and paste them quickly. I think that will be the best option. Or you can just use postman when given you have to use these commands if you don't want to. Alright. And similarly, for the update, you say it's request, but you have the new data is going to find email based on that, because email is our primary key, as you already know, and this is my API link will follow commands, I need one more command, which is the Delete command. So I'll change that to this. So you will get all these in the and API gateway documentation on how to call these API's, you can get that also. And so I'm just copying those, and I'm just changing those commands. Alright. So what we'll do now is we'll try and test it. I'm pretty sure that we some error will fail. But let's do it anyway. Oh, so it worked. It worked. Alright. So it created this user, which is amazing. Restaurant the second command. Sorry, this command is not copying and pasting. Now returning the get all users command. So we'll get all the users only one user is S, which is getting that. And then we'll get the particular user. particular user has this email id, it will get that user also for me, because there's only one user right now. Yes, so that's also working. And now we will work on our put function. So sick, it's taking my email address and changing my first name to lalala and last name to blah, blah, blah, right? So it's done that you update is working. And now we have to work on the delete function. So if the delete function works, it won't return anything. So we will check if that user is still there, so we're getting all the users. That means delete work, because it's an empty array, right? That same user is not there anymore. Perfect. So that means everything is working. I hope you enjoyed this tutorial. It's a long video, I know there's a lot to follow. There's a lot to learn there. And I hope you really enjoyed it. I hope you learned a lot in this project. And very soon I'll have I'll have one more project coming up with serverless tag, but it's a little more advanced, we'll have multiple lambda functions, we'll have CloudFormation, we'll have you know, those CloudFormation scripts. So everything will be through YAML files, and then AWS CLI. And we'll also use AWS, Sam for the entire setup. So that's going to be really complicated. So make sure you've done the AWS lambda, you know that video and you've done the serverless video. And then you read a little bit more about how serverless works and all the different technologies. And that will really help you in the next upcoming video. There'll be slightly longer actually much longer, and they'll have like way more complicated project, right. So the point of that is where this is like a monolith serverless project, right? That will be serverless microservices project, there'll be API gateway CloudFormation. They will be a lot more technologies. I will use AWS, Sam for all the writing all the configuration files. Anyhow, so I hope you're enjoying it and do subscribe to the channel if you haven't already. And there are hundreds of videos on go Lang on my channel, check them out. And I also keep sharing some nice advice on you know, your development career. So keep watching that as well. Alright, so see you and connect with me on LinkedIn. There's the LinkedIn link in my description box below. Thank you