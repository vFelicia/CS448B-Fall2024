In this course, you will learn everything you need to do to start your own software as a service company. You will learn how to build and deploy a full stack AI SaaS from the ground up. You'll even learn how to charge subscription fees using Stripe. The app you will develop uses Next.js, OpenAI, TypeScript, and Tailwind. Elliot Chong created this course. He specializes in creating comprehensive tutorials to build AIpowered applications. What's poppin'? I'm Elliot, a software developer from Singapore, and today I'm going to showcase what I've built here, which is a chat with PDF SAS product. I'm going to teach you how to build it from scratch. So this is a SaaS platform that is a clone of an original product called chat.pdf itself, and how it works is really simple. You can basically drop any PDF you want here, and you're able to use OpenAI to interact with the PDF. So for the first example, let's just take my own resume here. I'm going to upload my own resume. This is going to upload the file into Amazon AWS S3, and then within a few seconds here, we can see that it's hosted on Vercel, and you can see that a chat is created with my resume, and we're able to see it updated on the platform. And the magical part is here. I can ask any question, and it will have the context of this entire PDF. So let's say I ask a question like, where did Elliot intern at? So I'm going to zoom in a little so you can see. So when I press enter, we can see that there will be a streaming response back from OpenAI itself. And he says that Elliot intern at Relu8 technologies. And this is correct. If you see up in the PDF, I did intern at this company called Relu8 Technologies. So it's able to get the context of this entire PDF and feed it into OpenAI itself. And usually we can't do that because if you try to feed in the entire document, it might exceed the token count for GPT, like chat GPT. If you try to paste this entire PDF into it, it might overflow and it won't be able to respond to you. But in this case, it's able to take in the context. So let's ask here another question like, what are some projects that he did? So I send it and we'll be using Vercel AI SDK for this streaming AI effect. So it's able to list out the PDF, and all of these chat logs are saved into the database. So let's take another example on how this platform can actually be potentially useful. So one good use case for this PDF function is, let's say I come to any documentation site. So let's say I'm in the Vercel documentation, I have this picture, but I don't read through it. And I actually want to ask GPT to interact with this. Because the issue is that chat GPT, if you go to the chat GPT website, the information are outdated, meaning that whatever you ask, the chat GPT has only been trained on data up to, I think it was 2021, September or something. So it doesn't have updated information about the updated technology documentation. So if I were to ask about a new feature of Vercel, chat GPT won't be able to answer that accurately. It will hardlisten it. So what I can do is I come down to that documentation, I press Command P, I can save this entire file, look, I can save this entire file into a PDF. I'm going to press Save. Okay, and I'm able to upload this PDF onto my chat PDF platform. So I'm going for it to save, and after that I can come here. I'm going to upload my CDS Edge runtime Vercel docs, I'm going to upload it onto the platform, and it will basically allow me to interact with the latest information from whatever document I want. So I can ask like, what is the Vercel Edge runtime about? So I'm going to send this and you can see that this information here is pulling directly from the document itself. So it does not hardlisten it. So that's another good thing about this entire platform here. So we're able to see that it's able to pull in the latest information. So not only is this a really useful platform, it's a very useful platform. I'm going to teach you how to build this entire thing from scratch. And actually what there's one more feature on the showcase is that by default, we can actually limit this platform so that users, when they sign in, they can only upload three PDFs. And then we'll be able to teach you how to integrate the Stripe API. So we can see Manage Subscription. We're able to use Stripe to allow them to pay a monthly subscription, $20 a month, and they're able to use this platform unlimited. So I'm going to be teaching you how to do the Stripe integration, and you're actually able to deploy this sales product and eventually make a business on it if you want to improve on this platform. So we'll be allowing a lot of things today. So there's two main parts of the tech stack. The normal tech stack for the full stack we'll be using next year is 13.4. We'll be using a click authentication. So it's a new authentication library that makes Google authentication, all types of authentication, super easy. We'll be using Drizzle ORM and NeonDB. So NeonDB is a new, not new, but it's a serverless postgrace database. So we'll be using that instead. And we'll be using the newest kit on the block Drizzle ORM. So this is in comparison to PrismaDB. Prisma is now ORM, but this I'll be using Drizzle. And I'll actually explain why we'll use Drizzle later on. Then obviously we'll be using Stripe API for the assessed product integration. And lastly, we'll be uploading all our files to AWS S3. So I'll teach you how to use the S3 bucket also. This is for the file storage. For the AI tech stack, I'll be teaching you how to use PyConDB, LangChain, OpenAI, and the new Versailles AI SDK. So I'll be going in depth on how to actually use these tools to actually create that custom context PDF thing. And so PyConDB is a DB to store a vector embeddings of all documents. LangChain is what ties together the OpenAI and the PyConDB. And OpenAI is obviously the GPT model that actually creates the last language model for us to use. So I'll explain a lot more in depth later on. So we just need to know that I'll be teaching you how to use this tech stack. So the new main concepts that I want to teach in this video is the H runtime environment. So what's H runtime? The H runtime is if you come back to exactly the Versailles docs that we saw just now. So the H runtime is in comparison to the normal Node.js environment. So H runtime is, let me draw it by this explanation. So imagine this whole thing is the globe, is the whole world, right? And let's say I have these two continents, Asia and America. Obviously, they're not to scale and there are other continents, but I'll demonstrate something. So let's say when you deploy a normal function, a normal endpoint to Versailles or a normal server, the server will leave somewhere in the world that you choose that is closest to your users. So let's say a lot of your users are close to Asia. You ideally set up your server in Asia so that whoever makes requests to the server will be able to quickly get the response back so to ensure the best user experience. However, what if the someone from America wants to make a request to your server? It's to travel all the way down to Asia and then get the response back. So you make the whole experience very slow. So that's the traditional serverless environment thing. So what the H runtime does is instead of packaging up and deploying the server to only one location, it actually is able to duplicate the code and actually deploy the execution environment onto CDNs. So CDNs are content delivery networks, meaning they are small machines that is distributed all around the world, right? And basically it allows for a very fast user experience. So whenever, wherever your users are, they are able to find a CDN that's closest to them. And so when they make the request, no matter where you are in the world, it's going to be super fast. So why the tradeoff of being able to deploy all around the world and making it super fast, the tradeoff is that H runtime usually have a smaller package size. Meaning, let's say we come back to the H runtime. Let's look at that tradeoff. So H functions run on H runtime, right? So the H runtime does not expose all the node APIs. Meaning, right, the power of node.js is that it has a lot of packages on NPM, right? So you're able to use all the NPM packages on a normal serverless environment, right? But if you're using the H runtime, you're sacrificing the speed for, you're sacrificing the packages for the speed. So there will be a lot of restriction in terms of the APIs that you're able to use. But if you sacrifice that and you use the supported APIs like the fetch API and the request response, all these, if you're able to sacrifice that, you're able to get a very, very fast response time for your application, right? So the reason why I brought up the H runtime is because today I'll be teaching you how to deploy all your AI services on the H runtime. So OpenAI has actually created a lot of initiatives and a lot of these are different packages, especially the Versailles AI SDK. They have started a lot of initiatives to move these AI packages up to the H, to make it H compatible. Meaning that a lot of these AI applications will be able to run on the H, right? Furthermore, the reason why we chose Drizzle Rm is because Drizzle Rm is compatible on the H, right? So I don't think Prisma DB is still compatible on the H, therefore we are not able to use Prisma for this project. So I'll be teaching you how to use Drizzle Rm to interact with your database. Then the second new concept down the check is the retrieval augmented generation. So this is a... So RAG, retrieval augmented generation, is a concept within a large language model. It's an AI framework for retrieving facts from an external knowledge base to ensure that the large language model has accurate information. So instead of the chat GPT just hallucinating up information, we're able to give it a certain context, in this case the PDF, such that it's able to generate accurate uptodate information. So that's what a retrieval augmented generation is within the context of this project. So I'll be going much more indepth on how to build the proper RAG framework for our application. Alright, so with that, let's actually begin the development of this platform. So the first thing here I'm going to do is I'm going to come out and open up our terminal and thus initialise a new Next year's project by doing MPX createnextapp at leaders with a TypeScript flag. So let's press enter, and it's going to ask us for the project name. So let's call it ChatsPDF.youtube. So we'll be using ESLint, Terwin CSS, we're going to be using the source directory, and this is the new 13.4 app router. We're going to leave everything as a default and we can wait for it to install and then we'll come back soon. Okay, so after we have initialised the project, let us actually cd into the chatpdfyoutube, and let us open up in our code editor by doing code. We should open up in VS code. Okay, so the first thing here what I'm going to do is let me open my terminal and let's just do npm run dev so that we can make sure that the project is up and running. So when we come back to our browser, I'm going to open up localhost 3000. So I'm going to try to develop it alongside here, I'll move it to the right of the screen and open up my VS code here. Okay, awesome. So right now we have our Next year 13.4 project up and running. Okay, so the first step I'm going to do is I'm going to come down to my directory. So under the source, we can see that there's a new app folder here, and how the routing works within Next year 13.4 is that under the app router, this page.tsx is a special file. Whenever you name the page.tsx, you can look at the file structure of it and determine the root layout. So right now this page.tsx lives at the root app folder, therefore it is mapped to this slash root. So this app.tsx actually corresponds to this page. So what I'm going to do is I'm going to delete everything here, and let me just return a normal h1, right, that says hello world. And let's give you a class name of text rate 600 to test out Tewin CSS. So if we save it, we can see that now it works. Alright, that's good. So now that Tewin CSS is set up, let us actually set up a shad cn. So shad cn is a component library that's built on top of Tewin CSS. So it's based on radix UI, which is a accessibility library. So if we come to radix UI, we can see that it is a component library that gives you the accessibility features out of the box. But these are unstuck. That means that by default radix UI is not stuck component. So to add a plaster on it, that's where shad cn comes in. So shad cn uses Tewin CSS to style those accessible components for us to use. Alright, so to actually start using shad cn, we'll come down to open a new terminal instance. So I'll split the terminal here. And let me just move this to the side. And let us do mpx shad cnuiui at latest, we're going to do init. So it's going to initialize the configuration for our styling. So we'll be using TypeScript, we'll be using the default style. We'll leave the base color as a slate. And for globals.css, if we come down to our directory, we can see that under this app, we got this globals.css, right? I'm going to delete this. So because we want shad cn to control our styling needs, I'm going to delete this globals.css. Then I'm going to come down to my terminal and I'm going to enter, it's asking where's my globals.css? So I'll do slash source, slash app slash globals.css. So it's going to replace the globals.css that we have. So we'll be using CSS variables and our tailwind.config, we can see that it leaves at the root here, tailwind.config.ts. So let's just enter tailwind.config.ts. And lastly, we'll leave the import alias for components and utilities as it is. I'll be using React server components and proceed to write the file, the configuration to components.json. OK, so let me just refresh the page. OK, so right now we can see that everything's working fine. OK, so let me close it down. So shad cn has created a components.json here that contains all configurations for our shad cn components. It has also created our globals or CSS, which includes the tailwind styles and also the shad cn default CSS variables here. And lastly, we can see that it created a new lib folder and under it has created utils.ts for us. And this is just a tailwind utility class function so that we can actually use conditional tailwind styling much more easier. So I'll go through how to use this function on later on. And lastly, it has created a component folder for us. So to begin using shad cn, let's render out the button. So to install the button, how it works is you have to come down to your terminal and whenever you want to use a new component from shad cn, you have to do mpx shad cnui add latest add button. So you have to add the individual components. So this ensure that whatever components that you don't need from shad cn will not be installed. So I can press Y to install the components into our folder. If I come back to my directory, we can now see that under the components folder, I have a new UI folder. This UI is going to contain all the shad cn components. So this is where shad cn defines the button for us. We don't need to, as you will touch this file, we just need to know that it exists and we can use it. So how do I actually use this button from shad cn? So let's come back to our page. So instead of returning a hello world, I'm going to return a button. So we can see as we type out, the button will be imported from components slash UI slash button. So I can press enter to auto import and I can just say click me. Then I'm going to save it and now we can see that the shad cn is properly configured. So that's excellent. Alright, next up, let's set up clock authentication. So in our original application, we can see that this or the authentication is handled by clock. So I can sign out and it is managed. And if I want to actually log in, I can press log in to get started. So then this will lead us to the clock signing page. So I can sign up with GitHub or Google. So in this case, I'm going to sign in, continue with GitHub. Then basically it will lead me back to my homepage and I'll be able to get my user information. And then we can see that he has brought us back to the original application. So to set up clock, let us go to this search clock auth. And then it should be the first link. So clock.com, I'm going to move this to the site first. So the first step here is let us actually log in. So if you have not created an account, please do. So after you have done that, we can actually come to our, let's just zoom out. And then we can go to the console, the dashboard. So let's press the dashboard and then we can come in and create a new application. So click on add application. And in this case, let's name it to chat.pdfyoutubeyoutube. So you can choose how your users will sign in. In this case, I'm going to toggle off email address, right? So we just want to allow them to use Google or GitHub. So you can add whatever you want, you can add Microsoft, whatever you want. So I'm going to just choose this tool for demonstration purposes. Then we'll click on create application. So let me just split my screen again. So now that we've got a publishable and secret key, we have to copy these two environment variables into our.env file. So come back to your directory and at the base of the directory, let's create a new.env file to store all our environmental variables, right? So one more thing, just in case we forget, let's go into our gitignore and then let us enter our.env. So we don't want git to actually track our.env file, so we don't want to push these environment variables up to GitHub. So save the git.gitignore and now we can copy these two lines of code into the environment. So these will define the two clerk API keys for us to use. So let's save the.env and we'll close it up. Now let's press continue in doc so that we can follow that instruction. So we'll be using clerk with Next.js so we can just follow this. So let me just close this out. So the first step here is actually to install the package. So let's npm install add clerknext.js. So let's install that. So then the second step is to put the environment keys, which we have already done. So now the third step is actually to mount this clerk provider. So what I'm going to do is, once it has finished installed, I'm going to come out to my layout.tsx. All right, so under my layout.tsx, I am going to basically put in the clerk provider. So here I'm going to do a few things first. So right now we can see that it has finished installing. So in my layout.tsx, this file is the one that wraps my entire application. So you can see this children. This children represents my entire application. So whatever metadata here we can add, we can wrap this entire application here. So for this metadata, I'm going to delete the description. So for the title here, this corresponds to whatever title you see on the tab itself. So I'm going to name it to chatspdf youtube. So if I save it, now we can see that the tab title has updated. Then under here, I'm going to add the click provider, right? So the first thing I'm going to do is, let me see if I can auto import. So I'm going to import clerk provider. So it doesn't auto import. So let's just manually import the click provider from add clerk slash next.js. So clerk provider, and then I'm going to wrap my entire application with this clerk provider. Okay, then I'm going to save it. So after adding this clerk provider, so let's see what else we need to do. So we have wrapped the entire clerk provider. And last thing here is we need to protect our application. So we need to create this middleware.ts file. So come down to our folder, and under in our root directory, in our source folder, so under source, create a file called middleware.ts, right? So this middleware.ts is a special file, right? Such that in here, we can define code that will run before every routes, right? So let's say you navigate to a route to slash home or slash api slash chat, right? Before you hit the endpoint, the code within this middleware file will run first. So let's just copy in the code from, we'll copy in. So let me explain what it does. So this config, right, that specifies the matches. So this matcher is basically a bunch of regex to specify when this middleware should run. So it will run whenever we're hitting a slash endpoint, or whenever we hit like slash api with a star character. So this array will basically dictate when this code will run. And then here, this is the auth middleware that's imported from clerk, right? So this code here will actually then run the necessary logic to protect our routes. So by right now, all the routes are private. So I cannot even access the slash. So now if I save it here, and I refresh the page, we see that it should redirect me to the clerk page because it's a protected route. And in this case, it does. So we can see that it's redirected to their hosted domain, right? And it's asking us to sign in to our chat PDF there's YouTube, right? So we actually want to make the slash route into a public route. So what I'm going to do then is I'm going to come down here into our auth middleware. So within this auth middleware, I can pass in some options. So one of the object is the public route. Public route is an array. So I can define what routes I want to be public. In this case, I'm going to just specify the slash route to be public. So then when I come back here to my local host 3000, instead of kicking me to the sign in page, I'll be authorized to visit this route. So this is a public route. So I don't have to be logged in in order to view this page. Okay, so now that we have set up a clerk, let's actually begin creating the homepage here. All right, so I'm going to just start out the diff. So the first thing here is actually to mark it async. So this async will make sure that it's a server component. So this entire code block is going to run once on the server to generate the HTML code. Then this HTML code is going to be directly sent back to the client for it to be rendered. So this is a server component. So I'm going to just return a few return. The first thing here is to create the upper the outer diff. It's going to have a width of a screen and the minimum minimum height of a screen. And also, let's create a bit the background gradients. So I search up tailwind CSS bg gradient. And basically, I found this website called hyper color that basically gives you all these options for gradients and you have to customize it and copy the tailwind CSS to your file itself. So I've already found one that I like. So I'm going to paste it in here. So it's going to be bggradient2, right? From rows 100 to 100. So if we save it, now we've got this nice background going on here. So within this diff, let us create an outer diff that centers everything in the center. So we'll do absolute position absolute. We'll give you a top of half, left of half and offset it back by negative translate half and negative translate y of half. So this will center anything within it into the center of the screen. So that's nice. So now let's actually create the text. So within this diff, let's have a new diff called flex column. So we'll have items of center and text of center. Within this diff, let us create a diff with a class name of flex and items that center. Within here, we'll have a h1 that says chat with any PDF. So let's save it first. We give this h1 a class name of margin of three, text of five excel and font of semi bold. So let's save it and now we have a nice title showing up here. Below the h1, I'm going to show the user button. So now we can see that there's this user button whenever I'm signed in that shows my information and I can manage my account. And this is a component provided by clerk itself. I can sign out also. So this component is called user button, right? I can import it from a clerk slash next to yourself, right? So we'll import that and we can pass in one option for after sign out URL. So whenever they click sign out, we're going to redirect them too. So I'm going to redirect them back to the original URL. So it's the same page basically. So let's save it. So right now we can see that nothing shows because we're not signed in. So this user button will only show when you're signed in. Okay, so that's normal. So then below this diff that shows a chat with any PDF, let's create another diff called flex and give your margin top of two. All right, we here will show a button that says go to chats. So let's save it first, right? So this button will show so that they're able to go to their chats if they're signed in. So actually, how do we check whether they're signed in? So actually, clerk also provides us with another very nice utility function called auth. So we can import this auth function from clerk, right? We'll invoke it. So we have to await the call here first. And we'll be able to get back a user ID. So I'm able to get back a lot of different things, right? But one of these things is the user ID. So if the login, this user ID will resolve to a string, right? Is it a string or no? But if it's no, that means they are not authenticated. So again, bind it to a variable called isAuth. This would be double negational user ID. So if it is not now, if it is now, this will turn it into a Boolean. And this isAuth now is a Boolean itself. It is a Boolean. So it's whether they are logged in or not. So underneath here, we actually want to only show this if they're authenticated. So if they're authenticated, then we let them go to the chats page. So right now, we're not authenticated. Therefore, it is hidden. OK, so that's good. So then underneath this div, let us have a paragraph tag that just says, join millions of students, researchers, and professionals to instantly answer questions and understand research with AI. So let's save that. It shows a nice tagline below it. So let's give this paragraph tag some styling. So we'll give you a max width of Excel, a margin top of 2, tags of large, and tags slates of 600. So if we save that, we got a nice styling here. So actually, just let me change it to margin top of 1, because I think it's a bit too big right now, margin top of 1. OK, that's good. Then underneath the paragraph tag, so we're still just above the tree closing tags. Let's have a new div that is a width of 4 and margin top of 4. OK, so this part here is going to be what is going to be the file upload page. So I'm going to just check if it's off. So if they're authenticated, then it makes sense for me to show a file upload component. So I'm going to create a file upload component later. However, if they're not authenticated, let us actually link them to the signin page. So I can import this link from next slash link. And within this link, let us just have a button, a button that says log in to get started. So this link component is going to have a hitref to slash sign in. So let's save it. So I still haven't created this signin route. So I'm going to create that soon. And this signin page is basically a click page so that they're able to see and log in with their Google or GitHub. So log in to get started. And let me just add an icon just below this button. So within this button, let me add a component called log in. So for the components, let us actually download the package called npm install lucidreact. So this lucidreact is basically a React package that gives us a lot of nice icons for us to use. So let me just do log in again. So let me just import it manually. So import from lucidreact. Okay, and then there should be a log in component here, log in icon. So let me just import it log in and let's save this. And right now we can see that there's a nice button here. So let me just dial it a little. So let's give you a width of 4, height of 4, and a margin left of 2. So now it looks much nicer. So then finally, underneath this div, we can add an image. So in case you want to showcase your application product, you can just add a screenshot of your image down here. So just in case for demonstration, I won't add it here, but it's a very simple function to add. So now let's actually create the log in route. So one more thing we need to add is if we come back to our.env file, we can actually define a few things for kirk to take into consideration. So let's come back to kirk.com and let's actually view the documentation again. So I'm going to come back to my console. So I'm going to expand this out a little bit more. So come back to our dashboard. Let me expand this. So dashboard and come back to our kirkpdfyoutube. And let's come down to our continuing docs. So we have already set up the provider. We protect our application. So last thing here is actually to create the environment variables to define where I will sign in and sign up pages are. So I'm going to copy these four variables into my.env file over here. So I'm going to copy it just below here. So let me just add a comment that says this is for the kirk. Kirk environment variables. So we list four variables. So it defines where our sign in page is, where our sign up page is, and where to go after we have signed in and signed up. So we'll just leave it as default. So even to change it, let's say you want to bring them to a dashboard after they have signed in, you can just easily change it to a slash dashboard. And then whenever kirk signs you in, it will automatically navigate you to dashboard. So let's save it. So how do we actually create these sign in files? So if you come up to our first step here, we can build our own sign in and sign up pages. So let's come down to our directory. So the first step is come down to our app folder, and let's create a folder called signup. Within this sign up, create another folder called double square brackets dot dot dot signup. Then within this folder, let's create a page.tsx. Then this page.tsx, we can just import the sign up component from kirk itself. So this sign up component has the prestyle from kirk itself. So let me save that, and let us do the same for the sign in page. So come down to our app, and let us create a new folder called signin. Within it, let's create the dot dot dot sign in wow card, and then let's create page.tsx. So page.tsx is a special file name. So we'll do the same for the sign in. We'll import it from kirk itself and just return it. Okay, so now that everything is completed, if you come back to our YouTube, and we can see that when we hover over it, we can see that it's being brought us to our sign in page. So let me click on it, and by right, it should bring us to our slash sign in, and it's basically showing us this default component from kirk. So let me just center this component in the center. So I'm going to just return a wrapping div with a position absolute. Okay, so I'm going to wrap this into sign in. So let us have this custom of absolute top of half, left of half, and the div translates x of half, and the div translates y of half. So let me save it, and now we can see the sign in page is brought to the bottom. So I'm going to delete this semicolon. So then we can press continue with GitHub, or we can go to the sign up page. So if we come back to the sign up page, we have shown the sign up screen here. So I'm going to do the same. I'm going to copy over this div to our sign up page. Right, so I'm going to just wrap this entire thing, and then within here, let me just close this div, and then now it's also centered. So I'm going to sign in with my just Google account, continue with Google, and we can choose which account you're going to sign in with, and by right, this should navigate us back to our slash page. So now we can see that we have been signed in. Right, so now we can see that our user button being shown here, and we can see that since we're logged in, the file upload component is being shown. So that's perfect. Okay, so now that we have set up Cluck, we can see that we can manage our account and even sign up. So all these functionalities are provided by Cluck in a very simple to use API. Okay, so the next step here is actually let us set up our database. So for the database, we'll be using a Neon DB. So come down to Neon DB. Right, we can see that Neon is a serverless, branchable postgres database. I'm going to open it here a bit more. So to actually create the database, so you have to sign up or sign in. So I have to sign up with my GitHub account, so I can sign in. So underneath the project, you get one free project for this database. So you just have to come down and press create new project. So for the name, let me just name it as chat PDFusual. For just postgres version, just leave it. And for the region, choose one that is nearest to you. In this case, I'm going to choose Singapore. For the rest, just leave the configuration as default and just press create project. So now we can see that the project has been created and the database has also been created for us really quickly. So now we're going to save this string to our environmental variables. So copy whatever database URL you have here. Come down to your VS code. Come down to your.env file. And below here, let me just initialize this variable called database and let's just paste it in. So make sure there's no white lines and make sure there's no white spaces behind. Okay, so one more thing here you might need to add is come down here at the end. Right, you need to add a config called SSL require. So let me just check here. So we're going to add one question mark and just do SSL mode equals to require. So this is so that our connection is secure and so that our Drizzle ORM is able to connect to our neon database. So after you're done, just save it and close it back out. Okay, so now that we have our neon setup, let's close the tab. We don't need it anymore. And now let's actually set up the Drizzle ORM. So if we are not sure what Drizzle is, Drizzle ORM is a TypeScript object relational mapper. So what's an object relational mapper? It's just a way for you to interact with our database without using SQL. So it also gives us that type safety and makes dealing with database cost much easier. And why we chose Drizzle ORM over Prisma is that Prisma is known to be much slower and also Prisma is not edge compatible. And in this case Drizzle ORM is a new ORM that is edge compatible. So let's actually set up Satya. So go under your file directory and we need to create a new library for this. A lib. So come under your lib and let's create a database folder. So name it db and within this db folder in the lib folder, create a new file called index.ts. Okay, so this is where we can set up our Drizzle ORM. So the first thing here, we need to actually install the Drizzle packages, right? So let me just close it and open our terminal and let's install the Drizzle by doing npm install a Drizzle dash ORM. Okay, and then we need one more thing. We need the npm install at neon database slash serverless. So this is for the adapter between the neon and also our Drizzle ORM. So while we're waiting for that to deploy to install, let's come down to our index.ts. So the first thing here is actually let's import a few things from at neon database slash serverless. So we need the actual neon function for the connect to our database. And then also we need a neon config. So we can set neon config dot fetch connection cache equals to true so that it caches the connections that's being set. And then underneath that, let's actually check. So if we do have a database URL, so if not process dot env dot database underscore URL, we can just throw an error, a new error that says a DB database URL is not found. So if we have a database URL, then we can connect the SQL server using the neon function and we can connect it to our process dot env dot database URL. Okay, then underneath here, we can just do export cons DB. So this DB variable is what is going to be used to interact with our database. So we can call functions like select database URL select star from whatever table you want. So this DB will be calling drizzle. So this drizzle is imported, so import. So I'll just move it down here. So import from drizzle ORM slash neon HTTP. Okay, so we need to just import a drizzle function. So this drizzle is going to take in SQL and then we need a schema file. So we need a schema because the schema defines the shape of our database. So let me save this index.ts. Come down to your folder again. We need this DB file. Let's create a schema.ts. Okay, so this schema.ts is going to where our table definitions are going to go. Right. So the first thing is I'm going to import a few things from the drizzle ORM dash PG core. So PG core sends for Postgres core. So it's going to contain a lot of different utilities from Postgres database. So it contains things like integer or like a PG table. So we need a PG table function. And we also, let's actually create a, let's actually start creating the tables. So for the data model, right, we need, first thing we need is a chat. So a chat table, the chat table is going to contain this individual stuff. So if you go to chats, we can see that each chat is an individual row within the database. So when we go into chats, we can see that we have all these chats, right? 10 plus chats. Each chat is going to be one row within a database. So each chat will contain the name of the PDF, the URL to the PDF, the user ID related, whoever created the chat, and also whatever chats that is going to hold. So let's create that. So the first thing here is we can export cons, a chats, right? It's going to be a new PG table, a new Postgres table. It's going to have a chats, a name within the database itself, right? And then for the second function, the second parameter, here's where we can define the columns for this Postgres table. So this is just how the user ORM works. So we're going to have ID, right? This is going to be a serial. So we can import serial from a PG core, right? Make sure it's imported from PG core, right? We'll have a column name of ID and we'll make this a primary key. Okay. Then we'll have a PDF name, right? So this PDF name is what is shown here in the sidebar, right? This is going to be, let's put it as a text. So this text also comes from a PG core. It's going to be named PDF name and we'll set it as not now. So make sure that this name cannot be now. We have a PDF URL, which is also mapped to a text of PDF URL. And we make sure this is not now also. We have a creator add view, right? This is going to be a timestamp view from PG core itself. And we'll just make sure it is not now. And also we can default to now. So whenever we create, it's going to default this column to the timestamp now. Then lastly, we need a user ID view. So this user ID will be pointing to the clerk user ID. So let's just put it as var char. So this var char also from PG core. So let's name it as user ID. We can give you a length of let's say 256 characters and make sure that this is not now also. So lastly, we need a file key. A file key, which is going to be just a text view. And we'll name it file key and make sure it's not now. So this file key is for when we are retrieving the file from S3. So you can see that we have this PDF thing, right? So this PDF maps to a resource within the S3 bucket. So we can use this file key to actually ID the file within S3. So after we have checked, let's also create a messages. So we can see that each message, let's say I come down to our var cell docs. We can see that each message here will be saved to a database. So we can also create that table. So let's export a cons messages. It's going to be a Postgres table. Let's name it messages within the database. And then for the columns, we'll have an ID, which will be a serial of ID and the sentence primary key. Okay, then we have chat ID. So each message will belong to a chat. So this is how we form the onetomany relations. So this is going to be an integer. So this is from pgcore itself. We'll name it chat ID. And then it's going to have dot references. So this is how we use the references variable within visual RM. So what is the reference? It's taking a callback function and it just returns the chat's ID. So this is how we make sure that this chat ID actually does a foreign key reference back to this chats.id. Okay, and make sure that it's not now also. And then we have a content. So this is a message content. Let's name it as text. Name it content and make sure that it's not now. Okay, then two more things. We need the created ad. So it's going to be the same up here. So it's going to be a timestamp, not now, and also defaults to the current timestamp. And lastly, we need a row. So this row can either be a user or a system. So we want to create a enum for that. So to create enum, we actually come up here and do export cons. User system enum. So this can be a pg enum from pgcore itself. Right? So we're going to name it user underscore system dash enum. So this is going to be the mapping within the database itself. And here we can pass in an array of what we want the enum to be. So this will log in the field, so that it can either be from a system or from the user. So if the row here is a system, that means that this message is being sent by GPT. If the row here is user, right? Then we know it's a user message. So we can just make this type more type safe by creating an enum within it. So for this row, you'll just be a user system enum. Name it row, right? And then we'll set it as not now. Okay. You can also set a default value, right? We can see that it gives us the intellisense to either system or user. Okay. So now that we have all this, we can just save the file. Okay. So now that we have saved the file, how do we actually make sure that this schema here is pushed up to the neon database, right? So for that, we actually need another tool from Drizzle. It's called Drizzle kit, right? So there's two things. There's two parts to Drizzle, right? There's the Drizzle ORM package itself. This Drizzle ORM is what is interacting with our database, but there's also a Drizzle kit, a package. This Drizzle kit provides us with utility functions to create migrations and to make sure that all our database is synced up with this schema here. Okay. So with that, let's actually install the Drizzle kit. So npm install drizzlekit. So let's install that. So this Drizzle kit will allow us to push it up. So one more thing that we need is that in our folder here, in our root folder, let us actually create that. Actually, let's save this schema first. And then in our root folder, let's create a drizzle.config.ts. So this config.ts is going to hold the Drizzle configuration on how we want to tell Drizzle where our schema file lives in. So the first thing here is, let's import a type called from Drizzle kit itself. So this type will import as config. So it gives us some type annotations for the configuration object. Okay. Okay. Then after here, we need to export a default configuration object. And we can see that satisfy config, right? So this object makes sure that it will satisfy config. And if we press control space, we get all these different type annotations as to what configurations are available. So the first thing we need is the driver. The driver is going to be PG Postgres, right? The second thing here is we need the schema. So this variable will tell this Drizzle kit where the schema actually lives in. So that whenever we push our schema, right? So eventually we can run a command within our terminal called mpx Drizzlekitpushpg. So this will take a look at our schema and then make sure that our database in neon is synced up with our schema. So to tell it the schema, let us actually do the slash source. So it's taking from the current path itself. So it's going to go into our source folder, come to the source folder, come to our lib folder into db to schema.ts. So make sure that whatever file here matches your file structure. So it will be under slash source lib slash db slash schema dot ts. And then lastly, we need the db credentials. We need these db credentials, right? We have a connection screen, a connection string, and this one we want to get it from process.env dot database URL. Okay, so Next.js actually doesn't provide this env here right now because right now, I want to observe that you see inside this source, all the files within this source folder will have access to the env variable. However, any files that's outside this source folder will not have access to the process.env database URL that's defined within.env, right? So to actually load this.env, we actually need to install our package called npm install.env. So with this.env package, we can load the env file into our process.env. So let's just import star as.env from.env. Then we'll call.env.config, right? We'll pass the path to be.env. So busy what this does is you will look at this.env file that lives in the same directory here. So you can see.env. It's going to load all these variables, including this process.database URL. It's going to load it into this file, and then we can access this process.env.database URL. So now that we have completed everything, let's save it. Okay, now we can actually do the pushing of the schema up to the neon database. So I'm going to do, just do mpx drizzlekit, drizzlekit. We can do push and then specify your database. So bpg send for Postgres. So let's press enter and hopefully this will read in our, you see it's able to read in our drizzle config.ts, right? And it's going to try to push. So one more thing I forgot. We actually need to come into our TS config, right? Sorry. So we need to come into our TS config. So we see this target. Instead of ES5, we have to move it to ES6 instead. So let's save it. And with that, let's actually try again. So let me just drizzlekit push and now we can see changes applied. So while it's saying that it has actually pushed our tables, so it has run our commands at create table and it has pushed it up to our neon. So to make sure that it has worked, right, I can actually come out to the terminal and I can do mpx drizzlekit studio. So this will open up in a studio itself. So pg is not imported. So we need to install this pg package also. So npm install pg. So this drizzlekit studio will open up a in browser database client for you. So let's try again. So let's open the studio. And now we can see that the studio is up and running on this port. So let's open this port. Okay, let's open it here. Open in our browser. And we can see that it has a nice interface for us to interact with our user models. So if you come down here, we can see that the chats and messages table has been created. So these chats and messages, we can see that the schema, this chat ID content created at is coming from our schema.ts. So we have made sure that all our schema has been properly migrated up to the neon database. So that's perfect. Yes, everything's up and running and we are good to go. So let me just close this drizzle studio and then we can continue working on the other parts. Okay, so that's excellent. So now that we have set up drizzle in our database, let's actually create the file upload component that we see here. This drop PDF function here. So I'm going to explain it a little bit here. Let me just collapse our terminal, clear up everything. So let's actually create a new component, come down to our components. Let's create a new component called file upload.tsx. So this is going to house our file upload component. So I'm going to initialize it by doing TSRAFCE. So this snippet is from extension. So let me search out the extension. I think it's called ES7, EN7 snippets or something, ES7 React Snippets. ES7 React Redux Snippets. So this snippet give us the ability to just type in TSRAFCE and generate the React component for us. Okay, so for this file upload here, isn't it not going to take in any props, right? And this is going to be a client component. So let's put this use client. So if you're not sure, so this for any component that requires interactivity, like unclick function on a button, or let's say you're trying to drag in a file that basically renders on the client and then it requires use state. So let's say if you're using a component that requires the use state function from React, then we have to convert this into a client component. So that this component will be rendered on the client. So to actually create this styling, so we need to install a library called npm install react dropzone. So this will create that file upload drop utility for us. So with that dropzone installed, let's actually import it. So import use dropzone from reactdropzone. Okay, so let's actually create a styling for this, right? So for this, I'm going to just return a normal div with a class name of padding of two, background of white and roundedxl. So let me save it first and let's actually import the component into our page. So come back to app.tsx. So whenever we see this file upload, I'm just going to import the file upload, sorry, upload file, is it file upload? Okay, it's file upload, so import it from our components. So let's save it and now we can see that we have a component that's showing up here. So right now it's this bgwhite that is showing. So within this div, let's actually install it properly. Okay, so we'll have another div. Within this div, we can actually store our file input. So we'll have an input variable here, input component. And then actually let us also destructor a few things from the reactdropzone so that we can properly style it. So we actually need to destructor a few things from usedropzone itself by calling it. So why is it going to return? It's going to return us with two things, getrootprops and also getinputprops. So these two props, we have to pass into our input field and also our div field such that you have the proper props to handle the file upload. Okay, so within this inner div, so we have this inner div, let's pass in the dot dot dot, getrootprops, just invoke it. And for this input, we assume you pass in dot dot dot, getinputprops, invoke it, and save it. So right now it doesn't show up yet, but let me try pressing on it. Okay, it doesn't show up. So for this div, for this getrootprops, let's pass in an object. We can pass in more attributes. Let's say class name. So we can properly style this div properly. So let's give you a border of a dash. So it has the dash border look, border dash two, rounded XL, cursor, pointer. That's why we hover over it, right? bg agree of 50, padding one of eight. Let's give you a flex, justify center, items, items dash center. And then let's give you a flex call. So let's save it. And now we have this nice input box here. So when we hover over it, you can see it turns our cursor out, our cursor into this cursor pointer. And if you click on it by right, by right it should show this input view. Okay, so it opens up our file explorer, which is good. Okay, so then underneath the input here, we want to show a thing here. So let us create a fragment and let us upload a inbox. So this inbox icon from Lucid React, let's give you a style of width of 10, height of 10, text blue of 500. Text blue of 500, and below the inbox, let's just have a paragraph tag that says drop PDF here. Let's give you a class name of margin top of two, text of small and text dash late dash 400. So if we save it, now we got this drop PDF here showing up properly. Okay, so that's good, that's good. So now let us actually add the file upload feature. So for this use drop zone, for this use drop zone, right, we can pass in an object. So we can pass in some parameters we need to tell how to behave. So we can accept. So we're asking what type of files do you want to accept from the users? Right, so it's going to accept an application slash PDF. Right, it's going to accept an array, which is only says p dot PDF. So this is the syntax to make sure that users can only upload dot PDF files. Okay, and then we're going to pass in max files of one. So they can only upload one file, one file, a maximum. And then we can pass in a callback, right? So we can pass in a on drop. So whenever they drop a file or when they pass in a file, we can actually get the accepted files. And let us for now, let's just console dot lock accepted files. So let me save it. So let me open, just expand it a little bit bigger. So I'm going to open up my console here. Right, so open up my console. So let me just clear that out. So let's say now we drop, press drop PDF. And let's drop, so you can see that only PDF files are allowed. So I'm going to edit this. And whenever we drop it, we can see now that we have this array of files. So this is what the accepted files, a variable shows. So it's going to be an array of files. So the file that we want is living in the first index and just contains all the information like the name, the path, the size of it, and so the type. So later we'll be using this file object to upload this file onto our AWS S3. All right, so now that we have the files set up, let's actually upload it to AWS S3. So to set up the AWS S3 account, come to your, just search AWS, right? And then just go into Amazon web service, right? So cloud computing service and you want to create an account and log into the console dashboard. So just press sign in the console or sign up for the console if you haven't. So you can sign up with email, right? So after you have signed in, you have to log in as a root user and you come back to the console home. So come down to the search bar and just search for S3. So S3 stands for simple storage service. So SSS S3. So click into it. And what we want to do is create a new bucket. Okay, so come down here and just press create bucket. So for the bucket name, just name it whatever you want, but it has to be unique globally. So let's just name it chatpgfyoutube. Okay, the region, choose one that is closest to you and make sure you remember which region you chose. So for me, I'm going to choose Singapore here, AP South is one. So remember this AP South is one. And then object ownership, just choose ACS, ACL disabled. Come down to choose, uncheck this. So we don't want to block all public access. So uncheck it and come down here, just acknowledge. Bucket version name just disabled and then everything else can be disabled. Yeah, so advanced setting just leave it as blank, as default. And so everything just leave it as default. So now it successfully created a bucket. So for now, we still need to change something. So we need to actually make all the objects to be public. So come to chatpgfyoutube, permissions, not probabilities, permissions, block public access. So right now it's off, right? Under this bucket policy, I need to press edit. So this is a JSON configuration to make sure that, is to tell people who can access the files that start in this bucket. All right, so for this policy, you want to make sure that everyone can edit, not edit, but everyone can access this. So just set up an object in here. So they'll have a version, right, this version will be 20121017, okay? And then for the statesman, statesman, right? This will be an array, right? And the first item in the array will be another object, right? So this object will have SID of public read get object. Okay, then you have an effect of allow. They have a principle of star. And then we have an action of S3, get object. So make sure you got the spelling and all the capitalization all correct. And lastly, we have this resource. This resource will have ARN colon EWS. ARN colon S3, then three colons. Then you have to enter the name of your bucket. So this is chat.pdfyoutube slash star. Okay, so with that, make sure that everything looks correct. So this has to be resource. Okay, so after you have saved that, just come down here, scroll down and press save changes. Okay, so now our bucket policy has been updated. So we have a bucket policy. Come down to course. So this course object is important so that we can actually upload files from our local host or from our vessel URL. So this course, we have to go and edit it. And so this another JSON object to tell EWS who can actually upload files. So this is going to be an array actually. So it's going to be an array. We need the first item in the array, right? Let us put in allowed headers. This is going to be an array. And let's put star. So we can allow all the headers. Then we need the allowed methods to be an array of put, post, delete, and lastly get. Okay, so let's style this properly. And then under the allowed methods, we need allowed origins. So this is to make sure that we can allow different URLs to upload to the EWS S3. So let's put star so that all the URLs is able to upload. And then we have lastly expose headers. Just leave it as an empty array. So this to make sure that, okay, so this get has this code. So after saving this, let's press Save Changes. So this course is important so that we can properly allow our website to actually upload files to EWS S3. Okay, so now if we come back to our buckets, okay. So now that we have set up EWS S3, let's actually create a function that accepts the local file input and uploads to S3 itself. Okay, so let me expand this back up here. So come down to your folder and let's create, under your lib, let's create a new S3.ts. So this S3.ts is going to contain the function to actually load in the S3 configuration, all right? So first we need to install the actual S3 package. So for that will be NPM install EWS SDK. So we make sure that we can interact with the EWS S3 buckets. So import EWS from EWS SDK, okay. Then we want to actually just initialize the S3 bucket, right? To initialize S3 function itself. So let's export async function, call upload to S3. Okay, so this upload actually will accept a file of this file input. So this is a standard web API file type, right? So we can accept this file. So later we pass in this file. So right now if you come to file upload, we can see that this accept files is an array of file. So we eventually call this upload to S3 on this accepted file's input, okay. So what we're going to do is we're going to put it in the try catch block, okay. So first we can initialize AWS.config.update, right? We need to pass in two things. We need to access key id, access. For the update we need to access key id, right? And also we need a secret access key, right? So how do we actually get this AWS secret access key and access key id? So come back to your S3 console, right? Come back to your console, right? Come up to services, right? You need to search for something called IAM. So this stands for Identity and Access Management. So come under the IAM service. So this is separate from S3 service that we have export within the AWS console. All right. So come down to the IAM console. Now we need to add a new user. So this user is going to give us that access to actually access the S3 bucket. So then we can create a key pair for this user and the key pair will be what is used for this access key id and secret access key, all right. So come to the sidebar and click on users, right? Right now we can see that we can create a new user. So just press create user and name it whatever you want. You can just chat bdfyoutubes3, right? So this user will be able to access the S3 bucket, right? So we don't want to provide user access because we are just trying to provide the console access to a, just to get the key value. We're not trying to give the access to a person. So uncheck it, then press on next. Then just have to attach policies directly. So search for S3 and basically want to give it Amazon S3 full access, right? Amazon actually full access. So check on that box. Then lastly, just press next. Okay, so now that we have granted the full access, we can create the user. So after created the user, come into the user itself and now we can access the key pairs. So come down to our security credentials and let us actually do access key. So create access key. So I want you to choose your, just choose local code for the use case, right? And then press understand the confirmation and press next. So then you can just give a description tag if you want. In case you can just leave it blank and create access keys. So right now we can see that we can just press show. So these are two things are what is needed for the S3 access key ID. So come down to your.env. Let's actually paste it in. So we'll create a new section called AWS S3. Okay, so we need the AWS S3. Let us do next public. Next public AWS S3. Sorry, we just put AWS, just name it over one. Next public S3 access key ID. So I'm gonna paste in this access key ID here. Okay, and then for the next line, let's name it next underscore public underscore S3 underscore secret access key. Right, then paste it in here. So the reason why it has to be prefaced with next public is because we'll be accessing these environment variables from our client. Right, because when we drop the PDF, we'll be uploading the PDF directly from the next S3 up to S3. Therefore, we need these two variables to be public to our client component. And so after we have done that, we can just come back to our code here. So save the env. And so we need these two variables, right? So just copy these two variables and make sure that you paste it in correctly. So for the access key ID, make sure it's next public S3 access key ID. And for the secret access key, let's copy this in here also. So then paste it here. So this is a secret access key. So make sure the variables match and make sure you have it properly configured within the.env. So let's save it. So after configuring the aws object, now we can actually get the S3 object. So const S3 equals to new aws new aws.s3. Okay, and then under here, we can actually pass in this params object. These params allow us to configure our bucket. Right, so remember the bucket name that we have created? We can just store this in a variable itself. So let me just copy this and let us create a new env variable. So next, public S3 bucket, bucket name. So just name it as whatever you have created in the S3 console. In this case, it would be, for me, it's chat.spdfyoutube, right? So let me save that. Then in here, I can just access it. So next public S3 bucket name, make sure that it matches. So I'll copy it just in case. Okay, so after configuring the params, you need to pass in, under the params, pass in the region, right? So this region, for me, is apsoutheast1. So remember the region that you created the bucket in. So just put it in here, this region configuration. Okay, now lastly, we want to define, we can actually upload it. So we can do cons upload equals to S3 dot puts object. Okay, this put object take in a params. So let's actually define the params here. Cons params is going to be an object of the bucket. So the bucket will be the S3 bucket name. And then we need the key. So this key will be the name of the file. So this key will be uniquely identified, fireable to the file, right? So we have this file key here. And then lastly, we have a body, right? With this actual file that is passed into this function. So for this key variable, let's actually create a file key variable, right? So that let's name it uploads slash plus dates dot now dot to string. So this to make sure that the file key is uniquely ID. Lastly, we'll do file dot name dot replace, replaced a space with an empty with a hyphen. So this file key, basically we want to upload to an uploads folder within AWS S3. So we can organize it properly. And then we just want to append the date dot now to make sure that it's properly ID, uniquely identified. And then we'll just replace the file name. If there's any blank space, we just replace it with a hyphen. And then this file key we can use instead of this file name directly. So just put in the file key. Okay, that's perfect. So now we can actually upload these params, right? So after these params, we can do dot. So right now these params is complaining because the bucket could be undefined. So we are ensured that this exists. So we'll just put a bang. So to reassure that AWS S3 that the bucket name will actually be defined. Okay, so then after we put objects with the params, let's do on. We can do a HTTP upload progress, right? Then we can access a event. So whenever as it's uploading, let's say it's a big cloud. Let's say you're uploading like 10 megabytes of PDF, right? As it is uploading, uploaded to AWS S3, this callback function will be called. And then you're able to monitor the process and it's able to give us back like the progress. Then you're able to create a UI to create a progress bar to show that the file is being uploaded to S3. So for now, let's just do console.log uploading to S3, dot, dot, dot. And let us just do parse int. So we can actually get a progress by doing, let's just do events.loaded, right? Divided event.loaded times 100, divided by events.total, right? And then this parse int, we can actually call the, dot, sorry, call the dot, dot to string, sorry, dot to string. Sorry, this should be here. Okay, so we basically, let me save this file so that it's easier to see. So we'll take the env.loaded times 100% so that we can get it in terms of the percentage divided by the total file size. We'll convert it to to string so that we can properly parse it as an integer. So we don't want to have floats. Then lastly, we can just show the percentage sign. So we console.log out this entire percentage string. We can see in the console later on. Then finally, after this upload, let's just do dot promise, right? So we can actually just convert it to a promise and we can just do, this promise will allow us to convert this whole upload process into a promise. Then we can just do await upload dot then. So we can just take the data. So this callback function will be called whenever the upload is completed. So when it's completed, we're just going to just say console.log success, success, fully uploaded to S3, exclamation mark. And there's also console.log out the file key itself. Then we can just do, after that, we can just do, all right, then finally, under this await, we can just return promise dot resolve. So we want to resolve this promise, right? Because this is the async function, right? So after we've uploaded, we resolve the promise. And we just want to return two things. We want to return the actual file key itself and return the file name, which is file dot name. So make sure we return the file key and file name. So we'll be using these two parameters to save it to our database later. So let's save this function, okay? And let's come down here and let's create one more utility function. So this is the last function that's going to be created in this file. So we're going to export function, get S3 URL. So this function is going to take in a file key of string and basically return us with a publicly accessible S3 URL so that we're able to embed the PDF within our chat screen later. So just do cons URL equals to https colon slash slash, right? Put in your process dot env dot next underscore public underscore S3 bucket name, right? And then here we can just do dot S3 dot ap south east one dot amazon aws dot com slash file key. So that's actually a special formatting for the AWS. So the AWS will always live on the bucket name dot S3 dot region. So this is what your AWS region is. So it might be different from mine. And then it will be lived at Amazon AWS and you're able to access it to the file key here. And then we just want to return this URL. So this is a utility function so that we can actually access the S3 URL just from the file key itself. Remember this file key is actually created here at this line here. So now that we save it, let's actually try it out. So come back to your file upload component, right? So whenever we actually, we don't do just console dot log, right? We actually want to upload to S3 itself. So to actually create a function, let us just get the file. So cons file equals to accepted files index zero. Okay, I'm gonna take the first file and then we can just first check. So if file dot size is bigger than 10 times 1024 times 1024. So if this is bigger than 10 megabytes, we don't need to upload to S3, right? This is bigger than 10 MB. So let's just, let's just show an error. So let's just alert, please upload a smaller file than this return. Okay, but if it is smaller than 10 MB, then let's actually create and upload the Amazon S3 file. So let's do cons data equals to await upload to S3. So we import it from our lib. So because we're using await, let's actually also convert it into an async function. Okay, async function. Although, await upload to S3, I will pass in the file, right? So this file comes from the accepted files, and then you will pass into our upload file function that we've created in S3.ts. And then this data, we can see that it will return us with the file key and the file name. Okay, so this is if it works, right? If it doesn't work, right, let's actually put it into a try catch block. So if there's any error, let's just do console.lock error. Okay, so await upload to S3, and then let's just do console.lock data. So let's try it out. So I'm going to save it. Okay, now I'll move the console here. And let's actually try uploading, okay? So I'm going to open up my console within it. Sorry, it's not that very responsive, but it's okay. Just for this video, you'll be fine. So let me just drop a PDF here. So let me just, so let's say we upload these eight runtime docs. If I press on it, we can see that uploading to S3, 100%. So it says that successfully uploaded to S3 and we get back the file key. So we can see the file key is created by having this uploads folder and then the random time followed by the actual name of the file.pdf, right? And we get the file name also. So if you come back to our S3, so come back to your S3 bucket within AWS console, right? Access your chat.pdfyoutube bucket. We're able to see now that this is uploads folder created. And we can see the PDF that is being accessed here, right? So we can see that now the function works and we are able to successfully upload files onto AWS S3. So that's excellent. Okay, so now that we have gotten to a decent point within the project, now I want to explain to you what exactly is retrieval augmented generation and how we can actually get the PDF to be fed into a chat.gbt so that it's able to give us that result such that chat.gbt is able to chat with us with the context of the document, right? So the first thing you have to understand here is two things. One is what is a vector and embeddings, okay? So a vector is just an array of numbers, right? A vector is just like an arrow, right? So a vector is an arrow. So in this case, this arrow is a twodimensional vector, meaning that it has an xcoordinate and a ycoordinate. So here we can see that this xcoordinate is the length here and the ycoordinate is the height, right? So in this case, this vector can be actually represented as an array of let's say two numbers of let's say one and two. So one being the width and two being the height. So in the case just for proportion, this looks more like two and one. So it will have a length of two and a height of one. So this vector can be represented in an array of two and one. But what if we have a vector of three dimension? Imagine you have an arrow that's pointing out towards me. I mean, obviously, because we are on the screen, we can represent that. But to represent a 3D vector, we can just have three dimensions, right? x, y, and z components. So maybe it can be one, two, and four, right? So this will be the x component, this two is the y component, and this four is the z component, which means how much is pointing towards me, towards the screen, right? So this is what vectors are, right? So why is this vector important? So embeddings are very similar to vectors, right? So how this is going to work is we have a function. So this function is able to take in a piece of text, a piece of string, right? So let's say we have a string of I like cats, all right? And let's say we take in another string here. Let's say I say cats are the feline species. And then lastly, I have another text that says dogs are upper zits of cats, all right? We can see that all these three texts, all three strings are kind of similar in the sense that they're all talking about related to cats. But how do we actually properly define which text are most similar to each other? So this is where the function comes in. There's actually a function within AI that allows you to convert this piece of text into a vector, right? Meaning that we have a function, let's call it get embeddings, right? This will take in a text, a piece of string. And the input of this string, and it will output lists an array of vectors. So this array is going to be like a multidimension vector. So it's a vector in the dimension of let's say up to thousands of dimensions. So it's not just one, two dimensions, or even three dimensions. It could be a vector in 1,536 dimensions, right? So the bigger the dimension, the more information it can actually represent, right? So this vector, so let's just take, for example, this I like cats. Let's say that this embedding creates a vector of this direction, right? Just for the sake of argument, right? So this I like cats, right? So if we embedd it, we get a vector of this shape, right? So the vector will actually represent the semantic meaning of the sentence itself, right? So that's what is amazing about it. So if you take the second sentence and we embed it, so we convert it into a vector, maybe this function will return us with a vector of this one. We can see that it's kind of similar because it's pointing in the direction, it's a similar direction. And then let's say if we look at this, dogs are composed of cats. Obviously, this is a little more different, right? So actually, maybe a better example will be, let's say we talk about our React is a JS framework, right? So if you embed this string into a vector, it might look something like this, right? So we can see that the direction of the arrow or the vector is actually dependent on the meaning of the actual sentence, right? So how they actually create the embedding will be using opening eye to create those embeddings for us. So why is this useful? Now that we have these vectors, what we can do is, let's say now I'm trying to ask a question. So I'm going to ask a question regarding like, what are cats, right? I'm going to basically create this vector. I'm going to create this query. So this is going to be a query itself. I'm going to create this query into a vector in itself. So maybe this vector will turn out something like this because it's similar to the cats, right? It has the semantic similarity to cats, right? So it will obviously be very similar to these two vectors. Then using mathematical notation, using math, we can actually find the cosine distance, right? So this cosine similarity, we can see is a measure of similarity between two nonzero vectors defined in their product space, meaning that there's actually a method to find how similar two vectors are. So if we actually basically look through all the vectors and find out which one is the most similar. In this case, the most similar vector will be this second sentence. So using pure mathematics and vectors, we're able to get this piece of text and see that this text will obviously will most likely contain the answer to my query just by how similar their vector representations are. So with this vector that is after we found the most similar vector, we can actually convert this vector back into the text, right? So we store this text in the metadata of this vector, right? So this vector will contain a few things. It will contain the embedding, right? It's going to be an array of numbers, right? So however dimension this is, might be in the thousands. And it also contains a metadata. So this metadata will contain the actual text content, right? This text content will be whatever you have here. I like cats. Cats. Let me just save it here. So I hope that this makes a little sense, right? What we are trying to do here. So we can see that each vector contains the embeddings itself, which is the array of numbers. And it can also contain metadata. So after we have found the most similar vector, we can extract out the text content. And then with this text content, we can actually fit the content into OpenAI so that it's able to generate context for us. So let's see how this ties into the PDF, a function that I'm talking about. So let me just explain this so that we have a more space to explain how this embedding works. All right. So imagine you have a PDF here, right? So let me just expand this a little bit bigger so that you will see. So let me just expand it more. Okay. Imagine you have this PDF. It's going to be a page. So there could be multiple pages to the PDF, right? So let's just take, for example, we have a single page, and there may be a paragraph, multiple paragraphs. So let me just align it to the top, and let's start typing. So imagine we have this one paragraph, then we have another paragraph, right? Then lastly, we have the last paragraph that is a bit longer. Okay. So within this page, we have these three paragraphs. So what the vector embedding is going to do is, what our backend is going to do is, we're going to take each page within the document. We're going to segment it into internal documents. So when we talk about documents right now, we're not talking about PDF documents. We're talking about a segment of the PDF, right? So this paragraph could be one document by itself. This paragraph could be another document by itself, and this paragraph might be another document. So we're splitting the PDF into small chunks of documents. So each chunk will contain maybe like two or three sentences, one paragraph, right? So now that we have segmented into a few documents, so let me just press it out here. Document, doc1, doc2, doc3. So we're going to take in the PDF, we're going to segment it into a lot of documents. So each document will contain like the metadata, so it could be the page content itself, right? So this page content will be whatever this paragraph shows, right? Then what we're going to do is, the second step is to convert each document here into a vector. So remember, we have a function in OpenAI that allows us to take a document and convert it into a vector itself. So this will then become a vector. So it's going to be a vector embedding. So now that we have converted all our docs, so there could be maybe 20, 30 documents within one PDF, depends on how we segment it. So then we have 20 vector embeddings here. Then what we're going to do with these vector embeddings is we're going to store all these individual vectors into a vector database. And that's exactly where PineconeDB comes in. So PineconeDB is a vector database exactly for longterm memory for AI, you see? So this is what PineconeDB is for, is to store vector embeddings. So all of this will then go inside of PineconeDB. So that's it. So what happens now when we actually want to do this? When we actually want to search for, when we type in the chatbot, how does he actually get access to the document? So imagine now I come back to my interface and I search for, let's say, where did he intern at? So imagine this is the document about my resume. And maybe imagine this first paragraph was talking about something about I interned at Reluvate company here. So what it's going to do is it's going to vectorize, it's going to embed this search query, it's going to turn it into a vector. So this is going to turn into another vector embedding. Then it's going to go through all the current vectors within my PineconeDB. It's going to look for the vector that's more similar. So in this case, the vector that's more similar will contain the paragraph that says I interned at Reluvate because they are similar within Semantic, in terms of the meaning. So let's say this vector embedding, the third vector embedding contains the paragraph that says this. So it contains the original paragraph. So what it's going to do is it's going to pull out this original vector. Then it's going to take out the metadata from it. It's going to extract out the metadata. Then we're going to feed in this metadata into chatbot so that we can create a prompt, so that we can then ask chatbot to take in context of the metadata and also the question, and then it can generate the answer based on these vectors. So these are very high overview on how we do it. So I hope you have a better understanding of how retrieval augmented generation actually works. So let me just break it down once again, two steps, so that we can actually code it out. So the first step is actually obviously to obtain the PDF. The second step is to split and segment the PDF into smaller documents. Then the third step is to take the documents and then factorize and embed individual documents. So after embedding different documents, we can then store the embeddings, store the vectors into Pinecone DB. Then lastly, whenever we want to search, so when we're trying to search, we're trying to check with the chatbot, we can first embed the query, so turn it into a vector. Then we're going to query the Pinecone DB for similar vectors. Then we're going to extract out the metadata of the similar vectors. And then finally, after we extract out metadata, we can then feed metadata into the OpenAI prompt to generate the proper output with context of the PDF. So that's the main step for it. So where does Lang chain actually comes in? The Lang chain will actually help us with the splitting and the segmenting of the PDF. So I'll show you how to actually code the app in the code very, very soon. Okay, so before we actually set up the Pinecone and make sure that we can embed all the documents, let's actually make sure that we can send the file name and the file key back to our backend whenever we upload to S3. So underneath here, I'm going to go to your Explorer, come down to your app, create a new folder called API. Under here, create a folder called createchat. And here we can create a root.ts. So this is a special root.ts is a special file name within the app router. So that whenever we can see that there's this file structure of slash API slash createchat, this will map to the rest endpoint for this endpoint. So this will actually map to slash API slash createchat. Then in the front end, we can hit this endpoint and this function here will be called. So let's export an async function called post. Right, so we are setting a post endpoint here. So whenever they hit a post endpoint to this endpoint here, this code here will run. Okay, so for now, we're going to just take in the request to be a request object and response to be a response object. Response, okay, that's good. So I'm going to try catch block. So if there's any error, let's just console dot error, and then we'll return the next response dot JSON error, internal server error, and let's pass in status of 500. Let's save it, okay. So for now, we're going to get the body from a weight request dot JSON. So we want to get the request body. And for now, I'm going to expect there's two things from the body itself. So we're going to expect the file key and the file name, okay. So this file key and the file name is going to come from this data. So remember, after we upload to S3, the data that it returns will be two things, file key and file name. We're going to take these two variables and then send a request back to our backend here so that we can actually do the pine cone vector embedding stuff. Okay, so to do the hitting of the API, I'm using React query to manage that. So at install and PM install at 10 stack slash React dash query. So this React query library makes it very easy to handle mutations and data querying from local to server state, server endpoints basically. Okay, so after we have done that, we need to come back to our folder. And let's actually wrap our entire app in a React query provider. So come on to your components and let's create a provider. So we'll do tsrefc to create a snippet. So this will be a client component. And what we want to do is import a few things from at 10 stack slash React query. So we need the query client provider and also the query client itself. So we'll initialize cons query client to be a new, sorry, cons query client equals to new query client. And then for this props, we'll take in the React children. So this is going to wrap our entire application. So we'll take in the children to be a React dot React node. Then we can destructure the children from the props itself. Okay, then here we can basically wrap our query client provider, passing our client here. And then we'll just wrap the children in this provider. Save it. Then now let's actually wrap our layout. So come back to our layout.tsx. So inside this click provider, okay, within this click provider, let's actually wrap our providers. So providers. Okay, let's wrap the HTML tags. Okay, so now that we have wrapped this entire provider, we can actually start using React query. So the reason why we actually have to wrap these providers is that, because React query does a lot of caching, right? So imagine we have one endpoint that gives us back some data. So imagine we have these slash API says messages data. Whenever we hit this endpoint, it returns us with a list of messages from the database. And then we navigate to another page and it makes the exact same call to this endpoint. React query will be able to detect that, oh, look, you're making the same call to the endpoint, but I did have the data from a few seconds ago. So instead of making that call back to the backend, which might waste some resources, why not I just cache the data and then return you immediately? So then with this, it creates a more efficient workflow when you're fetching data from the server. And that's why we need this provider, such that every component within our application has access to the data cache. Okay, so now we have this React query. Let's actually create the function to call the backend API to actually create the chat room. Okay, so come back to your, what's this called? A file upload component here, file upload here. So above these use dropdown, let's actually create a mutation. So mutation is just a function that allows you to hit the backend API. So cons mutate, so actually just cons, let's destructure from use mutate mutation from React query, right? We can see that it actually returns us with a few things, returns us with a lot of things like each loading state, error state, even the mutate. So this function will be called. So for this use mutation, we'll pass in a few things. We'll pass in the query key. Sorry, not query key, not query key. It's just a directly mutation function. So this mutation function will be an async function, right? So let's actually install axios, because we need axios to actually make that API call to the backend. So npm install axios, so do cons response equals to awaits axios. So import axios, import axios from axios. Axios.post, we want to hit a slash API slash create chat, right? So this create chat will hit this endpoint here. And then we want to pass in two things. We want to pass in the file key and the file name from the body, right? So how do we get this, we can get it by destructuring here from file key and file name. So this will be destructured from here, file key, which is a string, and file name, which is also a string. Save this. So later on, we'll pass this file key and file name into this mutate function, which will be, we can access it here. So then we'll pass in file key and file name. Okay, awesome. Then after we have made that call, we can just return response.data. Okay, so how do we actually call this mutate function, right? So this mutate, we can just come down here. So after we have uploaded to S3, right, we get this data, we get a check if not data.fileKey or not data.fileName. So if for some reason there's no file key and file name, we know that something has went wrong. So let's actually alert something went wrong and return. If not, we can actually call the mutate function. So you see this mutate function comes from this top here, right? And then we define this mutate function within the property. This will take in two things, file key and file name. And right now, if I come down to file, mutate, right, and I pass in the object, we can see that we need this file key and file name. So we can just pass in this data, because this data is ensured to have the file key and file name. So we can see that it matches the data type here, matches whatever we expect from this mutation function. Then this data, this data file key and file name will be passed up to our backend endpoint. Okay, so then for the mutate, the second object will contain a few things, a few callbacks for onSuccess. So it gives us this onSuccess. So if it's successful, right, we get back the data from the backend endpoint. So let's console.log data. In case there's any error, let's just take the error. Let's just console.log error. So let me just add one more toast thing. So I'm going to add this library called reacthottoast. So it's just for nice alerts, right? So if you come back into this library, we can see that we can have this nice toast alert to notify whenever something is happening, right? So let's install that library. So come down here and do npm install, reacthottoast, okay? So to use this reacthottoast, we need to come down back to our layout.tsx. Import, we need to import this toaster from reacthottoast. What do we need to import? We need to import the toaster component. Then underneath the HTML, let's just import the toaster here. So this is why it's actually used to actually create the alerts. So save it, come down here. So we will just replace all these alerts with a toast. So we can see that this toast, we can import from reacthottoast, right? toast.error, file to large, okay? So let's save it. Okay, so come back to your layout. So this toaster should be within the HTML tag. So make sure it's within the HTML tag. So now let's save this and then let's refresh the page and hopefully I'll take it back. Okay, that's good. So we can do toast.error. So this will create a nice popup notification, right? Then we do have this alert. Then for this alert here, we can also do toast.error, something went wrong. Return this and lastly here, we can just toast.error, error creating chat. Okay, so let's save this and now everything looks perfect. So basically what will happen is whenever we drop the file, it's going to upload to S3, right? So whenever we upload a file, it's going to call this upload to S3 function, right? It returns us with the file key and the file name. Then we'll basically call this mutate passing in the file key and file name. This mutate will then take the file key and file name and pass it back to our endpoint create chat. So by right now, if we upload a file, it will then be able to console.log out the file key and the file name. So let me save this and let's actually try it out. So this will obviously be logged out in the server because this is running on the backend. So it will work on the terminal. So let's try it out. So I'm going to press job PDF and let me just upload these 8 runtime docs. So if I press this by right here, we can see that the create chat is being run and then hopefully it's able to tell us that. Okay, so now right now there's an error. Okay, so obviously we didn't return anything from this. That's for a string error. But right now we can see that it's working. We can see that this file key and the file name is being logged out. So this is the file key and this is the file name and it's being logged out within the backend. So we know that this is working. So one more thing here for the file upload, right? So other than the mutate function, remember it also gives us that it's loading state, right? For this is loading state, we can actually use that to display a loading component while it's uploading. So I'm going to just come down to our file upload here. I'm going to define one more state. I'm going to call it uploading, then set uploading. So it's going to be a new state, React.useState. So by default, it's going to be false. Then whenever we actually upload a file here, whenever we upload a file on drop, we're going to first do set uploading to be true. Then underneath here, finally. So whether it's failed or whether it succeeded, we're going to set uploading to false. So then we have these two variables, right? We got this is loading and uploading. So if any of these are true, let's display a loading screen. So if you come down here for this input, right? Below the input right now, we are still showing this drop PDF no matter whether it's loading or not. So to create a better experience, let's do if it's uploading or is loading, is loading. So this uploading variable will be true when I'm uploading to S3. And this is loading variable will be true whenever I'm sending the Falcon founding back to my backend. So if any of these are true, I'm going to show a loading state. I'm going to show a loading state, right? But if any of these are, if both of these are false, then it's fine if I show the drop PDF box here. So I'll move this up. Sorry, can I move this up here? Then for this here, I'll go show a React fragment. Okay, so here I can actually show my loading state. For the loading state, let me just show a, sorry, let me just show a loader too from Lucid React. So let me give a class name of height of 10, width of 10. And we'll do text blue of 500. And then finally, animate spin below the loader too. Let me show a P tag that says a spilling T to GPT dot, dot, dot. We'll give you a class name of margin top of two, text SM, text slate of 400. And let's save it. So let's try out right now. So this root.ts, if this is successful, if this is successfully, I'm gonna do a return. Next response dot JSON message of success. So let's save this. And let's see if it works, okay. So if it works here, instead of console logging the data, I'm gonna do toes dot success. I'm gonna do data dot message. So let me just save it. And let's try out. So I'm gonna press drop PDF. I'm gonna drop the same PDF here and see it's loading. Then after it's loading, it's sent to the backend. If it sends to the backend, we can see that a success message pops up. So everything is perfect. Everything is working well. So now we can actually start working on converting the PDF into vector embeddings and storing within Python code. All right. So let's actually now create the Python feature. So come back to your root.ts on the create chat feature. So eventually with this file key and file name, we want to execute the steps, right? So obtain the PDF, split and segment the PDF, factorize and store the vectors into pinecone DB. So first thing here is actually create a account for pinecone. So come down to pinecone DB, then just go to that pinecone DB.io. So you can either log in or just sign up for free. So in this case, I have the account, so I'm gonna log in. Okay. So once you log into the app.pinecone.io, the dashboard, right, come down to create index. So we'll first create an index. So index within pinecone is just like one is a database within like a normal SQL database. So it's a place to store all your different vectors, right? So let me explain this, the terminology within pinecone. So pinecone terms, okay. So we have index. An index is just a database to store all your different vectors, right? Then within index within pinecone, there's nothing called namespace. So a namespace is like a table. So imagine we'll have a different namespace for each PDF. So it's two segment PDF vector spaces. So basically, each PDF will have its own namespace. And then each namespace will contain its own vectors. Then basically, we can query whenever we query, we can pass in a namespace parameter. So then you will only query vectors of query for similar vectors within that specific namespace. Yeah, so that's how it's going to work. So come down to the name. So give it anything you want. I'm going to call it Chats PDF dash YouTube. Then for this index, for the dimensions, put 1536. So it can have up to 1500 dimensions, right? For the magic, leave it in cosine. So we're using cosine similarity for the algorithm comparison, right? So you can then see this distance metric to use for measuring similarity between the vectors. Then just choose starter and then leave everything as default. So it's a threetier index. Just press create index. So in this case, I already have an index, right? And because I'm on the threetier, it only allows me to have one index. But it's okay. You just create an index and you're still able to follow along. So after you have created the index, you should be able to come in and you're able to see different information about it. So in this case, we can see that right now I have 578 vectors within my database, right? So later on, when we start inserting, it will increase also. So now what you need to do is come down to your API key section. Okay, so just create a new, come down here and create a new API key and name it whatever you want. Just name it, I'm going to name it chatPGF YouTube. So create a key. So as it's waiting, we will need two things from it. We need a pinecone environment and we also need a pinecone API key. Okay, so after you created the key, it needs to have a name in YouTube. We need two things. We need the environment, we also need the API key itself. So we need these two things. So come down to your.env, right? We're going to create a new section just for the pinecone. Pinecone. Okay, so we need the pinecone environment. So copy in the environment here, it's the location of where it's located. We also need a pinecone API key. API key. So let me copy in this here. Copy and paste it here. So let's save it. And then we can just quit out of this pinecone console for now. Okay, so come down to your directory. Let's go under your lib folder and let's actually create a pinecone.ts to store all our functions for pinecone, pinecone.ts. Okay, so the first thing here I'm going to do is I'm going to declare a let pinecone to be a pinecone. Actually, let's install the pinecone first, right? So let's install npm install at pinecone databased slash pinecone. So let's install that. So we'll be installing a few things also. Okay, one more thing we need to install is, actually, let's install it as we go as long as we need it. So let's import the pinecone first. pinecone at pinecone databased slash pinecone, right? This pinecone, so here pinecone client, right? So this pinecone variable here will be a type of pinecone client or now. So this is going to be a global variable here. After this, we're going to do, we can export a cons function, a cons get pinecone client equals to it async function, right? So this is going to help us initialize the pinecone. So if not pinecone, so if we have not already set the variable, what we're going to do is we're going to call pinecone equals to new pinecone client, right? Then we'll do await pinecone dot init. So init, we need to initialize it with our API keys, right? So for the environment, we do process dot env dot pinecone environment. So it's what you have copied in from the dot env here, okay? So make sure it exists, and then we also need the API key. So this will be process dot env dot pinecone API key. Make sure it also exists. So put the exclamation mark to ensure that TypeScript that it will always exist. Then in the end, we just want to return the pinecone. Pinecone, excellent. Okay, that's good. So now let's actually create a function to load S3 into pinecone, right? So right now we can see that we have a few things that we need to do. Let me find the proper stuff here. So we got a few steps, right? We need to obtain the PDF, split and segment, vectorize and store it. So we have four steps here. So let's see how we can map it into a function. So we can export an async function called load S3 into pinecone. So this thing is going to take in a file key. It's going to take in a file key which is a string. So this file key will be what is being passed from this root. So let's actually call this function right here already. So let's just do a save this file, and let's call await load S3 into pinecone, and let's pass in the file key. Okay, so what this function is actually going to be the bulk of this project, right? So I'm going to go through it line by line and let's see how it works. So the first step is, number one is obtain the PDF. So how do we actually download the S3 file key into our local directory so that we can read the text from the PDF, right? So within this obtain PDF, we actually need to download and read from PDF. Okay, so to do that, let's actually create a S3 function for this. Come down to your directory, right? Under our lib, right? Instead of this s3.ts, let's create another function called s3server.ts, right? So this will make sure that this file will only run on the server. Okay, so come down to your s3server.ts, let's create a function, export async function, download from s3. Okay, so this download from s3 will obviously take the file key and then download the s3 file onto our local computer. So it's going to take in the file key, which is going to be a string. Okay, so what we're going to do, we're going to first import the AWS from AWS SDK. So it's right similar to what we did just now. So we'll do a try catch block. So if there's any error, let's just console.error, just return now. Okay, so we're going to do aws.config.update. So it's the same thing just now. access key id will be process.env.next underscore public s3 access key id, make sure it exists. Then we'll also need the secrets access key, right? It'll be the same thing here. So after configuring the AWS object, right? So actually we can just copy from s3, right? We don't need to type this out. So the copy up here, copy this. So we're just trying to initialize the s3 bucket here. Okay, now that we have that, let us do cons params equals to the, we need the, what's this called? We need the bucket to be process.env.next public s3 bucket name. And then for the key, for the key, we need a file key, right? So with this params, we can actually obtain the s3 from that. So we do cons object equals to await s3.get object, passing the params. So these params, because it contains the file key, is able to extract out the unique id, unique file from s3. So we'll convert it to a promise, right? So we await the promise. So this object now contains the actual file object. Then all we need to do is, let's import the import FS for file system from FS. So we need this FS to actually download the file to our system. So we just need to do FS.writes file sync, right? Give me a file name, and we'll just do object.body as buffer. Okay, so let's declare this file name. So this file name is where do we want to install it in our local, how do we, where do we want to download it to our local folder, right? So we'll just download it to slash temp slash PDF, dash, let's actually create this into a template string, dates dot now, dot PDF. So it's just going to download it to our temp directory, a temporary folder with a unique PDF with a date dot now, and just name it PDF. So then we'll just download it into our file system. Okay, then we want to return the file name. Okay, so that's all we need to do. So this function will actually take in a file key and just download it to our folder and return the file name to where the folder is located, where the file is actually downloaded to. So let's save this, and let's come back to our pinecone.ts. So with this function, with the S3 function, we can actually use that, right? So let's just do console dot log, downloading S3 into a file system. So we can call cons file name equals to await download from S3 passing the file key. So this is from the S3 server that we are importing, right? Okay, then the second step is to actually get the PDF. So how do we actually get the text from the PDF? So of course the PDF is a dot PDF, right? How do we get all the text format from the PDF itself, right? So what we can do is, let me just, we need to install one other thing. We need to install, let me see. I think we need to install langchain. So the langchain provides us with a nice PDF loader, such as we would convert PDF into text strings. So let's npm install langchain itself. So langchain gives us a lot of utilities to actually do a lot of AI and machine learning utility functions. So what we need from langchain, we need from langchain slash documents underscore loaders, loaders slash FS slash PDF. So this will give us a PDF loader class, right? So this from file system PDF. So this PDF loader will be able to read from the file system and give us the text of that PDF file. So we can just use this. So we'll do cons loader equals to new PDF loader, right? And we pass in the file name that we got back after we've downloaded it here, right? So if something goes wrong, so if not file name, so maybe there's some error downloading here. So if there's no file name, let's just throw a new error saying that we could not download from SG. So that by the time we get to this line, we're guaranteed that there is a file name here. Okay. So what I'm going to do here is I'm going to stop here for now and I'm going to just console dot lock. Let me see. I'm going to get cons pages equals to loader dot load. So we can call, to get the pages, we can do loader dot load. So this loader dot load will then look at this. You will read the buffer content and metadata based on the type and call the parts. So basically what this does is it will return us with all the pages within the PDF, right? So what I'm going to do is I'm going to just return the pages. So we're going to see what happens when we load this in. So I'm going to save it. I'm going to save this file first and then come back to our root, right? Remember that we call this load actually into pine code. So right now, it will return us with a bunch of pages, right? So we can see these pages is a type of document. So there's a lot of documents, right? So let me just await this loader dot load, okay? So then finally here, we can see that it's going to be an array of documents, right? So this is exactly what I mean by splitting and segmenting the PDF. So let me save it, come back to our root, and let's just return the cons pages equals to, let's just console dot lock the pages. So let's see actually what we actually get back here, okay? So I'm going to come back to my file upload. So instead of just a toast or success, also let's do console dot lock data. So just delete this. Okay, so now hopefully if we did everything correctly, we're able to see the documents being loaded from the backend. So clear your output here, okay? Then let's press drop PDF, right? So I'm going to drop the H1 time docs, right? So right now we can see that it's uploaded as three, and then it's going to hit the backend. The backend is going to load the PDF into our file system and then read. Okay, so this is normal to be expected, right? So we actually need one more library for the PDF parts, right? So this internal dependency of the Lang chain PDF loader, right? We need this PDF parts library so that Lang chain is able to properly parse the PDF for us. So let's refresh it and let's actually try again. All right, let me just refresh the page. Hopefully everything is... Okay, so there's one more of this very common error that I actually faced while developing this app is you see this weird stuff here, and eventually you will say, let me look for the error. Okay, reach heap limit allocation field, right? JavaScript heap out of memory. So what I did was I copied this and I searched up stack overflow. So apparently this error is about my Node.js running out of memory trying to run this application, right? We can see that this stack overflow solution is trying to see that a JavaScript heap run out of memory. So what to do is actually we want to allow Node.js to actually use more memory than what is allowed by default. So what you want to do is come down to your package or JSON, right? So whenever you do npm run dev, next dev, right? We can actually set one more thing up here. We can do... Okay, so we do... So here next dev, we do export node underscore options, right? So we want to pass in a variable so we can do here. So what options do we want? We want to do that's just maxed o space size equals to 8192, right? So we're going to basically export a variable, an env variable called max go space size to be 8 gigabytes of RAM. So we allow it to use 8 gigs of space size, and then after that we can run the normal next dev. So this ampersand sign allows you to run two commands in one npm script. Okay, so I think for Windows, if you're using Windows, I think instead of export, it should be set, right? So I think you have to play around to see how you set your environment variables based on your operating system. So for Windows, I think it's set, but for Mac OS and Linux, we could be used export. So let's save this and let's press npm run dev again. And this time we can see that it's exporting this configuration for Node.js to use more a memory before running the actual dev server. So after we have solved that issue, let's actually now try running the server again. So I'm going to refresh the page and hopefully now it will work this time. Okay, so I'm going to collapse this a little bit more. So it's going to compile the page. So let's wait for it to compile. Okay, so now let's actually drop a PDF here. I'm going to do, upload this. I'm going to open up my console. So you can see that it is uploaded to S3 and hopefully now it's going to hit our backend. It's going to download the S3 file into our system. Then it's going to use LinkedIn to read the PDF into text and it will return us with a list of documents. So let's wait for that to actually work. And okay, now it works perfectly. So we can see that it has returned from the backend. So we console out the data. So this data comes from this pages here, look S3 into pinecone. So let's inspect it. So within this, we can see that this pages is an array of 13 objects. So within this object, you can see that there's a page content. And this is exactly what we are looking for. This is the text representation of the PDF. So each object here will have page content and also the metadata. So page content is the actual stuff, but here the metadata is what's interesting. The metadata will give us the location. So which document is, so that's one page. So for now, the default function will basically segment the PDF into singular pages. So you will have 13 pages, therefore segments into 13 objects within the array. So each page will have its own page content and its own page number. So if we come down to the second object here, we can see that the page content is the second page. And the metadata will say that its page number is 2. Okay, so that's perfect. So with that now, we can continue working on the pinecone feature. Okay, so I just want to make sure that everyone's on the same page as what we're actually doing. So now that we understand that this function, this pages variable is going to be a record of page content and also the metadata. So what I'm going to do here is I'm going to define my own custom type. So above here, outside of the function, I'm going to export a type of PDF page. So this PDF page, remember just now we saw in the console, it has a page content, which is a string, and also it has metadata. Within the metadata, I have the location, which contains a page number, which is a number. So this is what I got just by looking into the console and looking at what this console.logs out. Okay, so now that we have that, let's actually just do, let's wrap this here and just do as PDF page here. So then we have properly type it. So right now we can see these pages is now properly a PDF page. So it has the type annotations. Okay, so that's perfect. So now let's actually move on to the next few steps. So okay, so now we actually need to split and segment the PDF, right? So right now, how it does the splitting is that it splits the PDF by pages. So if the PDFs have 13 pages, it's going to split it into 13 pages. But the thing is that's not very ideal for vectorizing because we want each vector to contain only a very small paragraph. So maybe two to three sentences. So we don't want each vector to contain the whole page content. That's not very good for vectorization. So what we're going to do is we're going to use another function from, I think it's from pinecone. So pinecone gives us a function called recursive character text splitter. So it helps us with the text splitting into a smaller paragraph. So we can be doing that right now. So let me just close this terminal and let's continue working on the function. So now we're talking about the second step. So now we have these pages, right? We can move on to a second step. Number two, which is split and segment the PDF into smaller documents. So right now these pages is an array of documents, but the documents are still too big. So within the 13 objects within the array, we want to split it even further. So what we're going to do is we're going to write a function. I'm going to write a function just called a function called async function. I'm going to call it prepare document. All right. This is going to take in a page of PDF page, and then it's going to take in a splitter. Sorry, a splitter. Sorry. So it's going to take in a PDF page, just a PDF page. And what this function does is it takes in a singular page. So remember just now a page is one of the objects within the array of 13 pages, right? So we're going to look at the page content and then split it up even further. So to get the splitter, how to actually split it, we need to install a more package from pinecone database itself. So npm install add pinecone database slash doc splitter. So this is another package within pinecone database that gives some utility function to help split our documents. So let's import that function for us. So import a few things from at pinecone database slash doc splitter. So we need two things. Many, many, the document type, the document class, and also a recursive character text splitter. So let's come down a prepare document. So let's actually do the splitting here. So the first thing here we need to do is we can export a few things from the page itself. So remember this page, we defined this PDF page, our custom type here. So we can destructure the page content and also the metadata. Okay, then what we want to do is page content. We want to just replace page content dot replace. Replace, let's do a regex for the slash, sorry, how do we actually do the regex? It will be slash n slash g. So just replace it with an empty string. So this is just a regex to replace all the new line characters with an empty string. Then finally, we split the docs. So we do const docs equals to await, so how do we get the splitter? We can do const splitter equals to new recursive character text splitter. Then we'll do splitter dot spits documents. So when the spits the documents, so this document is going to be an array, right? But in this case, we only have one PDF page. So inside here is only going to have one document. So each document is like one page within this function. So we'll pass in a new document. So this new document is defined from what we've just imported here, right? So this document will contain a few things. So the page content will be the same, right? So this page content comes from the PDF page here. However, the metadata, we can actually specify our custom metadata. So we can pass in a page number to be the metadata dot location dot page number. And also let's pass in a text. So this text will actually contain the original text of it. So because this document will be vectorized and stored in pinecone, this text might be too long for pinecone to handle. So let's create another function for this. So export const truncate string by bytes. So this is going to take in a string and also take in a number of bytes. So what I'm going to do is just const encoder. Sorry, this should be an error function. Const encoder equals to new text encoding, new text encoder. And we just want to do return new text encoder. Sorry, text decoder. I mean text decoder, right? Text decoder. Pass in the UTF8. So we'll just give you a UTF8 and then decode it. So what do you want to decode? We want to decode the encoding of the string, right? And then after the encoding, we want to slice from 0 to bytes. So this will make sure that the string that we pass in is within the byte, within the size, the proper size. So I think pinecone only accepts strings. The metadata text to be up to 36,000 bytes. Therefore, we'll pass in the 36,000 to make sure that it truncates off properly so that it doesn't cause any errors when we actually insert into pinecone. Then last thing, after we have split up, so this splitter will take in the original document and you split up into smaller documents, then we can just return the docs. So now these docs, what it does is it takes in one single page and splits up into multiple docs. So it can be split up into five, six paragraphs for a single page, all right? So now let's actually call this prepare document, okay? So for this, before we don't return the page, what we actually want to do is we do cons documents equals to await promise.all, right? We want to pass in pages.map. So for each page, we just want to, for each page, we actually want to call the prepare document on the page itself, right? So this can actually be shorthanded into just prepare document. So what this does is, so once you have loaded in all the 13 pages from the PDF document, we can call the prepare document function on the single page. So then it's going to split up into even smaller chunks. So maybe like, let's say pages was an array of 13 elements, array of 13 pages. After calling these prepare documents on these array of 13 pages, these documents could be like maybe array of like even 100. So it takes in the single page and splits up even further. So now that we have all these documents, right, we can then vectorise and embed the individual documents, right? So that's the third step now. So we're doing well. So I hope that you are still following on. So now we actually want to vectorise and embed in the virtual documents. Okay, so let me just create another function here called embed document. So async function embed document. So before that, let's just comment this out first. Let's actually use the openAI function to actually get the embeddings of a single string, right? So come down to our, let me see where did I put it. Okay, come down to your file structure. Come down to your lib. Let's create a new file called embeddings.ts. Okay, so for this embeddings.ts, we need to install the openAI package, right? So npm install, store openAIh. So this openAIh is an alternative package to the normal openAI package that's edge compatible. So this package allows us to run this pinecone thing on the edge. So after we have done that, let us import a few things from openAIh. So we need the openAI API and also the configuration object. So the first thing here we need to do is const config equals to new configuration, passing in the API key. So how do we get the openAI API key? So let's come down to our browser. So just come down to openAI API. Okay, come down to the API and then look for the API key. So I'm going to just zoom out a little so that it doesn't, okay. So come to the menu and search for the API and just go to our overview. So get started for developers. Okay, so you see this GPT, it allows us to generate embeddings that can be used for tasks like text classification. So we want the embeddings API. So just log into the account, right? And then you can actually read more about embeddings within the docs here. So come down to your view API keys. Okay, so for this create new secret key within the API, just name it wherever you want. I'm going to name it chat PDFyoutube, create a secret key and then I want you to copy in this secret key. And let's close this tab. So come back to your.env file. So let's just put a openAI API, sorry, openAI API key, just paste it in here, save it. Let's close it. So now we have this openAI API key in our configuration. Okay, then let's just do cons openAI equals to a new openAI API passing in the config object. So now let's actually export an async function called getEmbeddings. This is going to take in a text of a text with a string. So this function purely converts a text into a vector, right? So let's do a try catch block, right? So if there's an error, let's just go to the log, error calling openAI embedding API passing the error. Okay, then actually just throw the error. Okay, so let's just do the cons response equals to await openAI dot create embedding, right? So passing in the model. So for the model, we actually want to choose the text dash embedding, embedding, sorry, make sure you're spelling it correctly, embedding dash ada dash 002. So this is the model that actually helps us do the embeddings. So it's fast and also efficient and also capable enough that we're passing the input, right, just do input, sorry, the input will be text dot replace. So just replace all the new line characters with an empty string here, empty space here. Then lastly, we just want to return. We want to do cons result equals to await response dot JSON. And we can just do return results dot data index zero dot embedding S number. So it's going to be a vector. So this embedding is merely a vector of multi dimensional numbers, so this is a vector itself. So let's close this embedding file, then we can actually use it in our pinecone.ts. So once basically remember when to embed the documents, right embed the individual documents. So for the embed documents, let's take in a doc as a document type. So these from the pinecone, pinecone type annotation. So this is going to, let's just do try catch, put in a try catch a block. So if there's an error, let's just do console dot lock, error embedding documents and passing the error. Then we'll just throw, throw the error. Okay, so what we're going to do. So first we're going to do we get embedding embeddings equals to await get embeddings. We imported from the embeddings file that we just did just now. So doc dot page content. So we want to basically convert the page content into the vector. Then we want to get hash of the page content. So for the hashing function, we'll MPM install MD5. So this is help us ID make sure that we can ID the embedding ID the vector within pinecone. Right, so let me just import, import MD5 from MD5. Right. So I think we need to install the types for this to MPM install at types for MD5. Okay, so let's save the file. Come down here. So for the hash for the unique ID, we'll just do MD5 passing the doc dot page content. Then lastly, return the return. We want to return a vector, right? So this is going to return a vector. So the vector type, so how do we get the vector type? The vector type actually comes from the pinecone database. So you see this at pinecone database, right? We can actually import the vector type. Okay, so come down here. So this can return this as a vector. So then here, we can actually do that. We can get the type annotation. So we need the ID. So this ID is going to be the hash. We need the values, the values to be the embeddings. So these actual embeddings within the vector. And then we can pass in the metadata for the vector that is going to be stored within pinecone. So we can store the text will be doc dot metadata dot text dot text, right? And then for the page number, we can page number. We can do doc dot metadata dot page number. So this doc dot metadata dot text actually comes from here. Remember, we put the metadata here. We put in page number and text. So now what we're doing here, we are accessing it here. So the metadata dot text, here metadata dot text here. Okay, so I hope everything's still clear. So then we just return the vector. Okay, so right now, we can see that now, basically, this takes in a document and returns a promise of a vector. So now that she vectorized and embed the individual data, it's an embed the individual documents. So we do the same, very similar to just now, we just do cons vectors equals to await promise dot all. We do document, we do documents dot flat. So we flatten the document first, then map to it. And then for each document, we call the embed document on that function. So then these will then give us back a real vectors, right? So if you come back to our XCALI drawer, we can see that we are now on this step. We have already broken down into each document, a small document. Then we have created into vector embeddings. So then now the last step is just to put these vector embeddings up to pinecone DB. Okay, so we're doing really good. We're doing excellent. So now we have the last step. So the first step here is upload to pinecone. Okay, so let's just get the client first. So cons client equals to await, get pinecone client, right? So this pinecone client is what we have written up just now here. So it just returns us to the pinecone with the initial, the config, the API key configs. So to get the pinecone index, right? So this index is the name of the database, right? So we want to do await client dot index. So what is the name of the pinecone index? So for me, just now I name it chat BDF, right? So if you come back to your pinecone app dot pinecone dot IO, right? So for me, I name it chat PDF. So the pipe, the index name has to be chat PDF. Okay, so that's good. So after we have gotten the pinecone index, we can then let's just say, let's do console dot lock. Let's just put a debug lock that says is inserting vectors into pinecone. And then we can just get the namespace, cons namespace. So remember, we have a different namespace for each document. We can get the file key, right? So this file key is being passed up. Okay, so there's a bug that I faced just now where if the file key was not in all ASCII characters, right, then obviously it does going to be true and error within pinecone. So we need to write another function that actually converts the file key into ASCII characters. So come down to your folder, come down to your utils, your utils or TS, and then let us create a function called convert to ASCII. So export function, convert to ASCII. Okay, this is going to take in the input string of type string. All we're going to do is remove any non ASCII characters. So this is all the function does. So we do cons ASCII string equals to input string dot replace and put these regex in. So I just got this from chat GPT, honestly. Yeah, so you can just copy whatever I have here. We can just copy whatever I have here within the code base. So let me just actually copy my own version within my code base so to make sure that everything is correct. Okay, so make sure you're putting in this regex. So this I think it just takes any non ASCII characters and just replace it with an empty string. So the last thing we just want to return the ASCII string. So let's save it. We can close it off. So remember for the file key, we want to convert to ASCII. We want to import a function from utils, right? So we're passing this file key to make sure that the namespace is ASCII compatible. Then lastly, what we can just do is we can just call. So one thing we want to import from pinecone database is the utils function, right? So when you rename the utils as pinecone utils, right, so this is a renaming of the utils function that's exported. Within these utils, pinecone utils, there's a function called chunkedupset. So it will just help us update and push the vectors into the pinecone index. So we're passing the pinecone index first. Then we're passing the vectors. There on the insert in the pinecone, passing the namespace, which is this convert ASCII. And lastly, you can see the last function here is the chunk size. So I'm going to just enter a 10. So I experimented around and just found 10 was a nice number to use for this. Then let's just return the documents in index zero. So we'll just return the first document, right, just for the sake of it. So this is the bulk of this whole retrieval augmented generation. So if you're able to understand the concept and able to implement it like here, then we are actually really good to go. So let me just save the file. So if you come back to our root.ts, right, remember that we call this load S3 into pinecone. So we got this, let me just recap everything, right. We call the file key. We downloaded S3 into the file system. Then we loaded it and then we split into the individual, we split and segment the PDF into smaller documents. We vectorized and embedded documents. Then we finally uploaded to pinecone. Okay, so now that we have that all set up for us, we can just call this so we are not actually getting anything back, any useful information back, right. So we just need to await load S3 into the pinecone. And now here is actually where we create a new chat. So we want to remember, create a new chat within our database, right. So actually let us do that. So to use GZORM to create a chat, let us do const, sorry, let us do await, sorry, await db. So this db is from our adlib slash db, right. So we do insert. So we want to insert into the chats. So we can import this chat from our db slash schema. So insert into chats, we want to insert, we want to insert the values of, we can see there's some type annotations, right. So all these type annotations comes from the schema here that we have defined. So that's a very useful feature for ORMs. So we'll pass in the, sorry, we'll pass in the file key to be the file key itself. We'll pass in the PDF name to be the file.name, file name. Then we'll pass in a PDF URL, right. So remember, we wrote a function within our S3 that helps us get back the, sorry, this S3, we wrote a function that helps us get back the S3 URL from the file key. So we can actually use that. So we get S3 URL, pass in the file key. And lastly, we need the user ID. So how do we get the user ID? So what's that called? Clerk actually also provides us with an auth function, right. Remember, we used the auth function just now. So we can do await auth from a clerk says next.js, right. So this will return us back with the current user ID. So just in case here, just in case user ID doesn't exist. So if not user ID, that means they're not authenticated. We just return a next response.json saying that the error is unauthorised and passing a status of 401. So now everything works fine. Everything works perfectly, right. We can see that we're able to get the user ID from clerk to protect our API. We're also able to get insert into our database. So actually want to return, we want to return the inserted chat ID. So we can do returning, returning, right. We pass in the, want to return the inserted ID if we change the ID. So with here, we can actually destructure the cons chat ID equals to this. Okay, so this chat ID over then will give us back this inserted ID. So we can just return, finally, we can just return next response.json, right. We want to pass in the chat ID to be chat ID index zero dot inserted ID, right. Because how it works is that this DB dot insert of values, right, this returns an array of all the inserted values. But in this case, we only inserted one value. Therefore, we want to index into zero and then we want to get this inserted ID, which is what we return from here. So this is how we actually get the chat ID from Drizzle or AMP. Then we can just pass in the status of 200 to make sure that, to tell the front end that, okay, everything is going fine. Okay, so I think everything looks perfect. Everything looks perfect. And then, so we have created this create chat root. So now finally, let's go back to our file upload and finish up the function to actually create and upload the pine cone vectors. Okay, so if you come back to our file upload for here, so remember this data, this data will now contain this chat ID. So let us destructure this chat ID from this on success. So if it successfully returns, if the function runs successfully, then we're ensured that there's a chat ID here, right? So if there's a chat ID, what do you want to do? We're going to redirect them to the chat page, to that particular chat ID that has been created. So I'm going to do those are success first. I'm going to see that, okay, chat has been created. And then I'm going to push them there, push the router to the chat page. So take a cons router equals to use router. So import this from not next slash router, right? It's not next slash router, it should be imported from next slash navigation, right? So make sure you're importing new router from next slash navigation and not from next slash router. So after we have this router, we can come down here on success, we just do router dot push slash chat slash chat ID. Okay, then everything is perfect. Let's just console dot error if there's any errors. And let's save it. And I think that's it for this page. And then I think we're good to go. So I think everything will work now. So let's actually test it out and make sure that everything is working. So open up my console. So I'm going to monitor what was happening here. So I'm going to actually come back to my app.pinecone. App.pinecone.io. Do I have it here? So I'm going to go into my chat PDF pinecone index. So right now we can see that I have 578, sorry, 578 vectors. So if everything goes well, and I upload a new file, the vector counts should increase because I'm pushing new vectors into the database, right? So I'm going to come down to my chat PDF YouTube. I'm going to go to, I'm going to drop my PDF here. And let's pray to God that it works. So I'm going to upload my edge runtime for cell docs. It's going to be spilling the tea. So right now we can see that it's hitting the create chat endpoint. So let's look at the console logs to make sure that everything is working fine. So let's hope that it works. So now we can see that it says inserting vectors into a pinecone. So you saw just now inserting vectors into pinecone. So then everything is working perfectly, right? So if I come back here, I should see that it has now increased to 591. So that means it works perfectly. And we have created the chat and has been pushed into the database. So that works perfectly. Everything is going really smoothly. So in the next part, we'll be creating the chat page. All right, so now that we've completed the pinecone uploading, let's actually work on the chat pages. So I think from here onwards, it's going to be much easier. So if you're able to understand the first part here, I think from now on, it will be much more fun. Okay, so to create a chat page, come down to your app, right? Come down to your app, and we'll be creating a new folder called chat, right? And this chat will have a wildcard that says chat ID. And reading this chat ID will have a page.tsx. So this is a special wildcard within the app browser, so that this maps to like slash chat slash whatever here. So we're able to get this ID from the URL. So we'll do tsrefce, right? So that we can get the, can we get the arrow function? Let's do a chat page. Okay, I'm going to save this file. Then I'm going to close the sidebar. Okay, so now let me refresh the page. And right now we'll be showing the chat page here. Okay, that's perfect. So how do we actually get the ID, the chat ID from the params? So within the props, right, next is actually provides us with the params within the props. So we'll get the params object. And then within it, we'll have a chat ID, which is a string. So this chat ID will come from whatever is in the square bracket. So whatever you name here has to match this chat ID. Then with that, let's actually just display the params, right? Within the params, we can actually obtain the chat ID. So let me just display the chat ID here. So if I save it here, I should show a index of ID of one. So if we go to like, let's say ID of four, then we can see it is four, right? So in this case, only chat ID of one exists. So let's actually do the starting for this. So the first thing here I'm going to do is I'm going to try to get the const user ID from the auth, await auth from clerk slash nextyears. So to use these, we have to convert this into a server component. By marking it as async. So we'll do const user ID. Then we're going to check if not user ID. So if they are not authenticated, we don't want them to be here. So we're going to just return redirect. So this redirect comes from next slash navigation, redirect them to slash sign in. Then we can try to get all the chats that the user has, right? So because we want to show like the sidebar, the chat sidebar, we can see it shows the chat sidebar with all the chats, right? All these chats, let's actually get that page. So we'll do const and just call chats equals to await DB, right? DB from our DrizzleRM dot select from the chats which imports from the schema, right? Let me just put this aside a little bit more. We're going to do equal. So this equal comes from DrizzleRM. So equal when chats dot user ID equals to user ID, right? So this is very similar to a normal SQL statement. So select from chats where chats dot user ID equals to user ID. So make sure that you can see the difference between these chats and these underscore chats. These chats actually come from the schema. So if we press and see, this is the schema that we have defined, right? That's why we're able to access the user ID here. Whereas this underscore chats is the list of all the chats that return from the database, okay? So with that, we can check if not chats. So if basically there isn't any chats, which is return redirect to slash, okay? But then the thing is, if within the chats, there isn't a valid chat ID, right? That means we couldn't find the chat ID within the owner's chats. Then obviously something is wrong again. So if not underscore chats dot find, right? Chat where chats dot ID equals to chat ID. So if you can't find a valid chat ID, right? So what's the issue here? Right now this, let me see, this chat ID is an integer, is a number. So we actually want to parse this into an integer. So parse int here. So if I can't find anything, I'm going to do the same return redirect to slash. Okay, so with that, let's actually start styling it. Let's do return and I have a upper div, a very big div here. There's a class name of flex max height of screen and overflow of scroll. Of scroll, okay. Then within this div, let's actually have this another div. This div will have the class name of also facts width of full max height of screen also as well as overflow scroll. Okay, so then within the big div, we have a smaller div. So we'll speed it up in three sections. Let me just label it so that we can see it properly. So we have a chat sidebar. Chat sidebar, then we have the main PDF viewer. And then we have the chat component for them to chat with chat GPT. Okay, so within the first div here, let's give you a class name of flex dash one. So it's going to take up one unit of space. We give you a max width of XS and then we'll just create a chat. We want to have a chat sidebar component. So we'll create this component later. For the PDF viewer, for this div, we'll give you a class name of max height of screen, padding of four, overflow of scroll as well, and then flex of five. So it takes up five units of space instead. So we have a PDF viewer here. So we create that component later. For this chat component, lastly, for the div that's wrapping it, we'll give you a class name of flex dash three. So it takes up three units of space, border left of four and border left of slate 200. Then we'll have the chat component. Okay, so let's create a chat sidebar first. So come down to your components folder. Let's create a component called chat sidebar dot TSX. So TSRAFCE to create the sidebar itself. Okay, so this sidebar is going to take in a few props. It's going to take in the list of chats and the active chat ID. So we want to have all the chats here, but also to know which chat is the active one. So for this, we want to take in the chats. So be a list of chat, but how do we know where this chat was? What's the type of the chat, right? How do you get the type of the chat? If you come back to our schema.ts, we can actually export the type out from the schema, right? So we can actually do, how do we get this? Okay, so in order to get the type of these chats, we can export a type called a drizzle chat. And we can do type of chat dot dollar sign, a dollar sign infer select. So this will give us the proper type of chat. So we get all this type script here. So let's save this. And then now let's go back to our chat sidebar. So this chat will be a list of drizzle chats. So we import it from our schema, right? And then obviously we have the chat ID, which is going to be a number. So with that done, let's actually style the chat sidebar. So we can obtain a few things. We obtain the chat as well as the chat ID. So for the chat sidebar, let's actually just make it into a client component. So later on, cause we want to have a striped subscription, right? So the button that triggers a striped subscription requires the client component. So let's do a wrapping diff. So this diff will have a class name of width of full, height of screen, padding of four, text gray of 200, and also background of gray of 900. So we have a darker background. Now within this diff we have a link from next slash link, next slash link, sorry. So this will lead us to, it will lead us to href slash, right? So this will contain a button, sorry, button from UI slash button. It will create a new chat, create a new chat. So when they click on this button here, here, if you see in that example, it brings them back to the homepage. Okay. So within this button, let's just style it a little nicer. So we have a plus circle icon from a Lucid dash react, but just plus circle. And then we'll give you a styling of, let's say margin of two, width of four and height of four. So let's see that. And right now we have a, we actually need to import the sidebar. So let's go to page dot TSX. So let's import the, the chat sidebar. Okay. So let me just move this down here, uncomment this. So let me import this chat sidebar. So it needs a few things, right? It needs the chats. So these chats will come from this underscore chats. And for the chat ID will come from pass in of the chat ID. So I mean, save this and hopefully something will show up right now. Okay. So, okay. So now I have a button that shows new chat. Okay. So the way I'm going to do this, I'm going to expand this screen so that we will see the whole screen, because it's supposed to be a big layout, right? So I'm going to come back to my VS code instance and we'll keep coding. Okay. So the next step here is for this button, let us actually give you a class name of, sorry, let's give you a class name of width of four border dashed. Uh, let's give you a border of white and border. So if we save this, right, we can now see that hopefully it will have a nicer styling with a dash border around it. Okay. That's perfect. Okay. So then, uh, below this link, let's actually map to the, map to the different chats. So we'll enclose this entire chat array into a flex dot flex call. So it'll be a flex column and we'll give you a gap of two and margin top of four within this diff. Let's actually map to the chats. So chats dot map. So for each chat, let's see what we want to return. So we're going to return a, uh, we're going to return a link itself. So this link will have a key of chat dot ID, but also a href of, uh, slash chat slash chat dot ID. Right. Okay. So within this link, let us have a diff, right? This diff will contain a class name of rounded LG large. Uh, then within this diff, let's actually put a P tag. That is the chat dot PDF name. Okay. Above the P tag, let us put a new nice message circle, uh, icon from Lucy react. Let's start it. Margin of two. So let's save it. And then if you come back here right now, it's going to look kind of weird because we only have one chat and also it's not properly stopped. Okay. But at least something is, is happening. Right. So let's start this paragraph tag. Okay. So this paragraph tag, we're going to give you a class name of, uh, with a full overflow of hidden, uh, text SM truncate. So if it's too long, we want to, uh, truncate it and we'll do white space, no rep and also text ellipses. Okay. Uh, for this, uh, upper diff with the rounded large, uh, rounded large, right? Actually I'm going to just convert this, remove this. I'm going to wrap it into a JSX and I'm going to call the CN function. So remember this CN function from the, from a shared CN that you created for us? We can use that right now. So the first thing here, let's put a rounded large. Let's give it a padding of three text late of 300 and also flex and items center. Okay. Then we're going to add a second parameter in the object. So I'm going to put BG blue of 600. So if it's the active, uh, chat, so I'm going to put if the chat ID equals to chat ID. So if it's an active chat, I'll give you a background blue and give you a text of white. Right. But if it's not the chat ID, then I'll put hover text white. And we'll just put the negation of that. So if I save it, so if it's the active chat, it should be blue. So right now, because it is active chat, it should be blue. So let's wait for it to reload. Let's see. Okay. So perfect. Now it's working. So it's blue color right now. Okay. So everything's working fine. So let's now comment of the, let's come out of this diff, uh, come out of this diff that reps the flex call. Right. So let's collapse it. So below the, just above the closing diff, let's have a, let's actually put some text here. So let's put a diff, uh, that has a custom of position absolute bottom of four and left of four. And we'll have a diff, another diff that reps our links. So this link can just, uh, just link back to like home. Right. Or then we have a hs of just slash and then we can maybe have another diff to like whatever source code you want. Just put source and any logos that you want to put here. Right. So later here, we'll be putting our stripe button. Right. So then we allow them to upgrade their account by pressing this button. So I'm going to give you a little styling. So for this, a wrapping diff here, let's give a style of flex items, dev center, um, gap of two, text of SM, text slate of 500 and flex wrap. So let's save this. And hopefully there's a nice icon. There are nice texts that shows up in the bottom left corner. So we're just waiting for it to reload and hopefully it reload. And now we can see that it just brings us to the home and the source page. Okay. So I hope everything is clear and understandable to you for now. Okay. So we have completed the chat sidebar. Okay. So now that we have completed the chat sidebar, let's actually go on to create the, uh, PDF viewer, uh, PDF viewer here. Okay. So I'm going to come back down to our VS code instance. So come down here and let's create a new component called PDF viewer dot TSX. Okay. So for the PDF viewer, it's going to be a very simple component, right? Uh, let's just do the same, the same thing. So we'll do TSRAFCE to create the TypeScript component for us. So it's going to take in a prop, right? It's going to take in the PDF URL. So it's going to be a type of string. So let's just destruct right here. PDF URL. So we're going to return just an iframe, a normal iframe, right? This iframe is going to have a source of the, so we're going to be basically using Google, uh, I think Google provides us with a free, I don't know if it's free. I don't know how it works, but it's, uh, it allows us to use Google Docs, uh, uh, PDF viewer to show our SG PDF. So for the source, you just put HTTPS, colon, slash, slash, docs, dot, google.com slash G view, right? And you pass in the URL to be our PDF URL. And then lastly, we want to do, uh, make sure that embedded, it goes to true. Right? Then we'll give you a class name of, uh, with a full and height of full. That's, that's all there is to here. So let me just, sorry, height of full. So save it, come back to our page dot TSX here and remember this PDF viewer. Let's uncomment it out, imported from our components, passing the PDF URL to be the, uh, so how do we actually get the, uh, sorry, how do we actually get the PDF URL? Uh, let me see. So to get a PDF URL, we must get the current chat. So let me, let's get the current chat. So we do cons current chat equals to, uh, chat dot find, sorry, find chat where chat dot ID equals to pass in chat ID. So we're just looking through the, the chats that we get back from the database and we just find the one that is matches the chat ID in the URL. So then for the PDF URL, we can just pass in current, uh, chat dot, uh, PDF URL. So this, this might be now, right? So then we can just do, if it doesn't exist, we'll just pass in an empty string. So let's save this and hopefully we're able to see the runtime docs. So I'm going to just refresh the page and then we'll be able to see the, the PDF embedded being shown here. So let's wait for you to load. I think VS codes are low. My, my computer is running a little slow here. Okay. And so, yeah, it works. So now we can see that the docs is being embedded into our iframe, which is being imported into our component here. Okay. So that's for the PDF viewer. All right. So, uh, now that we have completed the chat sidebar and the, the, basically the main PDF viewer, let's actually work on the chat component here so that we able to ask any question we want. And we have that nice, uh, streaming effect back from a chat GPT, right? So we'll be using, uh, Versailles AI SDK for this. So if you search for your AI SDK, it's a very new SDK that is just released in, uh, June. Yeah. In June 15th. So I did a video just yesterday about this library. So yeah, a bit of, uh, we're working you through how we actually create that, this whole, uh, chat GPT effect from, uh, from scratch with the help of this library. So this library actually abstracts away a lot of the, the knowledge needed to create a proper UI and to actually integrate different last language models into our application. So I'll be working you through that. And I'm going to show you how easy it is to actually create that chat GPT effect. So the first step here is to actually, uh, let us create that chat component. So right now here, we can see that we have this chat component. So let's come down to our components folder and let's create that chat components.tsx.tsx. Let's go TS array FC for the, uh, uh, component. So let's save that first, come back to our page.tsx and now we can just import the chat component. Okay. So with that chat component, let's actually begin, uh, begin the thing. Okay. So, uh, let me, for now, I'm going to go into my chat component. I'm going to make this into a client component. Okay. So another thing I need to do is I'm going to come down to my terminal and install, uh, let me just move this here. So we'll see it. NPM install AI. So my face is broken, but here, so it's just a very simple command. So this AI is the Versailles SDK. So let's install it and then let me move myself back here. Okay. So I'm going to collapse this. So we're going to first, um, set up the UI for this. Okay. So within this, uh, check component, let's return a diff with a class name of, um, relative, um, max height of screen and overflow of scroll. Within the diff, uh, let us have another diff. So this is for the header, right? So let's put here, uh, a hit three that says chat, uh, give, we'll give this class name of sticky. So it will stick to the top. We'll give you a top of zero. So it sticks to the top or so, and also insert X of zero. So this is a shorthand for basically putting left of zero and right of zero. And then, uh, let's say we give it padding of two, background of white and height of fit. Fit. Okay. So this history, let's give you a class name of text dash XL and font of bold. So if we save this right now, uh, we just have this, uh, check component and it should show, it should show the, the chat, uh, message here soon. If we wait for it to compile and load. So I mean, just let's give you a second. So I'm going to refresh the page and hopefully it shows up here. Sure. Okay. So the check is shown here. So we make sure that everything is working and the PDF still loads. Okay. That's good. So below this diff here, I'm going to have a create another component just for the message list. Okay. So I'm going to create a component later, but below that, let's actually create a form, a form within this form will have an input, right? So this input, let's actually install the input from set cn. So we'll do MPX set cn UI at latest at input. Okay. So then we can, uh, able to download the input component from set cn press enter and press, uh, yes, when it prompts you to, so it installs it to our local system. Okay. So here, let me just import the input component from our CUI library. So let me just format this. Oops. Format. Okay. Okay. So let me just destructor a few things from, uh, the Versailles SDK. So import a few things from AI slash react. So actually we only need one thing. It's called use chat. So this use chat actually gives us a lot of functionality to create that streaming UI for chat GPT experience. So let's destructor a few things from this, uh, use chat feature function. So we actually mainly need four things. We need, um, the input and also the handle input change. Okay. So for this input, let us pass in the value to be input and the unchanged to be handle input change. So all these two things are doing is, is giving control to Versailles, is giving control to GPT to control the input here. And then for the form, so whenever we submit on submit, right, we can actually destructor one more function here for handle submit. So it just helps us like deals with all the different submit, uh, submit, um, functionalities for us. Okay. So then, uh, with this form completed, right, let's, let's go into the input. I start with a little better. So we give a placeholder of ask any question and let's give you a custom of with full. Okay. So, uh, for this, uh, for this form, uh, let's actually give you a few classrooms. Uh, we give you a sticky. So when the stick to the bottom of the screen, so bottom of zero, inset X of zero, padding X of two, padding Y of four and background of white. Okay. Below this input, let's have a button, uh, this button from us button. Let's just put a send icon, send, sorry, send icon from Lucy dash react. We give you a custom of height of four and width of four. The bottom of a custom of BG blue of 600 and also margin level of two. So I'm going to save this and okay. So right now is it has an input showing up. So we'll wait for the, the styles to update and then it will show up in the UI. So while this happening, okay. So what this use chat function does for us is that it actually gives us back one more lasting is the messages array. So this is where the magic happens. This messages array is a array of messages. And basically what it does is it just, uh, it allows us to look through these messages and display it in our front end however we like. So if you actually inspect, uh, these messages, so let's just do messages index zero, and we do dot, we can see that the content, we can even see the row, right? So this content is like, uh, the text content of it, but the row here, we can see that it can either be assistant or user, right? So assistant is like the AI reply and the user is whatever we send to the GPT. So based on whether it's assessor or user, we can render different, uh, styles for our messages. So this is exactly what we're going to do for the message, this component. So what I'm going to do here is going to come down to, uh, come down to my component and for other component, let's create the message, uh, list dot TSX. Let's do TSRAFC. Okay, so create a component. So the first thing is I save this and let's actually import the message list, message list component from our component. And remember when we pass in the messages, when we pass in these messages from the use chat hook that we got from Versio AI SDK. Okay. So let me just go into message list. Okay. For the message list, for the props, let us actually get the messages. It's going to be type of message. So this message type will come from AI slash react, which is perfect. So it's going to be an array of messages. So let's actually destructure the messages. So then let's do the styling. So, uh, I'm going to do if not messages, I'm going to just return an empty fragment. So other than that, if messages do exist, let's do a create div with a custom of flex, flex dash call, gap of two and padding x of four. Okay. So, uh, yes, yes, yes. Okay, cool. Then within here, within this div, let's actually map through the messages. For each message, let us just return a div with a key of message.id. So let's close this div off. Okay. Within this div, let's actually give you a few class names, class name. Okay. So we're using a CN function from utils. So for now, it's going to be flex box, right? But the thing is, uh, we're going to justify it to the end and if the message dot row equals to user. So why this is saying is that if it's a user message, I'm going to push the message all the way to the, uh, right of the screen, right? So let me just show you how it would look like. So if it comes to the original here, we can see that because it's a user message, I push it, I align the message to the right. If it's an AI message, I push it to the left. So right now, why is this button here misaligned? So let's, let's look at why that is check component. So I think what I did here was I forgot to wrap it in another, uh, flex box, right? Yep. So here inside this form, I should wrap it into a flex box that wraps the input and the button so that it aligns together. So in the meantime, we'll pass in the messages into the message list. Okay. So let's save it. So now let's go back to coding. Okay. So if, if it's an AI message, let's actually just do justify dash start if the message dot row equals to assistant. Okay. So let's add one more style here. We're going to give you a padding left of 10 and padding right of 10 below here. So within this div, we can actually display the message content. Um, so we have a div, uh, which will have a class name of rounded of large. Okay. Within the, uh, rounded large, let's actually create a paragraph tag that shows the message dot content. Okay. And then here, actually for this div, uh, instead of putting into a string, let us put in JSX cause you want to use the CN function. So first thing we're going to have the, uh, rounded that's large. That doesn't change, but for the second object, we actually want to color it blue if the message row is user. So, um, we'll do bg sorry, bg dash blue dash 600 and tags of white. If the message row equals to user, right. So for the other than rounded large, let's give you some more style. So padding X of three, tags SM, padding Y of one, shadow of medium, ring one, ring dash gray dash 900 divided by 10. Right. So let's save this. And that's, uh, that's it for the message list. Okay. So that's good. That's good. So right now, obviously we will not be able to see anything cause we do not have any messages showing up. Right. So how do we actually do the messages? So how it works is that if you come back to this check component, we can see that this use chat, right by default, let's see, we can show you, we can actually add some more configuration into object so we can pass in a lot more data, like, uh, the API. So this API is going to default to slash API slash chat. Okay. So we have to actually create this endpoint so that, uh, whenever we hit enter, it will send the message to our chat GPD endpoint and then it will return us with the streaming output from chat GPT. So let's create this endpoint. So I'm going to save it, come down to our app, right under our API, let's create a chat folder and inside, let's press root.ts. Okay. So the root.ts is going to be pretty simple. Right. So first here is import. Let's import from open AI H. So cause we're using the open AI model. So open con or import configuration and also open AI API. So we do the same thing, right? We'll do cons config equals to new configuration, right? Passing in the API key to be process.env to open AI API key. So we already got the API key just now, so we can leave it there. Then we'll do cons open AI equals to new open AI con API passing the config. So one more thing here is I'm going to do export cons runtime equals to H. So these were the H runtimes comes in, right? Because we're using the open AI H, we actually mark this function as a H. So H function so that you make this a function much faster when we actually deploy it to Vercel. Okay. So now let's actually export a async function called post. We're going to take in request to be the request. So how this works is we're going to first get the body. So we're going to do a try catch block. So we didn't try it as get the body equals to await request.json. Okay. So in the body, we can actually destructure a few things. We'll destructure the messages array. So whenever the check component, right, this will handle all the logic for us. Whenever we press a submit on the input, it's going to send the current messages into our slash API says chat, which we will receive in this messages request body. Okay, then once we have the message, right messages array, let us do we ask open AI for streaming comp check completion. So we do cons response, sorry, cons response equals to await open AI, sorry, await open AI dot create chat completion, right, passing three things, we need a model. So the model will be using GPT3.5turbo. So it's a very fast model, but it's also very competent. Then we'll set we're passing the messages array. So this comes from the request body. And lastly, we want to set streaming to be true. So because we want like token to come back one by one. So what streaming means is that let's say I send a request to open AI, instead of waiting for it to generate the whole response, and then sending it back at once, and we have to wait for maybe a few seconds. The moment that it starts generating tokens one word by one word, it will start sending the one word by one word back to me, and able to display on the front end. Okay, so to actually create a streaming effect, all right, Versailles AI actually gives us utility functions to create this to get the response stream and convert it to a normal stream to our front end. So let's import two things from the AI library itself. So this AI is from the Versailles AI SDK. So we need to open AI stream and also the streaming text response utility function here. So first, let's get the stream to, we basically call the open AI stream function, open AI stream and passing the response. Then lastly, we can return a return a new streaming text response passing in the stream. So it will take the streaming response from open AI and passes it back to our front end. Then let us save this, come back to our check component, right, and look at the magic here, right, and believe it or not, this is all it takes for you to create to create chatgbt, right. So now if I try to answer any questions, so right now, let me ask like, hello, I send it, right. We should be able to see the chatgbt slowly answering back. So let's wait for the check. I can see, look, it works and that's incredible, like we didn't really write any like custom code. All we need to do was call some functions from the Versailles AI SDK is able to create that chat streaming effect for me. So I can ask like, how is, sorry, explain JavaScript runtime to me. So we can see that there's a streaming effect from a chatgbt. So what it does is it hits the backend, it hits the SAS API SAS chat, then it creates that streaming effect and then basically sends it to the front end and then it updates the messages array, right. So remember here, these messages that we got from this huge chat, right, you update the messages, then we pass it to the message list and then we look through the message list and depending on whether it was the AI responding or the user responding, we're able to create this beautiful, this beautiful response, right. So the issue right now is that, yes, although we have a nice chatgbt interface going on, this chatgbt has no idea about the PDF, right. It doesn't know any idea about what the PDF is talking about. So in the next part here, we're going to start trying to fit the context of the PDF into the chatgbt response so that it has context of the PDF. Okay, so, so now that we have this chatgbt interface, right, the issue right now is that it doesn't have context about the PDF. So let's go back to the escalator to see what we're going to do next. So remember now that we have all these vector embeddings documents stored within our pinecone DB, right. So how do we actually get the relevant vector embedding for whenever we ask a question? So let me, let's say the second part, right, see this search part. So the first step here is to embed the queries, then we can query the pinecone DB for similar vectors. So then we're going to take maybe like the top five similar vectors, we're going to extract out the metadata of the similar vectors. So we're going to take out the text content of the five, top five similar vectors, and then we'll feed the whole paragraph of context into the OpenAI prompt. So if you come back to the, if you come back to our function here in within the, the chat root, right here, whenever we do this, we get the create chat completion, right. For these messages, right, we can actually get another prompt. So we can have an additional prompt such that we're able to give the OpenAI context of the PDF. So that's what we're going to do next. So let's just open our directory and let's create that function to get the context. So close up everything and come down to our lib and let's create a new file called context.ts. So this context.ts is going to mainly have two functions, right. So it's going to have two functions. The first function is going to be actual async function get context. So this is the actual function to get the context of the query. So we'll take in the query, which is a string, right. So this query is, is basically why it's being passed whenever we ask a question like in this chat box here. Okay. And the second thing is we want to have the file key, right. So remember why we need a file key because we need a namespace. So remember I introduced you, I introduced the time we talked about we need this namespace. So not just now, whenever we push vectors within the pine cone, we actually add a namespace prop, right. So now we need to get the correct namespace so that we search the vector DB for the correct, within the correct namespace, so that we're not searching for information from other PDFs, right. So therefore we need, we also need this file key to get the correct namespace. So then to do this, let us first, so we also need a function export. Let me see. So this second function will be called get matches from embeddings. So this step, this function will take in embeddings. So it's a vector, so it's an array of number, and also the file key with a string. So this function is going to basically take the query vector, it's going to search through the pine cone for the top five similar vector, and then it's going to return me with the top five similar vectors. So I'm going to write out the code and then we'll see what it means. All right. So the first thing here I'm going to do is for these get matches from embeddings, so I'm going to be querying pine cone, right. So I need the pine cone client. So I'm going to do cons pine cone equals to new pine cone client, right. Then we'll do await a pine cone dot init, right. So we need the API key which is pine cone API key ensure that it exists. And we also need the environment, right. This environment is going to be the pine cone environment. So make sure you have this within your env here, right. So we did it just now, so it's fine. So make sure this exists. So this should be environment. Okay. So after initializing pine cone, let's get the index, right. The pine cone index, we do await pine cone dot index. So the index, remember what you name it, I name it uh chat PDF, right. So it's the one that corresponds to within your pine cone console chat PDF. Okay. So now that we got this index, let's do a try catch block. So if it fills, let's just do console dot lock, error querying embeddings, then we just pass in the error. Then we just throw the error back to the caller. Throw error. Okay. So what did I try? So first we get the namespace. So remember the namespace, we have to convert the file key into ASCII characters. So we import that from utils and we pass in the file key. And then we want to initialize a const query request, right. So, sorry, query result. So this query result is going to be the function is going to get back from this function called index dot query. So pine cone index actually has a function called query, right. So if we go into the object, we can see that we need a query request object. So within this query request object, we can pass in a lot of other vectors that we want to search for. So this top key basically tells, is asking pine cone how many vectors we want to return. So if you put top key as five, it's asking, it's saying that we want to return us with the top five similar vectors that matches the query embedding. Then we pass in the vector that we actually want to query against, which is the embedding that's passed into this parameter. And then we want to include metadata so that we can get back the text, the original text from the query, the similar vectors. And we pass in the namespace, which is from the convert to ASCII. So this query result, you can see that it's going to be a query response. So we can then return query result dot matches else and empty array. So these matches are going to return us with a top five SCOT vector. So it's going to be an array of five vectors because we put in top key as five, right. So then we're going to return this. If not, we just return empty array. Okay, so now that we have this function, we can actually call these get matches from embedding within this get context function here. So I'm going to do cons query embeddings equals await get embeddings. So we've written this function using OpenAI, right, then we pass in the query string, right. And then now we can actually call this upper function. So we do cons matches equals to await get matches from embeddings, pass in the query embeddings and the file key. Okay, so these matches will be returned from this query result of matches. Then we can do cons qualifying docs equals to matches.filter. So for each match, for each match, we're going to return the return if match.score exists, we're going to return match.score bigger than 0.7, right. So what this does is basically it will look through all the matching matching vectors. So if the score matches more than 70%, then we return it. So if it's less than 70%, it's probably irrelevant. So we just want to ignore that. Okay, then lastly, we can type the metadata. So remember the metadata type metadata, we have a text, which is a string, and as well as a page number, which is a number. Okay, so with that, we can then do let docs equals to matches.map matches. Sorry, we can actually do qualifying docs.map for each match. We can do match.matterdata as metadata. So we customly type it .text. So what it does is, if we go through these docs, right, then because remember we added the metadata before pushing into pinecone, then we can just get back the text. Then lastly, we just want to return docs.join, sorry, docs.join a slash n. So basically, let's say we get back five vectors, right. The five vectors we can basically take the five paragraphs from each the five vectors, then we just join it together. Then that's going to be the context block in which we feed into OpenAI prompt. Then we're going to substring it to 0 to 3000. So in case that the docs exceeds 3000 characters, we'll just cut it off because we don't want to feed too much information into OpenAI because then the token limit might be reached, right. So let's save this. So we've actually completed this function. Okay, so then let's come back to our chat's root. So now within here, we can actually get the context. We didn't get the context here. Okay, so the first thing here, what we're going to do is we need the file key, right. So remember what we want to do is we want to get the last message. Con's last message equals to messages or message.length minus one. So the last message is the message that is sent in by the user. So this last message is the query itself. So how do we get the context? So context equals to a way it gets context, right. We import it from our library context. So we get last message, right, which is a query. But how do we get the file key, right. Right now, we can't get a file key from this request body, right. So this file key has to actually come from the chat itself, right. So to get that file key, we actually need to go back to our chat component, right. So underneath this use chat, right, there's another parameter that we can pass in, which is the body, right. So these additional objects that can be passed back to our backend here, whenever we make the call. So we can pass in a chat ID, right. So how do we get the chat ID? We can get it from props. So let me just type it out first, and then we're able to explain how the entire flow works. So we need the chat ID. So if you come back to our page.jsx, we need to pass in this chat ID to chat ID. In parse int chat ID. Okay, that works. Then save it. So from our page.jsx, we pass in the chat ID to our chat component. We receive it in props. And basically this use chat, we pass it into the body so that we can destructuate from the request body at the backend here, chat ID. So I hope you get the flow of it. Okay, so how do we get the file key from the chat ID? We can query the database for this, right. So we do const underscore chats equals to await DB. So this from drizzle or m dot select dot from chats. Where? So this chats have to import from schema also, where equals chat.id equals to chat ID. Okay, yep. So then we're gonna check if chats.length not equals to one. So if there's not exactly one chat, something went wrong, we're gonna return a return a next, next response. dot JSON. Sorry, let's import this saying that error chat not found passing in a status of 404. Okay, so everything looks good. Okay, so now that we got the chats, right, we can obtain the chat. So const file key equals to underscore chats index zero, because we're basically getting back a list of all the chats that fulfill these requirements, right. So we do underscore chats dot file key. So this how we obtain the file key. Okay, then we can just pass in the file key into our context. So now this context should return us with a whole paragraph of relevant vectors and their pitch content. So with that, we can actually now feed it into the response. So I'm gonna just do const prompt equals to an object where the row will be a system. So this is us now feeding the context into chat GPT. So I'm gonna copy paste this prompt because I didn't write it out but I got it from somewhere. I got it from the Versailles AI docs, right. So I'm gonna paste this in. Let me just, let me just work. Okay, so basically what it does is it tells us the row is a system and tells it the content is telling the AI that is a powerful humanlike AI. And basically what it does is it passes the context block, right. So this context we can see that it templates it in within a prompt and tells it that AI assistant will take into account any context block that is provided in the conversation. Yeah, so I'll post this prompt into the description below so you don't have to manually write it out yourself. Okay, so now that we have this prompt, we can now feed it into the response of this create chat completion. So for these messages, right, other than just passing in the messages from the request body, I'm also going to map through. I'm gonna pass in the prompt itself as well as all the messages, all the messages dot filter message dot a message dot row equals to user. So this message will have a type of message which comes from ai slash react. So let me import that from ai slash react. Okay, so what this does is basically for these messages array that is being passed into OpenAI, I pass in the prompt which is this entire context block, right. It contains all the relevant documents as well as I pass in all the messages that only belongs to the user, right. So we only care about what the user is asking. So if the messages contains any assistant messages, we just block it out so that we can save some context, sorry, we save some token space where we create the chat completion. So I hope you understand. And then lastly, I think that's pretty much it we completed. So then we can save this file, come back to chat component, right, come back to chat component and let's see if anything else is required. Okay, so one last thing here down to add is, let me see here, let me see, let me see, let me see. So whenever the message is being sent, right, is being basically entered, I want to scroll down, scroll all the way down, right. Because if not like, let's say I answer as a question, right, it does not automatically scroll down for me. So to do that, what I can do is I'm going to come back up to a, let me see, let me see, message. Okay, under our chat component. So for our wrapping div here, I'm going to give you an ID of message container, then I'm going to add a react.use effect, right. So basically, every time the message change, messages change, I'm going to do document message container equals to document dot get element by ID, right. So I'm going to get the ID of this div, then if the message container exists, right, then I'm going to do message container dot scroll, scroll to, sorry, scroll to the top should be message container dot scroll height, and behaviour should be smooth. Okay, so this will basically automatically scroll us down to the bottom of the message whenever there's a new message that comes in. So if we save everything, right, and let's hope that it works. So I'm going to just refresh the page right now. Okay, so I'm going to try everything from scratch to make sure that everything is still working as intended. So I'm going to press a new chat, and I'm going to wait for you to bring me back to the homepage. So now I'm going to upload my own custom document and let's test if it works. Okay, so I'm going to do drop PDF here. So let me select a relevant PDF, let's say I ask about my resume, because at least that's something I know will work. So it's going to be uploading to chat, you upload to S3, then you upload to pinecone. So let's wait for a while because it's running locally, it's going to be a little slower. But when we push it up to Vercel, this process is going to be really, really fast. So let's wait for it to load. So let me see if everything is working fine. Okay, so chat has been created, we can see that the resume has been uploaded. I can see my resume here. And so by right, if I ask the question, it should take into context my my PDF. So let me ask what school did I get a 10? Question mark. So let's wait for it to respond, and hopefully, it's able to give me something insightful. Something is breaking. So let's look at the error. Okay, cannot read undefined. Text.replace is not a function. Error calling OpenAI Embeddings API. So let's see why that is the issue. Ah, okay, so I see the issue. Right now, we can see the last message is this is an object itself, right? But then we should be really getting the message.content, right? Instead of passing the whole last message. So let's pass in the message.content. So let's save this. So hopefully that explains the error. So yeah, I'll be debugging like this. Okay, so this should work now. So I can ask, where did I get a 10 school? Question mark. So if I send this, hopefully, if everything goes right, okay, yes, that's awesome. So it's able to see that it has gotten out of the context from my education vector within my PDF is able to give me an insightful answer. Okay, so let me ask like, let's see how many projects did he do? So we save that. And okay, so, okay, so I mean, obviously, it's not perfect, but it's able to get in context within the PDF. And that's, that's really exciting for me here. Okay, okay, so the issue right now is that everything is working perfectly. However, the moment I refresh, right, you can see that the chat log doesn't get saved, right? Because we're not saving the chat store database. So how to actually save the chat store database is a really simple thing. And that's why I really love about the Versailles AIS decay. So if you come back to our, you see this open AI stream, right? It actually accepts a second parameter, which is an object. And within this object, it gives us a lot of hooks and callbacks. So we can see that on start. So basically what this function, this callback does is that whenever the query has started, it's going to give us that prompt, right? It's going to give us the, it's going to tell us that it started and then we can save the prompt into our database, right? That means we can save the user's message within our database. So what we're going to do is, on start, we're going to save user message into DB, right? Then the second one is on completion. So whenever the AI, AI finished responding, it's going to give us the completion and then we can then save this into our database. So then save AI message into DB. So let's do that. It's a very simple call. So we just do await DB dot insert, right? Insert into our messages, sorry, messages. So we can see that messages right now is importing from the request body, but actually we want the messages from our drizzle schema. So let's get that. So instead of this chat, let's also import the messages and we can rename it to underscore messages so that the naming doesn't collide. Okay, so we can insert into messages dot values, right? It's going to take an object so we can see the different attributes we need. So we need first, we need a chat ID. So we have that from the request body. So that's perfect. Then we also need the content. So we can get that from last message dot content. So this is the user query. And then we can do the row, which is a user. Okay, then whenever it has completed, so that we can save the AI message into our database, we do this, write something very similar. So for this content, it's just literally completion. So completion is just a normal string. Okay, then that's pretty much it. So we have successfully saved the message into our database. Okay, so how do we actually access the messages whenever we first load here? Okay, that's a very simple thing to do. Let's also create let's create a new route within our API called get dash messages. Sorry, let's create a folder called get dash messages. We'll create a route dot TS underneath here. Okay. So inside this route is a really simple function, we just want to return all the messages for a given chat ID. Okay, so we'll do export const post equals to an async function. This will take in the request object. Okay, so it's just gonna, we're gonna get the body from await request dot JSON. So we're gonna destructure the chat's ID from the request body. And then we'll just do const messages equals to await DB. So we import this DB from adlib. And then we can do dot select dot from messages. So these messages can be import from schema dot where equals message messages dot chat ID equals to the chat ID pass into the request prep. So it really is like SQL. So drizzle. I am is cool in this in this sense. So actually, we can also mark this export const runtime equals to H to make this function faster when we deploy it because drizzle is compatible to H runtime. That's how we can do this. Then we just want to return next response dot JSON pass in the messages. Okay, so let's save this. So now we got to call this function, call this route from the front end, right. So this check component, we can see that for this use check, right, there's one more thing that we actually pass into this check component. Within our object here, we can pass in a other than the body here, we can pass in an initial message messages, which can be an array, right. So how do you get back these initial messages, we can just do a call to our endpoint just now. So we'll do that from a use query. So this from React query again, use query. Okay, we're passing the query key, right. So this key is to uniquely identify this query made to the back end, right. So query the chat ID. And then so this can be anything, right, this is not important, the query key doesn't make much of a difference. So the query function is what is being called to get the messages. So we'll do const response equals to await axios.post to slash API slash get messages, right. We can pass in the chat's ID, right. And then we can pass in a generic so that this will always ensure that it's going to be a message array. So then this message array that we get back here, this response.data. So let me just return response.data. We can see that this response.data will have a type of message array, then we can just pass in this data. So let's destructure the data from here. This data will have the message array, right. And with this initial message, we can just pass it here, data, if not passing the empty array. Yeah, that's all there is, right. So one more thing here is, let us save that first, and let's make sure that it works. Okay, so I'm going to refresh the page, refresh the page, and then I'm going to wait for it to load. And then I'm going to ask the question, and hopefully it saves my query to the database. Okay, so I'm going to ask you a question like, where did he intern at? Okay, so it should return me with the response, then if I refresh the page, hopefully this chat will, okay, so it works. So when I refresh the page, you can see that it gets the messages that stop within the database, it passes it passes the array into the use message hook, so that it renders the initial messages. That's good. So one more slight UI improvement that I just want to make a very simple one is just to while I'm fetching the data is loading, so I get is loading from this use query, I'm gonna pass it into my message list. So pass is loading to is loading. Okay, I'm going to go into my message list, I'll accept this as props is loading, it's gonna be a Boolean. Okay, then I just want to, if it's loading, I just want to show a loading spinner. That's pretty much what I want to do. So I'm gonna show if is loading. So let's distract it from the props itself is loading. I'm gonna return a div. Sorry. So I'm gonna return a div with position absolute, right, we'll give you a custom of top of half, left, sorry, left of half, negative translates x of half, negative translates y of half, then inside here I'm going to put a loader, a loader to imported from Lucid React. Let's give you a custom of width of six, height of six and emit spin. So this is just that when it's loading the initial messages, it will, there's a nice loading effect, refresh the page again. Okay, so I guess there's a side flash of the loader if you can see carefully. But yeah, so that's, that's pretty much what we need to do to get the database to save the chat logs. Alright, so we're almost basically done with the project, like the main functionality of the chat to BGF has been finished. We have been fully implemented by now. So the last part here is I'm going to teach you how to implement Stripe into this product to really make it into a software as a service for you to market it and improve on it. Okay, so the first step to integrating Stripe is let's install the Stripe package. So we do npm install Stripe. Okay, then let us come down to, let's actually clear out all the files here so that we start fresh. Okay, so come down into your schema.ts here, we can create a new user subscription schema to store records of whether a user has paid for the pro subscription or not. Okay, so within your schema.ts, we can export a new, sorry, export a new table called user subscription. So export cons user subscriptions equals to a pg table, user sub, sorry, user subscriptions. Right. And then for within the object, the columns will have ID. So the serial ID, which is a primary key, we have a user ID, which is a var char of a user ID. And let us just give you a length of 256 characters. Okay. Then we'll have a sorry, we'll have to make this not now, as well as this issue has to be unique. Sorry, unique. Okay. Then for the user ID, we have a Stripe customer ID, right? This will be a var char as well. We'll give you a Stripe customer ID. And then we'll have a length of also 256. Okay, this has also not to be not now as well as unique. Okay, then we'll have a Stripe subscription ID. There's gonna be a var char of Stripe subscription ID. Let's give you a length of 256. However, this time, this few could be now. So yeah, but we still want it to be unique. Then we have a Stripe price ID, a var char map to Stripe price ID within the database. We'll give you a length of 256. And this could be now also. Then lastly, we have a Stripe current period n. Let's give you a timestamp of Stripe current period n. And let's make this nullable. So with that, out of the way, let's save this file. So we have created this user subscription table. So now let's actually push it to our database. So we'll do the same thing, mpx drizzlekitpushpg. So let me move myself out of the way, mpx drizzlekitpush with a pg command. So we have already done this before. So with that, let's just press enter and hopefully that it works. Okay, so changes has been applied. So perfect. So the migration has worked. So now let's close the terminal. So now a new table has been created within the neon database. Okay, so come on to your folder. Come on to your lib. Let's create a Stripe.ts. So this is going to contain our initialization of the Stripe library. So the first thing here is let's import Stripe from the Stripe package that we installed from npm. Then let's export const Stripe. It goes to a new Stripe. Stripe passing in the process.env.stripeapikey as string. And then the second object, the configuration will pass in the API version. Right, to be whatever they ask you to enter and type script to be true. Okay, so let me just spell this right const and save it. Alright, so to get the API key, let's come down to our browser. Go to Stripe console. Just search for Stripe console within Google and come down to the first link here, Stripe login, the dashboard. And what you can do is you can create a Stripe account if you have not. If you have, you just log in. So in this case, I have already signed in. Right. And the first thing you want to do is come down to the top left hand corner. So I'm going to zoom in a little. And then I need to create a new account and name this wherever you want. So I'm going to name it chat PDFyoutube. Country of operation, choose the one that you are based off, then create account. So you might need to enter your password sometimes to access the new part of the dashboard. So after creating the account, you should be able to be led to the developers page. Right. So come to press developers and you should be able to see your API keys. Okay. So this is the secret key. So we need a secret key. So review the secret key and just click to copy to your dashboard, to your admin, your clipboard. Then we have to come back to our env.env. So let me just come down here and let's do Stripe. So just enter Stripe API key. Let's enter it here. Just the SK test. Let's save it and let's close the file. Okay. That's good. So now when you come down to our folder, come down to our API and let us create a new folder called Stripe. Within that, let's create the root.ts. Okay. So this will map to slash API slash Stripe. So we don't be calling this backend, right, to actually create the payments and create the billing accounts. Okay. So with this, let's actually start writing a code for this Stripe endpoint. All right. So the first thing I want to do is export a async function called get. So it'll be a get request. So we'll do a try catch block. So the first thing we want to do is we want to get the authenticated user awaits auth. So this comes from Next.js. So we've done this before. We'll get a user ID. Okay. So now that you have the user ID, we can check for the user. Cons user equals to await a current user. So this is also a function from clerk slash Next.js. Then we're going to check if not user ID. That means they're not authenticated. Let's return a new next response telling you that is unauthorized and passing a status of 401. So if they are authenticated, let's actually check for the user's application. Have they subscribed to the account? So if they have subscribed to the pro account, that means they're trying to cancel the account or change their subscription. But if they have not subscribed, that means if there's no role within the database, that means we know that they are trying to subscribe for the first time. So let's get the cons user subscriptions. It goes to await DB from drizzle dot select dot from user subscriptions. So this comes from schema dot where equals so we check the user subscriptions dot user ID equals to the user ID pass in from clerk here. Okay, so if user subscriptions at index zero, right, and the end user subscriptions at index zero dot stripe customer ID. So if the customer ID exists within the database, that means they are subscribed, they miss they are trying to cancel, trying to cancel at the billing portal. Thus we gotta do get const stripe session equals to await stripe. So these from our libstripe dot billing portal dot sessions dot create, right, passing the customer to be user subscriptions index zero dot stripe customer ID. And then the return URL, let's just let's actually make that into a variable up here. So cons return URL to be process dot env dot next public URL. Sorry, this can be named to next base URL. So let's create that env variable. So let's put under here next base URL. So this is where we want it to redirect to if they cancel or if they finish the transaction in stripe. So for now would be HTTP localhost 3000. Then when we deploy the versatile, obviously we want to put it as the versatile URL. Okay, so let's save this. So this will be next base URL plus slash, right, so when to return it to the return URL. Okay, then after that, we can just return a next response dot JSON, passing the URL to be striped session dot striped session dot URL. Okay. However, if this is not the first, if this is not the case, that means is the users first time trying to subscribe. Okay. So if that's the case, let us do cons stripe session equals to await stripe dot checkout dot sessions dot create. So for the success URL, we can pass in just a return URL. Okay, for the cancel URL, we're still gonna pass in the return URL. Then for the payment method, payment method types, we're just passing one type which is the cart, which is an accept cart. Then for the mode, you'll be subscription, subscription. For the billing address collection, let's put it to auto. For the customer email, customer email will pass in a user dot email addresses. So one user might have a lot of email addresses. Index zero, we take the first one dot email address. Okay, then we will do line items. So this is a list of items you want to buy. So in this case, there's only one item, right, which is the subscription. So it will be price data, right, this could be object, the currency, let's put it as USD, like USD for the product data. So product data is going to be object, the name will be chat PDF pro with the description being unlimited PDF sessions. Then outside of the product data, outside of the product data, let us put unit amount to be 2000, which represents $200, not $200, $20 a month, then recurring will set to object of the interval, meaning the month. Okay, so you'll recur every month. So that's how the subscription works. And then outside of the price data, right, outside of the price data, we'll put the quantity as one. Okay, then finally, outside of the line items, right, so outside of line items within this array, right, we'll pass the metadata, right, passing the user ID. So we need this user ID because later on, whenever we finish this transaction, right, Stripe is going to send a webhook back to our API endpoint again. And within the endpoint, we need to be able to access who actually did the transaction. That's why we need this user ID metadata here. So lastly, after this Stripe session has been created, let's just return a next response dot JSON passing the URL to be Stripe session dot URL. Okay, so if there's any errors, let's just console dot lock a Stripe error, passing the error, and we'll just return a new return renew next response, saying that internal server error with a status of 500. Okay, so let's save this first. Okay, so let's actually try writing out, try using this endpoint in our web application. So if you come down to our chat sidebar, right, let's come down to our chat sidebar, chat sidebar, right, we have a button below here, below the strike button here, that actually displays our strike button. So what I'm going to do here is I'm going to wrap this entire thing into a, sorry, I'm gonna move this strike button outside of this. And let me give it a button. Okay, of class name of margin top of two. Okay, this button will have a class name of text white and bg slate 700. Okay, and then it's gonna say upgrade to pro. Okay, so then let's create a function for the work what happens when we click on the button. So cons handle subscription, right, what happens is we want to make it an async function. Right, we're gonna do a try cat. So let us have a sorry, what's the issue here? Okay, here should be like this. So we'll have a state for the loading state, right, when it's loading the back end. So first we will do set loading to be sorry, set loading to be true. Then finally, we want to set loading to be false. Okay. So what we're gonna do is new cons response equals to await axios.get slash API strike. So this will hit the endpoint that we set up here, root.ts, right. And remember, it's gonna return us with a URL. So whether it's URL from here or URL from here, we are ensured that there is a URL. So we're gonna do window.location.href equals to response.data.url. So this is gonna redirect us to the strike page. So if there's an error, let's just console.error the error. So let's save this and let's go back to our page. So I'm gonna refresh the page. And let's hope that the subscription button shows up and then it is able to show us a subscription. Okay, so we can see this upgrade to pro button working. So what I'm gonna do here is I'm gonna disable this button. Disable when it's loading. Okay, so I'm gonna save it. So then let me just refresh the page again. So I think it's just my computer being slow right now. So hopefully this will work. Okay, so let me just refresh the page. All right. So when I press upgrade to pro, I should disable and then show me and eventually lead me to the strike checkout page. So I'm gonna upgrade to pro. Okay, so right now obviously nothing is happening because I haven't bounded the onclick handler. So let me just do onclick. I'm gonna do handle sub description. So let me save this. So whenever I click on this button, I want to actually call this function up here to redirect me to the strike checkout page. All right, so let me just refresh the page again. So wait for next year's load. So then once he has loaded. So if I click on this button, it should lead me to the strike checkout page. So click on it. So now it's disabled. So it's loading the backend. Then it's going to create the strike checkout sessions and return me with a URL. Then it's gonna redirect me and replace this whole page with a strike checkout. So let's wait for the next year's route to come back. So then okay, see it works. So we can see that it's asking us to subscribe to chat PDF pro. And here we can enter all details. So once we enter it, right, it's actually gonna help us send a webhook back to our application. So let's set up the webhook. Okay, so I'm gonna come back here. Come back to our VS code. Come back to our directory. We need our app. Let's create another folder called webhook. Inside here, let's do routes.ts. Okay, so this route.ts will be the webhook that strike is going to send back to us whenever the transaction succeeds or whether it failed. Alright, so let us just do export async function post. It's going to take the request body. So this request is going to be made by strike myself. So that get the body equals to await request text, right, then we do const signature. So let's verify that the webhook is indeed coming from strike itself. So we take headers. So this headers function will be imported from next slash headers. So headers, so invoke it, then we'll do do caters.get, stripe, signature, string, right, then we'll initialize an event, let event to be a stripe.event. Okay, then let us do a try catch block. So event equals to stripe.webhook. So let's import the stripe from our lib folder. Stripe.webhooks.construct event, right, we're passing the body, the sick nature, sorry sick nature, as well as the process.env.stripe.webhooksecret. So I'll show you how to get the webhook secret in just a bit. Let's just code it out first, fstring. Okay, so we construct this event and save it to the event variable here. Okay, so if there's any errors, that means then the struct signature didn't come through, that means is something suspicious going on. So let's just return a new next response, right, that says webhook error, passing the status of 400. Okay, then lastly, we just need to come out of this. So we can check for the, we can check for the session, const session equals to event.data.object as stripe.checkout, checkout.session. Okay, so we need to check. So if the new subscription is created, we'll do, we'll save it to the database. So if event.type equals to checkout.session.completed okay, so if the checkout is completed, we can take const subscription equals to await stripe.subscriptions dot retrieve. Okay, what do you want to retrieve? We want to retrieve the session.subscription as string. Okay, then we'll do we check if not session dot metadata dot user ID. So remember this metadata user ID is what we pass in to the, to this metadata here. That's why we need it to show here. So if the user ID does not exist, what we gotta do is we're gonna say that, okay, something's invalid, we'll do return new next response, saying that no user ID. Okay, then if everything passes, we'll just insert into database. So in await DB dot insert user subscriptions from the schema dot values. So we want the user ID to be the session dot metadata user ID. Right, then stripe subscription ID will be the subscription ID, stripe customer ID will be subscription dot customer as string, then stripe price ID will be subscription dot items dot data index zero dot price dot ID. And then lastly, we have the stripe current period n, which will be a new date and we'll initialize it to subscription dot current period n multiplied by 1000. Okay, so we've inserted into the database, right? So if it's not the subscription created, that means the payment has succeeded. So we gotta check if events dot type equals to invoice dot payment succeeded. Right. So if this is the case, we do const subscription equals to await stripe dot subscription dot retrieve, we're gonna retrieve succession the subscription as string. Okay, then we're gonna do await DB dot update user subscriptions, right? We're gonna set, we're gonna set the stripe price ID to be subscription, sorry, sorry, subscription dot items dot data index zero dot price dot ID. Then we set the stripe current period n to the new date subscription or current period n times 100. So it's the same thing as above, but we're just updating the current row. Right, we want to update it where the user ID, sorry, the user subscription dot stripe, stripe subscription ID equals to the subscription ID. So we're basically, we're gonna look at the subscription and we're gonna update the database based on the where cost here. Okay. Then finally, this is the most important part when the return a new next response, right, of now and 200, sorry, and the status has to be 200. So the status has to be 200 so that the webhook knows that it has finished its job. So if you don't return this status of 200, start noting that something is went wrong and you keep sending your sending messages to your endpoint until it gets a success back. So that's what the status 200 is for. Okay, so now that we got this, let us actually add one more thing. So come back to your middleware.ts. We need to add one at this root to the, we need to add this middleware slash epa slash middleware to the public root because stripe will be the one that's hitting this middleware. So we need to be public. So let's save it. And lastly, let us go into our stripe, stripe endpoint, stripe console here. Come up to webhooks, come up to webhooks here, and you will need to be able to test it here. So what's the, what's the issue here? So let's cancel this. So I'm just gonna stop my Next.js server for right for now because it's getting really slow. So come back to your stripe, stripe console. Okay, so what we're gonna do is come down to webhooks. We're gonna test, test in local environment. Okay, so the first step here is to download the CLI. So you can follow the instructions depending on whether you're on Windows, or you're on Mac, or you're on Linux. So for me, I'm on Mac, so I did brew install, right? If you're on Mac, you can just follow the instruction here, Windows. So after you have installed the stripe CLI, come down to your terminal and do stripe login. So come back to your VS code instance, and just do stripe login. So it will ask you to open this link within the browser to verify that you are trying to test your stripe webhook. Then just click on allow access. So then you are logged in within the command line. So see that the CLI is configured. The next step here is stripe listen too. So let me copy this command when you modify it. So it's saying that which, where is our API, where else was webhook listening on? So we're listening on localhost port 3000 slash API slash webhook. So this corresponded to our webhook here. So then I'm going to press enter, and basically it's going to set up a local testing environment for our stripe. So you can see this, it has given us our webhook signing secret. So I'm going to copy this whscc all the way to the end, copy it, come out to our.env, right, and then just paste it here. So next, sorry, it should be stripe webhook signing secret, paste it in here. So make sure this variable is here, and then we'll come down to our webhook. So we can see that we have this stripe webhook secret right here, right? So make sure that whatever variable here corresponds to whatever you have within the.env. So then once you have that, let us save the file, and then we can actually test out the webhook signing. So I'm going to come up, I'm going to open the terminal up bigger, I'm going to start my dev server running again. So what this is going to do is once we complete the checkout on the stripe page, it's going to send a webhook to our API, it's going to send a webhook to our endpoint, then we're going to create a row in the database, and then based on that, we can then check whether the user is subscribed to us. So come back here and refresh the page, wait for next year to compile for me. Okay, so S is compiling. Okay, so everything is up and running again. So I'm going to press upgrade to pro, it will then lead me to the stripe checkout page. Okay, so then I'm going to enter test credit card. So because we are testing, I can enter something like 42, 42, 42, all the way. The same here, I'll just give it my name. And let's press subscribe. And I need to look carefully as what happens to the backend. So if everything goes well, we should see 200 requests. Oh, 401. Okay, so my mistake, I made a mistake here. This should be access API slash webhook, right? It's not API slash middleware, so that's my mistake. So let's save this and let's try again. So this 401 error is unauthorized, right? So let's try again. So I'm going to go to my, the go to chat is not finished implemented. So let's just manually go to our slash chat slash one, right? Then what I'm going to do is come down to our subscription. Okay, so let's try again. So I'm going to press upgrade to pro, then it's going to send me to the stripe checkout page. And I'll try again, right? So four, two, four, two, four, two, all the way. My name, subscribe. So by right, if everything goes well, now we can see, we should be able to see 200 requests coming in. Oh, 404 still 404. Okay, there's yet another very, very silly mistake, right? So we can see that, uh, let's actually, let me save my ENV file here. So the silly mistake that I've made here is that you can see that, uh, this webhook, right, it has been placed in the roots app folder, whilst this, uh, webhook, uh, folder should actually be placed within the API folder. So I'm going to move it up here, move it up into the slash API folder, uh, move it up, this should be placed in the API folder, not in the app folder. So I hope you didn't make the same mistake as me here. So I'm going to put it in. Okay, so, uh, because it is file based routing, right? So this webhook has to be placed within the slash API folder. So let me try one last time. So hopefully this time everything will work. So let's go to, okay. So let me just upgrade to pro. All right. So let me test one last time. Hopefully this time it will work. So four two, four two, four two, four two, four two, four two. Subscribe. So if you look at the backend, this time it should return us with 200 response. And let's see if it works. Let's wait for a while. So it's combined. Okay. Yeah, it works. So now it returns with 200. That means everything is worked. Everything works perfectly. And now if we go look into our database, we should be able to see the, um, we should both see the role. So right now let's create a utility function to check whether a user is subscribed to the pro account. So come under to your, uh, come under to your, I see, uh, your lib folder and let's create a file called subscription.ts. Okay. So for this subscription.ts, uh, it will, we have to check whether the row exists within the database. So what we're going to do is first, uh, export a function called check sub description. It's going to be an async function. Okay. So the first check, if they're logged in, away it's off. So this is from a clerk, right? This is from the clerk itself. Uh, that's imported slowly. Then we'll get a check, uh, get a user ID out of it. We got to check if not user ID, we got to return false. So if they're not in, obviously they're not a pro user. Okay. Then we'll get all the current, we get the user subscriptions. So user subscriptions from await DB dot select. So this DB comes from our lib slash DB as usual. Dot select. Dot from user subscriptions. This one will come from our schema where equals to the user, correct. So I'm looking at user subscriptions dot user ID equals to user ID. So let's save this. So this just merely checks for whether the row exists. So if not user subscriptions index zero, right? Then we know obviously is false. That means they are not, they do not have a record database. So they're not subscribed. Okay. So let's get the actual user subscription from, uh, underscore user subscriptions index zero. Okay. Uh, and then we can do cons is valid. It's going to be user subscription dot stripe price ID. So they must have a price ID that exists as well as the user subscription dot stripe current period n dot get time, right? Plus a plus, let's define one, one variable up here called cons day in milliseconds. So how many milliseconds are in the day? 1000 times 60 times 60 times 24. So if the current period n plus one day in, in milliseconds, so give them a one day buffer, if it is bigger than date dot now, that means it is still valid, right? So if it's valid, if both of these, uh, statements are valid, right? So if the stripe price ID exists and they still have, they're not, their expiration is not over, then we want to return not, not is valid. So this converts it into a Boolean. Okay. So this function is exist now for us to actually check whether the user is subscribed to a chat PDF pro. So the last step here is to actually, let's come back down to our app dot TSX. So the main page here. So above here, remember here, we asked to put the, this go to chat here. So, uh, underneath here, uh, underneath here, let's add the subscription button. Okay. So let's actually get the, whether they are pro account first. So we can check is pro is pro equals to await check subscriptions. Okay. So this subscription obviously is imported from our, a, our check subscription file. Then we could create a new, uh, component called sub script button dot TSX. Okay. So this subscription button is going to take in a few things. So we do T S R A F C first. So it's going to be a client component. All right. So this will take in, uh, this is pro. It's going to be a Boolean, right? We're going to check, uh, we're going to have a loading state for this, right? So we can return a button, right? Imported. Just disable when it's loading. That's going to say that if, if props.is pro, right, we're going to show manage subscriptions. Otherwise we're going to ask them to get pro account. Okay. So then cons handle subscription. So we can copy this code, uh, cons handle subscription from the, uh, chat sidebar, right? We can see that we have this handle subscription. So let me copy this and let me paste it in here. So it's the same code here. So then we just, whenever they click on this button, we just want to handle, subscribe, handle subscription, right? And those sub script. All right. That's pretty much it. So let me save this. So let's import axios also, save it. Then we can come back to our page.tsx, right? We can then, uh, just import it. So underneath this go to chats button, uh, under this go to chats, let us put the subscription button. So we have a div that says margin left of three, and we have the sub script subscription button from our components and we'll pass in the is pro pro is pro passing the is pro. So this comes from a check subscription function call. Okay. So, uh, if everything goes well, right, we can now see that there should be a subscription button that shows up here. So let's wait for it. So in the meantime, let's talk about how do we implement this go to chats feature. So we need to, when you get the first chat within, uh, database, right? So we're going to get ID of the first ever chat and then we'll link it there, link it them there. So how do we get the first check, right? We're going to check, uh, let's first chat. We're going to check if user ID exists first, then we'll do first, uh, chat equals to await DB dot select dot from chats for these from unit user schema dot where the equals where chats dot user ID equals to user ID. Okay. Then if first chat exists, they want to set first chat to be first chat index zero. So this variable here returns us with an array with a list, but we want to get the first element here. So the first check they have of what this user, then we got to check here. If, if it's off and the first chat exists, okay, then we can show this button that goes to chats. However, this button will wrap it in a, uh, H ref tech, a link tech. So let me just do here, like here. So let me just import the link component, uh, link component. I'll wrap the button in here. Okay. So wrapping this button here, this link will obviously go to, uh, sorry, such chat slash first chat dot ID. So it leads us to the first chat ID. So let's save this file and then let's come back to our thing. So right now I see these go to chats. So let me just add one more thing. Let me add one icon to make it look nicer. So for the icon, I'm going to choose the arrow, right icon. So let's get the arrow right icon moving. Oh, it's really lagging really bad in here now. So, uh, arrow, right. So import the arrow, right icon from Lucid dash react. Let's give you a styling of, um, uh, margin of two. So let's save it. Uh, let me just remove this. Okay. Save it. And hopefully there should be an arrow that pops up and then we'll be able to start it properly. Right now, if you go to, go to chats, it will lead us to the chat page, right? So let me go back here and right now, because we are pro, you ask us to manage subscription, right? So right now if we press this, there is going to be an error, right? Let's look at the error and I'm going to explain how to fix the error. So the error is that, uh, we need to enable the billing, uh, test, test website. So let's look at, look at the console for the error. So, okay. So this error, so scroll up to the error. They should, they should tell you that, uh, you can create a portal session in the test mode until you save your customer portal session. So just click on the link here that goes to test settings, uh, billing slash portal, open it in your, uh, in your browser. So it opened on my other browser here. I'm going to bring it up here. Uh, okay. And then all you need to do is just, uh, enable the billing portal by clicking the button activate test link. Okay. So that's all that you need to do. Then close it off. All right. Then just come back to your thing here. And if you click on manage subscription, this time it should work properly. So it will link me, it will lead me to the billing portal where I can manage my subscriptions. Okay. So that's also working perfectly. So everything is working fine. So here is where they can manage their subscription, like canceling and yeah. So let me just return to chat PDF. So the go to chat function will also work. So I think that's pretty much it. So the last part here is just to, for this upgrade to pro account in our chat sidebar. So let me close this off, come back to my chat sidebar. Okay. So for the chat sidebar, I'm going to do the same for my, uh, for this button here. Uh, I'll wait to pro. Uh, yeah, that's pretty much it. That's pretty much it. So for this button, I can actually replace it with my, uh, subscription button imported from my component. So we pass is pro. So how do we get the is pro prop? Uh, we can get the is pro prop from the prop here. So let's just do, uh, is pro. This will be a Boolean. Then let us destruction is pro. Okay. Uh, then let's come down here. I'll pass this is pro into this component. So for this subscription button, this is pro, we need to go back to our page or TSX in our chat ID, right? This is where we are rendering this chat sidebar component, right? So now we require a, uh, is pro prop here, uh, is pro. So let's get back to is pro by doing cons, uh, is pro equals to await check subscription. Okay. So let's import this from our subscription dot TS a lip file. So let's wait for it to load, check subscription and invoke it. Then we can pass the is pro prop into the chat sidebar. So then we save it and then that's it for the progress. Okay. So I think that works perfectly. Everything is done. So that's it. So all right. So we are complete down with the project. And so now I'm going to teach you how to deploy it. All right. So come down to your, come with, let's go make a new gate repository from this repo. So come down to your terminal. So I'm going to stop everything that's running first. I'm going to stop the server, stop this or so exit. So I'm going to do, uh, let me just do this. Let's do get status. So we can see that we are going to try to comment all these files here. So let's do get at dot gets comment dash am initial comment. All right. Come down to your browser, go to github.com slash new. So let's, let's create a new repository together. So here you just name it wherever you want. I'm going to name it, uh, chats, PDF dash YouTube. Okay. Uh, just put it as public and create the repository. So you just need to follow the steps that GitHub ask you to do. So we have already added and committed, right? Rename your branch and then go to copy the remote origin. So let's add the origin and finally let us push it up to min. So git push dash new origin min. So that will push up all our code to the GitHub repo. So now if we refresh, uh, this page, we can see all our, uh, this, we can see that all our code is being pushed up. So now all we need to do is come down to, uh, resale, resale.com. Add a new project. So add new project and what you can do is import your chat, uh, chat PDF dash YouTube for the project name. And for this environmental variables, come back to your.env file. Okay. So I need to copy up everything except for this next base URL right here. So copy from all the way here, all the way up, copy this. Okay. Then paste it into my in V variables. So the last thing here is I need to add, uh, sorry, I need to add this, what's it called next base URL. So let's copy this. So let me add the next base URL and this will be later on will be changed on, this will be later changed to whatever versatile gives you. All right. So let me just delete this so that we can deploy first. So for now we do have to add that URL, but later when we deploy, once we get the versatile URL, we can just place it back there. So I think that might be an error, but let's see as it builds. Okay. So the project has been deployed successfully. All right. So let us go to the continue dashboard and let us actually try out ourselves. So I'm going to visit this domain. So this is the URL that we need to place into our next base URL later on. So for now, let us actually log in to get started. So I'm going to click on it, log in. It will bring us to the, the clerk page. So I'm going to log into my, with my Google account and just log in with my here. And so it will lead me back to my, to the homepage where of hopefully I'll be logged in. Okay. So that's good. So right now I can see that my chats are great. So let me go to the chat page so you can see the chats being shown here. So let me create a new chat by dropping a new PDF here. So let me drop back in the edge runtime docs to make sure everything's working. So hopefully that this will work. So I'm going to show you how to actually add one more configuration to your versatile app later, but let's see if this works. All right. So it works check created and we can see that the runtime works. The PDF is here. And let's ask a question. Let's ask how to use the edge runtime question mark. So this should give me a response in, in regards to the PDF. Okay. So correct. These are all pulling directly from the versatile docs. You can see that it says versatile in it. So we know that things works and everything is perfect. So the last thing here is let us change the environmental variables for stripe and for the base URL. So come back to your, uh, versatile dashboard. Okay. Come down to your settings, come down to your functions, right? Choose a function that is nearest to you. So choose for me in this case will be Singapore. Okay. Save it. So this is where all my serverless functions will execute. So obviously you want to choose one that's nearest to you and your users so that the response time will be fast. Okay. So with that out of the way, let us come back to our general, come back to our environmental variables, right? So we need, uh, so remember that we have this next base URL. So let's fill that in right now. So let us add a URL called next base URL. So this we can just copy from the base URL URL here. So copy here and let us just paste in the value here. Okay. So I'm going to save this file. Okay. And also for the, for the strike webhook, I need a secret. Come back to our dashboard here. Okay. Come back to webhooks. All right. We want to now add an endpoint. So this endpoint will be at our versatile URL slash API slash webhook. Right. And we want to select events to listen on. So what events are we listening on to our webhook? So remember we are listening for checkout section completed and invoice payment succeeded. So let's add these two endpoints. So first will be, uh, checkout dot sessions dot, dot completed. Right. And also we have a invoice dot payment succeeded invoice dot payment dot succeeded. Sorry, invoice dot payment underscore succeeded. Okay. So it's just these two, uh, these two, uh, events that we're listening on. Then we'll add the events and then, uh, that's pretty much it. Then you can just add the endpoint and everything will work perfectly. So now we will get this signing secret, which we'll have to, this is the actual official one. So copy this, come into our inview variables, come into our, uh, strike webhook signing secret and let us edit this. So just replace it with the one that you pasted in, copy it, press it, save. Right. And one more thing I want to change here is now the button looks kind of ugly within the chat here. See this menu subscription. So I'm going to just change that by going into our subscription button. So I'm going to change this, um, button to a type variant of, sorry, variant of outline. So I'm going to save it and I'll push the code up to my repository. So I'll just put change button, commit and push. So whenever I push, uh, results automatically going to detect, there's a new changes. It's going to redeploy the entire application for me. So we come back to our original Versailles application, right? Come back to our deployments and we're able to see it has detected that we have a new, uh, commit code change button. So if we come into our, click onto it in here, we're able to see the deployment status, the commit change, right? And let us click into it so that we can see what's happening. Okay. So now we just have to wait for it to deploy and then everything should be up and running and ready to go. Okay. So now that it has finally deployed, let us receive the original page. So let me just go back to our original, uh, homepage and everything should work fine. Yes. So now we have, we changed the button. So we go to chat, at least a button doesn't look, uh, that ugly anymore. So I mean, you can start it further, but in this case, I'll just leave you up to you. So yeah, we have completed this whole project. I'm very happy and very proud of you for staying all the way to the end and falling true with this project. And yeah, you feel free to continue improving on this project and eventually turning it into a realsense product where you can be really making money off of this. So I hope you have learned something from this video. So today I taught, um, I taught mainly about AI, right? How to use a retrieval augmented generation to feed in proper context into a chat GPT, right? So I hope that this has been helpful to you. And if you have learned something new today, uh, please do like comment and subscribe on this video because I put it, I mean, apparently a lot of effort. I hope that you actually learned something and I provide a value to you. So with that, thank you for watching and have a good day.