hey folks we are back again with another c plus plus audio tutorial today we are going to build this plugin from scratch using modern c plus and the juice framework check the description for links to the repository and to download the final build okay what is this thing this is the little brother of my new audio plugin and course for programming for musicians where you can learn to build these other plugins also where you can learn modern c plus and the juice framework taught from the context of writing audio software in a mentored environment in programming for musicians you are not following videos you are not watching someone else code and you are not copying them either you are coding it yourself from a design spec and i'm reviewing your work every step of the way alright enough about those let's learn about what we are going to build today this is a 3band compressor audio signal is split into three discrete bands and compression is applied to each band separately the bottom of the gui contains the controls for the selected band you'll find standard compressor controls here attack release threshold and ratio on the right side you'll find buttons to mute solo or bypass an individual audio band these buttons are helpful for dialing in an individual compressor or hearing how it is affecting the overall audio signal the band select buttons are on the left these control which compressor is being controlled remember we have three of them in the middle of the gui are the global controls you'll find input trim on the left crossover controls in the middle and output trim on the right crossover sliders control where the audio is split into the 3band the top portion of the gui features a spectrum analyzer which shows us what we are hearing where the crossovers are in the frequency spectrum and what our thresholds are set to as well as the current gain reduction per band at the very top of the gui you'll find the analyzer bypass button on the left this button turns off the fft analysis in the spectrum analyzer finally we have the global bypass button on the right which disables or enables all three compressors simultaneously we are going to learn to build all of the dsp that's going on in the background we are going to learn how to build this gui okay that's the feature set for this plugin and for this course my name is chuck i go by the name matcat music on youtube instagram and twitter once again check the description for links to the repository and where to download the final builds let's get started and write a multiband compressor using modern c plus plus and the juice framework from scratch welcome to this tutorial teaching the simple multiband compressor if you happen to get stuck during uh any part of the setup or in the actual tutorial itself grab any free product from programming for musicians you will be sent an invite link to a slack workspace where you can send me a message directly i will help you get unstuck we can work on error messages if you have setup issues that sort of thing all right on with the show hey folks welcome to this tutorial documenting how to build this threeband compressor before we start building anything we need to have a working development environment that is what we're going to do first i'm going to show how to do this for mac and then how to do this for windows here is what we are going to accomplish in this first part of the course we're going to install the ide which could be xcode or visual studio we're going to clone the juice framework we're going to build producer create a project and then create a repository for the project then we're going to build and run the standalone app version of the project then we're going to set up audio plug and host we're going to configure the ide to launch audio plug and host whenever we build and run the project then we're going to configure audio plugin host so it can load our plugin and set up a filter graph so audio will run through our plugin then we are going to set up an audio file player so that we can actually play audio files through our plugin then we are going to configure audio plugin host to use the audio file player plugin to send audio into our plugin and out to our sound card if you are a windows user you can skip ahead to the time stamp shown below for your steps all right let's begin the first thing we need is xcode now i have already downloaded and installed xcode but if you haven't there are two ways you can get it number one is to get it from the app store just go here and search xcode oops search here xcode this is going to get the version that is the most recent version that is available for most people to get if you have an older computer the other way you can do it is to grab a apple developer account these are free you only need to pay for the account if you are code signing okay so if you don't um if you're not planning on signing any of your binaries you can just go to developer.apple.com developer.apple.com uh sign up for a free account and then uh sign on in all right once you are signed on in go to downloads click on more and then search for xcode all right you will see all of the versions of xcode that have ever been released xcode 11 12 13 keep scrolling on down there's 11.7 there's 11.4 xcode 4.6.2 xcode 10 11. all that stuff so if you're running an older version of mac os and you cannot get um you cannot run xcode 12 or xcode13 this is what you can do we have successfully grabbed xcode and our next thing to do is to clone the juice repository navigate to juce github.comuce framework slash juc we are going to clone using fork which is a get gui you can grab that from https colon slash fork dot dev once you've got fork go ahead and launch it now we need to configure where fork looks for all of its repositories so go to the fork menu go to preferences and you're going to specify the default source folder in my case i am putting all of my code here in my users folder in a folder called programming okay once you've got that configured you can go back to we can close this we can go back to github we can copy this url right here click the green button for code um copy this url and then go to fork file clone it's going to automatically populate this url if it doesn't that's fine you can just paste it click clone now if fork if you're running an older version of mac os and it throws some kind of errors at you you need to install the swift runtime so again you can grab that you can grab that either you can grab that from the developer your developer account go to your account go to downloads search for more and swift somewhere in here is it here there it is swift's uh runtime support for command line tools this is what you need to install that will make fork run again this is only if you have an older version of mac juice has been around for like a decade or so i'm not quite sure how long um by default it checks out the master branch but the master branch there's quite a few commits that have happened between when the master branch was released and when the developer branch which contains the most recent fixes had its most recent commit push to it so we want to check out the develop branch so go ahead and double click on origin developer that'll check out a branch and now we've got the latest set of changes in producer all right our next step is to build producer which will create juice projects for us okay so just click open in finder your little button right there navigate to the juice extras folder the producer folder and the builds folder and then mac os x double click on the juicer file this is going to open up xcode if this is the first time launching xcode it may ask you to install it may ask you to install additional command line tools just click yes and then get it to this point all right i've already built this a few times because i was doing test runs in this video what we want to do is go to the product menu and choose build now we can watch what it's doing uh during the compilation process by clicking on this button right here of these buttons right here it's the rightmost one and just click on this and it will take us to this report showing us what is being compiled while it is being compiled we just need to wait for it to finish all right currently compiling gui basics linking signing there we go build succeeded all right we are done with xcode for right now go ahead and close the project all right navigate to the builds folder in the debug folder is where you will find the produced binary double click on this to launch producer producer is here now the first thing we need to do is turn on gpl mode if we go to file by default it might be on it may not be on choose sign in and select gpl mode now the next thing to do is to customize where the juice paths are because this was cloned to the to a location other than the users folder pro juicer is not going to be able to find the modules so go to the globalpaths menu choice under producer and we need to set our path to juice okay so that's over here and all we need to do is find our juice folder which in my case is in this programming directory matcap music programming there's the juice folder whoops mad cat music programming juice open all right now we need to do the same thing for the juice modules modules are found inside of the juice folder so we just need to navigate to that and then choose open again this is like programming juice modules okay once we've done that we're good to go here now we can create an audio plugin in the simple eq video there were a lot of comments of people who created an audio application we do not want an audio application we want to create a basic plugin okay the first thing to do is set the name we're going to do simple mb comp short for simple multiband compressor and click create project we just need to choose a valid place to save the project so i'm going to save it into my programming folder okay next we need to make sure that the plugin copy step is enabled so click on exporters click on debug and scroll down for the plugin copy step make sure it is enabled all right the next thing to do is to set the c plus plus version to c plus 17. click this little gear icon for project settings and scroll down to the bottom and then up a little bit we can change the c plus plus language standard here change it to c plus plus 17. finally let's set the company name that's up at the top i'm going to put matcat music llc when we scan for plugins in audio plug and host this is our plug this is how our plugin will show up it will show up under the name of whatever we put here all right now we can click save and open in ide let's create a repository next let's go over to fork in fork we're going to choose file create new local repository and then we just need to pick this directory notice that there are a ton of files that are unstaged okay we need to customize the git ignore file for this project and we're doing this because we don't want any of these files that producer automatically generates every time we save the project to be stored in the repository again they're autogenerated so there's no reason for us to keep track of how they changed okay so right click on one of these files i'm going to right click on this builds directory and choose ignore custom pattern now i'm going to type some stuff here the first thing i'm going to type is star star slash builds that's going to ignore everything in the builds directory next i'm going to just type star star whoops star star juice library code that's going to ignore everything in the juice library code folder and then because this is mac i'm going to type star star dot ds store that's going to ignore the ds store files which are generated by mac os every time you customize the view of a folder all right add to git ignore now we only have six files awesome we've got our four source folders and our ignore file and then the juicer file for the project now we can stage these by clicking this button right here to stage all and now we can make our initial commit initial commit all right every time we click save and open in ide it's not going to produce new changes it's only when we change source code that it will do that all right we can go back to producer and we can choose save and open in ide let's build and run the standalone app version first of all change the scheme right here to the standalone plugin and then click the play button to build and run all right we can watch the build happen again go to the report navigator click on the entry with the spinning wheel all right build succeeded we're waiting for it to run this is the default audio plugin that comes from producer running within a standalone plugin app it is our job to customize the dsp and the graphics but let's not get ahead of ourselves we need to set up a test bed that we can use to run audio through our plugin so let's set that up next go ahead and close this all right we can close this project as well close project if you uh were not aware i am doing this in a virtual machine that has nothing set up in it um that's just to show you if you've never done this before here's how you can get set up real quickly show me later never okay all right the first thing to do is to set up audio plug and host we need to navigate to that folder okay so users folder programming it's inside the juice folder it's under extras it's audio plugin host open up the juicer file save and open in ide and build it product build linking build succeeded okay close the project once building is complete we are going to configure our plugin project to launch audio plugandhost every time we use the vst3 scheme all right we can close this juicer file let's go back to our simple multiband compressor and open this up all right we can make this full screen now go to the xcode project we're going to edit the vst3 scheme okay click on this guy to select it and now edit the scheme all right we're going to change the executable from none to audio plugin host so choose other and we're going to search for audio plugin host there it is click choose now let's see close this now we just need to run this and that's going to launch audio plugin host well first it has to build the vst3 version linking build succeeded okay launching audio plugin host there's audio plugandhost yes you can use my microphone okay the first thing we need to do is configure audio plugin host to load our plugin go to the options menu and click edit the list of available plugins we're going to scan all right so choose options and scan for new or updated vst3 plugins that's fine there's our compressor right there simple mb comp okay we can close this window now that our plugin has been found we can load it into the filter graph so rightclick select it from the popup again this is where you set your company name and there's your compressor now if we double click this it looks the same as the standalone version cool let's wire it up to the output go like this click right there click right there and drag that okay right now any audio that our plugin produces will go to the sound card all right now we're not going to hear anything because there's nothing feeding audio into our plugin so let's do that next and then the other thing is if we go to options we can change our audio device settings again i'm running this in parallels so it's using a virtual machine and the virtual machine devices okay let's set up audio file player next we can save this and we want to save this into our we want to save this with our project so let's see where's my documents full not documents we want to save this with our programming programming simple multiband comp this is like um simple mb comp test testbed cool that'll work we can quit audio plugin host for now in the previous tutorial video that i created the simple eq tutorial i used apple's au audio file player let me show you what that looks like let me see if that's even on here hey i just wanted to interject i'm editing this video the next day the au audio file player does show up on a default installation of mac you just need to scan for audio units and it will be there so if i do that then i can scan and it'll show up under apple au audio file player there it is okay this is what i used in simple eq all right i just wanted to let you know that this stuff does come on here if you do have um a fresh install of the operating system you do not need garageband and you do not need logic to access this this comes with the operating system this time we're going to use the audio file player plugin that i created this plugin is a port of the juice audio playback demo app to work as an audio plugin the demo app if you're curious you can go to file open example audio audio playback demo and this is an actual audio application so what i have done is i have ported this into an actual plugin that you can use in your daw in audio plug and host on mac and windows to handle all of these playback duties so we need to go grab this let's close our project for now it's close we're not going to close that we need to go grab it so let's open up our browser we're going to navigate to github.com mathcat music slash audio file player this is what we need to clone so click on the code button copy it and then clone it in fork file clone paste that url and let's clone it all right successfully cloned now we need to compile it open in finder let's go to our audio file player audio file player.juicer save and open in ide it's going to launch xcode we just need to build it and it's going to build um all of these it's going to be able to the standalone version the vsd3 and the audio unit build all right cool once it's built um we should be able to launch audio plug and host and uh be good to go so close this project we can close audio let's not close it yet because we may need to um do it again let's open up our simple mb comp all right let's run it and now we are going to scan for audio file player all right options menu edit the list of available plugins options scan for new or updated vst3 scan there it is audio file player perfect close this window right click mat cat music my company name audio file player here's the audio file player double click it to view the gui now we just need to wire up the outputs of this uh to the inputs of our simple multiband compressor now let's just add an audio file we can either drag one in or select something from here and if it prompts you to grant permission uh to the desktop and the documents folder in the music folder just click accept that's all it's you know mac security stuff let's press play to hear the audio file awesome there we go let's push stop all right save the filter graph now audio plug and host is configured every time we run the vst 3 version of the project audio plugin host will launch and it will load our plugin and it will load this audio player let's go ahead and quit this and show what i mean we run this it's gonna launch there's our audio file player plugin and we can just stream audio right into the plugin all right perfect we are ready to start coding up this plugin mac users you can jump to the time stamp shown below to start the tutorial that actually codes up the plugin windows users we are going to cover setting up your system next all right windows users as a reminder i am using windows 10 inside of a virtual machine on my mac i am doing this to show uh how to get started using a relatively fresh and clean operating system installation and also because i love the pain of using windows 10 in a virtual machine sad face okay ah let's dive in the first thing we need to do is grab visual studio community from the website not visual studio code but visual studio we can get the community edition just go up here and just google for it visual studio community all right we want the 2019 community edition go ahead and download it once you have that then resume this video okay once you have the installer downloaded go here and run the installer and we need to configure it to build c plus plus apps if you already have visual studio installed but you're using it for javascript or c sharp or something else but you don't have c plus plus installed run the installer and set it up the way i'm about to show you once this thing launches in 10 minutes so we have this here uh visual studio community 2019 click the modify button and what we want to do is set it up for c plus development so go to here desktop development with c plus make sure that's enabled and what you want to configure um you're going to want clang tools you're going to want the address sanitizer you're going to want intellicode you uh we don't need live share we don't need test adapter for google tests we do not need boost.test we need a latest we need the latest v142 build tools we need we don't need cmake we need the profiling tools we need the just in time debugger we need this guy and we need this guy all right so set your thing up so that way it's got these and then um just click install while downloading all right once everything is installed you can quit visual studio the next step is to download the juice framework or sorry not download but clone the juice framework okay we always want to clone it so we have access to the repository history so the first thing we're going to do is we're going to use fork which is the get gui to interact with this repository so you can get that if you open your browser you can grab that from fork.dev it's available for mac and for windows okay so you can go ahead and grab it here download fork for windows okay once you've got fork installed we need to configure it to store everything um in our preferred location any repositories that it clones all that sort of thing launch fork go to the file menu go to preferences and we need to specify the default clone folder i like to keep things in a folder called programming i have it right here on my desktop you know i could move it somewhere else but for the sake of this tutorial it's right here on the desktop so i just navigate to that you know click this folder button find where i'm going to put it basically anything that i'm going to clone is going to go there so i'm going to put it on the desktop programming like that select folder okay now anything that i clone is going to go into that folder in its own repository now we need to navigate to the juice framework and get the url for that so open up your browser open up a new tab then visit com github.com juice dash framework work juce in all caps here's the juice framework now we need to click this code button right here click the copy button and go back to fork and now we can do file clone it's going to auto populate this repository url and it's going to save it into the programming folder that we requested click the clone button and you will be downloading a copy of the juice repository to your computer okay cloned alright perfect now we have a copy of juice on our computer the next thing to do is to build the producer which creates juice projects for us but before we do that juice is a pretty old framework by default the master branch or main branch is checked out however there have been several commits since the most recent branch oh spinning wheel a lot of things have been fixed in the juice framework since the master branch was last updated so we want to check out the develop branch okay so just double click right on origin slash develop and then it will prompt to create a branch and track the remote branch click the track button now we can open up producer and build it okay so click on this open in button right here and choose open in file explorer now we need to navigate to the extras pro juicer navigate to builds visual studio 2019 and then we're going to open up this solution file we can just go to the build menu and choose build solution this is going to build producer for us now we just need to wait for it to finish compiling all right build succeeded fantastic we can close the visual studio project now now we can create a plugin project next navigate to the x64 folder click on debug click on app and now we're looking for producer.exe there it is all right double click it to launch now if this is the first time you are using producer it's going to ask you to sign in we want to turn on gpl mode if this is not the first time you've probably already set it up but normally what you will see you'll go to the file menu you will choose sign in it'll show this thing you can if you have a juice account you can set that up or you can enable gpl mode now gpl mode has the requirement that we make our projects open source so uh yeah make your project open source okay in the simple eq project a lot of people left comments that they created an audio application or they were missing um they were missing the plugin processor file and that's because they created an audio application instead of a plugin instead of a basic plugin so for this you definitely want to make sure you are definitely going to want to make sure that you choose plugin category and that you choose basic all right first thing that we need to do we need to give it the name simple mbcomp and then create project oh i'm sorry before you do that if producer says you need to set your paths because you had downloaded juice to a directory that's not the standard directory it's expecting go here under the file menu go to global paths and then customize these paths here this is what i'm talking about when you install it to the default location it's expecting juice to go in a folder on the root level of your hard drive so obviously i put mine in this programming folder on the desktop so that is not where my juice folder is and that is not where the modules folder is so i'm going to click these three dots i'm going to choose the juice folder and then select folder and i'm going to do the same thing for the modules the modules folder select folder and i can close this window now all right now i can create this all right i want to put this in my programming folder with juice and the other stuff i've made this is going to create the project the next thing that we need to do is enable the plugin copy step this is going to copy the plugin when we compile it to the folder that most hosts you know reaper cubase ableton they're all looking for plugins in this one folder so this is going to enable copying it there automatically in this view click on exporters click on debug scroll down to the scroll down a little bit and you'll see where it says enable plugin copy step make sure this is set to enabled all right we'll figure out where this actually gets copied to in a little bit next we need to um change the c plus version so go up here go to let's see this is down at the bottom of this list okay scroll all the way to the end then scroll up a little bit and change the c plus plus language standard to c plus plus 17. all right next we want to supply our company name so let's do that first i'm going to type mine matcat music llc when we scan for the plugin in audio plugin host whatever we put here is the name that it's going to appear as it's going to show up as a sub menu under this name right here okay we may or may not need to set this using namespace juice so we'll come back to that first thing we're going to do is we're going to save and launch this save and open in ide this is going to launch visual studio we're going to find out whether or not we need to turn on that using namespace juice so go to the build menu and we're just going to try to build this real quick rebuild solution and if we get any errors about namespace stuff then we will turn that on let's see what happens okay cool all right so the copy step failed but we don't have any error messages relating to the namespace juice let's do the next thing which is to create a repository for our project first and then we will deal with this copy step all right we can close this for now okay to create a repository open fork and then do file init new repository and choose the simple mbcomp folder for the project now you'll notice that there are a ton of files here um listed under under local changes so we need to customize the get ignore file for this project and ignore all of this stuff the reason we are doing that is because all of this stuff gets created automatically by producer whenever we save and whenever we save and open in ide or when we compile like you'll see there's all these object files and stuff so we want to right click choose ignore custom pattern star star and for this we're going to type star star slash builds then and what this is going to do is it's going to ignore all of the files that are in the builds directory we want to do the same thing for juice library code so star star slash juice library code like that now if for some reason we want to migrate this project over to mac it's very handy to add star star slash dot ds store that's going to ignore any ds store files on mac these files control how the finders view looks basically if it's showing icons or if it's showing a list or if it's showing um if it's arranged by name or if it's arranged by day created that sort of stuff that information is stored in these ds store files okay add to git ignore you can see we only have the four source files our git ignore file and the juicer file now we can make our initial commit let's stage these by clicking the stage all button and now committing them initial commit now we can save and open in ide go ahead and go back to visual studio save and open in ide this will launch visual studio one more time okay on the right side is the solution explorer we want to right click on the standalone plugin and choose set as startup project okay now we can build and run it by clicking on this local windows debugger let's see if this throws an error with regard to the copy step or not it shouldn't because we're not spawning the copy stop version we're not spawning the vst3 this is the default audio plugin from producer okay it is running inside of a standalone app that is part of the juice framework that hosts this okay it is our job to customize the dsp that runs on our plugin as well as the graphics let's not get ahead of ourselves though we need to come up with a test bed so that we can actually run audio through our plugin that's what we're going to set up next all right close that close this let's go set up audio plugin host navigate to your juice directory navigate to extras navigate to audio plugin host navigate to the juicer file and open it up in producer save and open in ide build it build the solution okay build one succeeded zero failed awesome all right we're done with audio plug and host okay we can close the juicer file as well all right let's configure audio plugin host to launch whenever we have the vst3 as to startup project right click on the vst3 target go down to properties navigate to where it says debugging we're going to change this command so click on this arrow go to browse and we're going to look for audio plug and host all right got that build simple me comp navigate to the juice folder navigate to the extras folder audio plugin host builds visual studio 2019 x64 debug app and now audiopluginhost.exe click apply and okay now we need to change the target from standalone to vst3 change that to the startup project and now if we build and run it's going to fail on that copy step like we saw earlier let's do it anyway all right copy step failed it's trying to copy to common programs wherever this thing is okay so we what we need to do is change the permissions of this folder to allow the current user which is you know whoever we are logged in as we need to give them write permission to this folder so open up explorer this is located in the c drive program files common files this is where um x this is where visual studio is trying to copy this file to so right click create new create a folder call it vst3 and then the second part of this is to change the permissions so that the loggedin user can write to this folder because visual studio is being run under that user's settings okay so right click on this go to properties go to security click on edit to change the permissions and then we need to change the permissions for the user to be able to modify all right apply okay okay all right let's try this one more time let's see if it throws an error or not okay cool copy step completed if we go back over here let's see where was that let's just press stop real quick if we go to the build and scroll to the top we can see that one file was copied correctly all right let's go ahead and launch this now we need to scan for our plugin so choose options edit the list of available plugins and now this is where we need to scan all right so i've already done this scan before but i'm going to clear this list and now i'm going to scan for new or updated vst3 plugins right like i said it's looking for program files common files vst3 scan all right here's our plugin okay now we can load it into the filter graph right click go to your company name and here's your plugin if we double click on it it looks identical to the standalone version we saw earlier okay let's wire it up to the outputs just click and drag and we're not going to hear anything because there's nothing feeding audio into our plugin and thus going to the speakers let's fix that next go ahead and we can save this and add it to our repository choose file save and let's see let's add this to our repository desktop programming simple mbq and then we can say this is the um oh it's called simple mb comp filter graph now we'll get the extension save all right we can close that let's make a commit that we added this added filter graph go ahead and stage that commit that all right we are going to set up audio file player so that we can run audio files through our plugin go ahead and close this project okay in the previous tutorial video that i created i used apple's au audio file player to run audio files through the simple eq windows users did not have a plugin like that at their disposal and i saw a lot of comments in in the comments section of that video about that like people were just like hey what's the windows equivalent to this so this time we're going to use the audio file player plugin that i created this plugin is a port of the juice audio playback demo app it has been ported to work as a audio plugin so you can see that project if you want if you go to open example audio audio playback demo this is what this guy well we're not going to look at that right now but if you want to check it out just load that up um save it build it you know what to do because you know you've already done it a few times with producer and uh this project and with audio plugin host okay let's go get this thing all right open up your browser navigate to github dot com slash mat cat music slash audio let me spell that right audio file player okay now we want to grab the code from this copy we're done here in fork we want to clone all right it's already populated for us clone it all right let's open it in finder or in file explorer okay open up the juicer file save and open in ide now we just need to build it build solution this should also copy the vst3 to that folder let's see what it does may need to change the build target creating library one file copied okay that should be okay all right let's close this now we can go back to our project let's close audio file player the juicer file close that guy and we can also close this repository we don't need that anymore all right go back to our simple multiband comp let's load up xcode let's launch it and then we will configure audio plugin host to use it go ahead and run it now we need to scan for our plugins one more time because we just compiled the new one so go to the options menu edit the list of available plugins options scan for new or updated threes scan there is our audio file player so we can right click here mat cat music llc that's the name it's going to be under and then choose audio file player and here's our plugin all right this is what's going to play the files we just need to wire it up we've got our instance in the filter graph okay let's add an audio file um i've got one on the desktop it's this guy right here let's start that over all right perfect let's save the filter graph save all right we can close this what's great about this is that every time we launch this project it's going to load that audio file automatically for us we're not gonna have to you know go find the audio file every time we relaunch audio plugin host that's the problem that existed in the earlier version of this plugin that i had which i that plugin was just a bandaid fix when i first created this simple eq tutorial for the windows users because i didn't realize that they would have this problem i have since fixed that so that it now it now shows you it now remembers what file you had loaded so if we go ahead and launch this again there's our file and if we press play gonna work as expected so that's fantastic all right we'll put this guy over here audio plugin host is configured and um we have set up our project so that way every time we have the vst3 version set as the startup project it's going to launch audio plugin host and we'll have a real easy time of you know debugging our plugin and adding features to it and being able to run audio through it using audio plugin host now we are ready to start coding our plugin now we will be reusing and modifying some elements from the simple eq tutorial that i made for free code camp if you haven't completed that tutorial i recommend that you pause this video and start watching that one i'm not going to explain how the things we are reusing were created if you want that information you can watch that video where all that stuff is explained okay i will be explaining the modifications that we will be making to those classes though so with that said let's begin building this simple multiband compressor let's survey the lay of the land before we start writing any code also thanks to everybody who watched simple eq and said i looked like guilfoyle i had never heard of that show silicon valley before i started checking the comments for that video and that's good times okay number one there are several important parts to any audio plugin the first one is the dsp code itself this code is responsible for the actual audio that we hear we are responsible for making it fast and efficient number two is the audio parameters these control the various parts of the dsp code examples include the filter frequency or the pitch of a node being played by a synthesizer for example if we were writing a reverb plugin we might have a parameter that controls the reverb time in dsp programming it's all statebased programming we are constantly updating the state of our dsp based on math that modifies the audio signal in some way for example when we filter audio we keep track of the previously filtered samples these samples which are known as the previous filter output get added to the incoming samples after being scaled with some coefficient the newly filtered samples become the previous filter output for the next time that we process incoming samples number three preparing our dsp before we start processing anything with it before we can run audio through our dsp we need to configure some basic information about it the number of samples we're going to be processing the sample rate we will be processing those samples at and the number of channels we will be processing for example we might have a stereo feed which is two channels we might have a mono feed which is one channel or we might even have a dolby 5.1 which is six channels now if you are unfamiliar with the concept of sample rate there are numerous videos on youtube that explain how digital audio works let me grab my whiteboard so i'm reading my script over on this side so bear with me as a brief overview the audio we hear with our ears is an analog signal like this graph that i've got drawn here our eardrums detect changes in air pressure and they convert that change into an electrical signal which gets turned into sound by our brain this signal this graph that i've got right here this is a graph of the changes of the air pressure it is continuous if we uh take this signal right here if we were to continually zoom in on it like i've got down here on the bottom part if we continually zoom in on it it's always going to appear smooth okay now on computers that's not the case computers on the other hand operate using ones and zeros like i was saying computers operate on ones and zeros what this means is that the computer has to sample this smooth audio signal at a specific rate and produce an approximation of this smooth audio signal the more frequently that the signal is sampled the smoother the approximation becomes as an example let me use this blue color here if we sample at every tick like this blip blip blip and blip we are left with and also right there we are left with a wave form that looks like this if we sample at these tick marks we and we remove the continuous line we are left with this lollipop graph like this which has these little dots the more frequently that we sample the signal the smoother this approximation becomes as you can see right now it's not it's not a very good approximation of the original so let's sample it twice as often all right we'll sample here and here here and here that's going to give us a circle there circle there circle there circle there okay let's see the more frequently that the signal is sampled the smoother the approximation becomes this is the sample rate you know we can keep going we can keep bumping this up blip blip blip like that like that like that like that this is starting to look like the original waveform which is great which means like our approximation this digital approximation is much more accurate it's much more true to the original waveform okay this is the concept of sample rate the higher the sample rate the more frequently the signal is sampled now our ears they can hear up to around 20 000 hertz there's a theory called the nyquist theory that basically says that digital audio needs to be sampled at a rate of twice the highest frequency that you want to reproduce so this comes back to the way the waveform is shaped across the grid if i want to reproduce this pink line i can't sample it here and only there i need to have an intermediate point so that way um the full shape of the waveform is captured that's what the nyquist is talking about if i only capture here and here i'm gonna miss the fact that this actually goes up and goes back down that's the whole point behind the whole nyquist theory and whatnot so since we want to hear things up to about 20 kilohertz we need to sample that audio that 20 kilohertz um signal we need to sample that at 20 kilohertz times roughly 2. then this is where that sample rate of 44.1 kilohertz or 48 kilohertz comes in the sound card in the computer is converting 44 100 or 48 000 audio samples into an analog waveform literally an electric signal and it's sending that to the analog outputs every second you might have speakers or you might have headphones plugged into that analog output and this is where that analog signal goes and then the speakers themselves or the headphones might have an amplifier built into them that actually boosts this electrical signal that comes out of the analog output and then this boosted signal from the amplifier it is sent through some wires that wrap around a magnet that is attached to the speaker cone then the speaker cone vibrates when it gets that electrical signal goes like this which moves the air which our eardrums detect that change in pressure and then our brain translates that into sound that we hear okay now there is a ton of math and science behind these numbers of 44.1 kilohertz and 48 and like the way the ears work and the electrical signals and all that stuff we don't need to know any of that we just need to know that what sample rate means is it's like we have this we have this curved line which is continuous that's air pressure moving back and forth and we need to convert it into a digital signal that represents it and the more often we sample it the closer our representation will be now in the juice project there are two important functions that are always called the first one is called prepare to play let's go find the declaration of that that's right here i hope this font is big enough for those of you watching this on a tablet let's go look for the actual implementation of it also if you're using xcode or visual studio there are navigator things in the bars at the top which lets you jump directly to a function so you know learn to use those tools they're very handy the first one is called prepare to play and this is where we configure that basic information of our dsp code the sample rate the number of channels the size of the blocks and stuff the next one is called process block that's right here that's declared right here let's go to where that is over here okay this function process block brings us to our fourth important piece of the audio plugin processing audio samples at a regularly recurring interval using our dsp code this is what happens in the process block function now if you recall let's see let me hide that ring light that's in the back if you recall our sound card has to send 44 or 48 000 samples of audio to our speakers every second now internally let's pretend that this chunk right here on the bottom let's pretend this is 48 000 samples okay internally the sound card splits this into small chunks of samples called blocks or buffers so let me just draw what i mean by that okay so instead of sending let's just say this is zero and then this is 48 000. okay imagine there are 48 000 samples right here now internal as i said internally the sound card is going to split this into smaller chunks they're going to be called blocks and buffers now by doing this the sound card can lessen its burden of having to send this huge chunk of data to the speakers and to the amplifier and the digital audio converter all at once every second so instead of sending one big chunk of audio it can send lots of little ones such that the total number of samples per second ends up equaling the sample rate so for example it might say here's a chunk right here all right then here's the next chunk and then here's the next chunk and it's going to keep chunkifying this up into just these little blocks well that was terrible these little blocks like this until it gets the total number it needs to send per second if the buffer size was 512 samples let's pretend each of these is you know 512 samples and the sample rate is 48 000 then the sound card is going to send 48 000 divided by 512 buffers to the sound card every second or 93.75 buffers okay so obviously my picture is not totally accurate there should be 93 orange uh chunks right there okay now it's much easier to send 512 samples 93 times a second than it is to send samples one time per second and it's also easier to design hardware that can deal with 512 samples versus hardware that can handle 48 000 samples at a time okay so that's one of the things that goes into why we have these smaller chunks called blocks or buffers that are like 64 samples or whatever now this is how that idea affects our plugin and how we design our dsp code the process block function receives a buffer of samples whenever the sound card is ready for more audio to send to the speakers using a sample rate of 48 000 and a buffer size of 512 we know that the sound card is going to send audio to the speakers 93ish times per second or once every 10 milliseconds one 10ish milliseconds so that means that all the stuff that happens in our process block it needs to do whatever it's going to do in within those 10ish milliseconds the faster it does it the better however if the buffer size is even smaller maybe it's only 64 samples then our dsp code must be that much more efficient the sound card needs to send 48 000 samples to the speaker in blocks of 64 samples that means it needs to send 750 of these little blocks per second to the speaker that means it needs to send one block of 64 samples every 1.3333 milliseconds that's pretty fast we need to make sure that our dsp code runs as fast as possible as a result the sound card is not going to wait for us if we don't have that block that we were working on ready to go and this is what causes audio dropouts to happen the sound card will just send a block of silence to the speakers if the buffer it sent to our plugin wasn't processed in time so now you know what the process block function does and the constraints that exist for it audio dsp is a serial process there's a loop that is always sending a buffer of samples to our code and then our code in our process block runs from top to bottom and then the loop sends another buffer and there is no asynchronous coding happening here on the dsp side of things it's all happening in series which simplifies thinking about the code a bit this is also why i said earlier that dsp programming is all statebased programming we update the state every time the loop sends us a new buffer of samples to process and finally we have the gui which is the last piece of any audio plugin the gui is where we have all of the sliders all of the knobs all of the buttons that control the audio parameters which in turn control the dsp state it's important to design a gui that is very intuitive to use in terms of how this shows up in the code the plugin processor is where we handle the audio sides of things the dot plugin and cpp source files is where our gui is programmed while we are designing the audio parameters and the dsp for our plugin we will be using the generic audio processor editor instead of our own custom editor this class is really cool because it will automatically create all of the sliders knobs and buttons and combo boxes for every audio parameter that we declare this will allow us to dial in the dsp first and then add a pretty paint job later in the form of the gui now this is important because there are often times where we can't see the gui but the dsp code still runs for example the user might be using automation in their daw to control the audio parameters instead of the gui our gui always reflects the state of these parameters it's never the other way around the gui always shows the state of the audio parameters with this understanding let's switch to the generic audio processor editor so navigate to the create editor function in pluginprocessor.cpp create editor comment out this line that currently returns the custom editor we will develop later and change this to return the generic audio processor editor instead return new juice generic audio processor editor oh that's deprecated all right add the star all right let's run this and take a look at our gui don't forget our plugin will automatically show up because we already configured audio plugin host which is awesome it's this guy right here simple mb comp okay we don't have any audio parameters yet so the gui is not going to show anything we will add some audio parameters next let's talk about compressors and what they do now audio signals have different levels they can be loud they can be soft it could be a medium level there can be signals that can be too loud for a given system now when i say system i'm referring to the circuitry and the code that is either converting an analog signal into a digital one or converting a digital signal into an analog what this means is that the signal's amplitude can be greater than what the system can support let's use an example let's say that we have a sine wave that is represented digitally if we plot this wave on a graph that shows time on the xaxis and amplitude on the yaxis uh let's let's give it an amplitude with a range of negative 0.5 to positive 0.5 so we'll start here and we'll just go that high that high like that okay so let's just pretend this lines up with 0.5 and this lines up with negative 0.5 let's add some gain to this signal right we're going to boost it and by doing that we're going to double the signal okay so i'm going to turn up my volume knob crank it up it's going to double it add some more gain all right cool so now the wave has an amplitude of positive one to negative one that's the range of the signal so that's the range of the signal's amplitude okay let's add some more again some more we're going to double it again so now it goes from zero goes up to plus two let's see i'll use this red color hopefully this shows up i'm gonna add this guy right here we're gonna double it we go up to two our waveform has an amplitude of minus two to plus two what happens if we try to send this signal to our speakers through our sound card now the sound card can only handle signals between negative one and plus one let me use this green color i really hope this shows up now the sound card can only handle signals between negative one and plus one so the sound card is going to clamp any value that is outside of this range to this range so it's going to take this red signal and instead of it doing this instead of it doing that it's going to clamp it right across like that same for the top one it's just gonna go blip and right here it's gonna go blip just like that all right this is gonna turn it into a quasi square wave this doesn't sound good when that happens this form of signal clamping is a form of brick wall limiting this signal is hard limited to a specific range of values with no regard for what sort of distortion this will cause to the original signal by distortion i mean the fact that we had a nice smooth curve and now it's got like a square top and a square bottom it is no longer accurate to the original a compressor allows us to control the signal's amplitude in a musical way and in an automated way there are four parts to every compressor the two main parts are the threshold and the ratio so we're going to talk about our hypothetical signal for a little bit our signal is currently being clamped by the sound card whenever the absolute value of the signal is greater than one that's happening right here and then right here this plus one this absolute value plus one that is the threshold the threshold control tells the compressor whenever the absolute value of the incoming signal is greater than this threshold whenever it's greater than this apply gain to the signal it can be negative gain apply it to the signal so that the signal stays near or below this threshold now the next part is the ratio control the ratio control affects how much gain is actually applied to the signal is it is written as x colon y like this you've got x y so you could have three to one you could have ten to one you could have two point five to one like that okay these are the different ratios what they mean is that for every x decibels of input signal above the threshold the output signal will actually show y decibels of signal above the threshold so let's do an example to understand how this works because it's easier to think of this stuff in terms of decibels versus negative one and plus one normalized samples let's say that we have a signal that has a value of plus six decibels we can see that it goes over this threshold right here i've changed the scale on the side we still have zero plus one and minus one but you can think of zero as negative infinity because it means silence like the signal level in terms of decibels is infinitely small and then the plus one is the same as zero decibels below full scale and then any signal above that is reflected as a positive value okay let's say that our ratio is two to one and we're going to have a threshold of zero db okay now let's say that our signal is plus 6 db that means that our signal is 6 decibels above the threshold so let's plug the ratio into this line for every x db of input signal above the threshold the output will show y db of signal above the threshold so that means for every two decibels of input signal above the threshold the output will show one decibel of signal above the threshold so our signal is six decibels of the threshold so the output will actually only show three decibels of signal above the threshold that's going to look like this okay i should have probably used a different color but you get the idea this is plus six here this is plus three now let's try a different ratio like 10 to 1. what that means is that for every 10 decibels of input signal that is above the threshold the output will show only 1 db of signal above the threshold our output is 6 over the threshold so the output will only be 0.6 above the threshold which means our signal let me use a different color means our signal is actually going to look like this i think that math is right if it's 6 above the yeah 10 decibel 10 to 1 ratio so we're going to get a 0.6 out of it now we can continue to increase this ratio and get more and more reduction of the input signal however we can never make the output not produce a signal over the threshold unless we use an infinite ratio and that's what that brick wall limiting was that we saw before where the signal was just just chopped off that's where it just went like that and like that that's that brick wall limiter thing that i mentioned earlier that's using that same ratio of infinity to one okay so that covers threshold and ratio these are the two of the four parameters you can see them here we got threshold and ratio now clamping the audio like this doesn't sound musically pleasing furthermore going from clamping the signal to suddenly not clamping it doesn't sound good either and this brings us to the other two parameters the attack and the release the attack parameter controls how long to wait after the signal exceeds the threshold before gain reduction is applied the release parameter controls how long to wait once the signal stops exceeding the threshold before the gain reduction is no longer applied let me show you what that looks like on this graph all right we're back with our signal it goes from it's got a plus 6 db range on it uh the threshold is zero is still zero let's give it an attack time of one of these ticks right here so what that means if we draw a vertical line where this intersection happens let's just let's just pretend it happens right on this line right here that means that we're gonna wait until this tick to actually start compressing this signal okay so now i've got this orange line right here what this means is that it's not going to start applying compression until this point in time so this chunk of signal right here is not compressed it's going to go over the threshold and what is actually going to happen is we're going to apply the same rule right here of you know let's do two to one so this is you know let's say this is this looks like four so we're at four db so this is going to produce an output of two which means we're going to get something like this here we're going to see that okay so like i was saying we have this one intersection point what's going to happen is the signal is going to come to here it's going to rise the way it was normally going and then when it's going to hit that attack time let's say this is attack right there and this is going to go down like this and go like that so it's going to wait before gain reduction is applied based on however long this time is set to okay that's the attack time again the release parameter is going to control how long to wait once the signal stops exceeding the threshold before gain reduction is no longer applied so what that means on this side is that let's say the release time if we draw this line down here let's say this is our release right here just it's just one chunk of this right here so what that means is it's going to continue to apply gain reduction to this until we get to about there and then it'll drop across and how much gain reduction is applied depends on the ratio these two parameters the attack and release time allow us to smooth the transition between compressing the input signal and not compressing the input signal and then finally the threshold is always expressed in decibels and the attack and release times are expressed in milliseconds so the ratio is not expressed in any units even though conceptually we like to think of it as input decibels versus output decibels so with this knowledge in hand let's begin coding up some audio parameters to control our soon to be functional compressor one of the things we need to think about is synchronizing these audio parameters with our gui thankfully juice solves that for us with the audio processor value tree state class this class synchronizes our audio parameters with the host application that is loading our plugin and with our plugins gui we're going to need one of these in our audio processor it's going to need to be public so that the gui can attach all of its knobs and sliders and buttons etc to it now parameters must be declared when the plugin is created they cannot be dynamically created as such the apvts expects us to provide the list of parameters when it is constructed so we're going to need a function that will provide that list for us in the form of an audio processor value tree state parameter layout object let's head on over to our pluginprocessor.h let's go to the end of the public section right here and i'm going to use an alias using apbts equals juice audio processor value tree state now i'm going to declare this function first static ap oops um parameter layout create parameter layout all right now we can declare our ap vts give me the argument list all right we want this one all right we want to connect to this we're not going to use an undo manager we're just going to call it parameters and then the parameter layout will be provided by our create parameter layout function all right let's declare let's see i'm going to use my alias now a b v t s and then i got to use curly braces here instead of parentheses because it's initialization now we can go implement our uh the function that will provide the param the parameter layout let's go to the cpp file i'm going to put this all on one screen let me hide this uh hide this assistant guy all right i'm going to put this down in put this past the set state information put this right here first things first return type parameter layout and then the name of our class and the function all right first thing we need is uh the thing we're going to return lay out and we're going to return that all right we're going to be using the juice name space a lot i don't want to have to type it so we're going to use the using alias okay the first parameter we will create is the threshold parameter i'm going to set the range for the threshold to be between negative 60 and plus 12. i'm going to set the step size to one decibel meaning we can adjust the threshold in one decibel increments the skew parameter will be one now the skew parameter affects how this range of values from negative 60 to plus 12 is distributed across the slider that for the slider that's going to be attached to this parameter if you want to learn about this stuff i covered all of this in detail in the simple eq tutorial okay here we go layout.add we need to make a unique pointer all right we want to make a audio parameter float this one right here that guy off we're not going to use this my first parameter is going to be threshold parameter name is also threshold normalizable range we'll figure that out in a second all right we want to have a default value of zero decibels for our threshold let's define a normalizable range next normalizable range let's see which one do we want uh this one has start and interval and skew we'll use that one all right it's going to be a float type our range start is going to be negative 60 range end is positive 12. our interval value is 1 and our skew is 1. all right awesome next i'm going to dial in the attack and release i want to have a minimum attack and release time of 5 milliseconds so that means our compressor will always take at least 5 milliseconds to start compressing once the input signal goes over the threshold i'm going to set the max time to 500 milliseconds and i'm going to set the step size and the skew to 1. the slider controlling the attack and release will be linear just like the threshold slider let's do that next first let's define the range auto attack release range equals normalizable range this guy right here floats our range start is going to be five milliseconds like we said um then we're gonna have 500 as the end and then one and one for the skew and for the step size let's add an attack param and a release param layout.add make unique uh this is audio parameter float and oops i forgot this we want this one right here okay this is attack attack our normalizable range will be this thing our default value will be 50 milliseconds all right we can do the exact same thing for the release just need to change the name paste that there i'm going to change this release time to be 250 and we need to add the closing carrot to the template type and then let's change this to say release and let's line these guys up now finally we need to give ourselves some ratios a onetoone ratio results in no compression and a 100 to 1 ratio is basically brick wall limiting i'm going to use those values as like my start and end range and i'm going to add some values in between and since i don't want to use linear steps between 1 and 100 because that would just provide a huge list of ratios i'm going to use audio parameter choice and hard code the choices that i'm going to use okay the audio parameter choice constructor requires a string array of choices so i'm going to declare my choices first i'm going to convert them into strings and then i'm going to add them to the string array then i will create the parameter so here's my choices so i'm going to do i'm going to start at 1 1 2 3 4 5 with a 1.5 this is a pretty common um just you know very very light compression basically one two three four five six seven eight you know linear steps and then once we hit 10 i do 10 15 20 then 50 then 100. okay this 20 50 and 100 are all basically gonna sound the same they're just variously more aggressive forms of brick wall limiting now i can declare my string array and now i can use i can convert my choices into juice string objects now there's a string constructor that takes a um takes a double and we can specify how many decimal places get used so that's the one i want here double double value into number of decimal places i only want to display one decimal place so we're going to do that first and we're going to pass the choice to it that takes care of that now we can create the parameter and i do not want one to one to be the default ratio so i think three to one would be better so i'm going to use the index of this guy right here as the default value and remember that indexing starts with zero in c plus so we go like this layout dot add std make unique audio parameter choice all right this is going to be called ratio this is also ratio and my choices are the string array my default index is let's see this is zero one two three that guy right there all right like that and then we need our carrot all right there we go let's run it and we will see our sliders let's see what we got this should show us some sliders okay look at this we got our threshold guy right here we've got our attack time we have our release time and here we have our ratio awesome let's add saving and loading of the parameters next let's implement saving and loading of our plugin parameters state it's very easy to do because the plugin state is stored in the audio processor value tree states state member i'll show you what i'm talking about go over here let's go to where it's actually defined jump to definition way down here in the at the end of the public section there is a state member let's just look for that state right here yes it was at the bottom of this okay this is the public member the state okay this is the state of the whole processor all right let's go back to where we were plugin processor.cpp let's move to the get state information function it's very easy to implement saving and loading of our plugins parameter state and that's because the plugin state is stored in that state value tree okay now the value tree serializes to memory very easily we can use a memory output stream to handle the busy work which is needed to write the ap vts state to the memory block that this function has been given by the host it's this thing right here so all we have to do is create a memory stream juice memory output stream uh here's the block we're going to write to okay we're going to write to destination data um yes we can append because who knows if we're getting an empty one or a full one one that's empty or one that's already got a bunch of stuff in it let's give ourselves a member name a variable name and then we can just do apvcs dot state dot write to stream and then write it to our memory output stream all right wasn't that easy now we can do the reverse and restore our plugin state from memory using a value tree helper function the only thing we need to check for is whether or not the tree that was pulled from the uh chunk of memory we were given this stuff right here we just need to check if it's valid um before we copy it into our plugin state once we know that it's valid we can replace the plugin state appropriately here's the free function to use juice value tree read from data this is the one we want so we're going to pass the data we're going to pass its size in bytes this is going to give us back a value tree auto tree equals we just need to make sure it's valid if tree dot is valid if it's valid then we can replace it ap vts.replace state with our tree awesome let's test it out where did that go oh you're hiding okay we'll put you here all right i'm going to change the ratio from 3 to 10 then i'm going to save and quit and i'm going to rerun it the ratio should appear as 10. and there it is perfect all right cool let's add a compressor next and get it to modify some audio next if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming for musicians.com and you can message me directly in the slack workspace and i will help you directly juice has a generic compressor that we will be using for this project in order to access it we need to include the dsp module first before we can use it so let's go to our juicer file okay go to the modules section click on this plus icon right here add a module global juice modules path and choose the juice dsp class dsp module save and reopen all right now there it is now we can use the juice dsp classes let's go to the private section of our header file plugin processor let's declare an instance and then next we will prepare it in prepare to play so juice dsp compressor float compressor that was easy all right let's head over to the cpp file and prepare it go to plugin processor and go to prepare to play now we need to prepare our compressor we do this by passing a process spec object to the compressor we must first set up this spec object let's declare one juice dsp process spec give it the name spec first it needs to know the maximum number of samples that will be processed at any time so spec dot maximum block size equals this parameter here samples per block next it needs to know the number of channels this compressor can handle multiple channels we will use the number of output channels that our plugin can support as the number of channels to configure our compressor with spec dot num channels equals get total num output channels okay and now it finally it needs to know the sample rate which is this parameter here spec dot sample rate equals sample rate now we can pass it to our compressor which will prepare it compressor dot prepare spec next go to process block all right now we can start using our compressor to squish our audio the compressor wants a context to process and this context requires an audio block in order to be constructed so let's create an audio block out of the buffer that was provided to us let's get rid of this stuff right here and we're going to leave this code which clears channels that are not in the input okay so first let's declare an audio block juice dsp audio block and we want to use the one that takes a buffer as the constructor float pass it the buffer pass it this thing right here all right let's give it a name auto block equals whoops let's spell that right all right now that we've got our block we can create a context auto context equals juice dsp and here's where we want our context we're going to use a replacing context which means we're going to replace the audio in the buffer with our processed audio and we want the one that takes a block as its constructor argument float block now that we have our context we can process audio with our compressor compressor.process context let's run it everything should sound the same let's try it out and just to be sure that i've got some signal that stuff is actually happening i'm going to instantiate project 12. i'm going to feed project 12 with our output and this is just going to be over here so we can see what's going on okay let's play it we're going to run some sound through it all right now not doing anything to the sound and if we bypass this sound is the same all right so this is because we have not wired up any parameters to our compressor to adjust the threshold attack release and whatnot we've got our parameters here but they are not connected to the compressor that's actually doing signal processing let's do that next head on over to the header file plugin processor dot h okay now the apvts has a member function that returns pointers to the parameters that we created in the create parameter layout function it does not make sense to call this member function for every single parameter every time process block is called remember process block if our buffer size is small it could be being called 750 times a second so the cost of looking up those parameters could get expensive very quickly and this is one of those optimizations that we can do i know the rule don't prematurely optimize but this is one of the ones where it's okay to do it alright so let's create some member variables that will act as cached versions of our audio parameters for this compressor instance we're going to use the same types that we used when we created our parameters if we go over here go to our create parameter layout we used audio parameter float float float and audio parameter choice so we will create pointers to those okay so go to pluginprocessor.h and start declaring them here juice audio parameter oops let's spell that right parameter float make pointer attack initialize it okay we're going to do the same thing for the release and the threshold release threshold and then the ratio is a choice parameter juice audio parameter choice let's move over to the process block next and use these guys first before we set them up okay go to process block all right now here is how we use these guys first of all we need to use them we need to configure all this stuff before we start processing audio i'm going to do that before i create the block and the context okay here is how we use these parameters the float parameters have a get function that we can use and we just need to call the appropriate compressor function with this parameter value so we do compressor dot set and you can see we've got choices here attack release threshold ratio so let's start with the attack set attack and then we call attack param and just get the value let's do the same thing for the release and the threshold compressor dot set release release get compressor dot set threshold threshold get now for the ratio setting we need to extract the float value from the current ratio choice if you recall let's scroll down here if you recall uh the choices are stored in a string array all right so we need to get the float value of the current choice from the string and thankfully there is a helper function in the string class which does this for us and all we need to do is get the name of the current choice and then call that helper function so let's do that next we can do compressor dot set ratio and do the ratio parameter and we need to get the current choice name this guy right here returns a string and then we just need to call that string helper function get float value now before we actually test this we need to initialize our member variables so they aren't null let's go to the constructor to do that because if you remember when we declared these guys they're all currently null if we were to run this now we would get a big old crash all right so let's go on up to the constructor all right now as i said earlier there is a member function in the ap vts that allows us to retrieve pointers to parameters that we have added and all of these parameters are stored internally as ranged audio parameter this is the base class that all parameter types come from so we need to cast these parameters these ranged audio parameters to their correct type before we can assign them to the cached instances that we declared so let's do that we need let's do the attack parameter first let's do attack equals like i said we need to cast it to a juice audio parameter float and this is where we call apvts.getparameter and our name was attack okay now the getparameter function will return a nullpointer if the parameter name that we provided is not found in the list of parameters in case we type the parameter name incorrectly it's very useful if we assert when the parameter is null so this is going to help us catch any misspelled parameter names so we can do jsert attack is not a null pointer remember this function returns null if it doesn't find this parameter and if it does find this parameter then if this cast succeeds then the attack will not be null pointer if this cast fails like for instance let's say the attack was actually an integer audio parameter in or this cast would fail and we would have a null pointer here and we would hit a j assert so this is really handy so let's do that same thing for the uh two other float parameters just copy this we'll make this the release release and change this to release and then we can do threshold threshold threshold and threshold for the ratio we need to cast to audio parameter choice is this ratio ratio ratio choice audio parameter choice and ratio all right perfect let's compile it and run it and tweak some sliders we should hear some audible effects here's how we're gonna test this out okay change the ratio to like 50 to one and then we're going to set the threshold pretty low and then we're gonna start messing with the attack time so highly recommend get yourself some headphones to hear this all right let's run some audio through it though all right change that ratio to 50 drop that threshold down and we can really hear it clamping on that signal let's adjust this attack time so you can hear how the signal goes you can hear how the signal peeks through and then gets clamped down real quick that's that attack time the weight once the signal is past the threshold before it actually starts getting clamped we can hear if we change the change the ratio to something more subtle uh to a lower ratio we can hear that it's going to um it's not going to be as drastic of an effect so if we go back to 50 we can really hear it doing something major and then if we set that attack time as fast as possible we're not going to hear any attack at all because our ears just don't hear we just hear the audio getting really slammed okay if we set that release time really fast we're not going to hear so much oh we can start to hear a lot of distortion happening it's really smashing the signal all right let's bypass it see what's going on all right let's increase that release time all right cool so there we go our compressor is currently compressing all right let's find something else to do to make this turn this into a multiband compressor next all right cool let's add a bypass parameter it's much easier to click on this parameter than it is to rightclick on the plugin in the audio plugin hosts filter graph and toggle that menu option so let's head on over to the create parameter layout and add a bypass parameter stick this at the end layout dot add std make unique we want to add an audio parameter bool audio parameter bool this one right here all right this is called bypassed same name by passed and the default value is false meaning it is not bypassed that means it's active next let's declare a cached version of this plugin processor.h down to the bottom stick this guy right here juice audio parameter bool pointer bypassed nullpointer we can toggle whether or not our compressor processes the audio by setting the is bypassed flag on the context let's head on over to the plugin processor dot cpp go to process block and we can modify this context okay this is the simplest way to do this we can toggle whether or not our compressor processes the audio let's just actually go look at this okay if context is bypassed then just copy from the input to the output and get out of here okay otherwise do all this stuff which actually processes the code processes the audio samples all right this is the simplest way to toggle bypassing all we have to do is go context dot is bypassed equals our bypass parameter and get that value okay another option would be to write an if statement and wrap all of this stuff that creates um that creates the block and the context and does the processing in that but this is much much simpler to just do this okay so let's finally move to the constructor and initialize this param we will follow the same pattern as before initialize and then check it out all right we copied it let's change this to be bypassed and we want audio parameter bool and this is bypassed and then we just check it if it's null or not all right let's run and test it let's see what happens grab these headphones one more time all right there's our bypass parameter go ahead and start the music wow it's really slammed there we go bypass parameter is working as uh expected so this makes it much easier to compare the unprocessed and the processed audio so we can hear what our compressor is doing all right cool that was easy super easy we are trying to build a three band compressor what we have done so far is implemented the functionality of a single band so it makes sense for us to wrap this functionality into a class so it can be reused easily let's do that next let's declare a compressor band struct let's go to our plugin processor dot h and turn on the assistant editor actually before we do this let's make a commit let's go over here stage all this stuff i'll say implemented basic compressor functionality all right there's our juicer file filter graph yes we want that right we added our params and then here's where we initialized our params here's where we initialized our compressor here's where we processed our audio here's where we saved the uh here's where we're using the generic audio processor editor here's where we are saving and loading the state and then here's where we are creating our parameter layout all right as i was saying let's go to our header file go up to the top let's declare a compressor band struct let's add an instance of the compressor class to this and make it private now for the ease of initialization i'm going to make the audio parameters public in this class let's just go copy them from our audio processor copy these guys let's make them public next we are going to need some member functions that update the compressor settings that prepare the compressor and that also process audio through the compressor let's declare the prepare function first put that down here it's going to take a process spec object let's prepare our compressor with it now we can update our compressor settings by copying the code from the process block function that we had written earlier so let's do that let's just write this function right here void update compressor settings and then let's go to our process block that's right here and we're going to grab these things and just copy that right over like that okay the same goes for processing audio we are going to copy the code that we used here it's these guys and we just have to remember to pass in a buffer by reference since we will be modifying that buffer so let's declare that here void process juice audio buffer float reference buffer and now we need our block and our context we need to set the bypass state and then process boom now we can replace our compressor and the parameters in our audio processor with one instance of this compressor band class let's do that go way down to the bottom let's comment all of this out and change it to compressor band compressor like that now we need to do a bit of revision in the process block it's right here so let's take care of that it's coming out the old way of using the compressor to come with that stuff out now we just need to call the update function that updates the compressor compressor dot update settings and then pass our buffer directly to the compressor compressor dot process buffer okay the last thing we need to do is configure these parameters like we were doing but um we need to configure these in the constructor but for this object instead of these directly all right we just need to go up to here now we need to make these all say compressor dot attack that sort of thing so these cached parameters now live in the compressor band class so we just need to update these variable names here compressor dot attack like that ratio and bypassed okay let's test it everything should function exactly as it did a moment ago let's try it out all right i got my headphones all right um let's do a quick clean and rebuild just to make sure clean rebuild all right one more time all right that works as expected we can now start to think about how to ride a multiband compressor now that we have this building block of the compressor band all right let's make a commit now that we have our compressor banned um let's clean up this code let's get rid of this dead stuff too let's see it's gonna be in process block that's down here let's get rid of this okay let's make a commit added compressor band wrapper that's that that's that that's that guy that's that all right and our filter graph stage okay great let's figure out the roadmap for implementing the rest of the dsp in our plugin let's go to the top we'll put this at the top of the header file there's that file here we go at the very top but this below the fragment once okay road map number one is figure out how to split the audio into three bands figure out how to split the audio into three bands number two is going to be create parameters to control where this split happens number three we need to prove that splitting into three bands produces no audible audible artifacts okay number four we need to create audio parameters for the three compressor bands create audio parameters for the three compressor bands and these need to live on each band instance just like we currently have one compressor band which has the parameters as cached members okay number five we need to create the two remaining compressors create the two remaining not create we need to add the two add two remaining compressors because we already have one all right number six we need to add the ability to mute solo and bypass individual compressors add ability to mute solo bypass individual compressors number seven we need to add input and output gain because compression lowers the output level add input and output gain to offset uh changes in output level number eight we need to clean up anything that needs cleaning up clean up any um anything that needs cleaning up all right that will conclude the dsp side of the plugin dsp road map okay let's get started on the first one uh figuring out how to split the audio into three bands all right it's time to break out the white board okay let me erase this graph of how the sound card talks to the process block and the speakers okay sorry for the ring light okay here we go all right we learned in the simple eq project about low pass and high pass filters let's just draw what those are so say we've got um say we've got a filter spectrum like this um here's like here are the different frequency ranges this is like 20 hertz this is 20k all right low pass is eliminating all the frequencies above whatever the crop the threshold is let's say we got something like this so if i go let's say i want to eliminate all the frequencies below let's just call this 1k right here if i want to eliminate all the frequencies i would use a high cut filter which is going to cut out the high stuff and our frequency response will look like this likewise we can have a a low cut which is going to eliminate all of the frequencies below whatever our cutoff is set to let's set it to the same frequency so i will have a filter response like this all right so that's what we learned in simple eq the low pass and high pass or low cut and high cut however you want to think of it okay now if we duplicate our audio buffer we can filter the copies separately and if we set the cutoff of these two filters to the same frequency then we will get a frequency response like this where we have roughly flat except for right here now there's a special type of filter that we can use for the low pass and high pass filters that will actually produce a flat magnitude response when we sum the output of both of both of these filters this is the linquitz reilly filter let me write that here linkwitz riley filter oh geez that's like a terrible r there we go that looks like an r okay now these are known as audio crossover filters if you have a speaker that has multiple drivers in it it is using some kind of audio crossover to send part of the signal to each of the drivers separately for instance you might have a 10 inch woofer you might have a 5 inch midrange driver and you might have a two inch tweeter so let me show you um let me move this stuff over here and just draw a quick diagram of the speaker the speaker's crossovers might be set up so that the 10 inch woofer only covers frequencies below 100 hertz let me draw that on here so the uh speakers crossover filters may be set up such that the 10inch woofer only outputs uh audio that is below 100 hertz so that might be that's this guy right here this might only cover 100 hertz and below which means it's only covering this range like that the 5 inch driver might be set up to only output 100 to 5000 that might look like this let's see here's here's 5k right about there and that means the tweeter can only output stuff above well not can the tweeter may be set up so that it only outputs audio above 5000 hertz so this is 5 k plus that looks like this let me clean up this line right here because this one's bad okay now on a frequency plot we can see that this is a pretty even distribution the midrange is doing a decent amount the um little range is kind of handling there now why do we do this the reason is because it's pretty difficult to make a big heavy 10inch speaker move fast enough to produce frequencies above 5000 hertz right you got all that mass you're trying to move it at a really really fast frequency and it's really difficult it takes a lot of energy to do that likewise it's really difficult to make a small two inch speaker like this tweeter produce any kind of frequency below 100 hertz you know all of us are very familiar with listening to audio on our cell phones on the speakers that are built in and there's no bass whatsoever coming out of that tiny little speaker so some really smart people figured out that if we split the signal using these special filters these link with reilly filters we can have much better sounding music come out of our speakers when we dedicate each speaker to a specific frequency range all right now in the juice module there are link with reilly objects that we can use to split our audio into separate bands before we start using those however we need to start creating parameters that can control our filters and compressors so we're going to have a lot of parameters for these compressor bands so it makes sense now to refactor how our audio parameters are being created we don't want to have to type so much code since there will be a lot of repetitive code in the next few sections of this course okay let's get started creating a new approach to declaring our parameters the system we are going to create will let us easily look up the names of our parameters and not have to worry about misspelling anything either which is cool all right let's go to our header file first let's declare a namespace called params let's put this above compressor brand namespace params i am going to add an enumeration and this enumeration will represent all of the parameters that we are going to have in this project we are going to add to it as we add more dsp functionality and add more gui functionality as well for now here is the basic enum i'm going to call it names i'm going to add two entries for the crossover frequency parameter first low mid mid crossover freak and then mid high crossover freak and then i'm going to add entries for the threshold attack release and ratio for each of the three bands finally i am going to add an entry for the ability to bypass each of these bands bypassed band we'll do low mid and high all right now i'm going to create a map that will act as a lookup table for the string name of the parameters if you remember when we create our parameters let's go way down here when we create our parameters we pass a string in okay so we're going to pass in the name's enumeration value and that will give us back our string name that's how this map is going to work so this is going to eliminate the chance of misspelling anything and we'll be able to use autocomplete to choose items from the enumeration when we look up our parameter names as well which is cool so here we go inline const std map we're going to use our names enumeration paired with juice string and this function is going to return this map as a const reference i'm going to call it get params all right now this is what is known as a myers singleton pattern well it's kind of like meyer singleton it's more like a local function singleton pattern first we're going to declare a static map and we're just going to return that map map we'll call it params and we'll declare what it is in just a second and then we will return params okay so now we just need to um supply um pairs for the map so we just need to start declaring them so let's do the first one we're going to use this guy low mid high crossover and then i'm going to provide the name for what i want this parameter to actually be called low mid crossover freak when see i'll just do free so it's all within one line okay we just need to do this for all of these guys here so i'm going to copy this all right last is to add a oops we need to add commas at the end of all these there's our map now what is interesting about this pattern is that this static map that we've got right here it does not get created until we actually call this function so that's pretty handy okay let's update our existing parameters to use this map now so we need to change where the parameters are created and also where they are assigned to the current compressor band so let's do that first all right head on over to the create parameter layout function i'm going to switch from using um i'm going to get rid of the assistant editor all right head over to pluginprocessor.cpp and go to create parameter layout i'm gonna save myself a lot of time by adding the namespace alias right here not alias by using the using keyword and i'm going to get a local reference copy of the parameters map const auto params equals get params now i just need to replace all of these strings with the correct entry in the map and i'm going to set all these as though they were being assigned to the low compressor band so the first one becomes params.at names threshold low band let's do the same thing for the attack and the release and change this to attack low band attack low band and then for the release let's fix this indentation as well this is release low band next we need to do our ratio let's put these on separate lines copy these guys right here ratio low band and then finally the bypassed bypass low band bypass low band all right that was easy enough let's revise our um constructor where we initialize the cached parameters next head on up to the constructor we're going to do the same trick i used before of using the namespace and caching the sorry not caching but getting a local reference copy of the params map using namespace params const auto params equals get params if we look at our enumeration in the params class we have a lot of float parameters and the plan is to add solo and bypass functionality as well as mute which are boolean parameters and i don't want to have to keep typing this casting code more than i need to so let's write a helper function to do that let's go back to our constructor you can see what i'm talking about i don't want to have to write this line more than i need to okay so let's write a helper function we're going to use an in place lambda and i'm going to capture all the stuff that i use in the lambda by reference call this float helper auto float helper equals lambda lambda lambda all right we're going to need to capture the ap vts because we're using that to look up the parameters so actually let's do this let's um let's copy these lines into here and we'll adjust what we've got so we're going to change this to say param equals that and then we'll just say param is not an alternator no pointer param and then for this we wanted to say uh params at name like that or we can do program name okay so what do we need to capture let's capture apbts apvts equals this abvts we need to capture the params capture those guys capture these guys by reference now we need to pass in the parameter this thing right here so we'll just use auto and then we also need to pass in the param name autopram name all right cool unused variable let's use it now i'm using auto here because i want the compiler to figure it out and you can do that with lambdas which is pretty cool again all of these are being treated as though they are being attached to the low filter band the first one we're going to do is the attack param so do float helper and our parameter is compressor dot attack and then our parameter name is the names low band attack okay that takes care of this now we need to do the release param that takes care of this and now threshold that takes care of this now i just need one for the choice parameter and the boolean parameter and remember we're going to have three different choice parameters because we're going to have three different compressors with ratios and a boolean one for the bypassed mute and solo so it makes sense to just create it now so i'm just going to copy this and we're just changing with the cast we're just changing the cast that gets used really so this is going to be audio parameter bool uh not but we're doing choice first choice so this is the choice helper we can call it choice helper we got compressor dot ratio and our param name is names uh ratio low band all right that takes care of this guy and now let's add our uh boolean helper duplicate paste bool helper change the cast type and now we just call it bullhelper compressor.bypassed and we got names bypassed low band all right let's run it just to make sure everything works as expected all right my headphones we're going to adjust all the parameters and see if they work the way they should or if we get a js or false all right node.jser that's cool when you make big changes like this sometimes you need to recompile the code so let's do a you need to clean it out and recompile it from scratch so let's do that all right here we go change that to 50 drop that down all right that works for me save quit all right awesome all the controls are doing what they're supposed to be doing all right if you were curious as to why when we loaded this up our previous parameter settings were no longer found it's because we changed parameter names so they fell back to their default values okay onward let's make a commit of our changes let's see what we've done added road added road map and params namespace all right that's that and then we added where we use our params and all that good stuff okay now let's uh go to our roadmap let's tackle this guy right here figure out how to split the audio into three bands i had mentioned link with riley filters earlier now we're going to use them let's go look at the documentation for this class okay it says that um these are used in audio crossovers that have two outputs a low pass and a high pass such that there's some is equivalent to an all pass filter with a flat magnitude frequency response remember this it's they're talking about this like the response of the filter when you sum them together gives you a flat response okay they are saying that summing the output of two filters is identical to the same result you would get if you ran your audio through an all pass filter we are going to use that information later when we prove that the filters do not add any audible artifacts to the signal for now here is what we need to know we can split the audio into two bands using the juice linquit's reilly filters low band and high band once we do that we need to split one of these bands into two other bands that comes with its own set of problems that we need to deal with so for now let's just get a high band and a low band working first before we add a mid band okay so let's go down to our plugin processor dot h so we're going to go to our private section of plugin processor way down at the bottom we're going to do this after our compressor band let's declare two instances of this linquist reilly filter i'm going to use an alias to make typing it easier using filter equals juice dsp link widths riley come on auto complete filter float all right give me two instances filter low pass high pass all right we are also going to need a cached audio parameter for the crossover frequency juice audio parameter float low crossover little pointer all right each of these filters modifies the audio if we low pass our process block buffer then high pass filtering it will not give us the expected results here's my audio band okay we're doing low pass and high pass so if we low pass a bunch of signal like this this is what's left in the buffer okay this stuff right here this is what's left in the audio buffer right we originally had you know this was full spectrum and then you know we chopped out all of the high pass we did a low pass which kept all of the low frequency and everything above it got cut now if we try to high pass this at the same frequency you know we're trying to cut out everything below you know let's say this is our high pass that means we're trying to cut out everything below this point but there's nothing here this is all gone so the only thing we're gonna get left with is this chunk right here that's not what we want that is not the result that we want to have okay so what we need to do is use separate buffers and these are what we're going to sum later as the documentation said if you sum the results together you'll get a flat magnitude response all right let's declare an array of buffers std array juice audio whoops let's spell that right audio buffer float two of them filter buffers let's spell that right okay let's create a filter parameter next and then initialize it and then prepare our filters and buffers head over to pluginprocessor.cpp create parameter layout let's do this at the bottom after we make our bypass param layout.add here we want std make unique we want an audio parameter float all right we are going to set the crossover's range to be the auditory range of human here of human hearing 20 hertz to 20 000 hertz and we're going to set the default frequency to 500 okay so first things first let's provide our um our names so params.at names crossover low mid right copy that duplicate it let's give our default value of 500 and then we need a normalizable range normalizable range our range start will be 20 our range end will be 20 000. our interval value will be 1 meaning our value can change in increments of one hertz so 20 21 22 23 all the way to 20 000 and our skew will be one next let's initialize our parameter go on up to the constructor can use our helper for that float helper let's put this at the bottom float helper we are initializing our low crossover with the names low crossover awesome now we need to prepare our filters so go to prepare to play let's do this here lp dot prepare spec high pass dot prepare spec and now we need to prepare our buffers so that they don't allocate whenever we copy the input buffer into them let's do that next for auto buffer filter buffers buffer dot set size the number of channels is spec.num channels number of samples is samples per block all right let's go to process block now let's disable the uh compressor while we mess with these um while we mess with these filters for a little bit comment those guys out first let's copy our incoming buffer into these dedicated filter buffers for auto filter buffer filter buffers fb equals buffer each buffer in our filter buffers array now contains a copy of the input of the buffer that we were given from the sound card all right next we will update our filters cut offs both of the filters are going to share the same cut off so auto cut off equals low crossover get now we can do lp dot set cutoff cut off then hp dot set cutoff cut off now we must create blocks and contexts for the filters all right so we do auto fb0 block filter buffer zero block equals okay so we've got one audio block pointing to the first filter buffer and then another audio block pointing to the second filter buffer now we can create our context all right just initialize each context from the appropriate filter block and now we can process our audio lp dot process lp gets the first filter buffer of the two fb0 context hp dot process fb1 dot context oops no dot okay now that our input buffer has been turned into two separate buffers each of which has been filtered separately we need to sum them back into a single buffer now in order to ease some of this struggle with copying let's cache some of the details of the input buffer so auto num samples equals buffer dot get num samples auto num channels equals buffer.get whoops let's spell that right getting them channels and we need to clear our input before we start um adding our filter buffers to it so buffer dot clear okay each channel of our filter buffer needs to be copied back to the input buffer so i'm going to write a helper function to do that i'm going to use a use a lambda in here to do it auto add filter band equals lambda lambda lambda first thing let's see first thing we're going to do is create a parameter for our input and then a parameter for the source that we're going to copy from so here's our input buffer input buffer and then where we're going to copy from so const auto source all right now we just need to simply loop through all of the channels that were in the input buffer and copy from a source buffer into that so we can do 4 auto i equals 0. i is less than num channels is what we want so let's capture that by copy num channels eyes let's numb channels plus plus i now we can do input buffer dot add from and let's see what are our parameters let's see buffer dot add from let's do this okay our destination channel is going to be i our destination start sample is going to be 0. so let's just do this we're going to do i we're going to do 0 our source is going to be the source source channel is going to be i star source start sample is going to be 0 and then our num samples is going to be um this because buffer and the source have the same number of channels so we'll just call that ns all right this is what we add here like that all right and we need to capture n s n s equals num samples okay and just to go over that so we are capturing our num channels and num samples we are passing in this guy we're going to pass it in as a parameter and we're going to copy every single channel from the source one at a time and add it to our input buffer now we just need to call this helper function with our filter buffers add filter band our input buffer is buffer and our source is filter buffers zero add filter band buffer filter buffers second one all right perfect let's run this and see what happens grab my headphones all right okay all the top end is gone let's go figure out why that happened let's go look at how this class gets uh created all right we have a type parameter sets the filter type well we didn't do that let's see what type this thing defaults to all right default filter type low pass so that makes sense we're basically running our audio uh this is low passing it and then this is also low passing it at the same frequency let's solve that we need to call that set um set type function let's do that in the constructor going up to the constructor all right go down to the bottom let's configure our filters lp dot set type here we go juice dsp link what's riley filter all right now our lp is low pass and then let's do it again for the high pass this is hp and this is high pass all right let's test this again now remember we don't have our compressors turned on so we're literally just going to hear this filtering the result of our audio going through the lp and the hp filters here we go all right no audible um no audible effects to me if we adjust the slider which is adjusting the crossover nothing no audible effects so that's fantastic all right perfect we are halfway through splitting the audio into three bands before we go further let's prove that our filters are producing no audible artifacts we will also demo that the filters are actually doing something by soloing each one we'll do all that stuff next let's make a commit of our progress it's always a good idea to do that what did we do we added link with riley filtering here's what we did all the processing here's where we set up our filters that's where we prepared them here's what we processed with them here's where we created the parameter let's go back here let's save and quit this okay we can bypass the filtering by exiting the process block before we clear our input buffer and copy our filter buffers to it it's just temporary but we can use our single compressor's bypass parameter to control this alright the purpose is just to show that the filters don't introduce any audible effects when the buffer copy step is bypassed we are listening to the input buffer still and when it's not bypassed we are listening to the sum of the filter buffers being copied into the input buffer so this is very easy to write we just need to do it after this num channel so we can just say if compressor dot bypassed if it's bypassed um don't clear just leave the function right we've done our filtering but we're not clearing our buffer and we're not copying stuff into it okay okay here is how we can prove that this is actually what is happening let's run this okay first things first make sure this bypass low band is toggled on next let's add a breakpoint right on buffer.clear now if we press play notice that the breakpoint does not get hit and it's not until we uncheck the toggle button that it actually gets hit and this is going to cause like some weird audio stuff but you know just bear with me okay here we go gonna unbypass this all right hit the breakpoint so let's remove the breakpoint all right now we can stop our audio okay but that proves uh the point i try i was trying to make that our audio is actually running through our filters and we can hear the difference between if it's um between if we're hearing just like the raw buffer input or if we're hearing our filtered input okay all right let's talk about this crossover filter and one of the special properties of it when you have a pair of these filters like we have here and you sum their output like we are doing here the result is the same as though you had run your signal through an all pass filter with the same cutoff frequency i want to show you what i mean by that so let's add an all pass filter and then demonstrate toggling it with our lp and hp filters so we can see how they sound the same okay let's go to our header file let's go down here to our filter let's add another filter filter ap like that for all pass filter and now it needs its own buffer so let's give it one of those juice audio buffer float ap buffer all right we will prepare it and set the type next let's go to the prepare to play function prepare to play let's do ap dot prepare spec all right let's uh set the buffer size ap buffer dot set size spec.num channels samples per block all right let's go set the type in our constructor we learned our lesson from the first time we messed with these filters and we're going to make sure we're going to set that type now ap dot set type whoops set type juice dsp let me just copy this all pass next we will make our process block toggle between our low pass and high pass doing the filtering versus our all pass doing the filtering and we're going to use that bypass parameter like we used earlier because it's you know it gives us a toggle button that we can just easily click on and off okay let's go do that next alright let's go to our process block let's get rid of this bypass code let's just comment it out for now now we can copy our input buffer to our all pass buffer ap buffer equals in uh buffer okay we got to make sure we do that before we clear all right let's do the same processing you know we're going to create a block and a context and then process with the filter so i'll just grab these two lines right here and i will just rename them this is ap block and then this will be ap block this is going to be ap buffer and then this will just call this a all pass context and let's do our processing ap dot process ap context all right now we can revise our logic that does the copying if the bypass toggle is unchecked use the low pass and high pass buffers otherwise use the all pass buffer so if compressor bypassed get if that toggle button is unchecked use these guys otherwise add filter band buffer from the ap buffer this logic will let us hear the lp and hp buffers by default we already know that they don't add audible artifacts and toggling this checkbox will show that the ap buffer produces the same result so let's test this out we're going to just run this we're going to toggle the thing on and on on and off let's grab our headphones all right so let's play it turn this down so if i toggle this all right let's push stop real quick now we can confirm that it's working by making sure bypass is unchecked and then setting a breakpoint in the else block let's press start once we click that check box the break point will be hit perfect this is expected show all the dewey okay so that works as expected so let's investigate soloing the low and the high bands next okay our compressors will be able to compress either band so it's important to know what these bans sound like let's check that out next all right soloing one of these bands is really easy we just need to comment out which buffer gets added to the input so let's solo the low pass output by commenting out the second line all right we can toggle between hearing the all pass filter and the low pass filter using our check box let's run this oh you know what we can adjust this there it goes i was wondering why i wasn't doing anything because i had this this cutoff way up high all right so right now we're listening to the low filter uh the low pass band now we're listening to the all pass all right cool save that quit all right let's do it again and switch to the high pass okay so uncomment this one all right sorry comment the first one out and then uncomment the second one let's run and test all right we'll drag the same crossover slider again so we can change how much bottom end is actually cut out of the signal all right all right so there you go so that is how soloing and the muting of the bands works okay it's all about figuring out which buffer you want to copy to the input all right so we're going to do one more little test with these audio filters next okay the final test that we will do is to sum the inverse of the all pass filter with the output of the low pass and high pass filter the purpose of this is to show how the two outputs sum to zero or silence again we will be using the bypass switch to toggle between this behavior versus hearing the output of the low pass and high pass filters so let's comment out this code actually let's copy this first because we're gonna need this let's copy this now we can comment this out all right now paste this here okay we are going to always copy the output of the filters into our m into those buffer that we were given by the audio audio system okay now if the bypass switch is turned on we will invert the all pass filter buffer and add that to the output we can do that by going if compressor dot bypassed get if the switch is toggled on then we need to invert every channel in our all pass buffer and then add that to the filter band so let's let's set up the add band first add filter band buffer we're copying from the all pass buffer okay and now we just need to invert so let's do this for every channel and we can do this using float vector operations so four auto ch equals zero ch is less than num channels plus plus ch now we can do juice float vector operations and there's a there's a way that we can multiply a fixed value against every sample in a particular channel so we're going to use that multiply and we want the one that takes a multiplier okay our destination is going to be a right pointer to one of the channels in the ap buffer so ap buffer dot get right pointer because we want to be able to modify this buffer that's why um our channel number is ch our multiplier will be negative one to flip it upside down and we're going to do this for every sample so num samples all right now that they are inverted um we already we're already adding them over okay so now the next thing to do and this is actually something we forgot to do earlier um is to go up to where we are setting our cutoffs and we need to set the all pass filter to that have the same cutoff as the other filters we forgot to do this earlier so when we were dragging the slider back and forth yeah just a fluke that um it didn't sound audibly different to me let's go to the last step we can test this out now and if it works as expected we will hear silence when we toggle the bypass switch let's check it out all right silence there we go and if we adjust the frequency silence all right awesome so that is doing what it is supposed to do okay let's learn a little bit more theory about this whole lp plus hp versus the all pass filtering and how we can use this to make three separate audio bands that some to produce a signal with no audible artifacts once we have this knowledge we will implement it and check off item one in the dsp roadmap let's make a commit of our progress from uh working on this filter stuff before we start diving into filter band theory all right what did we do oh we have to fill the graph okay we um uh tested using all paths filter that's basically what we did we got our filter here and our filter buffer here's where we set up the filter type here's where we prepared it here's where we set the cut off here's where we did our processing and then here's where we did the inversion to basically cancel out the regular filtering that's what's going on there all right all right let's talk about filter band theory all right let's discuss some theory behind these filters before we create the three band splitter filters work by delaying part of the signal let me get this more on camera we've got a pair of filters here a pair of linguists riley filters we got low pass one and high pass one okay every time we filter the signal we introduce a delay now i don't know how the math of this delay actually works and that's beyond the scope of this video that's what they end up doing in the math is they apply delays to certain frequencies in the spectrum and that's how you end up getting that stuff to be muted so when we split the signal into low pass and high pass bands we are introducing the same delay so to speak to both parts and then when we run the signal through an all passed filter the same delay is produced of course that's assuming the all pass filter the low pass and the high pass all have the same cutoff frequency so that means that we can use an allpass filter to equate this same delay okay so whenever we have a pair of these we can replicate that same delay by using an allpass filter okay now we can use this to our benefit we can split our signal into two bands like we're currently doing and this split will just add one delay to the signal you know delay so to speak okay if we then split one of these bands into another delay we will end up with three bands let me show you what i mean all right so check it out we've got our three bands here this band this band and this band okay that's what we're trying to accomplish three bands however the problem is that lp1's output the signal that runs through this chain only has one delay whereas the signal that is split from high pass one this guy and this guy there are two delays and that means that our signals will not sum correctly okay now as we learned earlier the all pass filter introduces the same delay as this so all we need to do is replace this line you just we just need to add an all pass filter here set to the same cutoff frequency as these two filters and we will have a um we'll have our solution so this is the solution that we need to use okay we just run lp1 through an all pass filter and that gives us an output that has the same number of delays as the other uh signals over here okay so the low pass one to all pass two contains all of the audio be low filter cut off zero and then the uh high pass one to low pass two contains all of the audio between filter cutoff 1 and filter cutoff 0 this range right here and then high pass 1 into high pass 2 contains all of the audio at filter cut off 1. all right so there we go three bands that sum to a flat filter response okay and we can prove that this null's out by creating two more all pass filters set to filter cut off zero and filter cut off one and inverting their output and then summing it with the output of these three bands okay all right in project 12 you will learn how to dynamically create uh n number of bands you'll learn how to figure out okay if i have seven bands how many allpass filters do i need how many lowpass filters do i need how many highpass filters do i need and um how do i structure them so that way it can all sum together and can all do everything that it's supposed to do my computer can handle about eight filter bands when i'm in debug mode maybe yours can handle more than that but it's a really really interesting problem to solve and is very cool so let's code that up next and begin filtering let's restructure our filtering i find that it helps to declare them visually in the same way that they will be structured i'm also going to write the name of the cutoff parameter that will control that particular group of filters above that filter itself so let's get rid of our old filters and the buffers and stuff and start writing this first all right here we go so filter uh we've got an lp1 and an ap2 all right that's part one we've got hp1 and that feeds into lp2 and then we've got our hp2 on the bottom so that guy let's add these cutoffs next here we've got our fc0 filter cutoff 0 and filter cutoff 1. let's rename this crossover and add another one for the mid high right click refactor rename i'm going to call this the low mid crossover all right let's duplicate this this is going to be the midhigh crossover mid high crossover finally we can give ourselves a third filter buffer because we have three bands let's add another parameter for the midhigh crossover then we will set our filter types and then prepare our filters and then use our filters head over to pluginprocessor.cpp go down to create parameter layout go all the way to the end where we create the low mid crossover copy and paste it and change this to the mid high crossover frequency all right now while we are here i'm going to change the range of the crossovers so they do not overlap so this first one is going to go from 20 hertz to 999 hertz i'm going to change the default to 400 and then for the second one it's going to have a range of 1000 to 20 000 hertz and the default value will be 2 000 hertz all right let us set our filter types next and then initialize our cached crossover variables head up to the constructor all right let's go to let's do our cached value first so float helper we're doing the mid high crossover names mid high now let's tackle these errors we just need to rename these types so it's lp1 now and hp1 and then it's ap2 and then this just needs to be duplicated for lp2 and hp2 alright cool let us go prepare these next head over to prepare to play again renaming the old filters this is lp1 this is hp1 and this is ap2 and just copy these and rename we've got lp2 and hp2 all right we don't have an all pass buffer anymore so this line gets removed all right let's configure some 3band filtering next over to process block the first thing to do is to configure the filter cutoffs so the low mid cutoff is applied to lp1 and hp1 all right let's rename this parameter as well refactor rename and this is low mid cutoff the mid high cutoff is applied to lp2 hp2 and ap2 so let's get that value next auto mid high cutoff freq equals mid high crossover get and then this is ap2 ap2 gets the mid high cutoff and then let's copy these guys and this is lp2 hp2 and they also get the midhigh cutoff the next thing to do is to create audio blocks and contexts for each filter buffer now there is a dry way to do this but if you want to know how to do that you need to take project 12 because project 12 covers all that in this video we are going to hard code it so the first thing we need to do is let's add a block for our third filter buffer so copy and paste this fb2 block goes to filter buffers2 let's add a context for it copy this line fb2 context goes to fb2 block and now we need to run the appropriate context through the appropriate filters lp1 and ap2 get the first filter buffer ap2.process fb0 context next hp1 and lp2 get the second buffer but here's the thing we need to know let's come back to my chart here okay the thing to know and i've written the names of like which filters go with which brands the thing to know about this is that hp2 needs the result of hp1 so we have to filter this first we have to filter hp1 first and then copy it to the second filter buffer before we can run it through hp2 okay that's the only gotcha that's going on here all right it's okay so currently in our code we've got lp1 and ap2 processing the first filter buffer that's this line right here okay now what we need to do is process hp1 into filter buffer one and then we can copy it to filter buffer two and run it through here and then run lp 2 through filter buffer one so we've got filter buffer 0 filter buffer 1 filter buffer 2. alright let's do that let's turn that concept into code all right let's see hp1 processes filter buffer context 1. then we copy the output of filter buffer 1 into filter buffer 2. filter buffers 2 equals filter buffers 1. all right now we can process lp2 that gets fb1 context and then hp2 can process filter buffer 2. filter buffer two okay this is very important now our audio has been filtered into three bands and now we need to sum it back let's get rid of this um code right here the ap buffer stuff because we don't have that anymore and let's get rid of this stuff here as well let's just clean this up now i want to make the bypass act as a toggle like we did earlier so we will just exit before we clear we'll go like that okay i am going to comment out all of this all pass invert code because i do want to come back to it in a little bit but for now we just need to add the third band and i am not going to use a loop for this even though this is pretty repetitive and that is because i eventually want to have the ability to mute and solo and bypass individual bands and that is accomplished by not adding a filter buffer to the input buffer and writing a loop right now would make that you know we'd have to revise it later which is annoying so for now we'll just leave it uh we'll just manually add each one like that okay let us go test this out we're gonna toggle the bypass we're gonna drag the sliders all that good stuff all right let's test this out adjust the sliders toggle the bypass that sounds good to me i'm not hearing any of that phasing that's fantastic all right now we can confirm that this is working by toggling the bypass checkbox and then adding a breakpoint anywhere after that bypass param check so i'm going to add it on buffer.clear and let's push play and then once we unbypass our breakpoint will be hit yep all right so it works as expected okay the last test i want to do is the null test with the inverted all pass filters we will do that next all right let's close this guy save quit go to pluginprocessor.h okay i showed earlier how a single inverted allpass filter will know the output of a pair of lowpass highpass filters when they are all tuned to the same cutoff frequency and you multiply the output of the all pass filter by negative one i'm going to show that the same thing is true here with these three bands each stage in the filtering acts as a delay that's this stuff right here the lp1 and the hp1 that's stage one and each delay can be nulled out with an allpass filter set to the same cutoff of that stage so we've got two stages so we need two allpass filters let's add them here filter inv ap1 i inv ap2 all right now we are going to need one buffer for the all pass filtering since they are processed in series juice audio buffer float in ap buffer next we need to set their types then we need to prepare them and then we need to process audio with them head to the constructor in pluginprocessor.cpp let's go down here let's do this at the bottom all right let's just copy uh copy this all past two dot set type let's put this at the bottom all right we're gonna call this inv ab2 and invap1 go to prepare to play and prepare them as well as the buffer let's just copy this paste paste inv all right and let's prepare the buffer in ap buffer dot set size spec.num channels samples per block let's filter and invert some audio next go to process block all right we're going to do this after we do our initial set of copying first we will copy the input buffer into the buffer that we will be processing in ap buffer equals buffer next we'll set the first inverted all pass filter to have the same cutoff as lp1 and hp1 then we will set the second all pass filter to have the same cutoff as the second stage now we need to make our block and context to filter our all pass buffer with our filters i'm just going to copy this and duplicate that let me do that after we process this guy i'll put that right here this is in ap block and we will use in ap buffer and then here's in ap context ctx and this is fed by end ap block all right now we just need to process it in ap one dot process apctx and then in ap2 dot process abctx let's get rid of this bypass functionality for just a moment if the bypass button is not ticked let's see let's comment this out let's talk about what we're going to do if the bypass button is not ticked we will be hearing the audio running through our three filters if the bypass button is ticked we will be hearing the sum of the three filter bands added with the inverted all pass filters that's what we're going to implement next all right let's reenable this chunk right here and then let's change the names so it compiles this is in ap buffer and then that's it that's all we need to do all right so we're always adding these guys um and if our bypass button is turned on then we're adding the output of the inverted all pass buffer after it's been multiplied by negative one okay so clicking the bypass button should produce silence when we test this out here we go all right let's press play again if we click this button we should get silence all right and drag in the sliders perfect all right awesome so this wraps up the theory side of things we can start compressing our separate bands once we remove this inverted all pass filter stuff all right let's remove the all pass filter stuff the inverted all pass filter stuff we're not going to be using it anymore in this project we are done with all of that so let's head on over to pluginprocessor.h and we can get rid of this inverted all pass filter we can get rid of the buffer we can get rid of the stuff in the constructor stuff down here get rid of these two guys go to prepare to play basically everywhere if we were to build this now everywhere that we have errors is where we need to comment this stuff out okay we don't have these three anymore so i'll get rid of those and then in a process block that's going to be right here that's going to be here and right there that's going to be all of this code right here actual block context and filtering we don't need that let's turn this bypassing back on and then we can get rid of all of this code that inverted the samples you can get rid of this stuff right here let's build and test bypassing should not produce any audible differences that's what we're aiming for when we use the bypass button versus if we drag the sliders and whatnot all right let's try it out no phasing no audible difference here either awesome all right we can check off the first item in our dsp roadmap figure out how to split audio into three bands done cool let's make a commit of that figured out how to split audio into three bands here's our buffers and whatnot fill the graph yes all right here's where we set our types here's where we prepared our filtering here's where we set our cutoffs here's where we did our processing um and then this is just here's our parameter and then this is just where we are adding our third filter band all right awesome let's create audio parameters for the compressors that we will be adding we can also remove two other items from the roadmap since we completed them as well goodbye number two and goodbye number three all right so we are on number four now all right let's head over to create parameter layout in pluginprocessor.cpp all right we already created param names for these extra compressors so we just need to create the parameters for it since they all are going to have the same settings and range of settings we can literally just duplicate most of this code that creates the current set and just change the names so let's copy let's do the threshold first copy this paste it twice and then hold down option shift to select multiple lines and then change this to mid same thing for this one here change that to high done couldn't be easier let's do the attack param select this paste paste option drag mid option drag high boom okay let's do the release param copy this and option drag mid option drag hi perfect all right let's do the ratio parameter next copy paste paste option drag mid option drag hi and then the bypass parameter is next option drag mid option drag hi all right cool let's run it all right look at all the parameters that we have access to now all right that was super easy all right let's close this now in project 12 i teach a much more optimized solution for creating the parameters and looking them up versus using this params get paramed dot at thing that we're using here all right let's go on to the next item in the road map since we are up here let's see we're done with this done so now we need to reinstate our compressors and add two new ones let's do that next let's go to pluginprocessor.h we'll go down to where we are declaring everything go to our private member variable section the first thing i'm going to do is create an array of compressor band instances and then i'm going to create aliases to each one now the reason is so that i want to have the option to be able to loop through and i also want to have the option of being able to target each one individually without having to use array indexing so check that out let's do std array compressor band three there's my compressors we're going to change this to be plural and now we're going to do compressor let's see i'm going to do this on three lines so let me write this three times compressor band band comp uh let's see capital b band comp equals compressors like that all right let's just fill it in all right first this is going to be the low band this is going to be the mid band and this is going to be the high band this will be the first one this will be the second one and this will be the third one boom that was easy all right now we need to initialize all of the parameters for all of our compressors so go to pluginprocessor.cpp go to the constructor all right i'm going to rename the very first one and then i can just copy and paste the three lines to initialize the other two compressors all right so let's rename this right here this is gonna be low band comp like that now i can copy and paste it and rename accordingly all right i'll change this mid band and then this one is high band all right do the same thing for the bypass and the ratio so first rename this low band comp ratio and then copy and paste this two times and this is the mid band and the high band um oh you know what i forgot to do all of these need to be um let's see this is low so these need to be let's get let's line these up that could have been problematic let's see um all right go to the end arrow over one two three mid same thing here high like that awesome okay do the same thing here this needs to be mid with a capital m and then high with a capital h it could have been a disaster all right let's do this let's see this is low band comp bypassed copy and paste this and let's see this needs to be low this is mid this is high all right and then this is going to be the mid band and this will be the high band perfect all right the compressor parameters are initialized now we can prepare our compressors all right so when you're doing this step be very careful to make sure you're initializing the low band compressor with the low band parameters all right you know mid band with mid params high band with high params okay just be careful be very careful when you're doing this on your side go to prepare to play all right remember what i had said about the ability to loop through these we can just do four auto comp compressors comp boom done onward to process block first we need to update all of the compressors settings again looping for the win for auto compressor compressors let's turn that on now we can't actually compress any audio until after it has been filtered so we need to move this line this compressor dot process until after all of the filtering has been completed so let's go do that all right that happens down here okay now one of the important things to note was that filter buffers zero this guy right here this holds the low pass audio and that same index zero is the same index of the compressor that is set up for low band processing so isn't that convenient that means that it makes it really easy for us to run the correct buffer through the correct compressor so it would be a problem if it wasn't done this way imagine if we had to remember that filter buffers2 was the buffer to use for compressor zero all right anyway it's very easy to do this we just need to use an index based loop instead of a range based loop for size t i zero i is less than filter buffers dot size plus plus i now we can do compressors i dot process filter buffers i wasn't that easy how simple is that all right let's get rid of this uh bypass stuff let's clean this stuff up too we don't need that all right let's get rid of this bypass stuff we can delete it for good and uh that's it all right we can get rid of this stuff as well all right let's test it out our compressors should be able to be tested separately so grab your headphones and mess around with it here we go let's put this on screen so we can see more of the parameters and let's um let's see let's make the output of our compressor feed project 12 so we can actually see the result let's just turn off all processing first okay if uh we're gonna run some audio and then we're going to um you know adjust and adjust each individual band and just kind of mess with them all right so we got our low band we're going to hear the way this is set up now we're not going to hear a lot of low band you can really see this as we clamp it down we can see that a lot of the low band is gone let's go down here let's see that that low end is really chopped and then we turn it back we bypass it we can see that uh that happened all right let's let's uh chomp down the mid band wow it's really getting chopped all right let's adjust our mid band so it's tighter and let's change that ratio you can see this dip that's happening right here uh between 1k between as we show here 761 and 2300 it's kind of a dip right here between 1k and 2k let's change this to be closer to 300s that's right around where this line is you can see this dip right here so if i bypass the mid band see a little bit of a boost here change this ratio to be like really dramatic and really slam it all right we can see a big dip right there okay all right so that's a pretty good test next let's add the ability to solo and mute the individual compressors because that's a very cool feature let's save this and quit this let's um make a commit let's see what did we do we um reinstated all three compressors all right here's where we did that and fill the graph and here's where we set up our parameters here's where we set up our ratio param our bypass param here's where we prepared them here's where we did our settings updating here's where we actually processed audio and we got rid of some code there here's where we created our params params params params params good times commit all right solo bypass mute next let's check off road map item number five add two remaining compressors done number six add the ability to mute solo bypass individual compressors all right we can already bypass an individual band we just need to be able to solo and mute them so let's duplicate the bypass enum entries and rename them go to the params copy this paste paste and we just need to rename so option shift mute and sorry not shift just option drag to select and then solo i don't know if that's a thing on windows but on mac it is in xcode it's very handy all right we just need to add them to our map below let's go down here again copy paste rename one two let's get that back on screen all right first things first this is um let's see we'll do mute first copy paste copy paste copy paste all right and then solo will be the second set solo solo copy paste paste alright awesome now we need to add solo and mute parameters to our compressor let's go to the compressor band and declare two more boolean audio parameters named mute and solo so duplicate this copy paste paste it says mute and this is solo now these aren't going to be used in the compressor class at all they will be used in process block we still need to create the parameters in parameter layout before we can initialize them in the constructor so let's do that next head over to pluginprocessor.cpp and create parameter layout all right go to the bypass parameter where is that that's down here at the end all right copy paste rename do this for mute and solo all right change this to be the mute and mute again option drag mute and then we'll do solo here at the end solo whoops solo solo all right awesome let's go initialize the parameters and our compressors next go to the constructor all right copy and paste the boolean helper code for the bypassed param and then rename accordingly whoops let me add extra line okay this should be mute let's do all three of these and let's see i can't because their line lengths are different i can copy and paste this is solo copy and paste all right now for these i can do it at the end so this is all right no because high is too long all right gotta do them individually all right this is mute and then uh solo and solo okay excellent all right let's go solo or mute our separate bands next in process block all right this happens after buffer dot clear right here okay the logic is surprisingly simple if any of the bands are soloed we copy only the solo band's buffer to the output otherwise if a band is not muted we copy that band's buffer to the output so first we need to figure out if any band is soloed this is pretty easy to do we start with a boolean flag and then we loop through the compressors and just check their solo param if it's true then we have at least one band that is soloed and we stop checking once we have at least one that looks like this again we start with a flag we loop through every compressor if the solo parameter is true then we have at least one that is soloed so we don't need to check anymore let's comment out the old way of looping of adding the filters all right now we just need to check if bands are soloed or not all right if bands are soloed else if any of the bands are soloed copy only the solo band's buffer to the output now we cannot use a rangebased loop here because our filter buffers don't live with compressors so we have to use an indexed loop instead but that's okay that's easy to use for size t i equals zero i is less than compressors dot size plus plus i again uh let's get a compressor auto comp equals compressors if comp dot solo if it's soloed then add filter band add the buffer and this one we want filter bands uh filter buffers we want if index i apostrophe th all right cool that's very simple to understand all right again if a band is soloed loop through all of the bands and if a band's solo parameter is on then we add the associated filter buffer that that particular band is using all right let's implement what happens when nothing is soloed next go to the else block if nothing is soloed then copy only the buffers that are not muted let's use the same loop again and we need this uh compressor part as well oops all right if comp dot mute get all right if it is not muted it's very important to include that exclamation part if it is not muted then we can add that filter band okay that's it that is solo mute and bypass let's test it out let's mess with the solo buttons and the mute buttons grab your headphones all right here we go all right this is bypass let's mute let's solo the mid band all right we can adjust this just this range we can see how we we can make this mid band really narrow like that all right and we can bypass it as well so we can see what our mid band actually is like and what it actually sounds like what that means is that we can go up here and dial in all this stuff like say i want real slow attack time i want to let all of that you know snare information through i don't want that to get clamped down so i can adjust all that stuff it's just ratio all right let me stop you stop soloing it you know it's funny about that i was adjusting all those parameters and it was bypassed so i wasn't even hearing it so that's a whole that's a whole thing like you shouldn't be able to adjust these sliders um if it's bypassed but that's something we implement later all right so we can mess with this mid band see what it actually sounds like and use the bypass to um uh you know adjust this stuff let's change this ratio so it's real dramatic here there's a lot of information that's being uh is it in the high band well the high band is real wide all right so we can dial in a lot of the snare stuff that's going on here anyway that's solo mute and bypass actually mute the mid band we can see it gets dipped out there let's mute the high band stuff gets kind of dull if you need the low band it'll sound like a telephone and we can like you know tweak all this stuff early okay all right that is solo and mute and bypass of three separate bands with our filtering so we can check another item off of our roadmap let's solo this i'm not solo let's save this quit go to our roadmap turn off the ability to uh let's mark it as done that's awesome and then uh let's see we're gonna add input and output gain to compensate for level changes and then we're gonna clean it up and that will be the dsp side of things let's make a commit all right added mute solo functionality and bypass bypass functionality all right here's where we set up the uh mute and solo params here's where we implemented the actual dsp here's where we created the params uh marked it off list here's our enum here's our param names and here's our parameters on the compressor band excellent done all right input and output gain next and then clean up and that will conclude the dsp side of this plugin awesome all right now it is time to add input and output gain because compressors lower the output level of the signal the input gain is mainly if the incoming signal is not high enough or if it's too high and we need to turn it down first we need to add some entries in our enumeration that will point to the parameter names let's put these at the bottom next we need to add two entries so copy these stick these at the bottom number four all right we need to declare some gain processors and cached parameters go to plugin pluginprocessor.h way down at the bottom where we are declaring all of our stuff let's put this after our filter buffers uh let's see juice dsp gain float we got input gain output gain all right then we need two parameters these are going to be audio parameter float as well okay we need to create some actual parameters that represent our input and output gain so let's go to plugin pluginprocessor.cpp create parameter layout so we're going to put these at the top so i'm going to define a range of negative 24 to plus 24 with a step size of 0.5 this means we can boost or cut our incoming signal with a range of uh not in with a range but with steps of like 0.5 such as you know 1.5 db of gain 2 db again 2.5 db of gain same will go for the output gain levels all right so let's define that first auto gain range equals juice normalizable range actually i didn't need to type juice just type normalizable range range start is negative 24.f whoops that's float in the wrong place holder here we go range start negative 24.f range end positive 24 interval value 0.5 f and our skew will be one okay that's our gain range now we can define our parameter all right let's just copy this paste paste let's change this name to be gain in and we'll change this to use our gain range all right and let's just duplicate this copy paste replace that right now this can be gained out all right now that we have created the parameters we need to initialize our cached parameters in the constructor all right let's uh let's do this after our crossovers where's that that's right here okay float helper input gain param as with every other dsp processor we need to prepare our gain processors before we can use them let's go to prepare to play all right we also need to specify the ramp duration for these processors now this function the ramp duration it controls how long it takes to transition from one gain level to another whenever the gain level is changed so anything quicker than 5 or 10 milliseconds is pretty audible and it sounds it produces like clicks and pops so i'm gonna go with 50 milliseconds we'll go input gain gain dot prepare what do you want srb come say hi to everybody oh yes everybody say hi to srabby she's very whiny can you whine you gonna wind everybody all right down you go spec all right output gain dot prepare spec let's set those ramp times input gain dot set ramp duration in seconds 0.05 because there's a thousand milliseconds in one second so 0.5 seconds is 50 milliseconds all right do the same thing for the output copy paste copy paste okay now that this is all set up let us start processing our audio with our gain processors all right um let's see go to process block and before we start applying gain to our input buffer we need to update our processors with the most recent gain parameter values so input gain dot set gain in decibels because we're storing our parameter in decimals input gain program get do the same for the output all right we must apply input gain b4 processing audio through the bands so i'm going to call an imaginary function that i haven't written yet that applies the gain and then we'll implement that imaginary function next but first we'll do that here and call apply gain buffer and our input gain i'm doing this because i'm going to be applying gain i just don't want to have to write the code that actually applies the gain twice let's implement this imaginary function next head over to the header file plug in processor.h down at the bottom all right i'm going to declare a helper function that will apply the gain we are very familiar with creating the context for a particular buffer so i'm trying to type in that code so i'm going to write this helper function and i'm going to use templates because i'm too lazy to figure out the type that each of the arguments should have so you know why should i have to think about that stuff when the compiler can figure it out for me you know all right so here we go template type name t type name u void apply gain passing in a buffer and passing in again all right let's make our block auto block equals juice dsp audio block float out of the buffer make it out of the buffer let's make our context auto ct x equals juice dsp process context replacing float this is out of the block and then we can do gain dot process ctx all right head back over to process block so we can apply output gain next all right now finally we apply output gain after processing all of the audio that way at the end after all of this stuff apply gain buffer output gain all right cool let's test this out the gain sliders should change the volume headphones all right cool gaining at the top gain out at the top as well let's mess with this we'll adjust our levels let's just bypass um let's bypass our compression for right now turn down the input that works as expected all right cool that is awesome that works as expected all right so here's an interesting test um let's turn down the input gain to like negative 12 negative 12 and then let's turn up the output to positive 12. all right let's run some audio through it all right now if we toggle the bypass of plugin oh wait hold on i need to unbypass this stuff okay oh let's see all right if we bypass this the audio will sound the same okay so you would think that we would hear some type of compression especially if the compressors have a pretty low threshold prior to modifying the input and up again but when we do this we don't actually hear any compression all right so the reason is because we turned down the input gain level which means the low threshold that we had and the compressors is no longer low relative to the signal level so we need to lower these thresholds by 12 db in order for them to actually do anything right so for example if let's see um i'm gonna do it to just the low band for now turn the mid band back up okay i'm going to set this to negative 20. all right all right let me just solo this real quick oh look at me tweaking stuff all right here's our solo low band all right now because this is applying negative 12 to the input um our signal may not be hot enough to actually trick to actually trip the compressor so what we need to do is lower this by 12. so put this to 32. there we go now we now we're starting to hear it smash you can hear it on the base boom boom boom boom boom open that up a bit if we bypass okay all right so that's the interesting test do that now it'll really be it'll be really big it will really compress it and if we put this back 20 negative 20 we'll hear the same results that we heard a moment ago okay okay so that marks another item on our dsp roadmap let's save and quit this let's go up to our roadmap uh where's that plugin processor.h way at the top add input and output gain done okay so now the next thing to do is to clean this up let's do that next okay uh head on over to create pro create parameter layout all of these thresholds use the same um normalizable range so let's dri that dry that auto threshold range equals this thing cut paste semicolon replace the next thing to do is to move all of the code that updates the dsp processors into a function process block always operates in this order let's go to processblock see let's actually just see what i'm talking about processblock always operates in this order first thing we do is update dsp processors with the latest parameter values and then we process the audio so again dsp processing is entirely statebased and the parameters represent the state so we update the stuff that does all the math with the latest dsp state before any math computations are actually performed so i'm going to call an imaginary function first i'm going to call that right here update state and then we just need to move all of this code that happens here all of this stuff she need to move that to that function okay so let's do that next first we go declare it plug in processor.h way down at the bottom void update state now we can go implement it i'm going to put this right above a plugin i'm going to put it right above process block put that right here simple mb comp audio processor update state let's update our compressor settings all right we need to update the uh filters let's grab all this stuff and then we need to update the gain processors let's grab these as well let's clean this up as well get rid of that stuff and get rid of that and get rid of that all right cool and now process block is much simpler okay we update our state then we apply our gain the next thing that happens is we split the audio into separate bands so let's do the same thing we will call another imaginary function we'll call that right here split bands and we'll pass our buffer to it let's go declare it go to plugin processor down to the end okay go back to plugin processor and let's just move the relevant code again um above process block void simple i mean comp audio processor split bands okay so this is where we make this copy first and we do our contexts and this needs to say input buffer we do our contexts and our processing right cool so again we are making process block just that much simpler and easier to understand right we update our state we apply our gain then we split our bands and then we're doing compression all right now i'm just thinking out loud here but because the apply gain function is set up for a generic processor we technically we could use it i mean we could use it here for all of these but there are five processors being used which means that we would be creating five blocks and five contexts and right now we're only creating three blocks and three contacts so i'm gonna stick with what we have because it's um even though it would simplify this function a lot what we have now is um a light it is less cpu intensive because it has less objects being created okay everything else that happens is already pretty simple we do our compression um we do our solo check then we do our um if it's soloed here's which buffers get added otherwise these are the buffers that get added um let's clean that up so we could refactor it but we're not going to really gain anything here instead single line comments can be used to explain what is happening in case it isn't readable what's going on but in my opinion this is very readable right we're clearing the buffer we're figuring out if a band is soloed and then we're using whether or not a band is soloed to add stuff to um our input buffer okay so let's just run and test this to make sure and it should be all good but let's just make sure okay that still works it still works it still works all right cool and solo still works all right sounds good to me this concludes the dsp portion of this uh simple multiband compressor um in project 12 we tackle how to dynamically change the number of bands so you can have six bands two brands three bands up to eight bands if you're if you need that much along with uh how to do a bunch of other stuff like a draggable gui for adjusting the crossovers and adjusting the thresholds and whatnot okay so we can move on to developing the gui and making it as simple and as intuitive to use because this will never fly in front of the customers customers will look at this and say i don't know what i don't know how to use this i don't know yeah this is i will not give you my hardearned cash if this is the gui that i'm working with all right let's work on that next good times save quit let's make a commit added io gain cleaned up dsp here's where we um let's see checked out these things here's where we added our input gain uh strings here's where we added helper functions and parameters here's where we set up our parameters here's where we prepared our dsp processors here's where we did some cleanup here's more cleanup here more cleanup there and more cleanup here and here's where we added those parameters let's see that goes there here's where we added the parameters and here's where we refactored um the threshold parameter okay excellent onward to the gui all right the dsp is done let's get rid of the old road map let's sketch out the road map for the gui all right first thing that we're going to do is the global so let's add this in here globe gui road map all right number one global controls these are the x over x over sliders and the gain sliders okay these are going to go in the middle of the display input gain on the left output gain on the right crossover controls in the middle okay next we're going to have the main band controls these are going to be the attack release threshold ratio sliders all right these are going to go below the global controls and these controls will be assigned to the mid band first all right next we're going to add solo mute bypass buttons again these are going to be assigned to the mid band first and these are going to be on the right side of the main band controls component okay number four band select functionality this is also known as resettable parameter attachments this band selects functionality will allow us to have one set of controls for all of the bands and it will also give us some buttons to switch which band is currently being controlled by the sliders and the solo mute bypass buttons okay we will be using the band controls so we will need to have a mechanism to change which parameter a control is assigned to it's a pretty cool system to implement um it's not not the simplest thing but it's it's a very it's a very interesting problem to solve okay next five band select buttons reflect the solo mute bypass state when we switch the bands now this is to give us some visual feedback when we click any of these you know low band mid band high band buttons okay we also need to implement the logic that prevents you from having both uh the mute button and the solo button set at the same time for example because it doesn't make sense to be able to be muted and soloed at the same time all right so we're going to deal with that all right next number six custom look and feel for the rotary sliders and the toggle buttons all right so custom look and feel for sliders and toggle buttons we will be modifying the look and feel that we developed from the simple eq tutorial so if you don't have um if you did if you didn't do simple eq um you know pause right now and go through that and then come back here so that way you have those files i will also be including links to the simple eq repository so if you don't want to go through it you can just copy that code and um you know paste what you need you know copy the parts you need and paste it into this project let's see number seven spectrum analyzer overview spectrum analyzer overview okay the spectrum analyzer in this project is slightly different than the one in simple eq so i'm going to go into detail about what is actually different number eight data structures for spectrum analyzer all right we're going to grab these from the simple eq tutorial and then we're going to you know modify them at some point number nine we're going to let's see what are we doing here we are going to do fifo usage in uh plugin processor process block oh i got weird capitalization going on number ten uh well sorry before we do that okay so for the fifo usage in process block um we need to do a little bit of dsp modification to make this happen correctly all right and then let's see number 10 is okay implementation of the analyzer rendering precomputed paths again this is going to be taken from simple eq the simple eq analyzer took a decent chunk of time to develop in that course so there's nothing gained if i duplicate that same chunk of video in this video other than to make this video an hour and a half longer so i'm not going to do that i'm going to include links to the relevant code and we will be copying what we need and reusing it okay number 11 drawing crossovers on top of the analyzer plot okay this is where we're going to customize the spectrum analyzer number 12 okay drawing gain reduction on top of the analyzer drawing gain reduction on top of the analyzer again this is the final customization and we will need to write a little bit of dsp code to make this happen so we will be doing a little bit of work in plugin processor and then let's see the last one uh let's see analyze or bypass analyze the bypass um we're going to use the same code that we used from simple eq and then number 14. let's see we have a global bypass button global bypass button all right and this is just something that every plugin should have because um it's it just makes it really easy to compare what your plugin is doing with um if it's not processing anything okay that is wrapping up the gui we have our roadmap so let's start coding up the very first item global controls if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming4musicians.com and you can message me directly in the slack workspace and i will help you directly now that we are tackling the editor we can disable the generic editor and use our customized editor plugin processor.cpp create editor comment out this line and there we go all right we want to return our customized editor go to plugineditor.h alright the first thing we are going to do in the roadmap is tackle the global controls i'm not sure what size i want my different gui components to have right now so i'm going to use placeholder components that will show me the sizes i've set these are going to be empty components that only draw a single color so the good thing about this approach is that once i've dialed in the placeholder positioning when i finish developing the real component the screen position is already locked in and i won't have to mess around with the positioning of the component itself let's declare a placeholder component we'll put this here at the top this component is going to draw a single color and that single color is going to be defined when the component is constructed and this compo this color is going to be randomly generated but it will never change once it's configured so here we go struct placeholder let's define our paint function first and we're going to fill the whole thing with this custom color and then the next thing we will do after this is to declare our custom color now that we have used it okay let's declare our custom color next and we will initialize it in the constructor next first we need to declare a constructor and because the autocomplete is not responding as quickly as i would like in this header file i'm going to define this constructor in the cpp file so let's go over to plugin editor dot cpp next all right let's put this at the top all right let's start place holder i'm going to use the juice random class to generate some integers that will populate the rgb values of our custom color okay cool let's give ourselves some placeholder components and position them on the screen next head over to the editor class declaration and add some placeholders plug in editor.h down here at the bottom the editor will be split into four sections at the very top will feature the analyzer bypass buttons and the global band bypass button below that will be the spectrum analyzer with the part that shows the threshold as well as the gain reduction then below that are the global controls and then finally we will have the actual compressor band controls at the bottom so let's declare four instances of the placeholder and give them appropriate names all right let's add these to our display in our editor's constructor so head on over to plugin editor.cpp next we need to add and make our child components visible if we want to be able to see them let's give ourselves a little bit more room and make our editor a little bit wider and a fair bit taller i'm going to go with 600 by 500. all right let's go to resized for the control bar at the top i want to have the analyzer power button on the left and the compressor global bypass button on the right so i'm going to make these sit within a bounding box that is 32 units tall so first let me get the local bounce and now i can get a 32 pixel tall rectangle that will form the bounds of our control bar by calling the rectangle remove from top function this member function will remove a chunk from the top of the rectangle and give us that chunk that was removed as a separate rectangle so i'm going to use that here to give the control bar a bounds that is 32 pixels tall and the same width as our editor and is positioned at the top of the screen next let's position the actual compressor band controls at the bottom of the screen and i think i need something between 130 and 140 units in terms of height so let me try 135 first and just like remove from top i am going to use the rectangle remove from bottom function here which behaves just like the remove from top except the chunk is taken from the bottom of the rectangle let's dial in the analyzer bounds next i know i want this to be taller than the band controls and the global controls in the center so let me choose something between 200 and 250 all right let's go right down the middle and use 225 and remove that from the top of the bounding box again we're just removing chunks from the get local bounce rectangle and using those chunks as the bounding boxes for our child components okay we removed a small sliver from the top which was for the control bar then we removed the chunk from the bottom for the actual compressor band controls and then we removed a large chunk from the analyzer and that leaves us with a rectangle that will be used for the actual global controls let's run and test this i'm going to switch to the standalone editor and we can find we can fine tune these values after we see what it looks like this very first time all right this looks okay to me this is um this rectangle right here is going to be the control bar at the top uh this is going to be the band controls here's our global controls in the middle and then this rectangle right here this is the analyzer okay i'm happy with these placements we have created placeholders for the main parts of this gui so now we can dial in custom components for the global controls let's make a quick commit added placeholder components also added gui road map all right here's our road map the graph here's where we change to the custom editor here's our placeholder and the usage and here's our placeholder constructor adding all of our child components and positioning them all right let's declare a global control component plugin editor.h let's put this after the placeholder i'm going to start dialing in the graphics before i add sliders to it and the reason is because i want to reuse the sliders that were used in simple eq and migrating those files over to this project will require a bit of code surgery and i want to do this simple task first so let's declare the class first and we just need to add a paint function for now okay now we can replace our placeholder with an instance of this global controls let's flush out the paint function this one that we've got right here head to the cpp file let's put this after our placeholder paint function let's put this after our placeholder constructor okay let's flush this out i want to draw a border around the component but i also want to have a gap between this component and the others so i'm going to use the draw order to handle this since i don't want to have to mess with the component bounds again in the editor's resize function so the first things first let's fill the component with our border color i'm going to be using the juice namespace in here a lot so let me just do the using namespace trick we're going to fill our component bounds let's get them first all right and i'm going to use a blue violet color for right now next let's reduce our bounding box a little bit and fill a rounded rectangle with all black there we go we reduced we set the color to black and then we filled a rounded rectangle let's take a look at this just run it quick let's see what this looks like it's kind of hard to tell because this is a similar color okay to make this easier let's hide some of our placeholders go to plugin editor.cpp go to the editor constructor and let's just see the global controls comment out the control bar the analyzer and the band controls all right let's run it again all right let's get rid of this and we'll fill it with all black go down to this paint function so we will comment all of this out and do g dot fill all fill it with all black now let's run it again okay great let's add this little gap that i was talking about next i wanted to have a little bit of a gap between each of these widgets and go back to global controls paint okay so i want to draw a black border around the entire bounds of this component and since i'm reducing bounds here i need to make a copy of this before i reduce it i need to do this before i do the reduction right now i can reduce like i'm doing here now i can draw this black border so i will give myself a small gap between this component and the surrounding ones without messing with the resized function now for what it's worth i could have accomplished a similar result if i do g dot draw rect i could have achieved a similar result by using the juice path and adding a rounded rectangle to it and then calling g dot stroke path but that would have given me rounded corners on the outside in addition to the inside so this way i end up with a square i end up with square outer corners and rounded inner corners and i like the way this looks a little bit better personally speaking let's take a look all right so you can see there's a little bit of a gap between this and the right edge of the component and between the purple line and the left edge i think this looks really clean you know this nice little gap and there's going to be a little bit of a gap between each of the components i want to use this border effect in the compressor band controls and with the spectrum analyzer but i'm going to wait to refactor this paint stuff until it's actually time for that the next step is to grab the look and feel and rotary sliders from simple eq and get our global controls functioning so let's just we'll close this for now and we'll figure out how to do that stuff next let's make a commit added global control graphics okay i want to reuse the rotary sliders from simple eq in this project these sliders depend on the custom look and feel class that we developed in the simple eq project and the easiest thing to do is to copy the classes from that project and just add them here now if you did not complete simple eq visit the repository linked below the classes will be in the plugin editor dot h and cpp so we're going to copy the declarations for the look and feel class and the rotary slider with labels class let's paste them above our placeholder components so let's go grab simple eq we can grab it from here matcap music simple eq we can go to our source plugin editor.h and we are looking for look and feel all right here's our look and feel so we need the look and feel as well as the rotary slider with labels class this guy right here and this guy right here copy these guys and you can clone it if you want and grab it that way um go to your plugin editor and put it below no put it above our placeholder components okay now we need to grab the relevant implementations draw rotary slider draw toggle button all of this stuff so go back to the um source on github go to the cpp file plugin editor and we are looking for the look and feel draw rotary slider the next look and feel class and then rotary slider with labels paint and any other rotary slider with label functions all right there's a few of them plugin editor.cpp let's put these at the top put those right there i'm going to put this line between myself and between these classes and the placeholder just so i can tell them apart all right once it is pasted we have a few error messages to deal with let's find out where those are do a quick build and it should show them to us unknown type name power button all right let's deal with these two type errors i want to have a global bypass button in this project and i want to use the power button graphics from simple eq for it so the easy thing to do is to grab the power button class from simple eq and that is found in the editor.h so go back to the source code on github or if you have the project grab it from there plugin h and look for power button all right paste that grab the power button and paste that before the placeholder before the placeholder after the rotary slider with labels class plugin editor.h after rotary slider with labels before placeholder what's the next error analyzer button and i want to use that same button that we used in simple eq to toggle the spectrum analyzer on and off so again just copy the code for this class from the simple eq project and we'll paste it after the power button class so go over here here it is right here right below power button analyzer button copy that and put this in plugin editor after power button and before placeholder all right now try to build it alright build succeeded so with these errors out of the way we can now add our global controls to the gui now all right here is the plan for the global controls number one add generic juice sliders and then do some refactoring because i'm pretty sure we're to reuse some code between the paint function and the resize function for determining the bounding box our sliders will sit inside then we will add parameter attachments then we will replace the sliders with our rotary slider with labels classes on the heap and start using look and feel then we're going to dial in the colors for the sliders and the borders a bit then we're going to add the range labels to the sliders we're going to add a title that's the plan okay so let's dive in and add some generic sliders we're going to need a constructor for adding them as child component where's our global controls class where is that global controls okay down here all right constructor first we're going to need a resized function for positioning them and then we will need some private slider instances we have our input gain slider our low mid crossover slider our mid to high crossover slider and then our output gain slider all right let's head to the cpp file next and then add them as child components plugin editor.cpp let's go after our placeholder constructor let's add some child components all right let's position them add a resized function after paint i'm going to use flexbox for this so first let's get our bounding box then let's make a setup for row positioning because we're arranging these in a row i don't want to write juice all over the place so i'm going to use my using namespace juice let's move this up all right here we go flexbox all right i've declared my flexbox it's going to be a row flexbox and i don't want anything to wrap around now we just need to add every slider with the same amount of flex and then finally we just perform the layout all right let's see what we get let's run this okay those are not rotary sliders we need to customize the type to be rotary all right instead of doing this for every single slider let's declare a rotary slider class and make it inherit from slider and then we'll just set it up so that way it is it has the rotary style with no text box all right let's do this after let's do this right up here app right before our global controls all right let's initialize the base class rotary slider inherits from juice slider and it uses the rotary horizontal vertical drag slider with no text box let's change the type from juice slider here to rotary slider all right and let's test it out go ahead and run it see what we get all right much better okay let's add attachments next and then we will replace these with our rotary slider with labels that we created from simple eq all right let's declare one attachment per slider let's see where am i right now global controls we're down here all right i'm going to allocate these on the heap so that way i can optimize a bit in the constructor i will explain when we get to that stage for now let's just declare a unique pointer to the attachment and create one attachment per slider okay one attachment per slider now if we are using attachments we need the ap vts to look up the parameters so let's modify this constructor and let's change now how we initialize our global controls we need the audio processor dot apbts that's why we made that thing public that's why it's a public member variable way down here all right let's change our constructor plugin editor.cpp go to the global controls go up to this constructor choose ap processor valley true state apv ts okay now all of these attachments are unique pointer which means we have to call std make unique to create them now the slider attachment constructor wants three different parameters number one the ap vts number two the parameter name and number three the slider to attach to the first thing that we need is our parameter map so we can look up the names so let's do that before we start adding these things as child components the next thing that we will be writing a lot is attachment equals make unique attachment and then the three things and that sure seems like an opportunity for not repeating myself by writing a free function now i'm too lazy to look up the type names so i'm going to use the templated function instead and let the compiler figure out the type names so let's head over to the header file we're going to write a function called make attachment we're going to put this after our rotary slider it's going to go right here okay let's start by writing a function with no parameters now in the body we will call the actual make unique call using generic names in our parameter map so let's do void make attachment and here we're going to do attachment equals std make unique it's going to be an attachment and let's see what do we say the first argument that is needed is the apbts second argument is the parameter name which we get from our map and then the third argument is the slider itself okay now that we've got this we can dial in the um parameter list and then we can use template parameters for the five variables that are used in this function this is variable one two three four and five and then there's this thing right here so the first argument is the unique pointer itself std unique pointer of type attachment all right next we have the parameter name let's see well i guess next is actually the ap vts but um we'll just do these in this order yeah we'll do ap vts next ap vts all right then we've got our parameters map that's this thing here so params then we've got the name param name name let's make those guys const and then finally we've got our slider slider type slider okay now we can just add um template parameters for each of these templates like that and now we can do type name and attachment type name apbts type name params type name param name and then type name slider type okay great so again what we did here to figure this out was we just made an empty function with no arguments we implemented what we were going to call and then we said all right what gets used let's add parameters for all of that stuff that gets used and then let's just you know use template parameters for that and then we can use um the compiler feature template type name deduction when we call this function we'll just you know pass in all the stuff it needs and the compiler will figure out all the types and it should all just work just like magic with this helper function in place let's go back to our cpp file and now we can write a lambda that lets us dry calling that make attachment stuff with five parameters instead we can just call it with three parameters so that's dry for the win all right here we go auto make attachment helper equals lambda lambda lambda i always need to call make attachments all right so we just need to pass in our attachment we need to pass in the uh let's see we're going to be using the params so we need to capture those let's capture those by reference we're going to capture the ap vts and then everything else is passed by passed as constructor arguments okay so here's our mpvts here's our params our program name is something we can pass in here and we also need to pass in our slido so let's do auto attachment this should be lower case and then let's do um const auto name and let's see auto slider alright so we can just do name then slider so this is a very similar idea to what we did in the constructor for the audio processor or we made a lambda to basically dry a bunch of code that initialized parameters okay next step is to call our attachment helper for each of those three um each of the attachments for the sliders so make attachment helper our first attachment is the in gain slider attachment and for this we want names gain in and we're attaching this to the in gain slider all right let's do it again for the low mid crossover low mid attachment names low mid crossover and then the low mid slider make attachment we're doing mid high now mid high attachment whoops not make attachment attachment helper that's what we want all right so mid high attachment names mid high and then the mid high slider last one is the output slider make attachment helper this is the out gain attachment names out gain and then name um let's see this is the out gain slider all right cool let's build and test now if we run and tweak some knobs then quit and rerun the sliders should return to the same position that we left them in all right so this is input gain so i'm going to turn this all the way down and we will quit and rerun perfect all right double click to reset okay our compressors are not connected to any gui controls but the input gain and output gain parameters are so let's switch to testing with the aph to make sure the gain controls actually adjust audio levels which they should since you know we just saw it be attached to the parameters but there's nothing wrong with testing okay switch to the vst audio plugin host and let's run this all right let's run some audio grab your headphones turn down that input all right perfect okay we can switch these sliders out with our rotary slider with labels next so let's go over here let's make a quick commit as well save quit commit and we want to say that we added not simply q we want to say that we connected up what do we do we have connected let's see let's do two commits here so first number one is added lnf and rotary slider with labels from simple eq that's this stuff here stage this stage this and that's these guys and then that's also this stuff here here's our look and feel that's the look and feel stuff this is all rotary slider with labels stage u okay cool so that's adding the look and feel and rotary slider with labels from simple eq now what did we do next next we did let's see we added um sliders to global controls and then we also wired up the attachments there's our global control there's where we laid them all out with flexbox okay great next let's connect them to the rotary slider with labels all right go to plugin editor.h let's switch these sliders out the rotary sliders with our rotary slider with labels class now this rswl class has constructor parameters specifically and wants an audio parameter first now we have this parameter names map right here in our constructor with the attachments so i'm going to put these sliders on the heap and this is going to let this will allow me to initialize them inside this constructor so i can reuse this map okay if i didn't do that then i would have to use this params dot get params at for each of these sliders and that would be super annoying it would also be really verbose okay so that's why i'm not gonna do that so let's put these on the heap let's get rid of these guys right here let's change this to be std unique pointer rswl and do using r swl equals rotary slider with labels all right even though we're not using this anymore i'm just going to leave it leave it as is okay let's build this real quick and tackle some of these errors that are going to appear all right number one these need to be dereferenced because they are all a pointer so hold down option drag to select all the lines and add the star 2d reference let's do the same thing in resized okay now we can initialize these so let's do in gain slider equals std make unique rs oh that's not going to show us the full name so show me the full name rotary slider with labels all right okay we can fill in our suffix before we start dealing with our the thing that gets the ranged audio parameter so let's see for the uh in gain we want to use decibels so we need to look up a parameter from the ap vts so let's write another helper function that's templated that'll do that for us let's do the same thing go over to the header file we'll do the same thing that we did like we did with make attachment we'll just do it with um you know get the parameter so we'll start by calling functions on the objects that we haven't declared so let's first get a function we'll just do void get param like this and then what we need to do is get our parameter from the apvcs using our map autopram equals apvts.getparameter params.at name or position we'll do name this function returns a pointer so let's make sure it's not null j assert param is not null pointer okay now the let's see what what does this want here this wants a reference let's dereference the parameter that we looked up so let's go return param okay this jsert right here will fire if our parameter is not found but that should never happen because we are using our map to provide the names and also to create the parameters all right now we can start filling in function parameters we need our map we need our ap vts and we need our name okay so let's do um let's see apv ts ap vts we need our params so params params and then our name so name name and this should be const reference and this should also be cost reference now we just need to template it template type name apbts type name params type name name all right now we can call it plugineditor.cpp all right and let's add a helper function just like we did here our make our getparams function needs three parameters and three of those parameters are sorry two of those parameters are the params map and our ap vts yeah we can use a helper lambda to make it so we only need to pass in the name so let's do that auto get param helper equals lambda lambda lambda and let's grab our params and our ap vts by reference and now we just need our name const auto name we need to explicitly specify that this thing is going to return by reference so let's do that and now we can call our function super simple all right cool now we can fill in this placeholder with our lambda get param helper and here we want names in gain gain in and then finally we can replace our alias our rotary slider with labels with our alias r s w l cool that's clean all right now we just need to initialize these let's do the rest of them ingame slider let's see there's the ingame slider all right this is going to be the low mid crossover slider this is the midhigh crossover slider and this is the out gain slider all right this was low mid this was mid high and this was uh gain out and let's see this is in hertz and in hertz let's build that figure out if it's going to continue to give us errors or not oh you know what of course i forgot to change this return type here void return void function get param should not return value but it is returning a juice ranged audio parameter reference all right that's important i could have bogged this up for a while all right let's try it again build that should solve all the errors all right what's wrong with this one here oh you know what it's because these need to be dereferenced because this is a unique pointer now so to reference that because it wants the actual object like that all right let's try building it again voila magic all right let's run this and see what we get all right awesome those look nice and clean they display the value good times i'm very happy with that okay the problem is that they are smashed up to the top of this component so let's dial in this positioning next and we can also switch to using the standalone okay go to the resized function now let's shrink our bounding box a little bit just just enough i'm gonna go with five dot reduced five all right i want to add some spacers between the sliders and also at either end of the row so let's make some instances of the flex item class that will do that for us all right spacers are going to go in between the sliders and then end caps will go on the very ends this is just to kind of nudge everything in towards the center of it let's make the end cap a little bit bigger okay we need an end cap at the beginning and the end of the items array and then spacers in between each item all right here's my end cap and then a spacer between each item let's test it out all right cool so there's a bit more of a gap here a bit more of a gap here and then the gap in between is also a bit it has made these a little bit smaller and notice there's a little bit of a gap at the top too which is great all right let's tweak these colors next all right actually i want to add labels to the sliders next and i want to revise how this was accomplished in simple eq so let's take a quick look at what was done in that project so if i go to the simple eq constructor um let's see which class i can go to any of these classes i'll just look for dot labels okay here we go in simple eq i was hard coding these ranges okay now what i would like to do is actually extract them from the audio parameter for this project in this one i only care about the minimum and the maximum value of the parameter so let's write a helper function that can populate the labels array of our sliders and all we need to do is just give it the parameter for the range and the suffix so it's time for some more template magic let's declare a function and pass in our labels the parameter and the suffix and um we'll get it's just it's going to populate this labels array with the good stuff from the parameter let's go to our header file plugin editor.h let's go after get param now let's see we're going to modify the labels object and we're going to modify labels but everything else can be const to reference all right the first thing we want to do is first declare this function void add label pairs labels this is what our labels are all right everything else is constantly we've got our program type param and then we have our suffix type okay so the first thing we want to do is clear whatever labels are in the array so labels.clear all right so let's just add the first thing labels dot add um let's take a quick look at what was done here all right it was a we used curly brace because it's this position object we can take a look over here let's see it's in the middle of this class all right first object is position second object is a string all right labels.add curly brace first object is a string no first object is the percentage 0.f the second object is um the string okay um and actually let's add some template parameters for now we just need three let's just copy and paste this and do labels param type suffix type perfect all right we know that we need to return a string right here so let's create a function called getval string and it's going to return juice string get val string okay we know we need to pull our value to display from the parameter so let's make that a function argument one of these things next we're going to only display the minimum and maximum values so let's add a boolean flag to the parameter list and this flag will indicate if we should use the low end of the parameter range or the high end of the parameter range bool gets low the thought behind this comes from where we declared all of our parameters create parameter layout we always declared you know minimum the range start and the range end and then it was always step size and skew but you know this is like the low end of the range and this is the high end of the range and that applied for every normalizable range that we created negative 60 positive 12 5 and 500 um was there any others no there's not okay so that's where that comes from all right plugin editor dot h that's where this get low flag is coming from the idea behind that okay finally we need to append our suffix so let's make that be the last function parameter now if this was a templated function we could define it here but we know all the types so let's just declare it here and define it in the cpv file top uh well we'll define it in just a second let's use it first though all right go down here and then replace this quoted stuff with a call to it getval string all right now we can pass an hour param we can pass in our suffix yes we want to do true because we want the low parameter at the zero percent and then we can repeat for the 100 position one dot f and this should be false we do not want the low we do not want the low param we want the um yeah we want the end per value okay let's go implement this get val string next go to plugin editor.cpp way up at the top let's put this up here all right juice string get val string are you going to auto complete for me no all right let's copy it over from the header file copy paste remove that semicolon add curly braces all right we need our string juice string str let's return it next return str all right let's get our parameters minimum and maximum value from the parameters range autoval equals get low param dot get normalizable range dot start or param dot get normalizable range end okay that's part of the puzzle let's add our suffix str suffix now something that i really liked from the rotary slider with labels class was that um the k the gods appended to the little the letter k that is appended um to the suffix whenever a parameters value was 1000 or higher so let's refactor that into a function that we can use here and in rotary slider with labels and in look and feel all right so i'm gonna let's see where does that happen let's take a look at that logic real quick that's right here if the value is over 999 divided by a thousand and then we're going to add the k and then it's like if we have to add k then um we just stick a key on there before we add this suffix very simple all right so i'm going to just add a function at the top i'm going to call it truncate kilo value let's see um let's do void for right now truncate kilo kilo jeez louise value and let's i'm not sure what type i'm going to use so i'm going to do that let's template this i'm declaring it here in the cpp file because this is the only place that will get used currently all right here's the logic if the value is over 9.99 divided by 1 000. okay we're passing in by reference because we're going to actually modify this thing and then let's see if we did perform a truncation let's return true and if we didn't let's return false so if value is greater than 999 let's cast this 999 to whatever type t is all right if it's over 9.99 value equals static cast t 1 000 return true return false all right so if it's over 9.99 divided by a thousand and return true meaning yes we did perform a truncation all right let's go use it all right so we can do bool use k equals truncate truncate kilo value kilo value value all right and then um let's see don't forget this function is going to modify this if we used if it performs truncation so we can add our string now str val if we should use kilos append it as well if use k str the letter k we can make use of this in that get display string function over here get display string it's a float param now just looking at the rest of this function here we could probably revise it to use our get valve string function too but that's not something that i want to do i just want to replace this with our code so i'm just going to comment this out and do add k equals truncate kilo value all right a little bit of a code surgery all right um let's see let's go back to where we are creating our sliders because once we once we've made our let's go back to where we are making our attachments it's under global controls constructor because after we make our attachments we're going to add our labels but let's do a quick build to make sure we don't have any template errors first make sure our truncate function works all right cool all right let's use our helper function let's do this right here add label pairs so the first label is going to be the let's see i'm going to do the in gain slider labels and the param is going to be get param helper let's see names in and the suffix type is going to be decibels right let's do it for the next one let's put these on there online add label pairs let's see we got the low mid crossover slider labels pram is get param helper names low mid this is hertz again add label pairs mid high get program helper names mid high also hurts all right last one is the output gain slider add label pairs out gain slider labels get program helper names output gain whoops put that on the next line and decibels okay let's run this and we should see some labels next to our sliders let's see what we got oh build failed what happened no matching call forget val string what did i do wrong oh my get param helper let's see what's the problem candidate function you want a reference parameter what is being passed i'm passing a const reference oh that's why this should be const and that's because that's because it's const right here okay am i going to run into a bunch of const issues let's see undefined symbol yes because i made one const and the other not constant okay this needs to be const up here get val string this should be const build completed build succeeded boom all right we've got our labels negative 24 positive 24 20 hertz to 989 one kilohertz to 20 kilohertz perfect and this shows 1k awesome that's fantastic all right cool let's commit that very happy with that make our commit let's see added label pairs two sliders is that what we did um oh no we did uh switched to rswl and added label pairs to sliders perfect all right that was a lot it's not a lot of code here in this commit but in terms of like what we actually implemented that's a lot of functionality okay okay let's look at this constructor real quick we are calling get pram helper twice we're doing it right here when we make our slider and then we're doing it here again when we make our label pairs so let's fix that let's cache our parameters here and then replace accordingly that right here so auto gain in param equals okay let's replace accordingly all right and these ones down here all right cool let's build and test to make sure everything is cool all right i'm gonna change that to negative six brings you to negative six quit rerun all right awesome that works as expected all right let's add titles to our sliders so we're gonna add a third constructor parameter and give it a value of no title so let's go up to our rotary slider with labels class plug an editor get rid of this build target thing plugin editor go to the ranged no not range rotary slider with labels um we're going to add a third constructor parameter to this let's see where is that that's right here we're going to put this on its own line and we're going to give it a default value so everything still constructs um still builds without any errors const juice string title equals no title all right that's the first part we will display the component's name in the paint function so we'll call set name title now let's go to the paint function plug in editor rotor slider with labels paint wait why does this say just oh that's this should that should say juice all right uh paint function right below where we get the slider bounds let's see i want to draw this title at the top of the slider so we need to modify the get slider bounds function to account for this so let's draw our title first and then adjust the slider bounds next first let's get the local bounds auto bounds equals get local bounce next let's set a color and draw some fitted text i'm going to go with blue violet and let's draw some fitted text g draw fitted text all right i'm going to use the rectangle remove from top function to create the bounding box that the title text will be placed in and i'm going to use the get text height function plus a little bit more for this bounding box first things first the text we will display is the name get name the area let's see we're going to be centered justification centered do centered bottom and we're on one line all right let me put these on separate lines uh let's see we're gonna do bounds dot remove from top and the amount to remove is our text type plus a little bit all right let's see how that looks let's comment out this draw rotary slider stuff to begin with all right cool no title excellent all right let's uncomment to this okay so we need to dial in these slider bounds next all right go down to get slider bounds now we need to remove some space from the top of the local bounds so let's do text height minus 1.5 and see how that looks let's see what are we doing right now auto bounds is get local downs and let's trim off the top bounds dot remove from top let's do get text height times 1.5 let's see how that looks all right that's very small and it's still colliding with the title so shrinking let's see so let's change the y position of this rectangle to be the y position of our bounds let's do let's comment this out and do r dot set y bounds dot get y instead okay cool so it's not covering up the title now that's good that's progress all right let's adjust the s the slider size by adjusting the size of this rectangle here this thing right here now shrinking the size by twice the text height is too much so let's change this to be 1.5 and see what it looks like now that's much better okay this is a much more reasonable size let's remove the default parameter next go back to plugineditor.h let's get rid of this default parameter and let's build and add our titles where the error messages appear okay ingame slider you are going to say input trim in all caps low mid is going to be let's see low mid x over like that let's do this one this will be mid hi no gh x over and then this will be output trim output trim all right let's take a look at this now that we've got our titles in here okay that's fantastic now i don't like this black square in the middle that's surrounding the numbers but we'll fix all of these colors later alright for now that wraps up the global control so that's fantastic let's take a look at that one more time all right awesome very cool let's make a commit of that added titles to our swl bang boom all right so we adjusted that just that part is just that part here's where we actually added the titles we can start working on the actual compressor band controls next let's create the compressor band controls next here's the road map for this component this guy way down here compressor band controls number one we're going to add sliders for the main compressor controls once that's done we will add the solo mute and bypass buttons then we will add band selection functionality meaning we're going to change the parameters that the sliders are connected to uh whenever we click those buttons then we will dial in the colors before we add in the spectrum analyzer and drawing the thresholds and gain reduction all right let's dive in all right we are going to reuse our uh where is that class we're gonna reuse this rotary slider class for right now okay let's put this um yeah we're gonna put this after rotary slider oh let's put it after these functions let's put it above global controls okay here we go all right we need four instances of um the rotary slider class for our four compressor controls okay attack slider release slider threshold slider and ratio slider you know what comes next a constructor and a resized function let's implement those next head to the cpp file let's do this above our global controls uh constructor compressor band controls compressor band controls let's add all of these sliders as children is there anything in here that i can copy yeah i'm gonna copy this we have four sliders those are four sliders being added all right let's just delete this all right now we can add our sliders and let's see they all end in the word slider so i'm going to add that and now i can fill them in tack slider release slider threshold slider ratio slider now i am going to copy the global controls resized code to position these i'm going to move them later when we add the buttons but this is just to get them on screen so go to the compressor brand sorry go to the global controls resize function and we're just going to copy the whole thing and then we're going to paste it now we just need to change these names here attack slider oh sorry we need to change this name first to be uh compressor band controls all right now we can do attack slider release slider threshold slider and ratio slide it's very convenient all right let's change our band controls in the editor to use our compressor band controls class next select this and copy it let's go back to the header file let's get rid of our placeholder in our editor get rid of band controls here oops that's the wrong key command get rid of band controls and get rid of this comma and now add an instance here band controls all right now we just need to make it visible again so go to plugineditor.cpp go to the plugin uh go to the editor constructor and we're going to make our band controls visible let's test it out make sure you're doing the standalone version let's see what we get all right awesome our four sliders very cool so we'll turn them into these um sliders with the labels and stuff in a little bit all right i want to add the same border that the global controls has to this compressor band controls components so let's add a paint function i'm just going to copy this declaration put it right below resized now we can literally just copy the global controls paint function and just rename the class and we'll get that so go to plugin editor go to global controls paint literally copy this paste it after the compressor band controls resize function and just click change the class name compressor band controls change it to like that all right let's run it and see what we get all right i'm very happy with that remember i had said i wanted to have a border with a bit of a gap between the um between these modules all right so that's very clean let's refactor it next because we are literally repeating the exact same code in those two paint functions let's refactor this module background paint code so we aren't repeating ourselves i would like to declare a free function and it's going to be identical to what we are doing in paint except for the call to get local bounds that's this thing right here instead this rectangle bounds will be one of our parameters so i'm going to just put that um where should i put that i'm going to put that um i'm going to put that right above this paint function for right now we'll move it later void draw module background add an empty argument list now we're going to copy these guts over grab this copy copy and paste this and let's see all right first things first we need a graphics context to draw into then we need that rectangle bounce all right now that can let us remove this line there we go okay that takes care of that now we just need to comment out this old code here in our let's see let's do global controls first let's comment it out down here let's get rid of this and let's see i am going to need uh the bounding box so we'll do uncomment that line and now do draw module background bounds oh we also need your graphics context okay let's just uh verify that this works let's run this real quick all right global controls is still cool awesome let's do the exact same thing in global in compressor band controls copy that line scroll on up here comment all of this out and replace it like that all right perfect looks good to me let's get our sliders connected to the parameters next we will create attachments first and then we will change to rotary slider with labels all right let's clean this up we don't need that and we don't need this stuff let's get rid of this code okay fantastic all right head over to your plugin editor dot h go to the global controls and now copy these attachments from global controls we're going to copy them we are going to paste them in our compressor band controls and rename them put them right below our sliders now we're going to do attack slider attachments release slider attachment threshold slider attachment ratio slider attachment let me line these back up let's update this constructor next all right go to plugineditor.cpp go to compressor band controls the constructor and let's see what can we borrow all right we're going to do the same parameter initialization stuff that we did in uh compressor band in global band control so we can grab these things copy this stuff and we'll fix these incorrect names in just a moment all right go up here to the constructor and paste all this stuff let's copy all of that code that initialized those attachments from uh global controls so go down to global controls grab all of this stuff the make attachment helper we're going to need that stuff too grab this code paste it here all right now we need to change all of these names but we'll fix that in just a moment we need to copy the params declaration and update the constructor to receive an ap bts so let's copy that stuff from the global controls constructor as well grab this thing right here all right and paste that here as a constructor argument now let's update the declaration next copy this stuff right here go to plugineditor.h and modify this constructor oops uh this has an extra set of parentheses there we go now we need to revise how our class gets constructed in our editor so go down here and just copy these um copy how the global controls are initialized and just paste it here now we can fix all of these errors in our um constructor here all right so first things first we are doing the um attack attachment slider attachment and this is the attack slider and this name needs to be the attack let's do the um i think we said we were doing the mid band let's see what we did uh yeah we'll do we'll do the middle band first okay so we'll change that all right so there's the attack all right now we need to do release release slider release slider attachment and then this is the release mid band all right now we've got the uh threshold threshold attachment threshold slider and then threshold mid band then finally we have our ratio so this is ratio attachment ratio slider and then ratio mid band all right when we add band switching functionality we will be able to dynamically switch these attachments which will be a very cool thing all right let's test it out we are going to drag a slider quit and rerun and the slider should display this updated position let's see what we get okay i'm gonna do the uh i'm gonna do the attack time i'm gonna yeah i'll do the attack time i'm just gonna put it at 12 o'clock quit rerun the attack slider should be at 12 o'clock all right perfect it is double click to reset to the default value awesome our next task is to change rotary sliders with labels so that it accepts a pointer to a parameter instead of a reference the reason is because we will be dynamically changing the parameter in the compressor band controls class whenever we change which band is currently being displayed so the other thing we will do is to move the look and feel to our editor this way every child component inherits the look and feel of the parent class let's go to rotary slider with labels in the header file let's modify this constructor to take a pointer let's change this member initialization let's remove the look and feel member variable copy this and comment it out now by removing the look and feel we no longer need to set it here and we also don't need this destructor so that's cool now let's see before we add a look and feel to the editor let's add a member function which will allow us to change the parameter whenever we want let's go put this here right below get display string void change param and we'll go to juice ranged audio parameter pointer like that all right now we can go all the way down to our editor and add a look and feel member make sure this is the first member variable that gets constructed let's go to our editor's constructor we want to set our look and feel right here set look oh let's do it before uh before we make these guys visible set look and feel lnf make sure you're taking the address of it and now we must remember to set it to null pointer when our component is destroyed we go set look and feel null pointer oops null pointer okay now we can adjust where every rswl is created since the constructor wants a pointer not a reference so let's build it and start fixing all of those errors command b to build all right where does this happen okay so the only spot where we created these sliders is in the global controls function so we just need to pass pointers instead of references so we just need to add our ampersand in front of all these and let's test it out that should clear all of the errors all right build succeeded let's test it out let's adjust the in gain slider and see if it sticks well look at these guys all right turn that down and turn that down to 10 quit rerun it should be at 10 10.5 interesting let me do that one more time 10. okay there goes all right cool that looks good to me now let's see i just want to look at that one more time now changing the look and feel um and making the editor own the instance that all child components inherit from really messed up how these compressor band controls uh end up looking so let's fix that next all right go to compressor band controls in the header file all right this class is going to need access to the ap vts in order to look up parameters as needed so let's add a reference to that we can just copy this one right here from our global controls constructor all right next let's change all of these sliders here the attack release threshold and ratio sliders into rotary slider with labels so grab this class right here and paste it there alright we will need to use the member initializer list to initialize all of these next go to plugin editor dot cpp go to the compressor brand control constructor let's initialize all of these members first things first let's do the ap vts ap vts and i'm going to rename this to be apv now let's do all of our sliders attack slider alright we're going to start with nullpointer and our suffix is milliseconds and our title is attack let's do the others release slider same thing null pointer ms and release oops don't forget the quotes so the other two all right let's fix this error in the capture list now we need to do abbvts let's see ap bts equals this apbts like that all right now we are capturing this class's instance of the ap ap vts by reference okay all right let's test this out oh we need to um adjust this make params helper oh you know what i don't know if we actually need this get param helper yet so i'm going to comment that out i might need that in a little bit sure okay let's test this out we'll see what happens maybe we will have sliders with titles who knows uh what's going on here oh this is because it doesn't have a parameter all right let's fix that it's going back here so it turns out we did need this we need to get our parameters and now we can call change param on all of our sliders let's do that right here attack slider dot change param get pram helper let's see this thing returns a reference so we need to get the address of it and the name we want is names attack mid band all right let's do the others we got our release slider so i'm going to just copy this line whoops copy this line paste face paste release slider threshold slider ratio slider all right now this is release mid band threshold mid band ratio mid band let's test this out see what we get an error undefined symbol yes we did not implement this we declared it but did not implement it so let's do that next let's go up to where our rotary slider with labels get display string is we're going to put this at after it void rotary slider with labels and change param is the one we want so whatever parameter we pass into this is um what we need to give it um let's see so this becomes param equals p and then once we get a new param repaint let's try this out all right awesome so these are almost fully functional we just need to add labels next all right go back to the constructor we can use the add label pairs function that we wrote for all of our sliders except the ratio slider and the reason is because the ratio slider labels need to have a colon 1 at the end so we need to define those manually so let's start here add label pairs our first labels are the attack slider dot labels parameter is the get param helper attack mid band we'll refactor this in a little bit those need to be cached does that want to reference it does want a reference we're giving it that all right and our suffix is going to be milliseconds okay do the same thing for the release paste release slider release mid band and then threshold copy paste threshold slider threshold mid band and this needs to be decibels db so the first label for the ratio slider the first ratio is one to one so let's make a label position element let's add a curly brace for this for default initialization all right so at the zero percent position we want to see one colon one all right now the second one should be the highest ratio uh defined in the list of choices so let's get our ratio param let's see this is a juice audio parameter choice and we want to call get param helper we want our names ratio mid band all right now we just need to get the last entry from this let's add our line first um why can't we not why can we not use cannot convert from this to that um oh this returns a reference that's right we should take the address of the reference return okay so now let's see we want ratioslider.labels.add and this is for the 100 position and now we are going to add um let's see ratio param choices and we want the last one how can we do that we can do get reference and then ratio param choices size minus one okay let's see how that looks so this is displaying 100.0 and we wanted to say 100 colon 1. so we need to get the integer value of this string and then turn that into a string and then append the colon one to the end all right we can do that we need to change this to be uh choices get reference i'm gonna put this down here all right choices get reference give me the last one all right now you're going to give me the int value and then um let's see i need to turn this into a string first put that in parenthesis juice string and now i can append colon 1 to it let's see how that looks there we go 100 to 1. perfect now let's make the center of the sliders display the current ratio next so for this we will need to derive from the rotary slider with labels and customize the get display string function all right head over to your header file plugin editor.h go to the what's the name of this class go to the rotary slider with labels class all right we are going to override this get display string function so we need to make it virtual first ritual and then we need to make these member variables protected instead of private so the derived class can access them let's clean this up too while we are here all right let's declare a ratio slider class below this now this is a ratio slider which means we can hard code the title whenever we are initializing the base class we still need everything else though so let's just copy all of this paste it here change this class name and fix this indentation all right so all we need is the suffix and the rest is for the base class rotary slider with labels and put this on its own line all right we're passing in our ranged audio parameter our unit suffix and then ratio perfect curly braces all right now we can implement the function that we care about this guy right here get display string override let's implement it next let's go to the plugin editor.cpp go to the uh change param function we're gonna put it right below that all right so let's start the implementation this function returns a string okay what we need to do here is get the name of the current choice to do that we need to convert the program into a choice parameter so that's uh step number one auto choice param equals dynamic cast juice audio parameter choice param let's make sure that we can cast it once we have our choice param we can just get the current choice name now if you remember it displayed 100.0 when we used the choice name directly this is because we declared our choices as doubles because i wanted 1.5 to be one of the choices and everything else is an integer value basically which means it's gonna end up with that point zero at the end so if the choice ends with point zero just remove that from the string if current choice dot contains point zero get rid of it current choice equals currentchoice.substring our starting index is zero and our endpoint is the index of that period because the end index is not included in the substring we go from our starting point up to but not including the end currentchoice.index of okay once we've done that just stick the colon at the end current choice colon one all right there's our display string let's test it out let's return it return current choice see what happens nothing and that is because we forgot to change our ratio sliders type copy this ratio slider go to the header file go to the uh where's this class go to the constructor go to the compressor band controls class and change the ratio slider to be that ratio slider all right let's run this we should see the ratio in the center nope we uh what's wrong oh we don't need this third parameter that's why all right let's fix that all right third time's the charm okay cool there we go we're seeing our ratio in the middle let's cycle through them see what we get four five six seven eight nine ten fifteen twenty 100 perfect and what happens when we get to 1.5 is that a thing perfect all right let's make a commit of that so implemented basic comp band controls perfect stage stage let's add the solo mute and bypass buttons next we will position them and then connect them to parameters go to the header file go to our compressor band controls and let's add these after our attachments juice toggle button is the weapon of choice here okay bypass button solo button mute button let's set the name next go to the plugin uh go to the constructor compressor band controls let's do this after we add our sliders bypass button dot set name we're going to draw the name the name is what will be drawn when we configure the look and feel bypass we'll give it an x solo will have a big s in it and mute will have an m okay let's add them next i'm just going to copy three of these paste and now copy paste copy paste copy paste let's go to our resized function okay this component will have band control buttons on the right and band select buttons on the left so let's write a helper function to wrap this vertical arrangement of these buttons in a flex box somewhere since we are using flexbox already for the sliders so first we will pass in a vector of pointers to components that'll look like this std vector component pointer comps then we will declare a flexbox that we will be adding the buttons to but the column direction we can just copy this the column direction or the direction will be column instead of row that's the only change we're going to make there number six i want a small spacer between them so i'm going to copy this again this is vertical so we're going to do with height and i want it smaller than 4 2 pixels is fine all right now we just need to loop through our components add a spacer before and then add the component to the flexbox for autocomp comps flexbox.items.add add the spacer first then add the add to the component add a flex item with a flex of one now our item list currently goes spacer component spacer component spacer component so we need to add one more spacer at the end now we can return our flexbox all right so this is going to be used for the buttons on the right the bypass mute solo buttons and then the band select buttons on the left all right now we can call it we can call our lambda like this with our band control buttons with our uh not banned control buttons with our um uh yeah band control buttons that's right um the bypass mute solo buttons auto band button control correct capitalization auto band button control box equals create band band button control box and we need to provide a vector of our a vector with our components we want the address of the bypass button address of the solo button and the address of the mute button okay next let's get rid of this end cap for now and we're going to replace it with a spacer and now let's add the band control button box on the right flexbox.items.add band control button box band button control box and let's give it a width uh this needs to be wrapped in flex item declare a flex item and let's give it a width uh let's see 30. i you know i usually enjoy buttons and i like gooeys that have buttons around like the 20 to 30 size so we'll start with 30. see what we get okay we're not seeing them let's check the look and feel class next all right let's see go up to the look and feel draw toggle button all right if it's power button it's going to draw something if it's an analyzer button it's going to do something else okay it doesn't do anything if it's neither of those so let's add an else clause it's a pretty silly error okay let's draw a rounded rectangle with the component name in the middle all right if the button is on we're going to draw a black text on a white background otherwise draw a white text on a black background we'll dial in these colors later first let's get our bounding box auto bounds equals toggle button dot get local bounds and i'll shrink it a little bit alright if the button is on it would be nice to know all right let's give ourselves a corner size because remember we're doing rounded rectangle all right let's fill a rounded rectangle with the background color first g.set color if the button is on we're gonna do white otherwise we're doing black and now let's fill our rectangle and then invert the colors and draw a rounded rect followed by the text so g dot let's just copy this line invert the colors so if it's we're gonna do black first and then white depending on if the button is on or off now let's draw a rounded rectangle g dot draw rounded rectangle our corner size is going to be corner size our line thickness will be 1 and our rectangle will be bounds dot 2 float all right now let's draw our text g.draw fitted text we're going to draw the button get name we're gonna draw it inbounds we're gonna be centered and we're gonna occupy one line of text all right let's test it out boom all right got some toggle buttons fantastic all right let's connect them to parameters next okay go to plugin editor.h go to the bottom of compressor band controls and let's add some attachment i'm just going to copy this code we only need three of these we're using a different attachment we're using button attachment and we cannot use an alias without redeclaring one so let's do btn attachment like that and an indent indent indent we don't need uh we only need three of these so we'll do bypass button attachment solo button attachment mute button attachment and let's indent these so they all line up nicely okay and now head over to the constructor we want compressor band controls and let's use our attachment helper to initialize them make attachment helper our attachment is going to be let's see we'll start with bypass button oops bypass button attachment our name is names um we're doing mid band right bypass mid band and our slider is the bypass button i'm glad we templated that class because it means we can use it with any component not just um not just sliders all right let's do this again i'm just going to copy and paste this and rename stuff all right we've got bypass we got solo attach um we've got mute attach let's see the solo button this was the mute button solo mid and mute mid okay let's test it out that was very quick all right let's let's see um let's um let's close this this will be bypassed close that rerun all right bypass is still working all right let's go test this out in audio plug and host and we adjust the sliders and the solo bypass buttons and see if we hear any differences all right here we go oh headphones all right we're soloing the mid band and we can adjust all this stuff that is definitely working mute that band seeing it dipped out very cool let's give it a real quick release time that is definitely working all right right past that turn that off stop save quit all right we're getting there okay all of these are working the next step is to add buttons that let us select which band the sliders are actually controlling let's do that next all right let's add three buttons to allow switching of the bands go to the header file and just put them at the end of the list low band mid band high band let's go to the uh constructor and set their name there's a brand i'm just gonna duplicate this i'm gonna put this after the attachment stuff this is low band mid band high band low mid high okay these buttons need to be grouped together so that when you click on one the others toggle off that's what the radio group id is for so low band dot set radio group id set them all to one all right we'll do low band mid band high band these are all part of the same radio group let's make them visible we will position them next paste and now copy paste copy paste copy paste okay let's add another flex box go to the resize function we've got our band button control box let's add another one for the select buttons auto band select control box equals create band button all right let's add our vector with our three buttons low band first mid band next high band last all right let's get rid of the end cap let's replace it with a spacer and now add the band select box on the left flexbox items add flex item here you are going to control the band select control box with flex of one and we're gonna need one spacer after this let's see i'm not gonna do it with with with this flex actually i'm gonna do it with a fixed width um let's see okay so the band control box had a width of 30 um and that was displaying a single character of text so i know that this needs to be wider because it's displaying you know three or four characters so let's try 50 and we need a spacer after it as well all right let's take a look all right those look nice like that that looks good it's nice um nice positioning of everything so i'm happy with that so let's save this quit this those buttons don't do anything but we will fix that in a bit for now let's make a commit of what we've done what did we do we added um added control buttons to band control what is this thing called compressor band control class presser band controls that's what we did stage stage that um let's see here's where we customize the look and feel here's where we added all of our buttons here's where we added them to the flexbox stage stage stage commit all right awesome if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming4musicians.com and you can message me directly in the slack workspace and i will help you directly let's make these band switcher buttons work whenever we click on one of these buttons we will simply reset the slider and the button attachments and recreate the attachments okay the tricky part is figuring out which button was clicked now we're going to be doing all of this stuff before we make our buttons visible so first let's define a lambda that will be called whenever each button is clicked let's capture a safe pointer that is alive for as long as this class exists all right we're going to just speak some stuff into existence all right we're going to do this after we set our radio group and before we set everything visible all right here we go let's make a let's make this lambda all right we have uh declared that a safe point or member variable exists so let's um let's go make one okay go to the plugin editor dot h at the bottom of the compressor band control let's add one here juice component safe pointer come on auto complete there it is all right and it is a compressor band controls and it is an instance created from this and it's called safe pointer and initialization requires curly braces okay all right go back to that constructor okay let's do a quick build to clear that error okay if our save pointers component is valid let's call a function that updates the attachments if auto all right if the safe pointer component exists let's call a function on it alright i'm going to just call a function that doesn't exist yet but it will update attachments okay it doesn't exist yet but it will let's go declare it next plug in editor go to the bottom of this put it right here void update attachments all right we've got our declaration in place let's go implement this after we finish doing what we need to do in the constructor so go back to the constructor because we're not done there we can do a quick build to clear that error all right we've got this lambda so let's assign it to the on click member function why is that still giving oh there it goes error is gone because it says bill succeeded so that's just xcode is just taking a while to catch up all right here we go band dot on click equals button switcher do the same thing for the other three bands low band mid band high band oh sorry don't no parentheses all right we want low band mid band high band okay whenever one of those buttons is clicked it is going to call this function now before we implement update attachments let's make the low band the default band choice by setting the toggle state to true and then we can call our attachment updater function which will connect all the attachments to the appropriate sliders so first set the toggle state to true low band dot set toggle state true and we do not want to send a notification the reason is because sending a notification will trigger this lambda and we don't want that to happen don't choose notification type don't send notification all right let's call update attachments update attachments now we can go implement the update attachments function all right let's start this after the paint function right here void compressor band controls update attachments okay there are a few problems we need to solve in this function number one we have to figure out which button was clicked now we can do this by checking the toggle state of all of our buttons they are part of a radio group which means only one button can be toggled on at a time problem number two we have to figure out which parameters go with which buttons and number three we have to create the parameters like we did in the constructor so first things first let's figure out which button is clicked i don't want to use integers for this so i'm going to declare an enumeration and declare a variable that uses that enumeration as the type then i'm going to immediately invoke a lambda that will determine that variable's value first things first here is the enumeration scroll a little bit and here is the immediately invoked lambda all right this logic is very simple if it's the low band we're going to return low band type if it's the mid band we return the mid band type if it's high band well then the only thing that's left if it's not lower mid is high okay very simple all right next the plan here is to use a switch statement that works off of whichever button was clicked to populate a vector that contains the names from our param names enum that we can use to look up the parameters once we have that vector we can easily figure out which parameter to use with each attachment we have our band type from this lambda now we simply switch based on this band type let's let the autocomplete fill out all of the cases for us switch band type let's get rid of these and press build and wait for auto complete to tell us that we are missing enumeration values there it is all right add missing switch cases thank you let's reindent those correctly all right let's get rid of this get rid of these placeholders okay we have all of our cases now in our switch statement we can declare our vector next and then fill it with values from the param names enumeration next i'm talking about this enumeration right here this thing from a long time ago in this project all right let's create our vector next we're going to need our params namespace using namespace params std vector names names okay we can fill in the switch cases next with the param names for the selected bands so for the let's do the low band first names equals let's see um we need to do this and it's going to complain if i don't define the type because it doesn't know what i'm doing let's see this is going to be names if it's the low band then we're using the attack low band we're using the release release low band and we're doing the threshold let's see attack release threshold ratio and the bypass mutant solo all right this is what to do when it's the low band all right i'm gonna put this in curly braces okay we need to do the exact same thing for the mid band and the high band so grab this stuff paste it and just start replacing the values 1 2 3 h i g h okay great all right fix any errors that come up while you're typing it make sure that for the high if the high button is switched you're using high params if the mid button is switched make sure you're using mid params all right so here's the thing to notice from this we are always doing the same order attack release threshold ratio mute solo bypass attack release threshold ratio mute solo bypass same for here attack release threshold ratio mute solo bypass let's define another enumeration for the possible positions in this name vector and we will index into the names array using this position vector so enum position attack release threshold ratio mute solo bypass let's get our param name map that's auto params whoops that begins with the p params equals get params now the next thing to do is to update the parameter that the slider is connected to let's grab that param helper lambda from the constructor and we need to modify it to use the names vector to provide the parameter name so let's go up here go to our constructor we want the param helper copy this thing here copy go back to our attachment function we're going down here after our position enumeration and we need to capture our names vector and we're going to be using our position thing to index and do so let's just change that pos just so we know what we're doing and now we're going to use let's see let me call get param return get param okay we're passing the ap vts yes we are passing our params map and our name is taken from our names vector at the position this thing right here okay so we're looking up um let's see we have our names array and we're pulling out a position from it so if we pass attack into names and it happens to be the high band we're going to get back this enumeration value and then we're going to pass that into get params as the name of which position to get for the map okay it's a little bit of in direction there to figure out all that stuff all right now we need to reset the attachments before we create new attachment i'm not sure exactly why this is necessary as make attachment ends up calling the same destructor of the slider attachment class however if this is omitted then the sliders don't display the correct value when they are refreshed so if i figure out the answer i will let you know but for now just you know trust me on this attack slider attachment dot reset we have to do this for all of the sliders all the sliders and all the for all of the attachment all right let me work on that now now we can change our parameters and add label pairs to our sliders so let's cache the parameters so we are not calling the helper function twice for each parameter now remember that changing the parameter repaints so we need to add the labels before we actually change the parameter so let's get our attack parameter first auto attack param equals get param helper and our position is going to be the position attack okay remember we are using our names thing to look this up all right and our name our names vector is one of these three choices it could be could contain all midband param lookups it could be low band param lookups could be high band param lookups all right that's how all that stuff works okay let's get um let's add our label pairs add label pairs attack slider labels our param is going to be the attack parameter and our suffix is milliseconds all right and now we can change the param attack param excellent now do the same thing for the release param and the threshold param now for the ratio in the constructor if you recall we could not use add label pairs instead we had to manually code them up so let's grab this code because we're going to reuse it actually all this stuff is going to end up getting commented out but let's copy this and actually we need to clear our ratio slider labels ratio slider dot labels dot clear okay all right copy this stuff actually we don't need any of this now because none of this this is all getting set in that attachment um update attachments class we can come with that out now oh we don't need our end cap i'm a big fan of not having any warnings all right way down here at the bottom all right let's get our um our ratio param auto ratio param as a um let's see it's a ranged audio right now we can replace this all right our ratio param is going to be ratio param wrap all right and then now we can change our parameter ratio uh ratio slider dot change param ratio param okay great now we are ready to start updating our attachments so let's use our make attachment class directly ins uh our make attachment function instead of that make attachment helper well we could use that actually let's see where is that helper there's button switcher there's make attachment helper okay here we go grab this guy let's see let's see if we can use this make attachment helper all right make attachment helper first one is the attack slider attachment our name is going to be the names array and we want the position attack our slider is the attack slider okay let's do that for the release slider next now for the threshold slider and now the ratio slider next to the button attachments let's do bypass button first then we'll do solo and finally the mute button all right now we can go to the constructor and delete the code that configures the attachments and the sliders because this function does all of that for us this is a bit of a monster function all right let's go up to the constructor all right we don't need any of this um attachment stuff all right cool we don't need any of this grit get uh get param helper which means we don't need these either is that right can i get rid of that too i can get rid of that excellent all right let's run this switch to the standalone editor that was a big big chunk of surgery we did there on the code out of range why is that happening named that position what is being called here what position did i choose ratio mid band oh uh this is the wrong one okay for this yeah this should not be the names ratio this should be position ratio there we go okay all right there we go okay we're defaulting to the low band that's good all right so to test this out let's uh let's see we're on the low band now let's switch the threshold to like whatever like negative 24. cool let's switch to the mid band that goes back to zero let's switch back to the low band negative 24. perfect all right cool all right the sliders are currently reflecting let's chest the low band i'm going to change this from 50 to 150 whatever go to the mid band go back all right cool that works as expected if i go to the high band and change i'm going to change the release super short so this was five now it's 250 now it's five all right perfect so the next thing to do is to make the solo mute and bypass buttons have custom fill colors to reflect their state then we will make the band selection buttons reflect that state as well so that way if you're on the high band and the low band is bypassed this button will reflect that it's bypassed even though these buttons are currently showing the high band state we'll do that next let's close this let's make a commit of what we did what did we do we added let's see wired up band selection buttons that's a good way to describe it all right let's clean up that constructor um where is that that's here we have a lot of code that does not need to exist let's get rid of this stuff and this stuff all right great let's clean that up stage commence there we go commit awesome all right next we will um next we will adjust the colors that get used whenever you click on a button okay the next thing to do is to make the bypass solo and mute buttons change the slider enablements as well as change the color of the band select buttons also because these buttons are not part of a radio group that means we need to manually make sure that only one button is toggled on at a time that means we need to modify the audio parameters so that only one parameter can be true at a time remember clicking the button changes the audio parameter and the gui then updates itself to reflect the latest value of this audio parameter so we need to accomplish a lot of stuff whenever we click one of these banned control buttons so let's use button listener instead of the button on click lambda to coordinate all of this first things first let's go to our header file and let's inherit from button listener juice button listener let's add a destructor and the appropriate callback all right there we go got my destructor and the appropriate callback for the listener class let's add our band controls as a listener to all of our to our three buttons where are those guys those guys are right here let's do this before we set our name let's do this yeah right here it's fine bypass button add listener this class all right do the same for the solo and mute paste that copy this paste paste let's add the destructor and stop listening to these three buttons put that right here pressure band controls just copy these guys copy these three lines paste it and change this to say remove listener copy paste copy paste copy paste okay the next thing to do is to implement the button clicked function all right let's put this after paint go to the paint function and put it before update attachments void compressor band controls button clicked step number one is to update the slider enablements if you mute or bypass a band if um if a band is muted or the band is bypassed the sliders should be disabled it's extremely common for audio engineers to be adjusting a parameter you know tweaking a knob and they think that the sound is totally changing like totally different wow this sounds so much better when i tweak this knob only to find out that the plugin was bypassed the entire time when they're done it's this placebo effect but it's with audio so implementing this will prevent this from happening so let's call an imaginary function that does this first and we'll implement it next so here we go update slider enablements that's the first thing we will do let's go declare the imaginary function that we just called copy this header file go to the bottom of it put it after update attachments and let's put this right after oh let's give it a return type void let's put this right after our button clicked class for right now void compressor band controls implementation real quick okay here is the logic to implement if the band is muted or bypassed disable the sliders a simple or statement will give us our disabled status auto disabled equals mute button dot get toggle state or bypass button get toggle state if a button is mute if the band is muted or bypassed it should be disabled once we have our disabled state we just set each slider to that state attack slider dot set enabled if the mute button is on then that means disabled is true and it should be disabled if disabled it should not be enabled so we want opposite of that disabled okay if disabled is true then enabled should be false so if so we want to pass the opposite of disabled all right do this for all four sliders attack slider release slider threshold slider ratio slider let's try this out run this and now let's bypass and cool we can't we cannot interact with these and now we can perfect all right the next thing to implement is replicating the radio group functionality now we cannot use the radio group functionality that comes with the juice button clasp because those require one button in the group to always be on we don't want that we want to be able to solo and unsolo we want to be able to mute and unmute bypass and bun and bypass and also prevent being soloed and muted at the same time so that's way different okay we need to be able to have i'll show you what i'm talking about we need to be able to have these buttons in toggled off state and radio group will not allow that at least one button needs to be on in the radio group well not at least one button needs to always be having a toggle state of true in the um in the radio group okay so that's why we cannot use radio group let's write a function that is called after this guy that updates the solo mute and bypass toggle states so we need to pass in the button that was clicked so we can update the nonclicked buttons accordingly let's call our imaginary function and then implement what it does next update solo mute bypass toggle states and update it with the button we passed in and we're going to pass it as a reference because yeah because it's yeah let's let's just do that all right let's go declare it copy this function name go to the editor put it at the bottom void and pass in a juice a regular juice button as a reference clicked button excellent all right let's implement it next go back to plugin editor.cpp let's put this after slider enablements before update attachments void compressor band controls update solo whatever that huge name was that we came up with all right the logic here is pretty simple if you click the solo button on toggle the mute button and the bypass button off if you click the mute button on toggle the solo and bypass buttons off if you click bypass on toggle the mute and solo buttons off and if you click a but if you click a button off don't do anything and we need to remember to send the notification as that is what alerts the parameter attachment to update the audio parameter all right so here is what this code ends up looking like i'll show you the first one if the clicked button is the solo button and the solo button was clicked on set the bypass to false and send that notification to update the parameter do the same for the mute button set the mute button to off and send the notification all right now we need to do the same thing for the mute button as well as the bypass button okay there we go if the clicked button is the mute button and the mute button was toggled on turn off the bypass button and turn off the solo button if the clicked button is the bypass button turn off the mute button and turn off the solo button let's try this out we should be able to click on the buttons and only one should be toggled at a time all right solo mute mute bypass bypass off solo on soul off mute on mute off all right cool that works as expected so the next thing is to make these solo mute and bypass buttons use a custom color whenever they are toggled let's make a commit before we go any further what did we do we added um let's see we uh added solo mute bypass click functionality that's a i don't know any other way to describe it and that's a pretty good description of what it's doing um added extended click functionality all right commit that stuff okay all right like i said the next thing that we have to do on our todo list is to make the band buttons for um first we have to make the solo mute and bypass buttons show a custom color whenever we click on them and then we need to make the band select buttons reflect that state of the band but before we do that we're going to do something else before we tackle the next item in the band controls to do list let's create separate files for all of the classes we currently have in editor um editor.h and editor.cpp so these this these two source files are getting pretty cluttered so what we're going to do is one class or namespace per source file so here is the process we're going to use producer to create a new set of source files we're going to migrate the class over and we're going to repeat this until all nonoriginal classes and namespaces have been moved into their own source files once that is done we're going to correct all of the include directives and keep trying to build until it builds successfully so let's go over to producer let's sorry let's go to our header file first let's go all the way to the top alright first thing we're going to do is look and feel okay first thing we're going to do is look and feel new cpp and header file look and feel all right that went in the wrong place let's get rid of that put it here look and feel all right save and open now go to plugin editor and just start migrating stuff over okay let's do the cpp file next this is an instance where it's very helpful to use the assistant editor all right that's one class oh we don't need this anymore let's get rid of that okay let's do rotary slider with labels and we will put the ratio slider in that class as well because it's you know it has like minimal there's no reason for it to be its own to be in its own separate source file so we'll grab all of this and put it there okay let's do ratio let's do a rotary slider with labels rotary slider with labels grab these guys cut paste and we need our juice header we need to copy these functions collapse collapse and ratio slider okay cut and paste all right next we can do our buttons the analyzer and the power buttons these guys are implemented in class so we just need a header file for that well you know let's do header and source custom buttons cut custom buttons include juice header all right let's move this analyzer toggle button copy paste add the fully qualified name and get rid of this there we go and we don't need the override keyword okay uh placeholder component and we can leave that we do need to yeah we'll just add those as like um we'll just do like utility utility components utility comps utility components okay copy these guys paste them here juice header plugin editor all right our placeholder constructor might as well put the paint function there and now our rotary slider there we go okay next all right we need some utility classes for all of these templated guys utilities i'm just going to call it utilities all right let's see we need to move make attachment that goes here what else goes here um get param that should go there get vowel string declaration of it that should go there let's grab um get val string that goes here let's see um we can do this truncate kilo value that's templated so that can go here as well and then add label pairs all right let's see what else should go there i think we can use our draw background function where did that go that here that's in this class draw module background let's do that one too that should move as well cut this put that at the end of this cpp file and grab the declaration okay all right now we need a compressor band controls compressor band controls all right you know let me let's organize these let's see sort alphabetically there we go okay plugin editor dot h let's grab compressor band controls paste it here and don't forget the juice header all right let's collapse all of these so they're easy to copy sized paint button clicked update enablements update solo mute update attachments okay copy all of these over all right what do we have left global controls okay last one global controls all right plugin editor we need our global controls paste them here include the juice header and now let's grab our global controls from the cpp file collapse all these down okay cool it's just three functions very cool all right and is there anything in plugin processor yes we have our params let's do that next params let's add the juice header and we can probably move this to the cpp file um it's not necessary though all right next one is compressor band let's do that next compressor band all right let's copy this guy over okay include juice header awesome and let's see we can do all of this cpp file very simple all right just turn all these into declarations oh you know we're here we can check off some things we did our global controls those are done we have added our main band controls that's done we added solo mute bypass and we did band select functionality very cool so we have split all this stuff up and if we build it we're going to have a ton of include errors let's fix that stuff next the way that you do this is just start building it and tackling the errors expected namespace so we need to include that include params.h just start building it until stuff disappears all right compressor brand control unknown type name rotary slider with labels let's include that include rotary slider with labels go to the next one ratio slider that's part of that class that's fine um okay button listener let's just see what it does let's just start clearing stuff out look and feel needs to know about the rotary slider with labels class in the cpp file include rotary slider labels you need to know about our utility function kilo value include utilities i believe is what i called it yes uh plugin processor you need to know about the compressor band all right plug an editor you need to know about look and feel include look and feel what else do you need to know about you need to know about global controls and compressor band controls include global holes include compressor band controls global controls you need to know about rotary slider with labels global controls constructor you need to know about params all right placeholder where is placeholder located include utility utility components that's where that was all right global controls needs to know about get param that's in utilities all right cool power button you are located in those custom buttons is that what it's called that will be called that file yes all right draw module background that is found in the utilities i need to know about the params oh build succeeded all right let's run it let's see if it looks the same fantastic all right cool let's make a commit of that all right refactored into separate files that's huge there's our compressor band custom buttons global controls and actually what i want to do uh before i commit that i actually want to put these into dsp and source folders so here is let's see programming simple mbcomp uh not build source i'm going to add a new folder i should have done this when i created the files all right click um how do i make a new folder in here new folder dsp and then i'm gonna make another new folder gui all right dsp stuff goes in here compressor band goes in here that's in dsp params is part of dsp um everything else seems to be gooey gooey look and feel is definitely gooey custom buttons compressor band controls is definitely gooey rotary slider with labels is definitely gooey and utility components is definitely gooey utilities this is all gooey stuff so we'll just leave it in there all right now let's fix this by deleting this so we'll just delete the entire chunk just remove the references and just drag the whole source file in perfect save and reopen okay now we need to fix all of these includes now that they are organized correctly so let's do a build and start fixing errors look and feel not found because it is found in gui like that all right global controls all those are in the gui we can really just look through this okay this is um params is fine let's see compressor that's all going to be in there so it's really just plugin editor that needs this stuff and then plugin processor needs that stuff that way all right params you are going to be located in dot dot slash dsp like that right include dot dot slash dsp params yeah that was right okay all right any of these files that need it are going to be the same this is dsp slash same for global controls all right build succeeded let's run it just to make sure cool all right now we can make our commit let's just stage all of this okay here's our compressor band let's look at this all right compressor band that's cool that's cool also cool all right because we didn't we opted to not move this to the cvp file okay compressor band controls all this stuff all right this is fine let's commit these 23 files okay great that was an epic refactor but now our plugin editor is much simpler let's customize these button colors let's enable the ability to customize the color per button by using the find color member function of the component class these are toggle buttons that we're currently doing uh but we will use the text button color ids to figure out which color we want let's i just want to show you which ones i'm talking about if we go to draw if we go to the toggle button class and then actually go to the text button class there are several color ids that we can use we can use color id when the button is off when it's on and then the text color for when it's off and when it's on okay so we'll be working with that stuff all right let's work through this revision let me show the code first all right we are calling set color twice right here and right here one for the background that's what the first one does when we fill our rectangle and then the second one for the border that's what this one does and then the text that's what this line does okay for the background we want to use the button on color id and the button off color id okay the trick is to remember to call find color on the toggle button itself that means we need to remember to set both of these colors the button on color and button off color we need to set both of these on the button itself in order for this find color lookup to actually work we're going to customize the border color later when we work on the color scheme for the entire plugin so for now let's head back to the compressor band controls class and assign some default colors for these guys head over to compressorbandcontrols.cpp all right we're going to do this after we add our uh after we set our low bands name we're going to um we're gonna do low band and we're gonna set the color and we need to do the on color and the off color so low band dot set color and then we need to provide the name we're doing juice text text button color ids and we're doing the button on color for this i'm going to do gray all right for the off color let me copy this for the off color i'm going to do black now don't forget the on button and the off button color need to be set for this to work all right let's do the same do the same thing for the other two bands all right we just need to change the names here high band high band all right next let's set the colors for the bypass solo and mute buttons when these buttons are toggled on they should each have a different fill color i'm gonna go with yellow for bypass greenish for the solo and then red for the mute because usually when a button when a track is muted on a like an actual console it's got a red led all right and then if you solo it it's i don't know maybe it's yellow or whatever i don't know i haven't looked at a console in a while regardless let's add these colors next all right here's the bypass we'll do the bypass button first set name okay first color i'm going to do for bypass i'm going to do yellow and black yellow when it's on and black when it's off for this is the fill color not the border color the solo button next i'm gonna do lime green and black and the mute button is gonna be red and black red when it's on black when it's off okay let's test this out let's do a quick run all right cool so we get gray when it's selected that's cool and this is yellow this is greenish and red all right fantastic the next thing to do is to make the band select buttons these guys right here we need to make their fill color reflect the state of the band if the band is soloed then we want this button to be green if the band is bypass we want this to be yellow if this is muted we want it to be red every time we click a button we need to refresh these colors for the active band so let's head down to the button clicked function next all right head to the header file and we're going to add a pointer right here that is going to keep track of which band is the active band this is based off of which band select button is currently toggled on juice toggle button pointer active band and it's going to default to the low band right now we need to update which band is the active band whenever we make new attachments go to the cpp file go to update attachments and we can do this in the switch statement if we click on the low low button then we need to say that the active band is the low band if we click on the mid band and it's the mid band click on the mid band button the active band is the mid band and then finally if we click on hi active band is the high band what's cool about this is we don't have to check toggle state to figure it out all right let's go back to button clicked alright let's call another imaginary function update the active band fill colors let's call it first then we will declare it and then implement it update active band fill colors and we'll pass it the button that's currently being used all right let's go declare it next go to the header file let's put it down here void update active band fill colors juice button clicked button now this function is basically going to call active band arrow set colors with specific colors let's go implement it now copy this thing go back here and let's put this above update slider enablements put it right here compressor controls update band fill colors um what's it called yeah that's right oops let me just use autocomplete there it is okay first things first let's make sure our active band is valid i don't see why it would ever be but just you know just make sure all right and let's print out the name just so we know what's going on active band active band get name next if the button's toggle state is off we need to reset the active band's colors back to the default colors so let's call an imaginary function for that if clicked button dot get toggle state is false if the button is off then reset active band colors we'll fill that in we'll implement that in just a moment otherwise we need to refresh the active bands colors and we need to pull the colors from the button that was clicked so let's call another imaginary function refresh band button colors active band and the clicked button okay let's implement reset active colors next first let's declare it header file void reset active band colors and let's put this above slider enablements void compressor band controls reset active band colors so first the button was clicked off let's restore the active band to the default fill slash off colors active band set color and we're going to do the button on color text button color ids on color and we want to do that gray color juice colors now we're currently using gray for the default color but we will eventually build a system that lets us look up colors from the global color scheme it's going to be similar to that params names system that we built earlier but it's going to be for colors okay let's implement the other function after we do the rest of this all right so we've got our active color for on is this and then we need to do the off color and we're using black here now changing the color doesn't cause it to repaint so let's do that next let's implement the other function refresh band button colors let's declare this guy right here this one right here copy it go to the header file void let's make it static so we can use it with any button pair that we need static and the first thing is going to be juice button and then juice button color source we're going to pull colors from the color source and apply them to the to the first param let's go to the implementation cpp file uh put it above reset void compressor band controls refresh okay we're going to do band dot set color and now we need to copy copy the button on color id from the source to the band button on and we're copying um we are copying color source color source dot find color this thing since we want this color to persist when we change the selected band we need to also set the off color to the color sources on color and what i mean by this is if i click the solo button on the low band and then switch to the mid band i still want the low band to show i still want the low band select button to show me that it is soloed and when you switch bands it uses the off color when it's no longer toggled on so that's why we have to do it this way so we go band dot set color i can just copy this line okay we are setting the off color button color id to the on color of the color source and then once we set the colors we need to repaint the buttons and dot repaint all right let's test that out all right let's bypass and switch to the mid band and it still shows up as yellow so that's awesome the only issue is the text is white instead of black and then if we switch back this is cool all right solo let's bypass you very cool solo and bypass very cool all right that's awesome that works as expected so that is fantastic all right here is a test what happens if we mute a band other than the low band let's see uh let's just me let's mute the mid band let's quit and relaunch what do you think is going to happen okay the button the mid band button does not reflect the state of the band when the gui opens once we click on the band it happens so we need to update the band select button colors when the gui is loaded disable that guy now we'll leave that on actually it's a good way to test okay so let's write a function that does that and it's only going to be called from the constructor as the band select buttons reflect the band state correctly after the gui has finished loading and one of the buttons is clicked okay so this is just like we only have to do this in the constructor all right let's declare it first we're going to call it update band select button states go to the header file let's put this down here void update band select button states all right here is what it is going to do number one it is going to query the audio parameters for all three bands um for their solo mute and bypass states it is going to update the band's select buttons fill color appropriately back again huh you want some more time on camera is that what this is just going to make all the noise now all right here is what this function will do it is going to query the audio parameters for all three bands um it's going to look for their solo mute and bypass parameters and it's going to update the band select buttons fill colors accordingly this function again is only going to be used during construction to ensure that the band select buttons show the correct colors when the gui is initially loaded let's go call it in our constructor where is our constructor it's here at the top and we can do this after we um after we update our attachments and before before we make the low mid and high bands visible and we also need to enable we need to configure enablements as well so let's do that to update slider enablements and then we can do update band select button states let's add this before update slider enablement just a good place to put it void compressor band controls update ban select button states all right here's the algorithm for this function number one query the following params in the following order solo mute bypass if a parameter is on set the band select colors accordingly do this for the low mid and high bands i want to do this in a loop so let's make a vector that holds all of the program name enum entries that we need to use go check this out first we need our params namespace then we need our array of param names to check next we need to get to the parameter in question as an audio parameter bool so this will let us check if the parameter is true or false easily let's get our params const auto params equals get params and then let's make a helper auto param helper equals lambda lambda lambda let's back up on screen we need our params and we need our apv do we need ap vts yes we do but um i'm lazy we're just going to capture this and we also need a name to pass in let's see let's implement this first return dynamic cast juice audio param i never hold down shift long enough audio parameter bool and we want our get param this function which returns a point or returns a reference we need to point to that okay we need our params we need our name let's pass that in const auto name and then we need our ap vts all right great now we just need to loop through our vector of params to check and do some magic inside this loop all right so four size t zero is less than params to check size right let's get a list so this is the name of the params we're going to check so auto list equals params to check whichever entry we're on so we might be iterating either iterating through this list we might be iterating through this list might be iterating through this list let's figure out which band is currently being updated based on our index auto band button equals if i is zero then we're working on the low band otherwise if i equals 1 then we're working on the mid band otherwise we're working on the high band all right now we simply check the solo parameter the mute parameter and the bypass parameter if any of these are true we can use the static function we wrote to change the colors of the band button declared here if auto solo equals param helper first entry in our list right here we could use an enum but this is fine all right if it's this and solo get this is going to return true or false then we can do refresh band button colors and our band is going to be the band button and our color source is going to be the solo button okay let's check for the mute parameter else if auto mute equals param helper list one mute get refresh the band button with the mute button colors finally else if auto bypass equals param helpers list two last one oops that's not where that semicolon goes all right if it's the bypass button that's currently on then update our appropriate band button with the bypass button all right let's test it out all right cool the mid band is currently on so that test worked as expected i'm going to change this to solo i'm going to bypass you and i'm going to change you to muted all right let's save and quit and rerun we should see them as expected all right cool and the low band is muted which it means uh these are bypassed mute band is soloed and the high band is also muted so those are disabled so that's perfect all right and solo and bypass all right cool that is some excellent gui functionality helpful for the user let's make a commit of that dialed in custom band control colors all right good times good times let's look at our road map we have our bands reflecting this we're done with that all right and we have we got custom look and feel going so we can um we can mark that one off as well we are up to the spectrum analyzer next uh okay we're gonna do an overview we're gonna migrate it over from simple eq we're gonna get it working and then we're going to um we're going to get it drawing and then we're going to customize how it draws then we're going to add bypass functionality to the analyzer and to all bands at the same time so we still got a decent chunk of stuff to do i'd say we're about maybe 60 of the way done so the next thing we will tackle is getting the spectrum analyzer from simple eq into here if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming for musicians.com and you can message me directly in the slack workspace and i will help you directly all right spectrum analyzer okay a lot of code surgery in this one if you have not completed the simple eq project we will be reusing the spectrum analyzer and related classes from that project so you might take this opportunity to pause this video and start watching the simple eq videos so you can learn how to build that spectrum analyzer before you copy the code over to this project either way we are going to visit the simple eq repository and copy over the appropriate classes and get our spectrum analyzer functional before we start modifying it let's do that now go to your browser go to the spectrum go to simple eq and we're going to go to the um the plugineditor.h okay we need to copy over what is this thing called this is called the response curve component if we go down here we've got our let's see where is this thing yeah it's just called the response curve component okay for whatever reason that's what i decided to call it um i don't remember why but that's what i called it instead of spectrum analyzer but we will be renaming it here because it will not be displaying the response of a filter one of the first things we will do is remove the um the response curve display from this all right let's go grab this class response curve component copy this okay copy all of the response curve component copied it and now let's paste it in our plugin editor dot h paste it above the editor and let's um let's see we're going to replace the placeholder we're going to replace this placeholder here for analyzer with an instance of that response curve component analyzer okay now let's figure out what else we need to copy over by trying to build it and obviously we need to copy over the cpp files so let's grab those as well go to source go to plugin editor and now we're looking for a response curve rotary slider here we go response curve components all right paint function get frequencies get gains get x's draw background grid draw text labels uh resized parameter value change process timer callback update chain get render area get analysis area grab all of these functions copy them go to plugin editor dot cpp paste these all at the top okay let's try to build it okay first thing to do is to change this constructor parameter to be the audio processor for this project so go to plugineditor.h let's grab a copy of this simple mb comp audio processor and let's change that here simple audio right and same for right here okay we took care of this member variable and we took care of this constructor all right let's try building it again that should take care of those errors all right cool let's get rid of this mono chain we don't need this we don't need the response curve uh we don't need the response curve member variable and we don't need the update chain function next let's see okay we need path producer so let's go grab that from our repository let's see that's going to be in the header file first plugin editor dot h we want path producer where are you path producer there you are okay path producer copy all right put this at the top above our response curve component paste that okay next we need to copy over the single channel sample fifo now the explanation for how this thing is built the single channel sample fifo can be found in project 11. so if you're interested in learning how this thing gets built you can uh sign up for that course this is going to be found in pluginprocessor.h from simple eq so let's go grab that source plugin processor dot h all right single channel sample fifo copy that and let's paste it above our path producer actually uh this needs to live in pluginprocessor.h so let's put it there let's put it above our class declaration for our processor we need to copy over the channel enumeration from simple eq let's do that next go back to the repository and grab this channel enumeration i really don't know why i chose to do the right channel first and the left channel second because left is always channel zero right is always channel one but i'm stuck with it now changing it would be a huge um huge code revision so we'll just leave it as it is all right put this above single channel sample fifo in plugin processor dot h all right let's build this and see what happens okay next thing is it wants a fifo so let's grab that as well from simple eq where's that that's right here here's our fifo make sure you include the array class that's part of the fifo fifo needs that i put that above the channel enumeration again if you want to learn how to build this fifo from scratch and all the design decisions that come with it you can check out any of my advanced plugin courses because they all use it project 10 uses it project 11 uses it and project 12 uses uses it all right let's build this again let's see if we have any more errors in the single channel sample fifo none okay cool all right let's go back to the editor editor.h and uh cp and editor.cpp and get the rest of these classes working okay let's change these references right here to the simple eq change it from simple eq audio processor and change them to our simple mb comp audio processor that goes there that goes there build that all right it says no member named block type in simplemb comp audio processor all right let's see what this block type is go back to the repository um let's just look for block type let's see what our options are okay there it is using block type equals audio buffer so it's just an alias so let's um it's public let's just copy this line and put it in our plugin processor dot h and let's also copy over these two channel instances these two single channel sample fifo instances as well that are declared right below it let's copy those all right plugin processor go down to the end of the public section after ap vts is declared and put them right there all right let's do a little build and see what errors are left okay build failed all right block type disappeared so that's cool all right what do we got next okay we need this fft order type we need that so that is found at the top of where is that found it's in here somewhere let's see let's check plugin editor there it is fft order all right let's copy that let's put that at the top of our class at the top of our editor header file all right let's try to build it and what do we have here oh that's cpp file stuff let's fix that while we are here um go back to the plugin editor copy this simple mb comp audio processor go back over here run away all right this needs to be changed okay let's try that one more time okay so now we've got an error with fft data generator all right let's copy these over next we're going to grab the fft data generator and the analyzer path generator these are both found in let's see here's fft data generator and here's the analyzer path generator let's copy both of these classes they both go in plugin editor.h above path producer let's try that again again if you want to learn how to build any of these classes from scratch and learn the design decisions that went into them check out my advanced courses project 10 project 11 and project 12. they all use this spectrum analyzer so you'll be able to understand how these are put together all right let's fix the cpp file stuff okay we're getting rid of update chain all right let's see what's next update response curve let's get rid of this function actually we don't need it at all same for update chain that's gone entirely let's just keep building it there's stuff that needs to be removed all right remove this code that uh draws the response curve this line right here and get rid of that entirely all right let's next um okay update chain that can disappear response curve okay this stuff in resize we don't need any of this that can all disappear all right um we don't need any of this update chain update response curve all right let's see what happens next constructor must explicitly initialize okay we need to do that that's down in our header file plug in editor all the way down to the bottom this needs an instance of its audio processor yeah it is the audio processor okay let's try building it one more time all right let's see what we get uh we forgot to make it a visible child go to plugin editor and let's add our analyzer make it visible all right here we go let's see what we get there it is we have our spectrum analyzer in place that we can start modifying it uh let's rename it next and then modify it to display what we need it to display okay let's rename this class to spectrum analyzer right click refactor rename spectrum analyzer okay cool let's clean it up next all right let's delete these all right let's see if there's anything left in here that needs to be deleted i think we removed a lot of stuff earlier instead of just commenting it out yep that's it okay all right let's make a commit now that we have a spectrum analyzer added spectrum analyzer and associated source associated classes all right it's not wired up but that's okay we'll do that next well first let's refactor into separate files all right so we'll do what we did before we've got all of these classes so one source file one class one source file go over to producer and let's see first thing we're gonna do is add fft data generator fft data generator all right just paste that here include juice header dot h all right next let's do the analyzer path generator uh collapse it uh sorry yeah let's collapse these first this will make it easier to see what we have to do all right three classes analyzer path generator path producer and spectrum analyzer okay so let's see these are all in the gui spectrum analyzer and let's see path producer path producer and then analyzer path generator is just a header file analyzer path generator all right let's take care of these all right let's do spectrum analyzer first cut paste this here and don't forget the juice header alright next is path producer and don't forget the juice header include oops not that one choose header and then analyzer path generator include juice header.h what else do we got there's something in uh that's it for this guy so let's migrate over stuff from cpp let's collapse the spectrum analyzer collapse all of these let's grab all of them it goes in spectrumanalyzer.cpp all right next um let's see fft order let's put this in utilities put this at the top all right and then plugin processor dot h has single channel sample fifo and the fifo class so let's add these to the dsp dsp folder add new header file fifo make sure that's dsp folder fifo.h and then single channel sample fifo all right all right channel can go with the single channel sample fifo class put this here include juice header.h let's migrate over the fifo and include the juice header okay all right now we can fix all of the includes try to build let's go through the errors plug and processor needs single channel sample fifo include dsp single channel sample fifo we got no let's see where was that name no template named fifo so let's include the fifo here what is wrong with this oh yes okay unknown type name spectrum analyzer let's include that include gui spectrum analyzer spectrum analyzer does not know about the path producer let's inform it include path producer path producer does not know about the fft data generator include fft data generator include what's the other thing analyzer path generator all right fft order that was in utilities uh that wasn't gui utilities no template named fifo include dot dot slash dsp fifo all right path producer we can um we need to include the audio processor include um let's see dot slash plugin processor dot h all right build succeeded let's run it just to make sure all right cool let's commit that refactor all right refactored separate files set bar 8 file 3 vector all right we will run audio through the spectrum analyzer next and get it to display what it displays let's remove some stuff from our road map we have not looked at that for a while go to the pluginprocessor.h wait at the top let's see what do we got left all right we've done our spectrum analyzer uh we have our data structures for it we need to do let's see this needs testing and then we need to get this working this is what we're gonna do in this issue all right let's tackle this one number nine fifo usage in process block this is where we will feed audio into our single channel sample fifo head on over to pluginprocessor.cpp go to processblock before we apply our gain let's send our incoming audio into the fifos for the spectrum analyzer so the spectrum analyzer is going to show um it's going to show the incoming audio before any gain reduction left channel fifo dot update buffer right channel 5.0 update buffer all right let's switch to testing out the vst version and run some audio through the plugin pst3 run let's see what happens j sertion aha we forgot to prepare i'm glad this guy was here this was smart if uh yeah if i hadn't done this uh who knows what this thing would do all right let's go fix that go to uh plugin processor dot cpp go to prepare to play and we need to prepare our fifos put this down at the bottom left channel fifo dot prepare samples per block right channel fifo prepare samples per block all right now let's try it all right let's play some music through it headphones if needed excellent all right let's test the accuracy next just to be sure and save this quit let's make a commit wired up um spectrum analyzer to incoming audio stage u that's that yeah it's funny these two lines of code are these four lines of code are what make the spectrum analyzer actually work that's good times all right we're going to verify the spectrum analyzer accuracy next to verify the accuracy of the spectrum analyzer we're going to need an oscillator to generate a test signal now we could use a daw for this um but i'd rather use internal code to do that so let's go down to the bottom of our header file and after our split bands class let's give ourselves an oscillator the juice framework has one it's part of the dsp module we will use that let's go to prepare to play next we need to configure it let's do this after our fifos let's initialize to prepare it and then set the frequency we need to provide a lambda that takes in a position within the circle of pi and returns a sample float x this is our position within the circle of pi oops um and we can just do return st sine of x this is going to generate a sine wave all right let's prepare it all right let's go down to where we are updating our state plugin processor.cpp process block okay let's do this after update state the move here is to clear our buffer and fill it with samples from the oscillator so let's give ourselves an if block let's just say if true if it's true you're going to do this thing you're going to do buffer clear then you're going to you're gonna fill it with oscillator samples do an audio block from the buffer do a context and now we can do ask.process right this is going to fill up the buffer with samples from the oscillator all right this is going to be super annoying to listen to because it's going to be a full scale sine wave at 440 hertz so i suggest muting your speakers i'm not going to use headphones for this what we are looking for is a single peak in the spectrum analyzer at 440 hertz where did 440 hertz come from it came from right here if we go to the oscillator class way down at the bottom the default frequency is 440. that's where that comes from because you'll notice we did not set a frequency with that said turn down your headphones possibly turning them off or unplugging them or turning your speakers off and switch to the standalone version and now let's run it we can test other frequencies that line up with grid lines later for now we want to see this peak hit the zero db line oh let's change all right let's try that one more time okay so it's pretty accurate in terms of uh the the pitch let's try 500 and then 2 000 okay those frequencies are actual lines on the grid so we can go up to our prepare to play and this is where we will set our frequency ask dot set frequency is that what it's called yes it is all right let's do 500 let's test this out all right that's pretty accurate let's do uh 2000 hertz all right that's basically right on the money all right let's add a gain processor and test negative 12 db since that is a grid line on the scale on the left i'll show you what i'm talking about real quick that's over here this line right here this is negative 12. let's go declare it go to the plugin processor.h after the oscillator go back to um plugin processor.cpp we need to prepare it let's do that after our oscillator gain dot prepare spec gain dot set gain decibels negative 12.f all right now let's just process the context with it process block gain.process ctx okay let's test it out okay what i am seeing is that the peak is not at negative 12 it should be lining up with this grid line and it's not it's a bit lower than that and if we turn the gain off let's comment this out it's below the zero db line which is this line right here so there is an issue with the spectrum analyzer mapping that we need to solve and i want to test a few more frequencies though just to see if it's an issue with the amount of energy in that particular frequency band so let's try 50 hertz next go to um prepare to play let's try 50 hertz all right let's try 50. okay this is definitely below zero db and we're not applying any gain let's try 1 000 okay all right so we definitely have a mapping issue with the spectrum analyzer let's investigate that next let's go back to process block let's turn on our gain processing real quick all right as you can see the fft is not correctly displaying our test signal it should be displaying at negative 12 but it is not it is much lower than that i want to make the gain adjustable while we figure this out so let's use juice live constant to give ourselves this option this will give us a slider to drag in a popup window and we can use that to adjust the test signal level let's close this let's right here we will go gain dot set gain decibels juice live constant negative 12. notice i'm using negative 12 not negative 12 dot f that's because if i do dot f this will give us a float and i want to do integers so that way i can have um steps of like 12 11 10 9. okay let's try this off oops cancel let's try this one more time building all right here's our live constant editor all right so now we can drag this slider let's see how far up do i need to go to make it zero i have to go about 5 db maybe 4 db up to get it to line up with 0. so there's something going on with how the test signal is being mapped vertically to the screen coordinates let's solve that let's head on over to spectrumanalyzer.cpp and we're going to go to the paint function all right let's get rid of this y transform and see what happens we're going to put 0 here and we're going to put that on a new line comment it out and put that like that let's do the same thing for the right channel oh i need uh both of these there we go all right do the same thing here put a zero put this on its own line and then put the curly braces on there uh put the parentheses on there online all right let's test and see what happens okay so our setting is negative 12 and now it's showing at right on negative 12. the problem is that we can now see where negative infinity is currently mapped to so there's an issue with where negative infinity is in the rectangle that we are using to convert our fft bin values remember with the rectangle we are using to map these values the top represents 0 db and the bottom represents negative infinity so let's look at the rectangle that we are passing to the path producer all right go to the timer callback we are passing the analysis area rectangle so let's take a look at how this gets computed i go to get analysis area okay so we start with our local bounds here and get render area that's what's going on here and in this function we remove a chunk from the top then we remove a chunk from the bottom then we remove a little bit more from the top and a little bit more from the bottom okay so let me get the whiteboard so i can explain um how we are mapping this stuff okay we are mapping our signal let's see let me let me first step back all right this big rectangle on the outside that is our local bounds let me go this way that's our local bounce and then in our get uh render area this is where we remove a little bit from the top and a little bit from the bottom and that gives us this purple rectangle on the inside then we do get analysis area which shrinks it even further now we are mapping our signal between this area here and here the top line is 0 db let me draw that here this is 0 db and this bottom line is negative 48. however negative 48 is not negative infinity we need down here to be negative infinity so we need to update two things number one the rectangle being passed to the path producer needs to have a proper bottom edge that actually lines up with negative infinity right now it lines up with this it's this green greenish blue one so we actually need to make a rectangle that goes from here like that okay number two we need to tell the path producer that the decibel value number two we need to tell the path producer the decimal value that is negative infinity for that we need to figure out what is the db value of this bottom edge if this is 0 and this is 48 or this is negative 48 what is this this is uh like negative 50 or 52 or something and that's what negative and that is what is negative infinity in terms of uh this mapping of values okay so let's take care of number one first the rectangle being passed to the path producer needs to have a proper bottom edge that lines up with negative infinity let's do that first all right let's go to our timer callback let's set the bottom of this fft bounds right here to our component's bottom fft bounds dot set bottom get local bounds get bottom next we need to adjust the top and bottom values in the function that maps decibels to screen coordinates that is over in the analyzer path generator analyzerpathgenerator.h okay that's right here all right we are mapping the bottom to get height but we need to map it to fft bounce get bottom so comment this line out and do auto bottom equals fft bounds dot get bottom next we are currently adding 10 to whatever the bottom is that's right here in this lambda this magic number is also a source of inaccuracy so let's remove that all right let's get rid of this line we also don't need that cast anymore bottom top all right let's take a look at this and see if we have an improvement okay better now it's mapping negative infinity to the bottom of the screen but this is slightly off right here and if we adjust this if i put this at negative 24 it's still off that way if i go up to zero zero is lined up negative 36 and this is because it is not it's mapping the negative infinity negative 48 to the bottom of the screen instead of this line right here so we need to define what negative infinity actually is in decibels relative to this 0 db line and this negative 48 db line on screen range let's do that next all right let's head over to the path producer and way at the bottom let's add a negative infinity member variable float negative infinity let's initialize it to negative 48 just as a starting point all right let's add a setter function so we can update this in our spectrum analyzer after the component has actual screen bounds void update negative infinity float nf negative infinity equals nf now go to the cpp file all right we need to where's my path producer did i not migrate this stuff over i don't think i migrated this stuff over oh you know why because it's here in spectrum analyzer right there path producer process oops let's collapse that that belongs over here okay okay we need to look for any negative 48s and replace them with negative infinity there's one and here's the other okay this shouldn't make any visual difference but let's just test to make sure all right that's still off if i put it at negative 36 what do we get are we gonna get that same weird uh difference yep that's fine okay and zero zero lines up the top okay cool all right no difference all right let's set negative infinity for the path producer let's head over to the resized function in the spectrum analyzer spectrum analyzer.cpp go to the resized function all right as i said earlier the top line i'll show this make sure your speakers are muted uh make sure you're um yeah well i'll mute this in post okay the top line right here is 0 db this gray line and then the bottom line is negative 48. however negative 48 is not negative infinity we want the bottom of this component to represent negative infinity so first we need to get this analysis area since that area represents 0 to negative 48. let's do that first auto fft bounds equals get analysis area dot to float then we need to j map the bottom of our local bounds from the analysis area range to the decibel range auto neg inf equals jmap all right our source value is going to be local bounds as a float rectangle and we want the bottom of it all right our source range minimum is going to be our fft bounds get bottom and our source range max is going to be f of t bounds get y and our target range minimum is going to be negative 48 our target range max is zero d is zero uh float so this negative 48 corresponds to the bottom of our fft bounds and the zero corresponds to the top or the y the y value and then we are mapping our local bounds the bottom of it based on this set of top and bottom values now we can update our path producers let's print out what the bottom of the window actually maps to in decibels and update accordingly okay let's test this out all right that is almost perfect still not 100 it seems all right it seems like it's a tiny bit off but maybe it's not actually off let's look at the maximum value being produced where the fft bins are converted into decibels and i'd like to think that it should be whatever gain level our gain processor is set to since a fullscale sine wave is being used as the test signal but let's find out head to the fft data generator all right fft data generator go down to the bottom we want to see the maximum decibel level that the fft data has so let's use juice jmax to find out first declare a local max variable set it to negative infinity this is where we convert everything into decibels so we want to find the maximum decibel level all right now declare a local variable that will hold our converted bin value then use jmax to store the max value between the current max and the converted fft bins value that looks like this auto data equals this thing f of t data at index i equals data and then max equals juice j max uh our data value and our max value let's add a j assert false so we can look at what that max value has j assert false i do not want to flood the console with this max value which is why i am not using a debug macro here all right oh and here's what our negative infinity turns out to be it's negative 49.41 whatever okay let's test this out we need to press the continue button several times until the fft buffers are filled with data but let's see what we get we'll be able to inspect and see what max is set to all right max is negative 41 continue 19 negative 16 negative 16 negative 16 negative 16 negative 13 negative 12. all right 13 12. okay negative 12 3 6 5 whatever whatever okay i'm happy with that yeah negative three six five whatever okay now why is this not exactly 12 it's because our oscillator's frequency is not the same as that of one of the frequency bins so let's change our oscillator's frequency to match one let's comment out this j assert false and head over to plugin processor dot cpp go to prepare to play all right now we're gonna fix this frequency here we need to test with a frequency that lines up with the center of an fft bin the bins are spaced evenly between zero hertz and the sample rate so we just need to divide the sample rate by the number of bins minus one and that will give us the bin width then from there we just multiply this bin width by any number n to find the center frequency of the nth bin i'm going to go with 50 because it's kind of close to a thousand hertz the fft order is a bit shift value so we need to shift 2 to the left by our fft order to get the number of bins then just subtract one since we don't count the bin with a center frequency of zero hertz that's what this looks like comment this out we're going to do oscillator dot set frequency we start with our sample rate get sample rate and then we divide that by uh our bin order which is fft order um let's see what are we setting that to i think we're doing it at like a low value let's see um the spectrum analyzer where are we doing that is that in the path producer class there it is right there fft order order two zero four eight all right let's copy that go back to plugin processor this is the fft order that we want okay we take this value we shift it we do bit shifting and then we subtract one from that and this gives us the bin width and then we just multiply this whole thing let's see this all needs to be in uh um let's see that needs to go this needs to be in parentheses and this gets multiplied by whatever bin i want so i'll do 50. all right this is going to produce a frequency that lines up with the center of one of the fft bins let's check it out all right look at that boom right on the money negative 12 and if we adjust this let's do negative 24 right on the money and negative 36 right on the money all right bug solved the fft analyzer is accurate again i hope you enjoyed um this whole process because this was a really fun bug to solve for me and i'm excited to share how it gets solved because it's a really interesting problem that was good times let's make a commit of that and we've got some extra stuff in here but that's okay we have these guys we'll just leave them in there for now we can turn this off in a minute okay let's see what do we do in the spectrum analyzer um this is mapped to zero this is mapped to zero uh we moved that function all right that's what that is okay path producer um we gave ourselves a means of supplying negative infinity based on the window position um in path producer this is where we just migrated that function over okay and then fft data generator this is where we figured out the max value um i don't know if we need to commit this we can just remove it later an analyzer path generator this is where we corrected a mapping issue stage that all right all right this is going to say corrected fft mapping inaccuracies i hope i spelled that right inaccuracies don't judge me if that's spelled wrong we need to fix a bug in the path producer the float vector operations copy function is not meant to be used where the destination buffer is the same as the source that's exactly what we are doing here this causes undefined behavior and causes address or thread sanitizer issues if that stuff is turned on i can't remember which one it triggers i just remember that it triggered it at one point and yeah either way we need to fix it so we can use std copy instead we also need to make sure that the temp buffer has the same or fewer number of samples as the mono buffer so let's do this first let's add a js search j assert size is less than or equal to monobuffer dot get num samples and now um we can just force it size equals juice j min size monobuffer get numb samples all right so this makes sure that size is set to monobuffer.getnumsamples or size whichever one is smaller all right for this we will need the read and write pointers in the monobuffer auto right pointer equals monobuffer get right pointer channel num is uh we need channel number is zero and our sample index is zero we need our read pointer auto read pointer equals monobuffer get read pointer this one we're reading channel zero and we're starting at index size basically these two lines right here all right now for std copy the first parameter the first parameter is the location of the first sample in the source buffer that we want to copy so that's going to be our read pointer the second parameter is the location of the last sample that we want to copy plus one so wherever we want to copy to the end of that all right read pointer plus here we have our monobuffer dot get num samples minus size all right and then the third parameter is the destination right pointer second parameter is kind of confusing so let's break out the whiteboard just to explain uh before we do that let's comment out the old code okay std copy is annoying because of how it works but it's the right tool for the job in this situation so i'm going to explain what is happening i've got rp representing read pointer i've got um wp representing the right pointer this is the same block of memory okay it's just i'm just showing eight eight bytes for right now okay our goal is to add three samples to the end of our array the way we're going to do that with std copy is to provide the right the read pointer which is at the third index and then our read pointer plus num samples minus the size is the end of the chunk we want to we want to read from and then we say hey where do we want to put this the destination that's the very beginning so again one more time we the first argument is the read pointer this is where we're gonna start reading from then we say all right where's the end and that's the read pointer plus the number of samples minus our size our size is three our number of samples is eight so we get three minus three plus eight is eleven minus three gives us one past um it's basically gives us the index after um the range we wanna copy it's that same thing with like um string uh substring where you say here's the first index and then go up to but not including this other index they're doing the exact same thing here we start at this index we go to this we copy from here up until this index but don't include this index and then we say all right we want to copy all that stuff to the right pointer which is at the beginning and this is going to shift this whole chunk over here which is going to give us our three samples it's going to give us room for our three samples at the end that's how std copy works like i said it's not the most intuitive thing to use but it does not trigger the thread sanitizer or address sanitizer errors that float vector operations do okay so that's um that's how the std copy operation works okay all right we commented out the old float vector operations so we can go ahead and test this out all right no visual difference this is still at zero uh still negative 12 still accurate negative 24 all right cool so that's fine okay cool so we can get back to our roadmap now that the spectrum analyzer has been dialed in and it is now ready for modifying let's go take a look and see what we have left to do all right this is done and this is done all right so we need to do this next all right let's make a commit because that was um that was a pretty decent um pretty decent bug that we fixed fixed um i think it's a sand i think it's address center issue in um path producer stage and stage okay all right let's disable our test oscillator this is extremely simple go to process block and change this to if false we can remove this stuff later if we want to i'm going to leave it in in case i need to do more testing this is more convenient than just com commenting it all out we're just left with a simple warning um let's see all right the next thing to do is we're going to tweak some of these graphics a little bit and then once we do that we're going to do a little bit of refactoring and then we're going to tweak the labels and then that's going to wrap up the spectrum analyzer so let's adjust these background graphics first all right go to spectrum analyzer dot cpp go to the paint function now i want to reorganize this a little bit i want to use the draw module background first that i've been using in other classes so that's the main motivation is i want this to have that same cool border that our other modules have the global controls and the compressor band controls draw module background is in the utilities file so we need to include that that's up here at the top include let's go find it setting is that in the guise yes it is in the gui so it's just right there in utilities i go back to the paint function okay right here let's call draw module background okay this function does not return anything but i wanted to return the area inside the module bounce this area will be where we draw everything and it is smaller than the local bounce so let's change the drawable so let's change the draw module function to give us this autobounds equals that all right we're just kind of saying hey this is going to give us something back all right let's go fix that next let's go to our utilities utilities.cpp all right bounds is what it is going to return bounds is the inner reduced rectangle so let's return that let's uh say that it's going to return a rectangle here and now let's change the return type in the declaration there is that function down here at the bottom rectangle okay cool back to the spectrum analyzer all right the next step is to revise how the background grid is drawn it is currently drawn relative to the local bounds and we need to make it relative to this bounding box that was returned from draw module background so let's revise the declaration first and then pass these bounds to it where we are calling it right here all right go to the header file all right comment out the old one and add a juice rectangle as the second parameter let's copy and paste juice rectangle int bounce all right go back to the cpp file cpp file now we can pass our bounds to this function let's update the implementation next go to the implementation draw background grid let's update this to take a rectangle as the second parameter all right next we need to make this analysis area function take a rectangle as its parameter let's change the declaration first and then the call site and then the implementation go to the header file get analysis area add a juice rectangle as the parameter all right that updates the declaration go back to the cpp file all right let's pass in the bounds now and let's update the implementation next this is way down here get an get analysis area change this juice rectangle int okay we need to make get render area compute its result based on this bounce that we're passing in so let's revise that function as well and then after we finish that revision we will update the implementation let's go to the declaration and add a rectangle as the parameter back to the cpp file and now let's update the call site here we can say bounds equals that and this is no longer an auto now we can update this implementation here pass inbounds all right we are providing a bounding box now so we do not need to get the local bounce okay let's go back to where we were in the paint function because we have a few errors now since revising get render area and get analysis area we're going to get to those though let's go back to the paint function okay let's get this compiling before we continue first of all we need to pass our bounds to this uh to these functions that want a parameter so response area um is provided by get analysis area and that requires bounds in draw text labels let's draw text labels let's see what error is our first spectrum analyzer okay this one um let's see just looking at my notes here draw text labels is what it says to do next all right draw text labels needs a rectangle because get analysis needs a rectangle so let's make draw text labels receive a rectangle as the second parameter and let's call that here bounce and let's update that declaration real quick go to the header file draw text labels okay go back to our cpp file go to that paint function one more time okay we're down here and draw text labels let's pass our bounding box here um let's add our bounds here into this get render area and in this one as well bounds are there any others in here okay let's do a quick build okay we need to pass our local bounds here in our get analysis area so let's get that auto bounds equals get local bounds bounce and we can dri dry this one right here this should just be bounce all right let's see what do we have next okay the last place is um right here let's get analysis area so let's dry this getting the local bounds auto bounds equals get local bounds and now we can pass bounce here and we can use our bounce here all right let's test it out it should all look the same except for having the module border around it all right no module border all right let's investigate paint and see if we missed something aha this fill path is covering up the background let's comment it out see what we get all right excellent we have a module border and we've got this uh line right there we'll deal with that in a little bit um and then we can also tweak these positions for the text labels next that was a lot that was very surgical let's make commit of that added uh what do we do we added module border to spectrum analyzer also disabled disabled test oscillator okay here's where we modify draw draw module background to return the rectangle that it ends up yeah it returns the rectangle that is being reduced right here's where we updated our declarations to work with bounding boxes and then here's all the code surgery that we did all right let's move all of this code into its own function let's declare a private member function spectrum analyzer dot h down at the bottom void draw fft analysis we need a graphics and a bounding box we can take that from here all right we're going to pass the bounding box because we're going to draw the paths within this bounding box all right let's go call it spectrum analyzer.cpp draw fft analysis g bounce all right let's implement it we just need to copy this code and then remove it i'm going to put that right up here void spectrum analyzer draw fft analysis and uh wants the juice namespace using namespace juice all right let's get rid of this code here all right let's go to our function because it's got it we have a few errors all right first error is it wants the response area so let's take that from here got that since it's not used anymore that can go here all right let's run this all right everything seems to look okay uh let's do the um we still have that white line but let's run this let's actually run some signal through this now just to make sure you can grab your headphones if you want all right that's still working cool all right let's take care of that white line that's being drawn we can use the graphics reduce clip region function to shrink the area that we are allowed to draw within if we combine this with graphics scoped save state this reduced clip region will stop being reduced once we leave this function so this lets us draw only within this response area which is pretty handy so first create a graphics save state juice uh we don't need to write that graphics scoped stave save state triple s passing in our graphics instance and then let's do g dot reduce clip region response area all right let's take a look at it all right i don't see that white line anymore that's fantastic all right and it's only drawing it within the negative 48 0. that's awesome okay the next thing is to fix these text labels and the grid itself because uh we don't care about you know plus 24 to negative 24. we carry about um plus 12 to negative 60 because that's what our threshold range is that's what we want to see on here okay let's commit this since that was a decent bug to fix fixed um negative infinity line being visible in spectrum analyzer also refactored how fft paths are drawn all right cool all right let's continue cleaning up the spectrum analyzer go to the paint function all right let's get rid of this border we already have a border that's the uh draw module background so let's comment out everything except the draw text labels get rid of that and get rid of this all right let's test it out standalone editor all right cool it looks good all right let's dial in the text labels next all right let's take a look at this all right first things first notice that this text along the top is colliding with uh this border so let's fix that that's in the text labels function let's go to that all right this is where we draw our frequencies right in this chunk right here all right this is where we draw it okay the y position should be the y position of the bounds that we're passing in not one so that's the first fix right there r dot set y bounds dot get y remember we're passing in a bounding box that is inside of our uh module background all right let's look at that all right cool they are no longer colliding that's great see next the text on the right okay this text is colliding with the edge let's fix that again it needs to be relative to the bounding box that we are passing in not the components bounding box let's go where that is that's in the gains that's gonna be this uh set x it's currently based off the components right edge and we need it to be based off of our bounding box right edge r dot set x bounds dot get right minus text width all right the text on the left let's see how that is i'm pretty sure that's colliding too and i can see where right there where did this go all right yep that text is colliding all right so this is good this is no longer colliding that's great this is colliding this needs to be not one to the right of the component left edge it needs to be one to the right of the bounds dot the bounding box left edge oops plus let's look at that okay great our text labels no longer collide let's do a quick commit of that surgical edit corrected uh no fixed text collisions with component edge also uh removed old border all right it is now time to introduce the concept of negative infinity and max decibels as well as min frequency and max frequency these values are constants that we are going to use in this project to ensure we aren't typing magic numbers whenever we need to supply a frequency range we will use min frequency and max frequency let's go define those now head over to utility.h utilities.h plural all right define these up at the top put these right here define min frequency 20 hertz and define max frequency 20 000 hertz next let's define our decibel ranges define negative infinity this is going to be negative 72 and then max decibels will be plus 12. define max decibels 12 dot f finally we need to define our minimum threshold for our compressor bands define min threshold whoops all caps negative 60. our next job is to replace all instances of these values with our macros we will start with the plugin processor there i go to uh what's the name of this function this is create parameter layout let's change this threshold range right here this needs to be min threshold and max decibels whoops max decibels all right let's do a quick build am i including utilities here apparently i am all right cool i did not think i was but i guess one of these classes is including it all right back to the spectrum analyzer all right let's change our mapping first all right we're not going to do negative 24 to positive 24. we are going to do negative infinity to max decibels so comment this out replace it auto y equals jmap our source value is gdp we got negative infinity max decibels and then this is let's see this is going to be um bottom but cast doesn't float and then top cast as a float all right good times all right we need to do this again where else do we need to do that um right here in draw background grid so we're doing it in draw text labels and then we're doing it in draw background grid so we can just copy this first just copy this stuff and let's fix this indentation and you should be all the way to the left all right let's go to the resized function because there's a negative 48 over there all right comment out this line and add negative infinity and max decibels that's the choices all right let's test this out and see how it looks with our test signal we're going to reenable our test signal so be sure to take off your headphones or turn down your speakers when you press the go button put this on true all right let's test it out all right we're missing grid lines it still lines up with the grid line uh but our labels are wrong it says plus 12 to minus 24 and then 12 to the negative 48. so let's fix that next back to spectrum analyzer all right we need to go to the get gains function all right let's change what we are returning here first of all uh let's dynamically create the vector instead all right if we change what negative infinity and max decibels mean it can be automatically reflected here so let's start at negative infinity and increment to max decibels using an increment size of 12. start with a vector of values let's return this return values now we can do auto increment equals max decibels we can change this if we want for now this is 12 db steps now we do 4 auto db equals negative infinity db is less than or equal to max decibels and we are incrementing by our increment db plus equals increment all right let's do values.pushback db all right let's test this out see if that solves our issue with the gains all right that looks good to me 12 to 96. uh why does that say negative okay this one says the right range it says plus 12 to negative 72 which is what we want and all right this is off it's showing negative 12 and it should be showing that should be showing here we'll deal with that all right let's make both sides show the same range first all right let's get rid of the code go to the draw text labels function um there's code in here that shifts the value yes this code right here okay let's get rid of that don't clear it don't shift it all right the only thing that we need to actually change here is the x position because we're drawing the same string uh that we set here this string right here this is the only thing we need to change or sorry this is the only thing we're drawing so we don't need to change the text width we don't need to change the size we don't need to change the color we're just drawing the same string in a different position all right let's test this out we should see the same range same scale range on both sides of the fft now there we go plus 12 negative 72 plus 12 negative 72. all right great all right now uh our fft is not mapping correctly this is negative 12 and it's showing up as zero so let's fix that next go to the analyzer path generator this is the source of the problem the problem here is that we are mapping our y position to the screen coordinates and notice that the upper range is zero and not max decibels so let's change that we want to make this max decibels instead negative infinity max decibels there we go um let's see if do we need to include the utility header for that let's do a build and see see what it does maybe it'll complain maybe it won't all right no complaints that's cool let's run this now all right all right this is pretty good all right let's change this to negative 24. also pretty accurate let's change it to zero all right it might be off by like you know one db or half a db uh but for the sake of this tutorial which is free i'm going to call this good if you really want to know how to make this stuff absolutely perfect you can check out project 11 or project 12 where we create a perfect spectrum analyzer that is perfectly accurate all right let's turn off the test oscillator we no longer need that discard change all right one last test um let's do it with um let's see why did i run the standalone that looks clean now let's let's run some actual audio through it make sure it looks okay run it grab your headphones turn the volume back up so you can hear what it's doing all right fantastic okay cool all right next we're going to draw the crossovers then we're going to draw thresholds then we are going to draw gain reduction and that will conclude the spectrum analyzer let's make a commit of the work that we did what did we do um let's see um standardized how ranges are defined that's that that's what that is um fixed spectrum analyzer labels these should be reversed let's switch that all right fix spectrum analyzer labels and then we standardized how the ranges are defined all right sounds good all right before we go and implement crossovers and thresholds and gain reduction let's go through the code and replace any 20 hertz and 20 000 hertz with min frequency and max frequency where does that happen first all right here's one in analyzer paths generator right here okay this needs to be min frequency and max frequency okay there is another in spectrum analyzer um we just need to search for twenty thousand twenty one two three dot all right spectrum analyzer all right right here in uh the get x's function we're doing min freak and max all right and there should be two more let's just look for 20 000. only look in the actual project source code okay um spectrum analyzer um we're going to keep these hard coded all right plugin processor okay here's one right here this should be min min frequency and then this should be max frequency all right i believe those are the only two that remain all right yes okay cool all right those are the only two let's make sure all right our gain sliders still works our threshold slider still cool our frequency still goes 20 hertz to 20k all right cool good enough for me let's draw some crossovers next if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programmingformusions.com and you can message me directly in the slack workspace and i will help you directly we are going to draw our crossovers next to accomplish this all we need to do is get the frequency value from the crossover parameter map it to an x position and then draw a vertical line the timer callback is taking care of repainting the screen at a regular rate let's go look at um our spectrum analyzer.cpp so you can see what i'm talking about go to the timer callback okay this is repainting at a regular rate so that's good times okay so we don't need to do anything special to refresh whenever the crossover slider is dragged we just need to declare some stuff and add some functions and whatnot that can get the parameter and pull the crossovers and produce x values for us to draw from top to bottom okay let's declare a function for drawing the crossovers and call it first go to the header file spectrum analyzer.h let's do this at the bottom i'm just going to copy this draw fft analysis and rename it to be draw crossovers okay super simple let's go call it go back to that paint function and we're going to do this before we draw our text labels draw crossovers g bounds all right let's go implement it next i'm just going to put this right below the paint function because i'm lazy void spectrum analyzer draw crossovers all right i don't feel like scrolling to put it in the order that it was declared in which would mean it's after that draw fft analysis function okay we are going to be using a lot of juice functions in here so let's set up the namespace alias as always using names namespace juice okay then let's get our bounding box bounds equals get analysis area from our input argument all right next we need to give ourselves access to the two crossover parameters let's go back to the header file let's declare two member variables to do that one for the low mid and one for the mid high all right let's initialize these up to the constructor where is the constructor way at the top all right let's do this before we start our timer using namespace params whoops let's spell space correctly let's get our params map auto param equals get params all right um let's see it doesn't know where params come from so let's include where those come from include dot dot slash dsp params oh uh conflict so let's make this param names all right let's copy the float helper lambda from the plugin processor constructor plugin processor all the way to the top where's that lambda float helper this thing right here copy that go back to spectrum analyzer let's put that here and we need to change the capture stuff a little bit differently we're not using that let's go like that and then this needs to be param names and this is going to be apvts equals audioprocessor.apbts and this we're capturing param names not params there we go okay now we can use it to initialize our members float helper low mid crossover and we want our names low mid crossover freak float helper mid high names mid high crossover freak cool all right we are going to draw a vertical line from the top of our bounds to the bottom of our bounds so let's go to that uh function we were working on draw crossovers and we need to cache the top and bottom let's do that next const auto top equals bounce dot get y and then const auto bottom equals balance dot get bottom all right first we need to map the frequency to a screen position so let's copy the mapping code from our get x's function wherever that is get x's all right here's the mapping code and we can turn we can uh dry this later use a free function if we want let's change this push back into a return statement we're going to stuff this into a lambda go back to our draw crossovers all right auto map x equals lambda lambda lambda all right and here's where we're going to take our norm x and we're going to return left plus width times norm x all right what do we need we need left left equals bounds dot get x we need the width width equals bounce.get width we need our frequency indent that please all right float frequency um let's make this say all right that's nice and readable all right now we can draw our crossovers use the map x function to convert the low mid into an x coordinate auto low mid x equals map x frequency is going to be low mid x over pram get all right uh let's draw a vertical line from top to bottom g dot set color colors let's do orange because that'll stick out and we can do g dot draw vertical line our x is going to be low mid x and our top is top and our float our bottom is all right let's do the same for the mid high auto mid high x equals map x mid high pram get the value drop g dot draw vertical mid high from the top to the bottom let's test it out all right we see some crossovers let's put this right at 200 perfect works like a charm but a 2k default value default value all right awesome let's do thresholds next let's do the same thing for the thresholds that we did for the crossovers go to the um header file we have three compressor bands so we need three threshold parameters let's go um yeah just copy these rename them and we will initialize them in the constructor next let's do one more all right low threshold param let's just copy the word threshold and change this to say hi whoops hi h i g h mid threshold all right cool that takes care of the declarations let's go construct these again go to the uh constructor let's use our float helper to make our life very simple i'm just gonna copy this three times and rename it two three low threshold mid threshold high thresh low threshold threshold low thresh mid and thresh hi perfect okay let's go draw let's go to the draw crossover function and update it to also draw thresholds all right draw crossovers okay here is how we are going to draw these thresholds number one we draw a horizontal line from the left edge to the low mid crossover let me pull the plugin up so you can see what i'm talking about all right we are going to draw a horizontal line from the left edge to this crossover right here all right we're going to use uh the y value is going to be the low threshold param mapped to this decibel range okay then we're going to draw a horizontal line from the low mid crossover to the mid high crossover again using the same y value is mapped onto these screen coordinates then we're going to draw a horizontal line from the mid high to the right edge of our analysis area so we're going to need the left x and we're going to need the right x too all right let's get those guys const auto left equals bounds dot get x const auto right equals bounds dot get right now we can map our thresholds to their y position and then draw horizontal lines let's grab the y mapping code from draw background grid that's this stuff right here and turn it into a lambda copy this go back up to draw crossovers let's make a lambda real quick auto map y equals lambda lambda lambda guts of it is this mapping function we need to capture the top and bottom bottom top and we need to pass in our decibels so change that name db float db and now we just need to return it okay great now we can use it i want to use a different color than the color that i used for the crossover so i'm going to go with yellow colors yellow now we're going to draw the low band threshold from the left edge to the low mid crossover so g dot draw horizontal line our y is going to be map y and we are mapping our low threshold parameter and our left side is going to be the left edge and our right is going to be low mid x okay pretty simple let's test it out just to make sure it works we should see a yellow horizontal line for the low band depending on what it is set to all right cool it is set to negative 23 and i see that this line is right above the gray so that's cool let's put this on 12. all right nice and accurate awesome that is working as expected that means we can do the other ones uh this line is a little bit hard to see i might change this later to draw a rectangle that is you know taller with a center y of this thing whatever this y value is uh but for now i'm just going to leave this as is and we're going to draw the other lines draw horizontal draw horizontal okay we are mapping the mid threshold param and we're mapping the high threshold param our left side is going to be the low mid x and our right side is going to be the mid high x for the mid threshold for the high threshold our left side is the mid high x and our right side is the right all right let's test it out all right let's adjust the mid threshold cool and let's adjust our crossovers fantastic now if you want to make these draggable or if you want to learn how to make these draggable when you click and drag on them you can learn how to do that in project 12. we cover how to make this a very interactive gui so you can adjust all this stuff all right the last thing to do is to draw gain reduction all right we are nearing the end of our road map let's go mark off a few items ah let's make a commit first actually what did we do we um added a spectrum let's see spectrum analyzer shows crossovers and thresholds that's what we did stage um we also adjusted um used macros for min max frequencies all right here's our spectrum analyzer with our draw crossover fanciness we're nearing the end of our road map so let's mark off a few more items plugin processor.h we are drawing the crossovers that's done um and we need to draw the gain reduction so let's do that next let's go to the compressor band class all right first of all we're going to need some atomic members that will store the rms levels one for the input and one for the output all right these should be initialized to negative infinity uh we're going to need to include our header file to make use of negative infinity um these are going to get the rms level of the buffer before and after processing all right let's put these here in the private section std uh let's see i'm doing two of them so i don't want to type twice so let's do the old option drag and do std atomic float um let's see rms level db curly brace negative infinity closing curly brace semicolon all right let's change this to be input and this is output cool let's include um utilities for that include uh let's see yeah utility so dot dot slash dot dot slash all right gui utilities dot h let's just make sure that that's cool all right all right build succeeded all right next we need some getter functions so let's write a pair again i'm going to type it twice float get rms level db these are const functions and they return rms level db colon all right let's fix these names get rms output level and get rms input level and this is going to return the input returns input output returns output cool all right let's go to the compressor band uh cpp file we just need to sample the rms level before we compress and then after we compress our buffer has multiple channels so we want to compute the average rms level over all of these channels we're going to need to write a function to do that i am lazy and do not want to figure out the types that we are passing in so i'm going to template this function because templates are awesome okay go back to the compressor band header file put this after these guys all right this is fairly simple to write first of all we need the number of channels let's uh write a template function now template type name t float compute rms rms level const t buffer okay first we need to compute the rms level of each channel um let me start over first of all we need the number of channels in the number of samples then we are going to need to compute the rms of each channel and add them all together then we just divide this summed value by the number of channels and that gives us our averaged rms level for the buffer let's do that all right so first we get the number of channels and the number of samples then we get a we set an rms level to zero and now we walk through every channel and get the rms level for that particular channel for all samples then after summing them all together we just divided by the number of channels and that is our averaged rms level for the buffer nice and simple all right let's go use this function next compressorband.cpp go to the process function all right let's get the prerms level of the buffer and remember this is not expressed in decibels so auto prerms equals compute rms level buffer okay and then let's get the post rms level compute rms level buffer and i don't want to write juice decibels gain to decibels twice so i'm going to do a helper lambda return juice decibels gain two decibels and now we can use it to store our pre and post rms levels as decibels in the atomic members so rms input level dot store convert to decibels the prerms then rms output dot store convert to db post rms all right the next thing to do is to get these values into our spectrum analyzer head on over to the editor for that plugin editor dot h we need to pull these compressor rms levels poll we need to pull these compressor rms levels at a regular interval so let's inherit from timer next juice timer let's add the appropriate callback void timer callback let's go start the timer in our constructor let's do this after set size i'm going to do a 60 hertz timer so it's refreshing 60 times a second and now let's go implement it let's do this after resized void simple mbcomp editor timer callback all right the compressor bands are not public so let's make them public first before we start polling them here go to uh pluginprocessor.h way down to the bottom move these to the public section all right go back to plugin editor timer callback now that those compressors are public we can create a vector and get these rms levels so i'm going to create a vector so i only have to pass one object to the spectrum analyzer instead of six this means that the function that i write i only have to type one parameter uh declaration instead of six so you know simplify my life a little bit here we go declare a vector and grab the input and output rms levels from each band let's go write a function in our spectrum analyzer to receive this vector spectrum analyzer dot h let's make an update function in the public section void update now we're going to need to compute the gain reduction from the values that we are getting so let's let's see i'm getting ahead of myself all right first let's declare this it's going to take an std vector of float values all right we're going to need to compute the gain reduction from the values that were passed to us let's declare three variables that can hold those values all right three floats let's put these at the bottom way down here with our params float low band gr initialize them all to zero since no gain reduction is happening to begin with float mid band gr okay cool back to the editor let's pass that vector to the um spectrum analyzer uh analyzer is that what i'm calling it updates values all right our analyzer has been updated with fresh rms levels of uh input and output uh gain buffer levels whatever we're calling it rms input levels let's go implement this update function next all right let's go to spectrum analyzer.cpp i'm going to put these below the uh draw crossovers function all right void spectrum analyzer update first let's make sure we have six values j asserts values dot size equals six um i don't know why it wouldn't be that but you know just to make sure all right next i am going to help myself out and give myself an enumeration that i can use to index into this vector and keep track of which indexes point to which rms levels that looks like this all right now i can simply update my gain reduction my gain reduction member variables and then repaint the gain reduction is a negative value usually so we want to subtract the input from the output as the output is almost always lower than the input level so that looks like this low band gr equals values low band out minus values low band in all right very simple all right let's do the rest and then repaint all right in order to draw the gain reduction correctly we need to know the following coordinates per band this is going to happen in where are we doing this we're doing this in our draw crossovers draw crossovers is where we need to go in order to draw the gain reduction correctly we need to know the following coordinates per band the left x the right x where 0 db is as a screen coordinate and whereas the gain reduction is expressed as decibels again as a screen coordinate so let's um compute zero db auto zero db equals map y zero dot f all right we've got the left x and the right x that's what this stuff is and this stuff here so we just need to map the gain reduction before we can draw our gain reduction that's pretty easy to get so let's get our color first i'm just going to give it some alpha so it doesn't cover up the grid lines g dot set color i'm going to use hot pink because i want something that sticks out colors hot pink with alpha give me an alpha of 0.3 f all right now i am going to use the rectangle static function left top right bottom to create the rectangles that will represent the gain reduction and then i'm going to fill them up so here we go and i'm going to draw these behind i'm going to draw these behind the actual threshold levels all right g dot phil rect and we're gonna do rectangle um we're gonna do float and we want the left top right bottom okay our left is going to be left our top is 0 db our right side is going to be the low mid x and our bottom is going to be the low band gain reduction mapped map y low band gain reduction all right let's put that all separate lines okay let's do this again for the next um for the mid band all right so this is mid band it midband gain reduction this one is high band gain reduction okay our left side for this one is the low mid x and our right side is the mid high x for this one it's mid high x and then the right edge all right let's feed some audio through the plugin we're going to test this out we should see some gain reduction uh not standalone we're going to use um audio plugandhost we're going to feed some actual audio through this and we should see some gain reduction rectangles light up let's see what happens do we have any errors nope just the warning about that stuff that's marked false the test signal all right here we go there we go look at that rectangle that's awesome let's adjust the midband get that squishing all right all right very cool awesome okay there are only three things left to do in this project let's save and quit this let's make a commit and then we'll talk about those three things that remain uh this was added added gain reduction display is that all we did yeah that's right game reduction uh timer is part of that here's the gain reduction that's where we passed it to the spectrum analyzer those are our members that display the gain reduction and here's how we actually made it happen and then here's where we compute the gain reduction so this was cool bit of code surgery on this one pretty involved but good times all right let's talk about the major three things we have left to do let's look at our road map plugin processor.h at the top all right we are currently drawing our gain reduction done all right analyze your bypass button that's not going to be difficult um global bypass button that's got a few tricks to it and then the color scheme and the color helper stuff i want to talk about that at the very end so we are nearing the completion of this project i hope you are enjoying the journey let's tackle the control bar next uh the first thing we will do is add the analyzer button just like in the simple eq project this button will toggle the analyzer on and off let's go to the plugin editor.h let's just put this right here all right first things first let's define a class for it okay we already copied the code for this button over earlier that's right here here's our analyzer button so we just need to include that file include gui custom buttons and then we can give ourselves an instance let's put this in the uh just toss it right here analyzer button analyzer button all right next we need a constructor to make it visible and a resized function to give it some bounds plugin editor dot cpp go to the top stick that right here add and make visible analyze button uh let's make it uh toggled on by default analyzer button dot set toggle state should be on true uh don't send a notification all right let's make it sit on the left and be about 50 pixels wide i'm gonna want a small gap between the top of the component let's start our resized function void control bar resized um as i was saying let's make it sit on the left side of the gui be about 50 maybe 60 pixels wide i'm gonna want a small gap between the top of the component and the bottom um and also between the component and the spectrum analyzer so i'm going to trim a little bit off of the top and the bottom of our local bounce auto bounds equals get local bounds an analyzer button dot set bounds and we're going to do bounds dot remove from left 50 and then we need to take some off the top dot remove from top just a little bit with trimmed uh not remove from top we want with trimmed top with trimmed top all right this returns a version of this rectangle with the given amount removed from its top edge so that's what we want with trim to top four and with trimmed bottom all right because we're removing four from the top of this rectangle the rectangle that's 50 pixels that was removed from the left edge we're trimming four off of the top of that thing all right that's the width trimmed stuff versus the remove stuff can be kind of tricky the first few times you use it all right let's get rid of our placeholder once and for all go to the plugin editor get rid of the placeholder control bar and make it a control bar awesome get rid of all this stuff all right plugin editor.cpp let's connect the control bar analyzer button uh to the actual analyzer and toggle enablement accordingly let's do this before we make it visible control bar dot analyzer button dot on click equals lambda lambda lambda semicolon you go on a new line oops and we're going to capture this and we're going to do analyzer dot toggle analyzer analysis enablement and it should be on if the analyzer control button if the control bar analyzer button toggle state says so so let's just get that state bool should i'll use auto auto should be on equals control bar analyzer button get toggle state all right now we just need to make it visible let's uncomment this line let's test her out run some audio see if the spectrum analyzer turns on and off all right let's test her out all right we're going to run some audio we're going to click that button all right perfect save stop quit perfect all right um global bypass is next all right we have included uh let's see where's our header editor file all right all right we already included our custom buttons so let's add our power button next super easy um declare an instance power button global bypass button all right great let's add it as a child go to the plugin editor dot cpp up here add and make visible global bypass button all right let's give it some bounds and um see what we got all right i'm going to make it 60 wide maybe that'll look cool let's see i'm going to stick it on the right side globalbypassbutton.setbounds bounds.remove from right 60 and i'm going to trim off the top and trim off the bottom with trimmed top i'm gonna do a little less than four so i'll do two with that width with trimmed bottom see i might change that later let's see how we see how it looks should see a little power button in the upper right hand corner alright perfect it doesn't do anything let's make it do something alright clicking the bypass button should toggle the bypass parameter of each band before we set up the bypass buttons on click lambda let's declare a function that will toggle the global bypass state all right let's go declare this as private plugin editor.h go down to the bottom put this here void toggle global bypass state all right let's go set up the lambda plug in editor.cpp and do the lambda right after our control bar control bar dot um whoops let me spell that right dot global bypass button dot on click equals lambda oops equals lambda lambda lambda we're going to capture this one more time all right we're going to call our toggle global bypass function all right let's go implement that let's put this after timer callback void simple editor toggle global bypass okay first we need to get the toggle state of the button if the button is off meaning it's green everything should be enabled so auto should enable everything equals control bar global bypass button get toggle state all right again if this is on sorry if this button is off meaning it is currently drawing as green everything should be enabled so if it's off then this should be true if this is off that means it's false which means this should be true so we want the opposite of that all right next we need to get all of the bypass parameters let's write a function to give us that plugin editor.h put it after this uh let's return an array std array all right we are returning three instances of audio parameter bull it's called get bypass params nice and convenient all right let's get to the params auto params equals get bypass per amps let's write this function next all right put this down here std array juice audio parameter bool three of them simple editor get bypass params we need to query the audio processor value tree state for these parameters so we will need the usual namespace aliases and references when looking up the parameters let's do that now all right let's copy the bool helper uh first i need to include the right params file include dot dot slash dsp is that where dsp is no dsp is right there params all right let's copy the bool helper from plugin processors constructor and modify it for our needs plugin processor scroll down for the bool helper copy and put it right here all right so specifically we needed to return a pointer instead of a reference right now this is returning a reference and this is also modifying um it's modifying the input parameter we don't care about that so we're not doing that we're going to return whatever it figures out return param and then ap vts um we can just capture that that should be that um then we need auto declaration here auto param equals whatever param we get from the ap vts casted to a audio parameter bool if the cast is cool this will not fire and hopefully we will return a pointer okay great now we can use the helper to get three boolean parameters auto low bypass param equals bool helper names bypassed low band all right let's do that for the other two bands there we go mid band high band bypass all right now we can just package them into an array return low bypass mid bypass high bypass all right cool all right we have our parameters now whenever we change audio parameters we need to tell the host that it is part of a guester this is so that the host can store these changes in automation let's write a helper lambda to do this we are going to be updating three parameters so the first lambda argument will be the parameter second will be whether or not the parameter should be bypass auto bypass param helper equals lambda lambda lambda first param is the parameter auto param second is whether or not it should be bypassed bool should be bypassed all right now we can begin our change guester param begin change gesture then we can set the params value based on if it should be bypassed or not param set value notifying host should be bypassed then it should be one otherwise should be zero um it's important to remember that set notifying set value notifying hosts wants a normalized value between zero and one all right and then we can end our change guesser param and change guess now we can loop through our parameters for auto param params if everything should be enabled then should be bypassed should be false that means we want the opposite of should enable everything passed in as the parameter so bypass program helper passing the param and should be bypassed is the opposite of should enable everything all right let's test that out all right let's do this okay so the active compressor bands band select button changes the other band select buttons do not for instance this is showing as bypassed but this state is not updated and if we click on those bands like same for the high one it's bypassed but this button is not reflecting that state so we need to fix that we need to update the colors of the band select buttons that are not the active band whenever we toggle the global bypass button let's do that next we need to add a member function in compressor band controls that will update these bands colors so head on over to compressor band controls all right let's declare a public function void toggle all bands bool should be bypassed all right let's put this below button clicked in the implementation button clicked void compressor band controls toggle all bands here is how this function is going to work we're going to use an array of pointers to all three band select buttons and we're going to loop through that array here's the logic we are going to implement if the global bypass button is clicked off meaning that everything is bypassed we need to set every band buttons on color to the bypass fill color and then we need to set every band's off color to the bypass color as well if the global bypass button is clicked on meaning nothing is bypassed we need to set every band buttons on color to the default fill color and we need to set every band's off color to black as this is the default off color when the band select button is bypassed and not the active band it will still display the correct fill color and finally we need to manually repaint after we change a button's color let's implement that now here's my here's my vector of buttons we're going to loop through each button we're going to set the color based on if we should be bypassed we're going to pull it from the bypass button if it should be bypassed and if not we're going to use our default gray color and then we are also going to set the off color if it should be bypassed we're going to use that on color again otherwise we're going to use black and then we're going to manually repaint okay very simple all right head back over to plugin plugineditor.cpp let's call our function now below this band controls dot toggle all bands and if it's if it's if everything should be enabled then it should not be bypassed so we're doing this again all right let's test it out all right all right awesome toggle them on and off okay very cool the next thing to do is to update the global bypass button if we manually bypass each button separately for example if i go low as bypassed mid button is bypassed high band is bypassed this should turn off and then likewise if we have all bands bypassed when the plugin loads then the global bypass should also reflect this let's tackle that next all right the final task is to make the global bypass button reflect the bypass state of the bands if we toggle them manually we are going to use our timer callback to do this let's go look at that real quick all right we are going to declare a function to update the global bypass and then we're going to call it here and implement it next let's go to the header file plugin editor.h declare a private function void update global bypass button go to timer callback and we will call it after we update our analyzer all right it's gonna i'm gonna put it right below timer callback void simple editor update global bypass all right the logic here is pretty simple we need to get all the params all of the bypass parameters we need to figure out if all of them are set to true and then we set the global bypass buttons toggle state accordingly and we need to make sure that we don't send a notification when setting the toggle state if we were to send a notification it would trigger that on click lambda which is something we don't need to have happen because that's gonna fire all this stuff let's get all of our params auto params equals get bypass params we can use std all of to check if all of the params are true bool all bands are bypassed equals std all of params.begin params oops params.end and our predicate is a lambda i am the lambda lambda const auto param we want to see if the param is true or not so return param get finally now that we know whether or not all of the bands are bypassed we just need to set the toggle state so control bar dot global bypass button set toggle state and remember do not send that notification juice notification type don't send okay so remember if all of the bands are bypassed then the button should not appear as green if it only appears as green when the toggle state is off so this is most likely false which means all bands are bypassed which means our toggle stage should be false all right let's test this out here's what we're going to do we're going to enable all the bands we're going to manually bypass them one by one and see if that button switches all right let's turn this on turn this on and if we bypass this is this one going to change it does all right great and clicking it turns them all back off okay so the next test is if we do this if they're all on and then i turn off a band is this going to turn on yes it does awesome that works as expected now what happens if we close the gui when all bands are bypassed is this button going to be set correct let's save and quit and rerun and see what it does all right perfect that works as expected okay that wraps up the functionality for the plugin for this tutorial the last thing that i want to do is customize some of these colors and show a few tricks that i use to do that let's make a commit of our work uh implemented global controls implemented global controls um let's go to our plugin processor let's mark these guys off done and global bypass done our roadmap is now complete that is fantastic all right plug an editor here's our control bar here's where we did all this bypass stuff there's our editor here's all the bypass code that we implemented control band this is how we update the colors of the control band based on whether or not it should or should not be bypassed all right commit six files all right do color stuff next all right head over to look and feel i'm going to show you a trick that is going to help you dial in your colors the first thing is to declare a macro that toggles whether we use juice live constant or not put this right here define use live constant all right next i'm going to write a helper macro that will make use of this macro right here this macro doesn't do anything except return what was passed to it if the macro is true then the juice live constant editor is true otherwise this function just returns what was given to it the only downside here is that the juice live constant editor doesn't show the relevant code in the code snippet viewer and it triggers a jsert but who cares you know it's for what we needed to do it's awesome if use live constant we're gonna define a color helper function where we pass in c and we use juice live constant c like that else define color helper and if okay the next piece of the puzzle is to declare a namespace that holds all of the colors i plan on using and it wraps these colors and getter functions so i'm going to demonstrate one first all right in this function all i do is call the color helper function with whatever color i want so return color helper i'm going to go with blue for right now okay now i just need to replace whatever color i'm using when setting the slider's border with a call to this function instead let's go to lookingfield.cpp let's go find where that is drawn that's going to be drawn in the draw rotary slider at the top all right this is where i draw the border so i'm going to replace this line uh with a call to the um get slider border color g dot set color enabled if it's enabled use color scheme get slider border color otherwise do uh colors gray otherwise do this thing all right let's test it out and it will trigger a j assert but we can just continue past that it'll still work as expected oh um sorry let's do this in the standalone version and why is this showing an error redefinition i don't know why it's saying that all right here's that j assert i was talking about okay let's pull up our plugin here all right so you can click on this color right here and adjust all of the colors directly which is a great way to dial in um you know your colors in your gui once you find a color that you like oh that's a cool color um yeah copy the hexadecimal value and paste it where you were passing the default color to color helper that was over here in not look and feel that was over here in lookandfeel.h this color right here so i would just paste this instead and then wrap it in a juice color constructor juice color like that because there's a juice color constructor that takes a hexadecimal value all right let's do another let's do the module border all right let's go declare this function inline juice color get module color return color helper juice colors blue violet all right we're returning the color we want now let's use the function as needed in uh look and feel that'll go right here g dot set color if it's enabled use color scheme get slide uh get module border otherwise use dark gray and then let's head over to the draw module border color find that in utilities dot cpp there you go all right we need to include our look and feel so we can use the color scheme um look and feel all right and now we can set the color to the module border instead of that blue violet we can do color scheme get module border color all right let's run this it's going to j assert all right that's one there's the other all right let's find our plugin window here we go so what's cool about this is we get two colors now so we can adjust all of these like that you can see how it's adjusting the fill color of the knobs as well as the um border color and then we can dial in this thing and again once we find a color that we like that's kind of cool once we find a color that we like we just copy the hexadecimal over to our um copy it over here and replace the colors all right so there you go that's a nice helpful tip for how to dial in the colors you know once you get this color set to what you want if you want this like red color or not so much this uh maybe you want this to be like an alpha color and you can do that too that looks kind of cool this pop out more once you get this color dialed in to what you want um just copy the hexadecimal and replace it in your color scheme helper and you'll have your colors dialed in so it's you know a pretty handy way if you don't have a graphic designer to provide you colors and like give you like a real fancy gui it's just one of those things that we can use to tweak our gui and make it um a bit easier to make changes in a dynamic way that are easy to update okay so i hope you found that tip useful um i've used it a few times and i think it's a pretty it's a pretty efficient way to dial in gooey colors all right all right so there you go that wraps up the tutorial i am going to dial in some more of these colors and tweak the gui a bit to my liking i'm going to encourage you to do the same you can check out the completed project at the link in the description and if you want to learn how to build the big brother of this plugin check out my course project 12 which is available at www.programming4 you will be building it from instructions written in a jira board i will be reviewing your code every step of the way it is not a followalong course like this video was you're going to be getting your hands dirty and figuring it all out for yourself alright thank you so much for watching and supporting this be sure to check out my youtube channel my instagram and my twitter accounts check the links in the description including me starting from scratch videos as well as simple eq and my other courses and as always if you get stuck or run into trouble while coding this or simple eq just grab one of my free products from programming4musicians.com and you can message me directly in the slack workspace and i will help you directly thank you for tuning in i hope you appreciated this tutorial and i hope you learned a lot from it i will see you in the next one