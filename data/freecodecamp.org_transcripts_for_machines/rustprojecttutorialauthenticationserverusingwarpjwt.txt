rust is an increasingly popular programming language in this course you will improve your rust skills by learning how to build an authentication server in Rust Akil Sharma developed this course he is an experienced rust developer and is a great teacher for beginners so let's get started in today's video we're building uh a authentication server so we'll be using JWT but for the apis we'll be using a framework called warp it's a web framework in Rust the benefit of warp is that it's a small lightweight framework so it helps you to get quickly started by building apis and and there are a lot of use cases so in the sense there might be many projects where you don't want to build a fullblown server like you don't want to use actex or you don't want to use rocket because of the much bigger Frameworks and with a lot of features they're also heavier slower slower to build with a lot of Concepts right so in those cases you might want to have something like warp which is very easy to learn very lightweight very easy to very fast to get started with fast to build with and fast to run at runtime it's also very fast so warp has a lot of benefits uh and a lot of use cases uh so uh by the way we've already built a project with actex right and was it wasn't a fullblown project like a very small simple project I just showed you how to use actex right uh so you might want to check that out I think that will be much before in the in the in this playlist series because in this video Even though this framework is much lighter we're actually building a much bigger project than the one that we built with tactics right but the projects are comparable in in the sense that even with this project if you're building we're not going to be using a database we're actually just using a hash map and that hash map we would already precreate the users and then when we log in we'll just be comparing with the users that are already created in the hash map okay so we don't have a database just a hash map with precreated users login and we'll do all of the things with JWT like creating tokens authentication there's also one more thing here which is role based authorization so we'll have different routes for users and admin and we'll be checking if the user is a regular user or he's an admin and depending on that we'll be giving him access to the apis okay so that also is there so that means it's uh it's it's almost uh like a proper project for for JWT right you'll have regular authentication and rolebased authorization that means you could use this code in multiple places all right so what we'll do now is um I have two terminals let me just show you my uh screen I have two terminals open here for you guys one is the uh place where I've already built the project now I just want to tell you that this project is already built it's on my GitHub right so I'll put the link of the project on GitHub on on this YouTube video but in case I forget to do that you just need to know that I'm akhil Sharma 90 on GitHub and all the projects almost all of the projects that I've built are already there and this one is definitely there because I just built it just uploaded it all right so here uh the project yeah the name of that project would be something like rust warp zero three example something like that anyway so now what we'll do is I'll just run it I'll just say cargo run okay and it's running it's running on Port 8000 and I will now interact with this project so uh the first thing that I'll do is I will hit the login route okay on a different terminal as you can see I'm running I'm hitting the uh the login route all right and I'm inputting the email which is user at userland.com and password1234 because this user is already created in my hash map which is there in the session memory of the project which is running at the moment right there's no database like I said just a hash map when I log in I get the token so this is what the JWT is doing here it's creating a token for us now what I'll do is I'll go ahead and I'll save this token somewhere okay so I recommend if in case you also have this project in your running it long you might want to save this as well but anyways this is just a demo so in case you haven't forged my project from GitHub and are not running it on your system it's completely all right I'm just giving you a demo right I have copied it somewhere the the token and now I'm going to try to hit the user route okay so I'll just press enter enter a couple of times hit the user route and it says as you see Hello user one that means um that means the um jwd is able to determine that this user already exists and it's able to check the token it's also unable to get the information like the user type from the token so this means it allows me to hit and it also sends back a responsing hello user one okay uh now what I'll do is I will um I will try to hit the admin route with this token okay so let me bring out my command for the same sorry uh yeah okay so this is my command my call command where I'm trying to hit the admin route with the same token the token that's meant for the user and ideally it should not let me in because this is the admin route meant for the admin user not for the regular user so it'll say okay not valid status 401 unauthorized all right so we have elaborate error handling in our project and that's also what we'll be building today okay and the next thing you want to uh do is hit the login route but with the admin credentials so what I'll do is I will hit the admin route just a second yeah hit the admin route so you can see here sorry the login route but with the admin credentials so I have the admin created here with different password like I said these users are already created uh whenever we start the project these users get created in the beginning and I'll show you how to do that we will initialize these users right so we're just comparing that this user which already exists in session memory right now is it the same as this user that I'm sending in as request and yes it is so it's giving me a token now so what I'll do is I'll just copy and and paste this token in a safe place and what I'll do is I'll try to hit now the admin route so we saw earlier that we were not able to hit the admin route right because it is saying it's unauthorized but now if we try to hit the admin route it says hello admin 2 which is with new token you're able to hit the admin drop all right that's awesome so what I'll do now is I will again um try to hit the user route and let's see what happens so try to hit the user route with this admin token and let's see what happens okay so I will come here I'll try to hit the user out but with the admin token so it remembers it says hello user two so that means the admin is able to hit not only the admin route but also the user out but the user is only able to hit the user out not the admin route I think okay I hope that makes sense it's quite elaborate like the rules that we've put in quite elaborate and that's it's like a fullblown working project you can just pick up the code use it on your project right if you have let's say a submission in your college or you're building something and you're at your office in your job you're building something very quick the best way to build it all right but jwd it has what but it has these apis it has error handling it has rules and authorization authentication everything is there anyhow so now let's get started so I'll just clear this all up I will stop this over from running and I will create a new project so I'll say cargo new and I'll give a name like uh rust what I'll say JWT and and waiting for YouTube so I'll CD into it rust warp JWT and YT all right and you can see here cargo tumble SRC now I have not created videos in uh uh in quite some time now and the reason for that is that as many of you might know that my startup armor dot AI was selected by techstars which was the next which is a great accelerator and then recently got selected by outlier Ventures which is again an accelerator Tech accelerator and in the middle we also got grants from companies or blockchains like Aptos so it's been extremely busy very very hectic and basically essentially what armor AI is it's it's a it's a platform where you can build security tools so it could be for web 2 for web 3 doesn't matter uh the platform enables you to build security tools really easily that's what we're building at at armored uh anyhow just wanted to update you on and why I've not been making a lot of videos but then uh now it's getting things are getting a little bit lighter I'll have a little bit more time hopefully and whenever I have time in between the day I'll just create a quick video like this right so that uh unable to also keep in touch with the Technologies anyway so I have it here I am going to open it up in my guess code okay so there are two terminals right the other one I can actually I can just get rid of that okay so here in my SRC I have a main.rs which is awesome but I need two more files I need my uh all the logic for my authentication and all the logic for my headers I need that as well okay so now another thing is it's it's uh there's quite a lot happening in this project so I'm just wondering where to get started with I think I'll just remove I'll just remove I guess get get rid of all of this and I'll start by just creating a user struct okay let's just do that so let's just create a user start okay uh and by the way I I'm not sure if you can see my screens they're up in the sky like up in the air now earlier they used to be on the on on the table now I've put them up in the air so I will be just looking here and there will have like four screens here um four different screens so yeah I just want to tell you that so like there's nobody else in the room I'm not looking at the person when I'm looking here at me I'm just looking at the screens all right so um like this having the same code window on two different places like instead of having like a split view just where to have it on different screens that's what I uh was doing right so uh in the main dot RS you have your user uh struct and I'm going to have a uid which is string and email which is again string okay and then password which is again string now I hope you all know what structs are you shouldn't be doing this video if you don't know the basics of Rush by the way because I I get a lot of comments on on YouTube saying that hey I didn't understand uh anything that you're teaching it's obviously because I'm expecting that you know rust uh before if you want to build a like fullon project with Frameworks and last right and a lot of people don't understand that and they just come and write on my videos I'm not understanding anything you're saying and you're just talking you're not explaining it's because it's because I'm not supposed to be explaining what is a struct in a video that's meant for uh building projects for the web framework right so I need to give me that much off like you have to have that kind of understanding at least so anyways even if you don't know what struct is it's basically uh enables you to create your own custom data types so user is a data type here which has a uid which is string email string password and role okay because role could be user or admin as we just saw in the demo and in then I have another struct for the login request okay so I'll have two things which is the request and the response for login and sorry I'm not able to look at my keyboard because of this mic let me just put it here all right so for the login request I have uh the email so I'll send the email and I will send the password email and password so it's a very straightforward simple straightforward login okay and then I have something called as the login response like I said you know when you um when you make a request for logging in that that is what this will look like the login request will always look like this it will have always an email and a password the login response will always look like this will have a token right so this is my way of defining the write request and response instructs right so that it doesn't deviate the project was interviewed from this all right so now because uh I'm sending the request as Json as you just saw in the terminal I was using um the terminal and I was sending Json requests right and I was receiving a Json response so I need to Desert serialize and serialize right because just it's not able to understand Json one and so on and a lot of people coming from JavaScript background they get very confused in this step they think oh but why is that you know why is Russ not able to understand that when JavaScript understands that by default because Json is Javascript transition and JavaScript already understands that by default but trust does not go Lang does not and that's why we need to do this okay so you're going to say DC realize here in case you're uh you don't you don't know how serialization dexterization works there's a very detailed video that I've created on uh in in this series itself this figures itself it's in the towards the beginning where I explain the Third Day package which is uh the third day it's great sorry which is what which enables us to do digitalization and serialization so what I'm going to do is I'm going to first get that because uh by default rust doesn't have it so we need to make use of the survey package Jesus rise and serialize okay and you have that now for the user uh we'll have to work with the user object multiple times right so when we receive the user object in the um you know so we will create the user object and it'll be stored in the session memory as a hash map we'll have to also compare with the user that we'll get uh you know the user data that we get in the request and then we'll have to search for the users so we'll do a lot of operations with users where we need to have multiple copies of the users so I'll just clone this so I'll just say I'll give it the ability to that that we're able to clone it uh very easily so I'll just say Drive clone and now what you want to do is we want to start working on the main function so I'll say sync FN Main okay and to be able to enable the async function we will be using Tokyo so in case you haven't worked with Tokyo there are multiple videos on the same playlist this rust playlist multiple videos about Tokyo make sure you check them out we've already built projects using Tokyo and the asynchron the async functionality brings us with it so here we'll say let users equal to Arc new in it underscore users now init users is going to be a function that will help us create default users so I'll repeat again and it uses the function that'll help us create default users as the program starts so before we make any requests two users will already exist in our hashmap to users one being the user regular user one being an admin user That's How we'll compare the user coming in the request with these users in the hashmap we'll search for these we'll compare them and that's how we'll create the token right that's the whole logic that's going to be there so Arc that we've just written here we'll have to add in the appropriate so it comes in from standard sync Arc Arc is something that you use usually with things that you will be using uh things that you'll be cloning a lot so it users is something like I mentioned we'll be cloning quite a bit oh by the way I'm not sure if I covered it with C at the end I made C Capital here in Clone uh you just need to see that this color changes right so maybe because I left for a quick break in in between uh just to get some water so maybe I didn't show you this which is C is supposed to be Capital make sure you do that in your code as well okay and we got this Arc now Arc unit users all right um so we have this now and now we quickly create our routes using warp now we also need warp here so I'll just quickly write use Warp and what comes with reject reply filter we'll need filter as well ejection and reply okay and we need warp now to be able to create these uh routes in the main function so we'll first say let login underscore dollars this is for the login route is equal to Warp but login okay so this is how the login starts and we'll say dot and warp post request so for that means for login that's the path right login. and it will be a a post method and we'll change some more things here so we'll say with underscore users and users dot clones as you know we're going to including users quite a bit that's why we have this here Dot and Warp body Json okay because the request will be in Json Dot and underscore then and login underscore handlers so essentially what's happening is if you hit the login route you need to have the login Handler that's the main thing right and everything else is just helping us with that so we have that it's going to be a post route it's going to have users so you'll clone the users and perform some operations in the user because as you you know with login you're going to be uh trying to find those users in the hashmap as we'll write more code it'll make more sense but just need to know that with login you need to have login Handler login Handler is a function we'll create in a while just ignore that right then we'll just create the user out and the admin route so user route is equal to again what paths and user okay Dot and with auth here you'll have role user okay so what we're saying is for the user out it's obviously when we whenever we had the user Outlet slash user that's when we're supposed to come into this chain and the role of that user should be users there are two rules one is the user role the other is the admin role talking about the user role here and then you have the user Handler okay talk about it just like we have the login Handler we have the user Handler here similarly we'll have the admin route and the admin Handler so admin route let's go to Warp path admin okay dot and with auth and you have the role which is admin okay Dot and underscore then admin underscore and essentially login routes with Slash login hits login Handler this is a post request user out with Slash user hits the user Handler admin route slash admin it's the admin Handler and generally let's just Define the routes so routes is going to be login route okay or user route or admin route might also recover so it the error if it's not any of these routes we'll have the recover error handle rejection handle ejection is something we'll work with uh mostly in our error.rs file but I'll mention it here error and handle rejection so what is this error so this error needs to be in in the top so we'll say use error everything from the error mod okay and I'll just get also everything from the auth so error and auth are these two files that we will be using as modules so I'll also get auth and here we'll have with hot and comma role right so we've done here uh reviews with users will not use yeah so we've used with auth also and the with auth you also pass role which is the user and that's the logic that we'll handle in our auth DOT orders file so that's why I've also gotten it from auth which is get with the auth and also the role okay because we're passing the role as well role user or role admin and here we can say mod hot and mod error all right now I need a couple of more things I need to be able to work with hash Maps like you know because we'll be creating multiple users as the program begins and that's the those are the users that we'll be comparing with when we have to do logins so we'll need hashmap and then I'll need another thing called infallible we've used it before it's when we don't want to return any error that's when we use infallible I'll use that also later on so I'll just include them for now so I'll say use standard just a second I'm not able to look at my keyboard because of this mic installing this new setup so you have used standard and you have collections cash okay and then you have use standard convert and parallel okay so we've reached here finally when you have defined all the routes you can simply start off the server so it'll say serve all the routes and run the server on 137 comma zero comma zero comma one comma eight thousand let's say dot await okay that's that now there's this function called with users so here you can go ahead and create that function so we say function with underscore users ticks and users which is a collection of users with a capital u so what does user of the capital user mean use of the capital u is actually the struct so multiple of those structs because we'll have multiple users like I said will be uh collection of these structs basically regulation of these trucks are assigned to users okay okay so implement filter essentially what you need to do is always we have that hash map of multiple users we have not created those yet but we'll create that in the init user function this function will create it very very soon but when you have that when you have that hash map of multiple users you need to be able to extract them right that's how you will you know go user by user extract user by user and then compare the details of that user with the ones that you'll receive in the request okay that's why we are extracting it so let's say is equal to users comma comma errors is equal to n value Plus clone save work any dot map mode enables me to extract users okay so there are three functions that I need to write here one is the login Handler the user Handler and the admin Handler so I'll at least create outlines of those functions so I'll say Pub async function login Handler okay the one that will be called when I have somebody hits the login path login Handler so it'll have users which is a collection of the users have body which is the login request okay so I'll explain this again users as a collection of the user with capital uses struct so multiple of users which are following this data type are the users that we'll have in users okay which is again here which had cloned and in login Handler you also have the body which is the login request so login request is something that you created here which will have an email and password so you'll have that also in the body which is the request body okay and we'll have to perform some operations with that so like like I told you the users we're going to get the users one by one and compare it with what you call in the body the details that's what we'll be doing here essentially and there will be something called as the web I'll just push it down something called as the web result so I'll say result reply match users users being multiple leaders right from the field assigned it to this variable users and you're going to how are you going to match you're going to match them by iterating over the users and you will find so like I I explained before that we have we'll have multiple users and we'll go over each of those users that the function will help us do by iterating user by user we'll go over them and then we'll compare them with the details that we get in the request That's How we'll come to know if this user matches this user which is there in the hashmap that's how you complete the login request so here will be find underscore uid comma user user dot email equal to body dot email user dot password equal to the body Dot password okay so uh for this web result right I will go up at results so I'll say type so it's a type that we've defined type red result standard result now we'll have to Define this result also T comma rejection now to Define this result also say type result t the standard salt result 2 comma error right and then you have type which is users our case it's Arc and it's a hash map of string comma each user right so this users that we were talking about all this while users like I said it's going to be collection of multiple user which is the struct and here we've just officially defined it as a hash map it's a art enables us to create uh you know with the help of cloning you have a hashmap which is string comma use it all right so here now that we'll find that particular user which is which matches the email uh the body email and user email and user password body parts which matches that you need to perform some operation on it okay so that means and we found it we'll perform some operation on it okay but before we do that I'll just create the init users function so that things are much more clear it's also sum even if I found it all right so first I'll just create the init user functions that things make a lot more sense so well because once I create this function everything will become so much clearer to you that all your doubts will go away so I'll create init underscore users function and this has a hash map string comma sorry string on our user and start with map s map new map dot insert this is the first user so we'll say if you remember here we just created so the reason I'm following this particular order is because I'm taking it through everything so users there's a string right the string is actually we use it for like one two you know the ID of the user and then we have the user and that's what we also had here the ID of the user and the user because we'll have multiple and we go through multiple users when we iterate through them so anyhow so the first thing is from I'll create one user number one comma and I'll say here user which is if you see capital u you mean you you know that I'm talking about the user the struct so here I have something called the uid which is string from one okay why because it starts with uid right and then I have something called as email which is again string from user at the rate user to land.com comma password restraint from one two three four these are all hardcoded values so I'm creating a hash map with these exact users and if you remember the demo that I showed you we were actually using this user details we were using this email exact email exact password to be able to authenticate that user that's what we're basically comparing role string and this particular user is has a role of users that's that's why when we logged in this user and we got the token we were not able to use that token to log in to the admin route the fit member comma so and now we'll say map dot insert for the next user so we want to create the next user now and we'll say string from 2 ND user okay comma user and it will say uid string from two come on email again a string from admin rt.com password is string from four three two one and the role is string form add right so this user's role is admin this is Rolex user as we know admin is able to log in to both user and admin but the user is not able to log into admin just user comma here and then finally we'll just say map all right now we can come back here so now that I've created the um init users functions now now everything is very clear to you right that we have these two users and we're basically doing everything else that we've done here is to compare the data that we receive in the in the request with the users right so when you found so we are basically in the login Handler we are trying to get uh we're trying to find the user which actually matches this email and password because that's what we send in the request once we've done that we want to perform some operations so we are going to create a Program forum so we'll say that token is equal to auth create 0w right so in the auth module you say auth because we have the auth multiple here which is going to have function called create 0p we'll have a function in the auth.rs file called create JWT going to just send it the uid comma and the role from string user dot role we would extract the user data Dot map underscore error reject custom error so we'll say okay reply it's Json so I've I've for the time being I've disabled rust analyzer and we will activate it so all of everything will get um formatted correctly but I'm just I'll just disabled it so that I'm able to type with these so all of this happens when that particular user was found so we created a token but let's say if no user was found like that which you know matches the email ID from that user that we were going through one by one and it didn't meet the body email or the body password what do we do then so we'll say none and we'll just send an error with reject and we'll say custom wrong credentials error so when we say custom that means basically we've defined these errors somewhere on our own that's what we mean and all that is there in the error file we'll Define all the errors now before I jump there I'll just go through the entire code once again just to be sure everything is fine and then we'll just hear the two handlers the login and admin Handler which is very straightforward but before that just quickly just quickly go through the code just to make sure everything is perfectly fine perfectly all right uh we have the user login request the login response and login route to use route yeah everything looks looks all right okay for now and now I will just create the user Handler and the admin handbook so let's see Pub async function user underscore handlers ID string we've already have the web result okay head so you remember in the demo that when the user was logging in it said user one user to admin to like that hello user run well so this is where it's all happening so we just saying hello user and we're embedding the uid dash foreign Handler you have the exact same function so let's say admin Handler takes in all of this says hello admin and with the admins ID that completes our main dot RS files now we we have the error file to complete okay and then we have our auth files to work on all right so now you know that we've completed the main.rs file I will now work on the arts.rs file okay so the first thing that I can Define is the enum roll and I know that role has a role can be of type user which is the struct that I've created or it could be admin so two two different values right user and then I'll Implement some functions for role so for example this function from string get the role from string and you get back role role being the E number right so from string uh like in the request you send the token from the token you will come to know if the user is a user or an admin and that will be a string right and then we'll you put that your string you want that to be in the form of the role the rule which is either user admin so you can compare so you get back to role right and now I'm going to match role if it's admin I'm going to say role admin or role user all right so there needs to be one more closing bracket this makes sense so in a JW token to create a JW token you need claims also right so we'll I'll create the claims struct here but I'll come back to it once I create the creates GW function okay so here we have the create jwd function which helps us create the token so here first you have the uid which is a string roll which is the role which basically sorry this from string is small s make sure you make the change as well okay so for here role is role which is the Ampersand role and you get back the result from here which is string so what all what all does a token comprise of it's the expiration time or date time date and the claims and the header right so first let's have the expiration we need the UTC package here obviously Etc now which is the time which is right now and then you'll say dot checked add signed using Chrono duration this is valid for 60 seconds it's the expiration time so if you were to use this after 60 seconds it won't function dot expect valid timestamp dot time stamp okay so now the other thing is the claims and here this will be equal to claims with the capital c which should be this struct that will create here the claims will have sub which will be string I have the role which will again be string and the expiration which will again be view size okay and here you need three things which is derive debug comma this serialized comma serials we'll be deserializing and serializing it but to have digitalizing serialize you need survey so we'll say use 30 serialize comma serialize right and we also use Chrono so we'll say use Chrono get everything from Chrono essentially okay so for claims we've defined what claims looks like uh here also for the role we'll say hash Drive and clone like capital c comma partial okay coming to the claims we have to work with three things sub which is actually the uid so two underscore owned comma we have the role which is role dot two undersource string and we have the expiration which is essentially expiration as unit size which is the type right string you size the types comma and finally as I mentioned the token will have the expiration claims and you'll have header so we'll have header is equal to header new using the hs512 algorithm and we'll encode the header the claims with the encoding key from and Source secrets jwd Secret dot map error sorry token version okay so first let's um let me actually use Json web token that basically gives us the ability to decode and code gives us the algorithm that we just used right so you we use something called as encoding and or the encode function which requires headers and claims which we have right now it is in claims the header will have the the algorithm different type of algorithms can be selected by us and then the encoding key which is directly secret we have to create that encoding key right now algorithm comma decoding key comma and coding key comma header command validation all these things we need and when I also use the fmt package and I'll need warp obviously and warp I'll have filters header headers cloned and have http header at a map column header value comma authorization and we'll have reject filter and ejection we will use this now but up until now what we've done is we have created uh enum for role I'll I'll just switch bring this out here the enum for role create the implementation for all so this shouldn't be here this should be here actually okay with the with the E number the data type and this is the information of function for role which as as I said helps us to get role which is admin and if this string is admin we'll Define role as admin which is part of the enum whole enum otherwise it's user then we have claims which has role and expiry which are the two more important fields the create durability function takes some uid and role and sends a result which is a string which in our case will be the token actually and first we create expiration with the help of Chrono Chrono package helps us create the expiration time which is 60 seconds or the token and expecting about a timestamp then you have claims which is uid role and expiration of all three and you have header header create a starting of header with the algorithm that was uh let's just do 500 in our case which has which you get from the Json web token Library and then you use the encode function so what you do essentially not sure if you use JS Json web token before but I've uh I've shown that on YouTube I think with the node.js video also and with the golang video also the way to create a GW token and you can also go to their website and try this same thing out the way to create a data token is to use some information that you will hash right so you'll create a hash from some information so you can use this algorithm and some information like header and claims and use the encode function which will use this algorithm to hash that data that you send it and you get a key from it now to Hash it you use a secret key which is in our case database Secret and we can Define it here so on top we can just go here before this you can just say we'll Define it as constants constant J interpret is is a type u8 Secret we'll also Define the better so what's this this is basically the thing that you see uh in your authorization so you say authorization right whenever you send a token in the request you see authorization and then you also say better and then the token okay so we'll see this value called authorization you'll see this Valrico better and general token a little bit secret is just the constant used for and as the encoding key to encode our header and claims and get the hash based on this algorithm and this error we have not defined it yet it will be in the error dot RS file and we'll work on that in a while okay so there's another function called with auth so if you go to your main.rs file you'll see this function being used called with auth with underscore auth and we are expecting this function to be created here okay so let's do that so we'll say public function with underscore hot let's see what it takes in so this it takes in the role so you pass in the role as user or role as admin again this role or user roller admin are coming from your enum role of user role for admin okay now that we're connecting the dots things will make sense maybe you are confused here why we're writing it like this but it all makes sense when we have uh because we had we're going in a particular order we can't do everything all at once so sometimes things end up we write we end up writing some things before they actually exist on the other file but now as we have with your um connecting all the dots everything will make sense okay so this is the function that you want to work with now function with auth and here we have role takes control and we'll implement filter extract is equal to string from error is equal to objection headers blonde dot map move headers error map header value so essentially it's just a long way of saying we're cloning the headers that you get in the uh along with the role you get you throw on the headers and you basically um you call the authorize function that's what essentially you're doing so in the authorized functions we will be passing the headers and the role okay and the authorized function is the main place where we'll write all the logic so what's happening here is when somebody hits the user out we want to because they're also sending in the token right and the login route when when they hit the login route because of the login Handler they will be able to create the um the token right so the create JWT function gets called from the auth package auth module so creatively function something that we created right now which basically creates the token for you so after you have the token that's when you call the user route right which starts with Slash user call that route when you have a token so here you're passing uh you're passing the role which is of user because you're expected to be a user if you're hitting the user out so you check if that user is is legit or not in the sense he has a right token or not if he has a right token only then you will enter this function called user Handler you have the user Handler function already it's supposed to send hello user and then the uid but to be able to reach here you need the you need to First cross this function called with auth or with auth as you've seen takes in the role which is the the user and it's going to essentially call the authorize function so in the authorized function you're going to pass the role and the headers okay so let's let's actually create that function here it's an asym function so async function authorize rule comma headers roll comma header map so you you might notice that we have to write a lot of boilerplate code like here we have to find that role is of type role and headers of type header map value here also in in the with auth function you're doing the same headers of type header map error value right all of that we're defining all of that but that's only because rust is highly uh you know has a lot of strict typing and it ensures that you don't end up creating a lot of errors so here you'll say match JWT underscore from underscore header class headers here now this function GW from header we will have to create this function as well so just write here function generally from here right so when you pass the token the jdb token in the request it goes in in the header right so you say minus H and then you say authorization then you say better and then the token right so because it's in the header you need to be able to get it out you need to be able to get out the token because that's how you will compare right match basically means comparing matching tokens only if the tokens match can we uh you know get the user to log in now the way to match is we need to uh decode the token as well right because we've encoded a token first we encoded using the encoding key use the encode function and now we'll also use in the authorize function we'll have to use the decode uh the decode function so you'll say in the decoded this is where you'll store it so decode claims Ampersand JWT comma percent decoding key from undersource Secret Ary and Source liquid comma and validation so you got to give it the algorithm with the help of which the encoding was done and you're going to decode with the same decoded hs512 so this bracket I've created here is wrong should be the round bracket dot map the error and just go here reject custom again this error we will create jwd token error okay that means there's some issue with the token and then we'll match the role if role equal to role admin so when you have these four dots right you you're saying that roll admin which is role meaning role with capital r enum and admin this role is the same as the role that we just got that was passed from the body to this function and roll from underscore string decoded dot claims dot role is not equal to role admin okay return error reject custom error no permission error yeah so if it's not an admin if the person is not admin and he's trying to access the admin route then we will say that you don't have permission to do this and that will basically be defined in the no permission error okay and we'll say okay coded dot claims dot sub here we'll handle the error we'll just return better sync eject custom header so this is your authorized function okay now coming back to this function which is the um GLD from header function which helps us get get the token from the header so here again we'll be working with those two things two two Fields or two uh two components of the token of the request body one is the authorization so whenever we pass a token right we say authorization and then then we say better and then actually the token right so we need both of those things so we'll just check for those things and then after that what comes is the token that's what we will return from this function so we'll see headers which is of type header map header value return a result which is string okay that header is equal to match errors dot get authorization if the value is matching then we'll return the value otherwise we'll just return and errors saying error is no auth header found it's no author header header right that will basically show that there was no auth header if there was a Authority it'll just return that but there was none we'll just say no auth header header and this error we will Define in the error module okay and you will um get that from header so so I'll have to import those grades so let's say use create error result okay so now I have the error create resulting with result in web result are these that we've defined here anyhow so coming back to Glory from header um so let's get the auth header which is my matching standard string from UTF 8. header dot as underscore bytes foreign otherwise again we'll return the same error which is no auth header header header and if there's no odd header that starts with better then we will return sorry then we will return error invalid auth error headers okay okay let's go header dot trim start so you're trimming the part which is the bearer part and after that is the token right so you whenever you pass token to make a request uh you say authent like I said authorization and then the uh better and then the actual token so you want to remove or trim the part to start matches with pairs all right so that's it that's that completes the auth.rs file what we'll do is we'll quickly go through everything just to make sure everything is correct and the file and then we'll wrap it up so we have pair you have 0b Secret you have the role the implementation for the role the uh yeah there's one more thing that's spending which is where we'll use this fmt package which will be in the Implement fmt display for role the right way to display the role to format it so it's format it properly which is self comma f Prime percent of mute fmt formatter now this is completely optional you don't have to do it you don't have to do this formatting I'm just doing it okay so the formatting part is complete we have claims we have with auth we have uh create JWT function we have uh authorize we have gwg from header right so quite a bit now the only thing that's left is the error.rs file to do that I will quickly create an enum for the types of errors that will have and we'll we've already used those errors in the other two files which is the main file and the auth file so we shouldn't have shouldn't have uh shouldn't be a big challenge for us now so what we'll say is say uh enum and errors so what kind of errors that I've used I've used the wrong credential error sorry the wrong credentials error I've used the GWT token error okay obviously token creation error this one I've used the no so that's the benefit with ID using a good ide is that we get these suggestions based on the errors that we already used the other is invalid auth header error and in no permission let me just also right here error wrong credentials 223 token not valid then you have awt token creation error no auth error so no error error foreign okay so what does the error response look like so what I'll say is struct and error response looks like this you have a message it's a string you have status which is a string and then in the beginning what you'll do is you'll say use so they serialize use standard convert valuable because I'll be using this and this as well so I'll just bringing them right now so that I don't have to come back here is what is obviously we'll use walk here XL http status code command rejection comma reply awesome okay now that we have everything you know the basics build we'll just Implement warp reject reject call error and now most importantly the handle rejection function so this one this function hand rejection which comes from the error module as the function that we want to create now so we'll say Pub async function handle rejection now after writing all of this code obviously we will have to so I'll just drink some water obviously we will have to turn on the rust analyzer because I'm sure we have made a lot of mistakes well that's completely all right uh this is all about working in Broad Strokes in the beginning and then figuring out how to fix the code because you don't want to break your thought process too much so just write what's coming to your mind here and then we'll fix everything we'll get into details and fix everything right now this is a very different way of working but it works really well good message is equal to if error dot is not found you will say status code not found not found Dot 2 on your Source string okay here it will say else if let sum the error dot find error and then you'll let's match the error right so if there's no error that that error does not exist so you'll say not found otherwise you'll just if there is an error you'll just match it with these ones so the first one is the wrong credentials error then you'll have the no permission error then you will have the jwd token error and then we'll have the JWT so this match function enables you to match the exact error then take um the right action based on the error now again uh this entire file which is error handling is completely optional in the sense you don't have to it if you're not building clicks production grade stuff but if you are building production grade stuff then it's it can really helpful right you don't want to build a project it doesn't have any error handling so here if I have wrong grain chills error what I want to do is I want to say status code forbidden comma e Dot do underscore string clear and Save status code on or authorized e Dot to understand string status code okay unauthorized two underscores let's go screen and for this we'll say status code internal server error done also now all of this that we are doing right now is very very basic simple code there's nothing there's no business logic here nothing that's happening that's critical it's just error handling matching the error right with the right uh with the error type and then giving the right status for it so at the end you'll say comma and status code right underscore request e dot two underscore string this is e.2 string and then after that it's if error dot find Warp checked mapper mode allowed that is underscore sum foreign underscore not underscore loud and the actual text that will be returned which is method not allowed I will be two I'll just call string so in case you don't want to build this entire file you can just copy and paste it as well not a problem like copy and paste it directly from my GitHub it's all just error handling and once you do this in this file or in this project you can we can do it in any other file also you can just copy and paste this so what's essentially Happening Here is we're matching the error with the type of error sending the particular status code like 401 500 blah blah this is 500 for example this is 401 for example right and with the message the error message right and here if there's nothing here then it's just bad request right no type of error is matching so it's a bad request and then we also uh handling for method.loud so if if method.log basically means if it's uh it was meant for post but you were trying to get right so that's method not allowed so that also we're handling out here here we'll say e print this is just very basic error handling I'm sure you already know all of this and then and then comma error here that is code internal server error on an internal server .2 underscore string then we have let Json equal to what reply Json error response status code Dot install string common message finally okay work reply with status Json command code okay so each errors has some Json message which is the Json and the code which is the status right the code has code is like 401 500 like that and the message is basically a Json Json has both of those things and cool all right so this is our error handling file and now we'll go ahead and um I'm looking for rust analyzer actually just say just come up yeah so I'll just enable it and and I get lots of errors which is nice because we will now fix them one by one all right so in the main dot RS file if you go to the login Handler function just login request needs to be one word right because that's how we created the struct and sum needs to be capital s so that fixes two small errors hopefully and now we'll just add some dependencies because those are the packages that you're using so once we add some dependencies hopefully the some of the issues should go away so here we have uh the version edition all of that and dependencies I'll just add the ones that I'm using so you can just copy and paste from my calculator file in case you want to write it on your own you can do that as well so we're just using Json retro control key or warp 30 sorry Json this error Chrome no debug sorry for profile Dev file test profile release so I've added those now and as you see now for main.rs lot of the uh almost all of the issues have gone away so it doesn't show any issues anymore all the issues that are pending are in error.rs but now again now again I can see I mean or others there are there's five issues again all right so we move that and then let's find the pending issues now in the auth.rs file there is in the pub inum role there is one comma missing put that there and here instead of fun which is FN I've written fun which is fun so when you when you save that just left the three errors here and then just four errors here right so certainly the errors have become much less with the error.rs file there are many things that are wrong so here should not have the comma should have semicolon here semicolon here and on top of that you need derive error bug out here and derive serialized bug out here so that should hopefully take care of a few issues right so now and take a look four issues are left in the add or RS file but auth and Main these two files are working completely right so this because there's dependency between these files when I fix issues here both these files are now like they're perfectly fine they don't have any issues at all you just have to find four more issues now one really small issue that I found here is that there's double colon missing and now we left with one one small issue and then the final issue is that two string the S should have been small and the other dot artist file now we see all the issues have gone away so the natural step now is to do cargo run and let's just start just one API and then we're sure everything else will work because because there are no issues and we have built it very carefully let's try at least one API okay so I will open up and let's check out if everything works as expected foreign everything's working perfectly fine now let's say uh if this score is not correct maybe because I've not tested all the other apis maybe if this is not correct you don't have to worry because I am going to be uploading the correct code which was which I showed you in the demo right even though this code is correct but like just for your peace of mind I'm going to upload the code which is um the one I showed you in demo right so it's already uploaded in GitHub feel free to take a look now you know how that code works you have a complete idea about that so we learned a lot in this video quite a lot right we understood how to use word power to create apis how to handle errors uh how to use JWT in in Rust for authorization how to encode the code how we used uh the claims the expiration and how we created the token and then the role you know how we had tools for admin and user so a lot of stuff lot of stuff in this video that we've learned I hope you learned a lot as well thank you so much for watching and do share this with your friends to share this playlist with your friends it's all free and it's um good information right thank you so much and I'll see you in the next video