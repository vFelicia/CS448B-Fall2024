in this video we're going to learn about the popular java testing framework junit 5. we will start off by learning how to write basic unit tests using jn85 by taking a simple contact manager application as an example and step by step will cover all the important features of junit 5. by the end of this course you will have a solid understanding of how to test your java applications using jun85 so what is junit according to junit website it is a simple open source framework to write and run repeatable tests jle provides a simple api to test our java applications the class or method we want to test is usually called as subject under test so to write a test we simply create a java test class and use the junit api to make some assumptions towards the behavior of the subject under test and then jail it verifies whether these assumptions are correct or not by either passing or failing the test before writing our first test let's take some time to understand the architecture of junaid 5. on a high level junit 5 is basically a combination of three different modules jain platform is the module which provides an api to launch the test from either the ids build tools or console so when you write a unit test using junit your ide or build tool or console whatever platform you're using uses this api inside the junit platform module to launch the tests next we have the jnet jupiter module which provides an api to write our jna tests and extensions in this course we are going to mainly focus on this module because if you want to write unit tests using jnet5 this is the module you need the next module is junit vintage which provides a test engine implementation to support backward compatibility for tests written with junit 3 and jnet4 so if you have some tests which are written using chain 3 and 4 you can use this module to execute the stress without rewriting them in jn85 and lastly junit platform module enables some thirdparty testing frameworks to build their own api to write the tests and reuse the junit platform module to launch these tests so this is another interesting update which is part of junit 5. now let's go ahead and write our first test using junit 5 so to write the unit test we are going to use a contact manager application i already prepared before as the name suggests this application manages the contact information and this is a very simple application which contains only two java classes the first one is a simple pojo class which contains three fields first name last name and phone number and the next class is named contact manager so this is responsible to store the contact information here we have a method named add contact where it takes the first name last name and phone number as input parameters and then storing the information in memory using a concurrent hash map we are using a concurrent hashmap because it's a thread safe implementation of the map interface so as part of adding the contract we are performing some additional operations like checking whether the contact already exists or not and validating the contact information based on some business rules so we have a method to validate each field in the contact class so if we open the contact class we have a method which validates the first name so it is basically checking whether the first name is blank or not that means it checks whether it's not null and not empty we are doing the same validation also for the last name and four number fields but for the phone number field we are doing some additional validations such as we are checking that the phone number should be exactly 10 digits in length and it should contain only digits and it should start with zero so once all these validations are passed successfully we are storing them in memory this is a very simple application but provides enough functionality to cover all the features of junit 5. if you want to download the source code have a look at the link in the description and you can also have a look at the written version of this tutorial by checking the blog article i have linked this also in the description section to follow along the tutorial i suggest you to download the source code for the starter project from the link in the blog post where you will start with a clean slate without any tests and gradually by the end of this course you will reach to the state of the completed project i am using intellij idea as my primary ide for this course and the start project is using maven as a project management tool if you are not aware of the what is maven i have a comprehensive video tutorial called maven complete tutorial in my youtube channel have a look at it i will also leave the link in the description section so to start off first we need to download jnet5 into our project for that instead of downloading the jar manually and adding it to the project i'm going to take the help of maven to automatically download the jar file whenever it's needed to be able to do that maybe need some information so that it can download the java file automatically we call these jar files as project dependencies so these dependencies can be defined inside the pom.xml file and inside the file i'm going to add a tag called as dependencies and under that i'm going to provide the dependency information by typing the group id as org jn8 jupiter artifact id as jlet jupiter and version as 5.7.0 so this is the information maven needs to download your dependencies these are also called as artifact coordinates i'm just giving the bare minimum information about maven if you need more details have a look at the video tutorial again so once i type these details we need to ask intellij to force maven to download these dependencies we can do that by clicking on the maven icon on the top right corner that's all you need to download the jne jupiter dependency to our project now let's go inside the source test java folder again this is the maven convention folder structure to store the test classes and inside the java folder i'm going to create our contact manager test class so you know what let me show a shortcut to do this automatically so from contact manager class so let me open the contact manager class and inside this class just make sure you selected the editor section then press the key combination ctrl shift t then you should see a small popup window which asks whether to create the test or not so i'm going to select that option and click on ok and intellij automatically creates the test class called menu contact manager test for us inside the class i am going to create a method called as should create contact the jna tests are nothing but methods inside the test class so junit identifies a method as a test when we add the test annotation on top of the method by adding this annotation junit understands this is a test and starts executing it when we run this class so if i try to run this class with the empty test method you will see that it executes successfully because we didn't add anything to the method so now let's go ahead and add some test logic inside the method so basically we want to test that a contact is created successfully so for that first i need to create an object for the contact manager class and after that i'm going to call the add contact method inside the contact manager and i'm going to pass in the first name last name and phone number details as input so if you go inside the implementation we are storing the contact information inside the map and we have a method called as get all contacts where we are reading all the contacts present inside the map so to verify whether the contact is created or not i am going to call this method and make sure that the contact information exists inside the list or not so back to the class class i am going to call the get all context method and as a first step i want to verify that the list is not empty so this process of verifying our expected output with the actual output is called as assertions so and jane it provides an assertion class and inside the class i am going to make use of the assert false method so this method will take a boolean parameter as input and if the boolean is not false it will throw an exception and will fail the test so as we expect this list from get all contacts method should not be empty i use the assert faults method next i'm going to make sure that there is exactly one element inside this list i can perform this assertion by using the asset equals method from the assertions class this method takes the expected value as the first parameter and the actual value as this has the next parameter so i am going to call the size method of the list written by the get all contacts method so now it's time to run the tests i'm going to click on the green button to the left side of the class declaration and click on run test and you can see that the test is executed successfully so we saw how to test a happy path scenario we added a contact and the contact information is saved to the application now let's go ahead and test a negative scenario where the contact creation is failing so we can test this case by providing some invalid input to the add contact method if we open the validate contact method inside the contact manager class we are validating the first name last name and phone number fields so now let's go ahead and add a test where we are providing invalid values to all these fields so i'm going to open the contact manager test class and i'm going to create three methods inside the class to test the case of invalid input of first name last name and phone number fields if you provide an invalid input the application should throw a runtime exception so and here you may observe that i added a new annotation called display name this annotation as the name suggests provides a custom readable name to your test so instead of displaying the method name which is sometimes not so readable junit displays this custom name in the test results so inside the first test method we are verifying if the add contact method throws a runtime exception when the value of the first name fail is null for that of course we have to provide the first name as null and we are verifying whether the runtime exception is thrown or not with the help of assets throws method from the assertions class this method takes the type of the exception we are expecting so that in our case it is runtimeexception.class and as part of the second parameter we have to provide the supplier where we are calling the add contact method so when i run the test again you can see that all the three threads are executed successfully if i open the other tests you can see that i am passing the value null for last name and as well as four number fields so now that we wrote a few tests let's go to some theoretical aspects of junit and understand how the jv test life cycle works so each junit test when it is executed will create a new instance of the test class and it follows different phases as part of the execution each phase is also represented with an annotation in jnet5 the first phase is before all phase where the methods which are marked with this annotation will be executed before any of the test methods inside the test class the second phase is the before each phase where the methods marked with this annotation will be executed before each of the test methods inside the test class and the third phase is the after each phase where the method will be executed after each test method inside the test class and finally we have the after all phase where some logic will be executed after all the test methods inside the class are executed so the main use of these lifecycle phases is you may want to run some initialization tasks or some cleanup tasks when running the tests some general examples of this include setting setting up or creating test data inside the database at the start of the tests and cleaning them up after the test execution so now let's go ahead and see how we can implement these methods inside our contact manager test class the first one is the before all annotation as i said before the method marked with this annotation will be executed once for the entire test class and usually this occurs before creating the instance of the test for this reason we have to mark the method as static or else jnet cannot execute this method so inside this method i am going to print a message so which should print this message before all the tests are executed and now if i run this test class you should see that the message is printed before the tests are executed so i just created a method and added the before all annotation and this message is is printed when at the time of test execution now let's add the before each annotation i'm going to create a method called as setup and add the before each annotation to this method and inside this method we are going to initialize the contact manager class you can observe that inside all the test methods we are creating the object for test for contact manager class this is redundant so we can move this logic inside the setup setup method so i am going to remove the contact manager instantiation part from all the tests and i am going to create a class variable contact manager and assign the variable to the contact manager object inside the setup now you may think that we are using only one contact manager object for all the tests inside the class is not true janet will create a new instance of the class for each method so each test will work with its own copy of the test contact manager object so now if we try to run the tests again we can see that the tests are executed without any side effects the same applies also for the after reach and after all annotations so i quickly created a couple more methods and inside this method we are just printing some messages but if you are working with a more complex setup usually you will clean up the test data created as part of the part of the test inside either of these methods as i mentioned before jnet instantiates the tests for each test method but we can also change this behavior so that it will create only one instance of the class by adding the test instance annotation to the top of the class and to this annotation we can provide the value lifecycle dot per class by adding this annotation junit instantiates the test class only once in this case we can remove the static keyword for the after all and before all methods the next feature we are going to discuss is the conditional execution feature in jvnet we can execute the test methods in our class based on a specific condition for example imagine if you developed a specific functionality on linux machine for our contact manager application which is after saving the contact maybe we are performing some additional logic which is specific to the linux operating system then we have to make sure that the test should only run when it's running on the linux operating system or else it's pointless to run the test to enable this jnet provides us with annotations enabled on os and disabled noise and to this annotations we can pass on the operating system name as the annotation parameter so i copied one of the existing test methods and i'm going to add the enabled on os annotation on top of the method and i'm going to specify the value as mac from the os enum and we can specify a message by providing an input to the disabled reason field so let me copy the test again and this time i'm going to add the disabled on os annotation and specify the value as windows because i am using the windows operating system and if i try to run the test now you should see that both these tests are disabled and actually it's not clear which test is disabled so i am going to change the method name and display names and if you run the test again you can see that the both this tests are disabled and we are able to differentiate which one is actually disabled the next feature we are going to learn about is assumptions these are similar to conditional executions annotations but instead of executing the test conditionally we are going to perform the assertions inside the test conditionally that means if the assertion is not if the assertion is not successful then the test won't fail but it will be aborted and won't be executed further for example you may have some unit tests which you may have some tests which you want to run only on the developer machine but not on ci enronment or maybe some long running tests which you want to execute based on a condition so in this case the test execution will simply be aborted if the if the criteria for the condition is not met so let's see how to do this in practice so i'm again copying the existing test and i'm going to rename it as should test contact creation on dev machine and also change the display name and inside the test before executing the actual test i'm going to read the system property called env this is the property which i have set inside the run configurations for the test so inside intellij i am going to edit the run configuration and add the property to the vm options so you can see that i had a decision property with minus with prefix minus d so in the test i am going to read this property and after reading this i am passing it as a parameter to assume true method so this is the method from the assumptions class which takes in a boolean parameter there is also an assume false method which also takes a boolean parameter but in our case we will use the assume through method to perform some assumption and if you execute the test now you should see that the test is passing and now let's quickly change the property to another name so instead of checking whether the property is def let's change it to test and if you run the test again now you can see the message assumption failed but the test is not failing it is just aborted the next junit 5 feature we are going to learn about is the repeated tests so in some situations you may need to run a specific test case multiple times maybe because the functionality has a bit of randomness to it imagine you are generating a random number between range maybe 1 to 10 or 1 to 50 and in those cases you may you you can say to junit to repeat the test execution for a certain number of times we can do that by using the repeated test annotation so this is just like a substitution for the test annotation but the test method will be executed for multiple repetitions so in our contact manager test we are not dealing with any random functionality so this is not a very good example for this use case but we can still apply the repeated test annotation to check whether the test method is executed for multiple repetitions or not so let's take the contact creation test again and i'm going to rename it and add the repeated test annotation on top of the method by adding this annotation we can remove the test annotation and to to the repeated test annotation we can pass in the value for how many times we want to that we want the test to be repeated so i want this test to run for five times so i'm going to pass in this value and now if i run the test you can see that these uh you can see the custom name for the repeated test like repetition 105 205 and so on we can also provide a custom name for these repeating tests so instead of just displaying repetition 105 we can make it more descriptive by passing the name field to the repeated test annotation and here i'm going to pass the value for name as repeating contact test and we want to know what is the count of the current repetition so for that we have the current repetition and total repetition values if we specify these values inside the curly brackets junit automatically fills in this value for these fields at runtime so if we execute the test now you can see the value repeating contact creation test 105 to a 5 and so on so now let's learn about how to write parameterized tests in jnet parameterized tests are similar to repeated tests but the difference is you can run the test repeatedly by giving different set of inputs to our tests similar to repeated tests we can replace the test annotation about the test method with the parametrized test annotation after adding the annotation we need a way to submit different set of inputs to the test method we can do that with the help of some other annotations which is used together with the parameterized test annotation so the first one is the value source annotation by using this annotation we can provide the input directly as a parameter value to the annotation and the value source annotation support different types of literal values like strings hint double float etc so you can see the complete list of supported values on the screen in our case we need only random strings to test the contact creation and we want to see if the validation for phone number field is working or not by providing different range of inputs so remember that we are doing some specific validation for the phone number field first we are checking if the phone number is not null and not empty then we check the length is exactly 10 characters long we are making sure that the given string contain only numbers and lastly we are checking whether the phone number is starting with zero so to test all these cases usually you have to write multiple tests to verify each criteria but using parameterized tests you can provide different set of inputs and test them in only one test case so back to the test class i copied the contact creation test again and changed the name and the text inside the display name annotation let's add the parameterized test and value source annotation to this test method and i'm going to provide some a list of strings which contain some random numbers as the input to be able to use these values inside our test we need to provide a string variable as a parameter to the method and j init then will automatically inject this value into the method while executing the test and lastly we have to make sure that instead of hard coding the value i am passing the phone number variable to the add contact method and now if i run the test you can see that the test is passing because i provided all the values which are valid so i'm going to change one of the values here and provide an invalid value so i'm going to add a plus symbol in front and run the test again this time the test is failed because it's failing the validation that the phone number should be exactly 10 characters long the next way to provide input for the parametrized tests is by using the method source annotation now you may have already observed that we are a bit limited to what input we can pass to the test using the val value source annotation in the real world the test data requirements are not so straightforward and we may have to construct some complex objects as the test data and pass them to our test for that reason we can use the method source annotation where we can refer a method inside the test class which is responsible to create the test data and this data is then injected into a test let's see how to do that back inside the test class i am going to create another parameterized test this time with method source annotation and i am going to create a method called phone number list which is returning a list of four numbers inside the test class i am going to just copy the method name and pass it as an argument to the method source annotation and now if you run the test jnit will dynamically read the data returned from the method and will inject them into the tests so there is no need to change the test implementation and let's go ahead and run the test so you can see that all the tests are passing successfully and if you're wondering how the previous test is passing again i just change the inputs to some valid inputs inside the value source annotation so the next annotation we're going to use for the parameterized test is the csv source annotation using this we can declare the input data as csv literals in our tests so if you are not aware of what is csv its called as common comma separated values so as the name suggests we are going to pass the input as a list of comma separated strings so back to the test class i'm going to create another test called as should test phone number format using csv source and change the display name text and i'm going to add the csv source annotation and to this annotation i'm going to pass the valid list of phone numbers as comma of separated strings so it's a pretty straightforward and if i run this test you can see that the tests pass successfully without any errors and the last annotation we're going to talk about for the parameterized tests is the csv file source annotation this is very similar to csv source annotation the only difference is instead of referencing the list of comma separated strings directly inside the code we are going to provide the reference of the csv file directly to the csv file source annotation so this file is usually located inside the resources directory of the test folder in the maven folder structure so i'm going to create a file called as data.csv and inside the file i'm going to just copy and paste the data we pass to the csv source annotation and if i go back to the test i am going to create another test method for this case and inside the csv file source annotation i am going to assign the csv file name to the res to the resources field now let's run the tests again and they should be passing without any issues the next generate feature we are going to learn is the nested test so as the name suggests we can nest or group some tests inside our contact manager test class into an inner test class so in our example we have multiple test methods which can be grouped together this may be some repeated tests or the parameterized test because they belong to the same category and if we organize these tests into their own classes then the task class will look much more clean and well organized so this is the main reason for using the nested class to make the test more organized so i'm going to quickly create two classes repeated nest test and parameterizedness test inside the contact manager test class jnet understands these are nested test classes by the nested annotation so i'm going to add this annotation on top of both these classes so the life cycle of nested test class is a bit different than the normal test class in the nested classes we are allowed to only use the before each and after each annotations but not before all and after all because java won't allow static members inside the inner classes however if you want to use the before all and after all annotations you can change the instance life cycle by adding the test instance annotation with life cycle value as per class okay now back to the test class and i am going to simply cut and paste the parameterized tests into the parameterized nested test class and the repeater test into the repeated instead test class apart from the change in the structure of the test there is nothing changed in the code so this change should not introduce any side effects for the test execution so let's verify this behavior by running the test again and you can see the tests are passing without any errors now let's discuss the last junit annotation of this course that is the disabled test you can use this annotation to disable some tests from executing in our test suit so it's not generally encouraged to use this annotation until it's really necessary because there's a chance that you will forget to remove the annotation after adding it and the test will be disabled forever which is not so good so to demonstrate this i am going to add this annotation to the first contact creation test we added and if i run all the tests after that you can see that the first test should con should create contact is disabled so so this is the end of this tutorial thank you very much for watching this and i will see you in the next tutorial until then happy coding techies