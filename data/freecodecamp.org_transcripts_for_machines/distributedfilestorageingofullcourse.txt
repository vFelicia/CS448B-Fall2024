learn how to build a decentralized fully distributed content addressable file storage system using go that can handle and stream very large files starting from scratch you'll learn how to create a peertopeer TCP library and go this course covers system design lowlevel programming and network protocols all while building a highly practical and scalable application Anthony GG developed this course ladies and gentlemen this is it this is going to be the 10hour plus video a full project where we are going to build a decentralized and fully distributed content addressable file storage that can handle very large files right that can stream very large files we going to build this completely from scratch we're going to build our own uh peertopeer TCP Library uh all from a blank page in goang I wish you the best of Lu guys because if you can complete this and you understand what's going on which you probably will you are going to be a goang maniac trust good luck and see you soon first of all first of all let's start with the basics we're going to make a main goal file I'm going to say package main what's going on here like this and let me say funk main so we can actually test things man I need to warm up not going to lie uh Funk main you're going to say fmt print Ln you're going to say we go Gucci like this and then we also what is this mmt doing whatever it is what it is sometimes a compiler cannot follow we're going to say a new folder actually maybe we should make a make file first right uh make file we going to say go I'm going to say build uh output is going to be bin FS maybe forever store like this then we're going to say run which always will do a build and then we're going to say do SL bin fs and maybe of course testing and that's going to be go test the whole sh bang uh and maybe minus for boss right you could also do dash dash race here but I don't know um cool okay is this working make run uh what's going on here go build go mod oh yeah I see maybe we should do go mod init can we do this GitHub um com andm forever store uh we Gucci okay and I'm going to do this um going to place ATS so we don't have these uh outputs in our um terminale make run we guci all right so we ready to get this party started so I think we're going to make our peertopeer lip first or maybe we switch things up and then we can go over to our disk uh storage which is basically what what what I think is going to happen is we just um going to send a file we're going to Hash that file uh just a hash a simple hash so we can have a nice key we're going to use the hash as a key then we going to add some kind of an in face Funk to transform uh the key to transform the the hashed file name yeah and then uh we're going to make these subfolders just like get does we're going to make these sub folders uh maybe in pairs of two store the actual encrypted data somewhere there and then we can have a nice way to uh do versioning of this files maybe we I don't know versioning um and all that good stuff right that's what we're going to do so we're going to do a lot of uh working with readers writers uh read closers and all that that goodu we even going to make a cash and an index system and all that beautiful stuff man it's it's insane um but first but first but first things first of course uh let's close this file and maybe let's close main we are going to make we have this bin we're going to make a new folder that's going to be peer topeer all right and iner to Pier I'm going to make a new file maybe I can call this transport port. goo package peerto peer because we're going to make things very uh generic right um like it was a real Library so I think uh maybe we should first do TCP and then we can actually see what kind of things we need to do for our interface not quite sure or maybe we can do something like type uh Pier which is going to be an interface uh like this of course and then we could have something like a type transport interface all right I could say uh transport is anything that um is anything that handles the communication communication uh between remote between notes between the notes uh in the network yeah and for for document uh if you're writing documentation on your functions you should always start with um this word should be the first word here right and then we could say something like Pier is Pier represents actually Pier is anything of no Pier is an interface that represents the remote node right that's what a p is right A lot of people don't know but appear is basically just the remote node it's a representation of the remote node of the remote connection of the the dude or the girl that is dialing us or the dude or the girl we are connecting to so of course these interfaces are actually um empty for now uh so basically uh T is is anything that handles the communication between no and the network this uh can be of the form TCP UDP web sockets right going to make some documentation maybe we'll make it better I don't know um it is what it is but I'm teaching you best practices right okay so what I'm going to do is real quick start with the TCP because I think if we have the TCP right we can uh derive what kind of uh interfaces functions we need to have we need to implement and um yeah yeah uh it's going to be TCP wait it should be TCP and then transport right and you see where where it is going right you could make your UDP transport and whatever transport you want right uh in separate files uh as long as they implement the transport interface and actually maybe transporter interface should be better but I don't think it makes sense uh in goang they want you to make interfaces right but I mean why interface not interfacer then hey anyway uh we're going to say type can you please close this yes it's going to be type TCP transport going to be a strict uh I thing is that we need to be very careful so we can actually have something that we can Implement in all our other projects so we need to we need to engineer this like a boss right TCP transport um man that's a good good idea a good thing what what are we going to I think we need to have a listen add actually no I'm going to start I thought was I thought making some configuration for this uh configuration uh listen address and that's going to be a string maybe you want a listener and that should be a net listener which is an interface like listen listener yeah and I think the transport should be responsible for holding its Pierce right so we could do actually this listener I don't like that it's I'm going to make everything private for now and we will see if we need to make something public we will check how uh but I think starting with everything private makes a lot of sense uh Pierce is going to be a map of uh Pier right it's an interface no not Pier it's going to be a map of string and maybe we should make our own type for this um we could use a net other like this actually that makes a lot of sense to be honest to use this um that makes a lot of sense and we will see but it's not going to be the address I'm trying to think out loud right uh I think you B that's good that will benefit you more than just copy pasting stuff uh let's start with a net Adder we will see we will see uh because a net Adder if you open this it's basically nothing more than Network and string right it's it's it's a super easy interface to use and it makes a lot of sense so uh GD right you need to do GD and you're here if you use the Vim plugin um P map adder and then we're going to say it's going to be a pier right and if we open up our uh normal transport thingy we see Pi is going to be an interface that represents the remote note right so it's going to be this and we need to have um an AMU right and a mutex and I think you could call it am but maybe a PE lock actually we're going to call it a it doesn't really matter you will see because if you have different m texes how you going to handle that right uh that's going to be a sync uh RW mutex right and you see how you need to group things right because we have this map and we have this mutex right and this basically means it's a common practice in goaling that you do this uh that you put your mutex above the thing you want to protect it so we can see oh this mutex will protect the Pierce right um that's good then you're going to say funk new TCP transport uh it's going to be l n like this going to be a string should it be a net adder or we going to create one H good question and that's going to return we we have a couple options we could return a TCP transport like this right and then say return um TCP transport and say that the listen address is basically the listen address we give it like this right uh but we can also say we can also make this actually a little bit more convenient and say hey this is going to be a transport right of course if you're testing this if you make a test right let's say you have a test here Funk test test things uh the problem is of course that if you want to test this thing and you say for example uh t transport T is going to be a new TCP transport like this right and you give this an address like I don't know could be anything the problem is you cannot say t listener right you see it doesn't work because yeah even though you need to cost this to uh a TCP transport like this and then it's going to work right except you see decisions you need to be make that need to be made and I want to show you this kind of stuff because um yeah it's a little bit Advanced and like I said patreons you're going to learn indepth stuff right very important stuff that will make the difference between a decent engineer and basically you know what I mean um you are the double weight you are the double the double Champion or your the double Division champion right Conor McGregor you know what I mean the best of the best that's what I'm going to teach you so that's a thing um in my opinion I'm going to try to keep the TCP transport like this um because it doesn't matter in my opinion I just want to show you these things CU sometimes people are returning the the interface right cool so uh we have this then I think we need to have some then um you know what let's let's uh try to do this in um in a TCP transport TCP transport test something like this and let's open up let's let's open up uh test here and then the transport DCP here so we can do stuff right going to say package uh peerto peer I'm going to say funk test TCP transport just to do stuff uh T is GNA be testing T right so let's save this real quick yeah so we're going to say for example um TR is going to be a new TCP transport and I'm going to say the address is going to be for example we could say that the uh listen add is going to be uh 3,000 or 4,000 I'm going to say okay listen address and then we could do something like um wait let me first to go we're going to use this for our tests go get get up.com I think it's stretcher and then testy and can I do something like assert equal TTR listen address listen address no we can't because if you're designing libraries and such or you're making production systems that's actually what what we're going to do we're going to make this as if this was a production system for one of your clients that are going to pay you a lot of money to build this so I need to teach you exactly how to make this quality code right quality it's going to take a little bit longer but hey it is what it is um so we're going to say uh get up I'm going to check if we imported this package actually uh get up come stretcher not quite sure of this stretcher and then test defy and I think assert man what's going on yes it's working I used this package so so many times in my life that I know it on the top of my head uh all right and now we can actually run this test like this and then everything is passing of course right but just want to make a point so we could do something like if we have a transport we should say a start function or an accept function depends on how a server is willing to use this so let's say we have um for example this is our server right uh how would we use this we're going to say for example TR accept or or it's accept already called by saying TR start right some things we need to to we need to take in consideration so let's say um so what what does a transport always do a transport always listens and accepts right it list listen and accept that's why uh I think maybe a function transport TCP transport you could say listen and accept something like this and then we could say or listener error is going to be net listen TCP T listen address what the hell is going on here vs code a little bit too enthusiastic uh T listener it's not going to be it's going to be T Liston address so we already know that we have have an error read right so we're going to say if the error uh is not nil we need to return this so I think listen and accept should return an error at all cases so we can actually return this error and then we could say tln equals listener lessener equals Ln like this or you could do for example say VAR uh like this and say add error and then um yeah or actually because it's only one and then could say something like T listener man this listen address man T listener R and then relieve the column that could actually also work depends all right so we have this listen and accept which is uhan and then we need to start up uh an accept Loop but yes this is going to return the error so we could say maybe a private function TCP to make it cleaner TCP transport uh we could say something like accept Loop like this and say for T listener it's going to be this it's con accept right so we need to listen wait this is a connection error is going to be T accept if there is an error in the accept we actually don't want to do anything for now you could say fmt uh print f I could say TCP trans TC TCP transport or actually TCP maybe TCP error accept error like this and then uh we could do a percentage percentage s a new line of course and then say the errors right and now we have a connection uh what are we going to do with this connection we're going to handle the con I think and then we could say accept Loop go accept loop I think we should say go start accept Loop and then we could say here go t start accept start accept Loop and then we could say return no here right now we have a con now we could say make other private function and I'm going to make handle come here it's very important if you're writing production code or very high quality code that you organize all your public functions at the top and your private functions at the bottom and always organize them based on how somebody would read it or based on the importance of a function right so if a function is more important put it more above and if it's just a simple helper function uh demote it to the the bottom right that makes a lot of sense because I don't want to scroll to a couple of string operation functions that basically makes no sense uh for me to read so and I think here you could say something like uh ttcp transports we could say handle con which is going to be a con net con and handle con because we know that we're going to call handle Con in a go routine so I don't think calling the turning in ER makes a lot of sense unless you're going to do some maybe a Channel or something but hey um so and now you could say we have a connection here and then you could say go T handle come come and call it a DAT right and then it can keep looping and keep listening and uh nice and tight nice and tight function and then here we could do for now we could say fmt print f um percentage plus v maybe a new line the connection and we could say for example um new incoming connection right cool so yes yes so basically how it's going to work is we have our transport which is a new TCP transport here and then we can say um Dr we don't have anything to start this listen and accept listen listen and accept all right uh so we could actually make test listen accept um this we're going to return an error so we could say assert uh assert nil T right that should give us no error right um let's run this test so it's working fine and we could also do something like for example if you do this and we run the test then it's going to return an error because this is not a valid um thing so so hey all good okay so thing we already know no matter what kind of Transport we have I think calling listen and accept is always something that can work so we can go to transport and we could say in our transport interface we could say listen uh and accept and basically does not then it returns an error that's the only thing it needs to do we don't care how or what this function is going to do it just need to be listen and accept because um that's something we are going to call in our server right and depending on what kind of Transport we're going to have we're always going to call listen and accept if it's UDP it needs to listen and accept UDP if it's websits it needs to do that if it's a local transport I don't even care what kind of transport it is it could be even a grpc listen and accept could be make could make sense here here right all right uh TCP transports are we going to see test okay so what we also going to do is if we are handling the connection um we need to basically the question rather is so are we good going to decode encode are we on or encoder and decoder is going to be an interface also but where are we going to call this is that something that's on the serice side or on the transport side or something in between right that's a thing um I think we're going to make a p we have this TCP transport that's here let's make I'm going to for now I'm going to make it here TCP P it's going to be a strict we're going to have a connection we're going to say TCP Pier represents represents the REM the remote noes over uh TCP established uh can we do connection yeah yeah yeah yeah yeah yeah what's going on Lost in Salvation uh TCP represents the remote nodee over TCP esta connection yeah con is going to be a net con um I think because we learned our lessons in all our protocols in the poker engine and in the and and and in the blockchain shenanigans you're going to say if this is an outbound Beach uh which is a boo right what is an B if we if we say uh TCP transport dial right and we dial to a pich that's going to be an outbound pich if we if you make connection with that Pier it's going to be an an an outbound but if so if we accept and and make a peer of the connection that's going to be um an inbound Peach right it makes a lot of sense like this for example um Let's do let's let's make documentation so basically um dial if we dial and accept wait a minute if we dial if we dial a connection outbound but if we accept and retrieve a connection e is this correct accept if we accept and retrieve a connection it's going to be outbound false well right because that's going to be an inbounded P I hope that makes sense um you could say con is the underlying connection of is the under connection of the P yeah um all right all right all right next thing we're going to do is basically maybe make a Constructor Funk new TCP P which going to be a TCP Pi or a pier doesn't even matter you're going to say return and TCP Pier of course if we make a new TCP we're going to say a connection which is going to be a net com and we're also going to say uh if if this is an outbound spe and then we can say come and outbound like this of course uh I prefer to do this although they have the same names still uh as for bothos as possible is always a good thing because I I think if you if you follow the blockchain from scratch we already had some nasty issue by not um providing the names in a more verbose Way new TCP P so we're going to make this P right we also going to need to have some way to add peers the question is are we going to do this with a channel I don't think so um but we're going to have a channel to communicate right because every kind of Transport is going to have a channel to communicate and we're going to call that as a as um as an interface function um handle connection do we actually I think we're going to need a pier here handle Pier uh that that's the thing the question is where are we going to H um and on I thought maybe we should do something like let's create a p right you could say that the PE is going to be in our case a new TCP Pier I'm going to say the com right and then if you accept it's going to be an outbound Pier so it's going to be true or you could make the peer here not quite sure uh probably going to change this actually we're going to make a new pier new incoming connection and let's do the spear and let's see if this actually works the question out is we cannot block uh for now actually we can we could do select like this and then um or we should call this in main could say that the transport is going to be a peertopeer new TCP transport forever store uh SL P2P I guess for some reason Vis Visual Studio code don't want to implement these things uh 3,000 like this now we going to say TR uh is going to be let's say log fatal start and accept question what's going on here listen and accept yeah listen and accept and uh of course we're going to we need to block here right real quick let's make run this uh nil what's going on of course because it's not uh yeah yeah yeah I see I see um let's do it like the traditional way right Edge clear make it all right so we are doing this thing let me quickly do uh tet uh talet Local Host 3000 all right so you see we are connecting and we say a new incoming connection so we already have easy we already doing TCP dopam mean dopam Meine you see this gives me dopamine and it should give you two uh okay cool listen accept is working so we have a new pier that's fine um uh now we need to make a very important decision because I want to make a handshake Funk which is going to be look uh what we're going to do uh I think because handshakes do we uh some some libraries need a handshake like our poker and what what's a handshake a handshake basically means U you connect to me or I connect to you it doesn't not really matter we connect and first of all before we are going to accept you as a new peer we're going to shake hands and if this handshake is not good we're going to drop the connection and Say Goodbye right um so that's why I think in TCP we're going to have something like what I call a handshaker or a TCP actually the handshaker doesn't even it it can no no I have an idea it could be any handshaker the handshaker could work over uh um a handshaker is going to be a handshaker and we could do something like this new file for example we could say this hand shake handshake Dogo we could say package peertopeer type uh hand hand Shaker interface uh and that could be something like is this correct my spelling hand yeah you could say handshake or or maybe shake hands nah handshake and the question is we're going to return an error doesn't really even matter it's going to be hard this handshaker because we're going to think about this but the thing is um because I'm not quite sure you see you could do like a handshaker right here um let's go to handshake and let's say type default hand uh handshaker man my spelling default handshaker is going to be a strict do we need to make this a strict does it actually make sense because we could do something like uh ah doesn't matter we're going to make this we could also do something like a type handshake Funk which is going to be a funk of type error something like this and I think that makes more sense because are we going to add stuff to this handshaker are we going to have things inside of this structure that's a good question I don't think so I can I think we can do something like this and make it even better and say the handshake Funk right and maybe we could do something like any could take an any I don't know to compare or something I have no clue and then in TCP transport wait handshake and we could say yeah yeah yeah yeah I have a good idea uh we could say transport and this is going to be the handshake funk handshake Funk right and this is going to be um handshake Funk right and if we going to construct this we're going to say the handshake Funk uh the handshake Funk is going to be a funk you could actually make this funk somewhere else but for now we're going to make a not funk it's going to be Funk any errors and say return n right so it's basically doing nothing so we could do could also do something like this right like like I said I'm going to teach you a lot of stuff so it's it could be a little bit slower but I hope you you have something about it and let me know poke me uh let me know what you think about these things should I go faster or should I explain these things you could also something do like this like a knp uh a NP handshake Funk which takes in an any we don't care and an errors and we say turn n right and then we could say instead of doing this here we could say yo this is a not handshake Funk we don't care right and and if you really want to be cool you can do in the handshake you could say hey I'm going to provide my users with an up handshake Funk right so if they don't need a handshake they could say yo oh man I need to sneeze oh no and I'm not going to cut this out I'm not going to go in this video to cut these things out that's not my style man everybody needs to sneeze and this big light is shining in my eyes make it it even worse uh so you could say handshake Funk handshake Funk is I don't know I don't know how to explain this because we need to uh probably make this handshake fun a little bit better and we going to see how this going to work so let's say we have the connection we have a pier which is good and then we could do I have an idea this handshake Funk is going to be look we're going to say something like this if R equals uh T handshake Funk with the connection and if the error is not nil actually I'm so sorry but I'm I'm going to be a perfectionist uh shake hands shake hands is going going to be a handshake Funk so we're going to say t shake hands with a connection and if it's an error we're going to say because we're going to here do go handle connection so we can actually start a read Loop right here uh we could say here con no not con uh um NR or decoder man I have so so many good itas this is insane oh man what you going to do guys listen oh we only at 44 minutes and I want to show so much stuff man we're going to make this is going to be oh my goodness I'm so excited I have so much dopamine you see I did this maybe 1,000 times in my life and I'm still getting so excited by making these these programs as cool to use it's crazy what is this what why do I have an eror unnown field yeah I know hey man let me let me be happy is it is it possible compiler uh handshake Funk we're also going to say um a a decoder a decoder is going to be uh should we call this decoder it's going to be a decoder or is this or is this too generic right and then we could make look what we going to do guys it's going to be insane uh new file we're going to say um encoding maybe we're going to call this encoding go and we going to call um peer to package peer to peer basically what I was saying uh this decoder thing right so um let's let's get back because maybe you guys uh had a longer break than I so we have the shake hands right um which we actually need to handle um what are we doing this is going to be our read um our message read Loop so we're going to read from the connection and actually if you want to read you need to do something like this let's say we make a buffer which is a a new bites buffer right and then you could say n r uh is going to be uh is it Con read the buffer right con read the buffer like this and then let's just eliminate eliminate the error for now man what's going on uh and then we could say something like um the message is basically debuff n right that's that's that's a message but I want to have something uh better we're going to make uh we the file this encoding file we're going to say type um we don't need an encoder but we need a decoder but I want to keep these files in the same uh keep these TR interfaces in the same thingy in the same file so we could say um decoder it's going to be an interface and that's going to be decode and addos the question is how we going to do this um you could say decode any no it's it's not it's going to be decode me a slice of btes no you're going to say decode me and IO readers that's what we're going to do decode me and IO readers and um an any uh ah I'm I'm thinking we could actually make this um we could do so many things is this what we need I think so because we could do something like this right instead of doing all the shenanigans we're going to delete this and we're going to say uh read Loop and actually could we could boot up a new one but it is what it is we're going to do it here and we're going to say actually the decoder is going to be a decoder that's good so we're going to say uh in this case we're going to say t decoder decode uh the connection into whatever type you want for example let's we are doing so many things at once it's crazy uh we're going to say type uh this going to be a placeholder temp it's going to be a temp is going to be a strict uh there's nothing in temp because we don't care and we're going to say here in this case we're going to say message uh wait what's going on message is going to be uh and temp and I'm going to say decote me the message right uh that's good and that's going to be an error if the man I'm thinking so hard that I cannot type if R is going to be this uh man yes no that is not nil because my my brain is already uh at the handshake because it's red it gives me an error uh and I'm going to say we cannot actually log here right we cannot return are we going to are we going to do a um Parma that are we going to do a perad that connection where if he sends us something we cannot decode we going to drop him I don't think so uh maybe we could do it could do cool stuff we could say for example um something like a l decode error right that's going to be zero and each time we have an error we're going to each time we have an error we going to say l de code error Plus+ and if uh the L de code error equals five times or something then we going to drop the connection hey spam protection something like this I don't know I'm not sure I just came up with this to be honest I just came up with this Shenanigans uh it could be a good idea actually um man I'm I'm so today it's my creative day not going to lie I'm creative today I need to abuse it so we're going to say fmt print uh F we're going to say percentage we're going to say actually it's TCP right uh we could say TCP TCP error once again and then we going to say s new line Eros continue like this right there's no PE do we actually care could be connection I don't care maybe we need to delete this this login I don't know so we have this spe we're shaking hands with connection maybe maybe we want a PE maybe maybe you want a peach handshake what's going on here handshake handshake funk handshake with a man what's going on here crumbles on my keyboard I hate it so hard I'm going to lie TSH hands why why is this uh giving us issues we don't have this function did we what's going on here did we not rename this what's going on oh man I forgot something let me quickly do get inet yeah sorry guys I missed actually um committing the first episode but I'm going to do it right now uh get commit uh if1 peer to peer uh peer to peer to peer lip something like that right and then it's going to be a couple more things in it but hey it's it's it's in the patreon community right it's in the patreon community you guys understand um so we have the shake hands that's good that's good everybody's happy Okay cool so we're going to shake hands if there is an error in Shake Hands we actually need to drop this connection so we're going to see actually we should start a b loop with the we should do we actually want already appear I'm not sure yeah maybe we going to set something in the peer we never know like get joining joining the the YouTube Studio which is basically my living room um wait we need to do some many design decision decisions uh new peer Shake hand let's shake hands with the peer we don't care right we will see if this n we going to say con close and actually return return this this this thing uh man why why so many lag in in in in this this vs code uh ver uh ER invalid handshake equals errors new invalid hand shake and always make your errors low caps why is it not working it is working um could say addage hand is returned if the handshake between the local and remote noes could not be established EST that bled man all right so we're going to say return at invalid handshake like this we couldn't of course we can't we are literally damn here ah it was such a nice thing the problem is of course we have this start accept Loop and then we have this uh no man we cannot have this because it's all just return and we're going to we're going to just log this out like this actually let's tight it up I'm going to say TCP erors TCP handshake erors like this very important that we first shake hands before we are going to decode here right because in this handshake it could be that we in the handshake function are actually reading from a connection so we need to be very careful with this um all right so yeah um let us actually open up main so we don't do we have a decoder we don't have a decoder right that's a problem uh so we're going to say TCP transport we need to have options right because otherwise we need to have we need to have some options to be honest um type DCP transport Ops going to be a strict and we actually going to say the listen man we need to do a lot of stuff not going to lie this going to take a lot of time we're going to say that the listen adders going to be a string we're going to have um handshake Funk hand Shake fun is going to be uh a hand shake Funk we need the decoder which is going to be decoder I'll make options like this this maybe I don't know or Ops or com I don't know how do I need to call this TCP transport Ops that's that's what it going to be um and then we're going to say instead of the chaning we're going to say give us give us the Ops which is going to be the TCP transport Ops and we're going to say shake hands we don't need all of this again Shenanigans we're going to say that the Ops I mean the TCB transport Ops is going to be the Ops like this and then instead of we can make this public listen add yeah that's fine it's all fine of course T shake hands that's going to be t uh handshake Funk right and then of course uh it's going to be T decoder right T decoder uh decode yeah yeah yeah yeah yeah like this so if not if you go to main um we're going to say that the Ops TCP Ops right is going to be peer top uh TCP transport Ops like this we going to say that the lesson Adder is going to be 3,000 uh decoder that's a good question I don't know and the handshake going to be a default not handshake Funk not handshake Funk because we're going to we're going to do no handshake because it's always going to be okay so yeah you could also Al say that the handshake Frank is going to return a Boolean if it's going to handshake yes or no but if it's return an arrow you can have a better logging uh thingy the problem is we don't have this uh TCP Ops we don't have this um decoder right so if you go to decoder encoding I mean could say type go go why am I laughing a lot of people maybe don't uh is going to going to going to understand this but we are using GOP so many times and I don't like GOP I actually like it but it's not yeah it is what it is man uh GOP decoder strict is that a strict yeah why not actually we don't need this right so we could say funk um deck which is going to be a Gob decoder help do we need a pointer probably not right I mean well we could do that because then we could check if it's n and anyway we're going to try without uh it's going to be a hub decoder we're going to say decode we going to decode um the io AR is going to be an IO reader and we going to have V is going to be an any I'm going to return an error right so how we're going to do this actually very easy we're going to say return can we return yeah we can we can say uh Hop new decoder we're going to say the reader and we're going to decode V hey hey I cannot do it it's that easy I mean it's plug and play right now we going to go to main and then we're going to say yo the decoder in our case you can make any decoder you want you could decode it in in and I don't know you're the b Ras if you want to extend this with your own decoder man go ahead and send me the code so I don't need to do it decoder is going to be aop a peer toe goop decoder easy that's what we're going to do yes all right so now we can actually do some cool stuff right we can we can uh we can test all right so we have this handshake yes yes yes decoder uh what's going to happen we have this me this is not true first of all we need to make something that we can actually use in some kind of uh Channel a message if you want to send something over the wire I'm thinking actually how we going to do this maybe we could do nah that doesn't make any sense we could make a new file I know it's a lot of files but uh message go we could say uh package peer top we can actually Defector this and and and do whatever we want right uh I'm going to say type message RPC is it not RPC is it RPC actually I'm going to make this even even just more genetic or just message right it's going to be a strict and uh a message is going to be or we make it like this btp message actually why because it's already in full P message um it's going to hold a payload which is going to be a slice of bites actually it could be any is that uh payload do we need to know from W comes we actually always no right or not I mean uh message represents uh any arbitrary message any arbitrary data message holds any arbitrary data that is being sent over uh over the over each transport uh between two notes the network and then we could say something like this message is going to be a message we're going to decode this stuff and after this we're going to say fmt print F uh percentage V new line the message and we could say um message we're going to change this right but just for testing to see if this works actually actually actually actually H it doesn't does it make sense to make what do we actually let's do make run all right that that's running that's running so we're going to use uh or Shenanigans uh Local Host 3000 all right so we have new incoming connection hello there are we hand yeah we hand can I actually de code this in a message because we're not sending a message right because the message is always going to be unless we have something uh it cannot it Gob cannot encode this uh that's the thing why am why are we decoding by the way yeah decode decode right decode encoding decoding uh the problem is look if if you do this real quick uh damn this was such a good idea not going to lie we could do like a buff it's going to be a new bites buffer then we could say n is going to be con read uh the buff right uh if add of course is not n we going to the OT and then we going to say uh like here we going to say buff M can we do this okay so this this is basically something else right so we say uh tell net Local Host uh 3,000 now see that that's working right so we have this um these messages and the reason why a normal message not work is because it's go and coding but hey of course it's not going to work because tet does not send any go encoding so how do we fix this how do we fix this well well then we write our own encoder that works for uh for normal connections isn't it I'm going to comment this out make this message yes that's what we're going to do we are actually insane trust me we're going to go to encoding and we're going to say funk not P coding just plain bites yeah that's that's a good idea you're going to make a type uh KN KN decoder which basically not going to decode anything right and I think always uh providing something for Library like KN this KN that KN KN everything it's interesting because users can just use this directly for their test and and and all that stuff uh so we're going to say funk actually I'm going to copy this whole sh bang real quick so I don't need to type that much I'm going to say this is going to be a KN decoder decode is all the same thing and we're going to say basically we're going to say uh actually I'm going to make a new buff going to make a new bites um buffer like this and I'm going to say buff read can I do this is that a thing I probably it's probably no it's different right it's or read buff is that a thing ah we can't it needs to read bites um doesn't matter you're going to say that the buffer is going to be uh 28 or something I'm going to read the B going to be n like this if add turn add and otherwise you're going to say of course this any is of course well is is is a problem right iaka um I'm thinking actually because do we want to do the encoding in in because we are in our in we are in our transport right we are here in our transport so making this is already hardcoded isn't it because this could work like this but I think we we we I mean how you decode everything into a message right into into into a message instead of this any type uh we could say it's going to be a message and we're going to use this as a communication at all times but what's the payload going to be that's that's generic that's depending on the platform that's what you're going to that's that's what you're going to decode with with with whatever we don't know we actually don't know we we need to give the user the option ourselves the option because maybe depends on what we are going to build um so we could then we could actually do something like this yo uh the message is going to be this is actually this is this this this this this uh need a pointer right because I'm we going to say the message payload that's going to be the buffers uh with this right and then we could uh actually delete all the shenanigans always make it a message oh I think my my cap lock is on right and then we have this message uh which is going to be the message and uh yeah do we wait wait wait we need to make sure it's a knob or default default coder yeah yeah yeah yeah yeah and then we're going to say uh basically in main we can just configurate this we're going to say this decoder is not going to be it's going to be the default decoder right like this what's going on here yeah yeah yeah I see I see I see it's not going to be any got be a message make run V again what's going on with V where is V all right so let's say uh tet Local Host Lo Local Host 3,000 hello ah you see now it's working right so we could give some messages some random stuff and then we can see that we are actually having a message with a payload yeah and then what we could do before we going to pipe this into a channel we are going to go to what's going on with TCP transport test yeah that's broken I guess uh but we could go into TCP transport and in what we could do is uh if we take message we could say we're going to have a from so we always know uh it should be an ADD and now we could say something like uh we have this message decod it and then we going to say message from it's going to be become remote remote edit and that's not going to work uh that's going to be a problem because like we mentioned in the poker engine it's not because the the if we dial somebody and his remote address is going to be the address he's listening to and actually I want to have his listen address because uh so we can actually send back much more easy but uh that being said that being said actually for now it's good enough right we could say make run and then we can say here go run oh go run down Local Host uh 3,000 and can say hello right and then we have this message and it's coming from this other guy here and that's the payload right and then we're going to send that into a channel just a generic Channel with a message right and everybody that's using the library we for the most part um we can then say okay it's a channel we have this here and we're going to handle it in the server and that's going to be decoded the p is going to be decoded could be an N it's could be an any uh we going to see you're going to see because now it's it's it's it's a default encoding which is basically plain bytes but it could be that it's that even those two messages are going to be sent over go up encoding over Proto buffer and then how we handle the inner bites could be another encoding decoding I don't know we're going to see how this going to work um I think this is good for this video uh I think the next video we are going to actually finish this up we're going to finish this this complete up so we can actually start uh with our key with our dis dis storage thing make a server use our own uh library to connect and everything is going to be nice nice nice or maybe we actually going to do our be Discovery and stuff also in this Library not quite sure we're going to see so let me do make run okay I think we started with this uh peertopeer package right we are implementing our own peertopeer package let me see uh the main yes and then I think TCP transport all right we have these things so I think what we're going to do next is basically we are doing this message decoding here and it's not the decoding of our payload but it's the decoding of the RPC actually the RPC between between two peers and I think we what is the stamp actually what the hell I think remove the stamp so I'm really so I'm left over relix uh let me do settings real quick first and make this uh 18 for the blind homies I think what we're going to do is open up message and I think we're going to rename this to RPC an RPC strict that makes more sense RPC and maybe we should rename the package to RPC but a um message so we're going to say this is an RPC we're going to say RPC this should be an RPC and this is going to be an RPC and of course this is going to be an RPC RPC all the things uh what is going on here this should be a small caps RPC by the way and let me open up um I think we Gucci actually and I think we have some the test is is actually broken uh yeah that that's because we basically have uh or transport options right instead of making this so we should do like Ops it's going to be transport DCP transport Ops like this and I'm we going to say that the listen address is going to be uh let's do 3,000 3,000 please we need the handshake right we did those handshake funk that's going to be a knob handshake Funk we're going to for now we're not going to implement any handshake Funk so you see that we have the ability to create a handshake Funk but we don't going to use it and then we need a decoder and of course we provided the default decoder uh so we can just use that and then put in opts what going on here op inside here and then we want to assert the listen Adder is that's going to be the listen Adder listen Adder like this uh and that's going to be we could do something like this right to test it like this make test real quick undefined message encoding yeah we need to change this it's going to be um an RPC do we actually want a pointer not quite sure not quite sure make test I think we're blocking in a test by the way yeah the select statement this should be good let's make test real quick uh and everything is working fine that's good then let's go to main uh let's do a make run that's working let's open up uh talet my microphone is is is doing crazy stuff uh talet is going to be Local Host 3,000 uh now we're going to actually send some messages by the way we're going to say um hello you and then see what's going on yeah so it's all working fine we have uh from from who is this is this Comming and the payload which is sending which is fine working all good um let's open up transport real quick the P interface I think the first method we're going to have in our p is close very important uh close like this so we can close the p is connection and if we open up TCP transport or transport itself uh enable to read these messages we need to have some function which is called a consume which will return a Channel of RPC and now we need to make sure that it's going to work so we're going to say uh TCP transport uh and that's going to be let me quickly think about this you're going to say an RPC Chen which is going to be a chen of RPC a Channel of RPC and then I'm going to say here that the RPC channel is going to be make me a chen of RPC easy then we need to in in in uh Implement our uh interface we're going to say t TCP transport we're going to say consume and that's going to return a Channel of RPC and you see this this syntax right this basically means if you watched the concurrency for beginners this basically means we can only read from the channel and we cannot send to the channel right very important and we're just going to return T RPC Channel like this and then we could say consume implements the transport interface just like that you could say uh which will return a read only Channel uh for reading the incoming messages sent from received from another P actually received from uh another P another p in the network yes that's good all right so now we need to let's do this cursor out of the way now we need to find a way to actually put that uh into our into our channel right so right now we're just printing this channel but we going to say something like that the the RPC channel is going to be the RPC it's going to be an RPC it's going to be the RPC right what's going on that's a pointer we don't want that although we need the address here for the coding so that's good yeah this is is is failing because uh P does not implement the the the close interface right the peer interface so we're going to say uh P TCP P by the way we're going to say close going to return an errors and we're just going to say return P come close and then we can say close M uh implements the P interface just like that all right I think that's good um let's test that out right how we going to do this we're going to say uh listen and accept maybe we going to boot up a new go routine here quick to test this real uh real fast we're going to say for TR consume is going to be the message I think it's something like that uh print Al Lan message or we could say print F what's going on here print F and then say percentage plus fee uh maybe a new line something like that is it going to work uh I have no clue let's let's run this uh running is going it's working you could say Tet Local Host 3000 hello yeah it's working fine right although we have this Relic this slend Relic for some reason yeah we don't have a a bad new line uh it's crazy why is this wrong oh yeah of course this is not a this is a new line I see make run we could say tet uh Loc host 3,000 and then do it again yes perfectly fine so now we can consume it's very important because if we uh attach or transport to a server or something in some way then we need to have we need to call consume on any kind of transport and the TCP transport will return his channel but for example any other transport will also return it his uh respective Channel which he communicates over over the wire and in our case it's TCP but it could be anything right we need to make it generic so that's fine um it's it's actually capturing output what's going on here let's close that in my OBS I hope it's fine all right so we have that the next thing we going to do is um we need to find a way because let's open up real real quick PP transport I'm going to show you yeah so this spe map I don't think we going to we going to keep them we not need a spear map because I think the transport is not going to be responsible to keeping the peers because peer is an interface so we could um I think the server is responsible to maintaining a list of his peers which could be a peer interface which could be any peer right it could hold uh peers that are connected with ECP it could hold Speers that connected with a local transport it could even hold Spears connected with grpc it does not really matter a p is an interface and our server could hold any kind of peer any kind of connection with his Respec uh respective transport that is the beauty of this genetic implementation but we need to have a function we need to have a way to notify the server that there is a new peer that the server can do with a new peer whatever he wants so I think to do that is to do something in TCP and we could say something we have decoder we have H fun we could say that the perer fun or onp is going to be a function of a P with an error right and then we could say that if this function returns an error we are not we're going to drop the P um how we going to do this um first of all I think I'm going to do something like this I'm going to say a defer fun here I'm going to call it or not how does it work it's like this right and then we going to say um actually do it here and then maybe say V error add error then yoink paste it in here and then we could say uh something like uh dropping p connection read Loop yeah uh dropping peer connection and then we could say an error which is going to be the error here on top then we're going to say con close so we could not do doing anything here we could just return here this can be good and here we could say if error first of all we're going to say if T onp right if that's not nil if somebody provided this function then we're going to call it if somebody does not provide this function then we're not going to call it but if somebody has uh provided us this function then we going to call it then we going to say uh if R is T on P and we going to say p no it's going to be the pier yeah we just made and if the error is not nil then we're going to say these erors needs to be can new erors actually we're going to just return yeah something like that so basically what happens is we're going to do our handshake if that's okay then we're going to do the on peer if that fails we're going to drop if that continues then we're going to start our read Loop right um yeah I think that's fine so if you go to main we could say here uh onp let's let's try this without let's try this without first uh make run so that should be normal right you could say uh tnet Local Host 3,000 hello you see everything is working fine we got these messages uh but if we say something like uh onp right and we're going to say that's a function of uh p eror and then we going to say something like um return fmt error F failed the onp funk uh there should be a peerto peer peer like this and we run this again right and then we connect in Local Host 3000 right wait let me do this right it it it instantly drops a connection right so we connect it and and and suddenly tet just exits out and that's because here right dropping p connection filthy on P Funk which is nice because that means that our logic is is working and of course uh we could say here right we could say um let me do we could say onp or something we don't need to specify it in the in uh directly into the transport options right you could say on PE is going to be onp here it's going to work perfectly fine as long as it has the correct signature right um that's fine now we return an error but we could also just return nil right so it's going to work so we could return nil here and then we could say fmt uh print Ln and we could say uh doing some logic with the appear outside of TCP transport and let's boot tet up and then we could say hello we can send messages and then uh we're going to say doing some logic with the p transport so it's all working fine if we have a new peer um we are actually in a good spot that's nice all right let's close it up yes I think it's good so um yeah yeah yeah yeah yeah yeah I think we're in a good spot it's going to be a short episode this one because I think right now we have everything we need to have uh or maybe wait we can actually not I want to test something because on pier we could say this is the pier right and I want to test something what happens if we do be close that's a good question what happens if you do that I'm going to I'm going to check it out it's a very important thing because that's going to basically um drop the Pier from from whatever yeah so we see that's good that we have this eror now we have this Loop right use of closed network connection and it's in the read um how are we going to fix this let's open up p real quick which is in transport right close it's in TCP transport actually it's here right uh if you have an error we keep looping uh let me see so what happens is that we we have a we have an error here in this decode what are we going to do are we going to drop the connection or we going to check the errors good question do uh let me can we do net at closed so I think we could do something like this because I think if if if somebody sends us a wrong payload I don't think we need to punish it I don't think we need to punish him and say yo you're out because you sent a wrong payload but of course uh we could say something like this right R is going to be this and then we could say uh if f is going to be net a con closed then we going to say uh return and we could do it like this and otherwise we're going to say the TCP read error is that something that's going to work let's try it out uh talet uh Local Host 3,000 use to close network connection it's it's not working oh it's return yeah I think it's fine Clos it it is I CL turn my is already closed yeah I think that's good right because can we can we can we Panic the air to see what kind of a this is it's a very important thing we need to get uh uh working let's not make run it's going to be tet right yeah you see it's it's a use of of of Clos Network connection the question is is is um let us see reflect uh type of as it's a net up error H that's um can we not do this damn okay I think we need to investigate this I think enable to make this um let's return let's return for now let's see let's just return right and now it works right now we have dropping a PE uh because we have a use of closed network connection I think there should be a way so we can assert this specific error so we only drop the beer if it's that error instead of just a normal error actually uh another error for example a code error or something right but hey uh I think we need to figure it out uh soon I will check it out how we can do this maybe it's it's I don't know we can we can see we're going to make it work it's not a big big of a deal for now um I think we have a good portion of our peertopeer lip then we're going to make the storage then we're going to make a server Implement that storage into the server and then we can do some um Shenanigans let me see uh what do we have main um I think we're going to make a new file we're going to call this uh storage go I think or store doesn't really matter uh package main I'm going to say type storage or store maybe store maybe store is good uh it's going to be a structure and then let me quickly find a good spot here and um I do we need something maybe store options or something type uh store Ops it's going to be a strict also and we going to we're going to have some some some stuff uh I'm going to I'm going to keep this here for now let's let's do let's go now with this cursor store test what is this I'm going to do the first function so if you want to write to dis right so basically what we're going to do is some kind of a Content addressable storage where we can save anything in a deep nested folder based on the transformation of the key you will see uh so I'm going to say something like Funk s store uh right stream because I'm want to stream it or try at least we're going to say key is going to be a string and then we're going to say an r i your reader right what's going on here uh a read it like this we're going to return an errors uh yes let's save it real quick and then so something like this right so the path name we could do it maybe this the path name is going to going to be some kind of a transformation of the key right so we could say something like um transform Funk or maybe bad transform Funk which is going to be a type of a bad transform Funk right and I'm going to say it's going to be a function we're going to say of the string of the key and it will return a string it's easy as that and then you could say the stups that the pad transform fun is going to be a pad transform Funk right need to be that signature yes and then we could say here that the store Ops we could just embed it and we could say a funk new store I'm going to give this uh opts which are store opts and we going to return a pointer to a store maybe an error not quite sure I'm going to return uh pointer to the store and I'm going to say that the store Ops are going to be the Ops right something like that of course if you make a test file uh I'm going to make the store test actually store test go right and I'm going to rename this real quick to store yes uh let's close this and let's make another file what's going on here let's open up store on this side and of course test on this side we're going to say package main Funk test store t uh it's going to be testing T and then I'm going to say for example uh that the S is going to be a new store we need options and options going to be store options yeah and the transform Funk uh let's make a default one for Now default pad transform Funk going to be a funk of key string to a string and we going to return actually let's let's make it let's make it clean what's going on let's make it clean we're going to say return the key very simple uh thing that's going to be a v yeah and you could say default pad transform Funk which is all good and we going to say the Ops here and then we have a stor what going on here all right yes so we have this Pat name and then we could say something like s uh pad transform Funk dis key right and then we have a pad name let's return no let's bring it up higher and then we going to say something like um the file and the error is going to be OS actually we need to make um if s is going to be OS mad and I think we need to do all especially uh for our content addressable Shenanigans we're going to mcut all the key no the pat name like this you're going to say if add is not n I'm going to return the Eros what does madol do a file name I think it's I'm not quite sure with this file name is file permissions We Will We Will um figure that out I think it's more the perm not quite sure so we're going to make all the folders We we are needed and you will see you will see why uh and then we're going to say now we need a file name actually and the file name for now is going to be the key we can't let's say it's some file name uh we don't care for now we're going to fix this because we're going to use uh some tricks we're going to make a hash of the contents right we're going to make a hash and that's going to be the file name inside of that Pat name folder that's pretty neat you will see thought about this last night then we going to actually say here um f is going to be OS uh open you're going to open the file I think it's the PAAD name plus slash uh the file name like this and I'm going to say if there is an error we're going to return the errors then we have a file and then we're going to say if I think it's n n add is going to be IO copy for streaming for streaming copy right because IO copy let me quick I will show you um you're going to stream this right you're going to not you will see I I copy we're going to say copy the file with the reader and if there is an error we going to say return the F maybe we should do an fmt or maybe a lock uh print F I'm going to say uh written per D bytes to dis like this and that should be good M we could do something like this right um you're going to say Pat and file name is going to be it's going to be the bat name plus it's going to be this this thing that we did and then the file name right and then we could say bad and file name that's not true this one Pat and file name did I make a mistake bad n what's OS open actually just a name right oh yeah let's see what's going on here like this I could do something like percentage s and maybe do the pattern file name all right um yes let's test this real quick so we're going to say and now we're going to make our transform F and make it beautiful so we have this s is going to be a new store Ops yes we going to say um let's say we want to store something right let's say we want to store s right stream let's make a key uh let's say it's going to be my special picture right could be a special picture and I'm going to say this need to be a reader right let's let's say data is going to be bytes new reader and we going to say uh bytes some GP some GP bytes right it's it doesn't matter it's bytes but right so we're going to say it's going to be some gpeg right uh and then we're going to say data and then we're going to say if actually we should use uh testify to be honest but hey we're going to say t eror and then the add like this and then yeah I think that's good enough uh to test can I do make test real quick no such file or directory um what are we making we need to make create file maybe we need to do us create that could also be a case hey make test yes so you can see written 14 bytes to dis and this is our uh location right my special picture some file name let's open up B I mean b let's open up you see it's my special picture the folder and now we have our file name right which is good uh can let's keep it there of course we're also going to do a configuration where we can set the root of the of the file system and blah blah blah blah blah yada y y right so all right so let's make a let's make a nice uh transform function uh we we're going to test this real quick here we're going to say funk test uh pad transform Funk I'm going to say t uh testing T and we going to make this let's make it at the top I know we're going to split things out as usual right we're going to we're going to make things beautiful as as later on uh let's make it how can I call this let's make it C uh C control add ible bat transform Funk and we're going to take in a a key which is a string we're going to return a string all right and this is the magic you will see this is going to be so cool uh so we're going to say fun funk all right so we're going to take a sha one or an nd5 it doesn't matter I'm going to take a sh one because we will have more bites uh we're going to have a longer a longer a longer thing because I think md5 let me open up md5 md5 um Su yeah what's md5 size we don't know I think it's 20 or 16 I don't know I forgot so guess controlable pad transform funk how we going to do this um first of all let's let's let's hash this thing so we're going to say that the hash is going to be sha one sum of the key right can we not do this we need to have byes right uh bites of the key then we have a hash then we're going to say that the hash string is going to be hex because now we have bytes right you're going to say hex and code to string to string and it's going to be the hash right uh what what's going on oh this will what does it return hash I think hash returns a 20 yes 20 by and of course uh and go to string a slice so we can convert this to slice by doing this a very neat trick by the way guys uh if you want to convert a fixed uh let's say you have a a 20 byte right and you want to convert this to a slice then you need to do this right easy trick because a lot of people are still using these Loops to uh convert it to to a slice which is okay but it's it's unnecessary right it's unnecessary performance waste of CPU U so we have this hash string and now we going to say something like the block size and that's going to be so we have 20 right let's say a or a pad block size let's say a block size of five and I'm going to say that the slice length and that's going to be I have no clue I think it's Len uh the hash string divided by the block size and then we going to say that the PS wait now I need to think this is going to be on the top of my head not um that's is going to be is it slice length yeah yeah yeah yeah it's this it's this it's slice length yeah yeah so pads wait so we could do yeah yeah yeah uh Pats is going to be make me a slice of uh slice of bytes I guess or even a slice of string actually and we going to say the slice L I'm going to premake it oh yeah and then we going to say Forge and I'm going to Loop through L pads I guess or even even you could say slice Len it doesn't really matter slice L is actually it's already a number right so what am I doing here uh like this now we going to say from to is going to be uh it's going to be I times block size I times block size plus block size and I'm going to say they're going to say Pat y equals the hash string look at this the hash string from two right and then we going to now we have this Pat and then we could say return strings join man this is is actually insane uh strings join uh strings join strings join strings join the the the the the pads can we do this actually we can't because we can we can we can strings joins pads and then we're going to join it with the slash right for the pad thingy yes let's try this let's try this we're going to say that um the pad the pat name from our key right so we're going to let's say we have a key right we're going to store for example um a bite it's going to be a string actually so we're going to say mom's best pictures mom best picture right and the pth name of that uh thing is going to be so we're going to each key is going to be transformed to a certain pad on disk mom's best picture and the pad name is going to be uh C pad transform we're going to give that key and then we're going to basically I don't know what it's going to be so so let's let's print it out uh fmt print Ln the pad name let let us run this you see this is our pad name right so we're going to make a folder this folder then inside this folder we're going to make this folder and inside this folder this this this so we're going to go in depth right so we're going to have a nice nice nice uh depth of folders for every 10 and uh yeah so we can store these things on disk that way and we could we we we we can change this up right it could be that we only have two depth or or a three depth or whatever but now we have a five depth which is good nice the question is how how are we going to test this um actually what we could do is um run this again I have no clue man I'm going to just copy this and I'm going to say uh if bad name it's not the best thing to do but hey if bad name uh is not this let me going to say t erors let say actually expected expected pad name you're going to say something like this let's let's yink it and paste it in here expected bad name I'm going to say Dem eror f t have this want this Bad Name expected bad name and we don't need to do this D by the way all right something like that something like that all right so we're going to say that the pad name is going to be transform Funk so we could do it's not going to be the default transform Funk we're going to say it's the gas pad transform fun and you can make your own transform funks and and and we can extend it with with whatever ever you want to you want to do you could do a git gtit type thing uh it doesn't matter right all right so the next thing we need to do is this file name this file name is not okay we want to have uh an md5 hash or something even a sha hash it doesn't really matter it needs to be hashed so and of course things are going to be encrypted I know but for now I think the problem is we have this reader right this reader so what we could do enable to Hash the contents of the reader the bytes of the reader right we need to read but we also need to read to to copy it to the file right we have the file we have our reader and we need to copy the reader into the file which will read and once the reader has been read it's it's done so enable to do that I think you're going to first Le into a buffer so we're going to say buffer is going to be a new byes buffer right it's very interesting actually because we do a lot of this uh networking stuff and now we are doing these these these um file reading Shenanigans which is nice right and now we going to say I'm going to say IO copy and we going to copy this reader into a buffer and then we going to say something like that the file name itself the file name bytes is going to be md5 the sum of the buff um bytes like this now going to say that the file name it's going to be a hex and code to string of the file name bytes then we can do this patn file name thingy then we're going to create it and of course this reader is already already uh we can do anything with it so we're going to say can we do buff that would be nice that would be nice is it going to work yes look at this so so now we're going to see right let's open up our folder so we're going to say this one and inside this folder we have this structure this structure this structure 1 2 3 4 5 6 7 why do we have so much yeah it's it's normally it's because yeah yeah is it yeah so we have these nested folders right I think it's okay let me it's D and this one this one this one this one and then we have this file which is jumz so we are storing this on dis already it's nice nice look at these folders I like it I like it and if we want to read it's the same principle we we know exactly we transform the key we want to read and it will be wait wait we have a trouble we cannot we can we cannot transform it like that because how do we read something if we read it we need to no no no we can't we can't we made a mistake uh let's close this up we cannot do this file invites I think uh that's not true because right now we are storing let's let's make um I think we need you you know what I'm going right because if we want to read a key and we have our key but we don't know what's inside most of the time so if we want to have the full pth we need to have the bites of the thing we want to read the the content of the data so we can hatch to know its file name but that's that's impossible right to get something so let's I have an idea I have an idea we're going to say something like something like a type uh a pad key going to be a strict and a pad key is going to hold the pad the pth name which is going to be a string but also the original is it the thing original key Maybe original original is good so the spad transform Funk could return a pad key why we going to return a pad key and I'm we going to say that the um we could say return me a pad key and the pad key is going to have the um the pad name and the pad name is Going to Be Strings it's I'm going to just going to type it out again uh strings join this thing that we did right we're going to say pad and then we're going to join it with this and then we're going to say that the original is going to be the hash string right like this uh expected Pat name and I'm going to say expected Pat expected original or Ori key uh and that's going to maybe the pad key but without these things right I'm making so or G no man I cannot type original so then we going to say bad key here now we going to say the pad key uh Pat name is going to be this right and then we could actually copy this again paste it then I'm going to say pad key original should be the expected pad name it's going to be Pat name original what's going on with your original key no it's going to be expected original key yes is this going to work work yeah of course we have some issues I understand so we're going to say that the pad key can I make this like this or this I don't care and then we going to say make everything it's going to be the pad key Bad Name Bad Name wait we don't need this we can we don't need to copy this actually we can uh I think I think we Pat and file is going to be the pad key uh this and then we going to say actually what we could do look at this let's do it like this I don't know what what I'm doing actually uh bad name yeah of course we have some issues in our test uh like this and then we going to see what's going on here what's going on oh it's the yeah it's true what's going on unnown field pad name and we going to we can make a function right we can say uh Funk uh we could say pad key and let's say file name yes file name is going to return a string and we could just return uh like this we could say return and we can make it clean we could say fmt s Sprints s and we could say it's going to be percentage s/ percentage s and that's it and I'm going to say ppad name p original s print what's going on F yes that's the file name so we're going to make the pad name the patn file name only thing we need actually we could do it that's going to be pad key file name right and instead of copying this BFF we can copy the add right I think that's going to going to be some uh there going to be something I think we are at a good track Let's test the storage yes so we are written to dis this whole shebang right so now you can see that we make these folders right and the file name is going to be the path name but then laid out so then we can find it but then we can retrieve it right all right so what I want to test um is basically uh reading so let's make something like Funk s store let me let me move it up here Funk s store I'm we going to say uh read stream a key which is a string and it's going to return us that's a good question are you reader it it it's sounds weird but and an error maybe uh because we're going to W these functions right so now read stream right stream is going to be internal functions but we're going to wrap them with read right and and and easy easy API to use um right so we're going to say that the pad key we're going to say the same thing right the pad key is going to be Asad transform fun of the key right and we going to say that the file name or the full PAAD actually maybe uh the full PAAD is going to be actually can we I think we're going to say OS open and we're going to say it's going to be an f file and an error it's OS open and I think you're going to say the pad key uh file name no it's file name it's I don't like this file name thing because where is Pat key file name the pat name the original I don't like original uh this is going to be file name we're going to refector this uh and I'm going to say this is going to be the full pad the pat P name and this the file name will give us the full pad is that is that correct uh leave some comments if you think I'm I'm wrong if if you think we can do this better because hey so the full pad is going to be the pad name with the file name because this is the file name right I mean it's clear as that of course that's we're going to bat name original is going to be the file name yes full pad of course we have some issues here uh and here let's make it full pad and of course here also uh going to be full pad yes and then we're going to say here pad key full pad that's we're going to that's we're going to open if there is an error we're going to return can we return n as a yeah we can we're going to return no Ed then we have a file the question is we can we can um what do we want to return if we want to do a read stream that's a good question I think file is is a reader right file as a reader H but I think we need to this read stream because we're going to do decryption and stuff decryption needs to happen on the client side I think which happens right well I mean we're going to get um this is a hard one is file reader that's a question let me I think so right yeah yeah it needs to be yeah we can of course we need to close these files right that's a thing so the problem is with we reading we're reading a file from this but we need to make sure we close this so I don't think it's going to be a reader but a read closer which basically means we can just do this return the whole sh bang but that doesn't make any sense but then we can wrap this in a function and we could say for example s store and uh just read read the key is a string and then what we could do here is um H we could bites or a reader not quite sure guys what we need to do here there are a lot of options uh to be honest so we could say for example Del stream this Str this key we return n n right and then we could say uh we going make a buffer new bites buffer h you're going to say I copy F buff no buff F and I'm going to say f close and then we're going to return the buff no actually what you could do is let's do this let's going on what did I do let defered heat F close should I do it like this actually I think it's fine uh I think it's fine we can say defer I'm we going to say add and then we going to return add right doesn't does it huh what what what happens here written add right oh yeah new new variables yeah I see um yeah yeah it's fine it's fine is that a thing Let's test this right so let's let's put it up higher so we're going to say here data we're going to read uh what is this my special picture let's make a key I'm going to say the key uh what's going on there going to be mom specials you're going to read the key these are the bytes these are the data right this is a new store like we're going to write this and then we're going to read this right then we're going to say uh that the s s is going to be S read uh we're going to read the key we going to say if s is not nil the error right T eror um now we have this reader right and and I think it's important to return a read because then you are then you are flexible then then we are flexible if you just return the btes I think it was important to to close the file so we don't need to do that the users well we don't need to do that later on but a reader is important to have so we're going to say uh R is going to be we're going to say that the B going to be IO till read all R uh if R is do we need this and we're going to say um wait what you could do is instead of doing we're going to say this is going to be bites like this and we're going to say this is going to be a bite uh new reader here my mic is constantly doing stuff it doesn't need to do hey anyway it is what it is um yes we're going to do it like this because then we're going to read this bites and then we could say if uh B is not equal to the data right that we that we put in you're going to say t add F you're going to say want this can we do s I think so have uh this we want data we have B what's going on what B is not data damn it's it's I see well what you could do is this right you could say string B string data is that a thing yeah look at this it just work it just working so because we could say fmt print uh print Ln and we could say string uh B right so you could see what we readed right some geg bites it's fine it's working yay all right so help me what's going on here we can read of course I think we need to do some more stuff in here but hey it's fine for now um and I'm thinking my special picture so we have these cool St oh we have what the hell is going on here the of course if you store the same file again this is weird Behavior well so it's going to Hash but why is it the same pad and not the same thing ah see yeah of course it's it's hashing the same pad uh we do an md5 no we don't anyway uh doesn't matter we will fix that uh we will see what what is this uh how how that happens it doesn't really matter because it's the same file the question about the is what what do we need to do when we are storing the same file once again so we we're going to fix that all later on uh the basics first actually we should we should um let's make a delete function so we can actually clean up our test otherwise if we run the test we will have these folders sitting around right um we have read here let's make a delete if you really want to delete something right uh we're going to say delete we're going to delete a key we're going to return an error and the first thing we're going to do like usual is make our pad key that's going to be S transform Funk with the key and I think we need to do H let's do F actually do we need to stat this to be honest because can we not do something like OS remove removes the name the named file or empty that Dory if there is an error and what's remove all removes remove all removes pad and children contains it removes everything it can but Returns the first okay see maybe I think I remove all and it's going to be the pad key full pad like this uh let's return the OS of course this we can actually just return this unless we want to lock and even then uh even then but we like I said this is very very early I think we're going to add much more to this later on in these things right especially if you want to work with a cach and everything so I'm going to Implement a cach and if you want to work with a cache we need to bust the cach and if you delete and blah blah blah and all that good stuff right so that's why this function will be bigger we can actually make a deferred funk I could say something like this right or or this uh it's going to be pad key full pad maybe actually file name maybe right this is going to work no idea um can make this test right you could say funk test delete going to be a t testing. t um could copy this let's write it let's write Mom special key uh and let's then say uh if s is as delete key the error F not not error F uh let's make another function actually has key we need to make this pad Keys all the time right we need to make this transform funks uh all the time let's going on I think it could do something like um file information is OS stat uh the key no not the key the pad uh full pad what am I doing here with this capital P full pad uh we're going to do with this AR has do we care about this look look at this what we're going to do is if add not n going to return false is that a thing actually should we do this so let's say if we have and we and we are trying to stat something and we get an error in stating I'm going to turn false you know what I mean it's it's uh then we going to say um how can stat actually turn n anyway wait maybe let me let me see what stat does stat Returns the file info describing the the file name if there is an error it will be bad error it's a bad AR right because we don't get this file info right uh is not exist buting whenever the is know report directly exit Cod should use FS uh FS a not exist is that a thing I don't exist man this is this is crazy huh if F what is this should use return R is not equal resist instead of if why because if the error is the file not exist then we return files right because we don't have the file then I don't understand am I am I stupid maybe baby man let me clean up these folders real quick actually do we have we have no Shenanigans right so basically what I'm going to do is I'm going to test store delete key I'm going to store this key and I'm going to delete this key so I'm going to run this test and then is see delete it from disk but the problem is this they're still here but the file is gone the file is gone the file is gone but the the folder is still there oh man so what do we do do we remove these folders also or or what is this I thought I thought remove all I really I really I really thought remov all would remove the whole shebang not going to lie what what happens if you do remove all the pad key and we say we're going to remove the pad key pad name what's going to happen then if you do this again as the this boom that's that's that's that's crazy it's deleting that's for sure remove removes the named file remove remove bad and any children it contains oh but ah man why is it not working the bat name Pat that's crazy that's crazy uh I was really really really assuming that o REM move off would delete the whole She Bang but apparently it isn't uh let me think then we could do two times right we could do but that doesn't make any sense oh oh but that's it's full pet full pet yeah full pad right so we're deleting the full pad so I don't know I don't know I don't know why this is not going to work to be honest why does vs code not yes boom so we deleted this file name yeah I understand it's gone I completely agree H weird Behavior Uh so let's do something like I'm not quite sure if this the right approach to be honest but hey now return we're going to say patk full Pat Uh we're going to say yeah no not the full pad this is going to be then the the the the pad name right pad name it should delete everything it is what it is I don't understand um let's let's open up let's remove this folder once again now right and let's do this again all right now now everything's no what's going on you know what you you you know what we're going to do what is this man is is this window Shenanigans what we going to do is um we're going to say pad key make a new function you're going to say p bad key first pad name and that's going to be it's going to return a string and we're going to say um return strings split thep pad name and we going to split it with this and we're going to return the first all right and we're going to say we're going to double check because we are doing a ray so let's do pads like this uh we're going to say let's make it actually good right because um people going to roast me so we're going to say this this is going to be the pads right I'm going to say if Len uh pads if if if l p is zero right I'm we going to say um we could Panic here because if we want a first pet name and it's zero but let's return nothing it doesn't matter I mean you could say yeah Pat name needs to return a string and an error but you could man if you could yeah yeah I know but still I'm not I'm not I'm very I'm a big fan of errors and handling errors very important but these things if you are trying to get the first Pat name but the you cannot make a pat name something is terribly wrong in your system in my opinion something to think about you could say return now we're going to return the pads zero right the first one right so instead of doing this where is M remove delete here let me try something real quick let me comment this out we're going to say remove everything but we're going to say pad key the first pad name okay delete Perman do it again hey you see now it's working ha so can we actually do the complete test actually uh let's let's do it test Le key yeah yeah yeah so we're going to do do our test here read everything and we're going to test this and then we're going to basically just say um as delete key yes it's working yeah baby uh yes of course we also want to basically for our test if you want to do a complete tear down where we delete everything we just stored we need to uh implement the root of the storage we need to know where the root of the storage is and um once we know that then then we can just delete the the delete the complete roote uh basically so we could actually say should we make a function clear not quite sure but anyway um let's open up store and store test real quick and uh what we already can do is save things we're going to make these folders uh based on the key right based on the key we're going to transform that key and then we are going to create some some pad to the file right uh content addressable but the problem is there is no way to specify a root right we cannot just store that randomly on disk we need to have a root that contains the whole shebang so how we want to do this uh is basically a couple things actually because I was I was uh inspecting this code base and um we made a a mistake well not a mistake we forgot something so we have this let me put out of the way this uh cursor so we have this default Pat transform fun which is basically the default uh and we have no way to basically uh add default values right so we could do something like here new store and we could say like if the Ops uh the pad transform Funk is nil then we could actually say that the Ops pad transform Funk is the default pad transform fun but that's not going to work because we changed this interface uh let's go up top we changed where where is the thing this pad transform fun is basically takes a string and and returns a pad key but we are returning a string still in this transform fun so we need to say it's going to be a pad key and that's going to be that's going to return uh that's going to return a pad key and I think because it's the default function we can say that the pad name is going to be the key and then the file name can also be the key why not right so that's going to that's going to work perfectly fine the next thing I want to do is basically add a root in the store UPS which is going to be a string it's going to be uh root we can say root is the uh folder name of the root of the root containing containing all the files maybe folders uh files of the system like this and then we could say something here right we could say if the op actually we could say uh let's let's make a constant we're going to say default uh root folder name or something I don't know and we could say it's going to be GG wait my my keys my it's still it's back to International and it needs to be us keyboard layout otherwise uh my quotes are up we're going to say GG Network like this and then we could say something here if opt root actually we could say if the length of the Ops root equals zero that's how I that's basically how I check if strings are zero you could to basically like this right is the same thing if Ops root equals uh this right but I don't like it for some reason I don't like it so I'm always doing if Len of the string is zero then we could say that the op root is going to be the default uh default root folder name of course now the whole system is is broken right because we have um what is this we can delete it I guess because if we want to write uh so we're going to say Pat key and then we going to M the bang right the the pad name of the pad key the problem is we need to append I not append preent we need to preent the root name to this so actually it could be something like uh s Roots like this but that's that's a nasty way to do that I know right is I just want to test this real quick let me open up my folders and let's uh run test here right it's not going to work um why why is it panicking actually I don't understand now basically it's it's tried to open uh it's try to open that shenan it's a right stream it's maybe because we're also doing read streams here let's let's uh Delete so we're going to WR stream here we already have these uh these complete folders here that's fine so something is working all right let let us test uh just writing right that's going to fail uh that's going to fail it's the full pad yeah yeah yeah I see I see what's going on so we basically do this m all with the root and then we making a full pad and then we are going to create but the full pad also needs to be the root uh plus the full pad right let me delete this folder once again and let's run this again right now it's it's going to work perfectly fine so we have our root and then we have our file here which is some gpeg bytes so that's already a good start um okay so how can we make this cleaner with this root thingy let me close this bites thingy I'm tired it's still early and I'm trying to do this as raw as possible right no no no no prerecorded Shenanigans so wait what is this pad name and then we have the full pad with which is basically the pad with the file name and this is going to be uh the pad key pth name which is going to be the pth without the file name what we could do is make a transform fun with the root do we want that I don't think so or we could do something like pad key uh something like pad key root or something and then say that's going to be the S root but I don't like it I don't like that so what we could do is basically you can keep it like this I'm also thinking maybe should do a pad transform fun with the key and the root or something like this but that's then it's not a separation of concerns right I want to have this function as pure as possible uh so what we could do to make it a little bit cleaner is basically uh it's going to be the pad name with root and that's going to be an fmt S print F yeah as print uh F yeah like this we're going to say percentage s/ percentage s and then we're going to say it's going to be the S root and the pad key uh is going to be the pth name I guess bad name yeah like this right it's already a little bit cleaner we're going to say pad name with root then we have this full pad and then we we could say the same thing like full pad with the root right and let's just uh let us copy this bad boy but that's not going to be the pad key pad name it's going to be the full pad right actually yeah then we can say full pad with root full pad with root and then this is going to be we written to B we written to the dis and it's going to be the full pad with the root is that a thing I don't know let's delete this and let's run it again it's all working as expected that's perfectly Gucci so let's Del it again I think what I'm going to do is make the delete function uh right now because then we don't need to do it manually but let's make this test work first right so then we're going to read we're going to read the key we're going to read the key actually so that basically means we need to fix it what's what's what's going on with right stream test it doesn't detect it's telling me probably that it's not getting used although we're using it in our test but a and this thing uh this can be different we could do if erors uh is s o not exist is the same thing right so if if if it's not existing then we return false otherwise return true uh read read read read read where is read what's going on here like this should be fine uh where is read here so we're going to do a read stream is this one we're going to say that the pad key is uh transform fun with the key and then we're going to say read me the full pad that's not true we're going to say that the pad key uh with root is going to be an fmts actually what we could do is um it's fine I mean we could we could make these things like I said in an application you can keep making things even better and better and easier to to use but hey uh percentage s/ percentage s and it's going to be the S root and then with the bad key like this and then we could say open me the pad key with root right is that I think it's going to be the full p with root to be honest it's going to be a reading that should actually work I think it isn't I see what's going on what's it doing here oh yeah I do the key that's crazy uh full Pat right yeah so we have written um 14 bytes to dis that's fine the question is why don't we do we print that out we don't we could we could try right you could try if if you're actually reading this thing uh print f yeah it's gonna it's it's it's working fine because we say want F so that's fine right but hey if you want to see it on the screen we could do string B uh and run this thing again what's going on here print F you could CH print alen uh and do this boom some gpeg bite working working as intended that's good and then we're going to say delete key the question is is is this going to work probably not we we need to do some changes so let's open up delete it's above here so we're going to say uh pad key pad key the file name but we're going to remove the first pad name that's actually that's fine right so we could say first pad name uh with root which is going to be an fmts print uh F same Shenanigans percent s/ percent s and it's going to be the S root and the pad key uh first pad let's just type it out instead of typ hint then and then we're going to delete uh everything inside this we're going to say the first bad name and let's type it out again with root sometimes it's fine to not rely on your typ hinting I'm so sorry spell Rusty and I'm going to delete this the question is what what what is it going to delete it's going to delete the whole shebang uh let's see right so we have this thing I'm going to do run test it's hey look at this it's working perfectly fine yes that's already a good start sometimes things go like it should be that's great that's clean that's clean that's clean Let's uh do we need to have something else we have delete has has has has has has key where is Hy a hasy h uh we're going to do this uh transform Funk we're going to see if the stat to the full pad uh I need to say full pad with root right uh full pad with root and that's going to be again again I know I know uh s print F uh percentage s/ percentage s is going to be S uh roots and the pad key uh it's going to be the full pad I guess yeah so a function actually is it yeah yeah yeah and I'm going to say that the full pad with root is going to be this how do we test this has thingy that's delete um well let's just test everything in uh let's do it here right you could say um if okay s has uh the key and it's okay it's not okay actually what we uh what we're going to do is this right actually no if it's not okay it should have it right so we could say if not okay and we could say the errors F uh you could say expect it to have key key noise man sometimes and like I said this chair I need a new chair it's my back hurts everything hurts it's just a simple uh living living room chair you know where you just eat and and dip and dip them but I'm sitting here for for hours and hours it's it's crazy and I'm an old man and I need to have a I don't know so yeah uh this is this is nice what I'm going to do is real quick I'm going to say get at and then I'm going to do a get uh command M uh added roots to the store maybe going to say added root option to maybe store Ops like this Gucci Gucci and once again for the people that are uh patreons thank you for the support of course like usual thank you thank you very much if you're not in the Discord uh DM me or or DM me on patreon or something and I will give you the correct role in Discord right you get a better role so we have our private you can join the private channels uh where I'm basically continue continue helping people out right um so do that let me know if you are not if you don't have the correct uh role yet and I will happy to give you an exclusive status the stat of the status of the high value engineer software engineer which you are or you're going to become yes so that's fine what do we need more actually what I want to do in these um in these tests actually is make maybe make a tier down or maybe make uh some helper functions for example uh we could say new actually new store we're going to say testing do we need a testing I don't think we need actually um yeah we going to we going to some helper functions for us test it it will it will make uh our life easier what's going on here a store uh we could say return actually let's do this copy this do we want a root we don't want to I think GG is fine G G network is fine the default one so we're going to make our cast uh transform thingy and then we can actually just uh return this new store let's make a function uh it's going to be tear down and what do we want with tear down actually H um do we want testing T I think testing T and maybe the store itself not quite sure actually wait in a we need to delete everything do I have coffee actually yes lucky well this is basically a once in a lifetime opportunity that I have coffee available when I when I didn't expect it so we're going to do a tear down function how can we actually remove uh the whole She Bang uh I think we could do something like if R is going to be OS where do we do this uh remove all actually we should make a function like uh for example F store and then the store one then I think the store is basically complete we can store things we maybe need to come back to add or cash and everything but hey the next thing is to couple this on a on a on our Network so we can store things and then distributed that's that's the that's where the magic is going to happen uh but this needs to happen also right so we're going to a clear function right not quite sure what it's going to do will probably return an error uh we're going to say remove all and I think we could do something like s root uh and actually do return isn't that amazing is that a thing uh if add is going to be as clear and the error is not n and we going to actually D error s is that a thing let's let's try this real quick um so we don't need the stuff what we could say here is basically say s is going to be a new store like this and we going to say defer as tear down clear clear clear no tear down tear down help tear down DS is that a thing I'm not sure let's try yes you see now GG network is completely gone and now we can keep running these tests right okay of course it's it's it's getting cashed right it's getting cashed uh maybe we going to make a new key Fu and bar uh it's getting cached so let's change this so the cach can be busted here you see and everything is working perfectly fine and we don't have any relics in our folders uh from the test which is nice uh and the reason why we pass tear down in test uh where we pass testing. TNT damage basically so because clear can return an eror and then we can assert it and uh it's all fine and to be honest we could move these the shenanigans completely at the bottom of the file and because they're just helpers right so how do we need to test actually a little bit better this uh test store what we could do is um we could do we could do this right we could make a for Loop and we place everything in this for Loop right oh I'm I'm I'm itching what is this Fu and bar thingy wait wait wait wait I made a mistake I guess uh so this is a for Loop for Loop for Loop we're writing these btes where is our key we don't have a key what the hell is going on okay key is gone but it's no problem uh because we're going to make a new key we're going to say that the key is going to be fmts uh print F and that's going to be let's make this Fu underscore uh d which is going to be the Y right so we have count was count how many times we going to do this you can test this uh 50 times right then we're going to make some data we're going to say some geg bytes we could make some function for random bites but hey doesn't really matters uh I'm going to make a new key does it matter actually that we have a different file size I don't think so so now we can actually do this uh completely the same time you're going to write to dis 50 times and um with different Keys you see and it's it's it's all different keys right here 14 bytes I know what's going on here stop vs code yeah fine and we have no relics in our folder which is fine so we're basically testing uh writing we're testing has we're testing read and we're testing delete at the same time but if we delete um we need to assert we need to make our test pinpoint precise right pinpoint perfect we're going to say uh a not nil and we going to T error uh this error that we returning and then we need to say to make this actually perfectly fine then we need to try to see if we have a key um and then we're going to say if it's okay right if we have the key expect it to not have that key right because we just deleted every 10 right uh and we're going to do this 50 times so that basically means we're testing every 10 uh we have so we don't need to test this delete because we already testing this and we don't need yeah that's fine test store a new store tear down I think this is perfectly fine we're testing in one test we're testing the whole She Bang 50 times with different keys so we could do make test is going to fail because we have um an error in in in our uh TCP at somewhere so test that's failing boom right and I think the tests are are perfectly working yes Gucci do we have in our make file actually we have verbos on I'm going to delete verbos in make file so if we test make test right then we don't oh yeah it's printing anyway my ask see why it's make R yeah I see I see uh make t actually anyway uh why why actually why is it failing it's uh in peer top what what's going on uh TCP transport test or something what's going on help help yeah what's going on here uh don't test this it's going to that's working fine who why do we have tests we have transport test handshake store test why is it failing that's that's insane make test what's going on fail ah it's the pad transform thing that's feeling that's weird that's weird um that's that's weird store test this this is failing you see uh we want this who this is the exact same thing what's going on here um wait if the pat name and file name is not the expected uh file name wait wait wait wait wait wait wait what's going on here what's going on here half wait let in N vs code we can actually hover my mouse is broken you see if you hover this then you see on the other side that it's basically mimicking the same you see it's the same thing so we have this but we want this but it's the same thing so store test is going to be why why are we doing this not equal it's 19 line number 19 what's going on it's this one uh if the pat name file name the pad key file name is not the expected file name but they are the exacted file name wait this is not correct right because they expected the pat key file name that's not this one right the file name is the expected original key this is expected file name this is the expected file name and this is the expected path name right so this should be equal and the file name should be uh the expected um file name right and I'm going to say here uh expected uh file name that should be right all right I remember that we that we changed some stuff up so that could that could be the issue uh okay yeah I think I think this is fine so we can write stuff we can read stuff we can delete stuff we can clear the whole shebang we can test if we have a key I think this is uh a very good start to swap back to our um server this SW back to our server and then we can attach this storage there store a file and then we going to basically replicate it to to to all our other uh notes in the network and we're going to do some encryption and we're going to see uh what what we need to do so hey we at a good part somebody from the community uh noticed something um not quite sure if you remember but we had this uh weird warning on uh eror is somewhere I think in has in the has key yeah here uh although the warning is is is uh already fixed uh I think we can make this even better right instead of doing error is and check if it's false blah blah blah we can actually uh do this and return this directly what's going on like this right uh actually return this like this and that should work perfectly fine let's do make run test actually yes perfectly fine the next thing I also want to do is make uh an exposure of uh the right stream because we have this right stream here and I want to expose this as a private uh function so we're going to say instead of making this uh because I think we're gonna we're gonna do some more stuff in it uh later on but for now I'm going to expose it as a simple right uh store we're going to just say write which will take in a key which is a string and also take in an IO reader we will return an error and then we can actually just say uh return me as right stream with the key what's going on here key and R like this and it will all work fine the next thing I want to do is start creating our server uh new file we could call it file server or server I don't think it really matters um let's call it server package main rather we're going to say a type server which is going to be a structure we're going to have uh wait let's make some options right server options it's going to be a strict also we need a listen Adder uh for our transport right uh because we need to embed our peer topeer lip into the server thingy so we going to say let's call it file server file server UPS let's now there's going to be a string we also need a pack uh a storage rout Right Storage root it's going to be a string also and of course some uh we also need a private key and and all that stuff um not quite sure we need to implement that because we going to encrypt right we're going to encrypt uh probably uh some some stuff or maybe an encryption key doesn't need to be a private key we will see we will see storage root uh file server um h we can say file server opt right here new file server it's going to return a file server we could actually say something like uh return and file server I we need a store that's that's what we need a store which is going to be a pointer to this thing store we just created right and then we going to say that the store is going to be I think a new store if I remember correctly it's going to be the file server Ops and then we could say here that it's going to be the opt storage route what's going on in new store actually what's going on uh store pad transform fun that's the thing uh are we goingon to yeah yeah yeah I see I see see see see see so what a I think we should it's going to be a pad transform thing to be honest because we need to we need to pipe in we need to aggregate all these options I think uh yeah yeah we can no no no I see I see what's going on I see what is going on uh I think this going to be the store Ops we need to make the store Ops right it's going to be a store Ops like this and then we're going to say at the storage route is going to be Ops storage route and the bad transform fun is going to be the Ops bad transform fun right it's not going to be it's going to be the root here I that I think yeah yeah yeah and then we're going to inject these stor Ops into this uh new St stingy that's fine and of course we're going to the file server Ops going to be the Ops here and then we need something like a function run uh it's going to be we could say FS but uh s is fine I'm going to say file server Ops it's going to be a run or maybe start actually don't like run let's put it higher on the screen I think we also need a uh TCP transport which is going to be a transport I think it's going to be an interface we could say transport going to be a peertopeer transport is that in the configuration all right so how do we run this transport by the way um right we only have this interface only to listen and accept um where is listen and accept it returns an error so we already know that start can return this error and we could say that uh if R is going to be S transport uh listen and accept and the error is not going to be nil here then we going to return the errors right away is this blocking it isn't so it's going to start this accept Loop which is fine which is perfectly fine uh let's let's do quickly return null let's go to main to see how we can uh make this work all right so we have this TCP transport Ops right the question rather is are we going to pipe everything into file server options probably we do because we're going to configure this complete server which then will spread out this configuration to the other ones I think that's the way to go so we're going to have a transport uh or maybe we can just say that the transport options it's TCP transport options that's nasty because Yik uh TCP transport Ops uh transport Ops like this right um yes this be transport UPS that's a f wa I'm thinking right so then we need to specify actually no no no no no no no no no no no no no no no no we're not going to do this uh we're going to say transport and we're going to yeah I see look what we're going to do uh let's clear everything here on peer let's let's that's what we need we need an on PE but we're going to say like this we're going to say that the fs no let's say s because otherwise we can um it's going to be a new server file server by the way uh we need to take options we're going to say the F uh s file server options it's going to be it's going to be a file server options right what do we need we need a listen address which is going to be let's say the classic one 3,000 one of my favorite ports at all times uh the storage route we're going to say storage root is going to be it's pretty important because we're going to say 3,000 of files the reason or Network I don't know man uh the reason why we're going to do this because we're going to boot up multiple notes right to see if they are um replicating their their their state right because everybody needs to have that that uh that thing everybody needs to have the storage the same the terministic storage uh so we can make 3,000 Network 4,000 Network and all that stuff so we can see that otherwise it will store everything on our on our disc right if it makes a lot of sense uh then we're going to say the pad transform fun we're going to say it's just going to be a gas a default one we can make as much as we want but we already have a cast and I like it you can Implement whatever you want it does not need to be exactly that uh content addressable storage uh and then we're going to say transport right so the transport is going to be a TCP transport and we can make it like this we could say TCP transport is going to be a peertopeer new a TCP transport like this and we need to give it up so we're going to say TCP transport actually well man it's fine we're going to say TCP transport Ops and it's going to be a peertopeer TCP Ops what do we need let me open up TCP the other side real quick for the options uh transport Ops we need handshake Funk decoder and on P I don't like to specify all that Shenanigans I think we need to have some defaults do we have that do we check that decoder decode um damn damn damn damn damn do we have decoding and coding I hope the yeah I see a c uh not quite sure let's say uh listen add is actually so we don't need a listen address here man this is going to be nasty listen we don't need this back to TCP transport options we need a handshake Funk we can we do no uh peer to peer I saw it already Yes a not handshake fun because we for now we don't need one and then we going to say the Cod you see how how cool it is that we can actually control all these things uh of course we only need to specify it once but it's nice to have these interfaces and these functions so we can make our program uh much more generic and testable although this decoder is also an interface but we're going to say this is going to be a p to Pi we oh we have a default decoder look at this man man man we are literally gods look at this we have a default decoder and then an onp function we need that onp function but not for now uh we could say to do uh oner Funk like this and then we can say it's going to be the TCP transport Ops that's our TCP transport and then we can say in our transport which is going to be an interface but TCP transport implements that we could do this then we say file server opts and then we say s start going to return an error so we could say if uh f is going to be this starty thingy and the error is not nil uh we can actually uh I let's just look fail out here because it's just testing you're just architecting stuff uh of course if you make run I think uh the problem is with make run that that we will We let's block here real quick uh like this okay the problem is we don't see anything happening so I think we should have some default and the birds are basically eating breadcrumbs outside it's nice to see but they are distracting me because they're with a lot uh so some logging I think in transport uh wouldn't be too bad right here we're going to say go accept and we could here do a simple login actually maybe a log or something uh print Ln or NF actually you could say um uh TCP server actually transport maybe DCP transport listening actually listen uh listening on Port and then we could say uh percent s and then maybe a new line actually and then we're going to say here uh T listen add listen listen add yeah uh because this is uh yeah yeah it's fine M you see so TCP transport listening on Port 3000 all good all set up um and I wish I could this this terminal on Windows basically you see that the difference between my fonts size and uh this terminal uh font size is is is different and I already looked it up and I I have this uh settings zoom level where is zoom level Zoom I think it's in in my other settings uh but I I'm going to plan re remake my config and actually uh Drive vs code to the Limit because you can you can basically do everything in vs code right you can hook into everything I'm goingon to make it completely uh myself completely minimalistic even more um performant as it is uh on my side so I will share that just just a side just a side I know this is forever store but hey I have no friends let me talk to you I cannot explain this to my girlfriend because she doesn't understand so talking to you you understand what I mean so that's nice all right let's go so yeah everything is running uh I want to uh that's our server so it's all fine wait I'm thinking uh we could do a couple things we could make this with with an HTTP which is fine but I'm going to make this as a terminal app right so we have our terminal and then we can basically um run it and then we can ex uh execute commands or something with it right we can execute commands with it and we can add files to the terminal and and replicate it store FM I don't know uh we can do a couple things but I'm thinking what the next step is do we need the Pierce we probably need them um let me quickly think about this to be honest how are we going to do this I think we should actually find a way to encrypt these files which is going to be a simple encryption that's going to be fine that's uh for another episode uh let's go to servers real quick so how are we going to use this we have our file server which basically will boot up and now we need to find a way to command this ST which could be directly no we can't the thing is file server right now and bet store but do we want to store a bet file server we don't so actually we give commands to the server right so we could say which does not mean that it needs to be over HTTP it could be we could say f file server uh file server you're going to say store or something store file I think store is good key string uh what how do we want to do this do we want to store bytes let me do this uh return s store right and we going to say key with the reader the thing is what we could do is basically have a channel for this thing a Channel with a reader and I probably should uh think thought about this a little bit more before I started this video I'm going to do this because otherwise we are losing a lot of time so just to to share my my thinking process here we have a storage which is just a simple thing that can store files on disk based on a transform fun and everything right then we're going to have a server and this is basically the server that will be running as a demon right and it will um receive me it it will receive messages it will um be in a distributed beer top Network so each if it's yeah I I I know I know I know I know I know what the next step is we need to have some um some messages to be honest instead of doing this store I know I know what the next step is my bad my bad so what we need to do is uh this server needs to have a loop going to be S uh file server was this file server up start this is not uh we're going to make a loop you're going to make a for select Lo by the way let's make it uh a quit Channel real quick quit channel is going to be a chen uh with only actually going to be a Channel of an empty strict like this I'm going to make a channel is that no we don't need to do this uh that's only when we actually want to close that and of course we're going to say case and I think we could do S transport don't we have that it's this right transport DCP transport what's going on transport yeah it's transport it's as transport uh it's consume I think that's the thing can we do this let's print the L real quick this message we made an error what's going on with this message expect it we we made a little mistake I guess and I cannot find where it is what's going on unexpected default unexpected case uh 36 oh yeah we need is it case man hey what am I doing what am I doing wake up uh FM fmt wake up my man yeah yeah it's yeah I know I know but we also going to have a case quitch and everything we going to say uh like this right I'm going to say Cas s you could return here whatever we could break here I like to break uh maybe we can do some defer functions here right defer so if we return that we can execute that defer functions or we can use um another loop and then we can break this other loop and then do do do our Shenanigans here or logic everything is fine nothing is wrong um it's it's what you what you want right how you how you want to do it it's going on why yes so we have the squit CH I think some some something what I'm always doing is uh make this squid function here uh wait this is Loop we can say funk as uh file server uh quit or stop I don't know maybe stop or something uh and then we could do something like um we could do this close s quitchen right all right uh so we have this Loop where are we going to loop I think at run right start you could say go actually we can block right we can block at start or we don't block at start that's a question are we going to I think it's always a good idea to block and then give the opportunity to the user to call this in a go routine because then he will have a quit Channel if he wants he can quit it if he wants uh yeah maybe yeah let's let's let's block for now not quite sure right and then we can do this right yeah so it's all fine it's Block in uh that's good that's good that's good and actually we could do um we can start it here and we can say go Funk like this and then we could say uh time sleep time second times I don't know 3 seconds or let's say three seconds and then we could say uh s quit like this stop actually what the hell s stop right is that a thing like this right not quite is going to work perfectly fine I think so yeah you see uh it stopped right because we we we closed our quit Channel um but there is we can actually do it like here and see that's why maybe let's let's do something different let's let's make it a defer fun here uh for that shenanigans uh user create action I don't know um files stop due to user quit action the the thing is because sometimes it can stop for for another reason I don't know maybe we can just uh do this do we need to close something I think we could we could clean something up uh maybe the transport I don't think we have a close thingy right in our transport you see we have uh listen accept and consume maybe what we need to have is something uh in our TCP actually let me open up TCP transport because it could be that we need to stop something right we have a listener right you see we have a listener so I think a good thing to have in our transport interface is a close right let's return an error because uh close and an error is always good and then we can go to TCP transport because we don't implement this we could say uh Funk D DCP transport close and we could say uh return T listener close do we need something else to close list listen what am I doing listener right transport interface look at this boys girls we are doing good stuff right so that's what I was saying in the beginning like okay we have this transport interface but we don't know yet what types of functions is going to be exposed what is going to be what's going to be needed although I don't want to have a a a whole complete Chang list of of uh interf uh functions on that interface because that's not a good practice then we can uh do do some uh composability uh if we want but I think what do we have now uh let let's open up transport real quick to check I think three functions I think three or four is the maximum I think maybe may I don't know three four five Max right uh so we can do we close stop we we and then here we do quit and then we have our defer fun we could say S transport close right like this and maybe we need to do more cleanup and ntcb transport like the p and everything that we will see make run and let's see if everything is going to be fine no errors or something okay we have because we say use of close network connection um that's fine we can fix that new incom connection yeah it's because we close that stuff we're going to say TCP transport because this is this keeps running right this keeps raining so that's bad so what we're going to do is uh we're going to accept here so if it's closed it's fine ah I see yeah yeah yeah so we're going to close it here right and then we say this and then we're going to handle yeah yeah yeah I see what's going on uh I think we need to do something like this right if we because we're closing it this listener I think it's fine but we're going to say here uh if errors once again uh if errors is is R is going to be I think it's um net R closed yeah you're going to return this function right that should that should actually fix fix your thing I think right so then then everything is nice and and and tidy cleaned up file serice stop to user interaction that's fine you see we don't have any errors it's uh The Listener is is being cleaned up we we uh fetch the error because yeah I think it's everything is fine uh what we need to do later is to see if we have if we have peers or something what how we going to clean that up right um because each Pier is a con connection and and right it's going to be he right uh so we need to check that later on if we have connections how we going to fix that yeah so I think uh I think in the next episode what we're going to do is basically try to connect and exchange messages so we can uh if if one stores we're going to try to connect with each other and then if one is storing uh we're going to have a list of bootstrap notes right that's always important that you have a list of bootp notes so we can connect to two or three people and then these people are going to give us their peers and and at the certain point of time we're going to connect to whatever uh maximum connections of 20 different notes or maybe 100 whatever we can configure um so they basically gossip and do peerc Discovery right but to make it simple in the beginning we're just going to have a simple list of of pred find boep noes we're going to connect to them and if we store a file uh we're going to broadcast that file to everybody else right uh that's what we we going to achieve in the next thingies then we're going to do some encryption and we're going to make it better and better and better right all right all right let's continue uh what I think is going to be episode eight of um forever store and um the previous episode I think uh well I think I'm pretty sure because I just made it uh we basically created or our file server uh and now we need to I want to connect a couple servers together uh or at least two and I think uh what we need in uh the file server Ops is basically a list of bootstrap nodes right uh boot TR noes which going to be a slice of string and what we're going to do then is basically if we start we could do a listen and accept and then um we could make a function actually you could say uh like this is going to be the file server bootstrap Network I think it's going to be a thir eror because uh it could be and then we could save 4 S not quite sure what it's going to be I think it's uh adder in s bootstrap noes range actually what is that let me quickly see uh y string okay cool sometimes I I I switch these guys up with uh with each other uh and then we need to do something like S transport dial right that's what we need to do uh and we don't have a dial right let's return n here real quick uh what we're going to do in our TCP transport actually here I'm going to make a dial function and then we're going to dial an address actually a string going to return an error right so if you go to TCP transport we can make this dial function we have consume close yada yada yada let's make it here it doesn't really matter uh T it's going to be TCP p no transport dial add string error and we could say that the connection uh and an arrow is basically net dial which is going to be be TCP the added man my hands are itchy what's going on random random stuff if there is an error of course we're going to return uh return null now we have a connection so what we need to do is actually create a peer I guess because right here in uh start Loop handle come we can do handle come is it uh we can do handle con but we see that it's outbound so we could say in handle con uh we could say is this outbound like this here right and this is start accept Loop so this basically outbound is going to be what that be true we're accepting so it's not an outbound right going to be false and I think we could do here uh go T handle con which is going to be the connection and this is going to be true right this going to be an outbound comp because we're going to dial and we're going to return null here does it make sense uh I think so dial uh implements the transport interace always I'm always after all these years I'm not sure do we need to do a punctuation after our comments yes or no I have no clue right because some people do it and some people don't and the question is what is the correct thing is there a correct thing what do you think let me know let me know in the comments I'm I'm curious um although this is basically nothing we need to discuss to be honest because it's basically it doesn't really matter but still sometimes that question raise UPS uh in my mind so let me know what you think about it right let me know and it's up to you you can choose it's all fine for me uh what is going on with this I'm going to mute my output volume of the of my audio captured yeah that's uh not quite sure if the volume if the volume guys let me also know if the volume is fine I have no clue what's going on let me know uh if the volume is good or bad right uh all right so we have this dial right can we do this so we're going to say here if a is going to be actually we can dial them uh in a go way we can say go frun here right uh like this uh and I think we need to do we need to do other string we will see what what the what the thing is telling us uh vs code what Al is going to tell us uh S transport you're going to dial the address uh this is just for logging purposes because um actually it's a good a good question to be honest are we basically going to this is returning an error although we cannot return because we're doing it in a go routine uh let's just print this right let's let's just print is out why not okay you see this is basically already the the error we have here right uh the warning so it need to be an add switch is a string and then me say Adder all right that's what we're going to do we're going to bootstrap the whole sh bang and we're going to do that in start right um I'm thinking uh we are looping but we're also put uping the network I have no clue let us see let us experiment yeah we're closing the server here yada y yada uh so transport options is here we're going to say that the bootstrap do we have this in transport no it's not in transport options actually are we do no I don't think transport is going to be responsible for for dialing um well it's responsible for dialing but not responsible to to do Shenanigans with the with the with the bootstrap thing that's something we we need to take care of ourselves uh it's going to be here bootp notes and we're going to make a list of a of a string and I think uh what we're going to do here is basically um let's do 4,000 although we are not connected right I'm going to see what eror is it throwing at us yeah nothing what's going on here are we calling this yeah right let me quickly do this how's it going on what is going on we don't do anything here um what's it going on here going to say uh bootstrapping not work man what's going on I'm I'm confused because I'm thinking already uh a step further and I cannot do two things at the same time what uping the N that's fine right it should return as a n or at least Panic though what's going on here who's network it's all fine I think the problem is that we don't have any of these um yeah you're going to say attempting attempting to C connect with this guy uh and then we're going to say transport dial the address and if they we're going to panic so it's probably something in TCP transport then so there is no error uh that's crazy um what the hell is this what is going on here are recalling start yeah recall start right uh and why is this uh maybe we stopped maybe it's basically it's trying to dial and dialing timeout as basically uh longer than three seconds that could be that could be nasty if it's so we're going to stop quitting the server we're going to just wait what's going on look at this I see uh maybe no no we can't do that right we can do that we could do Local Host but this is going to be fine we don't get any erors what is going on H connection fuse right so returning an error right if ER is not n return an error we dial this here because start is maybe what is going on see we don't get any eror not no Panic I time to connect with the remote banic heat who who what maybe I made some stupid mistake and you guys already can see it but I cannot see it after the panic man I'm I'm literally confused I'm not going to lie I'm I'm I'm totally stuck here um it's not executing Hispanic if a is transport dial the adders and the add is not nil wait turnill oh my goodness oh my goodness oh I could easily it's 15 minutes in I could easily remake this video right that's 15 minutes I just delete my code get reset hard and go back and and do it if everything is fine that I'm basically a God and don't make mistakes with this I'm going to leave this in I'm not going to redo it it uh oh man look at this oh and I didn't see it and you guys probably saw this oh man I'm I'm going to leave this in this is this is actually too too too funny uh to delete oh man oh it's actually smiling because it's it's I thought what the hell is going on this makes no sense uh okay cool uh man man man man man after the Panic everything okay what's going on it's still not doing anything okay that's because um wait uh so we dial this thing and if the error is not nail we're going to return the error and dial here uh which actually should Panic what is this it's anel Anthony please can you can you stop doing the shenanigans for once in your life all right what the hell I'm going to leave this in uh it's it's just too ridiculous okay cool this is fine uh so we're going to print this error here and we can actually return this uh yeah let's let's let's do not go routine this so we can actually have an but do we care if we don't want to actually guys I don't think it actually matters here uh I think we're going to I think we're going to break no continue actually if this guy is not uh dialing and then what we're going to say is basically do the G Funk anyway here I'm going to do the gunk anyway okay we cannot continue why not oh yeah see I see of course we cannot it's another thing it's fine it's fine oh guys what is this uh we're going to print this thing yeah now we need to sh we block are we blocking are we blocking I think we blocking make Run Okay so uh the connection refused that's fine no big of a deal it's good right uh so what we're going to do is oh man it's too funny uh what you want to do is make a function here actually I'm going to make it a top make uh a server uh I think you're going to set the listen adders here real quick listen Adder which is going to be a string and actually what I'm going to do is also the root which is going to be a string here and it's going to return as a file server and maybe an error I don't know this is actually just a convenient function uh to to testing right uh so we're going to do all the shenanigans here uh copy the whole She Bang paste it in here right and then we're going to say that we're going to take the Liston address here uh all the same all the same all the same uh we could do something nasty uh we could say listen addage plus uh this right uh bootstrap notes is going to be we cannot do this actually uh we're going to say uh string root and then notes it's going to be a slice of string right uh yeah like this actually I'm going to do it like this uh string wait it's going to be this right can I do this actually probably we can it's fine now we have the server and we can actually return a new file server here do we yeah why not return a new file server and then we can say something like uh that leaded this this whole thingy and we could say um S1 is going to be make server actually uh make server he going to listen at 3,000 uh what's this the root is going to be actually we do the root itself so we don't need to root yeah it's fine uh now we going to say boot step notes uh that's going to be 4,000 the problem is um actually it's not going to have one doesn't matter because if there are none we're not going to connect which is fine then we going to say s one start maybe an error actually could we do we can't because we need to run this in a in a separate thing like this right and maybe we could do is it going to is it not going to format this for me what's going on uh the reason why I want to do this in a function is because then we can actually catch we can do this right lock uh fatal this is that a thing I think it is yeah it's fine uh we're also going to make a server two which is going to be this guy 4,000 right and then we're going to say that the bootp note is going to be 3,000 right which is easy and then we're going to say here as to start like here it's going on and that will actually uh boot up these two notes I think I think not quite sure yeah it's working the only thing we need to fix is uh transport listening yeah yeah yeah attempting to connect with remote 3000 uh TB trans listening on Port 3000 attempting to connect with remote that's because we have no bootp noes what we could do is basically uh if uh can are we going to do this here I think we could do it here right you could say uh if the length of um s bootstrap notes is zero and maybe we have an empty string maybe we have an empty string that could also be the case to be honest yeah it's an empty string that's nasty probably because we do it like that uh um although the check is good what we could do here is basically uh if L Adder equals zero uh we could say continue actually see perfectly fine uh so we do this stings it's fine we have a logging do we actually want that date I'm not sure maybe we going to make a prefix uh in some sense we could that later um TP transport listening yes yes yes we have a new incoming connection that's fine uh new incom atcp transport I guess new incoming connection I don't like the way it doesn't tell us anything okay uh that's all good all good so what we going to do do we have a sent in the spear wait let let's first things first let's make our server uh it's going to be a map string uh as going to be appear appear to P like this uh I want to have a sync mutex wait let me do uh P lock is a Sy mutex right uh p is going to be make me a map string uh point no no no pointers PE like this is fine it's going to be a peerto peer peer yes yes yes um we could also do some some mechanic where we add peers and delete peers based on a channel but um yeah I don't want to over engineer channels you know it's it's I did I did this in my blockchain series I did this in I think in the ex I did this everywhere this ADP with his channels I'm not going to do it this time because why not why not a mutex it's not going to do anything it's not that it's a performant action adding a pis is just I don't know it doesn't matter it doesn't matter now we need to add P Funk right uh Funk file server on peer it's actually nice to test our own peertopeer lip uh maybe we should actually make one uh but actually open source one but a good one and I think for now it's it's working fine we have on peer uh which is basically where is dial list and accept close uh no on P is basically just um where is on coming from it's just a TCP transport thing right on PE doesn't matter the thing is should this be should that be in an interface where the transport needs to call on pier each time it has a peer actually actually maybe this needs to be in our um of course it needs to be because uh no because it's TCP transport Ops Next Level right or not next level or complete garbage it's either one of two it's binary right there either an Next Level move or it's either just complete dog there is no in between and the weird part is that I have no clue what it is um because you know what you could say yeah but transport needs on peer right because uh each transport will have a Pier which is an interface and each time it's connected the transport can call on peer which then everybody in everybody has that transport interface can call on p on it and and Y yada that's not true I think this is the best option uh where where we have just have an onp which is a generic function which is also generic right it's not something that's hard it's genetic function um this actually crazy because TCP transport Ops and we do on peer which in my opinion should not take a peer but a TCP Pier to be honest uh yeah I think that's the thing maybe we going to change that let me know what you think about this uh I think it's fine because now what we can do I think is uh where is our uh onp thingy and that's what I love to do the most man is the making these things it's it's insane I like it uh and once we have a good lip a good P2P lip we can use it in all of our projects right it's a lot of boiler plate all the time uh so we have on peer which will basically takes a p which is going to be a TCP Pier but that's nasty actually we could say p it doesn't matter uh so this G be compatible with everything later on something we need to think about and an error right because uh this takes an appear oh wait actually I think I'm going to keep it uh this way because I'm going to keep it PE because why because um this will make it compartible for other transports this onp because we have this P yeah yeah yeah yeah yeah yeah yeah because then we can call on p on each trans because now it's only TCP transport but it could be that we have uh web soet transport uh UDP uh whatever you want to grpc whatever so and every and and and and that's why we have this genetic peer thingy right this could be this could be a peer over over uh TCP could be a peer over UDP so this all peer can work on everything if we decided to if you or me me or whatever is going to use this decided to add other transports right okay so this debate is done the debate is closed and hey guys listen um if you have remarks or things you think hey why don't we do this or let's collaborate right I hey I'm open for everything I'm open for everything this is how I should do it but it's not this not this do not this does not mean that this is the best way it is a way it works for me but maybe something is better right we don't know and actually to know that we need to use it right that's why I'm I'm I'm going further and further and further because by using different stuff we know ah damn actually or a function we just implemented is not going to work after a couple days or something right uh and that's why you can make things better and better uh on P what we going to do with on P we're going to say s uh we're going to PE lock lock this thing and then we're going to say defer uh as per lock uh unlock unlock or boy and I'm we going to say as beers with uh how are we going to store this that's a good question it doesn't actually matter we could say p uh we cannot store this guy we need to have some more function in our in our uh interface speed interface right we only have P I think we need to have like um address or maybe we can make it compatible with uh with goine and we say remote adders uh which is going to return a string right and then DCP P close and I'm going to say funk P TCP p and then we could say remote adders string return BC remote adders Network we don't care ah I see it's uh it's uh are we going to do a net Adder why not let's make it compatible I mean if we make this uh more compatible with the go thing I think it's going to be uh I think it's going to be good right especially if you want to open source this peer to peer lip returning a net Adder think a lot of people appreciate that because to be honest uh let me go back to uh TCP P TCP TCP it's in in transport yeah uh and another thing is basically yeah why is TCP p in in in TCP transport and not in TCP package uh TCP file it doesn't matter right um I like to group things a lot of people like to split things out and make TCP the file with only 20 lines or something I think it doesn't make any sense uh but that's also a personal preference I don't matter I don't care I like to group things in one file because yeah I don't scroll through the files that much I just try to search for things and uh um I don't care if a file is 1 million lines or something 1 million is too much but hey you get the point right uh so remote Adder is basically let's say remote Adder uh implements implment the P interface and uh will return the remote actually and we'll return remote address of the uh underlying connection of the pier of it's underlying connection maybe of it's underlying connection all right that's fine so now back to here we could say s B and then say uh we could say remote Adder uh but we are using strings we could actually use uh remote adders ourself but we're going to say string like this right uh and then we're going to say it's going to be P right that's it and then I'm going to return all so yeah that's this and maybe going to we're going to do uh FM log or something I don't know log print Ln or f um connected with peer wait connected to it can we say addit p to the P map something connected to it uh remote which is going to be this and we can actually do B we can actually do something nice right because p is just a p i don't think we have a Stringer yeah we could Implement string yeah we're not going to do that we're not going to do that we can say a remote Adder because a remote Adder will uh it has a Stringer interface which is cool because I think if you go to remote Adder uh it's going to be a net Adder right you see see this implements a string do we want that to be implemented in our P I don't think so right I don't think so uh connected with the remote right let's see what's going on here uh are we doing wait wait wait first of all we have our on peer but of course we need to implement this into rtcp transport where are we where are we making this a you see the problem already let's go to main because we need to implement this this on PE we need to inject the pointer of this function into TCP transport right this onp you see it's going to be onp here uh so that basically means that we need to have our server first a uh can we do let me see what I can fix uh so the server is going to be this guy you're going to return the server here and then we're going to say that the onp transport onp is going to be the server onp uh so yeah is that going to work make run yeah so we have a new incoming connection from our TCP transport I don't think uh TCP we actually want that what's this new in connection yeah we don't want that actually that's loging connected with remote connect with remote so they both connected uh it's pretty fine actually maybe I um I was thinking maybe we want a string I don't know or maybe we don't so we can connect with each other that's fine the next thing we need to do is uh I think P has a scent function TCP P it's going to be a longer episode a little bit doesn't matter uh yeah so TCP P has this Con no no wait where is transport yeah P remote add close we also need a sent right we going to sent which will take in uh a slice of bytes and it's will returning an error that's what we're going to do uh very important and we're going to go to TCP TCP transport new TCP remote that close and all that stuff if we're going to write which is basically a very simple function uh we're going to say TCP pach uh sent uh bytes uh like this we're going to return an error yes and the only thing we're going to say is underscore R is going to be P com uh right right like this we're going to say B write the bytes and then we're going to return the eror um we could also just start this thing but I don't want to do that we are handling the read functions here which is fine yeah yeah yeah so and the next thing we're going to do basically is now that we have the scent function for our Pierce is um each time we want to store we're going to send that to to the other one is going to get that message a store message and then he's going to he's going to also replicate it so that's for the next it's going to be amazing I'm I'm actually thrilled to continue the previous episode I think we created our server right we created our server um which basically I think we also had something in main yes we created our server we have uh connected uh server one with server two let's uh make run real quick what's going on make run yeah so they're basically connected with each other uh which basically means that we can start sending files right uh of course we need to encrypt and all that stuff uh and another um major important thing is that we cannot for privacy reasons I don't think we can store uh wait I I will explain I will explain because we're also storing a key and it could be that our key would be for example uh my NES my NES which basically we don't want that that it's that key is being stored on uh on remote uh servers right so we want to basically store directly the the hash of the of the pad of the keypad of the pad key right uh but that's for later on um today we're going to do I think some some interesting stuff because we need to stream large files uh over over the network right so let's let's get started um yeah so let's open up main that's already here right uh let's let me put that a little bit higher so what we're going to do for example is uh let's say we have S server two is is being started right so what we could do is basically say something like S2 and we could say store file right something like this store file uh at a given uh key and then we're going to say um I don't know we could say that uh the contents the data it could be an I/O uh it's going to be a new reader actually not IO it's bytes right going to say it's going to be bytes new reader and it's going to be for example um my uh Big Data file here like this right and then we going to store this data here that's that's the thing and what's going to happen is uh let us go over to server um bootstrap Network yeah let's do it here right so we could say for example this going to be S uh it's is a file server right and we're going to say store data or store file uh anything right could be it could be legit anything it's a forever anything store right uh that's going to be we're going to store this at a certain key which is going to be a string right and we going to say uh it's going to be an R which is an iio reader and we going to error uh an error right that's the thing like this let's return n for now right so the first thing we need to do is basically first of all uh store this file to disk right then we need to basically broadcast um this file to the network right that's that's the thing to all peers actually uh store this file to all known peers in in the network right because it could be that we only know two peers but these P are going to broadcast it back so everybody uh is going to get that file that's the the the main goal of this and of course we need to encrypt that stuff right that's uh that's for sure that's for sure uh so how we going to do this is basically let's make a a simple broadcast function right so we can we can try to scolding this out let's say it's going to be broadcast uh and we want to broadcast a p now we want to broadcast a p which is going to be a payload and we're going to say error right so this payload uh is going to be a type is going to be a strict and this payload is going to have a key right because we we're going to send this file but the people need to know uh the receivers need to know the peers need to know which key is going to be stored of course for now we're going to just store the key like we it's going to be uh let's say uh let's go back to to main it's going to be the key for example uh my private data right that's going to be my key of course we don't want to store my private data as a key as plain text uh it could be we know that but the others cannot know that right of course it's not that big of a deal because everything is being encrypted but still right still privacy first that's very important so but for now we're going to just store it like this we're going to send it over like that and then later on we're going to we're going to just uh put the hash so actually maybe we should already put a hash anyway we will see so there's going to be a key which is going to be a string that's what we know right and then we're going to have um I don't know maybe the data and that's going to be a bite uh like this right it's going to be a bunch of bites so but we want to stream right we want to stream that bites because of course we need to copy this once but we don't want to copy this to uh you know what I mean we we want to stream this to all the peers because if we it's very important lesson actually uh if you go to PE TCP no um yeah TCP is fine right we have this sand function right you see here con right so it basically takes these bytes all the time uh they want to do that we want to basically stream uh the whole Shenanigans over the connections to all the peers at once some coffee so en able to do that we we going to refactor PE a little bit uh let me return nil here right so what we're gonna do is what I want to do here let's um make this more clear so in broadcast we could say for example 4ore Pier uh in Range s peers right then we could say for example uh let's read the btes here it's going to be for example uh B is going to be I uh read all and we going to actually the p is already bit right yeah yeah yeah no no no no what you could do is basically do make a buffer or something we going to be a new bites buffer like this and then we could say if at um it's going to be Hop new encoding new encoder and we're going to say uh the buffer because that's a writer and I'm we going to say encode the payload right and if the ER is not nil we can return the a right return the arrow here something like that uh what's going on with peach no no no it's not it's going to be yeah this is the buffer yeah yeah yeah and then what we could do uh so everything is in the buffer right now and then we could say for example uh P sent uh buff bites what's going on here uh buff bites like this right that's something we could do but I don't like that so what I want to do is basically delete this whole thing what I want to do is basically this I want to return um hop or actually any encoder we can make an interface for that uh new encoder and I want to basically encode directly to the Pier's connection but we don't have access to the peer connection and then we could say uh and code the payload right but then and then we can Loop to all the peers and do the same with one Pier if that makes sense so let's let's let's make this uh you're going to make this clean listen this going to be insanely good so in able to do this what I want to do is uh if you open up um transport right this Speer interface we have remote adder and all that stuff and we could say so we need the con here right we need the con of the PE to make this work right but uh it's a private variable so what we could say is make a function right like this make a function and say come here right which is going to be turn a NETCOM because a NETCOM uh is basically a reader and writer right that's what you could do uh why is it not working uh yeah of course because ccpp does not implement this but why are we doing this right what it can it can be even simpler so instead of doing this we can do interface embedding right uh we could say send can be here we could just do this right we could say net con just like that and then instead of saying con here we could just do Pier because p is already uh will have all these functions attached to it right so if you go to TCP peer uh instead of doing this remote added close stuff right we can delete all of this and it will it will be perfectly fine I guess because um yeah the only thing we need to do here is and instead of making this Con a variable we could just say uh net con here right just a NETCOM you could actually say uh that this is going to be uh the underlying uh connection of the p uh which in this case is a TCP connection right and instead of doing this we can as a private variable uh we could do this make come uh public right so what happens now is that the TCP P will instantly implement the as a netc it will be a netc it it implements all these functions so that means uh that we can use this directly as um as a as a as a as a as a writer or a reader right directly into this encoder of course p is payload here so not going to work but we could do for example this right uh for range p and uh S Pierce like this right uh we could do this we cannot return because it's going to be an issue you're going to say go new encoded P directly you see that works perfectly fine and then we could say if r y y uh is not n if the add is not then we can return the error right and in this case we're going to return n this will work fine but still what we could do is even uh something better and let's basically say that we're going to make uh Pierce and Pierce is going to be I want to stream this directly to all the peers like a streaming service so what we could do is say uh p is going to be a slice of Pier right any Pier uh is going to be a peer to PE peer actually peer to peer peer like this right then we going to Loop uh for actually this going to be Pierce yeah uh let's let's delete every 10 and then we're going to say Pierce is going to be append Pi Pier like this so we have a slice of Pi and then what we could do is um say that we have a multiwriter multi writer is going to be an IO multi writer actually and we're going to say it's going to be Pierce uh I think it's going to be this actually it's not going to work because uh multiwriter wants um you're going to say it's going to be IO writers right and that's going to work perfectly fine so this is very important to understand right so our P or TCP p or even p uh in general is an interface but P embeds the neton interface which basically um also implements the writer reader interfaces right this is this is a this is the peak of goang engineering I swear to God this is the peak of goang engineering so uh netcon also implements reader writer so what we could do is basically tell us that the slize of P can be as slice of iio writers which we can just append peers into it so we can then make a multiwriter of all the peers and then we could just return uh goop uh new encoder which is going to be the multiwriter and code me the whole payload and we're done that's nasty that's that's not nasty this basically insane I'm not going to lie um yeah I did this before um using the multiwriter and and we going to do some some some some cool stuff um yeah yeah yeah so that's it right that's cool what's going on in Mage yeah store file yeah yeah yeah we don't have store file right store data actually what's going on right my private data so it's now we already heing store data so this is It's is interesting because what's going to happen is that um we need to make this payload thing let me quickly delete this and paste it in here and we of course going to split things out so what you going to see is that the payload you're going to make a payload uh so the first thing we going to do is basically store this on disk and you can see that we're going to have some problems so we're going to say if f it's going to be s store uh write the file the key the reader if there is an error we going to return the error right so first of all we're going to store it to our own disk which basically means we're going to read from the reader but at this case here after we read the reader is empty right because there is already being red it's completely empty so what we need to do because we need to read it because we need to uh also send it back over the network right so what we're going to do is I think we're going to make a buffer which is going to be a new uh bytes and actually I can show you first let's let's let's do some demonstration what's going on so let's say um let's make the buffer yeah let's make the buffer we're gonna say it's going to be a bites buffer actually new buffer maybe it's going to be a new bites buffer right and then we're going to say IO copy we could say uh we don't care of this we're going to say the error is going to be IO copy which will basically do a streaming copy of reader and writer destination and source so we're going to say uh wait what's going on I think copy uh the first thing is the destination what's going on I cannot man nasty uh copy is destination right so the destination is going to be the buff right and the source is going to be the reader right uh I'm going to say if the error is not n you're going to return the error here right and then we going to say fmt print and print me The Buff uh bytes right so if we going to say here yeah if we run this wait of course we basically block here right so we cannot do anything here so we're going to say go and let's time sleep here so it it has time to boot up uh we going to say time sleep um let's say two seconds right maybe one actually yeah right so we're going to go start this thing right so we written to disk right that's fine we written to 22 bytes to dis but then we see that the buff even though we copied from the reader the buff is empty so if you want to send that buff because we're going to make a payload right we're going to say here this is going to be the the P which is going to be a payload and actually what I want uh this should be appointed to a payload because I don't want to copy the shenanigans into a function right because if you have large files so we're going to point to to the to the payload and then we're going to say that the key is going to be okay we need to have the pad key so we don't so we are sure we we don't expose the the the plain bytes of the key but yeah that's for later on so we're going to say it's going to be the key and then we going to say that the p uh the data right the data could be the both bites right that's what we're going to do both bites right and then we could say here um return as broadcast we're going to broadcast the payload that's what we're going to do right and then we're Gucci but the problem is that it's going to broadcast nothing right you can see this uh I think if you do make a run uh actually let's block here so we can see what um what the other site is going to receive uh make run you see it's getting it's getting this uh garbage thingy right wait let me let us let us make this real quick this is actually interesting guys this is so interesting you probably need to watch this a couple times to completely understand but this if you know this you're literally a God what's go if you can do this guys I swear to God uh this is years years years of experience and years of of figuring things out how things work this is nasty so this is transport print consume right so we're going to print out this message but what we're going to do is basically say that we're going to decode this into a payload so we're going to say uh p is going to be uh uh a payload or actually make it better p uh is going to be a payload right and then we're going to say if is going to be uh hop uh what's going on Hop new decoder right we going to decoder hands so called uh what are we going to decode uh we're going to make B new reader p no MSG payload actually we could make this into a reader directly from the T where are so so many things we can do not going to lie and I'm going to say uh decode me this uh thing into a payload can we make this a pointer I don't think it's going to work yeah it is uh if the is not n then we're going to basically log fatal out for now uh this error because actually we we we should not fatal out we could Loop right right this is what going to happen right let's let's make run wait uh what's going on spads I think it's just um uh wait fmt print LM let's say we're going to receive let's see if if if receive receive refuse going on uh yeah I think we need to who is dialing maybe we need to sleep here give this guys time to boot up before they connect yeah so we receive a message uh yeah yeah yeah yeah we receive a message cool cool cool cool yeah I forgot we need to do this I'm going to say print F right and uh we're going to say uh it's going to be a percentage plus v like this we're going to make a new line and we're going to say it's going to be the payload right uh so make let's make run this again you see so it's it's telling us the key so that's the first problem we have so this is this is being received on the other side right so we store to dis and we broadcast and this this this this uh this output is basically on the outer note of the network right and we already see it's my private data which is not good but hey we're going to fix that but you can see that the data is empty right that's a problem and that's because we already read from the reader can I not close this yeah so how we're going to fix this is we're going to do some nasty Nifty mechanics of course because we are the club of the high value Engineers high value software Engineers so what we're going to do is um here so what we're going to do is we're going to make this buff but we're not going to copy right what we're going to do is what's going on we're going to make this buffer then we're going to make uh a t which is going to be iot reader is it a new T reader no it's iot reader and um it writes it from yeah yeah yeah it writes so we're going to make the BFF Heat and the r e is that correct so we're going to read from um wait am I confusing this yes yeah yeah it's this it's going to read and it's going to write to buffer that's cool but we need to do this before we write this to the store right make the buffer here and then we have this t reader right so what we're going to do is we're going to read we're going to write a t reader and then we have the B bites boom We written to dis and we broadcasted it to everyone that's what we did so because uh if you don't believe me we going to see um B can we do B string actually uh B string is here yeah yeah what we're going to do is on the other side we're going to say story that we're going to we're going to we going to going to say this one um P let's do a string of P data and then make run let's go going on here unexpected end of file you see okay I think there there so much it's basically the sleep we need to make sure uh that it's okay because they are we will see so you see my big data file that's what we receive on the other site which is perfectly fine uh I see sometimes we have an issue I guess let me make run we will debug this yeah I think it's something to do with this connection with the time sleeps maybe second is not enough we will see we will see uh yes okay so the thing is uh this consume we're not going to make our our logic here right that's not that's not the best uh approach what we're going to do is basically um we're going to make a function we're going to say here s file server because we know we also need to store it on the on this right on the other side we're going to say handle message I guess uh handle message uh or handle payLo is may be a better thing it's going to be a p which is going to be a pointer to a payload like this and we going to say an error um I think the payloads wait I have an idea I think it's going to be handle message which needs to be a message actually how we can make this even better I'm thinking uh so we have a payload key string uh we could also make a message which is going to be sent over the wire uh so it's going to be a structure and we going to say that the uh man this is nasty uh maybe you should say from going to be a string and then we going to say uh that the payload of the message that could be any I think something like that because then we can actually uh and this is a payload I don't think it's going to be could make it as a data message which is going to be a key data uh so this is going to be going to be a data message right but then we need to make this into a message so we're going to say we going to broadcast we cannot we need to broadcast a message so we're going to say here a message and we're going to encode the message here right and then we're going to say uh broadcast uh a message and we need to make a Constructor we're going to do that later on and it's going to be from is going to be and we don't know the listen address that's crazy we don't have that that's maybe interesting what we need is the listen of the transport let's go to transport real quick dial listen and accept consume actually do we need that listen adds I think we need to be honest listen Adder which is just going to return the listen adders of the transport I think is that a thing because we make a new um file server but we don't Store The Liston address because we sto a transport here I see yeah so I think listen add is pretty fine for the transport interface TCP transport Let's uh make this real quick we're going to say funk uh P that's a p do a p we don't need that transport here here here here here Funk D let's put it higher it's going to be a TCP transport listen Adder it's going to return a string uh we're going to say a return the listen added we don't have this it's private I guess we don't what's going on what's going on here ah it's I see what's going on it's the same thing each how how we going to fix this um because we make the the transport uh the problem is in main you can see we make the transport we make the transport here and then we put that into uh yeah wait we going to fix that later on uh we're going to fix that later on where is where is uh transport interface because I don't like to have a listen address here to be honest so we're going to just uh do something nasty and we going to say from need to be too and we going to say that the data no it's going to be the payload of the message I guess yeah the payload is going to be B it's this data message here yeah and this is going to be done then we're going to say it's going to be a message all right and we're going to encode into a message instead of a payload uh because we can send other messages also right a message here oh it's the same that's nasty uh let's say m uh payload like this it's any we need to switch this we need to switch this and then here we're going to say handle message which is going to be uh a message which is going to be a message we're going to return this actually we could check the error if R is going to be S handle the message which going to be the m n m n M and if the Eros uh is not nil we can uh lock yeah we need to print land these things actually uh right and then we we we call this function and what you're going to say here is basically uh switch MSG payload uh type going to be a v actually do this and we're going to say case if it's um if it's a data message right then we could say print actually can do it like this right we can actually say print is it print F we don't have that that's nasty let's do fmt print F I'm going to say received data uh plus V new line V uh let's return n is is going to work all right we we still have this unexpected end of file we need to fix out why figure out why this is happening we will see we will see normally it's going to work perfectly fine no it isn't uh wait wait wait wait wait wait wait what's going on what's going on what's going on so this data message is going to be the payload you're going to broadcast that message yeah uh key B and bites and then we going to say this from uh I don't think we need the from by the way but hey the end of file why do we have that um is it B bites and the message in broadcast and broadcast will actually uh basically hop and code the message I think it should work but I think we have let me quickly check what's going on here uh do we need to sleep longer I have no clue to be honest I don't think it's a problem to be honest guys but hey we can try we can try okay so we we Rite it that's the thing right so that's cool so if if you open up our thing that that's fine still have some issues I think you make a mistake uh my big data file here so that's perfectly fine in the 4,000 Network which is basically server two all working all working like intended uh just one more thing I want to what is this um as you can see the camera is at top right and I have the lunar Vim shenan go going on um I think it has a better terminal uh bigger fonts and everything so that's fine uh so let's make run and so we can continue where we left off right and I'm going to say the next couple of episodes going to be super super important we're going to do advanced stuff uh and I can swear to God that if you know these Concepts very well um you're going to be you're going to know more than everybody else I can swear if you if you get if you grab 10,000 go developers uh I think only handful will know how these things going to work so we see that we have disc corrupted data uh here right so basically uh that's because uh if you go to our decoder right you can see our decoder which is basically let's open up thisp I'm going to show you real quick normally you guys should know if you follow along uh the decoder is basically the staying in the read Loop where we decode a message right and uh what we do is we decode the prefixed set of bytes a preallocated slice of 1028 bytes and you can already imagine that this is perfectly for or normal messages but it's not suited for big files 4 GB 8 GB 10 GB that's that's impossible um it's already too small and uh upping the size will basically uh make every computer crash because most of the computers don't have so much RAM to work with so what we're going to do is we're going to stream uh we're going to stream data directly to a file right so we need to do some some changes for that so we have our server here the first thing we're going to do is we're going to we're going to delete some stuff test some stuff and then make it better so basically this data message we're going to delete this real quick uh this message is perfectly fine I'm going to everything in here I'm going to basically comment out um and the next thing we're going to do is basically Let's test something let's test something real quick I'm going to say um foror p in Range s p is going to be this we're going to say uh if R is going to be Pier sent uh some bytes which we don't have yet and then we're going to say um add not nil we're going to return the error here then uh let's let's make a simple message um going to say this is a message uh this is from are we actually going to use this I don't think we're going to use this message for by the way uh we're going to say that the payload is going to be a slice of bytes just to test this is just a test to give you a concept uh what's going on and why we need to do this it's very important to understand uh this is really really really important trust me um so we're going to say here for example uh um it's going to be the storage key for example we going to send the storage key simple thing then we going to actually encode this with G encoding going to say if R uh is uh uh new encoder and we going to say we need a buffer actually let's make a buffer real quick going to say buff is going to be a new byes buffer which is basically just exactly what it is buffer and we're going to encode that in the buffer because a buffer is a writer and a reader and then we're going to say encode and we're going to encode the message uh I don't know do we need a poter I don't think so and then we're going to say R is not n and we're going to return the r uh let me find the plus sign here what's going on like this perfectly fine so we're going to have a message we're going to send that over to all peers and then we're going to return n here real quick we're going to clean everything up trust trust trust and then we're going to see where we're going to fetch the message on the other side of the network on other notes right where do we do this it's here right so we're going to handle this message we're going to comment this out uh we're going to comment this out we're going to call this we're going to delete this this is going to be an RPC this is going to be an MSG we're going to say RPC is going to be RPC payloads we're going to decode the MSG like this and then we're going to say fmt uh print Ln or maybe print F actually I'm going to say receive um percentage s and we're going to make a string out of the MSG payloads and we're going to cost that to a slice of B Because payload is a um and we're going to make better messages this is just for testing a payload is an any type and we are sending bytes on the other side remember we made this um storage pad B thingy so we're going to cost that and we're going to print that out uh so let me quickly make a run this to see what's going on uh of course in the spear uh scent yes we need to put in the buff bytes just like that and we're going to say make run and see data message okay we have some relics uh left over message I'm going to search for these guys here one and then we have I think that's it let's zo make Run Okay so the the the thing is running that's fine okay so we received storage key so everything is working like intended right so but that's what we're going to do we are going to send a message type a specific message type it could be hey uh a message type store store file which will basically means uh we'll hold the key and um so we know oh the next thing we need to do is open up a stream because we're going to receive a file and we need to store it right that's what we're going to do with all complications that uh probably will arise so how we going to do this right so we're going to mimic a stream we're going to mimic a stream uh we're going to mock one here right so basically this one uh so we we sending this right what we're going to do is we're going to make a simple payload right and we're going to say this a SLI of bytes and we're going to say this large file right this is going to represent a large file which is clearly not but hey um what we're going to do then is we're going to again loop loop again to all the p and we're going to make this better it's just for for demonstration right so the first thing we do is we send the message describing what we're going to do storing retrieving blah blah blah so and then we're going to send a big file that's what we're going to mimic here so we sent the message and then we sent the big file which need to be streamed right uh um but you're not going to send the above bites we're going to send the payload right yes right that's what we're going to do so if we test this right you're going to get some issues uh and that's normally fine that's because um let's open up servers we are in by the way right um I think we already received this first right yeah it's this unexpected Shenanigans um so we received the storage key already which is fine but then something happens right uh so we're going to fix this real quick and actually what I want to do here is a new line right so what I want to do is in this case I basically want to read right so we first read a message and then we're g to open up the the file for the stream right so what we're going to do is um I'm going to make a buffer no we don't need to wait the first thing we going to do is we we cannot read here right it's very important and it can be some confusing I'm not going to lie uh but hey you can always jump in the Discord and ask questions so what you could do here is basically um we cannot read here right so well we are reading here but we always transferring this RPC message to the to our server that's the way we communicate but we need a way here to read from from the pier if that makes sense and the way we're going to do this is to fetch the peer first so we're going to say that the pier okay is and that's why we need to have this from address in in the RPC method right so we're going to say p okay is going to be S Pier RPC from right and we going to say f not okay and maybe I I'm going to quickly can we return another no let's Panic here because that's very important we have a p it's going to say no peer uh in PE map actually P not found maybe uh peer not found in the peer map right uh then we have a p here let let let us see if we if we can find a p if that if that's working fine uh let's say just be it's probably not going to format but it doesn't matter just for testing purposes real quick right uh RPC from we don't have that right so uh I think we have a problem in this message real quick yes we're going to delete this net address we're going to make it just a plain string and then we're going to open up um TCP here and we're going to say instead of a remote address we're going to make it a string which is fine let's this this mouse is in the way uh then we going to make run just like that and see what's going on see if we get the pH okay so we still have this interface uh conversion what's going on here real quick um stop to use quit action that's nice uh server 143 actually what's going on here yeah it's this one I know I know I know know so what we're going to do we have the p is working that's that's that's good news right so what we're going to do is we're going to say we could say per read but we can't right and we're going to fix everything but first of all I want to I want to show you something right I want to I want to make things uh work so what you're going to say this is uh this is a TCP right so what we could do to access the read function of the connection of the underlying connection right actually I think um now we can't uh um is that we can we can read that's amazing that's amazing uh so we're going to say p read let's make a simple buffer now I'm going to say make a slice of btes Let's Make A th000 and we're going to read B and we going to say underscore R is going to be period so we know that something is wrong maybe we going to do this uh this need some that did need need some effector that's for sure but just to make things clear uh let's Panic here on this error because normally it won't happen I think all right the problem is right now that we are stuck at reading right so we basically are stuck uh at reading here from the connection um I think let's Panic here and if the Panic is not getting triggered we know that we are stuck I think we are stuck yes we are stuck right the problem is guys the the big problem is that in this TCP we have a read Loop here and it's the same read loop from this connection right this connection is the same connection sitting in this peer here in this peer right so the problem that's going to happen is that they going to read at the same time from this connection which is not the problem why we are hanging it's the problem that maybe after hanging we're going to have inconsistent results because W is going to read first and and and so on so we need to find a way to communicate between this gou team or this threat or whatever and this read Loop because if this message is going to be a message stream a store message or something then we know we need to add uh a weight group or something and that's exactly what we're going to do so I'm going to install a weight group and I'm going to say uh it's going to be a sync uh weight group like that and we're going to say uh wi is going to be a sync weight group just like this right and what we're going to do is and of course we need to check the message and we're going to all do all that stuff uh you will see first of all I want to make I want to test things if this actually going to work what I was thinking to do so uh what we're going to do is we're going to decode this is all fine uh let's say we going to uh we do p VG it's going to be IG adds and we're going to say add one then we're going to say print fmt uh print L waiting uh till stream is done right that mean we're going to copy this here we're going to wait the weit group is going to wait here right and then we're going to say here um stream Dum continuing normal read Loop that's what's going to happen all right so let's let's try it out okay so we are waiting till the stream is done right so that's cool that's that that's very important aspect so the thing is if we are waiting here we cannot continue the read Loop right we cannot continue this for Loop which basically means that this decod or decode will not get triggered so it will not read or read stream and will interfere with the stream we are actually going to read here if that makes sense that's the thing and I think it's pretty nice of course we have some issues uh because this reading Shenanigans is not going to work for some reason um although we sending this file to allps though um yeah I think I know what's going on um yeah um we need to sleep here I guess because it's going to send so fast after each other that we are going to decode this into one message I think that could be the problem not going to sure not quite sure I'm going to sleep for the um to be to be sure actually uh it's going to be let's let's sleep three seconds or something and uh the reason we are going to fix this later on is again a fix we need to make is to uh fix our um or or a default decoder that's not enough wait so we received the storage key which is nice that's the first bunch of bites we need to receive is this one that's fine oh what are we doing no no no it's fine we sending storage key here uh and then we are going to send back a payload over these Pierce yeah pier and payLo which is this large file that should be fine so why don't we receive it here um wait I'm a little bit confused now so we make this bite we read and we we cannot Panic here for some reason it's not going to trigger no we need to wait this seconds before the stream will arrive yes oh we Panic DDD that's fine that's fine fine fine fine fine um yeah yeah I see of course we're doing this we are so bad we are so bad we don't need to print this here right we're going to wait wait wait wait man man man man we're going to print here right that's the first thing we're going to do we're going to print our first message the storage key then we're going to grabb the peer then we're going to read from it and then we're going to print um again but we're going to receive Big Data wait we're going to just do nothing we're going to say um wait this going to be this it's going to be a string of the buffer I think that's fine let's see what's going on boom then we have a large file that's perfectly fine this is what we see so I hope you guys see what's going on so the storage key is getting fetched from here which will then be piped into W group uh which will then be piped into this RPC message which will be consumed here we decode the message here and we print it out here right here is where we print out the message the storage pad then we're going to fetch the p from who did we received it we're going to fetch that PE in our peer map we're going to make a bite and we're going to read the next incoming which basically should be the stream that's incoming right because this is not going to read because we block with this group right and the next thing we need to do here is basically after we um received our big file what we're going to do here is just say p VG and we going to call it uh d right like this and then uh we can make run a PG undef find yes of course uh the reason why we cannot do that is because uh p is basically um transport here right p p is an interface and we only have net and scent and net and sent right so what we could do is we could give it actually another interface and we're going to do that but another neat trick is to basically cost this to a TCP perer um but I wouldn't do that uh because then it basically abstracts completely the way um it will not abstract the way why we made the speed Dynamic uh and and generic right so we're not going to do that we're going to fix that later on uh we're going to make run and to see if this works so normally what we should see is a complete round trip of a complete streaming uh Shenanigans right we're going to receive you see we received the large the large file here and then it said stream done continuing normal read Loop and everything is Gucci okay but now we need to refactor this into something that's actually usable because this is spaghetti wety right this is arms are heavy and knees weak at the same time so first of all it's good that we have this right um yeah yeah so what we're going to do is first of all uh we're going to have a message which is a payload any right then we're going to make actually we should actually uh we should split these messages out but let's do it here for now we're going to say type it's going to be a message store file the question rather is um yeah why not I'm taking because message store file uh a pad key is somebody receive a I'm sending a bad key to you that means that I want to retrieve it no it's going to be store file you're going to say the key and the key is going to be a string maybe it's going to be a pad key to be honest or a pad name the pad actually the key let's make it key that's that's better so we're going to store a file based on a key so what we're going to do if you want to store data uh we're going to make a payload uh and that's going to be not this one it's going to be the um it's going to be a message store file yes and we going to say that the key is this uh a low small case actually I'm going to say that the key is going to be the key we give it right there at store data that's fine that's fine then we're going to uncode a complete message we're going to send that to all the peers that's fine right let's let's keep it like this we're not going to hassle with these things right now uh so we're going to comment these guys out and the next thing we going to do let me oh my back hurts once again man the next thing we going to do is basically see if we can fetch this thing on the other side which is basically here um what is this a t reader yeah that's because you're going to yeah yeah see that's that's for later on here um this is going to be the message I think this is not going to work right this Bel bite it's going to be nasty uh what we going to do here is quickly actually what we're going to do is let's print it out in a in a dirty way in a print fway going to say percentage plus v uh new line which then we're going to say message and maybe uh let's only print the payload let's see uh what we get nothing um we're going to decode the RPC yeah this should be a message what's going on here what is going on so we make a new by buffer we encode that into the buffer we range over all the peers and then we going to send the buffer bites to all the peers yes so why don't we receive anything um we don't have any OT even what's going on here I'm confused real quick don't we get any messages anymore what did I do what is going on wait no nothing is happening it's main it's main broken I'm going to store data which is basically um this private key my private data yes yes yes but we don't consume anymore uh why is that we're going to add one that's fine what's going on am I still sleeping no that's possible we we we don't consume anymore why is that um are we actually calling this what the hell's going on we panic in DDD that's fine because we call store data right so that's good uh we're going to encode this we range this uh let's Panic here maybe to see if it's uh being being being sent of course of I think so there's no reason to wait did we made a mistake uh we are blocking at Pierce we are blocking uh before we s p is going to block I think it's the Hop en coder it's the Hop encoder for some reason that blocks yeah you can see that we are basically blocking here but not here has probably to do with these messages I think ah I know what it is uh I think we have a book I think it's uh I know what it is it's um look at this guys and we need to fix uh this thing it's going to be a go register actually um go register it's going to be which is the thing um message store file that's that's the interface type you need to register right is anything that we are placing in the any anything that we are placing any kind of type we are we are embedding in this any type let me open up message a message here you see this payload uh all types we we place in there needs to be registered with the Goen coder otherwise it cannot register an interface that's the problem that's I hope that that's the problem not quite sure um that's why it's it up uh no it's DDD is the same thing let's DD I'm going to delete this right so now now it's working right let's make run yes uh payload is key my PR data that's perfectly fine so we have the key we know it's a storage we know that the message type is a stream a a store file so we now um can open up the connection for streaming open up a file and pipe these two together and make that happen and that's what we're going to do and refector that stuff in the previous episode basically let me comment this out we basically did um some Shenanigans where we could uh store where we could actually send a message type store file and if we receive it on the other side on a note we can uh we know it's it's a store file so we need to open up a connection a streaming connection right and uh we get this large file right here so now it's actually time to store that into a file right to store it into a file and to clean things up um yes so let's get started so basically we make this message here of course um let me quickly think we're going to encode this stuff and then we're going to send that to our peers we're going to sleep here that we need to fix later on all right so let's let's go to here right because here is where we're going to read from the P right here is where we actually need to store that stuff so why don't we clean this a little bit uh up to be honest so we have this handle message here wait uh let me see we decode the message yes yes yes okay cool uh what you could do here is basically let's comment this out so we're going to handle a message which is going to be a type of message which is fine we don't have a data message we're going to say case uh probably the message uh store file yeah like this uh let's make uh another function going to say file server uh handle message store file which is going to be what going on and that's going to be I think do we need a from we probably need that right from it's going to be a string and then we going to have the message I think it's going to be yeah a store file message I guess message store file maybe an eror here right and let's uh what we're going to do is um return null here and see if we actually can can make that work we're going to say uh print F we do a percent fee P Fe new line and then we say the message here we going to say return s handle message uh store file need to warm up not going to lie and we going to say V and from we don't have that um I think we're going to do here in handle message we are going to get a from which is going to be a string pass it in here so we're doing all that shans let's comment this out we're going to decode it so we're going to decode this message and then we're going to say if it's going to be S handle message RPC we could actually handle the decoding there and handle message instead of this uh thingy but it doesn't really matter uh so we going to say message I think it's going to be the message payload right yeah if the DAT is not nil we going to uh maybe a print a l here uh like this the error and then maybe return or continue not quite sure what you're going to do um that's going to be the message then what's going on and handle message wait let me quickly see it's going to take a message itself yeah I see what's going on uh we need the message here and then we need a pointer which is this which is fine all right let's see if this con um is going to work let's see make run wait uh or we receiving this let me quickly check uh received store file NSG like this right should work delicious coffee yes receive file private data is the key that's fine um okay okay okay okay okay okay we we can clean things up right so we don't to do we're going to fetch the p and all that stuff yeah yeah yeah yeah so that's what we need because we're going to open up a connection right so what we're going to say is um the same thing I'm going to say p uh okay is going to be ASP from right uh if we don't have okay we're going to say fmt error f p and then percent s in the P map we could save from some nice error then we have a p here here that's fine let me open up a server on the other side so we can actually um see much better what's going on and I'm getting a little bit of a cold or something I'm not quite sure what's going on and that's my own fault because I'm basically uh walking outside without any um jacket or something you know just bare naked almost I think this is good it's he it's he it's so we have the p and then yeah Okay cool so what we're going to do then is basically we know that's a file so we could say as uh as store Write we're going to write um the key we're going to write the key and then we need a reader which is basically the peer right we're going to read from from the spear and if the error is not nil from the storage we're going to return the error from here actually we could return right um we could just return this H are we going to return this or are we going to do it like this maybe maybe they need to be some logic here later on not quite sure well let's just return it let's just return it and we're going to see what's going on here uh okay taking a comfortable position yes what's going on here so we have this payload that's my mic CD kicking in right again once again so we're going to handle the message then we're going to do la la la la la and the speed and done and all that stuff we going to basically do delete this um and then we are going so what we're going to do here is basically uh again assert this to a TCP P do we have this Weg it's going to be a peerto peer TCP I'm going to call done on this we need to fix that um let's delete this folder because we're going to see if we're going to store something let's see what's going on right let's see what is actually going on okay I think we okay we have this folder but we don't have any contents in it okay okay and I also saw that we have two uh read streams which is not um what we want of course we are a legit trash right look at this of course of course not going to work uh what we need to do is this and if the error is not nil we are going to return the error here and then we need to uh call dumb and then we can say return no let's see wa the stream is done uh okay we are blocking and I think I know why but still I think we should have some file yes that's already been done so we can already um call store on a server it will broadcast this and then the other server will just store it but we're blocking and I know why I will I will explain I will explain exactly what's going on so basically uh what's this let's kill this so what is going on is uh let me open up store uh real quick here so if you open up store let's go to right uh stream it's actually small caps right right stream here so right stream is basically going to uh copy right and we tested this and it's all working fine we don't block here but you see I'm going to do a panic here so you know here with some exclamation marks you will see that we are blocking and that we don't hit that Panic although in our test it's working perfectly f as because we're using a bytes uh we make a new reader out of a slice of bytes which basically will return end of file um if we had the last bite written right you see stream is done and we don't panic out so the problem is that if you read from a connection right a connection will always will not return in the file so that's why basically our storage keeps waiting for new stuff to write in in in that reader so what we need to do is um a couple things we could do we could say copy n and then say we only want to copy 10 bytes or or n and and certain bytes right that's how we can fix it but we also can fix it by using some kind of a limit reader uh but where are we going to do this limit there where are we where are we yes so we basically sent this file of course this needs to be a file that's for later on let's first fix where are we doing that stuff man here we store right so we need to have a way to find out uh how many how many bytes this this is going to be because we could make this into an IO uh it's going to be a limit reader limit reader like this and let's say we want to read how many bytes is this thing let me open up um I don't know let's say we want to read 10 bu or something right and we're going to make run then normally it should um you see now now we Panic right but the problem is we only uh because the limit reader basically will say yo this is a reader but uh only read the amount of bytes you specify if you know open up this file you will see that this large right we only have written 10 bytes so it's actually an easy fix right so we need to find a way to get uh to get the size of of that thing we need to let uh the other side know what's coming in uh so what we could do is basically open up our message this one uh message store file we could say actually the size that could be an INT right so that's what we're going to do and in this case uh large file is basically this large file is 15 right uh and you will see we're going to specify the correct size uh not hardcoded in a in a in a in a bit of time so we're going to send that over so basically that means that if we handle this message um handle message store file this is here right right so we can see a limit readed and we going to say it's going to be um what's going on here it's going to be p and MSG size what's going on here yes like this what going on here an N64 okay okay okay okay okay uh it's all fine we going to we're going to change this hey all good my man and let's make run real quick and see what's going on what's going on everybody's sending me messages man it's legit crazy boom everything is working like intended we got this Panic uh and let us see boom this larg file so now we have a way to actually completely uh unblock here and we are fine right so we're going to close this um that's fine fine fine fine fine uh okay okay but now we are sending this large file which is basically not what we want to send right um what is this reader uh that's going to be the reader we give it so that's fine so let's delete um let's delete pent and let's do something like um IO copy which is going to be a streaming copy right we're going to say IO copy and we're going to copy to the peer and the reader is going to be the reader we give it or we could say by let's just try it with this uh by new reader payload and we're going to say maybe we going to say NF this and then say if the error is not nil we can return no we cannot return can we yes we can I'm going to return the error here and then we could say here fmt print received and written percent D we can't to disk we need to do it like this and just for logging purposes and let's see if that's going to work yes 15 bytes with dis all good all good but now we're basically doing still this are we doing this large file yeah we're doing this large file right let me quickly see if it's working double check yes yes yes all fine so what we're going to do now is actually take this reader right that's what we're going to do the reader we actually give it and store data in our main right you see in our main uh we are calling here uh bu new reader my big data file here and I'm going to store this at my prev data key and it's going to be the data we give it right so instead of making the spay load here we're going to say we don't need to make a byes new reader because it's already a reader Let's test that out make run okay unexpected an a file how is this possible we going to from AR which is this thing here right I see what's going on or not no I don't see what's going on I thought it was something to do with this with the file size maybe it is is it we can't right I think it is by the way it's stting at the same key um yeah I think the problem is that we don't know going be 15 uh 22 just counter cter bites manually is that the problem yeah that's problem now it's working fine right all right so we need to find a way to get actually uh the size of the file um so if you want to make this reader right the first thing we need to do is actually store it right we're going to say s uh it's going to be s store uh and we could say no not store s store right the key uh is going to be the all right and then you're going to say here as not n we could return an arrow here right just like that but the thing is uh that we need to do our let me open up server real quick T do we have a t t t t why can I not type what's going on T here man what is it doing yeah so we need the ster that's what we need we're going to copy this hop hop do it here let's delete this uh we can do this right we make a buffer we make a t reader we're going to store the file um this buffer can we reuse that buffer no I don't think so let's make it the message BFF then let's make it a message buff what can we do with this T we can't T can only read right T can only read so we have um we store it to our own disk then we're going to send that to the network to broadcast this it's actually in here all right uh let's delete this function okay okay okay so what I want to do actually in store is find a way to return if you do right stream what I'm going to do is actually return this and it's going to I'm going to return an in so we don't uh restore nothing we written nothing uh 0 n actually no that's not true it's going to be n that's an we're going to do it an uh an N64 for some reason it's an N64 like that and of course our test will be broken it's going to be right we're going to do the same thing it's going to be in N64 which is the file size yeah so now we could say uh this we could say um it's going to be T you could say n or actually size maybe uh yeah if add is not nil and then we pipe the size well pipe we're going to assign the size to the size is good very nice and then I think we're good let's uh let's open up this thingy let's delete this what's going on Windows man all right so uh all folders are gone let's make run let's see what's going on I store right that's basically in server 160 I yeah see it's a he right uh let's do this because we don't need this make aun yeah I think we uh up or t reader not quite sure this is T B bites it's this B oh yeah yeah yeah of course I think uh we made a mistake here this needs to be the message bth I guess is that true received and written zero bytes to dis e um of course we we got these two files right and we got nothing here right but we got Big Data file here so it's it's who is sending this yeah it's it's two right so we store the data so we store it at our own uh disk is fine right we stored it at our own disc but broadcasting is uh in problem or not what's going on yeah yeah yeah yeah so broadcasting is a problem wait wait wait wait wait uh oh yeah we do R that's not true of course we made a mistake this needs to be the buffer wait we need to be careful right because uh these file namings are basically blocking us um yay oh we did it we did it I think it's going to work so we have 3,000 here file here file there yes we distributed our storage man amazing all right but hey we are still not there because it's garbage right it's garbage code let me quickly do my um the serious position the position where we where we yeah if I'm in this position it means it means uh things are got to get serious right all right so we do these things I have this this this Micro CD man it's crazy what's going on why am I why why why do I have that okay so I want to change some names because this is the buffer this is a message buffer message buffer buffer that's fine that's fine that's fine how you going to name this um let's make this a file buffer right let's make it a file buffer and then we're going to say here that that makes more sense uh file buffer that makes more sense that is fine H H hop cool cool cool I think the store data is is kind of good maybe we should do this to make it even more cleaner right that's fine I like it MSG is this one I like it then we do we decode a message here here that's fine that's fine okay cool that's that that seems that seems good that seems clean where is this one and then this message thingy handle message what we do here is basically this one I don't like we need to fix that we store it here what I'm going to do store is actually um delete this thing so we can actually do it here and we're going to say n uh like this and then we could say here uh fmt written uh bytes to disk new line of course what's going on here what's going on here and then we're going to say uh it's going to be n then we're going to call P done but still we need to fix some stuff because there are a lot of things not okay because right now we do this here in TCP transport right you could see we are hardcoding this stuff uh because it could be that we are just sending a oneoff message then we don't need to lck the stream so we need to have functionality for that that's what we need to do uh what also we need to do is try to uh retrieve files uh if we can uh store a file if you can retrieve a file that's fine we need to do the encryption clean stuff up make some tests and I think then we're almost done with this of course you can expand upon this uh much further and further further but I think if we all have these things in place we have a very nice project that we made um which you guys could use uh to get a I don't know a higher pay job or something this basically if you show this guys be honest um they they they don't know what's going to happen uh in the previous uh episode if I'm correct me if I'm wrong uh we could actually uh distribute our files so if we store a file uh on a certain key we can actually uh distribute that between all the connected nodes which is perfectly fine which is actually the intention right so basically it means that if our uh computer blows up uh our file is safely stored somewhere else which we should able to retrieve if we don't have it right so that's what we're going to do now um yes that's what we going to do now so let's open up uh this thing first of all I think we need to do is basically um inore data right what we do here is this a bunch of thing right this this whole shebang what this does is it basically encodes the message and then it's going to send to all the peers uh and I think we should have a broadcast message do we have that yes broadcast here I think we're going to rename this to stream and uh actually uh make a new one we're going to say file server uh broadcast and we going to broadcast a message it's going to be a pointer to a message uh which will return an error like this right let's delete uh let's clear the highlights uh and then we can actually copy uh this thing so let's copy the buffer Boom place this in broadcast and uh instead of we could say just buff here uh like this just say buffer and I'm going to say buff bites and return n here I guess um so this is going to basically encode it and broadcast this to all the peers and now we can uh here say if the eror is going to be as broadcast uh point it to the message if the error is not nil just going to we can return uh return R which is fine now we going to sleep and we going to fix this sleep uh very soon very soon then we going to copy the whole sh bang and I think think we should do a multi writer uh here soon I'm going to say to do and let me do a high comment uh gfg is going to be green like this fine uh to do uh at uh NDM use uh a multiwriter here like this myty a myy a multiwriter yes um so that's fine for now is this going to work let me quickly test make run to see if this all working perfectly like intended yes right uh we have written two times which is basically one on 4,000 and one on the 3,000 server good good good so the next thing we going to do is um store data actually what I'm going to do I'm going to I'm going to rename this to store actually um it's not going to work so we're going to say store perfectly fine everything is out we're going to call this store and I'm going to say funk s file server and we're going to call this get which is going to be a key string and that will return I think it's going to return an IO reader right and an error like this right so if we want to do a get is basically the first thing we're going to do if we're going to say um if s store has if we have the key then we can retrieve it locally right then we can say return as uh store read key right but if we don't have the key right then we can actually say um going to return n here actually let's let's just Panic right uh don't have actually yeah you could do don't have file locally right that's what we're going to say here uh which then because I think we already have these files so we can comment this out and I'm going to say um or error is going to be S2 get and let me get some uh Fu which we don't have and if the error is not nil we're going to uh log fatal the errors right and otherwise we could say that the B uh R is going to be IO it read all the the reader here if let's copy this real quick like this and then we can say fmt print Ln the string of the bytes right let's make run real quick it's going to panic out right because we don't have this Fu thingy right don't have file locally which is fine but if we say uh that the key is going to be my private data right and we do make run then it's going to what's going on let's read all what am I doing private data like this that normally we should we should get a file Big Data file here right that's actually uh you can see big data file here that's that's what we stored in these files right so it's good it's working like intended right so if we don't have the file locally we're going to actually search for this file in the network right so we're going to say type uh message type get no message type message get file it's going to be a structure right and we're going to say I think we only need a key for now right and then we could say something like the message is going to be uh a message the payload is going to be a message get file and we're going to say that the key is going to be the key we want like this and I'm equal to if f is going to be as broadcast I'm going to broadcast this message and if the error is not nil uh we're going to return the error like this and uh instead of saying Panic we could to a print uh F don't have file locally key right don't have file locally uh we could say fetching from Network like this and then we're going to broadcast that stuff and uh that should be handled on the other side of the network hey so we're going to handle a a message here so we're going to say case message get file we're going to say return s handle message get file from V we don't have that so we're going to say funk as file server handle uh message get file what's going on like this and that's going to be from string and of course a message get file is it a pointer we don't need a pointer because we didn't do it in the other side we going to return an error um yes let's n and say fmt print Ln okay we need to get a file from this and send it over the wire uh let's see if this is going to work actually what we need to do is um block real quick on get otherwise it's not going to work we're going to broadcast this and I'm going to say select real quick to test it out uh what's going on clear make run um yeah yeah yeah of course we just copied some stuff actually a handle did we uh 79 that's not going to work uh and then 89 yeah of course we we we we turn yeah uh yes of course cannot use message as message and broadcast okay okay okay fair enough my friend you're right and if you're right you're right so we're going to do this Shenanigans my big data file here yeah okay good that's because we actually um we have this key right so we're going to see um a new key we don't have that's something we don't have in our in our storage right so normally uh it should now send message okay so we can see don't have file uh blah blah blah locally fetching from the network that's fine but we also need to make sure we can send our new message over the network is this thing we want to what's going on actually what did I do copy this paste it in and then we're going to say message store file we also going to say message get file right so remember for the go and coding we need to everything that's basically could be an interface in an any type anything that could be in there we should register that to the go and coder so that's what we do and then we could make run to see uh cannot use blah blah blah again I think we made a mistake it's because uh like this my bad my apologizes so normally right now we should have um yes so need to get a file from disk and send it over the wire right that's uh a thing wait until the stream is done why is that it's because we lock it yes yes yes we need to fix that because it's an a dirty thing so we sent that over the wire that's fine completely Gucci um here so what we're going to do here is first of all we need to uh make sure that we uh what are we going to do here maybe you could do ifs has because it could be that our remote doesn't has it right you're going to ask for all the peers hey yo give me a file but if he doesn't has it he doesn't have it uh and I think we should to respond with something I not sure what we're going to do here I think you're going to say if has uh MSG key if we don't have it uh I don't think we going to we just going to print something out we going to say print Ln of print or print F rather um uh cannot fetch cannot read file from disk uh actually file does not on disk all right that's that and if we have the file we need to basically fetch the file uh we need to fetch the file it's going to say that the um it's going to be a reader and an error right and that's going to be s store read we're going to read uh MSG key right and if there is an error of course then we're going to return an error and now we have a read here right so we have our reader here that's what we're going to send over the wire so we need to open up uh a stream actually with the connection and that's basically the p uh okay is going to be as peer from right and if not okay which basically mean this spe does not exist so we could to return an fmt error f p not in map whatever like this then we have a peer so what we could do then is basically copying uh files from this guy to the peer uh we could do that with um n r is going to be IO copy very important uh thingy and the destination is going to be the peer and what we are going to copy is basically the reader we just fetched from our dis and that's why we're using readers right you could say yeah but why are you using readers in in our storage and and people always use bites bites stop using bites right stop using btes you should use readers because it's compatible with the whole universe you know what I mean reader is so compatible you see why we're using read is because we need them it's Plug and Play It's Plug and Play boys and girls and everything else uh then we going to say if there is an error of course we're going to return an error all right and then we could we could actually log this out I could say parent uh f um row this is root a thing and I'm we going to say written n bites over the network to from and I made a mistake us that's fine now let me quickly see I don't think it's going to work but hey let's test it out listening to the transport uh of course we not we we're not going to have that file right so we're going to say does not exist on disk uh no such file directory open that's cool that's cool why is this uh we are opening stuff oh yeah yeah of course what what are we doing fmt print F we could return an error we need to return this as an error actually I we don't need a new line here uh is this so right so this going to be much more cleaner so uh like this right so it's it's telling me need to serf server file uh but it does not exist on the dis right that's cool uh just this little typo here like this and then we're going to say f uh file server stop du to server action quit uh not quite sure why that is is it probably for um handle get file here is here we going to handle a get message oh yeah we return heat yeah I see can we continue here I'm not going to do anything actually because these these errors causing um need to Sur F but I think that's better yeah uh and this error is basically not not that good um file server stopped due to error or user qued action something like that it Mak more sense each time we return here this function is going to get T first right uh and go and I think we're going to do the same thing here to be honest don't want to quit we just want to print out the error right and uh we could actually say uh decoding errors uh like this copy this paste in heat and we going to say heat handle message error much more cleaner eh all right intense intense not going to lie it's intense boys but it's nice it's cool I like it I love it and I hope you love it too I just want to make sure you guys are absolute animals on the keyboard with go and it doesn't even matter if it's with go this is basically uh programming this is about programming right this is go okay but you can do it in every single language out there it's just knowing how to do things is just knowing how connections work how how it is what it is if you you can literally give me any language and I will make the same thing literally just rust I don't care uh rust python even in JavaScript call me a language and I will make it happen although goang is my best language because I know a lot of things in the top of my head and in rest I don't but it doesn't care because all the things I don't know I know where to find them you know what I mean it's it's all it's all the mindset it's all knowing how to do things and if you know how to make these decentralized distribute storages you literally can make so much because you know these Concepts that's the most important thing to know uh and and even though these Concepts maybe you don't don't want to build a decentralized uh content addressable storage knowing these stuff can help you build other things you want to build right it's it's it's just knowing these principles this mechanics all right so okay cool what we're going to do is uh we are 4,000 right so what we could do is uh we are 4,000 which we're going to delete the whole folder of 3,000 uh 4,000 yeah what's going on here still is this a filter real real what's going on anyway it doesn't matter so we don't have um or folders so we're going to get the my private data which then basically will um well this this this we will have this right so we're going to actually can we can make a log line we could say ft print F real quick here and we're going to say got file percentage s serving over the network actually serving file over the network new line m g key like that uh make ritten real quick yes so we serving file my priv private data over the network and then it sets written 22 bytes over the network to that guy wait until the stream is done and then we have a decoding error yada yada yada so we copy this right that's good that this copy is working it's perfectly fine because that's reader we sering that over the network and of course we get this decoding error because right now the file is being uh decoded in the TCP Loop uh in in the transport in the TCP trans the file is being decoded here right here this thing we got it here right but that's not because we don't uh basically I'm happy with the result already but the the problem is that we um is's a multiwriter here right so we do a broadcast but then here we need to actually um open up a stream looking for my words so are we going to do this to open up a stream is basically we need to broadcast this to um read from every P that's what we need to do and we need to find a better way soon but hey going to be range as PE we need to do a copy we're going to say n r is going to be IO copy and we need to make a file buffer actually we need to make a file buffer for everyone because we actually don't know uh if you have a file maybe we should first ask there are a lot of mechanics we could do make this better guys we could first we instead of assuming they're going to serve it we could first ask if they have it and if they have it then we open up uh so we could say hey do you have this file he responds yes I have it okay I open up a stream or you could say uh what we're going to do right now is basically yo do you have this file I'm waiting for you actually not good so we we need to fix it we need to fix it uh but hey we built this up don't be too greedy in your over engineering because because that will basically kill your dopamine levels so we're going to Loop through the spe we're going to make a file buffer which is actually not true uh we going to make a file buffer which is going to be a new bytes buffer then we going to say uh who is the destination the file buffer is a destination and the p is going to be the reader and we going to say if there is an error of course we are going to return that error actually we should not do this because U but yeah we're going to actually we're going to fix this later on because if we return here an error uh this get is going to basically return and it could be that just this an invalid peer right it could be that the first p is going to turn n while the next p is going to serve or the file perfectly fine so we cannot do this but uh for now it will be fine and then we could say that we are receiving uh fmt print Ln uh received I think something is wrong with my um let me quickly check is it Windows Intel once again no it's us hey hey so I have basically I don't know why I have two keyboards one is us one one is international and I don't need International I don't know why Windows keep doing that should probably delet it uh but hey deleting in Windows is a pain in the ass not quite sure why that is um can we actually print out this buffer actually we could do buff string right is is going to work I assume not uh buff of course not how many BS do we have where is BFF okay let's uh one 109 let's let's let's open up this line real quick did we not save this what hell's going on just not saved it my bad all right so we're going to do those Shenanigans um what's going on uh so we waiting till the stream is done I think that may be a problem with till stream is done these vs in our in our Peach um we need to fix that soon so don't that file locally fetching it from the network then we wait till the stream is done not quite sure who that is serving file my private data over the network that's uh the remote we then going to write 22 bytes over the network which is fine uh but for some reason I think this uh I'm thinking for a good a good thing receiving stream from Pier and we could do this and then say b um remote data or something like that uh I think it's blocking there because we already read it from our other loop which is not closed wait until right receiving stream from a pach I think it's the same issue once again where we need to make sure that we time sleep here because um ah we need to fix that guys I'm going to lie we need to fix this stuff uh because otherwise otherwise we're going to read the whole shebang into the buffer into this in in this the code function you see so we have this uh 10,28 so basically because we broadcasting here and then we instantly uh trying to receive is it not quite sure I I think I'm wrong I think I'm wrong to be honest I think I'm wrong sometimes I can be wrong it's decoding out which come from an unexpected kind of file ah I see I see I see we need to be careful because um it's this copy thing uh the copy thing is a problem uh yes wait two problems two problems arise it's a copy thing is first because it's a connection which will not uh stop uh yeah yeah yeah yeah yeah yeah yeah uh don't file from the network that's fine receiving from the PE um wait tell the stream is done it's still not done he's sending 22 bytes right um so the problem is basically that we uh in our TCP transport that we read here first once again um so so it's going to be some juggling around with these weight groups and I think it's going to be a very good way a very good start to do this because uh we cannot leave it like this uh we can't we just can't it's bad it like I said it works it worked till it was good till now right some things you implement things to make things work but for for at a certain point of time things cannot work anymore you know what I mean and then you you fix them and that's how you come to a complete solution so the good thing is that we um have a way that that we actually can can can uh request files from the network we are copying them but we uh have a problem receiving them so we need to do some couple fixes and I think it's going to be an excellent episode to do these fixes in the next one so let's continue with our forever store and uh let me quickly do a make run to see where we start where we stopped so I think we um started with retrieving a file but the problem is if we don't have the file then we need to fetch it from uh all our other peers of at least from one Pier right the problem is we we we going to we're going to run into issues and um the reason is if you go to this transport right um this transport we we have this this p w ad and and and weij weight it basically means that um we hardcore this right because why do we need to wait is because we're going to receive a message like a plain message which we go up and code right and decode on the other side but the problem is that we need to find a way to close that we're doing that in in um in our server somewhere but the problem is the way we are doing it right now will is causing issues right so everything was fine until it lasted right until today so we need to do some some creation handing to to fix that right to support it in our in our lip so what we're going to do is we're going to support stream in our library super important right but the first thing I'm going to do is um I'm going to open up main real quick and uh instead of doing this uh get thingy which did not work yet right uh we're going to test it with data um with our with our store with this this this function basically works perfectly fine right if we delete uh these two bad guys here if we delete these permanently right uh and we then do a make run here and normally it should uh basically work like this and everything is fine right so we have this network here 3,000 with a file uh Big Data all good and then we have 4,000 with the file Big Data all good right so uh the best thing is that we test there a very common practice is that you always if you want to do a effector you test this with um things that already working instead of things that are broken right okay so how we going to do this very very important episode I'm not going to lie this is um how do you say that the cream on the on the pie or something I don't know yes the first thing we're going to do is we are going to open up and coding encoding here right because what we do right now is we read this uh 1,28 uh stuff and uh I already mentioned this in the previous episode that's causing issues so what we're going to do is I was thinking about this and uh I'm not going to lie I was thinking about this for a long time um but I figured I figured something something neat I figured something out which I'm going to teach you what we going to do actually G I think it's going it's it's it's implemented in a lot of other uh stuff also um what we're going to do is we are going to uh make a peak buff right a peak buff and that's going to be make me uh a slice of bites slice of bites and we're going to make a one bite so we're going to Peak the first bite right and we're going to say uh first of all we're going to do something like if R is going to be nothing because that is the bites written right this is R because we're going to read from the reader right I'm going to say R read me the end to the peak buff and if the error is not nil then we are going to what's going on here please V code yes then we're going to return the error like usual what did I do here if what's going on all right so if uh we're going to read the the shenanigans here and then we going to say that uh first of all what I'm going to do is going to open up message right and we're going to add some support for streaming in our RPC we're going to say stream which is a Boolean right because then we're going to know that we are streaming and if you are streaming we know exactly what we need to do we need to lock our stuff and then we need to have a way to unlock it when the streaming is done so we don't receive other messages in that read Loop right that's important and I'm going to I'm going to show it once again right this is the read Loop this thing is our read Loop which will basically each time there's a connection this read Loop will run in other go routine reading from that P reading from that connection but if we need to uh so each time there's a message being sent over the connection we're going to read it here decode it into an RPC pipe that uh into our Channel and we can read it in our server but if we are streaming we need to lck this read Loop because otherwise we're going to have problems right so we cannot open up two two streams of reading two two read Loops it's impossible so we're going to lock the main read Loop uh we're going to say hey log this because I'm receiving a stream so we can fetch the stream directly in our server that's what we going to do I think it's a very very very nice uh option we're going to add to our lip right so message here we're going to have a a config an option A support for streaming in our lab so we're going to say here that uh stream is going to be the peak buff the first bite right because we it's only one right uh and that's going to be equal to for example I'm going to say uh 0x2 right and actually what we could do is um maybe we could do in uh we going to do this in message we could say for example um how we going to how we going to call this this this variable that's a good thing uh if the pig buff is uh streaming type I don't know man uh maybe stream type or something it's going to be 0x2 actually what is it the type you could say const con stream type is going to be Z X2 and then um message type is going to be 0x one or something right and actually why I do that I can do this do this delete this and this something like that right so we go to uh peerto peer uh stream type what going on here Shenanigans we are in we are in we are in P yeah it's my it's my bad so if it's going to be um if the peak buffer is a stream type actually sorry guys I'm going to incoming message and I'm going to say incoming Stream So if the peak buffer is an incoming stream yes right now we're going to say if stream right so if if this if it's a stream then we're going to say that the RP the message which is our why do we call this actually message anyway doesn't matter we're going to say the message stream right is going to be true right otherwise it's going to be false and we're going to return here right we're going to return there is no need to decode right there's no need to call this right um could say in this case in case of a stream we are not decoding what is uh being sent uh over the network why am I actually searching for w like this is better we are just setting um Stream True so we can handle that in our logic or something I don't know uh it is what it is all right so we're going to say stream through and uh it's fine then then then then then we need to go to TCP transport right so for our TCP transport what we're going to say is um I'm going to decode this right and then we're going to say first thing we're going to do is if RPC stream right uh then we going to actually we can do this uh this RPC from can be can be on top that's all good the OU add if it's a stream we going to add uh the OU and we're also going to wait for the VG for the weight group right that make sense so if it's a if it's a stream we're going to wait so we're going to say um fmt print F and we could say uh this we could say the address of the thing um um how we going to call this incoming incoming stream waiting I don't know something like that and then we going to say here actually a new line maybe and then we're going to say here it's going to be um do we have the com com remote Adder so we know who is saying that now we're going to say here um resuming stream closed uh resuming Rel Loop like that that's cool and then we going to here we going to say continue right because there's no way because we're streaming which basically means we we fetched everything we need to have on the other side on our server or something or somewhere else so there's no need to to pipe an RPC into it with basically hold no bytes right so we're going to say Ouiji add we're going to say Ouiji weight right that's the first thing we're going to do all right so you can already imagine if we run this right now that that we're going to have uh big troubles right we're going to have inconsistent data because we are basically sending an U we we are peing the first bite and then the rest is basically completely broken right so what we're going to do is um in our server right in our server uh and I think it's broadcast we need to have broadcast it's actually I need to search for broadcast here yeah like this uh so here what we're doing here is basically we are sending a just a normal message right broadcast is just sending a plain message it's sending give me a file store a file with a file uh with a file name and all that stuff and a file size uh but it's not doing any streaming Shenanigans right it's not sending us that bytes over the network those file large file bytes so what we're going to say here is instead of we going to say p we're going to send um we are going to send the the the streaming incoming streaming type right this this bite we're going to say pent we're going to send a slice of bytes and uh it's going to be a peertopeer uh incoming message right you're going to say incoming message bite I don't know uh not not quite happy with the naming yet right so we're going to send an incoming message so we know that if we are here right if we are in um encoding here right so we Peak so we know that this is the first bite this is the first bite we are sending is going to be the peak buff which going to determine if it's an incoming stream or just a normal message right the next thing we need to do is find out where we are uh sending that stream over uh this is get receiving stream from P this is a receiver that doesn't matter uh handle message handle message get file store file you see here are we closing right here are we closing the the weight group is because the stream is done right so what we need to do is where are we sending this it's all right so we need to somewhere we need to copy copy copy copy here right so what we do here is we broadcast a message we're going to receive that somebody is willing to store a file so we have the file name and the file size we then prepare on the other side we prepare we open we open a file on disk which basically our storage right right stream and then after 3 seconds this guy is going to send the Stream So the first thing he needs to do is basically say peer sent right each spe we need to send uh a bite and that bite is going to be uh your body guessed it it's a peertopeer uh incoming stream just like that right and normally and I said only normally they should actually work perfectly fine not quite sure let's see what's goinging on yes yes I think it just worked perfectly fine incoming stream we wait in then we receive the stream we are written 22 bytes to dis and then we close the stream and we resume the read Loop right so to make this even more test we actually happy because it was um it's Advanced guys this is Advanced I if you know the stuff it's it's insane um let's open up main because I want to basically let's open up main here so I'm definitely not coding in this window uh I'm going to make this like a four because I want to make it a little bit more performant and I don't think that the sleep of these angles is needed uh let's do 10 times let's copy the whole she Bank inside of here let's paste it in here yeah uh so what we're going to do here is uh we're going to send it and then we're going to do a Time sleep because if we not sleep you cannot there's there's no use case it's going to send so fast this is going to send as fast as a CPU can which which no other note will ever do it's impossible there is some kind of a round trip in HTTP so we need to sleep otherwise it will it will us up uh it's going to be uh time sleep and we're going to say uh for example I think maybe five uh time I think millisecond is even is even enough five millisecond is is fine uh and then here we wait 5 milliseconds to send I don't think it it doesn't matter wait it's the same thing what the hell is going on where do we sleep oh yeah it's in server yeah yeah yeah I see I see I see uh here here here this 3 second we don't need this but I think we need to sleep a little bit uh and this is all normal behavior I think uh because millisecond uh millisecond I don't know uh five or something no clue we can test that out and make it even better like I said we're just going to make it work we're already downgrading from three from three seconds right uh make so let's see let's see hopefully we don't have any encoder decoder uh problems and and a not quite sure what's going on here uh I think just one more thing I want to do real quick is actually uh in server uh something we forgot is basically open up our quit Channel no it's not TCB transport by the way transport um like now we don't have a buffer Channel we have a unbuffered channel which is not good we're going to say a24 is going to be good um let me quickly see what's going on normally normally everything should be fine I guess but we're never sure yeah that's ourselves um is this actually doing what it needs to do I don't think so to be honest it isn't what is going on so we sleep five time millisecs I'm going to make it a little bit bigger here and a server also yeah uh I don't know maybe 500 which is actually let me see right let me see we're going to build things up right we're going to make things better for sure for sure sure all right this is this weight group negative weight cont yes yes yes I see uh the question is why is this happening um did we miss something did we miss something um this is our main this is fine so received and written bites to dis that's all fine I don't know maybe um let's make a thousand let's see what's going on here something something um is is still something is still not quite right um right so we we we sent this you say is it going to be a stream yeah that's fine then we do I think that's fine do we need to sleep his seconds I don't think is that a thing I don't think so so incoming stream waiting see so there something is is um it's not closing let me quickly uh do one real quick to see what's going on here uh because with one it's actually working or did we did we make a mistake uh in in between that could be this is fine so we add we wait and then we continue let's go back here that's fine did we miss something in encoding the stream we say it's the stream and um we return right so it's going to be we Peak it here yeah yeah yeah did we I'm thinking what's going on here real quick oh maybe we are actually this is get right we don't care about get we don't care about get where a store wait the bro is fine right so our broadcast um we don't care about the stream message broadcast is here right make a new bites buffer and then we first of all send this to our uh it's going to be an incoming message yeah yeah yeah so we can read that and then we send bites it's fine it's fine it's fine it's fine I don't know what's going on we sent the incoming stream this is good file we don't care about that it's a store file here so we check the pach and up uh at the end we unlock that wait first of all let us um do this real quick let's make some some nice stuff and you're going to say written percent D bites to dis which is fine and it's going to be uh there's no way to check actually uh what address we have let's open up transport uh TCP transport real quick uh let's open up transport itself uh what I want to do in this transport is basically expose an add uh in thingy which will return a string or it could actually even no I want to say add which is which is going to return a string and then in TCP transport um we going to say funk ttcp transport yeah adders and Adder is going to return what's going on here uh it's going to return a string and we are just going to return return the listen do we have a listen add what's going on here oh it's because maybe I it up here going to be a the listen add yeah yeah yeah okay cool that's fine we could say that Adder implements uh the transport interface returning the address the transport is accept connections right cool and then we can do actually here uh we could say S transport other and that's fine all right um if you make run should be all fine received and written bites to dis 22 uh and then we say we written 22 bytes to dis and then we close stream closed resuming read Loop that's what we want to see the problem is in main that we still if we do this uh for example for four times or even 10 it shouldn't matter that should also work and I don't know quite uh an idea what's going on you see it's an waiting but I think we are blocking here and I don't not not quite sure why that is right I think we're blocking heat so we cannot release heat are we sending it too fast I don't think it can right that's that's impossible right um I think we made a a mistake to be honest but where is it right where is it let's do it 5 Seconds that that that's actually enough right that's it's so much time for everything to to figure out what needs to do right we close the Stream incoming stream received wa you see that's a problem because we don't uh something is wrong we made a mistake we I think maybe I think I know what it is guys I think I know what it is I don't know I don't know is this is this it is this what happened nah 5 seconds it's too long yeah you see what's going on it's this right so yeah man this is you see this nasty even this can happen you see you you will you will encounter these stuff and that's why I'm why I'm why I'm doing this stuff real life without pre record with a screen next to me so I can see the solution so it all looks fluently and you think you learned something which actually will be but you can see that seeing myself making these mistakes will will you make more aware and even myself right so making this mistake the next time I'm going to do something like that I'm going to pay attention to these things right it's a stupid mistake but it's so important and I cannot emphasize this enough it's so important for you guys to understand some something is not quite right what is going on but you see that I looking I'm looking at certain places where this can happen and at a certain point of time you can see that I that I figured out that it should be something with this because de said okay we set the stream to true but we returning we continuing I was thinking at this continue but this will be true so it will keep thinking it's a stream which is not and then you know what I mean uh I hope it's this right you're not 100% sure we not 100% sure I think I think it is because uh so this time second guys this is actually this is way too much right such an application we cannot write so but we need to sleep uh so uh we need to sleep here uh for just a little bit of time because you cannot nobody can can process this at the speed of CPU right that is not U real life stuff so let's just do a five time millisecond that I think that should be good um what's this here millisecond right that's fine and then do we have a Time sleep here also uh it's 2 seconds that's already way way way way too much you're going to say um milliseconds uh I think five milliseconds is fine I think even one uh millisecond is good enough let's please let's um make run this and see if it finally can work um so we can continue Al yeah I think it did right you look at this uh it's nice right incoming stream right to bites stream closed incoming stream um the the the only way to test is basically to um open up these folders here uh actually I'm going to uh delete these guys delete permanently like this and then what I'm going to do here is instead of making this Kei uh we could do something like um something like an fmt I'm not seeing that I'm not going in my in my window here uh at the top um I think an S print right an S print F and we're going to say my private data uh underscore percentage D and then we're going to say why all right so it's going to have a different uh key so it's going to write all these file 10 10 times hopefully 10 folders uh make run let's see if something happens uh yeah yeah of course of course I was thinking why are there are two followers but it is is because the the root right so uh yeah you can see 1 two three four 5 6 S 8 nine 10 that's good and here also not quite sure if there's something in Big Data file that's fine yes yes I think it's working guys I think it's working here yes big data file and of course in our in our thingy e yay wo yes it's it sounds silly that I'm so happy but it's it was nasty books uh and I was thinking I I'm going to be honest I was trying this uh for a bit because it was a very nasty thing we need to solve with this with this prefixed bite what we needed to do and I was testing this and how can we do this because uh some I cannot figure these things out at at hook right uh although this is not scripted but I I still need to need to U prethink up front how a potential in my head it's not not not on not on uh on file not on my keyboard but in my head I was thinking how can I do this this this and it took me some time to to think about that and to figure out what we needed to do right that's something um that I do right is thinking up front uh before I actually make a video because otherwise uh it wouldn't be fun for you guys that I'm sitting here for 10 minutes just thinking in in silence right okay cool so I think uh what we going to do here uh let me quickly check uh so I think everything is set up fine uh what we could do is uh what we could do to make it a little bit better is and transport this spe let's let's let's call this a function uh and why why you see here um TCP right there is no uh TCP yes here right we see PP we C this to a TCP P to lock uh to close to set down so basically the the read Loop can continue so what we're going to do is basically say um we say close close streaming uh close stream yeah and that's not going to do anything but close stream will close the stream something we need and then in TCP P what we could do is basically uh make this EG public uh private my bad going to make this VG private so it's going to be VG like this and then we are going to make a function Funk uh it's going to be uh TCP P I think it's close stream yeah like this and then we're going to say here p w done we're going to call done on the w and then I think we have these uh capital vgs at the bottom we going to make them um RW RW why is this what's going on RW yeah I think that's fine and then instead of calling this spe here we could say peer uh close stream like this and hopefully that's uh going to be the same outcome and then we have a little a dynamic implementation without hardcoding Shenanigans yeah I think it's working perfectly fine yes I'm happy I'm happy because this is actually never did this before and for me this is also a nice project to do because like I said guys I'm not doing I never did this before well I experimented with these things but this is the first time I did this in in in a bigger scale all right uh this looking good man this is looking so good um yeah and I think for the next episode because we're already at 3 uh 33 minutes the next uh episode um we are going to handle our get because right now we have a nice and clean way to handle streams so now we can get the file uh if we have we're going to fetch it from our local disc and everything is fine if we don't find it up on our local disk we're going to get it from our other peers uh which is the power of our decentralization right and I think then what we need to do still is um our encryption and I think then we are coming close to the end in the previous episode we let me make run real quick we fixed our uh DCP transport to enable to support streams right for big files and as you can see um we are writing a lot of uh a lot of files to the network which we have uh node 3,000 and node 4,000 and they have all the files we need to distribute which is good but now um that's fine working fine the next thing we're going to do is basically open up a server and maybe on the other side we're going to open up uh I don't know maybe nothing actually this time this time nothing so we have let me put out this this cursor here um we need to fix our get right so let me search for that real quick get here right so basically um we can store that's fine but what we also need to do and we already did that but it was uh a little bit scuffed because we need to fix our our streaming uh option first our streaming support first right so what we're going to do is we're going to fetch a file wait let me open up main to show you better right so we have main here and what we're going to do is uh we're going to make one file we're going to store one file real quick um let's do this we're going to say um cool uh picture maybe cool picture. GP like this and we're going to store data right that's what we're going to do let me quickly delete these folders whe uh fast delete permanently he's gone get him out of here all right so let's do a make run so we just store one file uh like this of course stream close res zooming Rel loop I think we also need to fix one more thing uh because we're hanging and that's not good oh yeah let the select here I see I see I see that's uh no big of a deal so if we open up our folders right now we don't see anything is that okay uh I think it's a vs code book to be honest it's a vs code book because if I LS in the folder here uh we see the the the 3,000 and 4,000 Network so what I'm going to do is I'm going to remove uh the wait we are sending this from 4,000 right yeah so I'm going to remove the 4,000 Network like this not quite sure why vs is not showing this but anyway a little Buck why not so that's fine I'm going to comment this uh out and then we are going to comment this in back back in and we're going to say we don't want to get the private data uh we want to get the file and it's going to be cool picture cool picture uh. gpeg what's going on here geg right that's what we want to fetch so basically we're going to try to fetch this and um we're going to check first of all we're going to check our local disk right and if we have it on our local dis we're going to serve it from our local file from our local server from our local dis but if we don't find it then we're going to grab the network and try to fetch it from one of our peers that's the main goal right um so we're going to get here the first thing I'm going to do is make some uh because now we have support for uh our added right so it's very nice to prefix this with the added of the server so we're going to say uh S transport other and then this is going to be the key right like that let me close this because yes so we're going to get it uh what we could do is basically say here if we have the file I'm going to say let's delete all this junk um serving file from local disk yeah and it's going to be the file which is the key yeah fine fine fine and if we don't find a file then we're going to grab it from the network do that stuff that's all good we broadcast this so we're going to prefix that with a message uh bite that's good receiving stream from P I don't think we need this um maybe we going to do a little time sleep here not quite sure we need to check these sleeps um time millisecond maybe Millie second what's going on here I'm going to say 500 maybe something like that what am I doing what am I doing still sleepy time millisecond times 5 500 that's fine we're going to range to the Pierce uh then we're going to say here uh maybe a print F actually uh we're going to do this percentage s received uh this amount of bytes over the network which is going to be a percentage D in a format over the network and maybe we could do from it's going to be S transport addage uh it's going to be n and then this is going to be P remote adders right that's fine then we can we can print a buffer here but we don't need a buffer actually right we don't need a buffer because we need to store it to our disk but let's try it first like this and we don't need to forget that we need to send um a stream message to this Speer wait so we're going to say get this here um so we're going to receive it here right that B that basically means that we're going to say p uh close stream something like that let's see if this actually going to work yeah let's try this real quick no no no we need we need to send um is looping stuff handle message handle message get file we're going to do the same thing here need to serve file but does not exist on disk so we're going to say percentage s which is going to be S um transport Adder serving file over the network I do the same thing here as transport add yeah yeah yeah let's make it clean we're going to read from store we're going to check our peer and then we're going to copy here right so the first thing we're going to do is peer send we're going to send this um peertopeer uh incoming stream thing like that and then we're going to say here yeah we need to do a lot of uh Clean login stuff this amount of bytes over the network to this guy that's fine and we're going to say it's going to be again as transport others I'm going to return no right okay let's see let's see where we at uh let's see where we at I'm going to make run real quick and see what's going on all right so we don't have the file we serving the file we written uh over the network we have a stream we receive the bytes and then we say um and you can see that we that we fetched it right you see it here of course it's not going to be um in our yeah these these not quite sure what this is what's up with these folders by the way uh if you do an LS uh all we can see we don't have 4,000 because we don't store it yet uh onto our disc so we need to fix it some coffee never hurt gold of the world it is coffee okay so what we need to do I think actually it works pretty fine now that we have the streaming support it it it walks like a breeze um what we going to do is this one right so received what we're going to do is we're going to try to receive from every P that's not the best option because we need to check the first P sending or something I don't know but that's for later on it's F to receive it from HP doesn't matter uh and we can actually do use goroam for this also if you want so we don't need a file buffer and we don't need to copy what we're going to do with s is do something like if um n is going to be s store um right it's going to be the key I guess and we going to use the p yeah and if the error is not n we're going to return an error or what do we return here actually uh a file a reader actually we're going to say null F right uh we don't need the shenans so n is working that's fine we cannot do that we need to do this if R right like this then we have the F this file buffer we don't need this we're going to close the Stream and we're going to stop doing this and then what you could do is return we could actually pipe this into into a t or something so we can write to dis and then return it but the problem is that we are in this Loop so I think a good option is to just return once we're done with this reading is basically just return as store um I think read the key something like that so we can actually fetch that in our mean so we can fetch that he right and actually do we need to select we don't need to select let us see what's going on is let me see what's going on so we don't block here so why are we hanging we are we are hanging let me see but we have the file we have the file in the network which is good um I see I see what's going on uh of of course of course of course remember remember in um wait where is our limit reader you see remember this limit reader where we need to tell uh if we write into the store how much we're going to read from uh from this connection that's the exact same thing we need to do the problem actually is uh the problem that that we have is basically that we don't know the file size yet where are we copying here right so what we need to do uh if we write here we need to make this an IO uh limit reader like this and then we going to say let's say 22 bytes here right you know what I mean because we know it's 22 bytes but of course we cannot pref we can cannot hardcode that I know I know we're going to fix that we're going to say make uh run to see if now everything is working fine let me see it's working fine look at this but we have it we have it we're going to say Adam uh because we serving file from local disc yeah that's good andf we're going to say um actually can we do uh S2 can we remove something from this let's make that real quick to be honest s file server uh remove yeah this remove thing should also remove from the from the yeah that's yeah I see uh what we going to let's let's just do an uh an ad because we also need to remove from from from from all the peers then so that's uh it's going to take some longer than just a couple couple lines so we're going to say RM RF uh going to be 4,000 right because we're sending we don't need this fine let's make let's see received uh receive B of the network what I was testing actually totally forgot yeah yeah yeah you see that's a 20 that's why why I prefix it to 22 so we're going to fix that um there's basically I don't think a way to know the file size if you want to send that right so what we going to do is we're going to send the file size over right here so what we're going to do is we're going to send I'm going to say first sent um first send the uh incoming uh incoming stream bite to theat um first incoming stream to the to the p in uh and then uh we can send the file size yeah I'm we can s the file size and it's going to be uh as an N64 okay so we're going to send a stream and then we're going to say um what is the file size actually we read it here yeah let's let's hardcode it let's send it hardcode it over and then uh remove the hard code here right piece by piece piece by piece so we're going to say uh for example VAR file size uh which is going to be an N64 is going to be 22 right then we going to say uh binary actually yeah we going to say binary do write and we're going to write to the P we're going to say it's going to be a binary a little Indian and we're going to write this file size like that so we're going to write that as binary and then we're going to copy that right so now we need to fetch it on the other side let me find for 22 here uh so the first thing we're going to do is um need the file size so we can uh limit the amount of bytes that we read from the connection so it will not keep reading or hanging right that's what you're going to do so we're going to say v file size uh which is going to be an INT 64 like that I'm going to say binary can we read that yeah binary read did be a binary read we need to do a binary right did we did we do this correctly yeah B righted okay okay okay okay okay okay fine fine fine fine fine fine you did it like it okay here so we're going to say binary read we're going to read from the pis connection we're going to say it's going to be a binary uh little andian and we're going to take uh the file size like this and then we're going to say here uh file size right so we removed the the the hardcoded stuff here yeah okay let's delete this again um minus RF 4,000 not 3,000 because yes like this and make run and see all right all right right right right looks good looks good Okay cool so let's open up 22 here so the problem at this 22 is that we need to have the file size to send it over the problem is the only thing we get from read is basically a reader so you could say yeah why don't we read it into a buffer and um get the file size but I don't think it's a good idea because I need to read it into a buffer and and it's just nasty so I think I'm going to open up store here and I'm going to open up uh the read uh stream do we have that guest transform Funk read stream is this one where is R stream damn it just open right stream read stream um is this actually a good way because we this is actually I think we are reading this into memory to be honest instead of piping this directly to we need to fix that um I'm going to say uh instead we first copy this in to a buffer maybe just return the file from the r stream yes so we have this here right and then we have this this this read closer which is also a reader and then we copy it first so why don't we why don't we directly why don't we remove this right we could remove this I think that's an important aspect we're going to we're going to fix that we're going to fix that it's good that we have this uh this to do here um maybe fix me actually all right so what what what we going to do here is um we we have this n right we have this n so we can return the amount of bytes we we have but the problem is the problem is that we if we not going to use this later on then we don't have this n so we don't have we cannot return a file size so what we could do is in this read stream we do an OS open here on this full pad can we do an OS stat uh full Pat with a root and if yeah is not n we going to return n what's Fe do we have an S size or something we have that's amazing all right so what we're going to return here in a read stream we're going to change this a little bit up we're going to return uh a size which is going to be an N64 uh an iio read closer and an eror I'm going to do this and I'm going to say that the file uh erors going to be this can we do file size wait let me have let me do this um or does it return uh we're going to return here zero nil s it's actually a little bit nasty you're going to say Fe add is going to be stat you're going to stat a file uh not not quite sure why there is an error if if you already open up a file and then you st it by uh uh it's going to return an arrow to be honest so we're going to say return the same thing 0 nil Ed right uh and I'm we going to return uh Fe size file no that Mak sense of course our test are going to be broken I know I know I know of course this read is going to give us some issues because that's going to be n and we're going to return also an uh N64 here right uh we could do n here that's fine fine fine this is crazy uh let's let's fix this I don't like this we're going to say n uh n a store read right and then we have already an N uh let's make it size or file size maybe maybe that's even better file size we're going to delete this we're going to copy the file size here yes uh something is wrong in Ser of it not quite sure what it is let me do a make real quick uh 89 I need to sneeze I'm so sorry live on video live on video my bad I'm not going to cut it man I'm not going to cut it hey like I said this is the live off you know what I mean this is the real deal it's that's the real deal I love you guys all right so are we go I don't think we're going to return this uh what we're going to do we is basically uh do this read a and then we're going to return at uh read it at right something like that maybe maybe maybe we return the file size I don't know I don't know could be could be uh 122 the same thing right what is this get yeah yeah yeah I see I'm going to return store here um and store read is going to return us this thing a no uh reader a and we going to return add reader right something like that um so I think now everything should be not hardcoded from local disc I see I'm going to add them RF 4,000 yes make run see if we get it from uh the network yeah yeah yeah man this is insane this is insane so that's fine so what I want to do with this binary read stuff uh actually I was thinking maybe we should abstract that but to be honest I think it's pretty fine I mean a little bit of logic is is fine uh multi writer we need to fix that it's a TOD do or to fix me let us see in our test real quick um do we have a store test yeah yeah here right stream right s read is going to return us n what is Right stream do we need what's it going on with this I cannot initialize one variable with two oh yeah that's returning in um an add also yes test are working fine that's already taken care of all right the next thing I want to do is um is this I'm not happy with this read stream because we do this file yeah yeah that's fine but this is is bad this read uh you copy it here why do we do this actually why don't we just return right we could actually just return this because we don't close the file it doesn't matter right we could just do this right look we could actually just do this and actually get rid of one of these functions we could just return as readstream uh the key like this the question is are we going to this should be better actually that works perfectly fine now it's going to fetch from from local I hope you see what what the problem was right so let's let's revert this real quick you see so we get it from the so we we do R stream right so do we do our Shenanigans we get our file and then what we do is uh we basically say yo I copy everything into a buffer but can you imagine that's a 10 gab file then we fetch it from the store then we're going to read that into a buffer and then we're going to copy that buffer that's not good uh that's not what we want right so I think uh I know it's a little bit weird so we're going to just return the ream here right that's fine so we can remove this fix me already uh of course you see this function has no nothing in it it just returns this so we can maybe if you have a GH right we let's let's keep it for for now let's keep it like that the thing is what I want to do is uh I'm going to search for store read Because this is going to we return that so we return basically that stuff here so in main it's a read so we cannot close it that's why we did it right uh I see that's why we did that so we could close it first eat this one right this Edge so we should actually do like a defer uh a close but we can't what we could do is um can we do this I should be a pointer to a read closing Maybe can we do something like this maybe it that's nice uh yeah I'm going to explain actually I was thinking to to hard so basic what we do is we check if the the thing we fetched uh the the reader we check if it's a read closer if it's a read closer we going to say defer RC close we're going to close it and I want to let me quickly see if we can test that uh make run and we can and we can assert this I'm going to explain real quick closing reos it's fine that's cool so what you could do in go is basically you could assert if certain uh implementations are true right you could say um the read closer a Boolean equals the reader is that a read closer ER if it's read Clos it it's okay will be true if it's not then it will be false and then we don't care the thing is this RC I think I should do it like this if that something like that of course now we're going to fetch it from local so it doesn't actually matter I think yeah yeah it's fine it's fine it's fine all right so uh I think that's good very very very good I think it's actually perfectly working so what we also to do is delete thingy that's so we can remove files we need to do our encryption and maybe uh a separate thing where we do some cleanup and then uh I guess we have our we have our thing of of course you can like I said before you can make this as complex as you want right you can do so many cool features but I think that's a very very uh good practice for you guys on the other side of the camera and where you can have this working thing but you can extend it with with some with some cool functionality you should you think it should have right because like I said we can keep developing this for months and make it better and better and better and better but the question is where does it end right so we're going to do a couple things more so it's it's it's going to be good and robust and uh after that we can close that series and we can start another Series so the previous episodes we can store files we can retrieve the files we can retrieve them we can store them dist uh in in a decentralized distributed way we can retrieve them um from our peers if we don't have the file locally it's all good we have stream support now for our TCP uh Library uh peertopeer Library by the way and I think it's a good time to implement encryption right because um as you know if we going to if we going to store the file and we're going to store the file in on other peers in the network we don't want to store the plain bites we want to encrypt it with an encryption key that we and only we have so um if you want to retrieve the file we can decrypt it back and we can see the contents of it right so um of course you could say are we going to encrypt the files if we store it on or disk you could you could and maybe you should uh not quite sure if you're going to do that uh but we are going to make sure they are um encrypted uh that they are stored encrypted on our PS of course they want they don't want to see our nudes right so um so what we going to do is basically and I'm going to I'm going to look up some documentation for that uh while I code it because uh it's it's you don't do this any every day right so you cannot know this uh on the top of your head the first thing we going to do is actually let's delete these to bad boys and then we create a new file we're going to make this uh crypto go then what the hell is this what am I doing uh crypto go like this let's close it yes we're going to say package Main and then we going to call this as you can see in our storage right I think we also have something like iio copy uh like this right so we're going to make something like that a streaming a streaming way so uh the very important aspect is we are not going to encrypt them in into memory because like I mentioned before we are supporting streaming that basically means that we don't need to uh read every single bite that is being transferred into memory with only a portion and I think if you want to know how much that's going to be you can see copy here we do copy buffer uh and copy buffer basically here here here here so you see that the size is going to be 32 times uh 10 24 right that's basically the buffer that's the maximum amount we are going to read into memory and we're going to do something similar uh with our function and I think we're going to call this um copy encrypt encrypt like this we're going to take an key which is going to be our encryption key it's going to be a bite we're going to take in uh a source which is an IO reader and we also going to take in uh a destination which is going to be an IO writer like this and I think we're going to return the amount of bytes that being written and very important this normally you should say we're going to read and and then we're going to encrypt and write but we're not going to uh have the same bytes written as wrote it as wrote write and read I don't know what the the correct verbs are but we are going to write more buys and we read because we're going to preent or IV which is a a cipher thingy we need that for our encryption right uh so going to say it's going to be an INT and an error like this right okay cool so I'm going to I'm going to a little cheese a little bit uh I need to look things up so I have some documentation here and I will link the documentation in um in the description on of course right so the first thing we're going to do is I think we need a block uh R which is going to be AES we're going to you a we're going to use AES encryption and it's going to be AES rather you're going to say new Cipher is that yeah new Cipher and that's going to be uh we're going to give our key that will return as a block a cipher block first of all we're going to say if the error is not nil we're going to return actually could be ah let's let's return zero and an add here just like that now we have a block let me quickly see if I'm actually recording it's not the first time I'm doing uh these crazy shenanigans it's all fine then we have a block here and we're going to need that block because we're going to create an IV which is going to be and that's the thing we're going to store actually we're going to say make a slice of bite which going to be a block block size and I think this is going to be 16 bytes uh not sure 16 not quite sure if that's true we will see we will see so we have this IV the next thing we going to do is um fill it up with random bytes we're going to say if underscore R is going to to be IO read full right and we going to pass in a reader which going to be a random reader right like this and then we going to say IV uh and if the error is not nil then we're going to return zero because we didn't wrote anything uh and the error here that's fine let me scroll a little bit down to see what what the next thing we need to do uh right we need to make a buffet and a for Loop so we're going to for Loop here right but first of all we're going to make a buffer and a buffer is going to be uh make me a slice of bite and that's going to be 32 * 10 uh 24 which is basically this thing here right that's going to be the buff that's the maximum amount we're going to copy in memory and I think I think I think we also need a stream which is going to be a s is that um we're going to be a cipher actually new CTR okay not quite sure what it all is uh but we need a block and the IV here so we can we can have a stream and actually you could do a VAR to make it a little bit cleaner like this all right so now we can start reading from our uh from our source right we're going to say not got sure if you need the N first of all let's do n yeah we need to n we need to n for some checks actually the amount we read we need that we're going to say here it's going to be Source read we're going to read everything into the buffet right yeah if there is an error I don't think we're going to check the error yet we're going to say if m is bigger than zero that's important and then we're going to say stream uh exor stream that's what we want and we need the buffer and then we also going to say uh the buffer and the buff with the amount of bytes it's going to be yes this right the amount of bytes written uh R actually amount of B red and I'm going to say that the uh destination we're going to write the buff and yeah yes yes yes yes we're going to write everything this stream is going to write everything into this buffer let me quickly see what uh uh bite each bite yeah that's what he wants each bite yes yes yes it's going to each B each bite it's red I'm going to place it back um and and then and then we write uh the thing the encrypted stuff into our destination yes of course we're going to check this uh with an error and if the error is not n uh then we're going to basically return zero and the A and we going to do the amount of btes written later on to be honest what is this this is going to be perfectly fine and this error is here so you're going to say first if the error equals an IO end of file then we're going to break right we're going to break then we are we're done reading and then we're going to check the error so if the S um is not M then we going to return the Ed right yes okay and then here we're going to actually return we need to return some some value we're not going to do that uh quite yet we need to return the amounts we wrote and the thing is that um we also this IV is very important right this thing this IV needs to be in the file because we need that for decryption so what we're going to do we we we could do two things we can either store it and we can append it to the bites or we can prepend it and I think I'm going to prepend it so enable to preent we could say preent uh preent di IV to the file so we're going to say if underscore add is going to be the destination so we're going to write the IV just plain by so we can write it like this and if the eror is not n then basically we going to return zero and the F right and then we're going to start reading yes yes we're going to start writing to the file after the IV is uh inserted Okay cool so let us open up um actually let's make a test right that's going to be a good thing I'm going to say Crypt test. go package Main and we could say test wait Funk test uh encrypt test copy encrypt the uh testing do T what's going on here guys yes save it cool so what we could do is basically say uh we're going to have a a source right and that's going to be uh a b new reader uh new reader like this and we're going to say it's going to be bites and we are going to encrypt um f not bar something like that and actually yeah it's fine and I'm going to say out or a t actually a t and that's going to be a new bytes buffer like that and then we going to say um we could say NF is going to be a copy encrypt I'm going to say I think we need a key actually yeah we need a key that's a problem we don't have a key let's make one let's make a key we're going to say funk and new encryption key uh encryption key and it's going to return as a slice of bytes uh we're going to say how we going to do this I think we can say that the buffer is going to be key buff going to be make me a slice of bytes it's going to be 32 or something uh and then we going to say um I read for full rant reader into the keyb and then we can actually return the key buff bytes we don't need to we can actually just return it like that so then we have a key buff do we is this a capitalized no it isn't uh new encryption key like that then we're going to say the key is going to be here we're going to say the source is this and then the destination is that file and then we're going to check if F uh is not nil you're going to T error the error the F this this n is going to be zero anyway so we're going to skip that for now and what could do is basically fmt uh print Ln and we're going to say that the destination uh bytes we're going to print the bytes out and let's run this test real quick here all right so we have these encrypted Shenanigans which is cool uh one more thing I actually want to test is basically this one uh Funk Test new encryption key t testing l t and we going to say key is going to be new encryption key and we going to say uh for the length of the key first of all we could uh F key y equals can we do this is that a thing not quite sure if you could do that um zero bytes not quite sure oh we have it now the question is I think these keys are fine to be honest but I don't I I cannot check it with zero btes right because I could actually do fmt wait I could print out a key uh all the time of course there will be a zero bite right you see I think this key is fine to be honest um I don't think we need to test it it's fine because there will be zero bytes doesn't matter okay so test copy and crypt actually what we're going to do is copy uh test copy and crypt decrypt uh like this right so the next thing we going to do is copy decrypt that's the next uh function we're going to make we're going to say actually let make it at top that's be better for you guys to follow along we're going to say copy decrypt uh we need a key for sure it's going to be bite and then we going to say that the source is again it's going to be an IO reader and the destination is going to be an iio Rider and then U we going to return an INT of course again and an error and we need to fix these inss uh these bytes written and red soon all right not quite sure what we're going to do here do we need a block again let me quickly speak and Peak my um my thingy uh I think we need to block again right so we're going to copy this we make it the block with the key that's what we need now we need to R IV VI IV from the given uh IO reader uh which in our case uh should be all right so RV from the given I reader which in our case should be the block size bytes we read yeah uh how we going to do this so I think um so we're going to say something like this IV is going to be make me again a slice of bytes which is going to be a block uh block size like this right and I'm going to say if underscore R is going to be the source read me this IV um at not n then we going to return what's going on here uh zero R now we have an IV all right and I think we need to for loop again um now we need again this block right is this stream once again and it's buffer also so I'm going to copy this this I'm going to paste it in here buff stream that's all fine then we're going to do the same thing right we're going to say um n s is going to be Source read into the buff if there is an if n is bigger than zero we going to stream. sour stream I guess again the BFF and the buff um n and then we're going to write the encrypted things the the bites we encrypted back to D we're going to say d right if uh it's going to be NR d right the buffer but we write the buffer what we are what we have read actually encrypted and if the error is not nil then we're going to um caping caping locking we going to return zero R right and then the same thing if add equals IO end of file break if as the thing is could we actually not reuse this wait a minute no we can't right because we need to R the IV in this case some stuff we can actually uh split out because we're copying we copying too much uh uh stuff here but the problem is that a lot of things going to change because we're not going to we will see we will see uh not the end of the world not the end of the world right so what we're going to do here is basically we're going to say let me open up back my OBS so I can see what's going on here uh yeah yeah yeah we're good we're good we're good okay so what I'm going to do here is basically um so we have this this is destination we have our key we encrypted here then we can say out it's going to be make a new Buffet right and I'm we going to say that uh if underscore R is could be decrypt T no what am I saying with T it's going to be the key Source no it's going to be the destination right it's going to be the destination right this destination is going to be the encrypted file and the source is going to be well the new destination is going to be out if that makes sense Arrow out and then we're going to say out and let's make a string here so we maybe we can see what we because our our our encrypted stuff is basically F not bar right and maybe we should also print out the encrypted heat right and the encrypted heat in this case is going to be the destination uh destination string and then the actual string the decrypted string I hope it's going to we need to test actually can we do this let's just test here yes so you see it's working right so we we encrypt it and then we decrypt it and we have F not part which is good it's working and our tests are pausing actually uh what actually passing we need to say if um out string uh is not equal to actually it's going to be F not B right B payload now we can check it actually out string should be the payload T error F expected um encryption field I I don't care I'm going to say encryption field actually decryption field actually all right it's going to that should actually work all fine so we're going to do make test real quick boom everything is fine let me test this here boom uh pass yes yes yes good good good uh so we're going to delete these things uh wait like this yes okay encryption Done Right nice eses encryption uh copy streaming support and I was looking for some coffee but I don't think I have one maybe a little bit it is what it is a little bit caffeine okay so what there's a little problem right so I'm going to I'm going to tell you what's the problem going to be because if you go to server right and this copy um I think what we are doing wait I think also in the limit read there is going to be a problem yes so it's a message size right but the message the me the message is size like this right for we have this is basically 1 2 3 4 5 6 7 8 9 10 11 right uh it's going to be 11 bytes the problem is that the destination file the encrypted file is not going to be 11 bytes it's going to be 11 plus 16 bytes because um we put our IV right we we we we placed our IV into the file the first 16 bytes normally right so how we going to do this if you go to crypto real quick because if you check this n wait let me let me test something so we're going to do this copy and crypt you're going to say uh fmt you going to say print right and going to say print L Len uh payload right so if you send it's it's not it's not going to be boom it's going to be 11 right so it's 11 bytes that's fine but if we print the Len uh this Len out string wait that's basically the same thing wait I'm still stupid I'm stupid you're going to say print alen the destination right the destination is basically the destination of the encrypted stuff wait we cannot do it like here we need to do it here boom you see it's 27 right because that basically means if we do 11 minus 27 have 16 right so the IV is 16 and we can test this by doing um Len block block size right what cannot do l uh print without the fmt why not wait we don't make we need to we have this tested actually boom you see 16 right so that's fine so how we going to make sure we return uh how we return the same thing we're going to only check what we wrote so we're going to make an NW n written is basically zero right it's going to be uh it's going to be block block size all right and then each time we're going to write here it's going to be an NW h I don't like this to be honest because we have an N already we have an NW already so uh we going to say this is hard how are we going to call this this variable NN or something I don't know uh going to be NN and here we did our best because we wrote here right it's fine and and so we're going to save that n w plus s NN um what's going on block size in 64 uh and what is this ell is going on oh yeah see I'm I'm stupid um and we going to return and dou you right but that's only in in in uh copy decrypt right uh so we could say this and this is going to be 16 we going to quickly test right we're going to say 16 times basically it's going to be l uh out string we can actually say Outland right yeah but that basically means I'm going to say l payload to make it sure can I say t fail or something like this man I it I mean um all right so that's working fine right I know it's it's it's a bit nasty that we doing this thing because it's important that we return these bites because we're going to need them to send it over right we going to need time to send it over because if we using uh server right let me say it's store you want to say we store a file then we have a then we have basically here because this is locally right this is locally so this size is going to be in this case uh 11 right but then we're going to broadcast y y y and then we're going to say here uh there going to be a stream and we need to REM we need to can we just copy this this because we're sending that it's going to be size it's going to be encrypted so we need to say here plus 16 right what's going on here I'm losing my slipper I'm losing my slipper um so we're going to say plus 16 and I don't like the way this is happening because it's a hardcore thing so maybe we should and we don't can unless this size is going to be 11 right so uh 16 it's going to be fine I guess and this needs to be a copy encrypt right so we're going to re we going to first first of all first of all we're going to say our server file server file server options actually and we're going to say that the an key which is going to be a slice of bytes right uh yeah slice of btes like this and then we going to say yeah okay okay okay so we have an Angy and then where is store here what we're going to do then is basically we're going to not use this but we're going to say n r is going to be copy encrypt right and it's going to be the s n key it's going to be the destination The Source what's going to be the source the source is going to be where is that file buffer this is the file buffer here this is our T reader we use for teing here which will then write in file buffer so the source is in the source is the file Buffet yeah and then the p is going to be our destination yes yes yes it's a little bit different then copy works because copy takes in uh the destination as first as first argument in the function right so we can return F in this case and then we can say receive B is this going to work I have no clue let's see let's see uh make run I guess wait wait wait first of all first of all guys very important we need to have an N key in file server options we're going to say um the encryption key it's going to be new encryption key uh let me close up this thing and make run and see if we get encrypted files please let it all work just fine oh yeah yeah of course we are our main is basically we are fetching stuff but we we cannot fetch anything because we don't have anything right so we're going to just do this make a cool picture thingy sleep 5 Seconds no idea why we do that make run and see if he can store that file you see that we received and written by dis is zero Z okay and actually guys I found something like remember in previous episode we had this issue with these folders but you can just click refresh um so we were 4,000 right so do we have our file in plain text yes we have our file in plain text but do we have our file distributed encrypted yes it's encrypted hey that's good right um that's a very very very very goody okay um that's all good that's all good but we had one issue and I think it's basically because we let's open up Krypto I will open up here bytes written to disk because if we decrypt you're going to tell how much we decrypted wait why I'm I'm in the wrong crypto no I am in the right crypto it's fine it's in copy and cryp right that's what we use I think we can we can do the same thing we could say uh this is going to be block and I think we we can make this function even better what's going on oh we cannot do this block size what did we do here NW and then it's actually the same actually the same code we need to be we're going to split that out uh we're going to write to the to the Tangy we're going to say NW is going to be plus equals nn and in this case we're going to basically return uh and W right so basically um we're going to store it right now we should have the correct output that we received and written 38 to the dis that's actually not true because we're not encrypting it maybe we should encrypt it locally um because we're going to write you're going to if we copy and crypt right what do we mean by by this int that means that how many bites that we copied and encrypted right so in this case copy and encrypt it how many why is it we copy and encrypted that's basically H it's it's it's difficult because this block size we actually have the the IV in the file so but we copied only the file size yeah that's something we need to think about uh we're going to see that because in the next uh I'm going to cut the video out here me if I'm wrong but I think if I do a get lock the previous episodes we did encryption and decryption of our files and I think that we basically yes we could store things and um let us actually rerun this real quick um let's delete these two bad boys H and then we can just say a make a run and see what's going on normally I think it should be distributed and uh let me refresh these folders here we could we going to have 3,000 which is going to have nothing uh and this guy what is going on here we have a little issue is that what is going on here what a nice what a nice way to start isn't it a it um is that a thing what do we have here nothing all right no worries no no worries make run let's see what's going on no Panic we don't we don't choke uh stream closed resume resume that's a thing that's a thing so 3,000 doesn't have the files it it has it has what what's going on uh let us delete these two guys once again delete permanently maybe it was just I don't know so basically right now we don't have any file right no folders no not then that's fine uh let's make run and normally everything should be distributed right M run let's see let's see what's going on let's see what's popping all right received received this this is better right this looks better so we have this guy which is encrypted and then we have this guy which is Al which is not encryp because it's our local dis okay cool not quite sure what happened there I think um I don't know maybe we have no clue let's not worry about it right let's not worry about it okay so the next thing we need to do is basically find a way to retrieve these guys right um and if we open up server on this side and maybe main the other side then we're going to see that um I think it's handle get file is that a thing get get handle get file here this one uh we do a copy here but this is sending right so we are sending the file that's fine right if you get a f yeah yeah yeah I think yeah it's it's get right if we ask for a get here right and we cannot find this on local disk then we need to basically fetch everything from um store right that's a thing right so we going to fetch the files we're going to write but the problem is we're going to we're going to fetch these files in in an encrypted way so store right is not going to work here right so we need to open up store and we need to uh search for right this guy right and right is calling right stream uh but right stream basically just copies here right you see this this IO copy it basically just copies what it gets and that's not good because it's it's encrypted we need to decrypt this so we should replace this with decrypt uh copy decrypt uh the thing is maybe I want to do something like Funk um s let you see that I'm not coding in my uh window we're going to say right decrypt uh which will take an eny uh there going to be a slice of bytes it's going to take in a key which is a string and of course an IO reader uh which will return an N64 and an eror just like this and to be honest everything is the same right you could uh copy the whole ship bang it's only this uh of course we need to make this a little bit better because just copying this is uh maybe not the right idea and this is going to be I think copy decrypt uh but with uh ank key and we need to be careful let me open up crypto copy decrypt takes in a source and a dust the source is uh R and the d f is a little bit different than IO copy and of course I think this F this n is going to be an N than N64 uh which basically means we could do something like this in 64n and then of course the error if there is one so we could check that yeah I'm going to we're going to refactor this real soon but because there's a lot of duplication going on here you see it's the same thing here you could actually just delete this right and just return uh these things actually can we not just return the whole thing look at this it's basically the top part that needs to be refactored yeah okay so how we going to call this right is we have this right Crypt uh so what we could do is basically say something for let's let's let's just test this real quick and then we refected this right so let's do a right CP let's make it public right I'm going to make it public so instead of saying um what is this this crypto we don't need this instead of saying this store right we're going to say n r is going to be s store right decrypt right it's going to be the eny S eny and then we need um the key itself and I'm going to say an iio limit reader and it's spe and of course the file size like this I think you can delete this just the top part actually and now we have the same thing right I think that should be good is that true do we have all the files here yes we have this encrypted sting uh uh so what you could do is delete 4,000 right now we going to comment this out and then this let's see what's going on if we make run ah so it's it's it's yeah I see I see we get we get some stuff we get some stuff but we get encrypted stuff and I think the problem is the problem is actually the problem is this yeah it's this thing it's this new encryption key that's the problem because uh each time we boot up this make run we're going to make a new encryption uh key which basically means that if we have stored something with another encryption key it's not going to it's not going to work out fine for us because it's going to end it's going to decrypt it with a different key right uh so what we could do is basically we could say um let's store this right and once it's stored we're going to say if R is going to be S2 store delete um we're going to we're going to copy this everything inside of these brackets of course we need to we're going to say that that is the key we're going to delete it here we're going to say key here and then we got to say get the key not not get the key yeah we're going to get the key but we're also going to delete the key but only on the S2 um server and if the error uh is not n we can um what's going on here I'm going to lock fatal I guess like this right so we're going to we're going to store it we're going to delete it at on on our side and then we're going to fetch it again so it should be uh coming from um the network so let's delete these two guys now let us see what's going on it let's make and see what's going on I have no clue normally it should work I think it's working right if you get it yeah it works perfectly fine what's going on this is insane uh this is encrypted yes yes yes and this is uh my big data file so that's good it's all working perfectly fine the question rather is can we do all right that's good that's good um all right so there a couple things we need to do we also have something in server we need to fix I think we have a todo here yes use a multiwriter which is a little bit um better and then we have this thing right so we need to check uh what's going on we have righty Crypt and then we have a right stream um wait what is this uh we could say s store open file file writing yeah why not you're going to say key do we need the key yeah we need the key it's going to be a string do we need the iio readers I don't think so and it's going to return I think it's OS file as a pointer I guess and maybe an error and I think it could do this right we could uh yo actually delete this paste them here um which we actually then just could return this all right and then we could say f is going to be S open file for writeen uh we need the key right if Ed is not null you can return zero and the errors right and then we're going to return iio copy with this thing which is fine what is this uh we could say n all right and with right decrypt you could do the same thing right we have this copy decrypt this is the complete file we could delete all the sh bang here I could just say FF is going to be open file for writing is going to be the key that's fine uh return zero Ed and then we can do this thing is this going to work perfect I think I think it is this this basically uh eliminate some some some code duplication which is fine my big data file here this is going to be exactly what it is yeah yeah yeah okay cool that's fine taking care of that so right will go right stream um one more thing I want to actually change is basically this right we could do an eny in this we have right and then we have right decrypt I think it's fine write and right decrypt let me copy this real quick uh right stream I'm going to copy these guys and I'm going to paste them below this right because I think that makes a little bit more sense we can call right we can call right decrypt um and it's working perfectly fine so the next thing we going to do is fix this todo so basically what we could say is that the Pierce is going to be uh a slice of iio writer right and then we going to say 4ore p in range as Pierce and then we going to say that Pierce is going to be a pent uh Pierce Pier like this right and then we could do something like um I'm we going to say that the multiwriter is going to be an IO new is it multiwriter well mul writer I'm we going to say yo all the peers here like that and then we're going to copy this um but we're going to say it's multiwriter and we're going to write this bite right this incoming stream so we can notify every single writer that we are basically um sending a stream by notifying them and then we could do this right we're going to copy this copy encrypt we're going to yada yada file buffer and instead of this pier we're going to say all the peers right uh so we're going to delete this and then we're going to print out that we receive to dis maybe we going to do a print F do a percentage s here and then say uh maybe a new line here received and written you could do this percent D bites to disk and then we're going to say um S transport other like this multireader it's fine millisecond also good let's see if this is going to work uh make run works perfectly fine also fixed uh the next thing I want to do is basically instead of doing um let us let us test how far we can get this thing let's let's do uh maybe 20 or something uh let's paste that in here the key is not going to be this cool picture we're going to say that the key is going to be an fmts uh print F and it's going to be let's do picture underscore percentage d which is going to be the Y do we want jpeg BNG it doesn't matter uh 20 times um all right I think that's good so we're writing 20 times over the okay okay uh now I want to see what's going on here in our folders uh a I see some issues what's going on here this is UN kept it that's fine wait do we need to ah ah that was a l refreshing look at this we have all these files here because we are creating 20 30 files um yeah let me see what what's in here all right so we this file cannot be displayed uh yeah it's fine we cannot see what's in there that's crazy yeah I see some encrypted files right yeah cannot open it Y is because uh maybe if there's some character in it a special character that vs code cannot grasp and then of course and these things should be should all be the same thing my big data file right and all these things right yeah it works it seems that it works for me um that sounds pretty good uh let me quickly see all right so can we do some optimizations right that's the thing not make run I want to go to server right something I really want to test um actually what I want to test is if we go to main. goo right why don't we add another server right we could say another server is going to be S3 it's going to be make me a server and that's going to be a port 5,000 and we're going to connect with 3,000 uh of course the what want to say is that we need to have there's not really a way to uh automatically connect to all the peers I know I know normally you should have some peertopeer um protocol where you ask for the other peers so you could um do peer Discovery and once you get one peer it sends its peer list and everybody is connected right just like I doing in the poker game um on stream right that that thing poker game has that um that's something we also could do the question is do we need to do maybe we should maybe we don't could be a good exercise for you guys to implement this um because if we really want to make this distributed we need to do some some extra stuff right and then we need to broadcast uh we're going to broadcast is that's true um so we have S3 right so what are we doing here we start as one let's start S two let's start S3 S3 is connected with everyone right let's just test that uh first of all what I want to do is um let's get rid of these folders real quick let's delete them I'm not quite sure what's going to happen here so we have all these folders uh be bu up as three at Port 5,000 we connect with three and four so this can be interesting this can be interesting I'm going to run it and see what's going on just YOLO of course it's going it's yeah I see that's because uh that's because we need to wait here a little bit maybe one second I have no clue if that's going to work question refused who is this guy dialing 4,000 who's dialing 4 oh it's this guy uh what's going on what's going on what's going on wait do I have a yeah I see I'm doing this this should be as three S3 S3 that's going to work stuff is happening so that's good I'm curious what's going to happen actually uh let us refresh this boom we have three folders and we have three folders We have this 3,000 we have 4,000 has nothing in it because he has some issues and 5,000 is is doing its thing 5,000 should have the files and 3,000 should have the encrypted stuff which is very good the problem is this 4,000 guy what's going on why cannot why why does he why cannot can he not play with us so we make a server right what's going on with make server actually let see next server transport options y y and then we're going to dial probably but we're going to dial we wait a second then this guy and then three is starting here uh is this is this not enough I should be enough I should be enough why can I not connect collection refused who's dialing actually why is it refused why is it refused what's going on my neck hurts I don't know what's going on um they are dialing it's the transport where do we do this the stream thing can can can actually be remove we don't need this anymore good that we see this so we have a new file server we have broadcast get I think it's somewhere at the bottom onp Loop handle message boot up Network so we're going to boot up all the networks what we could do here is actually uh do a print F and make this a little bit better we're going to say percentage s uh so we know who's who's who's doing who's doing stuff uh attempting to connect with remote uh it's going to be percentage s and of course we're going to do a new line and it's going to be S transport other and it's going to be the edit just like that let me quickly see who's calling who uh wait wait wait wait it's the only stuff I know yeah so 5,000 is attempting to connect with 4,000 and attempting to connect with 3,000 that's fine it's it's um it it feels like um 4,000 is not starting on a port we have this uh listen to 3,000 listen to 5,000 why is 4,000 not booting so for some reason 4,000 is not booting up although we do it why we say as to start we don't care about this right we care because S2 is going to connect uh it's going to connect with one so we need to sleep a little bit uh yeah times uh I think millisec millisecond is fine to be honest unique millisecond yeah no what am I doing actually what the hell is going on uh 500 or something s to start we do listen and accept and boot out the N the network right I don't understand why it's not booting up you see the TCP transport listening on Port it's not working what am I missing let's do 8,000 or something I don't know no not 8,000 8,000 is a is a is a nasty Port um seven it's not call it it's so weird what's going on TCP transport listening TCP transport listening but 7 of course we cannot connect with remote 7,000 because it doesn't boot up okay this is crazy let me open up server fmt uh I'm going to say print F right we're going to say this guy percentage s starting file server on Port actually we don't care because that's support right starting file server maybe a new line S transport other let's make run and see what's going on starting file server listening starting file server listening what do I miss something do I miss something yeah of course I see I don't want to let us quickly do uh let's return here right let's do a return here so we don't interfere maybe it's just coming too late to the party I don't know I I can't really see it maybe you guys already saw it let let let me also select here uh select this is a nasty one not going to lie you see it doesn't want to start what's going on am I missing something S2 S3 S1 S2 ah of course of course we blocking oh no oh no a I'm Legit Garbage Guys Ah that's the cool stuff that I'm uh of live recording like you can see how many stupid mistakes do you guys already see me man I'm actually I'm a fraud what the going on oh so it's so stupid it's so stupid it's funny the problem is we do like this this this is what we had right the problem is this S1 start is basically blocking right this is blocking um is this blocking right so I still cannot start because this is guy is blocking so what you could do is basically do something like this right um can I do go lock fatal then we going to sleep and then we going to say uh go this one I'm not sure if it's going to work probably it is and then we going to go start the third one and if you make run this and you're going to see that they all booting up um what's going on can thing is can we do this that's the question do I not need to do let's do this and do S2 not quite sure okay cool that's that's what we want to see now we have five right so everybody's connected that's cool yeah yeah yeah okay cool that's what we need uh we finally have so now we have a 7,000 actually what we going to do is um delete all the folders here right how do I do this select this one this one and then delete permanently boom let's get him out of here all right let's do a make run let's going to see what's going on so everybody's connecting 3,000 7,000 4 5,000 yes let's go uh then they serving yes the serving Shenanigans pictures the whole shebang uh let us see let's see what's going on because we're not sure so we have 3,000 not quite sure where's this guy encrypted stuff five not quite sure if 5,000 has something uh to be honest yeah he has file seven I don't I the stuff we did it we did it of course of course of course I understand if you're really really going to dig deeper um there is no peer uh peer automatic peer Discovery hey I know there's no automatic PE Discovery um but but but he it doesn't need to be it does it does it does need but for the sake of this tutorial to discourse this series uh I don't think it needs to be because we can take this so far and then within four months we are still developing this stuff right so I'm happy it's working perfectly fine it's distributed we can get files um it's encrypted because we are S2 on our disk it's not encrypted and all the other uh notes and Network have this distributed encrypted so it's all good it's all fine uh I'm very happy we are reaching the end ladies and gentlemen it is what it is sometimes um we cannot keep going forever but uh a couple things we want to do I want to put the dots on the why you know what I mean so um yes yes yes yes yes let us see let us see let us see Okay cool so first things first let's go to uh crypto right this uh what is this new encryption key copy decrypt and all that good stuff right so what what we see here is basically um we have this for Loop right it's basically a copy Loop and this copy Loop is basically exactly the same as this uh copy Loop right so we should refactor that a little bit because uh duplicated code is not sometimes it can be good but sometimes it's bad news so what we could do is basically make a function why I have two copies here uh let open up server it's fine so what you could do here is basically say um I don't know maybe copy stream or something copy stream and then we're going to have um we're going to have a good question I think we have a stream which is going to be is it a cipher Cipher stream yes it's a cipher. stream I don't think it's a pointer we need a a source file which would be an IO reader and we also need a destination which going to be an IO writer we're going to return Le an INT and an error and I think we also need a block size uh we're going to say block size which is going to be an integer I guess something like this right and what we can then do is basically copy uh this uh bad boy right here and paste it in and we going to read the buffer oh wait we need to copy the buffer also I think uh this block size actually I'm going to copy this whole thingy and paste it in here the stream we don't need and this can be the block size and then we can actually return what's going on we can return this NW which is uh n wrote and write it and probably nil here right and then we have this nice copy stream yes yes yes and then we could do something like let's comment this out before we going to delete this I think we can actually return that stuff you can say copy stream which is going to have a stream name a block size a source and a destination and this buffer can be deleted we don't need this actually we could do just that return delete this yes and we could actually do the same thing we can um copy this we can do the same thing with encrypt return this delete the whole She Bang here something like that or something like this I think that should be fine is this going to work uh let us test real quick make run and see what's going on and in the meanwhile I'm going to sip my coffee all looks fine based on the the the log the loggings in the terminal I think it's fine so we want to delete this boom boom all right so that's being fixed now we have this nice copy stream which basically um prevents us from duplicating this copy code which if we need to adjust something uh we only need to adjust it at one place all right the next thing I want to basically tackle is um if we store a file right if we store a file uh we need to provide a key and if we store this on our own um storage local storage local server local machine it's fine that we say hey store for example um mind n. gpeg but if we basically going to distribute that we already encrypt a file which is which is fine nobody needs to see NES right but the problem is it still can see we still put the the key the name of the file the key in plain text so they can see what it is and that's also not uh a good uh practice right so we're going to fix that and how we going to fix that is I think we could do maybe we can do it in crypto by the way in this file new encryption key we could say funk for example uh um hash key key string returns a string for example and we could do we could do any hashing function we want we could even make this an interface we could say for example the hash is going to be maybe an md5 sum of the key it needs to be bytes right so let's make it a bite slice what's going on here my cap lock is turned on and then we can actually return a hex uh and go to string of the hash and do it like this so we have a nice slice there's basically a simple function which will hash the key in an md5 which a oneway a oneway hash function right so there is no way they can um you can even make it a sha 256 whatever uh but there's no way that they can see what's inside of um of that hash only we know that so we could do uh if we going to store right and we going to say if you want to distribute this message right this thing here we could say uh instead of the key we could say hash key uh put in the key and if you want to retrieve that all right if you come from local storage can be the key the plain text but if we uh want to fet this then we need to basically hash it again so we're going to say hash key like this make a run and that should actually be the same thing although it's going to have another pattern but that doesn't matter because it's is going to fetch it anyway right yes yes yes uh Clos and all that stuff Big Data file is coming out everything is working as intended so that's fine um all right the next thing what we need to do is we have we have actually a problem and I was not quite sure if we should should support it but I think it's a good way um I'm going to show you how to do is basically um for example what we doing now is if we don't have the file locally right we just going to send a message yo give me this file name the problem is that what happens if we don't know that file name right because some maybe our house is exploded or something I don't know and we actually don't know what files we had in our storage then how are we going to sync right because if we don't know the key we cannot fetch it we cannot ask for the key so how we can solve that is by um and I said like I mentioned before you can make this as complex as you want you could even do it with the public key private key and then sign your your your things and sign your messages and then we could validate and all that stuff so only you can store to your um ID which is what we're going to create so uh enable to fix this is um what we do now let me open up store actually I'm going to open up the other side by the way uh if you have store here for example let's go at the top what we do now is basically we create uh a pad right we create a pad and that pad is basically based on a transform um on a transform Funk based on the key we give it right and the key is for example it could be a file name and the file name could be um clown. gpeg right we're going to tr transform this file name right and that's going to return as a key um which is going to be a pad actually it's going to be a pad right and then we have a root we have the root of the of the folder right and we're going to have a pad right so what we're going to do is basically is we could do we can store it in a root because that's where we're going to store everything right files from from from everybody that that want to distribute his files and or files but we could actually do something in between and it's going to be a root and then an ID right and it could be a PB key uh if you want that could be uh some kind of a random ID or a random string uh if you know what I mean so basically if we then need to sync the only thing we could do is ask for a sync and give it um this random string right which basically is a random identifier of our storage of or server whatever note whatever you want to call it and then we can actually fetch all the files inside of it and send it over right so how can we Implement something like that um without doing too much refactor and it's basically something like um that's actually a good question we could do um if you go to crypto right we could do something like uh not quite sure if crypto is a good thing to do a good place to do it you could do it in a util function or something but hey um but you could to be honest it would be nice to have a public key uh enabl to to that to do some stuff with it but I'm going to use a simple ID right you're going to say generate ID which will return a string uh like this we could say for example uh it's just for to give you guys some ideas right because for you it would be nice to um extend this um forever store extend this distributed file storage with some of your own functionality to um to learn navigate through the codebase and to implement your own IDs right that's that's the best thing you could do but you could you could watch this series forever it's very important it's a very big mistake I also made in my uh career is what a lot of people or mistakes a lot of people making and it's not only with coding it's with everything they watch a lot of videos which is good which is very good right but they keep watching they keep watching but they don't do it's good that you watch but it's also very important that you do stuff and figure things out it's it's also very important so we're going to say uh let's say we're going to make a buffer which is going to be make me a slice let's call it buffer make me um a slice of bite let's make it 32 right and then we're going to say IO read all or read full I think it's read all is that I think it's read full and then we going to say IO um it's not it's not that it's going to be a Rand reader right I'm going to read above right and I'm going to say return hex and go to Str one of my favorite functions by the way X and go to string we're going to and goe this the buffer right that thing and now we have a nice uh ID right and you can already see it coming with this 32 you could you could use a PB key and then you could actually uh enhance this file server so every uh message we sent is going to be signed with the PB key and then uh you could store everything at the PB key location and you could check if the message is coming um is exactly from from the guy that wants to store and retrieve stuff to make it even more uh cryptographical secure right um generate idea Okay cool so what we could do is basically in server no in main or in server actually or maybe in rops store that's what we need and did I code into let me open up crypto did I code into my screen no I need to make sure that's not happening so let's open up store here yes what we're going to do is we have this um store UPS Store up so we have this root let's give it an identifier which is going to be a string right um ID of the owner uh of the storage storage uh which will be used to store all files at that location so we can sync all the files if needed something like that right what's going on everybody sending me messages um yes yes yes yes yes we have this ID if you're going to make a new store are we going to make an ID we could do that right you could say if L Ops ID is zero then we're going to make one right if somebody forgot I'm going to say op uh ID is going to be generate an ID just like that I cannot do this is fine so now we have an ID and then we could say in storage is basically if we open file for writing is that what we need yes so you can see we do a root which is this one and then we do the pad key right and we could do something in between and that's going to be the ID something like that uh what is this s root pad key I think we need to provide here the ID also just like that and now we need to do the same thing with the read stream right so the read stream is getting the root and we also need the ID like that as root then we going to say S ID like this hands are cold tell me something new hey all right so I think um if you open up store test actually not quite sure if this already going to expect to have keu we have some issues in our tests actually expected to have key this one expected to have key y y y uh but got I we don't have it ah I think it's has that's a problem um the problem we have with has we need to yes yes that's what I was thinking so of course we have the root and we also need to provide the ID here um as ID and maybe that's going to work a little bit better make test actually all right expect it to not have key uh I think a problem is that it's not deleted yet right uh let me delete these files real quick man this Windows this Windows signing B is crazy blowing up my ears uh I think we don't delete this where is delete right ex ex exactly right so we have again uh we need to refactor this that we have the ID of the storage like that right make Test please boom yes yes yes yes that's fine so let's us hope that make run is going to work perfectly fine and I think it is good good time to set the coffee uh yes all right all right right let's see let's see let's see yes we have these nice falters uh of course you can see that I think we do it with um 5ou I don't know I don't know who the guy is but you can see that these folders right um these pads are basically not the same as this 5,000 pads um you can see but these are the same right so this one these pads right these folder pads are the same as the 7,000 one but they not the same as the 50001 right and that's because the 50001 is the guy that is uh storing stuff and and and make it distributed so the two other servers uh in the network they will have the encrypt the hashed version of the key which will translate into a different pad right uh so they don't know the contents of the file because it's encrypted but all they don't also do not know the contents of the key which is amazing super secure well super private um like this uh and I think it should work right so if we man yeah encrypted stuff that's fine and then 5,000 should have the that my big data file is see these things come together is so nice um yeah and you can see what happens right so you you can see that this is the ID right this is the uh e77 A6 right uh this is a problem we we made a big mistake by the way we made a big mistake because they're storing these files inside of um it's good that we have an ID that's a that's a fact but um I was just thinking about I made a mistake guys you can see uh I also make mistakes um but we identified it which is good so basically the problem is that if we retrieve a file it's going to retrieve from the ID from the storage uh so it works all fine but it's it it's not working like intended um so what happens if somebody is storing it needs to store at a certain ID so instead of um anony anony anony so instead of storing at our own ID uh let open up server it's fine server is on the other side yeah so I think to be honest let's refactor this sometimes it's funny uh but I wait where is this this this thing this ID thing let me find this uh ID soorry yes I think we need to move the ID to the server yeah we're going to delete the ID guys we're going to delete the ID guys and girls and if I say guys it means guys and girls you know what I mean it means everybody I know uh we're going to delete this right okay damn damn damn damn no we going to I'm going to we're going to do it like um it's a mistake and we're going to we're going to we're going to take the pain we're going to take our mistake and we're going to refactor it that's sometimes what it is uh we can go the easy route and rerecord the video but I'm I'm not that guy and you guys know that um that's engineering and I want to see engineering at its finest and um if you make a mistake you need to take it as a man you know what I mean and that's what we're going to do I'm going to take it as a man so we're going to delete this and I hope you understand what what's the problem right so because we storing it at our own ID which basically has the same problem we already had before I think we need to um refactor the code a little bit if if we write and read we need to specify the ID of uh the location where it's get um the ID of the other note it could be our ID but could also be an other ID it's very important and that's the only way we can sync uh if we don't know we can basically sync the whole folder to a server right if you really want to implement that later on if you know what I mean okay so I think we are back these folders are pretty are are back at the state they need to be which is good um luckily we didn't refector that too much yeah I think it's fine to be honest I think we can we can make test and it's going to be all good yes all right right right right it it's nice it was good it was good it could be it could be much worse so how we going to fix this um we are going to say we're going to server here and we're going to say server Ops I'm going to give it an ID it's going to be a string uh we could do we need to it is fine it is fine uh what we could do is basically we could do like this right so if Ops uh ID wait we could say Len that's how I check if variables uh strings are empty could do it whatever you want we're going to say if L op ID is empty we're going to say Ops um ID is going to be generate ID so that's going to be always fine so we don't need to specify it it will generate an ID for us if you don't specify it and if you specify it it will use that ID yes so what we're going to do man we could say get the the key as a stream you could also say from from which ID we want to read right wait I'm thinking wait wait wait this is already in server um we don't need it here no no no because we could send yeah yeah wait wait let me open up store first store is the most important thing right now um right so we could do something like this um I'm thinking is this going to work with with with read and write let's open keyf write then okay so it's going to be it's going to be some nasty and maybe we should uh introduce uh um another episode for this or I could actually do it in one we could actually complete it here maybe so we're going to say um we need to prefix this with an ID it's very important we're going to say string and then we going to say percentage s going to be the ID right open file for wren ID um yeah the same thing here ID is going to be a string uh it's going to be the ID that's fine reading is going to be the same thing right we're going to say ID string ID here it's going to be a problem in uh read in read stream right I'm going to say ID string uh this going to be a percentage s it's going to be the ID right just like that all fine um write decrypt ID string ID key fine write we need an ID an ID string which is going to be ID uh no it's going to be ID key delete the same thing percentage s is going to be an ID yes and has is the same thing it's going to be an uh ID string you could you could see an ID as an extra key right um as an extra key where it's stored so we can actually do do some advanced stuff with it uh the question is what's going on here did we actually have have everything 10 ID key yeah yeah yeah file yeah right the Crypt ID yes write yes delete yes has also I think we're good of course now we have trouble uh in our storage here uh so we're going to say new store and maybe we need to make an ID and put this ID here and ID here it's a little bit of uh tedious uh operations I I know I'm going to make test okay server is complaining I know I know I know I know right if you want to get a file you're going to say it's going to be as ID right and then the key so then we don't have it locally right then we need to actually uh upgrade this uh payload message we need to we need to specify an ID which is going to be as ID we need to send our ID over right that's very important uh where is this message I have no clue let me quickly GD into this message right you're going to say the ID it's going to be a string actually this guy this guy it's going to be string size fine but we also need an ID actually we can do it at top uh and and that's going to be a string but i' also think we need this in get file all right that's fine so we specify an ID here let's put it at top it doesn't really matter it's just an OCD um and then we're going to read our key based on our ID like this and then if we store we need to specify an ID actually is it yes it's or ID the key then we're going to send that we need that this guy needs to store this uh at R ID all right handle message get read if store has uh it's going to be from this guy message ID we're going to read this guy wait I get wait so first of all need to Surf um wait because this is handle get file we first going to check if we have it I think it's going to be the message um ID not quite sure and then we have this one handle store file from this beer so I think we need to store this on the message uh ID right let me see if make test is working we still have not enough in Main and in servers 112 yeah righty cryp the I see yeah so we broadcast our ID this is going to be as ID this going to be R ID uh which is basically after this encrypt if this is going to work from the first time I'm going to be uh it's going to be this one and I think we still have some issues in our test here here here in right stream make test real quick um it's a problem in main that's fine so we want to delete um S3 it's going to be S3 ID right so that's going to be fine let's make test yes okay test is working uh okay I'm not quite sure if if if our thing our Serv is going to work um could be that you made a little mistake but hey okay it seems good it seems good seems good so how can we make sure that that is going to I'm going to refresh these folders because let me close all these guys here what's going on right let's refresh okay so we have these three uh three people in the network and I think it's 5,000 is going to be the guy we need yes 5,000 is the guy we need so he has uh two thingies I think some relics from from the past right um wait let me let me delete these folders and run again because it's going to be confusing as hell it's going delete the whole sh bang and then we're going to run again and then we're going to see if these um ID folders are are correct make uh a run and if so we are in a good spot right yada yada yada yes okay cool uh let's see what's going on so we have yeah I think this is fine right because we have this ID from 5,000 and they all have this ID and they store everything uh or files at this ID right at this uh thing which is perfectly fine which is was it intended so now our server works like a complete works like a dist like a distributed file server and if we um for example if 5000 doesn't have this folder anymore uh he he can either sync the whole folder right he can sync the whole folder or he or he can um ask for a specific file if he wants and people will exactly know where to find it because it's his ID um it's in his ID subfolder if that makes sense right so uh I think this was it for the um for the distributed decentralized file server file storage and um something I want to give uh I want to give an assessment for the people that are watching these series something that you can do it it's not mandatory of course it's what what you want um and what I'm going to what I'm going to give you is if you can see we have get right and we also have um store right we have these two uh apis we can use for our storage but what we don't have is delete right we have delete in our store but we don't have delete in our server so the the assessment I want to give you guys is Implement delete right that basically means it needs to delete the file on or on our local machine but it also needs to delete it needs to send a message to all of our peers we're connected to so it can also delete a certain file on their machine right that's the assessment I'm going to give you not too hard not too simple uh I think it's a very nice assessment and I'm going to uh when it's done you can DM me on patreon or whatever you know where to find me and uh I'm going to review that and give you some feedback on your implementation right that's what I'm going to do cool um yeah cool thanks for being a part thanks for um being in the community or whatsoever for the support and I see you on Discord on a video or on live stream thanks for watching byebye