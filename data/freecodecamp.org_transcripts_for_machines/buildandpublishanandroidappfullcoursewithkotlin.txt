hey everyone welcome to this tutorial where we're going to start with a brand new android project and see it all the way through to publishing on google play my name is rahul and i'm a software engineer and youtuber who loves teaching i think the best way to learn something is to build things and so we're going to build a memory game app to learn android development with kotlin as you go through this if you have any questions or feedback i'd love to connect with you i'm at rponde1234 on youtube and twitter the memory game is the perfect way to cover a lot of core android concepts we'll talk about dynamic layouts multiple screens image loading and persistence with firebase along the way i'll share some practical tips and tricks about app development and my checklist that i always go through before publishing any app onto google play i'm going to assume you have some programming experience and if you have a basic familiarity with android that's an added bonus we're going to be using a programming language called kotlin which is now the recommended way to develop android apps you're welcome to follow along if you're new to kotlin or even if you're new to programming but i'd recommend that you go through a quick kotlin intro first once you're done building the app share it on social media with the hashtag mymemory and don't forget to tag me so i can check it out as well let me do a quick demo of the memory app that we're going to build this game is really popular i played it a lot growing up and i'm sure it's familiar for many of you the objective is to try and find pairs with matching images so here i have two cards which don't match when i flip over a third card then the other two will flip back down and the reason this is called memory is because once you've identified where a image is you have to use your memory or concentration to find out where have you previously seen that card so here i know the matching flower image is over there and now i can continue until i have found all of the pairs once i found all the pairs in the game then the confetti falls and i have that message and we can also see information about the game at the bottom of the screen in the menu i can tap this button to restart the game and that shows me new random images and i can also choose a different size memory board so right now we're showing an eight card game which is four pairs and i can make it a little bit harder by choosing the hard version which is 24 cards and so now you can see how we are dynamically changing the size of each memory card in order to fill up the phone width and height one other thing we can do is download a custom game so this is a really cool part of the game it is that anyone in the world can create their own memory game with photos from their phone and we can actually play that so for example i created a custom memory game called bitmoji so bitmoji is my bitmoji character my cartoon doing different activities and so now if you flip over a card you can see these are images from my phone that i uploaded into a custom memory game and we can play the game like normal where we're trying to match up images and finally of course you can also create your own custom memory game so i'm going to choose to create an easy game which means i have to upload four images this will now launch the existing gallery app on your phone and i can select photos from my phone so i have these very adorable photos of corgis i want to give this game name the name of corgi and tap save and what this is doing is it's persisting these images to firebase and once that's done now we can actually play our custom game so you can see the images of the core keys that we have here and the cool thing is now i can share this game name corgi with anyone in the world and they can play the same game so there's a lot of really cool concepts i want to cover in the process of building this and i'm really excited to get started with you i'm going to make it really easy for you to follow along with me which means i'm going to keep copy paste to a minimum and the only tools that you really need are android studio and a working emulator or a phone an android phone i'll also leave a link in the description to the github repository which contains all the code so you can feel free to reference that as well here's a picture cloud representation of the main concepts we'll be covering so first off we're going to become very familiar with android studio we're also going to be talking about vector icons so android studio will help us to create a bunch of these vector images that will be used as a default memory game images we'll also talk about views and measuring out how much space to allocate with the content the padding and the margin which lives outside the view all that content will live largely inside of a recycler view which is how we're displaying the grid of memory cards so recyclerview is a very core component in android and we'll talk about the different parts that make up a recyclerview we're also going to be dealing with two firebase services the first is cloud storage which is what will be storing our images second is cloud firestore which will be the database associating our game name to a list of image urls then finally we're going to spend a bit of time talking about how do we create a release app that we can then publish onto google play and also talk about how to optimize your google play store listing i'll leave a link to the published app in the google play store in the description so you can in the download segment we are going to construct the layout for the main screen or main ui for our application just one more thing i wanted to say a big thank you to free codecamp for building out an amazing platform to reach so many students subscribe to their channel and check out my channel if you want more content like this we're going to get started by creating a brand new android studio project and then the goal for this segment is to set up the scaffolding for the main layout or main ui for our memory game here's what the final user interface for our app will look like at the top we have an action bar which comes in by default in every internet app and it describes how the user can navigate through your app the bulk of the screen will be taken up by something called a recycler view and that's how we're going to power this grid of memory cards that make up our memory game at the bottom we have two labels or two text views that describe the current state of the game and so at the end of this part here's what our ui will look like at the top we have the default action bar at the bottom we have a horizontal linear layout with two text views with dummy data and the rest of the screen will be filled up with an empty recycler view let's open up android studio and you can see here that i'm running version 4.1 any recent version of android studio should do so i'm going to tap the option for creating a new project and let's go ahead and pick the empty activity template tap on next and we're going to call this project my memory because it's a customizable memory game the package name has to be a unique identifier for your app and it will dictate the directory structure for your project typically i'll take my domain name rkpuna.com or my email address and flip it backward pick a location for where you want to save it we're going to pick the language of kotlin which is the more modern and recommended way of building android apps going forward the minimum sdk i'm going to pick api level 21 which is android 5.0 otherwise known as lollipop and you can see here android studio is telling us that if we pick api 21 that means our app will run on 94 percent of devices so that means around six percent of android devices are running a version of android which is more than five years old and they won't be able to download our app but there's a lot of pain associated with actually back porting your app and making sure it runs on all these super old android os so i would recommend that you stick with api 21. let's tap on finish and then android studio initially when it creates your project it will actually try building it based on the scaffolding that you picked so we have empty activity which means that we just have a kind of a blank activity here which will say hello world and the very first thing i like to do whenever i create a brand new project is simply to run it and running it will give me the confidence that i haven't screwed anything up in the setup i have android studio set up properly i have an emulator set up properly and i'm actually able to compile and run my app i have a bunch of emulators already set up here if you don't have any emulators click on avd manager it's android virtual device manager and that will guide you through the process of creating a new emulator that you can install the app on i'm going to go with this pixel 2 api 29 emulator and without making any code changes i'm simply going to hit this green triangle in order to run the app and boot up the emulator in the process awesome so you can see down here at the bottom how it says the operation succeeded and just like we want we're able to see this default empty application which says hello world so let me quickly talk through what we get in the starter project here there are really two files that you should be concerned about one is the main activity.kotlin file the dot kt means it's a kotlin file in the world of android you can think of an activity like one screen in your application so this file main activity.kotlin will be where we write the core logic for the memory game it'll be the brain of our app and the critical line here is set contentview r.layout.activitymain so what this is referring to is that there is a resource file called activity main so r stands for resource and r.layout means look inside of the layout directory of the resources and look for a file called activity main so we can actually try doing that my preference is to select the android view of our project the initial perspective which is simply called project represents the actual file hierarchy of the project on disk but it's a little harder to navigate and the android view is how i conceptually think about my project so instead of the android view in the app directory there's a folder here called dress which is short for resources so like we talked about there's a layout directory inside of res let's check that and there's one file here called activitymain.xml and that's what is creating a link between the main activity and the underlying ui or layout so i can go to the definition of activity main by hitting ctrl b or command b and that will jump to this other file activity main in android we define layouts using xml a markup language which allows us to define the views on the screen their position and how they're structured with one another so you can have views inside of another view and you can see here how it's really simple right now all it is is a constraint layout as the root element and inside there's a text view which just says hello world and that is how we are seeing the hello world text when we ran our application now we can start making changes and i want to be really precise about what we're going to do in this segment which is i just want to add a bottom component which will describe info about the current game being played in particular there'll be two text views one for the number of moves on the left and one on the right side showing how many pairs have been matched so that means we're going to have to be modifying the activity main.xml and you'll notice here that there are three different perspectives of this xml file so we have the code which is basically the underlying xml representation split which is both and then design which is just looking at the preview rendered in android studio itself so to give us give ourselves a bit more space i'm going to double tap on activity main and that basically minimized this project tool window and the first thing i want to do is get rid of the default hello world and we are now going to drag out a linear layout which is horizontal orientation because these are going to be right and left the two texts at the bottom are going to be horizontally aligned and we are going to set the layout width to be match constraint which means that we're going to have the width be dictated by the constraints that means that we should add some constraints so from the left end of the screen i want it to be zero dp which means i just wanted to be flush with the left end and same thing on the right and essentially what that did is it's making the width of this linear layout the whole screen width we also want to constrain the bottom of this linear layout to the bottom of the screen so add 0 down here as well i also want to change the height of this to be wrap content which basically means i want the linear layout to only have as much height as whatever is inside of it inside of linear layout we are going to contain two elements and these are going to be card views and the card views are actually what will contain the text view so card views are a really nice android component which show some elevation so it's a material design recommended ui so that's what we'll use to create some separation between the text views and we'll actually also use it for each memory card so i have a card view here i'm going to change the corner radius to be 8 dp here and then inside of the card view i want to drag out a text view so a couple changes i want to make here first off i want to make the width and height to be match parent so this texture takes up the whole width and height of the parent which is the card view i want to make the text appearance large make it a little bit bigger let's also give it some dummy text here so this is this one is going to represent the number of moves that the user has done so we'll start out with zero moves and then i'd like to add some padding onto this text view so let me search for this attribute called padding and let's give give this textview a padding of 8dp all around so you can see how it created some space let me zoom in on the design preview just so we can get a closer look at the changes we're making the last thing on this textview is i want to set the gravity of it to be center which basically means out of all the space that we have i want to be centered inside of the card view so search for gravity and then we are going to set the gravity to be center you can see how it got centered in there now going back to the card view one thing i want to add onto the card view is a margin so we can see a separation between the card view and the background which is the linear layout so search for margin and we are going to add a margin of 10 dp on all sides so now you can start to actually see this card you take shape and have this elevation that i mentioned earlier we actually want two different card views on the bottom in the linear layout so what i'm going to do is i'm going to go over here copy this then go and select the linear layout and then paste it what we did here is we are embedding two card views in the linear layout and in order to make them show up side by side there's a property on the elements in the linear layout called weight and the weight dictates how much space should the linear layout allocate for this child so if we set the value to be equal on each of the card views that basically means we want an equal amount of space allocated that looks good so now in the text here on the right we don't want that to represent the number of moves we want that to represent how many pairs have been found i'll call this pairs and then we'll say zero out of four all right and then you can see how one issue that we have right now is that the id of these textures is identical so let's go back into the code tab now and fix this so you can see again here in the code tab the red error highlighting and one thing to keep in mind also is that any change that you make in the design tab there's a one to one correspondence between that and what you see in the code tab so you can kind of see here we have a linear layout and inside that linear layout is a card view with the text view inside and then the same thing down here so we would like to change the id of this one to be tv num moves because it represents a text view with number of moves and then the id of this one should be tv num pairs the one more thing i want to do while we're in the code section is i would like to add a background color on the linear layout i'm just going to add the background attribute and the value of this i would we wanted to set to attribute and there's one inbuilt called color secondary variant which is kind of this teal color and if we go in the design tab you can see what that looks like cool that looks pretty good so now if you're on the app we should no longer be seeing the hello world text and we should now be seeing this linear layout at the bottom with that hardcoded text that we have awesome next we're going to drag out a recyclerview and this is going to be the primary component which will hold on to all the cards in our memory game and i want to set the left and right constraints of this to be 0 dp so i want to take up the whole screen with the top constraint should be flushing at the top of the screen and the bottom constraint i want this to be actually up against the top of the linear layer at the bottom in order to have that take a visible effect we need to change the layout height to be zero dp and now you can see how the recyclerview is basically taking up all the remaining space after we've allocated the space for the linear layout at the bottom of the screen and also the layout width we can also make it match constraint zero dp because we've properly defined the the constraints on the left and right side and this recyclerview won't have any visible ui change because we haven't actually written the logic to populate it yet that's what we'll do in the next part the last thing i want to do to wrap up this part though is go back to main activity and let's actually grab references to each of the views that we have on the screen now so in particular i would like to be able to get references to any of the components that we have that we will need to change programmatically so in particular these two text views and the recycler view so give this an id name of rv board because it represents our memory board tap on refactor tv num moves looks good tv numpair looks good and i'll just let's just go ahead and change the default name of the id here of linear layout 2 and make this ll game info which stands for linear layout game info this is a container with all of the information of the game and then let's refactor and android studio will take care of updating anywhere else that this id is referenced so now in mainactivity the pattern here is any widget that we have in our layout we can reference in mainactivity and we'll define that as a private member variable and all these will be private late in it var so for example rv board and this is going to be of type recyclerview and then similarly we're going to have one for tv num moves this is going to be a text view and there's going to be one more which is tv numpairs and that's also a textview and the reason it's a late init var is because we know that these variables will be set but they'll be set in the oncreate method which is invoked by the android system they're not going to be created at the time of construction of the main activity and that's why this is a late in it late initialization so now in the on create as soon as we've called set content view now we can set these newly defined variables equal to the corresponding view in the layout and we'll do that by calling a special method find view by id and provide the id that we assigned so for the recyclerview we give it an id of rv board and similarly tv num moves and then finally tv num pair now we've set up the scaffolding for the main activity and we have references to the key views on the layout the goal the next part is to add in data to the recycler view in a 4x2 grid of memory cards that we'll define so we have now this linear layout at the bottom which shows information about the current game and we have this empty recycler view which takes up all the remaining space our goal for this part is to fill up that recycler view with a grid of icons which will which will eventually be each memory card that you can tap on and flip over but for now we're just going to put in some dummy icon and the interesting thing here is that the size of each of these cards that you're seeing are not hardcoded instead we're going to dynamically set the width and height according to how much space we have so on a larger phone or on a tablet these will appear bigger on a smaller phone we're going to reduce the size appropriately we're going to make them just large enough that we can fill up the entire space that we're given in this recyclerview so jumping back into the code every recyclerview has two core components one is the adapter and one is the layout manager given some views that should be shown in the recyclerview the layout manager is responsible for measuring and positioning those items so the layout manager is actually quite simple for us we're going to use a predefined layout manager that comes with android called the grid layout manager and this is how we're going to have this nice grid effect so this takes in two parameters one which is a context so we're passing in this which is referencing the main activity because the main activity is an example of a context and a second parameter here is the span count otherwise known as how many columns are in your recycler view so for now we're going to hard code this four by two grid so there's going to be two columns and each column was going to have four rows we're going to pass in two here and then later on we're going to have to make this dynamic based on what the user has picked the other component that we're going to define for the recycler view is an adapter the adapter is more involved than the layout manager because it's responsible for taking in the underlying data set of the recycler view and turning that into or adapting each piece of data into a view i'm going to set this adapter property on the recycler view and we're going to define a new class which has all the logic for the adapter called memory board adapter and this will take in two parameters one which is the context so i'm going to pass in this and second will be how many elements total are in our grid and we're gonna hard code this in as eight for now and we'll change that later on before we define this memory board adapter there's one more thing that i want to point out which is optional but it's a performance optimization which is that there's a method on the recycler view called set has fixed size and we're going to pass in true here and what this method does if you look at the documentation is that we know the size of the recycler view is not affected by the adapter contents so like we talked about earlier the size of the recycler view on the screen is always going to be defined as soon as the app boots up and it won't change regardless of how many memory cards are inside the recycler view and so by setting has fixed size to be true we can make our application a bit more efficient okay so now let's go back and you can see how under studio is complaining that this class isn't defined so let's have inner studio help us to define this class so tap on the red light bulb and tap on create class memory board adapter and we're going to extract this out into a separate file in the same package name okay so the first parameter is going to actually be a context not an activity and the second constructor parameter will be num pieces representing how many memory cards there are and that will be an integer then hit tab one more time one thing i want to do is i want to prefix each of these constructor parameters with private val and that will actually allow us to use this in the body of our class what we have here is a class memory board adapter which is a subclass of the recyclerviewadapter class you'll notice that this is parametrized by something called recyclerview.viewholder so a viewholder is an object which provides access to all the views of one recyclerview element and so in our case that will represent one memory piece or one memory card in the game and we're going to define our own view holder which will encapsulate that memory card view and so what i'm going to do is i'm going to actually define an inner class here called viewholder and this is going to inherit from the recyclerview view holder hit this red lightbulb and then we need to match the constructor invocation of the view holder and now that we've defined this view holder instead of being parameterized by the base class i want to be parametrized by this inner class that we just defined so we'll need to import that okay and now that we've defined the inner class and we're parameterized by that now hit this red light bulb that android studio is complaining about for the memory board adapter and implement the numbers the recyclerview adapter class is an abstract class which means that we have several methods that we need to override in order for it to function and there are three that we need to override i'm going to select all three and tap on ok and my preference is to have the inner class show up at the bottom of the class so i'm going to have that i'm going to move that down here and now there are three methods here oncreateviewholder is responsible for figuring out how to create one view of our recyclerview getitemcount is actually really easy so i'm going to define that right now which is how many elements are in our recycler view and that will simply be the constructor parameter that we passed in num pieces and then onbindviewholder is responsible for taking the data which is at this position and binding it to this view holder which is passed in here so we'll we'll come to that in a little bit but first let's define the oncreateviewholder method so the pattern here typically is we're going to use a layout inflator i'm going to create it from the context which is the parameter that we passed in the constructor and we're going to inflate a resource file which defines our layout with the r.layout.memory underscore card and this takes in two more parameters one which is the view group the root view group and that'll be the parent which is the perimeter passed in and then the third parameter is attached to root we're going to pass in false here we have to now define this layout file again android video will help us with this create layout resource file have the root element of this be a linear layout tap on ok the objective here is to add in some children elements on this linear layout such that we create the view for one individual memory card in our game so if i go into the design tab what we'll do is first off let's change the height of this linear layout to be wrap content let's drag in a card view and inside the card view will be an image button we'll drag out an image button and let's have the underlying drawable or icon behind that image button be this icy launcher background which is a screen grid you should have that already from the default android studio project tap on ok let's have the id simply be image button and have the width and height be match parent now you can see how it takes up the full dimensions of the card view which is apparent let's set the background to be white this is a solid white color and the scale type can be center crop well and the card view represents one actual memory card so there's a couple design tweaks i want to do here first off i want to hard code the width and height to be 120 dp just to give it a more realistic feel of what a memory card might actually look like but we're going to change this to be dynamically measured later on but for now 120 is a pretty good default let's change the card corner radius and height to be 8 dp so it stands out a bit more and let's also give this an id of card view finally the last thing i want to do is set the gravity of this parent linear layout to be centered so this card view goes into the center of the screen so search for gravity and then hit center all right awesome so you can see how we're now aligned to the center of the screen so going back into the memory board adapter now this error went away and the return value of layout inflator inflate will be the actual view which was created i'll say valve view and then what we want to return here is the view wrapped inside of a view holder and then in on bind view holder what i want to do is for now just called holder dot bind position and bind to something which is not yet defined because energy is looking for this method to be defined on the viewholder class it doesn't exist yet so industry will help us to create it and for now this is going to be a noop and then later on we'll come back and address this okay let's run the app and see what happens awesome so what you can see here is we are now getting eight different elements in our recyclerview in this grid four by two grid and you can kind of see the outlines of the different cards that we've laid out so what you can see here is that we're not really making a good use of all the space that we've allocated for the recyclerview right like we have this kind of awkward white space at the bottom and also we want to ideally have some margin between each of the memory cards in our recycler view so let's figure out how to do that the first thing that's worth pointing out is that the space allocated for each memory card will depend on how many memory cards we have so right now we have this four by two grid which means we have two cards across and four cards tall on the other hand if we have a slightly larger board where we have three cards across and four cards tall now we have 12 cards instead of eight that means that the amount of width allocated for each memory card is going to shrink so let's implement that first going back into the code we need to measure what is the width and height of the recycler view which is containing all the memory cards and based on that change the width of our card view so instead of having this be hardcoded to be 120 dp we want to measure that according to the recyclerview width and height and that turns out not to be that difficult because the recyclerview is actually the parent which is passed in here so if we wanted to figure out what is the width of the card so i'll say val card width then that will be the parent dot the width divided by however many columns we have in our grid so in this example because we're hard coding is four by two grid the width will be divided by two and then similarly for the card height we have four cards tall so we're going to divide the height of the recycler view by four and we're going to mandate that each memory card in our game is going to be square so we're going to take the smaller of the card with a card height so i'll call it card side length that's going to be the minimum of card width and card height and you might have to import min which is coming from kotlin.math.min at the top here so now we need to actually grab out the card view from the view that we've inflated and set the width and height of that card view to be card side length the way we do that is we say view dot find view by id pull out the card view which we gave it an id of card view and we're going to get a reference to the layout params and this is going to be equal to layout params a variable that we defined and on these layout param this is what will allow us to change the width and height the width will be card side length and the height will also be card side length so let's try this one more time and hopefully now we shouldn't have this awkward white space at the bottom and you can see that that is fixed right so we are actually taking up the whole screen width and screen height there's one more observation i want to make which is that we don't actually want the card to take up the full dimensions of the space we allocate to it so for example if we're putting a memory card into this yellow square we want to have some margin between the actual icon and the space around it and the reason we want that is because if there's a neighboring card we want to have some white space in between the two and so that's the next thing i want to implement with you which is how do we add some margin so that we're not always flush with the card next to us and this also turns out not to be that difficult we're going to define a constant which is the margin size i'm going to define that in a companion object in kotlin companion objects are singletons where we'll define constants we can access its members directly through the containing class think of companion objects similar to static variables in java let's define a constant called margin size and i'll set that equal to 10 that's what i found to be a reasonable distance between each memory card so the card width we actually want it to be reduced by the amount of margin on either side to the right and left and so i'm going to subtract 2 times the margin size and similarly we want to reduce the maximum allowable card height by the margin on the top and bottom so we'll subtract two times the margin size again now we're measuring the dimensions of the card taking into account the margin but we actually need to set it when we grab the card view reference from the view we have to cast the layout params as a special type of layout params called margin layout params and once we've done that now we should be able to set the margin on the layout params so let's say set margins and we're going to set the margin size all around on all four sides let's try it that's so much better now we have this nice white space margin between each memory card one quick improvement i'd like to make here is adding some margin on the recycler view as a whole at the top and bottom so going back into activity main i'm going to add a 8 dp margin to the top and bottom and let's just see if that looks a little bit better now great i like that a lot more because it gives us some breathing room between the memory cards and the underlying parent view right now when i tap on any of these elements nothing actually happens to wrap up this segment i would like to actually register a click listener on each image button which is what these are so going back into the memory board adapter inside of the view holder when we bind the view holder we're going to grab a reference to the image button which is inside that card view so the way we can do this is in the constructor of the view holder i'm going to define the image button the id we gave it was image button and so here we want to actually set the image button click listener i'm going to add a log statement here click on position and then let's print out the position so we need to define this tag which we'll do in the companion object and the convention that i use is the tag name is always the class name so in this case the class name is memory board adapter and let's try this one more time so we're going to run the application and also open up logcat so i am going to filter out only for info level logs because we actually have this at info level and i'm also going to look for logs from memory board adapter so i started typing in memory and now if we tap on an element you can see okay we do see click on position zero if i go down here that's position two position four and this last one is position seven which makes sense because we have eight cards from position zero to position seven just one more thing before before we wrap up this segment if you notice if we go to the ends of the recycler view and scroll up or down we get these shadows which are the material design way of indicating that we're at the end of this recycler view there's no more content in our app it doesn't really make that much sense because we are mandating or guaranteeing that the content of the recyclerview will be fit to the screen dimension because the content is never scrollable we should never be seeing this visual indicator called edge effect and so if we go back into activity main and then go into the recycler view and then search for this attribute called over scroll mode and set that to never that should address that issue so if we rerun the app now when i scroll up or down you can see that there is no shadow the goal for the next part is to introduce the notion of a board size so we don't have to keep hard coding in a 4x2 grid and we'll create some icons that the user will eventually pair up as part of the memory game now we have this hardcoded 4x2 grid of 8 memory cards the first thing i want to do in this segment is create some flexibility so we can easily increase or decrease the number of memory cards in our game and the second thing i want to do is create a bunch of vector icons which will be used as the default icons when we play a new memory game so first off in order to build in more flexibility into the dimensions of our memory game there's a couple things we need to adjust so first off right now we are passing in two and four here as the dimensions of the board which is incorrect that'll change depending on how many cards are in a memory game and second we also are passing in two here for the span count which is how many columns are in our board and that also might change so in order to encode all the different information about the size of the board i'm actually going to create an enum called board size and so if you open up the directory where main activity is located i'm going to create a new package here a new package called models and we're going to add to this later on with a couple other things but for now the only thing this will have is a kotlin file called board size and this is going to be an enum and an enum can optionally take in a value and so we're going to pass in a vowel here called num cards this is going to be an int so in our current example what we have now num cards would be eight because four by two we're going to have three different values of board size first is easy second is medium and that'll be 18 cards and then lastly is hard which is 24 cards and these are the different options for the memory game so the current version that we're playing is easy there's only eight cards medium is 18 and hard is 24. we also want to encode in this enum information about the width and height corresponding to each board and so i'm going to define a couple other methods here one is called get with it's going to return int and depending on the value of the enum i would like to be able to figure out what is the width of the game and so the way we can do this is say return using the when construct this is referring to the board size on which we're operating easy medium or hard and the one expression is similar to a switch statement so it'll evaluate a list of conditions and it'll return when the first one is met so we're going to have android studio help us to create all the remaining branches and what that did is create a branch for each of the three enum values and so in the case of easy the number of cards widthwise is going to be two in the medium case we're gonna have a six by three board so we'll have three cards by and in the hard case we're gonna have four cards wide they'll be six by four we're also going to have one method here which is get height and one thing to observe is that the height is fully determined once we know the number of cards and the width right and so the value here is simply going to be the number of cards divided by get with and finally there's one more method i want to add in here called get num pair is also going to return in and this method is going to represent how many pairs of cards are there right so if we have eight memory cards in our game that means we're gonna have four unique pairs and so this is simply going to be the number of cards divided by two okay awesome so now back in main activity instead of hard coding in eight let's define a variable up here called private var board size this is of type of our enum that we defined and initially the value is going to be board size dot easy and i would like the memory board adapter to take in the board size instead of the number of pieces and then the grid layout manager the second parameter is how many columns are there and that'll simply be board size dot get width now let's fix up the adapter and the second parameter should be of type board size instead of the int so i'm going to tap this rear light bulb and change the parameter to the board size so going back into memory board adapter let's change the variable name to reflect that and now that we have this we can update get item count to be board size dot num cards that's the total number of elements in our memory game and the final thing we need to do is update what we're dividing the width and height by and this is going to be the width divided by the board size get width and the height we're going to divide by how many elements tall is our board let's try it from the ui perspective this should be identical and you can see it is but the benefit of what we did what we did is we can now very easily adjust the size of the board for example making it hard and now we should expect to see a 6x4 grid instead of a 4x2 and you can see that that actually happened and the dimensions and spacing of these memory cards is looking good awesome so the next thing i want to do in this segment is create icons which will be the actual underlying image for each of these cards and this luckily turns out to be really easy because android studio has a really nice way to do this open up the res directory which stands for resources and right click on drawable and go to new and tap on vector asset if you look at clipart here android studio comes bundled in with all of these free open source icons that we can use and this is what we're going to be using to power the default version of our memory game so for example why don't we start by creating one icon which is the face so just search for face and we have this nice clip art and i want to change the color of this to be red so red is 255 255.00 choose that and then let's also rename this to be icyface tap on next and then this is just telling us that it'll be located inside of the drawable directory ic underscore face and tap on finish let's peek inside the created file and one of the things that amazed me when i first learned about vector graphics is that the file is simply xml data which describes the set of points lines and curves along with associated color information so the image that we're seeing on the right is completely described by the text in the xml file and so the really nice thing about these vector assets is that they're much much smaller compared to a jpeg or png file where you have to encode information about all these different pixels and there could be thousands of pixels in your image and the other nice thing about this is that these are infinitely scalable so because we're just defining the path data here whether the image is a hundred by a hundred or a thousand by a thousand this image will always be crystal clear so that's a really nice thing about these vector assets and so if we look back to the board size the maximum size of our board is 24 and that means we need to create 12 unique icons for our memory game so right now we have one we're going to create 11 more so let me explain the logic behind how i created the vector icons and you can do something similar so you're free to choose whatever icons you want in order to build your memory game but i did some thinking about it and there are two things that we would like to optimize for as we pick our icons one is that the icons the vector icons that we create should be distinct shapes and second they should be distinct colors and the idea here is that when you're playing memory you want to have each unique image be as distinct as possible the shapes will come simply because we're choosing different icons the colors are a bit more interesting so as we think about what colors to make our icons each color is represented as a red green blue component and each of these three components is an integer between 0 and 255. if you wanted to create as distinct colors as possible the way you would do this is try and have the distance between each color as per the rgb value be as different as possible so the first thing that comes to mind is why don't we light up or maximize each individual component that's how we get a solid red solid green and solid blue just by having each of the three components be 255 we can also do something like this where we go halfway on each so you have 128 0 0 and that becomes a little bit of a darker red and similarly for this dark green and this dark blue for the other six colors we can combine each of these three primary colors so we can make yellow by combining red and green and then i picked a couple others as well that you're welcome to copy from me as well so combining these colors with different icons that we picked here's what i came up with on the left is what i'll name each icon i see face flower gift and so on the second column indicates the name of this icon in the vector asset studio so you can find it and the third column shows you what the icon will look like with the selected color now let's go create these in android studio let's repeat the process for creating the face icon several more times so we'll right click on drawable go to new and go to vector asset the next asset we'll create is the flower local florist is the name and we'll change the name in our project to the ic flower and we'll change the color to be green tap on finish and now i'm going to speed through this for the other 10 icons all right done now we have these 12 different icons the next step is to reference them in column code so we can start to use them in our memory game so the way i'm going to do this is i'm going to create a new package called utils and inside of the utils it's going to be a kotlin file called constance and we're going to now define a list of these drawables that we just created so i'll call this default icons and it's going to be a list of all the different drawables so i see face then we have to import resources and similarly for the other 11 icons that we created i'm just going to reference all of them by saying r.drawable dot the name of the icon now we have this list variable called default icons which will be the icons we use in our memory game let's go back now into the main activity let me exit out a couple of these files and what we would like to do is pass into the adapter the list of image icons these drawables that should make up that game so we're going to have we're going to end up adding one more parameter here the way we'll do this is grab the default icons that we just defined i'm going to randomize that list and then we're going to take a certain number and the number of images that we take will be board size dot get num pairs and the reason we want to do this is because for example in the eight card memory game we're going to have four distinct images right it'll be the number of cards that i bet you which is what we're doing in get num pairs so we're going to take four images out of the default icons so this is going to return to us the set of chosen images for our memory game and now what we want to do is we want to double up those images so we'll end up with two copies of each image we'll say randomized images is equal to chosen images double it up so we have each image in there twice and we want to randomize that list by again calling dot shuffled and now this randomized images list is what we're going to pass in to the adapter so tap on that red light bulb and add the randomized images as a parameter tap on refactor and then now let's go into the definition of memory board adapter and i'm going to rename this to be card images it's going to be a list of int these integers represent one of these drawable resources so now we can actually start to reference this inside of bind so what we want to do is based on the position we want to grab the corresponding image and that should be the image on the image button so they set image resource and that'll be card images oops we have to actually make this card images a private valve so we can reference it now go back here card images and position let's try it and looks like we have a build error here i need to add in the closing bracket let's try it again this succeeded so right now you'll remember in mainactivity.kotlin we're hard coding in the board size of hard which means we have 24 memory cards in the game and you can see that all the vector icons that we created are in this board and there are exactly two copies of each and because we're randomizing it if i run this application again we should see that these images are in different places so right now we have this graduation cap the school icon in the top left let's run this again and hopefully that should be in a different position now so you can see it is and then if we also go back into the easy version of the board run this now we should be randomly picking four images out of the 12 that we have and there should be two copies of each placed randomly among the eight positions and if we run the app again we should have chosen different images and they should be in different positions which we are seeing here awesome so now we have this welldefined board size concept along with a set of icons to play the game in the next part we'll start implementing the game logic the goal for this segment is to lay the groundwork for the memory game logic that will write and the key observation here is that every memory card will have an associated state so for example a memory card can either be face up which means that the image is showing or it can be face down which is the default state in how the game starts and so in order to capture all of that we're going to create a data class in kotlin representing one memory card so open up the project tool window and inside of the models directory let's create a new kotlin file called memory card this is going to be a data class and the objective here is we want to list out every attribute of a memory card so first off is we're going to capture the idea of an identifier for the card this represents the uniqueness of the memory icon which is the underlying resource id integer of the memory card and this is going to be of type int because the actual identifier is going to be a drawable resource that we defined earlier the second attribute of a memory card is whether it's face up or face down so we're going to define another attribute called is face up which will be a boolean and this will initially be false because everything will start out all memory cards will start out face down there's an important distinction here of val versus var a vowel is something which once it's set the value of it can't be changed whereas var means that the value can be changed during the course of a memory game we'll be flipping cards over which means that the is face up property will change over time and therefore it has to be a var on the other hand the memory card identifier will never change once it's set so that's why we made that a vowel there's one more attribute of the memory card which is is matched and that represents if this memory card has found its corresponding pair and as you play the game you're going to be matching up cards and when you've matched everything up you won the game and so this is also going to be a var is matched and it'll be a boolean with initial value of false okay so now that we have this data class in main activity.kotlin each randomized image that we have this list of images that make up the memory game each of those will correspond to one memory card and i want to create a list of these memory cards and the way we'll do that is we're going to utilize the map function on randomized images and what that does is for every element of randomized images we're going to do an operation and create a new list we're going to transform randomized images into a new list in particular create a new memory card object we're going to call the constructor memory card this takes the three parameters that we just defined first is it is the identifier and that will be the current randomized image that we're mapping over and we refer to that as it and then there are two more parameters here one which is is face up and third is is matched because we define a default value for is face up and is matched we actually don't need to specify here so this can be as simple as randomized images.map memory card of it and this is now going to return to us a list of memory cards and instead of passing in the list of randomized images i instead will will want to pass in the list of memory cards so let's update the third parameter of the adapter to be of type memory card going to memory let's go into the adapter and change this to be just cards now we can actually start doing something interesting with setting the image resource by default the image resource should be face down it should be the default image and only if the card is face up do we want to show the corresponding image and so here what we're going to do is grab the card at that position and check is it face up or not and if it is face up then we want to show the drawable image so we'll call cards position and then passing the identifier and otherwise we want to pass in the default icon which is the face down and that will be r.drawable dot ic launcher background and one thing we can do just to make this a little bit cleaner is save the variable of card's position into a local variable so what we're saying here is that if the memory card is face up then we will use that as the image otherwise we'll use the background so if we try this now we should see a change such that all the cards are face down initially and the next step is when we actually tap on one of these we would like to be able to toggle or switch the value of this property is face up before doing that one more thing i'd like to do is have a separate class which will encapsulate all the logic for the memory game so right now we have a data class which represents one memory card but there's also a notion of the game itself has some state and we would like to be able to maintain that in in a class as well and so we're going to again go back into the same directory which has memory card the models class and let's define a new column file called memory game and this memory game is going to take in the board size and we want to delegate a responsibility of creating all the cards into the memory game that shouldn't happen in the main activity that should actually happen inside of the memory game and so let's add in as a constructor the board size here the cards are going to be a member variable in this class i'm also going to have a couple more which we're going to add over time but to start out with we're going to have one which is num pairs found and this is going to be zero when you start the game you have found no pairs in the constructor of the memory game we're going to do the work to populate these list of memory cards i'm going to add this in the init block and the work we're going to do here is exactly the work that we already did over here i'm going to copy all this the idea is that we are constructing the list of cards based on the board size we are picking some random images and then based on that creating a memory card data class so now all we need to do is construct our memory game and the third parameter of memory board adapter should be the list of cards which we can now get a reference to using the cards property of the game awesome so again there's no functional change here all we're doing is kind of moving some code around so it's cleaner to understand where we'll add logic in the future the last thing i want to do is changing the state of a memory card when we tap on it going into the memory board adapter here is where we are getting notified of a click on an image button and we would like to notify the main activity of this click so that the main activity can then tell the memory game class that the user has taken some action and we should update the state appropriately and so the standard pattern for doing this is to define an interface so let's do that up here it'll be interface card click listener and this is going to have one method called on card clicked and it's going to take in a position which is of type int and the reason why we're defining this interface is because whoever constructs the memory board adapter it will be their responsibility to now pass in an instance of this interface and so i'm going to add one more variable in the constructor called card click listener and this is of type card click listener and now when an image is clicked we are going to invoke this method on the interface so i'll say card click listener dot on card clicked with this position well and so now back in the main activity we're going to get an error right here because we haven't passed in cardclicklistener object and the way we'll do that is by writing the word object and specifying we want to create an anonymous class which is of type cardclicklistener and here android studio can help us with this red underline under object android tells us hey this is the interface so in order to implement this you have to override this one method on card clicked and so now here is where we can add logic for toggling the is face up property of this card so for now i'm just going to put a log statement here just to make sure that we are able to actually get notified of the card click back in main activity and then we need to find a tag for this let's do that all right let's run it so we're not expecting any functional change but now if we open up logcat so now we're seeing two log messages every time we click on one of the cards the first one is coming from the memory board adapter and the second one is main activity being notified of this card click at the same position so in the next segment we're actually going to write the game logic for being able to flip over the card and also create matches our goal now is to implement the logic for the memory game so when i tap on a memory card i should be able to flip it over and also there should be some logic to check if two cards that have flipped over are matched this is a interesting challenge and you'll find that if you break it down case by case the code actually becomes quite simple so in mainactivity.kotlin we have a log statement here for when the card has been clicked and so i'm going to delete that and let's actually delegate the work of this into a method called update game with flip at this position all right and the idea here is that this method is responsible for updating the memory game with an attempted flip at this position all right and so we're gonna just delegate the work here into the memory game and so in order to reference memory game i need to make this a property of the class so create property memory game and it'll be late init var so late in it because we know that memory game is going to be initialized properly but it will only happen on create so that's why we're going to add this as late in it and then one other variable that i would like to make into a property is the adapter so we're going to split the assignment and the declaration of the variable and then we're going to define another variable which is a property of the class called adapter and this is of type memory board adapter so now we can reference adapter from multiple methods and not just the oncreate method so in the update game with flip the memory game itself should be responsible for handling what happens in the state of the game when the memory card at this position is flipped we're going to create a method on the memory game class called flip card and it'll take in a integer parameter called position analytics video will help us to create it and then i'll put this down here here is the game logic that we're going to write to start out with just to make this simple why don't we simply change the value of the is face up property of this card so i'm going to grab the card at this position save that into a variable called card and then we're just going to say card dot is face up is the opposite of what it was so if it was face down before it's gonna be face up if it was face up it's gonna be face down because the user is flipping it over and so once we've flipped the card then we need to tell the recyclerview adapter that the contents of what it's showing has changed and so it should update itself and the way you do that is adapter.notifydatasetchain let's try it so now if i tap on any of these you can see that this underlying image resource is shown and i can go back and forth as well so i can toggle between them so now let's think a little bit more about what exactly should happen when the user attempts to flip over a card so for example if i restart the game if i flip over this card and let's just pick another one like this the next card i flip over should automatically flip back to the default state the two cards that are currently flipped over and so the memory game has to have some some state or some notion of which cards have been previously flipped over and which have not and as soon as i flip over another card now both of these should have gone back down to face down and if you think a little bit more about this it really comes down to exactly three cases so first is there were zero cards previously flipped over second is there was exactly one card previously flipped over and the third valid case is there are two cards previously flipped over this is the totality of what is possible in a valid memory game you can never ever have three cards flipped over at once so now let's go case by case and figure out how the memory game should be updated when there were zero cards previously flipped over all we need to do is simply flip over that card there's no need to flip over any other cards in the game and there's no way a match could be found yet because after this turn is over only one card will leave left over but you need two in order to make a match moving on to the next case if there was one card previously flipped over we will always flip it over but we also now want to check whether the two cards that are going to now be flipped over if they match and if they do match we want to indicate to the user at the ui layer that the match has been found and we no longer want to allow these cards to be selected or flipped over again and finally in the third case when there were two cards previously flipped over we first want to restore the cards and make them face down again and then we want to take the card at this selected position that the user tapped on and flip that card over so if you can understand these three cases then the rest of the logic is pretty straightforward and one thing i can do to make this even simpler is you'll notice that this case when there are zero cards flipped over or there are two cards left over they're actually identical and the reason is because i could just copy over the same statement restore cards plus flip over selected card into the first case and the idea here is that if there were no cards flipped over previously then this restore card is essentially a noop so it has no impact and then we will flip over over the selected card and so we've reduced these three cases down into two cases that means the only information we need to distinguish between these two cases is if there was one card previously flipped over and in particular the position of that one card because we'll need that in order to check if the images match this is the key in sight and so what we're going to do is have a variable here called private var index of single selected card and the type of this variable will be a nullable int with initial value of null because when you make a new memory game there is no single selected card so now we can actually start hooking this state up into the flip card method so if the index of the single selected card is null what does that mean that means that there were either zero cards previously flipped over or there were two cards previously flipped over so in this case like we broke down here in the pseudocode the first thing we want to do is restore the cards and then the second thing we want to do is update the single selected card to be this flipped card right so let's say index of single selected card is now equal to this position that was flipped over so let's define this method restore cards and this turns out to be fairly easy we'll just iterate through the list of all cards that we have and we want to set the is face up to be false which basically means turn everything back to the default state there's one caveat here though which is that if the card isn't matched then we don't want to do that right so we only want to set the card to be face up if the card is not matched so i'm going to add exclamation mark here and say if the card is not matched then restore it to its default state awesome so in the else condition this is when we have exactly one card previously flipped over so now as per our pseudo code we need to flip over the card and then check if the images match and so let's write that logic add a method here check for match and we're going to pass into this method two positions on the board on the memory board and the objective is that this function will return to us true or false on whether those two positions on the board are identical images or not the first parameter will be index of single selected card and the second will be position and this is going to return to us whether we found a match or not so let's define this method check for match so the first parameter can just be position one and the second can be position two and the return type will be a boolean on whether a match is sound or not so if the card at position one if the identifier of that is not equal to the identifier at position two then we know that the user has picked incorrectly these two cards are not a match however if these cards do match then we need to update the state of those cards to be is matched is equal to true because now we found the pair the user has found the pair so we should set is match to be equal to true and if this happens we want to update this variable num pairs found and increment it and then let's hit return true all right let's see what is the issue or happening here the num pair is found we defined it as a vowel and it actually should be a var because that will change over time okay and there's one more error here saying that smart cast to int is impossible because index of selected card is a mutable property in order to force this to be a nonnullit i can just use a double exclamation mark to tell the collin compiler to not worry about this and the last thing we're going to do here is that if we get into the else branch which means there was exactly one card previously flipped over after the user has finished flipping the card then there will no longer be exactly one card slipped over and so we need to set index of single selected card to be null and the reason i wanted to save this found match variable is i would like flip card to return to us a boolean on whether a match was found or not and so i'm going to define a variable up here called var found match this is initially going to be false and then it might turn true when the user has flipped over two cards and we're checking the value and then here we're going to return the value of found match before testing this out one more thing i want to do is in the check for match method if our logic is correct we will now set the boolean property is matched when cards are indeed matched and so back in the memory board adapter we can use that information to update the ui appropriately in the bind method based on whether the memory card is matched or not we will set the alpha property of the image button view so the alpha value refers to the opacity how visible is the the image button and so if the memory card is matched we'll set it equal to a lower value 0.4 in order to fade it out and make it less prominent and the f here stands for float which is a different kind of number compared to an integer and in the else condition we will set the value to 1.0 which is a default full bleed opacity and one more thing we can do here is if the memory card is matched then we can change the background of matched cards to be a little bit grayed out and the way you can do that is i can say context compat dot get color state list context r dot color dot color gray and we're going to define what that is also null this is now going to be a color state list and we're going to call this method view compat dot set background tint list image button color state list the idea here is that the set background tint list is a way to set a background or shading onto the image button and so if the image is matched we're going to have a gray background which we create using contextcompat.getcolorstatelist with the gray color and that will be one more visual indication of the user that this card has been matched so let's now define this color resource so have indirect video help me to create a color value resource color gray and the value is going to be this gray color eo times three tap on okay and just to show you what that did if we command click or control click on color gray it added one more line into the color xml with the color that we picked all right let's try it it looks like we have an error here invalid color and i think i just forgot the hash symbol here all right let's try one more time so i'm going to flip over a card flip over one more and in this case these cards don't match so we don't apply the different ui effect of cards being matched but now the here's the real test when i flip over a next card both of these cards should go back to being flipped over let's see if that happens okay awesome so you can see that both of these did go back and now we're flipping over exactly one card so we're playing a valid game of memory now let's see if i can find a match so here's a house and the other house was here so there you can see that we found a match and that resulted in us having this gray background color applied to the button and the alpha value goes down to 0.4 this is a nice way of telling the user that these cards have been matched already all right we found one more match and one more thing i want to try here now is both of these cards are flipped over let's say now i actually tried to tap on this graduation cap one more time that's a little bit weird it actually led to this memory card being flipped back to the state and this one stays flipped over the correct thing to do here is not allow the user to make this invalid move let's try one more time so if i click this card again we're kind of in this bad state now where the user is able to tap on something which shouldn't be a valid move in memory that is what we're going to handle in this update game with flip method so here we need to do some error handling there are two errors that can happen one is if we've won the memory game and second is if that memory card is already face up so first if we've won the game of memory this is going to be a method defined on the memory class on the memory game class then we want to return because this move isn't valid so we want to maybe alert the user and the other error case is if the card at that position is already face up and then same thing in that case we want to tell the user that this what they're trying to do is invalid and then return early so let's define have one game but this is pretty straightforward because we know how many pairs have been found that's this variable here num pair is found so we know we've won the game when the number of pairs is exactly equal to the total number of pairs that should be in this board so we'll say board size dot get num pairs let's also define this is card face up method and again this is pretty straightforward all we need to do here is grab the cart at that position and check the value of is face up so in order to check if this actually worked i would like to show some ui when either of these things happen and the way we can do this is by using a snack bar the snack bar is an android component which shows up at the bottom of the screen and you can use it as a way to message to the user about something so i'm going to say snackbar.make and we need to pass in a view here the root view i'll call this yellow root and i'll define that in just a little bit i'll say u already one and then we need to find a length here snack bar dot length long and then show it and then if the card is face up then invalid here we need to define the root element on which this snack bar will be anchored and that's pretty easy to do all we want to do is go into the activity main and this cl root is going to refer to the constraint layout the very root element so i'll give this an id of cl root go into main activity and let's define that up here just subtype constraint layout and then we need to add it right here clru is able to find view by id r dot id cl root okay so hopefully the errors went away with the snack bar awesome let's try running this one more time i flip over a card let's try flipping over the card one more time and you can see invalid move which is great so in a in actual game of memory you shouldn't be allowed to flip over the same card twice so we have to flip over one more card after we flip this one over awesome so if i do the same thing that's invalid and let's actually play the game okay now we've won so now at this point we shouldn't be allowed to flip over any card right so if i tap on any card you can see that we get that snack bar you already won so just to review what we're doing here is in the update game with flip method the user is attempting to flip a card at that at this position in the recycler view and we're doing some error checking to begin with and then down here we're actually flipping over the card and this flip card method returns a boolean now i'm going to capture that let's put a log statement here indicating that we found a match and let's also print out the number of pairs that the user has found so far and that data will come from the property num pairs found on the memory game this is the core game logic for playing memory so if you have any questions or confused about anything drop a comment and i'm happy to help as much as possible in the next part we're going to update the text views at the bottom of the screen in order to show how the game is progressing the last part was quite heavy because we were implementing the core game logic fortunately this part is quite a bit easier because all we want to do is update the text views at the bottom of the screen to show the progress in the game let's start with the text view showing the number of pairs found so right here we are capturing the return value of memory game.flipcard and if that returns true the user has successfully found a pair of matching memory cards and so in that case we would like to reference that text view which is tv numpairs and set the text attribute to show this higher number of pairs found let's say memory game dot num pair is found and this is a value out of the total number of pairs which is board size dot get num pairs and here also we can do one additional check if the match is found then there's a potential that the user has also won the game and so we're going to check that so if memory game dot have one game and in that case we just want to show a message to the user u1 congratulations one quick correction from before if the user has made an invalid move by tapping on a card which is already faced up i want to make the snack bar length short instead of long the second text view in the bottom is for the number of moves the user has made if the user has gotten past the first two error checks the user has made a valid card flip and so right here we want to update the textview showing how many moves the user has made memorygame.getnum moves this method doesn't exist yet on the memorygame class so android studio can help us to create it and this is going to return an int of how many moves the user has made so the logic here is that as soon as i flip one card over i haven't actually completed my move yet my turn in the game or my move is only over after i've flipped over two cards so the number of moves will be half the number of card flips so we're going to define one more member variable or property on the class called num card flips this property will be private because we don't need to expose this information outside of the member game class and a var because the number of card flips will change as the game is being played we'll set it equal to 0 initially because in a new game there are no cards flipped yet and we'll increment this num card flips variable every time we get into the flipkart method because we know at that point we have a valid card flip now we simply use this value to compute the number of moves and we'll just do num card flip divided by two and notice here that we are going to be doing integer truncation so if the number of card flips is five when we divide by two the result of that will be two because we're rounding down and that makes sense because when i've made five card flips i'm in the middle of my third move i haven't yet completed it and so we still want to show number of moves being two let's try it so now as we play our game we should see both of these numbers go up okay so i made two card flips and then this makes sense now i made one move okay so now i made two moves because i flipped over four cards total and i got lucky with this last one and i found a pair so you can see how this also got incremented let's keep going awesome so now we see the snack bar u1 and the total number of moves is reflected properly along with the number of pairs the last thing we want to do in this segment is i would like to actually add in color interpolation on the number of pairs and this is a nice visual way for the user to know using a color their progress in the game so every time we increment the number of pairs we want to also update the color of the text view we'll say tv numpairs dot set text color we're going to pass in a color here and this color is going to be the result of interpolation so interpolation is a fancy statistical term but it's actually quite simple if i tell you that i'm walking a thousand steps and i'm 75 done then you would probably tell me i should roughly have taken 750 steps and what you're doing in your head is linear interpolation at the starting point i've done zero steps at the ending point i've done a thousand steps and so when i say i've done 75 progress you are estimating that i should be roughly 750 steps into that journey we're doing something identical here we're going to use a builtin class in android called argb evaluator which will take in the worst color meaning no progress has been made zero pairs have been found and another color representing full progress has been made which means the user has won the game and all the pairs have been found and all we need to do then is provide progress of how many pairs have been found so far in the game and based on that we will do interpolation between the worst color and best color and this is possible because like we talked about earlier colors are simply integer values behind the scenes so here's how we can compute the fraction of what progress has been made so far the number of pairs found divided by the total number of pairs and the issue here is that it expects a float rather than int so we're going to cast the numerator as a float the second and third parameter are the start and end value representing no progress made and complete progress made and so we're going to use context compat to get the color and then we're going to actually define the colored resource in our colors.xml file i'll call the color resources color progress none and color progress full so now we will create the color value resource and what i put in here is this red color because red kind of indicates to me that you've made no progress you're stopped so that's the burst value and then for color progress full i am using this green value which means that you've made it green means go so you've you've made a lot of progress and you've won the game awesome and then the set text color requires an integer and so we're going to now cast the value of this argb evaluator as an int let's try it as i make progress in this eight memory card game there are four pairs each time i should be 25 percent closer to hitting that green value so after one pair you can see the color changing a little bit and now you can see the full green color at the very end when i've won the game one thing you'll notice is that at the very beginning of the game we should see the color of that text view be red to indicate no progress but right now it's that default black color so let's fix that inside of the oncreate method after we've defined tv numpairs let's set the text color of that text view to initially be the color representing no progress color progress none which is a red color and if we try it we can see that the text view color is indeed red at this point we're able to play a fully functional memory game along with having information at the bottom showing how the game is going the goal for the next segment is to give the user some control to restart the game and also allow the user to control what size memory board they're playing with easy medium or hard the goal for this segment is to allow the user to restart the game that they're currently playing or to pick a new board size and try a different game so let's start out by adding a menu option for restarting the current game so let's go into project and go into resources and we're going to create a new resource directory android resource directory which is of type menu inside of this directory we'll create a menu resource file called menu main and let's start out with just one menu item we'll give this menu option a title of refresh but we'd actually like for this action to have an icon associated with it so we'll create a new vector asset called refresh give it a name of ic refresh and then tap on finish and we're going to set the icon attribute of this menu option to be this newly created icon we'd like for this menu option to show up as an action rather than being buried by default inside of the overflow menu which is what we're seeing here so i'm going to hit the show as action attribute and hit always which indicates the android system that we want this to be an icon rather than text in the three dot menu now we have to actually inflate this menu resource file that we just created in main activity so there's a method we will override called oncreate options menu so if you just start typing on create options then you should find it and we are going to get the menu inflator and inflate the r dot menu menu main and the second parameter here is the menu which is the parameter and then we'll return true because this method on create options menu requires a boolean return value now we want to get notified when the user has tapped on that particular menu item so first going back into menu main we want to add an id i'll call this mi refresh which stands for menu item refresh copy that and then the way we get notified of the user tapping on an option menu is through this method on options item selected so here we'll use the when construct so say when dot item id so based on the item id of this menu item we'll take a different action so the only one we have right now is r.id.mi refresh and in this scenario we want to set up the game again so setting up the game again basically entails doing all this logic again where we create a new memory game we set up a new adapter and then we set up the recyclerview with this new data let's push all of this logic into a separate function which we can then easily reuse so i'll call this setup board and paste in that logic in the newly created function and then my preference is usually to put all of these private functions below all of the functions that we're overriding i'm going to put this down here all right awesome so now let's just simply call setup board right here let's try it so hopefully now we should see a menu option up here where we can refresh so just click a few of these and then if i hit this option now i should be able to refresh the whole game yep and you can see that now we have different cards show up awesome one thing that is worth doing though is that if i'm in the middle of a game like this i've already made three moves and i already have found one pair i'd like to warn the user that they're about to lose their progress on the game and so right here if the number of moves in the memory game get num moves if that's more than zero and the user hasn't won the game yet then we should be showing a alert dialog to the user informing them that this is a dangerous operation because they might be very close to winning but they accidentally hit the refresh button for example so i'm going to delegate that work of showing the alert dialog to a method because we're actually going to show several alert dialogs depending on which menu option the user taps on so i'll say show alert dialog and then create a function for this we're going to leverage the alert dialog builder in order to create and show the dialog it takes in a context we'll pass in a title which will be passed as a parameter same thing with the view and then we'll get to the negative and positive button click listener a bit but first let's go back and add the title and view as parameters now we'll set the negative button text to be cancel and by passing null here we're basically saying just dismiss this alert dialog if the user taps on cancel we're also going to add in a positive button which will be okay and here we need to actually take action based on the user tapping on the ok button if we go into the declaration of set positive button the second parameter is onclicklistener which is an interface which has one method and that one method has two parameters but neither of these is actually relevant to what we need to do here so in order to indicate that we're still adhering to that signature we're going to put in underscores to say that that's the method we're writing and this is where we now need to take the action based on what happens when the user taps on ok and that has to be something that's passed in as a parameter to show alert dialog so i'm going to add a third parameter here called positive button click listener and that will be of type view.onclicklistener now we can call the on click method of the positive click listener which takes in a parameter of u which we don't care about so we'll pass in null here so now let's look at how we can use this in the show our dialogue method we'll pass in the title which will be quit your current game we don't need to show any additional information so the view of the alert dialog can be null and then we're going to pass in the positive button click listener which is what should happen when the user confirms this alert dialog and we're just going to call setup board and in the else condition the user is not in the middle of a game so we can just unconditionally call setup board so if i make some moves like this and now i refresh you can see that before setting up the game again we had this dialog which has the title that we specified along with two buttons cancel or okay so if i cancel all we're doing is exiting the alert dialog but we haven't actually taken action which is what we want on the other hand if i tap ok now we are properly resetting the board which is exactly what we want one other issue that you'll notice is that we aren't resetting the value of these text views properly when we call setup board so let's fix that so go into the setup board method so depending on the board size we would like to reset the value of those text text views at the bottom so board size is an enum and so now because it's an enum we know what are the possible values of this so we'll have android studio help us to add the remaining else branches in the easy case we'll first set the tv num move text view and we'll set that to be equal to the current game being played which will be easy and that's a four by two grid and the number of pairs is going to start at zero and there are four pairs total in the medium case we'll describe that the board is six by three and the number of pairs total will be nine and then finally in the hard case the board dimensions will be 6x4 and the number of pairs is 12. because there are 24 cards so i'm making some moves and so now if i reset you can see the number of pairs has gone back to zero and i also reset this back to a description of what game we're playing awesome the next thing we want to do is add one more menu option which will allow us to change the size so right now the only game we can play is easy but i'd like to have one more menu option which allows us to select easy medium or hard so for that let's add one more menu option in menu main and this one i wanted to actually show up in the overflow menu so i'm going to say show as action never and the id of this will be mi new size title will be choosing size all right so going back into main activity in order to handle that menu item being clicked in the on options item selected in the when expression we'll add the id and we'll create a function called show new size dialog one thing i'll also do is add return true every time that we're handling the menu item collect both for the refresh and this one so in this new function shown in size dialog we're going to call that function show alert dialog that we just created and the title will be choose new size we're going to pass in a view i'll pass in null for now but that should be a list of all the different options of board sizes and then when the user taps on ok we should change the value of the board size variable in the main activity all right so the objective here is that we want to create a new view which allows the user to pick between the various board sizes and the way we're going to do this is have a radio group and the radio group will have three radio buttons easy medium hard and that's how the user can specify which game they want to play and so we're going to inflate that view similar to what we did in the adapter the contacts which is this and we want to inflate r.layout.dialog board size and pass in null for the second parameter and this is going to return to us a board size view so now we have to define dialog board size so hit that red light bulb and let's create a layout resource file and then constraint layout is fine for the new element let's go into the design tab i'd like to i'd like to drag out a radio button group let's give the radio group an id a radio group and let's also add some horizontal constraints on the left side it'll be 0dp from the parent and also on the right side that means we can make the layout with 0tv or match constraint now let's drag out 1 2 3 radio buttons let's give the first radio button an id of rbez and then give it a updated text of easy 4x2 to describe the game the second radio button can be rb medium and the text will be medium which is 6x3 and then the third data button will be rb hard and that will have a text of hard six by four in the component tree you can see that red exclamation mark which indicates error and it says that there's a missing constraint on the radio group so if i go into the radio group we can see that it's actually not vertically constrained so i'll add a 0dp top margin from the radio group to the parent and that should resolve that issue one other thing i'll do is add a left and right margin of 16dp and 8db margin on the top just so we can create some space between the radio group and the parent alert dialog okay so now we have the dialog board size so this view is fine so now we want to figure out if the user taps on the ok button then the code here will get executed the value of the board size that we set in here will depend on which radio group button was selected and so we need to first define that radio group we need to pull it out of the board size view so i'll do that now and the radio group will mandate that only one of the buttons inside of it can be selected at a given time so depending on which of those was selected which is a checked radio button id we will set the board size accordingly so we want to add in three ids here rb easy and in that case the board size should be easy if the id selected was medium then the board size should be medium and otherwise the board size should be hard one more thing before we try this out is when we open up the dialog i want the current size board to be the one which is automatically selected in the in the dialog so depending on the board size we want to tell the radio group which items should be checked so in the case of easy then we want to check the rbez and once we have specified a new board size then we simply call setup board and that should take care of redrawing our whole board before running this we need to actually pass in the board size view which we constructed on 77 and pass it into the show alert dialog method let's run it and see what happens now we are able to see this radio button group and we have the easy radio button selected because we were playing a 4x2 grid let's select medium and see how the recycler view gets updated to properly show the 18 cards and let's also try out the hard version so if we go to the dialog again we see the medium is pretty selected and hard shows us the 6x4 grid and you can also see at the bottom the game info is also correct the last thing i want to do in this part is to update the color of the refresh icon because it's a little bit hard to see right now so this icon is what we just created it's called ic refresh and the color of it is dictated by this attribute here called android tint so i'm going to replace that and just use fff which is white in running the app again we do see that the menu icon is now white now we are fully done building out the memory game played with the default icons in the next part we'll allow users to create their own custom memory games by taking photos from their phone and using that as the back of each memory card instead of these icons in this segment we're going to embark on the creation flow where the user can create their own personalized memory game using photos from their phone the idea is that each memory card instead of having one of the default icons that we have put into the app we're going to have each memory card be a photo that the user has picked up so to start out with we're going to just add one more menu option here which will launch the creation flow so i'm going to go into menu main let's drag out one more menu item and then the title here will be create custom game let's give this an id of mi custom which stands for menu item custom and then show us action will be never we always want this to be underneath the three dots of the menu so now that we have that let's go into main activity and here is where we can register some action to happen when the user taps on that menu item i'll say r dot id dot mi custom and then we'll put this into a new function called show creation dialog let's define this create function and this creation dialog wall should be quite similar to show new size dialog because the very first thing we want before we navigate the user to the creation flow is we need to understand what size of a memory game do they want to create and so we're going to reuse the exact same dialog board size here and inflate that and that will be what we show in a dialog before we allow the user to go into the creation flow so i'm going to go ahead and just copy all of this and now we are going to show the alert dialogue so i'm going to copy this now although we're going to modify this a little bit so the title of this other dialogue shouldn't be choose new size it should be create your own memory board then the view will be the three different options of memory games and here we would like to figure out which board size has been picked once they tap on the ok button and so for that that'll be a local variable called val desired board size board and we're not going to set up anything here we just we want to navigate the user to a new screen or a new activity where they can actually start choosing which photos they like one thing i like to do before going forward is open up the dialog board size and have a default radio button selected so we're going to choose the easy radio button and what that means is by default when the user is creating a new memory board they're going to be creating an easy board but they have the option to pick medium or hard if they want now our objective is to create a new screen or new activity when the user has tapped on the ok button of this alert dialog so open up the same directory where my activity is located right click on it and go to new activity and we're going to choose empty activity and call this create activity because this will be the screen for creating a new board and then we'll just tap finish so the way we navigate between activities or screens in android is through something called the intent system so intents are fundamental to android they're basically requests to the android system or to another application to do some certain action so the intent that we're doing here is an intent to go from the main activity and launch the create activity so i'll say val intent is equal to intent and there are two parameters in the intent constructor the first is the context which is we're going to pass in this which is referring to the where we're coming from and the second parameter is the class that we want to navigate to and that will be the create activity dot java and now in order to actually navigate to the create activity we need to call this method start activity and there are two versions of the start activity method one is start activity and the other is start activity for result the start activity for result is necessary if you want to get some data back from the activity that you've launched so in our case we're going to be launching the creativity the user will be creating a brand new board there and then whenever that's done we actually want to get that data back in the main activity and allow the user to play that custom game that they just created and so we do want star activity for results because we want to get that signal back from our child activity about what is a newly created game so i'll say start activity for result and pass in the intent that we just created and because we're doing selectivity for result we also need to pass in a second parameter which is the request code i'm going to define that as a constant called create request code and we're going to have that be defined inside of the companion object of main activity say private const val create request code and i'll set this equal to 248. it doesn't actually matter what this is as long as it's some unique integer within your activity 248 is near and dear to my heart because that's the area code of where i grew up in michigan let's test this out by running the app and what we expect is when i tap on the menu option to create a new board and i confirm the alert dialog by picking a size then i should be navigated to a new screen which should be empty that should be the create activity and we can see that it's an empty activity and our goal now is to actually fill out the ui to allow the user to create this custom board one piece of information that we need in order to properly show the create flow is what size board does the user want to create what size game did they choose and that's actually the data that we collected via the radio buttons but we're not doing anything with that data and so android has a system with intents to pass additional data along with the request to do an action so here we're making the request to start the create activity inside of that intent we're going to put in an extra and that will be the desired board size so the extra has a key and value the key is always a string and the value is the the variable that we want to pass between these activities so the key i'm going to define as a constant extra board size and the value is going to be desired board size so we have to define extra board size i'm going to put this inside of the constants.kt file that we have from earlier and this has to be a string so i'm just going to have the string value be extra board size let's import this and the reason i'm defining extra board size into a separate file as opposed to within main activity itself is because we're actually going to be referencing extra board size and create activity and so for anything which is shared a shared constant between multiple files i'm going to put that into constants.kt rather than defining it into a single file now we've added this let's go into createactivity and let's pull that data out from the intent but the way this works is we will get the intent and get the serializable extra extra board size and we're going to cast this as board size right and we're going to save that into a variable called board size and actually i want this to be a member variable so we can reference it reference it across multiple methods say private late init var board size and now we don't need to declare it in the uncreate function one more thing i want to do is based on the board size i want to modify the title of the create activity to indicate how many pictures does the user have to select from their phone in order to make a valid game so the number of pictures the user has to select will be half of the number of cards in that game of memory so for example if i have a hard game that i picked which is 24 cards i need to pick 12 unique images from my phone and so that's what i want to communicate in the title of this action bar so in order to change the text we can say support action bar dot title and then this is going to complain because support action bar technically is nullable and so we can use a question mark operator which says only call this attribute if support action bar is not null and if that's the case then we want to set this equal to some string and we're going to set this equal to choose picks 0 out of 12 for example so if we pick the hardboard it would be 12 here if you pick medium it would be 9 and so on of course we can't hard code in 12 here so i'm going to define another variable which is num images required so this will be a private bar num images required and initially this is going to be negative one but as soon as we get the intent extra now we can set this equal to boardsize.getnumpairs and so now instead of hard coding in 12 here i'm going to pass in numbers required and one more thing i want to do before we test this out is on the support action bar there's an ability to instead of having the default appearance we can have a back button which allows the user to easily exit out of this flow and go back to the main activity if they want the way we can do this is say support action bar dot set display home as up enabled and pass in true here that'll modify the action bar to show a back button and then we need to actually take some action when the user has tapped on that back button this is similar to what we have done before so i'm going to override this method on options item selected i'll say if the item id is equal to android.r.id.home then we'll just say finish which means i want to finish this activity and go back to the main activity return through here and the reason this is android.id.home is because this id is defined within the android system the android sdk this is not a menu item that we added so that's why it has the android prefix here let's try it to go into the creation flow let's pick easy and so now you can see that we have um the back button and it says choose pix04 which makes sense because they're going to be eight images in the easy version of the game so that means we have to pick four different pictures if i tap on back then we go back to the main activity the last thing i want to do in this segment is do some quick adjustments into the ui in the activitycreate.xml so right now it's just a blank screen let's give us give ourselves a bit more space i'm going to minimize this and also let's delete some of the extra files that we don't care about right now so by default we have this constraint layout which is a new element and that's fine what i want to do is i want to drag out a button and this will be anchored to the bottom of the screen and this is going to be how the user can save their newly created game so i'm going to consider it to the bottom and also to the right and left and i want this to take up the whole screen width because it's a primary action this is what the user really is intending to do when they come to this screen width will be match constraint so it takes out the whole width and then i'm going to have a 16 dp margin on the left and right let me zoom in and show you a little bit closer and then also on the bottom let's add an 8 dp margin from the bottom of the screen let's change the the id to be btn safe and then let's also give this text of safe one thing that we'll want to do is by default the user shouldn't be allowed to tap on this button because they haven't actually provided the correct data in order to create this game right like it doesn't make sense to save the game without having chosen some images which we'll do in the later on and so to start out with search for this attribute called enabled and we're going to set this to be false so that grays out that button it looks good and then one more widget i want to drag out is an edit text and this edit text represents the name of this custom game that the user is creating so i want this to also be full width so drag this to the left and right and have it also be 16 dp on the left and right side of the screen and then i want it to be constrained to the top of the save button let's give it a margin of 8 dp from the bottom and the width can be matched constraints it takes out the whole screen with let's change the input type to just be text we don't want this to be a person name we just want it to be regular text and by default there should be no text here that's for the user to fill out but we do want to give the user a hint of what should be what what they should write in this edit text so in the hint attribute i'm going to write game name example panda fun and just a few more things before we wrap up first off i would like to set an attribute called digits on this edit text so search for digits and what digits represents is what is the valid allowable input in this edit text this game name that the user writes is going to be living in our database that we'll get to later and so we want to be we want to constrain what the user is allowed to actually put in here you can kind of copy what i did i'm allowing the user to enter in any of the digits one through zero through nine or a b c d all the lower case letters or underscore or dash that's it so there's no slashes allowed no question mark no period things like that and the reason for this is because i want it to be easy for people to be able to share the game name so for example panda underscore fun is a valid game name and that's also easy for me to communicate out to someone else as soon as we start introducing uppercase lowercase letters or slashes or things like that that will make it harder to communicate the game name to other people and also it actually might cause some issues in our database so it's better to constrain the user input here a couple other things i played around with this a little bit i want to set the ime options to be done action done and what that will do is they'll change the keyboard to have a check mark at the bottom right to indicate to the user that they've finished filling out this field and we can also change the id here to be et game name so it stands for edit text game name and if you go into the code tab there's one more change i want to make which is called important for autofill i'm going to set this to no and what this means is that we don't want the android system to be over eager and auto fill this field and finally specify the maximum number of lines allowed in this edit text which will be one that basically means that there are no line breaks allowed in this edit text which kind of makes sense we want the game name to be short concise and fit onto a single line let's try it so now when we navigate into the creation activity then we expect to see this ui at the bottom of the screen awesome so you can see the button is disabled and we have this edit text which has the hint that we specified and i can type in abcd and the letters like that but if i try typing in a question mark you'll see that it doesn't actually show up same thing with capital letters or slash and so on so that looks like it's working awesome so we have the shell of the ui for our create activity in the next segment we're going to start flushing this out a little bit more by allowing the user some ui where they which they can tap and select photos from their phone the goal for this segment is to continue to flesh out the ui for the create activity and in particular we want to show a grid of gray boxes which will be a indication of the user to tap on those in order to pick an image from their phone and the way we'll do this is actually quite similar to what we've already done with the main activity we're going to have a recyclerview which has a grid layout manager and that'll be how we construct this grid of images or grid of gray boxes for now the first thing i want to do is in the activity create in the design tab let's drag out a recyclerview let me zoom out a little bit so i want this recyclerview to be constrained to the right end of the parent and left end of the parent that's how we get zero and zero over here also concerning to the top of the parent and the bottom should be actually constrained to the top of this edit text and in order to have this to actually take an effect we have to change the layout width and height to be match constraint awesome so you can see how the recycle view now is taking up whatever is remaining after subtracting out these bottom components let's give this an id of rv image picker now in the create activity the first thing i want to do is get a reference to the three views on the screen the recycler view the edit text and the button so all these will be late in it var because we're going to declare them as member variables but actually set the value in oncreate so we'll just say rv image picker find viva id with the corresponding id and similarly for the edit text and save button similar to the main activity the recyclerview will have two core components the adapter and the layout manager the layout manager is easier so that'll be equal to the grid layout manager will pass in the context which is this and the second parameter is the number of columns that'll be the get with method on the board size one thing we can also do here is similar to the main activity i'm going to call this method set has fixed with set this equal to true because we are guaranteeing that the recyclerview dimensions won't change because we've allocated just enough space for it and now we want to set the adapter so i'm going to say rv image picker dot adapter and we're going to set this equal to an image picker adapter and this is the class that we're going to define this will take in three parameters first is the context and then we are going to pass in a list of the images that the user has chosen and so i want to define that as another variable up here call this private val chosen image uris there's going to be a mutable list of uri so a uri we're able to import this is a uniform resource identifier you can kind of think of it like a string which unambiguously identifies where does a particular resource live and so the resource in our case is an image this is an image which lives on the phone it's physically stored on the phone the uri is describing what is the directory path to locate this photo so when the user has picked two or three photos for example there will be two or three elements in this list two or three uris so that'll be the second parameter and the third parameter will be the board size let's have android studio help us to create this class we'll extract it to a separate file and the first parameter i'll rename it to be context the private vowel context second parameter is the chosen image uris and i want this to be just a normal list and not a mutable list and the third parameter is the board size and all of these should be private val just like before we would like to define an inner class view holder and that will be what we parameterize the constructor of the image picker adapter by so i'll define inner class view holder which inherits from recycler view holder and once we define this inner class now we can go ahead and override the three members or three methods of the adapter okay so the get item count is straightforward the number of images that the user has to pick is the number of pairs in this game so if i have a 24 card memory game then the user has to pick 12 images and we should be returning 12 here that'll be board size dot get num pairs that's why we passed in the board size as a constructor parameter and now let's implement the oncreateviewholder so again this is going to be quite similar to what we already did in the memory board adapter i'm going to call layoutinflator.from passing the context which is a constructor parameter i'm going to inflate a custom layout file that we'll define i'll call it card image parent and false this is going to be a view and let's now define this card image resource file i'm going to have the root element here be a linear layout because we can keep this file a little bit simpler and this is going to be really straightforward there's no need to embellish the design with any kind of card elevation or rounded edges or anything like that so the only thing we need to do is drag out an image view well and so i want to just hard code the width and height just to make this look a little bit more realistic to be 100 dp each give this an id of iv custom image and let's change the scale type to be center crop just like we had done earlier and let's also provide some margin on this element just so that the card views that we show in the creation and the creativity aren't glued next to each other there's going to be some space in between them so i'll search for margin here and set this equal to 8 dp cool one more thing is that the parent element the linear layout i want the height of this to be wrap content and then finally we want the image view inside of the linear layout to be centered so we're going to set the gravity of the linear layout to be center and one more thing we can do here also is on the image view if there is no image selected which will be the default state then i want to see the background color of the imageview and we're just going to have this be a hardcoded color which is coming from the android system called darker gray and you can't see that in the preview because we are using this sample image but you'll see it when we run the app so going back to the image picker adapter now we have this proper card image that we're inflating and similar to what we did last time this image view it shouldn't have a hard coded height of 100 dp we should instead be making proper use of the space of the screen and so we're going to do something quite similar so i'm going to look at the width of the parent which is the recycler view how much space have we allocated for the recycler view and i want to partition that up into however many images the user should pick across so that's the board size dot get width that'll be the card with and then the card height the maximum allowable card height will be the height divided by the number of rows in our board which is board size dot get height and again similar to last time we're going to define a card side length which is the minimum value of the card width and the card height so we're gonna have to import math.main from kotlin and so now we can grab a reference to this image by using the id so i'll say view which is the linear layout plus the image view and then inside of that view we're going to find the image view with this particular id r.id.iv custom image we're going to get the layout parameters and on the layout parameters now we can set the width and height to be the card side length that we just computed and finally the return value of this oncreateviewholder is a viewholder so we're going to construct this new view holder class and pass in the view that we inflated we can actually make this card height a valve just because we're not changing any of these again so similar to a view card with card height because these values are not changing we can set all these to be val and finally the onbindviewholder method so the intention here is given a particular position we want to define how do we display the ui there are two cases here so if you think back to the second constructor parameter the list of image uri so let me show you rename this to be just image uris so if the position that we're binding here is less than the size of the image uris that means that means that the user has actually picked an image for this position and we should show that image on the other hand if the position is larger than image uris the size of image uri something that we should just show the default kind of gray background to indicate to the user that they still need to pick an image if the position is less than image uris.size that means that we should showing the image selected in the image view so i'll delegate the work there to be in this bind method so i'll say imageuris.position on the other hand if position is greater than or equal to the size of the image uris the user hasn't yet picked an image at this point so we'll just say holder dot bind there's not really much to do but we're just going to define this method dot bind so there are two methods now that we're going to find in the view holder one which is bind without any parameters and the other has one parameter which is the uri at that position the view holder is wrapping the custom view that we defined in card image.xml so we'll grab a reference to the image view by saying private val iv custom image and that'll equal the find view by id on the item view now that we have a reference to the image view in the first version of the bind method the one which takes in a uri all we need to do is set the image uri on that ib custom image and the other thing we'll want to do is set a null click listener which basically means that we don't want to respond to clicks on this image view so in the second case this is where we want to actually be able to listen for the user tapping on this square on this image view because that will be an indication that they want to choose an image so what we'll what we'll do is say iv custom image.set on click listener and we'll implement this in the next part the goal is to launch an intent for the user to select photos let's try it and see what it looks like so as our app gets a little bit more complicated one thing that's worth investing in is thinking about how can we improve the efficiency of getting to the creativity right now we have to go to the menu tap on a couple different buttons and then finally get there one thing we can do which is a hack for developer efficiency is back in main activity in the oncreate function we can directly create the intent to navigate to the create activity so this will be similar to what we're doing when we tap on the menu option but we'll just do it right away so i'm going to create a new intent pass in the medium board size and then launch the activity right away this is definitely not something that we want to ship to production but in general anytime you have an opportunity to improve the efficiency with which you develop it's worth investing in so now when we start the app you can see we get a brief glimmer of the main activity but now we're navigating directly into the create activity we're seeing nine gray squares here because we hard coded in the board size of medium and what these gray squares are communicating to the user is that they can tap on them in order to select a photo from their device and that will be what's used in order to create their custom memory game one quick improvement we can make is if i scroll up or down in the recycler view we see this purple shadow which communicates to the user that there's no more content in the recycler view but that doesn't make sense in our context because we are guaranteeing the size of the recyclerview so if we go into the rv image picker and look for over scroll mode then we can set that to never and address that issue hey one quick tip i wanted to share with you if you're using an emulator like i am then in the next part we're going to be using some photos that live on your phone or on your emulator as part of building out the app and so if you're like me you probably don't have some photos by default on the emulator and so i wanted to show you really quick how you can do that so if you have a image like this one then all you need to do in order to have it show up in your emulator is drag and drop it onto the emulator and that'll copy the file and now in order to have it show up open up the list of all apps and look for photos or whatever is your gallery app on your emulator open up that gallery app and i found that sometimes it's helpful to force restart the photos app and then open it up again and hopefully we should now see this new photo that we drag and dropped onto the emulator now we can see the image that was previously on our laptop and now it's on our emulator so this is the easiest way for you to take images that are on your computer drag them into the emulator and then you can use them in subsequent parts when we start to build out the ability to choose photos from your phone in order to customize the memory game in the next segment we'll hook up the behavior of what should happen when a user taps on these grey image views in this segment our goal is to hook up the click listener when the user taps on any one of these gray squares or image views in the recycler view and the way we'll do this is once again quite similar to what we did with the main activity which is that in the image picker adapter we're going to define an interface and that interface will have one method indicating indicating that the user has tapped on this element and that will be how the create activity gets informed of a click and the create activity is what will launch the flow for allowing the user to pick a photo from their device so let's define an interface here image click listener and then this is gonna have exactly one function inside of it inside this interface called on placeholder clicked and the final parameter of the adapter is going to be an instance of this image click listener class so private vowel image click listener and it's of type image click listener in the view holder when we bind the set on click listener on the image view we're going to invoke the on click listener method of the interface so we'll say on placeholder clicked for image click listener and so now back in creativity we need to pass in this fourth parameter which is the instance of the interface so right object here and this is defining an anonymous class which implements the interface image click list center and there's one method we need to override and integrate will help us with that and tap on implement numbers and here is where now play on placeholder click means that the user has tapped on one of these gray squares these image views and so here is where we're going to launch the photo choosing flow and i'm going to delegate that into a method called launch intent for photos so this is the second time we're dealing with intents now we had one intent to go from the main activity to the create activity we're also going to have an intent here to launch the flow for the user to pick a photo and this is called the implicit intent because we don't actually care which application on the phone will handle this intent this request but we just want the user to choose either google photos or a gallery app or something else on their phone which will allow them to pick an image for our application to consume so what we had earlier was an explicit intent because we were explicitly navigating to this create activity and here the create activity is going to launch an implicit intent to allow the user to choose an image so let's define this method and i'll put this at the bottom below all of the overwritten methods and here we're going to have an intent and because this is an implicit intent we're going to just pass in uh intent action here intent dot action pick and there's a property on the intent called type and we're going to pass an image slash star communicates that we only really care about images we don't want video files or pdfs or any other kind of file and we'll pass one extra into the intent we'll say intent.put extra and this is a constant on the intent class intent.extra allow multiple so extra allow multiple is a constant defined on the intent class so this is the key and the value is true basically what this means is if the app that the user opens up supports it we want to allow the user to select multiple images and this is valuable because if i have to pick 12 images one at a time that can get tedious instead i might say i want to pick all the photos from today have all of them be imported into my application so once we have this now we can say start activity for result and we're going to say intent dot create chooser and we're going to pass in the intent that we just created called intent and then the second parameter is a car sequence or a string we'll pass and choose picks here and this is basically some text which which shows up when the user has multiple apps on their phone that can service this request and the second parameter to start activity for result similar to last time is a request code so i'm going to define a request code pick photos request code and we're going to define this inside of the companion object of create activity so inside the companion object we will define this constable pick photo code and i'll set it equal to 655 which is the street address of my favorite dorm at stanford brainerd hall one really important observation about what we're doing here is that with this request our application is going to need access to files on the user's phone and by default the android system doesn't give your app this permission this is where we're going to have to request permissions in the android permission model the first thing we'll do is open up the android manifest file and at the top let's declare that our application uses this permission and the permission is called read external storage because for example if the photo is located in the downloads or document directory of the phone we're going to read that location of storage which is external to our app there are two kinds of permissions in android normal and dangerous read external storage is a dangerous permission and what that means is just writing user's permission read external storage in the android manifest isn't enough for our app to actually exercise that permission instead at runtime the user has to be shown a dialog which informs them that this app my memory is trying to use this permission do you want to allow it or reject it and so that's what we're going to implement next so before we call this launch intent for photos function we need to check if the user has granted the permission or not i'll say if is permission granted then we can go ahead and call launch and temper photos like normal but if not then we need to actually request permission what i've written here is pseudocode so it won't actually compile but i just want to walk through the logic if the permission is not granted then we need to first request permission and then get a call back if the user has accepted and then once again call launch intent for photos to properly implement these we need to make calls into android system functions and i always have a hard time remembering them and i find them a little bit verbose and hard to parse and so i'm going to create a utility class called permission utils and have all the messiness of interacting with the android permissions api in that class inside of permission utils we'll define two functions first is permission granted and this will take in a context and a permission string and it'll return a boolean on whether the permission is granted or not and the body of the function will be context compat check self permission with the context permission and we see if the return value of that is equal to package manager dot permission granted the second function is request permission which takes in three parameters first is the activity which you'll need to import the permission which is a string and a request code which is an integer and the body of the function is activity compat.request permissions with the activity we need to pass an array of permissions so we'll construct that in line right here and then the request code so back in create activity let's actually use these permission utils functions in is permission granted the first parameter will be a contact so we'll pass in this at create activity and the second parameter is a string representing the permission so for that i'm going to define it as a constant called read photos permission in the companion object and this will be coming from android.manifest.permission read external storage to pass that in for the second function request permission i first want to define the request code so i'll say read external photos code and make it equal to 248 doesn't really matter what it is but as a best practice we should keep the two request codes distinct in request permission the first parameter is the activity so i'll pass in this at creativity second is the permission which is read photos permission and the request code is what we just defined we're almost done now this request permission function is going to launch an android system dialog asking the user if they want to allow my memory this app the read external storage permission regardless of whether the user accepts or rejects we will get a call back called on request permissions result and that's what we'll override there are three parameters here the first is the request code and the third one which is what we'll care about is the grant results so the first thing we'll do is check if the request code is equal to the read external photos code that we used to launch the permission dialog then we'll check the grant results and it should be nonempty because we're getting the results here and we'll check if that is equal to permission granted which means that the user has granted the permission if this happens we can go ahead and call launch intent for photos if not the user has rejected our app from getting the permission and we should inform the user the impact of this so we'll show a toast and we'll tell the user in order to create a custom game our app needs to have permission to get the photos from their phone let's try it and once you're on the app and we tap on one of these image views these gray squares if we've done our job correctly we should now see an android system dialog asking if we allow this application the read external photos permission so tap on it and you can see we do have this popup show up and this is a dialog that we didn't write it's coming from android so let's actually start by hitting deny and then we get the toast that we wrote now let's show one more time and let's allow it and now as a result of that implicit intent an application on the phone is opened up google photos which allows us to pick one or more photos that we can then surface in the my memory app let's go ahead and pick these set of three images and tap on done and you'll see that we don't actually update the ui at all with the images that we get back from the intent from the on activity result and so let's fix that and show the images here back in create activity the place that we're launching the implicit intent is right here and when we call start actually for a result whatever is the result of the launch activity we'll come back in a function that we're going to override called on activityresult the first thing i want to do in onactivityresult is check the request code does that match up with the request code that we passed in pick photo code that we passed in to launch the activity do those match if so then we know that we're getting we're processing the auditive results for the right intent and actually i'd like to do the negation of this because there are several cases where we know the data we get back is invalid if the request codes don't equal if the result code is not activity dot result okay or if the data is null in all three of these cases we should log a warning and return early because we won't be able to find valid photo data so we're going to add a log statement here and we'll log at the warning level log.w did not get data back from the launch activity user likely cancelled the selection flow now let's go up and define the tag in the companion object private cost val tag is equal to create activity and if any of these conditions are met we will simply return early on the other hand if we've gotten this far in the function we know we have valid data inside of the data intent and i've tested this on several different devices and based on my experience there are actually two different attributes that we care about on the data intent first if the application that's launched in order for the user to pick a photo only supports picking one photo then the selected photo will come back in the data.data attribute and that'll be a uri on the other hand if the application launched supports picking multiple photos and either picks multiple photos then that data will come back as part of data.clip data and we will prefer to use the clip data because that will have multiple images and the first thing we'll do is check if clip data is not equal to null and in that case we'll log at info level the clip data num images how many items are in the clip data along with the actual contents of the clip data object now we're going to iterate through the clip data so i'll say for i in 0 until the clip data item count we'll retrieve the clip item at that position in the clip data and now what we'll do is we want to get the image uri out of the clip item object so we're going to add this image uri into the chosen image uris and you'll remember we pass in the chosen image uris into the adapter and so having the image show up in our recycler view is as simple as adding it into chosen image uris so first we'll check if we still need to populate the chosen image uris check the size and if so then we can go ahead and add the clip item.uri into the chosen image uris the other case is if selected uri is not null so in that case we'll log the selected uri with a tag and just print it out and we'll also add it to the chosen image uris list the reason we're able to add selected uri unconditionally in this case whereas before we had to check the size of the chosen image uris list is because if we get into this method on it to be result that means the user has tapped on the gray placeholder image view and that means there's space for at least one more image in the chosen image uris list on the other hand in the case of clip data the user might have picked an arbitrary number of images for example 20 images but we only want the amount specified by num images required that's why in every iteration of the for loop we check how many images are in our uri list now we have added the image uris into the list so we can notify the adapter that the underlying data set has changed in order to do that we need to make the adapter a property or a member variable of the class so let's do that well adapter is equal to that and i'll just set the image picker adapter to be adapter and now this adapter it shouldn't be locally defined it should be defined as a member variable so let's do that private late init var adapter image picker adapter and so now let's get rid of the declaration here and just set this equal to the property awesome so now coming back here you can say adapter dot notify data set changed one more thing we should update is the title of the activity which informs the user how many images they've picked so far so on the support action bar we'll we'll update the title attribute to say choose picks and now the numerator will be the size of chosen image uris and the denominator will similar to last time be the number of images required all right let's try it out okay so we're in the creation activity let's go ahead and grab all three of these images awesome so we can see right away that the first three image views in our grid of nine are populated with those images that we picked and if we look at logcat we can see the log message from the creativity at info level which says the clip data num images is three which makes sense because that's how many images we're seeing in our recycler view let's also try out the case where we only pick one image so we'll tap on the great image view which is a placeholder and select the image of rochester downtown tap on done and now we can see that gets populated and again the logcat shows that this is clip data which means that we're falling into the case of the clip data not being null so on this phone we are always getting clip data back i have found that in some phones or in some applications where you're not allowed to select multiple images that's when you get into the case of the selected uri not being null try it out on your phone and see what happens one more thing worth pointing out is that once an image is shown in an image view you can no longer click on it so if we go into image picker adapter we're setting the click listener to null and that's what is preventing the click from being registered and that's a product decision that once an image is picked then the user has no ability to change it and if you wanted to you could modify this behavior to allow this kind of edit functionality but for now we're going to leave it as is notice at the top of the activity we have the action bar title to say choose picks 4 of 9 and looks like i am missing the ending parenthesis so let's go into creativity and fix that there's one final thing i want to get started on in this part which is the logic to enable or disable the save button there are two conditions that must be met in order to enable the save button first all the images must be selected so in this case we have nine images all of them have to be valid images and second there has to be a valid game name in the edit text and so when either of those two components on the screen changes that's when we might be enabling the save button so in the bottom of the audit tv result which means that the image has been selected i'm going to call this method should enable save button this function is responsible for deciding whether we should enable the save button or not but for now let's simply return true and try this out so now as soon as i select any image and i come back into the create activity now you can see how the save button is enabled because we're turning through there nothing happens when i tap on that button the handling of that will happen in subsequent parts this was a really critical part of the creation flow dealing with permissions and intents and filling out these images in the grid view all right this segment should be a little bit lighter our goal is to properly figure out whether we should enable the save button based on if the user has met the two conditions in order to save a new game first is they have to have picked out every image and second they have to fill out a custom game name the first condition is if the size of the chosen image uris list is not equal to the number of images required and that means the user hasn't picked enough images for the memory game size desired and in this case we'll simply return false the button should not be enabled the other condition is around the length of the game name the user creates for this memory board obviously an empty name is invalid but we also want to mandate a minimum length of the name for example a single letter like a or b shouldn't be a valid name so we're going to have two conditions if the et gamename.txt if it's blank or if the length is less than three then we want to return false and otherwise we can return true which would enable the button we're currently calling this method should enable save button whenever the user has picked an image but we also would like to call it whenever the text of that edit text at the bottom for the game name has changed so in the oncreate method we're going to add a text change listener on et game name we have to provide as the parameter a text watcher so the object text watcher and this has three methods that we need to override and we only really care about the first one after text change so i'm just gonna delete the body for the other two and leave them as empty and the logic here is very simple we're simply going to call that method should enable save button again and that will dictate the is enabled property of the btn save so every time the user makes any modification in that edit text we will potentially enable the save button one more thing that we should do here is set a maximum length of the game name so if the text of the game is too long it'll be painful to share with friends and family and so we're going to restrict the maximum length to be 14 characters and this turns out to be pretty straightforward there's a filters attribute on the edit text and we are going to set that equal to an array of filters and we're going to pass in one filter and it'll be an inbuilt filter called inputfilter.lengthfilter and we pass in 14 which is the maximum allowable length the result of what we've done is that the minimum length of a game name is 3 characters and the maximum is 14. this is a general good engineering practice which is always validating user input no matter what the user does the application should never crash and the steps you've taken here help to prevent anything unexpected from happening along those lines one more good practice is to define constants for these key values for example the minimum game length and the maximum game length can both be constants so min game name length will be 3 and max will be 14. so now it's very obvious in the code what these magic numbers represent so i'll pass in the max game length and the min game length as appropriate awesome so at this point if the save button is enabled based on the logic we wrote the user should be able to take the data that they've collected and save all that to firebase so anyone in the world can play their custom memory game so in order to make that happen let's add a click listener on the save button and the code that will execute when the button is clicked is going to be a method that we're going to define in a little bit called save data to firebase this method is responsible for taking all the images and the associated game name and saving that to firebase so let's have another studio create this function and i'm going to move this pilot function down below any of the other override functions that we have the actual logic of integrating with firebase we will do that in a subsequent segment but for now i want to put a log statement here and i want to write some logic for down scaling the image and the reason why i want to downscale is because the images typically on your phone are going to be quite large more than a megabyte or two megabytes and we're only showing you the image in the memory game in a very small square so downscaling the image means that we are able to use up less storage in firebase storage and also when we download the image it'll be faster download if you only have a few hundred users then the amount of storage you're going to take up on firebase storage is going to be minimal anyway so feel free to skip this part if you're not interested but it's also something interesting to learn about so let's put a log statement here and i'm going to have a for loop which now iterates over the chosen image uris and we're going to iterate through it with both the index and the element and i'll call that photo uri so we'll have this chosen image uris that with index so i'm going to find a method called get image byte array and this will take in a photo uri and this will return to us a image byte array and that image battery is what we're actually going to be uploading to firebase storage and this method is going to take care of all the downgrading of quality that we want so let's define this method and the return type should be a byte array the first thing we'll do here is get the original bitmap based on the photo uri and this will depend on the api version of the phone that this app is running on so i'll call this original bitmap and if the build.version.sdkint is greater than or equal to p which is android pie then the way to get the original webmap is by using something called imagedecoder.createsource content resolve a photo uri and then we call imagedecoder.decodebitmap with that source otherwise if we're running a lower version then we'll say mediastore.images.media.getbitmap contentresolver with the photo uri so this conditional is interesting what it means is that if the phone operating system that we're running on is running android pi or higher then the original bitmap will come from running those two lines of code and otherwise on an older version we'll run this one line of code in order to get the original bitmap now let's log the width and height of the original map so we can compare the size now versus after we scale it down so we'll log at the info level original bitmap.width and originalbitmap.height so i'm going to invent a method here called dot bitmapscaler.scale to fit height passing the original bitmap along with 250. let's define this class now i'm going to extract it to a separate file and put it into the utils directory tap on ok and the idea of bitmap scalar similar to permissionsutil.kotlin which we defined earlier is simply to create a nicer looking api or nicer looking method around some of the android apis so rather than typing out the code i'm just going to paste it in and then we can talk about it so as the comments describe the intention of these methods is to keep the same aspect ratio of the bitmap but scale it down as per the width or height passed in you can read through the math that's happening here in order to scale the bitmap appropriately it's not that complicated but the broader point here is that whenever you're able to take something complicated or harder to understand and wrap that around something simpler that's a big win computer science is largely about communication and what we've done here is we've taken something which is harder to communicate and wrap that complexity into something which makes it much simpler and that's a huge win now let's turn this into an object because this is a utility class it doesn't make sense to have multiple instances of a bitmap scalar so we can just call bemouthscaler.scale2fit height with a height of 250 and once we've done that now let's print out the scaled bitmap width and height the last thing we need to do in this function is to return the byte array and so at the bottom of the function we're going to define a new byte array output stream we'll take our scaled bitmap and then call the compress method on it and we'll pass in a compressed format of jpeg the second parameter is the quality reduction hundred means no reduction in quality and zero means a severe downgrading quality so we'll pass on 60 here and then we'll pass in the byte array output stream that we just defined and finally we'll return byte output stream dot 2 byte array so at this point we have gone through and down scaled the quality of each image the user has selected the job for the next part will be to figure out how to upload this to firebase storage at this point we have the list of all the images that we want to upload to firebase and we've downscaled them appropriately and we are now converting them into a byte array which is what firebase will take in in the upload process so in this segment we're going we're going to write the core logic for taking these photos and actually uploading them to firebase storage this will obviously require the use of the internet in order to communicate with our client our android device to firebase storage so let's open up android manifest and add in the internet permission one thing to observe here is that internet is a normal permission while read external storage is a dangerous permission which means that we don't need any of the runtime permission logic that we needed for read external storage we get internet permission for free in order to now upload this into firebase we need to have a new firebase project so what you should do is go to console.firebase.google.com let's tap on add project and let's call this project my memory continue and then let's disable google analytics for now it's not strictly required for what we're building and now firebase will take a couple seconds in order to build out your firebase project all right so we're done let's tap on continue and we're going to add an app an android app to get started so we're going to associate our android app to this firebase project so for the packaging let's go back into android studio go up to the very top and then here is our package name which is the thing that we had defined at the beginning when we were creating a new project copy that i'm going to leave the rest of this blank it's a register app and now we need to download this file google services.json and what we want to do is we want to actually drag this into the app directory the way we can do this is as shown in that photo go into the project tool window go into the project perspective of your project and inside of the app directory is where we're going to drag and drop that google services.json file so i just dragged it in and now in order to do it saying move file over so i'll say yes i do want to move this file over and now we can see we have google services.json so now let's go back into the browser and see what else we have to do so now we have to add in the firebase sdk or software development kit into our android app so in the project level build.gradle file we want to first check if we have the google repository and also in the dependency section add class path let's go back into the android perspective in gradle scripts the one which is in the root level we already have google up here and we also already have google down here we just need to add the class path for google services tap on sync now now in the app level build.gradle file we want to add this line for the gms google services plugin so let's exit this build.gradle file and open up this one and here at the top is we're going to add that copy that line and we have to modify this to match the format like that and now we need to add the dependencies for for whatever parts of firebase that we want so firebase actually has dozens of services within it we're going to only really need a couple of them so i'm going to copy this line for the firebase bill of materials so we added that and now below this we're going to add the dependencies for whatever products that we care about so let's open up this url there are two products in firebase that we care about firestore and storage so first off is cloud firestore and make sure that you're actually in the kotlin tab here so you get the kotlin version of these libraries so we're gonna have to say implementation with this library and the second product is cloud storage and the nice thing with including this build of material is that we no longer need to specify the version on each firebase product that we're adding in so let's tap on sync now now we've pulled in firebase into our project let's go back into our browser tap on next here and then tap on continued account console and here we need to enable the two firebase services that we're going to integrate into our project so let's start with storage and then tap on get started and tap on next choose a location which is close to you so for me it's us central tap on done so now we have firebase storage set up go into the rules tab and by default read and write are only possible if there is a logged in user on the client who's doing the request and we don't have a notion of an account or a logged in user in our app so i'm just going to set this equal to true and then if you're publishing this app of course you want to kind of be more mindful about who you're allowing to read and write data into firebase storage but for our purposes this is going to be fine the other product that we're going to use is cloud firestore so i'm going to create database and we're going to start this in test mode and test mode basically is something similar to what we just did it's saying that anyone can read and write to our firestore database as long as the time stamp of the request is within a month so for the next 30 days anyone can view edit or delete data in our database and again we're going to put the same location perfect so now we have our two products set up firestore and storage i wanted to spend just a couple minutes describing how cloud storage and cloud firestore work together in order to allow the user to create a custom memory game in our application this is the most critical part and most complicated part of our application so when the user creates a new memory game they're going to pick various images from their phone and each of them will be stored inside of cloud storage and when we successfully upload something into cloud storage we're going to get back a url which defines how we can retrieve that image later on so once we have a list of image urls for each photo that the user wants to attach into their memory game we're going to then take those list of image urls and upload that or push that to cloud firestore along with the associated key so for example in this case we have a memory game called corgi and corgi will have four unique images associated with that which is how we're getting eight memory cards and that will live in cloud firestore and so now when another user somewhere in the world wants to play this game this corgi game they can type that in to the memory game app and we will pull down all the images from firestore associated with corky and that'll be a list of four different image urls then that's how we'll be able to allow the user to play this custom game called corgi so the complexity here is due to the fact that uploading these images is an asynchronous operation so there are two kinds of programming one is asynchronous programming and the other is synchronous programming so most of the operations that you might be familiar with are probably synchronous for example if you're doing two plus two or any kind of simple arithmetic in kotlin or if you're combining strings those are synchronous operations in the sense that when you execute that you can expect a result immediately however what we're dealing with here is asynchronous which means that when we execute the operation we will not immediately find out whether it succeeded or failed because it might take a longer amount of time image uploads are a good example because images are inherently quite data rich there's going to be a lot of data and uploading that over the internet anything you do with the internet is going to require more time and so we're going to start the upload process on all the images that the user has picked out for their custom memory game in this case where the user has picked out the corgi game and we're going to start uploading all of them into cloud storage and the tricky thing is that the rate at which these images get uploaded it's not in our control so for that first image it might be halfway done uploading the second image might be totally not uploading and so on for the third and fourth we might have a different rate of uploading so the question now becomes how can we figure out when all of these operations have succeeded so we can record the image url corresponding to each image that we've uploaded and the way we'll do this is by getting notified when each image has successfully been uploaded so as soon as the image reaches cloud storage we will get a corresponding download url for that image and we'll track how many download urls have we received and the size of that list of download image urls is equal to the number of images that we're uploading then we know we're done and so we're going to continue this upload process until we get to this state which means that all the images have finished uploading and now we will have a list of image urls for each of the four corgi images that we have we're going to combine that with the custom game name which is called corgi and that is what we're going to send to firestore that is what we're going to implement at least partially in this segment so let's go back into android studio the first thing we'll do is get a reference to firebase storage and virastor so at the very top of the file call in the library that we included makes it super easy let's say private val storage is equal to firebase dot storage and then private val db which represents firestore and so going back now to where we have defined this image byte array our goal is to upload these into firebase storage the way that works is we're going to define a file path on where this image should live in firebase storage and i want this file path to actually be dependent on the game name so if you ever wanted to look at this from the firebase console it'll be easy to tell which images belong together so custom game name let's define this as et gamename.txt and then inside of that directory let's specify the current time in milliseconds dash the index and then this will be a jpeg file based on the logic that we wrote in get image by array and so the idea here is that if i have four images for example in the corgi game then that'll be saved in images slash corgi slash the current time in milliseconds dash zero one two three because there are four images this is a nice way to combine all the images associated with one memory game so now we have exactly what we need to upload the image to storage we have a file path and the actual underlying data for this image so we'll get a reference to the location of where we want to save this photo which will be storage.reference.child with that file path that we defined and we'll put the image better data at that location all right so this is the operation which will actually do this expensive work of uploading the bytes representing the image to firebase storage and so instead of getting the result of this as some return value here we will instead get a task which we have to now wait for until it succeeds or fails and so the way we can do this is we're going to say continue with task and what that means is this is an api defined by firebase which says this is a long running operation once it concludes then i want you to execute this code and i want you to also execute one more task so we're going to define what that is at the end but first the result of this put bytes is a photo upload task and from here we can actually conclude how many bytes were uploaded just to get some more info about what happened so photo upload task dot result and then if it's not null then we can check this bytes transfer field okay and then we have to end this block this lambda block with another task that's why we wrote continue with task and the task we're going to continue with is once this photo has been uploaded now we want to get the corresponding download url photo reference dot download url now you can see how the error went away again getting this download url is going to give us a task and so now we have to wait for the completion of that task and that's an asynchronous operation so in order to get notified of that we'll call add on complete listener and the parameter here will be the result of this this operation that we just triggered so it'll be called download url task and the first thing we want to check is did this operation succeed or not so if download url task that is if it didn't succeed then let's log in error and let's also show a toast telling the user failed to upload image if any of the images encountered an error while uploading let's set this as a boolean flag here did encounter error is equal to true so initially this variable is going to be false see about var don't encounter error is equal to false and then if we encountered an error in uploading any of these images then we're going to set that equal to true and if this happens we're going to return do a premature return because there's no point continuing the important thing to realize is that this add on complete list center will be called for every image which is uploaded and we don't control the order in which these are called right and so if this particular image url failed to upload then we'll go into this if block but if some other image upload failed then we wouldn't actually know from here and that's why we actually added this boolean did encounter error so if didn't counter error is true at this point that means that some other image has failed to upload and we again want to just return from the addon complete listener because there's no point in continuing otherwise we have been able to successfully get a download url so look inside the task look at the result and then cast it to a string and that will give me a url and at this point now we want to make note of the fact that this image has successfully been uploaded the way we'll do that is by keeping an array of all the images that have been uploaded so far so we'll call this val uploaded image url and that's equal to a mutable list of a string so down here we'll say uploaded imageurls.add and we'll pass in this download url now let's put a log statement here saying log.i with this tag and we'll say finished upload photo ui so if we think back now to that diagram how do we know when all the images have been uploaded turns out that's pretty easy right because we're keeping a track of all of the images that have succeeded so far in this list all we need to do is check the size of that list so if the size of uploaded image urls is equal to the number of images that the user has picked then we know we're done so we'll say handle all images uploaded so this is in some sense the success callback for the images having been uploaded and from here in this method we're going to pass in the game name and the uploaded image urls and this is exactly the information that we need if you remember to upload into firestore so that's what we're gonna handle later on uploading these two key pieces of information into firestore let's rename the parameters here to be image urls and game name alright that was some pretty heavy logic to think about and implement let's test it out and see if it works so one thing i want to do is right now we're launching the create activity with the medium size board which requires me to upload nine images that's too much for me i'm feeling lazy so i'm going to change this to be the easy board size rear on the app so we only have to upload four images now instead of nine let's tap on one of these images and let's grab these three so now we have one more to upload so let's get this panda picture okay so we still can't save the game because we haven't given it a name yet so let's say testing okay so now because we've added a valid game name now the save button is enabled and this tapping the save button is what will trigger these images to be uploaded into firebase storage let's try it and before i hit save i'm going to open up logcat and as we upload images we should see this log message in the creativity for the number of bytes that are uploaded along with the progress the status of how many images have been uploaded so far let's let's see if we can see those okay awesome so we can see that we have sporadically these log messages let's filter for create activity because that's all we really care about so you can see how the original width was a certain dimension and the scaled width is smaller because we're restricting the height to be 250 db this is logic that we wrote from before now we have four images that we're uploading so you can see we have four we're seeing this uploaded bytes log message four times which is great and as we upload each image we can see that the num uploaded goes up each time awesome so now to validate that this properly worked let's go back into the firebase console and check um firebase storage we don't expect anything to change in firestore but in storage we should hopefully have one extra directory in storage for this game and that's what we see exactly here so we have a directory called testing and this should have four images they're all prefixed by the current time milliseconds followed by the index which is what we have here and if you look at the preview we're seeing exactly what we had uploaded which is really promising awesome that looks really good and you can see kind of the rough size this is around 14k 4k and about 2.7 k so this is really pretty small so we're not actually eating up too much of the storage capacity in firebase storage and it's also going to make our app feel a lot faster because we're downloading less data as well and here's what the image looks like in the browser in the next segment we'll finish off the missing link of taking the image urls that we have along with the custom game name and uploading that to firestore so we're now able to upload images into storage but we haven't made the link yet to storing those image urls into firestore so that's what i want to do with you right now so if we open up android studio here's where we left it to do for given this game name and the set of image urls we now want to talk to firestore the way we do this is reference the db object that we have defined above and we're going to put this data into a document firestore organizes its data into collections and documents so all documents have to live in a collection and one document represents one entity in our database so each memory game will be one document and that document is gonna live in a collection which we're going to call games inside of games will be a list of all the custom games that people around the world have created and the parameter here is the path of the document which is basically the name of this document and it'll be game name and here we're going to set the data associated with this game and it'll be very simple all we really want to do is associate the image urls to a key called images images maps to image urls that is the data that we're going to put inside the document now let's get notified when this operation succeeds addon complete listener and the parameter of this lambda function will be a game creation task which indicates if this succeeder failed so if it didn't succeed game creation task is successful then let's log an error here and if this happens we'll return early otherwise we have succeeded so we can they successfully created game game name and then in this scenario let's show an alert dialog to the user to communicate to them that they've made the game and let's navigate back now to the main activity and play the game that they just created the user is only going to have one option on this alert dialog which is to tap on the ok button and when they tap on the ok button we want to pass back to the main activity the game name which has been created so i'm going to create an empty intent here and inside of this intent we are going to pass the game name they'll say put extra extra game name pass in the game name and then we'll say set result activity result okay and result data and then finally once we've set that data properly we'll call finish and we're going to show the seller dialog so we should define extra game name and this will be defined inside of the constants file let's import it awesome so let's try this now if we wrote our code correctly that means now we should not only upload images to firebase storage but also to firestore let's grab a couple images here okay so i added four and let's say test two and tap on save okay so after a couple seconds we can see that we have this dialogue popup where it says upload complete let's play your game test two so that seems promising let's see if it actually worked instead of firestore so i go back to firestore let's refresh this page and hopefully we should see a new collection called games now yes and we do the document name is test2 which is the same as the game name and inside of the document is exactly one field called images and images is an array of strings and each string represents the url for the image so for example i could copy this url open it up and we see one of the images that were uploaded awesome this looks great so there's a couple things i want to improve on here first you might notice that in save data firebase we are grabbing the custom game name based on the edit text and we are unconditionally creating a new game with this data however if another user in the world has already created a game called test2 or testing or whatever it might be then we're going to override that data right so we're going to go into firestore and when we call dot set all the previous data that was inside of that document if there was a previous document that will be overwritten and so what we actually want to do here is check if there already exists a firestore document with this game with this game name so right here the intention of the code that we're going to write is to make a check on firestore and ensure that we're not overriding someone else's data so the consequence of this logic is that once i create a game of a certain name for example abc no one else in the world can create a game with that same name abc and that seems like a reasonable decision to make so here what we want to do is call db.collection i'm going to target the same collection games and check do we have a document with this game name let's get it and that'll be how we figure out whether there is a game or not so the result of this asynchronous operation in this callback is we get a document and now we should just check if the document is null and if the if the document's not null and the data of the document is not null a game with this name already exists in our database and so we should not allow the user to create another game with this name so i'll say alertdialog.builder set title to be name taken set message set positive button okay no show all right otherwise we want to then execute all of this logic that we had from before so i'm going to actually put all that logic into a separate function called handle image uploading so let's create a function here and then let's move the parameter can be called game name and let's move all of this logic into that function we renamed this parameter to be just game name awesome so we added an unsuccessful center we should also add a failure listener in case for whatever reason we were not able to retrieve this document i don't really want to do anything too meaningful here just log and error so we can debug this if this ever happens one more thing that i want to do is as soon as the user taps on the save button then we would like to disable the button and the reason i want to add this button dot is enabled is equal to false as soon as the user starts making the network request is because if the user spams the button they would be attempting to create the same game multiple times which doesn't make sense so as soon as they hit the save button we wouldn't disable it so that no more saves are triggered and if we get a failure then we would like to enable the button again so they can fix this issue and change the name of the game and then they can try saving it one more time and same thing down here actually if there was a failure for some unknown reason like a network error then we'll allow them to retry by setting the button to be enabled again let's try that logic so we already have a game that we just uploaded called test2 so let me grab some images call this test 2 and save it and hopefully we should see an error saying name taken perfect so we say name taken a game already exists with this name name two please choose another okay and now we have the save button enabled again and we can try changing it to be test three and now hopefully this should work so you can see while the image upload is happening the button is disabled so the upload is complete and now we can go back to firestore and now we have test three here with these four images that we uploaded great the last thing i want to do in this segment is i'd like to give the user some visual indication of how much progress has been made in uploading these different images because this operation could take some time especially if you have the hard version of the memory game so you have 24 cards or 12 unique images uploading 12 images could take a while and so it'll be nice to provide the user some feedback on how many images have been uploaded already and this turns out to be fairly straightforward we can open up activity create and what i like to do is drag out a horizontal progress bar let's actually create some distance with the save button so i'm going to change this to be 150 dp from the bottom just so we can create a bit more space and now let's drag this out and i want the save button to be anchored to the top of the progress bar so get rid of that constraint and have this be referred to the top there and then the progress bar should be match constraint for the width and then we'll set the left constraint to be zero from the left end of the screen and also zero from the right end of the screen well it shouldn't be zero dp it should have some margin so let's have maybe a margin of 16 from the left and right end of the screen and also 16 dp from the bottom awesome that looks good so now as soon as we hit the save button we want this progress bar to show up and that will be the visual indicator to the user of how much how many of the images have been saved the one thing here is that the progress bar should only show up when this upload is in progress so initially it should be not visible at all and so for that i'm going to go into the progress bar and change the visibility to gone and the other way you can do this is if you tap on that progress bar element and the search for visibility you can change it to gone right here cool let's give this progress bar an id of pb uploading copy the id because we'll need that we'll need it for the create activity so let's go over here and call it pb uploading and this is a progress bar all right let's define that right here okay so now we have the progress bar as soon as the upload starts then we want to set the progress bar to be visible so where does that happen um in save data firebase what we're doing here is checking if the game name is unique so let's we're not going to set the progress bar to be visible here but as soon as we start uploading images that's when we want to set it equal to visible so i'll say pbuploading.visibility is equal to view.visible and here if we encounter an error then we want to set the visibility to be gone again because we'll we'll we won't make any progress at this point view dot gone and the interesting thing happens whenever we have successfully uploaded one image so right here is a success case we want to update the progress of the progress bar i'll say uploaded image urls dot size divided by the total number of images that we need to upload so for example in the hard version of the memory game we have 12 minutes to upload and we might have uploaded maybe six of them so far so that would be 50 progress so this progress requires some integer but the integer should be something between 0 and 100 and so right now this will always be 0 because we're doing integer division which will lead to truncation so in order to get something between 0 100 we're just going to multiply by 100. now the only thing left to do is let's set the prog the visibility of the progress bar to be gone when we're totally done with everything so when we get to the success case of all images uploaded and we've uploaded this to firebase as well right here we can set the view to gone again and actually i think it makes sense to do this even before we check if the game creation task is successful or not because once we've gotten into here we're no longer doing any network operations so we should set the progress bar to be gone okay let's try it so in order to make it a little bit more visible let's go back and choose the medium version of the game just to have more images to upload and let's pick all six of these images now we have three more to pick let's pick the three over here and then let's call this large test tap on save awesome so we see a progress bar and you can see how it's slowly making progress to upload each of those nine images so that's pretty cool and then we get the progress bar gets to the very end then shortly after that once firestore has informed us that it has successfully received the data then we show this dialog upload complete so tap on okay and then we go back to the main activity just to confirm this one more time now we do have in firestore this large test and it will have nine images instead of four because that's how many images we were uploading so now that we were done with the creation flow in the main activity that hack that we had earlier to automatically navigate there let's remove that after the creation activity is launched from here then we're calling start activity for result and so what we're going to do in the next segment is figure out the result passed back from the creativity and if it's successful and we have a new game created we would like the user to play that custom game now the user is able to create a brand new customized memory game our goal in this segment is to be able to allow the user to play that game in the main activity in the main screen and so we launched the creation flow with the start activity for result so we're going to capture the result of whatever the tile activity has done the creation activity in the on activity result method what we'll do first is just check if the request code is equal to the request code that we launched this with which is create request code and if the result code is equal to result code activity dot result okay so if that's the case then let's retrieve the custom game game name out of the data intent parameter so get string extra extra game name and so you'll remember the reason i'm i'm doing this is because in the create activity as soon as the operation to create the game is done then we set the extra game name to be the newly created game so that's what we're retrieving right here in the main activity if for whatever reason the custom game name is null then something has gone wrong and we'll just log that as an error and we'll return early otherwise we know the custom game name is not null so we have a valid game i would like to create a method called download game with this custom game name let's create this function and the idea of this function is to query firestore retrieve the corresponding set of image urls and use that to play the game of memory instead of our default icons so at the top of the file we need a reference to firestore similar to what we had in the create activity so right here i'll say private val db is equal to firebase top firestore and let's also capture the value of the game being played so it'll be private var game name is a nullable string and it's initially going to be null because when you're playing a default game with just the icons that we've predefined there is no game name um it's only set when the user is playing either their own custom game or a custom game made by someone else so back in the download game method we're going to query firestore inside of the game's collection that's where everything lives and we're going to try and retrieve the document called game name let's get it and then that operation might take some time this is asynchronous call so we're going to add a on success listener and we also will need to add a failure listener and then this this is easy but it's going to kind of log this so we can keep track of um what happened okay so in the success case here is where we're doing something interesting we are going to get back a document which has one field in that document which is called images and that will correspond to a list of image urls a list of string and so that mapping of taking this document which is what we're going to get back here and turning that into a kotlin data class is something that firestar will help us with so we'll say document.2 object and we want to map this to a data class that we're going to define and i'm going to call it user image list like that so let's define this now create class and i want to put it into the models directory that we already have and this is going to be a data class there's no body the only thing that we really need to define here is the field name of what this entity or this data class will hold and there's only one which is called images so it'll be val images and it's going to be a list of string and it's going to be nullable and the reason it's nullable is because firebase mandates that every time you do this kind of mapping between a document you get back from firestore and into a data class it needs to have a default value and so it's going to have a default value of null and one other thing that we should do is annotate this field with a property property name i'll say property name images this is how firebase will know that here's the key called images which is defined over here and it maps to this attribute which is a list of string cool so back in my activity now that we've done this document.2 object we will get back a val user image list if user image list is null or if the images attribute of user image list is null then something has gone wrong and the shorthand for this is to do user image list question mark dot images so i want to log this as an error invalid custom game data from firestore let's also put a snack bar here to just message this out to the user cl root and then this is the error case so where it's going to return early here okay so if you've gotten past this return statement if you've gotten past this if block that means that we have found a game successfully so now we want to reset up the recyclerview with this custom data so first off let's compute how many cards are in our memory game so val num cards is equal to user imagelist.psy.images.size times two so for example if there are four images inside of our image list that means that the total number of cards should be eight because we're making pairs so now given that we have eight cards we can now figure out the board size the board size has to be one of the enums that we've defined over here it has to be either easy medium or hard and what we know is we know the value so we need to figure out how to take the value 24 and map that to hard 18 maps to medium and eight maps to easy and the way we're going to do this is by adding a companion object inside of the enum called fun get by value and just as the name implies based on the value that we pass in here which is an integer we're going to return one of these three enums so we'll say the body of this function is going to be a oneline function we're going to look at all the values of this enum through this method called values and we're going to find the first one among this such that the number of cards in that enum is equal to the value so this is a nice cute oneliner and the reason this is valuable is now we can set the property board size from before based on the number of cards so the number of cards and we can also set the game name to be the game name defined here this actually leads to some naming conflict so i'm going to rename this local variable to be custom game name and now it won't be ambiguous that i'm trying to set the property game name to equal the local variable game name okay and so now there's a complaint here board size value of requires a string but the actual is a int oh it should be get by value okay the next thing we want to do is call this method setup board but setup board has to actually now have information about what is a list of image urls right and we're not actually saving that inside of any property so let's add that as a property now i'm going to add one more private member variable called custom game images and this is going to be a list of string and it'll be nullable because in the default case this list will always be empty right it doesn't make sense to have a list of image urls when we're just playing with the default icons so we're going to set this equal right here when we query firestore and get back a list of images so this is going to be equal to user image list dot images so now let's go into setup board and actually start using the custom game images variable that we have along with the game name the objective here is we want to prefer using the custom image list if it's there over the icons because that means that the user is explicitly intending to play this custom game so the change we're gonna make is we're gonna pass in the custom game images as a constructor parameter on the memory game so let's add this as a parameter hit refactor and we're going to call this custom images and here the memory cards that our memory game is going to contain will depend on whether custom images is set or not so if it's not set so if custom images is equal to null that means we'll just do what we've already been doing which is to look at the default icon list grab some icons out of those and create memory cards out of them however if custom images is not null then the memory cards should instead be using the image urls as the underlying picture of that memory card so we're going to say val randomized images is equal to custom images and we're going to get two copies of each image in that list then randomize it and now the list of memory cards is going to equal randomizedimages.map and we're going to create a new memory card for each of these so one thing you'll notice here is there's an issue which is that this randomized images here is a list of string that makes sense because each element is an image url which is a string but memory card if you remember the first parameter is a identifier which represents the image resource the drawable resource and we don't have that in the case of a custom game so what we're going to do is add one more constructor parameter called image url and this is going to be of type string and this will be optional because in the case of the default game this is it doesn't make sense to have anything here having the default value of null here we can create memory cards identically to how they were created before but now if we wanted to we can also specify an image url and that's exactly what we're going to do over here and pass in it for the second parameter now the first parameter we need to pass in some identifier which is an integer and so in order to do that we now need to figure out how can we take an image url and turn it into a unique integer and the easy way of doing this is by using a method called hashcode this is something that's defined on every single object including strings and the idea is that for two different strings the probability of them having the same hashcode is very very small it's almost impossible and so by having it.hashcode we're just basically taking the string whatever it might be and translating that into an integer and that will be our new memory card it's almost done in the memory board adapter now this is where we are actually rendering that drawable from the default list of icons that happens right here we're saying image button dot set image resource so if the card is face up we are setting the image resource to be that drawable resource otherwise the background however in this case we don't want to do this right in the case of a custom game image if there is a image url on the memory card we would instead of setting an image resource we want to actually download that image from that url so in order to download an image and show it into an image view there are a couple libraries on android which makes this super easy and the one that we're going to use is called picasa so if you use google for android picasa github you'll come to this page and what you should do is scroll down to the download section and copy this line implementation now add this line into the build.gradle which is located in the app module tap on sync now and going back into memory board adapter now we can use picaso to render the image at that image url inside of this image button so the logic will be if the memory card is face up then we should check is the image url of this memory card not equal to null if it's not null that means that there is a valid custom image at this memory card that we should be rendering instead of a resource identifier so we'll call picasso so we're going to import that dot get and we're going to load in the image url into the image button that's how simple it is to use picasso otherwise we're going to do what we had before which is image button dot set image resource on the memory card identifier and this is going to be one of the icons that we had created if the memory card is face down then we're going to go into this else branch and then we're going to do we're going to set the launcher background so just just that all right so we just wrote a lot of code hopefully it all makes sense let's try it out try it out i'm going to run the app and we're going to create a new game and save it and then when we save it we're going to come back into the main activity and hopefully we'll be able to play this new custom game that we created so i'm going to create a custom game make it easy so we don't have too many images to upload and let's do this the four images here and say play game as the name tap on save all right so we can see the progress bar upload complete so now we should be going back into main activity and main activity should at that point fetch all these image urls from firestore and display them in the memory game let's see if it works so now it all looks identical to what was there before because right now everything is face down but when we flip over a card you can see hey it actually downloads this image that we had which is amazing i got lucky with a match on the first one okay so this is working so we're able to download the images from this custom game and we can play the game like normal so the logic of figuring out which two images are the same works because the hash code of these images if they're the same image should be the same so that logic is all identical to what we had from before awesome so we won and we have the same logic there from before all right so to finish off there are two really quick things i want to do back in main activity so first off in the setup board method one thing that would be nice is as soon as we call setup board if there is a custom game which the user is playing we should change the title of this to be the name of the game rather than the default my memory so in this case we should hopefully have seen play underscore game as a title instead of my memory and we can do that pretty easily just by saying support action bar dot title and set this equal to game name and the game name might be null so in the case that it is null then we want to set it equal to the name of the app it's r dot string.app name that's one thing i wanted to do second thing i wanted to do is a bug fix so right now one thing you'll notice is that if we create a new default game of a different size we're going to trigger this method show new size dialogue and so if the user is playing a particular game and they create a medium sized game then we're going to call setup board but the issue is that setup board might still be using the cached data the save data inside of game name and custom game images and so basically the the key thing here is we need to reset these values every time the user goes back to a default game so in the show new size dialog right before we set up the board let's just null out the game name and also the custom game images should also be null awesome huge progress in this video what i want to do next is allow the user to enter in the game name that they want to play using a menu option but right now the only way to play a custom game is by creating it and then we immediately will play it back in the main activity so what i want to do here is add one more menu option for downloading an arbitrary custom game so to do that we're going to add a menu option so open up menu main and we're going to add in one more final menu item let's give this a title of download custom game and the id can be mi download it's a menu item download and similar to the other two above it we're gonna have show as actually never so we always want this to be in the overflow menu let's copy the id go back into main activity and register a listener for when that menu item gets tapped so r dot id dot mi download and in this case we would like to call this method show download dialog download dialog and then return true okay let's define this method so i'm going to put this below the functions that were overriding and then i misspelled downloads let me fix that so this download dialog is going to be simple all it is is the ability for the user to enter in through an edit text the name of the game that they want to download so i'm going to use the layout inflator to inflate that view which has the edit text so i'll take layout inflator from this inflate r.layout.dialog download board null is a second parameter this is going to be a view that we're going to call board download view and the idea is going to be we're going to call that same method that we have show alert dialog the title will be fetch memory game and the view is going to be the board download view that we are about to define and the third parameter is what should happen when the user taps on ok so it'll be view dot on click listener and what we want to do here is grab the value text of the game name so let's first define the dialog download board layout the root element here can be a constraint layout that's fine the only view that we need in our constraint layout will be in edit text and before modifying individual attributes of the edit text directly here one thing to notice is that we're going to be using many of the same exact attributes as the edit text that we showed in the creation flow and so i'm going to open up activity create and we have edit text here i'm going to go ahead and copy all of that go into the code tab of the dialog download board and copy over that same edit text we'll have to add in the app namespace declaration many of the attributes for example the allowable input digits number of max lines input type important for autofill all of that should be identical in this edit text in the edit text in the creation flow but there are a few modifications we'll want to make let's change the margin bottom to be margin top and make it 16 dp let's update the hint to say enter game name so the user knows what to do with this edit text and the constraint bottom doesn't make sense anymore because there is no btn save so i'm just going to say constraint top to top of parent which makes it flush with the alert dialog top finally let's update the id to be et download game now we can grab the edit text from that board download view find view by id with the specified id and now the game to download will be the text attribute of this edit text that will say etdownloadgame.txt.2string.trim and now we can call our method download game with this game to download string okay let's try it run the app and now we should hopefully see one more menu option next we do download custom game and i am going to try out the larger game that we had tried from before large test tap on ok so this is good it's promising because i do remember that we had made the large underscore test game a mediumsized game which means there are 18 cards or nine images that we added and yeah you can see that this is indeed the images that we had uploaded so one thing you'll notice is that there's a little bit of a delay the very first time that we download that particular image it takes a couple hundred milliseconds or maybe even one second and then every subsequent time that we download that same image for example the golden gate bridge subsequent times that we display the image is much faster because picasso is caching that image once we've downloaded it once subsequent times are much much faster to load so that's one optimization i'd like to do which is in the download game method as soon as we're successfully found the game one thing we should do is prefetch all the images with with picasso and this makes this is actually it's pretty straightforward i'm just going to say for image url in user image list dot images and i'm going to say picasso dot get and i'm going to just load the image url dot fetch and what this dot fetch is doing is saying hey let's go ahead and even though we're not displaying this into an imageview right away go ahead and download it and fetch it so it's saved in the picasso cache and one other thing i'd like to do here as well actually just show a snack bar to indicate to the user that they're playing this custom game let's try it so we have a couple games we've uploaded so far large test play game test tune test three let's try maybe test three and one other thing to look for is that the title of the screen in the action bar should also update appropriately let me say this test three okay so we are playing test three we got the snack bar and now you can see that the image images are loading much faster which is a great sign now we can play the game like a normal game of memory one bug you'll notice at the top is the activity action bar title hasn't been updated appropriately so let's debug that if we go into the setup board method that's where we set the title and so it relies on game name and the bug here is that the game name should be set before calling the setup board method so by doing that now that bug should be fixed let's try it one more time so let's try downloading a game called game two oh there is no game two what did we call it test two awesome and so you can see how now the title of this activity has changed to be test two and got that snack bar and we should hopefully be playing this new custom game and now it feels so much snappier so that's great one last optimization i want to make on the picasso side which is that there's still no way to avoid the fact that we might have to spend a little bit of time downloading the image the very first time and so when that happens in the memory board adapter there's a nice functionality in picasso to load a placeholder image while the image url is being fetched and so i would like to add that as well i'll say r.drawable.ic image and so we're going to define one more vector asset which will be kind of the placeholder image a silhouette of an image like a black and white image so let's go into project go into the resources and let's create a new vector asset in the drawable directory called image so we'll call this ic image and yeah let's leave it as color gray and then finish okay so this error went away and let's see if we can actually see the placeholder image so if we're really quick after we download a game then we might be able to see it briefly i'll say large test yeah and then you might have briefly seen the very first image i flipped over we were able to see that placeholder image and all the subsequent images are much faster to load because we're doing that prefetch operation so that's a really good sign it's a much better experience now before moving on to the next segment which is focused on design and style improvement there's one more small improvement i want to make here which is that if we have this snack bar show up right now there's no way to actually dismiss it and it's not that hard to make the snack bar dismissible and give the user more control over the ui simply by going into the activity main and right now the root element is a constraint layout if we instead change that to be a coordinator layout then any snack bar can then be dismissed by the user so let me do that coordinator layout and then we're going to add a bunch of these properties in the coordinator layout so copy this put it at the end and then i'm going to hit command option l in order to fix the indentation and we also need the layout width and height on the constraint layout of course and this id of cl root we're actually going to apply that onto the coordinator layout so everything else is identical because the only time we were referencing cl group is as the anchor for the snack bar and by making the anchor for the snack bar coordinator layout now the user should be able to dismiss the snack bar with more control let's try it okay it looks like we are crashing and i think i know why yeah the reason is because there's a class cast exception if you go back into main activity you'll remember at the top of the file right now we're defining cl root as a constraint layout but this should actually be a coordinator layout and here clru is finding you by id and that's fine so now let's try it hopefully we won't crash so we are able to boot up properly and if i trigger the snack bar now you can see how i was able to dismiss it in the next part i want to do some low hanging design improvements with all of you and then we'll be done with all of the functionality and design for the whole app in this segment i want to make a couple of very easy but powerful improvements in the app the first one is not so much an improvement but avoiding an issue in the app which is if you rotate the screen so you can see that whenever you don't hit the screen in android the activity is destroyed and recreated and we are not doing a great job with managing the space here our app isn't very smart around when the phone is wider than it is taller the number of columns in the memory grid should be larger but right now we're still assuming this portrait mode where we will always have more rows than we will have columns and so we have two options one is we could actually properly address this and that would require some logic inside of the memory board adapter and figuring out how much space to allocate in the width and height the other option is to do the lazy thing which is not allow the user to change the mode of these activities to be in landscape and that's what we're going to end up doing so if we open up android manifest we have two activities in our app creativity and main activity and we're going to update the screen orientation attribute to be portrait and that's it that's the only valid option and by adding this line into the android manifest file even if the screen is rotated even if the user rotates their phone then android won't actually go through the activity lifecycle we're not going to be destroying the activity and so we're still looking at the same portrait mode ui even in landscape the twoline solution that we came up with here to lock the orientation in portrait is definitely the lazy solution but i would argue that this is actually a reasonable tradeoff to make our job as engineers is about efficiency and so you have to make the decision about how much value are you delivering to users by implementing proper landscape mode in the app versus how much engineering time or developer time would that take and can you use your time better elsewhere you can definitely implement this if you want to learn more but the key takeaway here is thinking about what problem are you trying to solve the second improvement i want to make is i want to add a little bit more festivity when the user wins the game so right now let me quickly see if i can win the game so we just have this snack bar show up u1 congratulations i'd also like to have something a bit more festive and in particular i want to have some confetti pop up and this turns out to be really easy because we can use a library which does this for us so if you go to your browser and just google for android confetti library you'll come up with this github repository and this is the one that we're going to end up using so i'll show you how to use it but right now all you need to do is copy over this line to add this into your build.gradle file which is located in the app module tap on sync now so we can pull this library into our project and now let's go into main activity and let's figure out where do we actually detect that we won the game so as soon as we flip over a card that's the only time when we have the potential to win the game and we have this snack bar that we show up right now so right here is where i'd like to now show this confetti and it turns out that we can do this with literally one line of code i'm going to invoke a static method in the library i'll say common confetti import this and we're going to call this method raining confetti the first parameter here is the container that'll be the parent element on which the confetti should be falling so call cl root and then the next parameter is the colors that you want the confetti to be so i'll say int array of and we're just going to pass in some colors that are already defined for us by the android system and you can kind of pick whatever you like here's the ones i picked yellow green and magenta in order to actually launch the confetti we call this method one shot and that's it let's try it and see how it looks amazing so you can see how this confetti is falling and there's some like particle physics inside of the library some map so that we have some particles some confetti falling quickly some falling slowly and they also will drift side to side so it's a really nice simple way to make the app more fun the next thing i'd like to do is update the color scheme of the app and there's definitely no right answer here you can be creative and pick whatever color you like but what i recommend most people do is go to color.adobe.com and this is a really nice way to pick out a color palette you can kind of take this drag it around and figure out what color scheme you like and if you don't like uh this one which by default is analogous you can pick out one more like monochromatic triad complementary or whatever you want and this gives you a nice working set of colors which we can then use to update our android app we have a couple different colors like the status bar color this action bar color and this background color of the linear layout so those are the colors that i want to update so let's open up the colors.xml file i'm going to add three more colors here first we'll define green dark then we'll have one more called green darkest and then a third one called green blue and you can pick whatever colors you want for this like we talked about here's what i picked for green dark green darkest is a darker shade of green dark and then finally green blue is a teal and you can see a preview on the left hand side now we have to make use of these newly defined colors and we'll do that in themes.xml we'll define color primary to be green dark we'll define color primary variant to be green darkest and notice on line 13 the status bar color is the color primary variant and finally in the secondary brand color category we'll update both the color secondary and color secondary variant to be green blue one more thing i'd like to call out dark mode is all the rage these days and so android studio actually has a separate file themes.xml located inside of values night and so if the app or phone supports dark mode then the colors inside of the valuesnight themes file will be read instead of the one that we defined just something to keep in mind if you're into that sort of thing let's try our app with these new colors and if we've done our job correctly we should no longer see this purple color at the top we should instead be seeing the palette of green we picked out so we have a green action bar a darker green for the status bar and the bottom the blue green the final design improvement i'd like to make is to change the view of the memory card when it's face down this green grid because it just feels like our app is still under construction and instead use some custom image for the default state so you're welcome to pick whatever image you want for this i'm going to open up the drawable directory and the image that i found i downloaded from the internet is this picture of bamboo so everyone loves pandas therefore everyone should love bamboo i'm going to drag this bamboo.png file into the drawable directory now let's reference this bamboo.png file inside of the memoryboard adapter which is where we are setting the icon when a memory card is facedown so right here on line 65 is where we're setting the image resource if the card is face down and we're going to set this equal to bamboo so let's run the app and see what this looks like perfect so you can see how now we have the bamboo background and we can play the game like normal all right okay so let's try just for good measure let's play the whole game and go through the creation flow as well so i'm going to create a brand new game i'm going to call i'm going to have this be easy i'm going to call this corgi and of course i can't save the game right now because i haven't added the images but let's add our wonderful images of the corgi so i have four images of a corgi here and then let's tap on save perfect it looks like it succeeded tap on okay and now immediately we go back into the main activity and we can see that the title has changed to be corgi and hopefully we should be able to play our game now yay and you can see that okay we have this confetti following we have a snack bar we are recording the number of moves properly and we have this green text showing that we are 100 done and we found all the pairs we can replay the game and this works because we're still holding on to the image url list of all these corgi images and we can play like normal i can also choose a different size so i can pick like a medium sized board and here notice that we are reverting the title back to my memory because this is now playing a default game with default icons and we're also updating the text at the bottom and so now we're playing with the default icons rather than the image urls coming from a user this looks really quite good if you've also gotten this far in the game i would love to hear from you drop a comment and let me know i'll leave you with some extension ideas the really nice thing about the memory game is that there are so many creative and fun ways to extend the functionality of what we've built together so one idea i had was simply to add different board sizes so right now we have three enums representing the different dimensions of the board easy medium and hard we could simply add a couple more enums for different configurations another idea i had was to introduce user authentication and if you allow the user to log in then you have this really nice ability to be able to see all of the custom games all the custom boards that that logged in user has made so you have this notion of history or profile for that user and finally there could be a lot of interesting work around discovery of other people's boards so we could imagine there are hundreds of different custom boards created and i want to see which ones are popular and i could also enjoy playing other people's games so if you do end up doing any of these i'd love to see it drop a link to the published app or the github repository and we can celebrate your app in the next segment we're going to prepare our app for release so i'll walk through a checklist with you about what i typically do before i publish any app on the google play store if you've gotten this far i really hope you're planning on publishing what you've built the app that we have is really full featured and really fun to play with and there's a social aspect as well so in this segment i want to walk through a checklist of some of the things i always think about before publishing any app onto the play store first is the app icon so if we tap on the home button and then swipe up to open up the app launcher screen you can see the app we have here is the default one so of course before publishing we'll want to have a unique app icon for our app my memory you can design the app icon yourself or use a design agency or something like fiverr in order to get a high quality app icon here's what i came up with it's a grid of nine squares of different colors to indicate that there's some sort of pairing or matching going on the main thing to keep in mind with app icon is that you want it to be square and you want to avoid text or anything which is too detailed in the image because users won't have that much time or the ability to see your app icon in hires so you want to be very obvious at a glance what your app is so once you have something you're happy with then go into the drawable directory go to new and tap on image asset and this asset studio will help us to create all the different icons that we need depending on the kind of phone that you have so i'm going to tap on path and we're going to choose that icon that we had just created so now you can see a preview of how this icon might look so depending on the kind of phone if you have a samsung phone or a google pixel or something else the icon might look a little different and this is all the different ways that it might be rendered so i'm pretty happy with that so we're going to leave it the layer name as i see launcher foreground tap on next and this is basically just saying that we're going to overwrite the default ic launcher let's tap on finish great and so now if we run the app let's see if we actually have the app icon properly reflected so i'm going to exit the app and go here and you can see it does indeed show our new app icon awesome so that's one thing you want to do the other is enabling minification and proguard if you open up the build.gradle file i can show you what i'm talking about you should have a section in your app level build.gradle file for release and build types and what this is saying is what are the steps of the build process that you want to run on the release build when you actually publish your app you're going to be publishing a release build what we've been doing so far is a debug build by default android studio is going to have this minify enabled option as false in release builds it's important that you turn this on to true and the reason you want to do this is because it will shrink the size of your app so an app which might be 20 megabytes with minifi enabled it'll be much smaller than 20 megabytes in my experience the size savings can be more than 50 percent and the reason app size is important is because users often don't have that much space on their phone and also people may not have good connectivity and so a large app may deter them from downloading it from google play and just to demystify this a little bit when you enable minification what's happening is there's something called proguard and proguard will basically look at all the libraries that your project is including and strip out methods that are not being used or not being referenced and through that it's a it's a really nice way to get rid of code and resources which are not are not referenced and reduce the size of your application or of the apk which is generated at the end of the day and that's downloaded onto the device you do want to be a little bit careful with proguard because it's stripping out methods sometimes it's a little bit over eager and it may strip out something which you actually do need in your project and so you want to make sure that you test out your release build properly and make sure there are no issues that come up in the release build that don't happen on the debug build for example one thing i discovered after turning on minification is that i previously didn't have in the user image list i didn't have this property name images in the data class and this actually worked fine in the debug build but when making a release build this caused a crash and so i needed to explicitly add property name images in order for firestore to be able to construct the user image list correctly tip number three is if you want to understand better what your users are doing in the app once you publish it i'd recommend that you integrate firebase analytics and so there's a guide here you can google for but this is a way for you to understand how many users are opening up the app how many users are taking a particular action in the app and you can define what that action might be so that's an option that we're not going to walk through here but if you really want more detailed analytics about how people are behaving then this is a good way to do that one other thing that you want to do for sure is test your app on different phones and different api versions so right now we've only tested our app on this pixel 2 phone which is running api 29 but you want to make sure that you test your phone on a tablet if you want to target tablets you want to test it on the most recent api version api 30 for example you want to also go back five or six years and test your app out on a phone which is running api maybe 24 25 and make sure that everything works look in our build.gradle and you can see the minimum sdk version is 21. so you probably want to test a phone running api 21 as well we've only been testing our app right now on emulator it probably is also worth testing on a physical phone if you have one just because that will give you a genuine experience of how real users will interact with your app emulators are great for testing out your phone on very old devices or devices that are physically hard to get a hold of but it's definitely worthwhile to try out the app at least once on a physical phone and the final tip i have is to translate your strings right now we have a bunch of text that we show to the users those are called strings and these strings are all written in english for example here snackbar.move we say invalid move and this is bad practice because if the user is changing the locale of their phone to let's say spanish or hindi or some other language then we would want to be able to translate this text into that language and the way you do this typically is by having all the user facing strings belong in this strings xml file so right now we literally only have one string which is the app name but if you wanted to internationalize your app and have it be popular in countries that are not english speaking then what you'll want to do is move all of these strings out into the xml file and then reference the strings.xml file instead of having hardcoded text and once you have all the strings in an xml file like this you can create an additional version of the strings xml for each language so you'll have one strings xml for english one for spanish one for french one for hindi and so on so there are probably a bunch of other things that you could do to optimize your release and make sure it's successful this is a very quick list of what i typically think about when i publish if you have other ideas or other things on your checklist i'd love to hear what you do let me know in the comments how you think about it at this point not only are we done with the debug version of the app but also the release version which is the optimized version of our app for publishing in the next segment we'll upload our release app to google play and create a listing for our app on the play store the goal for this part is to publish our app on google play which is the dominant android app ecosystem run by google once we do this we can easily share our app with friends and family which will be really fun and you can point to your app in your resume or your app portfolio which will help you in landing a job google makes it relatively quick and easy to become a developer on their platform compared to the apple app store which is the app store for iphones and ipads and there are two big differences between google and app apple here one is that it's way cheaper to become a developer for google it's a onetime fee of 25 to become a google developer compare that to apple which is 99 every year so that actually adds up really quickly on the apple side whereas google is much much cheaper and the second reason that it's easier to become a developer with google is because the review process for publishing an android app is much lighter compared to apple the google's process for reviewing our app is largely automated which means that the turnaround time is a lot faster whereas apple will have a reallife human manually check your app and you might be rejected if your app is deemed low quality or if it's doing something that apple doesn't like and so there's been a lot of articles talking about the pros and cons of each approach i would say that the average app quality on apple is going to be higher because they actually do reject quite a few apps and they have a higher quality standard but the diversity of apps on google play is way higher with more than two million published android apps and that's because google accepts most of the apps that are submitted to the play store and the other impact of the automated review system of google is that the iteration speed is a lot faster so with apple you might have to wait more than a week in order to get a review and get your update published but with google as you make improvements those updates will go out faster to the end user so we're going to spend a lot of time in the google play console in order to create a new app and update it with all the information but before we do that there are two pieces of prep work that i want to do one in the emulator and one in android studio so first in the emulator this is where i want to spend a few minutes just taking some screenshots of the app so the way you can do that is ctrl s on a pc or command s on a mac so we can just take one of the home screen why don't we take a screenshot with some of the cards flipped over let me try and get a match well that looks good let's do one more screenshot here maybe we can do a different size for a couple and then maybe we can also include a couple of the creation flow and then finally maybe we can show folks that they can download a custom game okay awesome so those have now been saved by default they're going to be safe at the desktop we're going to use those later when we create our google play listing so the next thing we'll do is open up android studio and we're going to create a release bundle from android studio and that'll be what we upload to google play if you go into the menu go to build and tap on generate signed bundler apk you have two options here an under app bundle or an apk so the android app bundle is recommended because it's a newer file format that google was pushing and you can kind of think of it like a zip file which contains other files inside of it and in particular it contains the compiled code for your project plus the resources and it lets google play create an optimized apk that users will get on their device and so depending on the kind of device and the screen size and other things google play will optimize what code and resources needs to be downloaded by that user and that results in a smaller download size so i want to pick android app bundle tap on next and here we need to create a key store and this is a key store is basically a way that google can validate the authenticity of the developer and so i'm going to choose the location as the desktop then i'll give this a name of keystore dot chaos and then provide a password and make sure you keep the summary secure because if you lose this you're going to have to create a brand new app on google play rather than updating your existing app same thing with the key you need a alias we'll leave as the default key 0 use some password here and then for the certificate i'm just going to put my first and last name and that's all we need for now of course my passwords don't match let me try this one more time okay seems like that worked tap on remember password just so that as we make changes in the future we don't have to keep typing all this information again tap on next and then we want a release version of the app and so our app is fairly small so this building of the release app shouldn't take too long but if you have a larger app this can certainly take several minutes all right so it looks like we are able to generate the signed bundle so i'm going to locate it shows up over here and so you can see here the aab file is 2.5 megabyte and that's pretty good it's a pretty small app and keep in mind that this is an upper bound of the size because the aab is essentially a zip file and google play will optimize what apk generates for the user's device so 2.5 megabytes is an upper bound on the size of our apk so what i have over here are all the screenshots that we took so i'm going to drag over the aab file into this directory and this is now everything we need in order to create a good google play listing so let's go back now to google chrome and go to the google play console i'm going to create a new app we'll update this with a bit more detail later on but just for now i'm going to call it my memory the default language is english us it's going to be a game this is a free app and then we're going to agree to a couple of policies and then tap on create app all right so google play here will walk you through a bunch of different questions and policy things that you need to answer and then after we do that then we're going to upload our aab the first is app access in our case everything is available without special access there's no such thing as logging into our app let's go back to the dashboard let's go to ads we have no ads content rating we need to fill out a questionnaire i'll put in my email address our app is a game tap on next all right the only thing that we have to answer yesterday is actually this question because the app does natively allow users to exchange content through sharing images that's if you create a new memory board and someone downloads that that's one way for users to interact with each other so we tap answer yes on that question but we can answer no on all of these all right and then if you look through you can see the rating that we got in our app it looks like as expected our app is pretty friendly for everyone submit let's go back now and see what else have we not done all right so the next is the privacy policy so every app has to have a privacy policy and typically what i recommend for this is if you don't want to go through the hassle of setting up website just create a google doc which describes the privacy policy and paste that in i put that together over here and i can actually link this if you want to copy a similar privacy policy i basically took this as a template from some other app it just describes the app and how we're using some google services so i'm going to copy this make sure it's accessible to anyone with the link paste that in click tap save and then target audience we are going to target anyone 13 and up if you target people less than 13 there are some other compliance rules that i want to deal with around targeting kids tap on next and then our store listing will not intentionally unintentionally appeal to children so tap on no there and then we're done with this section tap save all right and then it seems like we have one more section here is our app a news app and there's no all right so we have completed all the questions about the app content that's great so now let's actually go into the store listing i'm going to the main store listing and there's a couple things that are required anything with asterisks is required regarding metadata about our app like things that are describing our app so i have a note over here where i spent some time putting together a name description and full description so i'm putting in a name of my memory image matching game and the app name is actually really really important because that's how google play will figure out when to surface your app for search queries on google play and i have a friend alex who wrote a really good article about how to think about naming your app and it really comes down to two things number one know what people are searching for in order to try and find your app and number two put those words that people are searching for in the title of your app and so i'm basically guessing that if people want to download our app they're going to be searching for things like memory or image matching or game and that's what i've put in the title one thing you can do is if you're publishing the same app i'd love for all of us to be able to find each other and try out the different versions of the app that people have built so just put your name here so that way anyone else who's looking for this particular app they can find it by they can find out who made it by looking at the last section of the title and this this topic of seo or search engine optimization is a huge topic you can read a lot about how do you game that and how do you make sure that your app gets the best chance of being surfaced i'll leave a link to alex's article if you want to learn more about that so short description is um something which is 80 characters or less so what i did for that is this a free customizable memory game on android match pairs images and then the full description can be a little bit more uh robust and long so i'm not going to read it all right now but basically what i'm describing is that this is a totally free open source app it's customizable memory game um there are no ads and i'm documenting some of the main features here all right so the next thing is graphics there are two required graphics one which is the app icon and one which is a feature graphic so the app icon has to be 512 by 512. um these pixels are exact so it can't be even one pixel off and then the feature graphic has to be 1024x500 and so what i recommend you do for this is open up a program like sketch let me show you what i've done here are all of the assets that we use for the memory game here's the app icon which is 512x512 and for example if you wanted to create the feature graphic you can insert a rectangle in sketch and then update the dimensions as appropriate so we'll want it to be 1024 wide and 500 tall and then you can kind of play with this however you want change the color add in some shapes add in some images and then once you're happy with what you have then you can export both the icon and the feature graphic let's come back into the google play console and we will drag and drop our feature graphic and app icon so for the feature graphic let me show you what i put together so just a picture of the corgi just because that's kind of the main custom game that we've created uh with this same color scheme of the app drag that over and then while that's uploading i'm going to also upload the app icon and so what i did for that is what you already saw just this grid of squares and so now both the app icon and feature graphic are updated and finally we get to the phone screenshots so i'm going to go back to this directory where we have all the screenshots and drag those out okay that looks good and you can have up to eight screenshots minimum of two and there are some really fancy things that you can do to make these look a little bit better like having some sort of colored background or combining two of the screenshots into a continuous shot but we're going to leave it simple for now we are going to ignore the tablet screenshot so let's basically reuse the phone screenshots same thing with the 10 inch and we don't have a video for now tap on save so now we have the basics for our main store listing we're going to go into the release section go into production here's where we're going to create a new release and just one thing i'll mention we're not going to deal with it currently but there is an option here for testing your app before you do a broad production rollout so you have open testing as an option or closed testing and also internal testing these are basically various options to allow you to test out your app with a trusted set of users in your company or with friends and family or just have an open beta program prior to releasing it publicly we're not going to deal with any of that just to keep it simple so i'm just going to go into production track and create a new release and we're going to use app signed by google tap on continue and then we're going to drag and drop our aab or android app bundle so i'm going over here drag dragging that the release name can be initial release and then release notes i'm just going to leave as the default tap on save all right that looks good one thing that we'll need to do is specify which countries we want to release our app to so tap on this add countries and regions and i'm going to go ahead and select all of them so we're going to add all 151 countries then we're going to go back to releases tap on edit and then go to reviewed release it looks like we have some errors all right so it says that our app can't be published yet complete the steps listed in the dashboard so let's see what did we miss in the dashboard so we have to specify an app category let's do that we are a game and in particular we are a puzzle game let's just quickly add a tag called memory apply that now we'll leave our email address and opt into external marketing and hit save so now let's go back into the production release section go into releases tap on edit and let's see if we are able to properly release this now okay amazing so we have set up our store listing properly we've done all the questionnaires all the policy agreements and we can see the internet bundle and then we'll hit this button for start rollout to production so the review process might take a little bit longer now because of chronovirus and and the lack of staff but my experience historically has been that still with a simple app like this we should be able to get a review and have it approved within two or three days hey everyone welcome back the my memory app that we submitted to google play just got approved into the store so what i want to do in this segment is walk through the google play listing along with doing a quick concept review of everything we've talked about to get to this point and then we will celebrate so here's the store listing it's pretty much what you'd expect the app icon and the title are what we submitted into the google play console it shows the developer name here along with on the right side more apps by that developer so i have two other apps live in the play store which you can see here we have the category of the app screenshots description and then when we get reviews those will show up over here this section what's new is about release notes for subsequent versions of the app you can leave a message to users about what has changed and the magical thing about software is that it's so easy to change to iterate and to improve so i actually already made one improvement in the app which is i added a couple more colors into the dark theme so that the app will render better if your phone is using dark mode so i would encourage you not to view publishing your app into the play store as an ending point but instead a starting point where now you can make a bunch more improvements in terms of features or designs at the bottom we have additional information for example when was the app updated how large is the app 2.3 megabytes how many installs does it have and also requires android 5.0 and up and this is coming from the minimum api version of 21 in our app and it tells users how recent does their android phone have to be in order to download this app so the really cool thing about having this app published is now we can take the url and share that with anyone in the world and they can very easily download this application my memory on their phone and tablet and play one of the core features that we built into the app is the ability to create your own custom memory game using photos from your phone so you're already familiar with the corgi game that we used during the video walkthrough for the creation flow i also have one called bitmoji which is my bitmoji character doing different things and then one more you can try out is the board game i created called rao which is pictures of me is doing various activities so if you also have a funny or creative custom memory game with your own photos drop a comment and i would love to play it out one more note on the topic of publishing from the time that i submitted the app until it got approved by google it was about three days i'm not really sure what the standard is given cova 19 if you had a much shorter review time or much longer i'd love to also hear from you the last thing i want to do in this segment is a review of everything we've covered so there's a ton of really fundamental concepts that we've learned that you can now apply to whatever else you want to build we created a brand new android studio project so we started from scratch and then the main ui of our application is built on top of the recycler view and the interesting thing is that the contents of that recycler view will be dynamically measured based on the screen width and height we also started thinking about how do we use models to represent the different objects in the memory game the memory card and memory game and this is going toward the direction of app architecture so we didn't explicitly talk about different kinds of app architectures but basically app architecture means how do you organize your code and so by using the recyclerview and using the memory card memory game we have already better idea of how to partition up the logic so it's easier to debug and extend our application and we also integrated with two firebase services storage and firestore for the creation flow and finally we were able to publish our app into google play and we talked about some of the best practices there so here is the same picture cloud representation that i showed you in the very beginning of all the different things we learned we made a brand new android studio project so you're definitely familiar with android studio now we talked about how to create vector icons and use that as a default memory card we talked about views on android and how they have content padding and then margins live outside the view and we take that into account when creating the view width and height the recycler view is the core component which is responsible for displaying that grid of memory cards we talked about how there's a layout manager which puts things in the grid the adapter which is responsible for binding a view in the recycler view to the underlying data set which is a list of memory cards we also are uploading images to cloud storage and we're using cloud firestore as the database which is associating the game name to a list of image urls and then finally like we just talked about we are now live in the google play store so the result of all that work is this where we are able to create a custom game with these very cute corgis we won the game and we have confetti falling and we have that message at the bottom and furthermore anyone in the world can now download our app from the play store and play play this game as well throughout the whole process if you have any questions or feedback i would love to hear from you i'm on twitter youtube and linkedin and instagram at rponde1234 so i'd love to connect with you and as you share the progress of what you're building or if you have a really funny or cute custom memory game um please use this hashtag mymemory in social media that way we can all see the progress we are all making and giving encouragement or feedback to people all right that's all i had for this project i hope you had as much fun building out this project as i had teaching it if you want to help me out hit that like button and subscribe so you can become part of this learning community until next time i hope you're all staying safe and i will see you in the next one bye