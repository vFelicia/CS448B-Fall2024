learn the 50 most popular linux commands from colt steel all these commands work on linux mac os and any other place you have a unix environment colt is an extremely popular instructor and for good reason he has a knack for teaching complex topics in a way that beginners can understand hey everyone my name is colt steele and today we are going to learn a ton about the command line and different linux commands i'm a developer well honestly more of a teacher who happens to write code i teach inperson web development i've run boot camps in san francisco i now do a lot of online teaching and i have a boot camp i created with springboard if you want to learn more you can find a link in the description and this is a picture of one of my cats i actually have to take her to the vet like in five minutes really her tail is just drooping down for no reason i was gonna take her sooner but you know i had to make this for you let's hope she survives before i say anything else i want to give a big thanks to flavio copez i think i actually only know him as flavio maybe it's pronounced copes but i'm pretty sure it's not anyway uh he generously allowed me to use his linux commands handbook there's a link in the description of course very detailed and thorough handbook if you're not familiar with his work he puts out handbooks and tutorials on all sorts of topics so this is just one of many different handbooks anyway he is allowing me to use his handbook along with some of the materials i've created to create this mutant super course on youtube so we are going to cover 50 actually i think it's a little more than 50 commands that are useful obviously to varying degrees some of them you'll use every single day as a developer for example and then some of them you may never use except in an emergency situation once a year but i'm going to cover a bunch of them they're not really in a particular order especially towards the end of the course but at the beginning i ended up deciding that instead of just 50 random commands in any order i wanted to make something for uh anybody so if you're a beginner you can start at the beginning and we'll go through the basics navigation working with the basic commands and options and making folders and files and so on but then after about this point things really open up and you can jump around to whatever commands you'd like and of course if you're someone who already has some terminal experience some of these commands are familiar to you just hop around take a look at the description there are time stamps and just click on whatever command you're not really comfortable with or you've never heard of there's probably something here for you but if you're a beginner i definitely would recommend starting at the beginning so aside from these commands which there's a lot here and this is a pretty long video i also cover some concepts that are pretty important so the very basics things like why even learn this stuff if you're not a linux user you're on a mac you're on windows why do you need to know linux commands do you need to know them the answer is probably yes if you're trying to break into web development programming coding engineering any sort of techie industry then we'll talk about things like unix and gnu and linux and unixlike and true unix what is all that uh what is a shell what is bash zshell kernel terminology stuff so that's all coming up of course there's time stamps if you want to skip around if you don't care about that stuff and then installation so if you're on a mac you don't really have to do anything if you already have linux installed you don't really have to do anything either and if you're on windows well we have to jump through some hoops the good news is fewer hoops than we had to jump through a couple months or years ago so i'm going to show you how to install something called windows subsystem for linux then we'll also talk about concepts like command structure and arguments and options working with man pages folder structure of linux redirecting standard output appending standard outputs tilde expansion history expansion path name expansion curly brace expansion and permissions so we're going to end with permission is a pretty big chunk honestly at the end of this course it's devoted to just these two commands and understanding how to read and manipulate permissions on linux so there's a lot here there's some introductory conceptual stuff in terminology installation and then we start from the basics so you could know nothing about the terminal never have entered a command in your life start at the beginning and don't skip around or if you feel confident or you know some of this stuff jump around use the time stamps they are there for you all right so let's start with a quick discussion around why this matters why should you learn these commands uh yes at times it might seem like you're you know doing stuff straight out of a 1980s hacker movie um and we're far more advanced and things have improved so much why do we still have to use text commands well there's a bunch of reasons including the fact that you can just do a lot more from the terminal using these commands we're going to learn you'll have more control greater access you can do things you just cannot do otherwise there's just no way around that if you want to start a server manage different processes interact with databases all sorts of things alter permissions you need to know terminal commands to do that another reason it's faster at least once you get past the basic hurdles you learn the commands you get used to them you can do things way faster we can make 10 000 files in a single line i can make 10 000 empty files all with different names doing that graphically with my mouse or file new save file new save would take hours now that's just a sort of farfetched example but in general we can do things much faster the one problem is that when you're learning it's going to be much slower i kind of already hinted at this one but we can actually automate things we can speed up repetitive processes we can save ourselves a lot of time another reason it's available everywhere so if you learn these commands you'll be able to work on any linux distribution you'll be able to then switch over to a mac if needed and use the commands on a mac now on windows yes it's a little bit different so it's not technically available everywhere but these commands we're going to learn are pretty standard across any sort of developer software engineer career which leads me to the next point it's essentially a requirement if you want to be a web developer data scientist devops engineer sys admin security admin machine learning engineer ai engineer whatever any type of coding related career you are probably going to need to use the command line you will have tools that only exist on the command line that you'll need to be able to use so for a lot of people that's the only reason that really matters you just need it if you want to get a job it's just part of the expected skill set also a lot of cloud computing programs or services don't even have a graphical user interface you just have to do things via a command line and again highpaying jobs lots of careers lots of roles that you'll need to at least know the basics of working with terminal commands so the next topic i'd like to quickly discuss is a little bit of context around operating systems and why these commands will work on linux and on mac by default but they're not going to work on a windows machine at least not out of the box so uh there's quite a lot of complicated history uh and and uh drama around different operating systems things being open source versus closed source and competition and copying each other it's quite dramatic but the general gist that you need to understand is that over the years since the very early days of computing well maybe not the super earliest days but we're going back to the 70s here this is a timeline that shows a very detailed timeline that shows operating systems and how they're connected anyway in the 1970s there was something called unix you can see it here and just take a look at all of these lines this whole family of operating systems that it spawned so there's lots and lots of them everything in red here is considered in some way related uh or indebted to unix so that includes things like linux so in this course i'll be using ubuntu which you can see here it is a distribution of linux but there's many many others things like android chrome os but also other uh more common linux distributions like fedora or red hats anyway all this linux stuff is descendant from unix all the way back here in the 70s now we also will see somewhere in here all the different mac operating systems here we are so mac os x we've got ios the apple tv os audio os watch os all these different apple products all the apple operating systems also related to unix but then our good friend windows somewhere down here it's not an it's not even in the same red color just to show how it is completely different it is in green this world of windows so windows windows vista windows xp windows mobile windows phone xbox os all that stuff is over here it's just kind of on its own it is not related it's not you know a descendant of that original unix operating system from way back in the 70s now the reason this matters is that all of these guys in red up here they tend to share the same commands unix was this operating system developed in the mid 60s at bell labs really cool time lots of innovation going on uh but what matters to us today 50 plus years later is that lots of those innovations lots of those new ideas and the specific commands the actual interfaces the way a file system was structured all of that carries over today yes it's changed it's been expanded but it is present in all of those red descendants of unix unfortunately for our windows users those commands don't exist natively on windows windows has its own set of commands its own default shell its own way of doing things so i'm going to talk about how we can get these unix commands to work on windows but just so you understand why this is a problem in the first place it just has to do with the history there are so many of these os's over the years inspired by and descended from the original unix os including linux and mac os but not windows lonely windows over here alright so now we have a basic understanding of the fact that of today's operating systems there's really those two groups everything descended from microsoft and then kind of everything else that is in some form some way related to unix now that's a vast simplification but again we're just talking about popular operating systems so you know linux chrome mac os all these things come from unix now let's talk about linux and unix and all that stuff in a little bit more detail so that you understand what exactly linux is why it exists so this is a diagram from wikipedia that shows the history going back to 1969 early unix versions and how it spawned all the you know other operating systems that are connected to it now what you'll see is that there are three colors red is closed source or pink and that means the code is completely closed off you can't edit it you can't view it you're not allowed to even try to tweak it then we have open source which you may be familiar with that term the code is openly viewable you can change it tweak it make your own versions try things out and then there's in yellow this mixed shared source type of operating systems so what you'll see here is that early on unix and a lot of other operating systems in the early days were mixed or shared source but then there was a plethora of closed source operating systems uh that were very walled off and you were not allowed to do anything with that code you were not allowed to view edit tweak and so on and that led to the rise of something called the free software movement free in this context does not mean no money free beer it instead means free in the context of freedom free speech so this software movement was all about uh the the idea that you should be able to collaborate you should be able to edit code view source code run copy distribute study change and improve software should not be walled off and the leader of this movement was this guy named richard stallman so he began work on something that ended up being called gnu gnu that was his own free software alternative to unix so he wanted to make a full operating system that had everything that normally came with unix but it was going to be completely free again free meaning you could tweak it and edit it do whatever you want to it and see the source code now that's a huge undertaking creating an operating system and at the same time this other developer named linus torvalds or linus torvalds was working on something called a kernel and we'll talk about what that is in a moment but this kernel he was working on he called it linux and a kernel is a very complicated and critical part of an operating system it is the thing that basically sits between the hardware and the software and it facilitates the interactions between different pieces of software and then the actual the physical hardware of the computer so what happened is that richard stallman was working on the gnu project trying to build a full operating system well he didn't have a kernel but at the same time linus torvalds was working on a kernel and torvalds ended up merging his kernel with the existing new components from richard stallman to create this whole operating system just a quick note so i don't get any negative comments here there is a bit of controversy over the name of the resulting operating system a lot of people most people have heard of linux fewer people have heard of gnu the term linux often people use it to refer to the entire resulting system when in reality uh the linux kernel was just one piece that was added on to some existing components but what matters for us here if we go way back to this slide over here is that what we see is a bunch of closed source mix source operating systems all over here and then this thing called linux pops up right there around 1991 in green it's open source now there's not a direct line as you can see going back to any of these what are called true unix operating systems and the reason for that uh is yet another piece of history there is a global consortium called the open group they own the trademark for unix in order for you to call your operating system unix if you make an os and you want it to be certified you have to pay a lot of money you have to go through a bunch of testing you have to comply with a bunch of regulations and standards and it's a complicated process and there's money involved it's not very free free software so we have another term there's true unix you've been certified as a true unix operating system and then we have unixlike operating systems which are compatible with the unix standards they implement things correctly but they haven't been certified as actually true unix and this is often because of financial considerations or ethical objections to the existence of the idea of true unix so what we see on this slide here is linux enters the picture it is not considered true unix but rather it's considered unixlike remember that linux itself is just a kernel which is very very important it's again that piece of the operating system that connects the hardware to the software so that's what linux is really it's the kernel but when we talk about things like ubuntu what ubuntu is is a linux distribution it is one of many many distributions out there there's nearly a thousand last time i checked uh you may have heard of fedora slackware ubuntu that's what i'll be using and what each distribution is it's it's the linux kernel it's some gnu tools documentation a package manager a desktop environment a window management system a whole bunch of other things combined together to form a full operating system so to recap all of that there are tons and tons of operating systems on this chart you can see some are open source some are closed source some are mixed source uh some of them are considered true unix they've paid they've been certified by this foundation or this consortium to be true unix but then over here we have linux linux is fully open source and whether you call it linux or linux gnu or gnu linux it is a unixlike operating system that conforms to all these standards these operating systems do we can use the same commands things are structured the same way there are subtle differences but it doesn't really matter everything on this chart here they're all part of this greater unix family or unix inspired family now we have one last piece of terminology and history and all that stuff to get out of the way before we move on to actually running commands we need to talk about the term shell so you may have heard of this before if you're on windows you may have heard of powershell or you may have heard of bash or z shell or you maybe never have heard of them but there's this concept of something called a shell what the shell is is a very very important piece of software that is going to expose the operating system itself to human users or to other programs so it is the thing that takes our commands and hands them over to the operating system to actually perform and the term shell comes from the fact that it's the outer layer around the operating system like the shell around an oyster so there's this other term terminal way back in the day a terminal used to be an actual piece of hardware it would have a screen and it was a physical device with a keyboard you'd go over and you'd enter your commands into the terminal today terminal is just a piece of software it's an application there's many different terminal applications it's the place we go to type our commands when we hit enter there's some shell that we are using in that terminal window uh by default on ubuntu and most linux distributions that shell is called bash on macs these days the shell is called z shell zsh another very popular shell is fish there are many other shells out there though and again their job is to take commands that we provide or other applications humans or applications provide and then give them over to the operating system and make sense of it all so again i'll be using bash that's the default shell that comes with the boom 2 but if you're on a mac i'll talk about installation and you'll see that fortunately z shell is very very similar and the commands are still going to work so it's not a big deal at all but it's good to know that there are different shells and then the job of that shell is to take those commands and pass them over to the operating system and as i mentioned bash is the most popular shell out there uh especially on linux based systems uh it is the most common default shell and the name if you're wondering it comes from born again shell and it really doesn't matter but it's this reference to this guy steven bourne who created a different shell called sh a direct ancestor of bash so there's sh and then born again sh and again bash will run on pretty much every version of unix or unixlike systems so it does run on macs it runs on you know any linux distribution any of the unix operating systems that you can see on that massive chart next up let's talk about setup and installing things if needed so that you can run these commands so right now we're looking at a linux distribution this is ubuntu this is the linux distribution i'll be using throughout the course if you already have linux if you have some version of it some distribution just use that it's going to be very very similar all that you need to know is there's a builtin terminal application if i just search for terminal i'm going to be running my commands in here probably change the color and this is where i'll type my commands so if you are on a mac you do not need to go and install ubuntu and a virtual machine that's actually how i'm running this i'm still on my mac here but i'm running it in a virtual machine you can do that but unless you have a really good reason to i would just stick with what you know because the commands that i'm going to show you will work on a mac all right so this is just for users who already have ubuntu here's the terminal app you just search for it and we'll run our commands there now if you are a mac user remember it's part of this unix family unixlike operating systems all the commands i'm going to show you will work on the mac all you need to do is search for terminal and it will probably look a bit different than this but you will have a terminal where you can run the same commands i show you so over here on ubuntu when i show the psax ww command it works you don't need to run this by the way but over here on my mac same thing p s a x w w it also works and it will actually learn what this is but it gives me a bunch of stuff all right windows users it's your turn let's talk about installation and the steps we need to go through in order to run linux so remember the problem here is that on windows we just don't have access to the same commands they're implemented differently windows is not part of this unix family this unix like family of operating systems so this means that a lot of the commands you'll learn in this video and that developers use every single day are not going to work on windows or they'll work differently or they'll partially work now windows has its own set of commands and as you could live in that world exclusively it's just a different world so if you want to use a lot of the common developer tools and you know you're watching this video you probably already know what you want to do we need to get some way of running linux commands on windows the way that we do this is really two options there used to only be one we used to have to have a virtual machine it's a pain to install uh it's totally isolated from your actual windows operating system and it can be slow can have a lot of overhead now instead we have a really cool fancy option called wsl windows subsystem for linux this is actually put out by microsoft and it allows us to run a linux environment directly on windows or inside of windows so it's not isolated it's not a virtual machine it actually works directly inside of windows it's just a command line version of of linux to be clear so we're not going to have a separate desktop you're not going to have you know all the apps and stuff that i have on ubuntu but that's kind of the point you can still be a windows user and have linux commands from the command line so it's really really cool it's updated pretty frequently it's still under active development and the really good news is that it's a lot easier to install these days than it used to be you do need to make sure you have windows 10 version 2004 with build number 19041 or higher or windows 11 in order to use the simplified installation instructions otherwise uh you can follow i would recommend going to this webpage anyway docs.microsoft.com look for wsl because this does change but if you have an older version you can still install wsl you just have different instructions but if you have the appropriate build number or higher all we need to do is from the app called powershell which i have open right now you can just search powershell okay this opens up this terminal where i can you can see ps by the way i'm using powershell i can type commands in here and it tells me in that case i don't know what the heck you're talking about but the command we want to run is wsl dash dash install so let's try it wsl dash dash install the requested operation requires elevation so what this is telling me is that i need to have admin privileges or permissions to do that so why is that happening well i need to run powershell as an administrator so i'm going to search again for powershell powershell but i'm going to click on run as administrator here all right and that opens me up a new window it says administrator windows powershell and we try again wsl dash dash install whoops and it might take a little while so i'll be back when hopefully this finishes successfully and if not i guess he'll watch me debug it oh check it out already we can see it's downloading ubuntu so that's the default linux distribution it uses when i first installed wsl a year or two ago for a different course uh you actually had to go and download your linux distribution separately you had to go download wsl separately you had to then connect the two and point it to the particular installation and it was just a huge pain but now hopefully super easy take a look it says the requested operation is successful that's always good changes won't be effective until the system is rebooted so let's reboot okay so once that finishes up i restarted uh i now have actually when i restarted it automatically opened up ubuntu which is now installed it wasn't even a thing before now i have an app i can run called ubuntu it opens up right now at least this terminal that i can see here and it tells me you know i had to install for a few minutes and then it wants me to set up a default user account and this username that i set up does not have to match my windows username but whatever you do you know you want to remember what you put in here so this is going to be for our ubuntu part of this machine i'm going to make my username colt and then a password and you'll want to remember that password you're not going to see what you're typing i'll hit enter and then retype it again you can change that password later i'll actually show you a command you can use to change that password and there we are i now have linux i'm running ubuntu on my windows machine so the commands will learn things like pwd and who am i just to show a couple simple ones or psaxww there are lots and lots of commands we're going to cover and they now will work these commands are running on windows now there is some additional setup you can go through if you go to the installation documentation they recommend on windows that you whoops this is the wrong page here they recommend that after you set up your linux user info which we just did that you can also install an app called windows terminal and windows terminal is uh remember a terminal is just an application that can run different shelves and it can sort of be a jack of all trades we can use windows terminal as our terminal it's just a more sort of fancy better features more customizable terminal application so you do not need to do this but if you want to you can install the windows terminal app and you can make it look all nice and pretty and run ubuntu from inside windows terminal rather than the default terminal that comes with ubuntu so one more time perfectly serviceable just to use this terminal but if you want to get windows terminal if you're serious about you know mastering all this stuff and working as a developer or some other you know you want to use the terminal day in and day out windows terminal is just the better option it has more features so i'm going to install it i'm going to download it just from windows website or microsoft's website now that it finished i'll click launch and remember a terminal is just like a piece of software that can connect or interact with different shells so right now it opened up with powershell which is not what we want to use in this course first of all let's see if i can just make this larger font for you there we go okay it's a little bit larger now so as you can see it's using powershell but i can click this little drop down arrow here and switch over to instead use ubuntu so now i'm in ubuntu you can see my prompt changes here it has my username in there you can customize the appearance and all of that so if we go to settings you know you can go down to ubuntu you can set up a different appearance font size but what you can also do is set the default profile to be ubuntu and if we save that it now means when i make a new window if i just do plus it is ubuntu you can see my little linux penguin that's the logo there and we're now up and running with windows terminal there's a lot you can do to customize it but that's not really the point of this course so now you have it run your commands here when you see me run them in ubuntu uh run them here okie dokie that should hopefully wrap up installation whether you are actually running linux like like i am right now ubuntu this is the desktop version i have the terminal open i will be running my commands right here but if you're not maybe you're using a mac so here's my mac i've got my terminal open right here i'll run commands inside the terminal application here they'll work just the same and then finally if you're on windows hopefully you installed wsl so here we are i'm running this is windows terminal i make sure i'm running ubuntu here i run my commands right here so whichever one you're on just make sure you know where you're going to be running those commands if you're on windows make sure it's not powershell because you'll run into problems we want to make sure we are running ubuntu so that our unix commands will work otherwise they won't yes by the way all three of these are on one computer right now i've got linux windows and my mac okay let's get started okay so now that we hopefully have everything installed correctly we can go ahead and get started now before we do the first thing i just want to make clear is that for the most part there's no order to the commands in this video it's a bunch of commands and they're useful and most of them don't really have to do with one another or depend on each other but early on right now i'm going to go through some of the very basic commands and there is a logical order to how i'm going to teach them all that is to say if you're a complete beginner stay right here and we'll go through the basics in order but if you have experience if you know the basics of ls and man and cd and pwd you may want to skip ahead so check out the time stamps in the description below and click on whatever command looks interesting or you'd like to learn more about but if you are new stick with me let's go ahead and get started all right so before we talk about commands let's talk about not commands in my prompt if i start typing really anything and i hit enter the shell is going to try and process that and figure out what command i'm referring to but i'm not referring to any valid command so i get a message that says command not found same thing on a mac type gibberish we get command not found same thing over here on my windows machine although i'm running linux on windows and i get command not found okay hopefully not that surprising so what we want to do is type commands that actually make sense that the computer can figure out what we're referring to and then run some corresponding program for us and the first really simple one i'm going to show you is maybe not that useful but it's just a good demonstration of a simple command it is who am i all one word no spaces who am i all lowercase it's going to print the username of the currently logged in user so maybe not something you need to do all the time you probably know who you're logged in as though there are uses for this especially in scripting if you write scripts later on but anyway if i just run it here who am i over here on my ubuntu installation i am logged in as colt that is the username i have here's my mac here on who am i my username is slightly different it's my full name called steel and i think on windows it's just cult as well all right so that's our first official command really really simple hopefully nice and straightforward right there's a difference between just typing gibberish and typing a command that is recognized but it is important to note you know who am i like this is not the same thing at all uh there's no real auto complete or spell check or anything like that uh the terminal is just gonna take what you what you give it and try and find that program so it can't find this program who am it only knows who am i okay so the next command we'll look at is called man the man command man is short for manual and that's exactly what it is it is a command that doesn't do anything to our system it's purely informative it tells us information or manual pages for commands as well as some other things not just commands but we're going to focus on the command side of things so anytime we have some new command like we just learned who am i we can actually run man followed by that command name to get a manual page entry for that command so if we need to learn more about who am i or any other command most likely you won't need to learn more about who am i because it's so simple but we can do just that we can run man followed by a command like who am i hit enter and our screen changes pretty drastically that prompt goes away i can't type commands anymore what we see here is a man page it tells us the name of the command prints the effective user id something called a synopsis will come back to this when we learn some other commands and then a description print the username associated with the current effective user id pretty straightforward there's not a whole lot here we can see who wrote the command and we can find a place to report bugs this is a very simple man page some commands have very long pages dozens and dozens of pages you would actually need to scroll through now important to note first of all to get out of here we need to type the letter q if you forget that you can find it down here but remember i am not at my prompt right now i can't type commands so i can't type who am i if i type things i start to see a whole bunch of other texts appear i'm actually looking at some help that tells me more about how this program works so it tells me you know you can exit by typing q or uppercase q or zz you can type h to display the help page that i'm looking at right now so that's what happened i typed who am i hit h but anyway i'm going to type q to get out of there uh now i'm back to the man page for who am i and i'll type q again so just one more time if i type man followed by some command if i want to get out of here type q and now i can type commands again so if i try and run man on its own it's going to tell me what manual page do you want this is a manual command i need to know what you want a manual for so we can actually do man man and that gives us the man page for the man command it's an interface to the system reference manuals there's a bunch here one thing i'll just point out quickly is that we can scroll by using the mouse that is one option but it's a lot easier to scroll one page at a time by hitting space there's a lot of text here and i can scroll down by hitting space rather than having i can also use the arrow keys by the way to go one line at a time up and down which is what i'm doing right now space to go down a page at a time q to get out of here all right so that's the man command nice and simple hopefully very useful especially when we have more complicated commands the next command is also nice and straightforward it is called clear clear and this command will clear your terminal screen it is useful although i'll also show you a shortcut that you can use in place that's actually much shorter so clear will clear the mess on your screen if you have a bunch of stuff here like i do uh clear enter and it's gone so i'll just show another example of that over here this is on my mac let's do some more commands how about man clear let's just take a look at that here is the manual page for the clear command it clears the terminal screen so i'm going to hit q to get out of here so i have a bunch more stuff let's just pretend that's all valid commands i want to get rid of it clear all right nice and easy now let's take a look again at the man page for clear this is on ubuntu and i want to talk about this right here the synopsis so we see the name it's clear here's a little description it clears the terminal screen nice and easy now the synopsis is actually showing us the syntax the accepted options and values we can pass to the clear command so clear is a command that accepts an option we can see if you see anything in square brackets here it means it's optional so you can pass this in you can pass this uppercase v lowercase x now what does that mean well commands accept options that alter their behavior you can change how a command functions so if we scroll further down we can see under options a description of what these different options do now the one i want to talk about is dash x now i don't use this frequently but it's just a good intro to options here it says that it does not attempt to clear the terminals terminal's scrollback buffer using the extended e3 capability i have no idea what that part means but what this means overall is that when we clear with the dash x option it is not going to clear our scroll history so i'm going to get out of here and demonstrate this so i'm going to hit q and let's make some history in here hello there i love you okay none of those are valid commands i can scroll back and you know see those commands and if i type regular clear it's gone i can't scroll back that history is gone now if i recreate some of that hello there i love you a lot if i use clear but this time i provide dash x and that's our first example of an option uh there will be tons of commands we see that accept options and they drastically they can drastically change the behavior of a command i'm going to hit enter and it clears but i can scroll so i don't use that often honestly i'm not showing it to you because it's something you need to know i'm showing it to you because it's an intro to options now one more thing i mentioned there's a shortcut and i don't really type the clear command anyway the shortcut is ctrl l so if i have a bunch of stuff again i want to get rid of it ctrl l and it's gone so that's definitely easier than typing clear it also works over here on my mac it works on wsl just control l okay so that's the clear command nice and easy the next command is also nice and easy it is pwd it stands for print working directory and this is a command that just tells us our current location in a given terminal window so let's start with man pwd and it tells us pwd prints the name of your current slash working directory so just like when we have i'll open up my file explorer here with my graphical user interface using my mouse i have a current directory that i'm inside of i'm viewing right now my desktop as you can see it's selected there or i can view documents or i can view my home folder this would be my current working directory home in this window right here but in a terminal it's a little bit different let me get out of this man page here hit q if i type pwd it tells me in text where my location is so in this window i am on the desktop which is located in the cult folder instead of slash home over here this is a different terminal window it has a different location just like i can have multiple file picker windows here's another one this one's in my home directory and this one's in desktop same idea so i can have in this case pwd a terminal window that is in slash home slash cold slash bin and here's one more different window a much longer path this is the full path to get to my location now i haven't shown you how to move so you probably don't have something like this set up with these different windows by default you can actually configure the default location of a new terminal window for me when i make a new terminal window just click that button there you can also use a shortcut it defaults to the desktop at least on ubuntu over here on my mac when i make a new window it defaults to what is called my home directory slash users slash my username you can configure all of this but it doesn't really matter where you are at the moment all that matters that you can find it by typing pwd alright so the next command we're going to cover is called ls the ls command is short for list and we use it to do just that it will list the contents of a folder so we can see what is inside of a directory you know normally if you're using a graphical user interface you don't need a command you just can see the contents of a folder but in a terminal window that is not how things work at all we have to ask for a list of the contents so here i'm on my desktop as we can see i ran pwd it says slash desktop you can also see my prompt is displaying desktop there as well that is also something you can configure by default though on ubuntu it does show you your current location anyway if i actually look at my desktop i can see a bunch of stuff there and i can list it out using the ls command so if i run ls with nothing else just ls it's going to list the contents of whatever current directory i'm inside of in this window it's the desktop and here we go we get a bunch of text so we see things like you know my folders uh some of them are quite odd here i've got wildlife i've got uh i've got files like greatgatsby.txt so there's some different colors and folders for me our bolded files are not bolded and they're just showing up white but that's all configurable as well but this is showing me all the contents of my desktop if i try it somewhere else here i'm in this slash bin directory i'll type ls i see different contents uh here that's my desktop desktop all right well let's try it on my mac here this is my home directory um i see a bunch of other stuff right this is different i see folders for my courses i make my desktop my documents labs some random things that you need to get rid of like hello.js and orange.python those are my files and folders now we also can provide a folder that we want to look inside of we can provide a path to ls so instead of just looking at our current location i could peak somewhere else so for example right here let's see i'm on my desktop and we saw that there is a wildlife folder on my desktop i could ask what is inside of there by running ls wildlife and i can tab complete so i don't have to type the whole thing and hit enter and i have no idea why i have a wildlife folder that contains three text files called angela one and nico survey it doesn't sound like wildlife to me but okay i've got a meal diary folder let's take a look in there and it has nested folders inside so now we can even burrow further in if we wanted to from my current location on the desktop i could look and set a meal diary and look inside of friday by doing this ls meal diary slash fry and i'm using tab complete so i'm giving it a path a path that is beyond it's not just one folder name it's now two that i want it to peak inside of so peek inside of this and we have breakfast dinner and lunch so i can actually run this again and let's see what's inside of breakfast i don't know if there's anything in there i'm gonna recall the previous line by hitting the up arrow and then just add a b and hit tab yeah there's nothing in there no it's a bit of a letdown so that's one example of using ls where we provide a file or rather a folder path but we can provide a full what's called an absolute path to any location on our machine so this file breakfast or this folder is inside of friday is inside of meal diary which is nested in the desktop which is where i currently am right pwd i'm on the desktop but maybe i want to see what's inside of my documents folder and documents is not on my desktop well one option is to do this ls and then the full path to my documents which is slash home slash colt slash i think it's uppercase documents so i'm using tab completion again so i don't type that myself i don't know if there's much in there nope just a single file but we can see kenneth.txt now i could get there right by just opening the file picker going to documents yes i see it but there are some special things that we can do with the ls command in the terminal as well but just to recap what i showed there we can provide what's called a relative path so relative to our current location i could just say show me list the contents of meal diary but that only works if i'm on the desktop if i'm somewhere else i can't just reference meal diary i need to reference the full path and that's exactly what i did down here to get to documents the documents folder is not in my desktop so i can't do ls documents it's going to tell me i don't know what you're talking about that doesn't exist here on the desktop but if i provide the full path this is the unique location the absolute location of documents i can see it's not exciting but i can see there's one file all right so now let's talk about some of the options ls accepts so let's use that clear command or use ctrl l and then let's run man ls it tells us it does list directory contents and then it says that there's a bunch of different options and i'm going to scroll through them these are all the options a lot of them most of them i don't use doesn't mean they're not useful they're just there's a lot i want to highlight two that are very useful the first one is dash l so let's find it here dash l come on h i j k l doesn't tell us much but it says it will use a long listing format so this means i can take a look around with ls and rather than just getting the file or folder name i can instead add dash l and get a whole bunch of other information so there's a lot we're not going to go over here but there's file permissions there's the owner of the file there's the group owner there's file size information modification date the file name so a lot of stuff here for each individual file so that is dash l now another thing we'll take a look at another option i'm going to go back to man ls is dash a now dash a you can also do the longer form dash dash all all it says is that it does not ignore entries starting with a dot when i just type ls i don't see any files or folders that start with a dot ls dash a i now see quite a few dot bash a bunch of stuff dot profile dot less something dot pseudo something there's probably some different ones on your machine i'll just try another example here lsa on my mac lots and lots of files that start with dot they don't show up if i do a regular ls which you can see right there nothing starts with a dot now we can combine options as well so if i want to and clear this screen i can do ls dash a to see all files including ones that are hidden dash l i want the long format that is one way of doing it but the much shorter and more common way is actually just using a single dash and put your options together so dash a l or dash l a i see the long format all the information for regular files and files and folders that start with a dot so we're getting both of those options uh taking effect at the same time so that's an intro to the ls command so we've seen how to find our current working directory where we are and list the contents of that directory now how do we move around how do we do the equivalent of what i'm doing right here in the file explorer double clicking on you know desktop and then going into this folder or going back how do i move around like i am right here well in the terminal the way that we do that is by using the cd command cd is short for change directory now the first thing you'll notice if you try and read the man page for cd it does not exist it just isn't there when i try it on my mac i see something but it is not a man page 4 cd if we look up here it's a man page for a bunch of commands tons and tons of commands including cd well what's going on here is that the cd command is actually implemented by the shell we don't need to dive into the specifics really at all just i want you to know that you're not going to find a super helpful man page for cd it's one of the few commands that we'll cover that does not have a man page however you can run help it's a different command it's like the shell's version of man help space cd and it's kind of annoying it just prints out text you don't enter that program where you can scroll nicely it just takes up a whole bunch of text but it does tell us it changes the shell working directory change the current directory there are some options we're not really going to use those however let's just see how it works so i'm going to clear my screen first of all remind you where i am in this window i am in my home cult folder if i type ls i see a bunch of other folders so let's say i want to move into one of those folders how about my desktop well the way that i do that is by writing cd and then specifying that path so i'm just going to do d e tab hit enter and you'll see my prompt changes if i type pwd you can see my location has changed to be home slash cult slash desktop before it was just home slash colt so i just jumped i just double clicked into that folder but i didn't click anything it was all done via the terminal so i type ls i'm on the desktop now let's go into the meal diary folder cd into meal diary all right and we're now in here i can cd into how about friday type ls or pwd you can see i'm now at this pretty long path if i type ls let's cd into breakfast so that's a really common thing ls and then immediately after cd you you use ls to look around and then cd to change directories into something that you just found so now i'm in this folder breakfast and i've hit a dead end there's no more folders to cd into uh how would i back out right normally if i did the exact same thing so on my desktop with the graphical user interface it was meal diary is that right if i can find that i double click friday breakfast okay how do i go somewhere else well i have a bunch of options i can hit the back button i can use these buttons up top to jump around but here how do i go back with the cd command well the answer is to use cd followed by dot dot so two dots is a special path that indicates or it refers to the parent directory so it's how i can back up one folder right now i'm in breakfast if i cd dot dot now i've gone back one level into friday pwd you can see i'm in friday type ls this is the contents of the friday directory so that's how i can go back one level i can go back further and repeat it and now i'm back on my desktop now i can also instead of just cding into one folder at a time one level at a time i can jump to any location on my machine as long as i have the full correct path so if i wanted to go back to where we just were which was this location here right desktop meal diary friday slash breakfast i could do that in one step cd and then meal diary slash friday i'm using tab slash breakfast so i don't have to do three separate cds i can jump as many levels as i want and the same actually goes for moving backwards i don't have to do cd dot dots enter cd dot dot enter uh if i want to move back multiple levels i can chain it together i can do this this is one option so it's a little clunky to do it this way but it does work so this is going to take me back one parent folder and then its parent folder and its parent folder and now i type pwd i'm back on the desktop i can also pass in absolute path to cd so everything we've done has been relative to our current location but if i want to go to my documents folder well it's not here it's not in the desktop i can't do cd documents if i try it doesn't know what documents folder i'm talking about it's only looking in my current location and there's nothing called documents on the desktop my documents folder is located at this path it is slash home slash cult slash documents and i can jump right there it doesn't matter where i am i can run that command anywhere and i'll be able to get to documents i'm now in documents one other note around cd and path names you'll see this tilde that refers it's a shorthand that is eventually expanded into your home directory now it's kind of confusing because this is called home but the home directory for each user is a directory with their username so for me it's colt so if i cd to tilde and i do pwd it takes me to slash home slash colt if you cd to tilde it will take you to whatever your usernames folder is and this folder is a very important place it has the desktop it has documents downloads a whole bunch of stuff you can put your own things in here too but even just if you do nothing it contains a lot of important folders and documents uh so that's kind of the basics of cd you can cd into a location that's relative to where you are like desktop i can do multiple levels at once i can back out with cd.dot we combine it often with ls take a look around where do i want to go let's go into wildlife cd wildlife okay i got some stuff in here and i'm not gonna do anything with it let's back out and i can also pass an absolute path at any point uh which is again a full path name not relative to our current location so that is the cd command so next up i want to talk a little bit more about folder structure and how things are organized if you noticed when i talked about absolute paths all absolute paths started with a forward slash and the reason for this is that the very very highest level directory on our machine is the slash directory also known as the root directory which is really confusing people call this root but there's also a directory called root root definitely confusing uh in the same way that people refer to uh you know my home directory colt if that's my username that would be colt's home directory but there's also a directory called home it's uh yeah it's not the most straightforward thing so the top level directory is slash we can actually go there if we wanted to from anywhere on my machine i can do cd slash and if i take a look around we've got a bunch of stuff that we normally don't mess with at least not as a typical daytoday user if you start writing scripts if you start doing admin stuff absolutely there are changes you can make here but we can look around there's a bunch of different files or folders and things called uh sim links that we'll learn more about later on in this video um and that's kind of all i'm going to show in this directory because there's just so much here uh but what i want to mention is that your desktop your documents your music your whatever files and folders you make typically are going to live inside of the home directory inside of your particular username so for me my username is colt we can always find that out if i need to it's also just right here in my prompt cult so i can go into the home directory i'll cd into that if i take a look around every user on my machine has their own unique home folder so carrots cult elvis and kitty let's take a look at kitty's directory whoops not kits kitty and you can see we've got desktop download documents pictures and all the stuff that we would expect i'll back out again and then i'll go into colt and this is where we've been working now i just wanted to reiterate how this all works slash is the root it's the top level directory on our machine we cannot go higher than that if i try and go to slash and then back out i'm not going anywhere i'm just staying right there at slash now as i said every absolute path starts with a slash because an absolute path is the full location the unique full location to reference a particular file or folder so it always starts with a slash now another character that we've talked about briefly is the tilde here which refers to your individual home directory so if i cd to tilde i'm logged in as colt that will take me to slash home slash colt as you can see right here okay and that's all i really wanted to mention around folder structure of course there's a lot more there's all these folders there's dozens of folders here that we're not going to discuss everything we're doing lives inside of our particular username home folder so slash home slash lily slash home slash colt and then remember this difference between relative and absolute paths if i wanted to go let's see where am i right now i am in my home directory if i want to go on to my desktop from here i can just cd into desktop that is relative to my current location but as we talked about that only works if i am in a place where i can view the desktop it's it is in my current folder so basically the only place this would work is from my home directory right here but if i go to slash i'm not going to be able to just cd into desktop i can't auto complete there is no desktop right here so i need to use an absolute path and i could do the full long name cd slash home slash cold slash desktop like that or i can do the slightly shorter version use that tilde character which refers to my home directory slash desktop okay moving on the next command we'll cover has to do with making directories or making folders it is mkdir or make deer mcdurr however you want to pronounce it it is short for make directory and that's exactly what it does it's the command we use to make folders so the basic way we run it is make directory or make deer space and then some folder that we want it to create for us and it will create that folder so let's try it i'm going to cd just onto my desktop i'm going to clear control l and i'm going to make a new folder here i'm going to make a folder called greenhouse i have a new greenhouse actually and i need to manage the crops that i'm growing and starting seeds and bills and maintenance and time sheets for employees i don't know that's just that's the story i'm going with i'm going to make a folder called greenhouse on my desktop so i'm on the desktop right pwd there's no folder called greenhouse you can see it's alphabetical there's it goes from great gatsby grep exercise keys so if i run make directory and then greenhouse if that's the name of the folder i want it to make me i'll hit enter we don't see anything happen but if i type ls again we now have a folder called greenhouse and if i just move this out of the way you'll see on my desktop there's greenhouse it's totally empty it's an empty directory so i can cd into that folder and that's exactly what i'll do cd into greenhouse oops i hit enter too early green house there we go i use tab complete again and now i'm in here so we can also make multiple folders at once you just separate their names by spaces so i'm going to make a winter and summer directory inside of greenhouse make directory winter and summer so i can have you know different schedules for what i'm growing in summer and winter i'll type ls and we see those two folders were just created for me in my current location right that's all i specified was summer and winter i didn't say any fancy path but what i can do is actually provide if i wanted to make inside of summer i wanted to make a folder called how about you know seeds i could do make directory summer slash seeds so i'm inside of greenhouse but i'm not inside of summer so in other words i'm right here in this folder i'm not going to go into summer and then make a folder in two separate steps i'm doing it in one step i just provide a path make the seeds directory instead of summer i'll hit enter okay type ls i don't see it but if i do ls summer there we are i'm looking inside that summer directory there's my seeds folder okay now one last thing i'll show you there's an option that's pretty common which is dash p which allows us to make nested folders so why don't we just take a look at the man page man for make directory and we'll scroll down here's p or the long form dash dash parents it says no error if existing make parent directories as needed so let me show you what it means when it says no error so inside of the winter folder which i'll just point out here graphically i want to make a seeds folder and instead of seeds i want to make a lettuce folder so if i try and do that all at once i'm inside of greenhouse if i do make directory winter slash seeds let me just expand this window a bit here winter seeds slash did i say spinach no i said lettuce if i hit enter here i get an error it says can't create such directory it runs into a problem because it expects that winter slash seeds already exists and it thinks it just wants us or we just want it to make lettuce that's not the case i want it to make seeds and lettuce but seeds doesn't exist it freaks out but that's where the dash p option comes in so make directory dash p winter seeds slash lettuce we're now telling it make any of the needed parent directories along the way to make this lettuce directory we don't get an error and if i type ls here we don't see anything but if i do a lswinter we see seeds if i do ls winter seeds we see lettuce so it successfully made that nested directory and any necessary directories along the way so here's we go back winter it made me seeds and inside of that it made the lettuce so that's the dash p option and that's really all there is to make directory so mkdir followed by whatever directory you want it to make and some location for that directory often it's just your current location but you can provide a path a destination as well so if i wanted to make something all the way back in my home directory which again i can use tilde as a shortcut i could say make directory tilde slash blah blah i'm going to delete this once i learn how to delete folders i won't see anything here but if i go all the way back to my home directory there it is right there so we can provide a relative path an absolute path we just give it some destination to make a folder and it makes it for us that's make directory the next command we'll cover is touch so touch unlike most of the other commands doesn't really tell you a lot about what it does or its name doesn't indicate its most common use make directory makes a directory uh you know change directory changes directory touch is used most of the time at least to create files so there's no create file or make file it's just touch so uh we'll talk about where that name comes from in a moment but let's just try using it if we run touch and we provide it with a file name that doesn't yet exist it will make that file for us so let me go to my desktop i made a greenhouse folder deny and then summer and winter let's cd into summer cd into seeds and let's make some files here so let me clear my screen i'm going to make a file in here there's nothing at the moment i'm going to make a file called how about squash so squash i'm going to have a file full of different types of squash seeds i guess so if i just run squash as is that's totally fine squash if i type ls it made that file for me i'll just show it to you also visually if i go to my desktop i'll go to greenhouse if i can find it summer seeds here's my empty squash file i can open it it's completely empty okay so that's one option i can also provide an extension as i'm making a file so if i want to make a txt file i can do dot txt so let's make another one how about berries how about just melon another summer fruit dot txt and i now have a txt file called melon.txt now it's important to note that the extension you provide it does depend on the exact operating system you're running but the extension does not indicate it doesn't it's not what's used to determine the actual file type of a brand new file so these are all empty files i could make a pdf file if i wanted to touch apple.pdf it's not really summer but if i type ls we've got an apple.pdf but they're all just completely empty at this point if i look at any of these files they are just plain old empty files at the moment of course i can put stuff in them i can change that extension there's all sorts of things we can do so let's try another example i'm on my mac here i'm going to touch multiple files so in this directory it's called colors i have a colors.txt file i'm going to make a couple of new files let's go with red dots pdf and then a space orange dots let's see how about png and then yellow we'll do a different extension here how about an excel xls i type ls those files were created they're all completely empty now here is i'm on my mac this is finder the graphical user interface i've got red.pdf orange.png if i try and open one of these just with my mouse on a mac it does try and use preview it does think that it's a pdf and it says it's empty i don't know what to do with that if i try and do a pdf it does use a pdf reader or pdf viewer but again this is just on my mac if i go back to ubuntu here and i open up a pdf it just opens in a text editor if i open up if i make a png file touch what's another fruit how about barry.png if i try and open that oh it uses the text editor as well okay so it does vary from one system to the next but the point is we just make empty files with touch now let's talk about when we provide a name of a file that already exists so if i run touch barry again i can do that i can just hit the up arrow it's not going to seem like it does much it doesn't make me a second file with the same name that would be a problem what it does instead is that it actually is going to update the timestamp of the file so it touches it if we run man touch always a fun command to type out man touch uh it actually says its main purpose is change file timestamps update the access and modification time of each file that we provide so it says here secondarily a file argument that does not exist is created empty so that's why it's called touch rather than make full make file or create file or something its main purpose at least historically is to change the access and modification times of a file and then oh also if that file doesn't exist it will make it as an empty file so how do we know or how can we view the access and modification times if we remember lsl that flag if we take a look at barry.png here right there october 15 1348 is the modification time that's ls dash l is the long listing format so 1348 let's see it's now 13.50 so if i try and touch barry.png again and i do lsl we now see it's showing october 15th 1350. so it does in fact update that modification time but most of the time 99 of the time that i use touch it's to make files uh and i can make a bunch of them at once as we saw just provide a bunch of file names separated by spaces and it will make them for you okay so we saw how to make files and make folders let's talk about destroying things so to delete a folder we can use the rmdir remove directory command rmdir followed by the name of a folder or a path to a folder that we want to delete or multiple separated by spaces however this will only work if the folder is empty so over here uh i've got i don't have any folders let's make a folder make directory uh delete me in all caps there it is to delete it one option is rmdir delete me i type ls and it's gone but if i back out and i try and delete the seeds folder which is not empty rmdir seeds we get an error failed to remove seeds directory is not empty and that's really all there is to rm deer it removes empty directories only empty directories we'll see another command we can use to remove directories that have stuff inside of them so next up we're going to talk about the rm command rm for remove let's take a look at the man page it says we can use it to remove files or directories so we saw how to use rm deer it only works to remove an empty directory i've got this seeds directory rmd or seeds no luck it's not empty alright so this is where the rm command comes in i'm going to show you how to use it to delete directories in just a moment but we're going to start by deleting files so i'm just going to make a couple files with touch uh how about cat dog carrot um blue all right so i have these four files now i can delete them using rm followed by let's do blue to start uh the name of a file and that's it it is gone now it's very important to note uh there is no intermediate recycling can or trash can or something some sort of bin we can go find all these files we've deleted they are just completely gone they're just vanished from our entire uh system so that can be uh a bit of a scary thing if you're not careful with what you're deleting so you definitely want to make sure you're only ramming things that you mean to rm but the flip side of that is that it's very fast powerful quick and easy to delete things uh just as long as it's not too easy and you slip up so we can delete multiple things multiple files if we just separate them with spaces of course like that carrot cat and dog are all gone so that's the basic use of rm i'll show you one more there's a couple of flags i want to talk about the first flag is dash v this is actually a trend there are many commands that support a dash v for verbose that option in the case of ram will give us some verbose output that that basically explains what it did if you notice here we run it we deleted three things but there's no feedback it's just silently deleting them we had to look to see are they gone well if we use dash v i'm just gonna remake my uh four files again if i use dash v so rm carrot cat dog dash v for verbose now it just tells me what it does each step of the way removed carrot removed cat removed dog pretty straightforward hopefully but the end result is exactly the same you do not need to have that of course it's just something you may want to use some people like to use it and like i said there are other commands like when we see copy cp and move mv we can use dash v for verbose output and it will tell us just copied this file i you know moved this file renamed this file removed okay so that's one flag dash v the next thing i want to talk about is using rm to delete a directory so we talked about rmd or does not work on seeds or any folder that is not empty so that must mean rm will work right let's rm seeds oh no cannot remove seeds is a directory but i thought the whole point was you know rm could delete a folder that has stuff in it yes that is the point uh but we have to use a flag and the flag we need to use is the r flag for recursive so if i do man rm again i'll scroll down a little bit further r so we can do lowercase r uppercase r or dash dash recursive if you really have a lot of time to spend and what this will do is it tells the rm command to remove directories and their contents so that could be other directories and further nested directories there could be hundreds of levels of directories nested down remove them all so here's how we would use it if i want to remove the seeds directory this is what it has inside remember it has four files and i want to remove that entire directory it's just rmr seeds and once again there's no feedback i could have added dash v and it would tell us more but now it is completely gone that's it so i'm going to make a directory again we'll call this zoo let's cd into zoo i'm just going to touch some random let's see animals cat dog snake i don't know jaguar okay so uh i have that zoo directory now i'm going to back out again this time i'm going to delete it with rmr but i'm also going to show you a new flag dash i for interactive and interactive is going to prompt us and ask us if we want to delete each file or not so if we do dash i here and then the folder which in this case is zoo now it's asking me do you want to descend into this directory zoo so do we want to go inside and see what's there i'm going to say y for yes or if i said no then we kind of end it all but i'll do y do i want to remove regular empty file snake yes cat y for yes let's keep jaguars i'm going to say no dog yes and now it's asking me do you want to remove the directory zoo uh i'm going to keep it so that interactive mode allows me to make decisions uh if you're deleting you know 10 000 files maybe not the best option but that is a flag we can use dash i to interactively decide what to delete and what to keep so now if i look at zoo it only has the jaguar file inside one more quick demo i want to show you i have a let's see where did i put that my desktop a directory called meals and inside of meals i made 52 folders one for each week of the year and inside of each week if i just pick one like week 35 there is a folder for each day of the week and for each one of those days there are three files breakfast lunch and dinner dot txt so we've got three files for each day of the week for 52 weeks of the year it's a lot of files and folders nested i'll show it to you here so this is the meals directory all these different weeks pick one pick another day all those files so there's a lot of stuff going on here and i just wanted to show you that i can delete the entire thing very easily and very quickly all those nested folders and files using rm so i'm going to cd back a couple levels one more and one more just to reiterate you know i don't need to do cd dot dot cd dot cd dot dot to go back three levels i could have done that right there or i could have just said take me to the desktop specifically so this would work from anywhere this cd dot dot cd dot dot cd dot dot only works if i'm three levels away you know three levels burrowed down from the desktop if that makes sense this will work from anywhere anyway i have this meals directory i'm going to remove it i need to do a dash r and i'm going to make it verbose so you can see exactly how many things it removes in a single go so this is just one command remember no recycling bin no trash can these files are gone so you obviously want to be careful but here we go rm dash r for recursive so we can delete a directory that has stuff in it and dash v for verbose and if i scroll up i'm going to be scrolling for a long time lots and lots of files and folders deleted in a split second so that's the rm command it also does work to remove empty directories so um in that sense you kind of never have to use rm deer i just show it as a quick you know command that you may encounter some people like it because you know that you're not going to be accidentally deleting stuff that has a bunch of contents inside of it but you could just use the rm command in general to delete files delete empty folders or delete folders full of a bunch of stuff as long as you use the dash r option all right so that is rm the next command i'll show you is one i use all the time on my mac it's called open and it will open a folder open a file outside of the terminal in the the sort of graphical world of our machine so if i make a bunch of files like uh i don't know how about purple i'll just make one dot txt if i now want to do something with that file i don't know i want to view it in finder well i could navigate to it and figure out where this is or i can do open i could do open dots that will open the current directory and here we go a finder window with that directory but i could also say open that particular file and it opens it up in the default application which is just a text editor on my mac but if i had some other file you know i can find an example here if i go to my desktop which i edited out i've navigated here i've got a file uh let's see i've got a pdf file if i open that it opens it up in my case using a pdf editor the default you know what it would open with if i double clicked anyway so that's the open command but it is mac specific so again i can do things like open dot to open the current directory i can see all my files and you know work with them here if i need to i can open a particular file and it's pretty smart but if i try this on ubuntu here i've got two directories here if i try and open that it's going to complain to me it can't do it it doesn't know that command now there is an alternative which is x d g dash open and uh there we go it opens up you know in this case this folder for me if i have a file just call it touch tomato.js if i do xdg dash it's a bit of a annoying one to type but open tomato it opens up the text editor and i can start working on this file now you may need to install it just to be clear i think if on wsl here if i try xdg open dot well i need a dash there it complains and it tells me i need to install it using this command so you can install that if you want but this is one of the main differences here open is a mac only command it might be one of the i think it's the only one we cover in this video that is different between mac and ubuntu or linux the next command we'll look at is mv for move this is how we can move files around it's also how we can rename files and that's going to be the first use case i'll show you if we run mv followed by an existing file and then a space and then a new file name what this will do is move pair turn it into new pair it will rename it so let's try an example here uh oh got a lot going on here why don't i make a new directory in here i'll just call this um commands i'll cd into there okay i'm gonna make a file in here and i'm gonna call this my journal but i spell it wrong like that and i wanna rename it i can use move let me just show you there it is i can use move and then the incorrect name journal.txt and then the new one just like that and again you may not get this verbose output that's just a setting i have but if we type ls we see journal.txt now if you do want that verbose output just for any of these commands like rm if i do m v i get the man page for mv there's an option in here further down dash v which explains what is being done so if you want to know exactly what's going on let's say i want to rename journal the correct version i want it to now be an uppercase j i don't know why if you add dash v which mine have by default you'll get that verbose output honestly i only put that in there when i'm teaching so people can see what's going on i don't really care to get that confirmation it yeah it's gonna work either way and we can see it's been renamed now we can also use move to change the location uh not just rename you know in the same directory but to move a file back a directory or into a completely different directory so let's find an example of that let's just make a directory here i'll call this one i don't know stuff and i realized shoot i really should have made that journal file inside of stuff well i can move it in there it's pretty easy i can just do move the thing i want to move and then the move command is smart enough to know that if the last parameter the last argument is a folder it will be the destination folder so i can move journal into stuff and if i type ls i don't see journal anymore if i look inside of stuff it's inside our journal is inside of stuff i can also do that to multiple files at once so if i touch i don't know about pi and cake and cookie sure i have these three files if i want to move them into stuff i can do mv cake cookie pie and then as long as stuff comes last it will be the destination folder and there we go they are moved into stuff now there's more you can do with move you can move folders around you can rename folders so if i want to rename stuff instead to be stuff in all caps move stuff to be stuff there we go i just renamed it um so yeah that's probably all i'll show you for move it's pretty powerful i use it all the time to move things around you know i could move this entire stuff directory onto the desktop if i wanted to i could do move stuff and then just have it go back one directory right now i'm on this commands folder i want it to go onto desktop it's not here anymore i'll cd back and here it is on my desktop somewhere there it is this is the one the uppercase stuff all right so let's move the next command i'll cover is cp which is for copy we can use this to copy a file or even copy folders so if i make some file i'm on my desktop here there's just too much stuff going on let's go back to my stuff directory okay so i've got this journal file if i want to make a new copy of it let's say for today's journal sure i'm going to copy it i can do cp the thing i'm copying which is journal and then the destination for the copy so if i wanted to be in the same folder then i don't need to do anything just provide a name so how about today's today journal or something like that and that makes me a copy so i have journal and i have todayjournal.txt now these are all empty so it's not that useful to show but if they had content inside of them like i'm on my mac here i have this linuxcommandhandbook.pdf if i want to make a copy of that cp linuxcommandshanbook.pdf and just give it a new name how about handbook dot pdf just like that if i type ls well there's gonna be a lot of stuff on here but there is a handbook.pdf file and if i open it up or just yeah i'll open it sure you'll see that it is a full copy so it's the entire linux handbook here all these commands we've been covering so it doesn't just copy empty files that's very important we can also copy entire directories so let's go back to ubuntu where are you here we are i've got this stuff directory why don't we copy the entire stuff directory so uh cp stuff and then i want to make a directory called stuff copy well if i try that we have a problem it says dash r not specified omitting directory stuff it's not going to copy this well if we take a look at the man page for cp it tells us if i scroll down there is a dash r option which just like with remove rm stands for recursive so if we want to copy the contents of a directory and any nested directories and their contents and so on we need dash r so let's replace this let's rerun it one more time cp dash r stuff stuff copy i have that dash v verbose on by default again you can turn that on if you want or you can just run it with dash v if you really want this output but here we can see it made a copy of the stuff folder and all of its contents so if we take a look here's my stuff copy and inside of it we have all of these files that have been copied as well so we can make copies like that i can also move as i'm creating a copy so if i want a copy of i don't know song of myself and i want it to go inside of stuff copy or instead of stop whatever let's go to my desktop i could do copy song is it capitalized yes it is song of myself long poem and uh let's actually put it uh sure let's put it inside of stuff so stuff slash and then i'm gonna call it s o song of my self sure psalms dot dxd all right so i'm gonna copy it but i'm also moving it at the same time because where i'm copying it to is a different destination i won't see psalms in here if i look in stuff cd into stuff nope where did i put it well wow i'm an idiot i put it inside of stuff with lowercase how confusing it's not in here it's going to be in this one so if i cd into lowercase stuff there it is soms.txt all right so it is there and that is a copy of that file so that is the cp command the next command we'll take a look at is called head so let's look at the man page for head it says that it outputs the first part of files head and tail are often used to refer in programming to two different ends of a structure in this case a file the head of a file is the beginning the tail would be the end so it's a really simple command it just prints out by default i think it is the first the first 10 lines of a file but we can actually specify an exact number using the dash n option but let me just show you uh so i've got this very long file in here which is song of myself.txt it's like hundreds of lines of long poem uh if i run head song of myself.txt it just outputs the first 10 lines now as we saw i can provide the dash n option followed by a number like 100 and it prints the first 100 lines from the beginning of the file so there we go 100 lines and that's kind of all that there is to head now there's also a command called tail let's look at man tail and it unsurprisingly probably outputs the end of a file so by default it's the last 10 lines but we can also provide an exact number using dash n uh and there are some other options here as well but let's just start with that so i'm going to do tail song of myself.txt here are the last 10 lines of song of myself but i can also say i want the last 20 lines and there we are i get the last 20. now with tail i'm on my mac now there's one option that we don't have with head which is dash f where are you here we are dash f it says it causes tail to not stop when the end of file is reached but rather to wait for additional data to be appended to the input basically it's going to read the end of a file and print it out but then also keep printing out any new additions to the end of that file this can be useful for log files output files error logs things that are changing and you want to monitor them if i just do tail this is a on a mac at least this system.log file it doesn't matter really but it's a file that contains a bunch of stuff i honestly don't know what half of it is and if i don't have that dash f option it just stops this is the last thing printed out but if i add that dash f in there whoops i need to make sure i put dash f in there first now my prompt does not come back this file is being printed out the end of it is being printed out and if i do something that would add to that log file if i i may i make a new window like i just did i'll do it again you can see that that log file is changing content is being appended to it so i'm getting a live and as i close as well you can see things are changing i'm getting a live update as i make a new process or i kill a process from this system.log file whereas if i had just i can get out of here by the way ctrl c but if i had just done tail without dash f it's not live it just stops it shows me exactly what's at the end of that file right now but with dash f it keeps listening and keeps updating the output so that's tail so the next command i'm going to show you is one that i don't really use very much i'm showing it to you actually because it helps illustrate some other concept so the command i'm going to show you is called date it's really straightforward date and it just prints out the current date and time let's see i'm sure there's some other options and different things we can do we can specify how it should display the dates honestly we're not going to go into it because as i mentioned i don't use very much it can be useful though if you're writing a script and you need to get access to the current time or the current date day of the week that sort of thing anyway the reason i'm showing it to you is because i'm using it to illustrate something that is not a standalone command we're going to talk about something called redirection so this greater than sign right here we can use to perform something called redirecting standard output so the date command or really any of the commands we've seen if i do ls not la ls or i do date or pwd all of these generate output and that output by default shows up in our terminal right it's printed out as text here but we can actually redirect where that information goes uh by sending it to a file if we wanted to so i can take the current date and store the result instead of printing it out store it in a file and to do that i use the greater than sign again what we're doing here is redirecting standard output okay so let's make a file i'll show you we don't actually have to make a file first but i'm going to make an empty file i'll call it today.txt uh there it is today.txt all right so what i'm going to do next is redirect date so again the date command greater than sign today.txt and this tells the terminal run this command first but whatever output we get don't just print it out instead we're redirecting the output to this file okay and we don't see any output nothing is printed out if i type ls there we are we see today is still there now in a moment i'm going to show you a command we could use to read this file very easily but we do know head we've already seen that so i could do head today.txt and take a look we see that it contains that text so what do you think will happen if i recall this line and i run it again so take the current date whatever that is that output and send it over to this file the file looks like this right now right if i run it again we'll get a different time it's still friday the 15th of october but it's now for what 27. so this should change um but what you'll notice is that it actually ends up replacing the contents of that file so it's not added as a separate line right we don't have two dates in there now it ended up replacing the entire contents of the file so this is very important if i had a lot of stuff in there for example if i navigate back i have this uh let's see stuff directory lowercase stuff i have this song of myself.txt you do not need to follow along with this but this file contains a lot of text if i just look at the first 10 lines it's the entire text of that poem song of myself now if i try and redirect something in there i can take the output of pwd for example and redirect that into song of myself.txt now that is the only thing in that file the output of pwd so we have another option which is to use a different operation very similar we use two greater than signs and this allows us to redirect standard output while also appending to a file instead of overwriting the file entirely so if i just ran you know pwd and then two greater than signs into this file this is let's do it a couple times this is silly to do but if i take a look at that file it now contains what five different lines let's take the date and redirect it into there let's take uh who am i and redirect it into there okay now let's take a look at that file again and you'll see it contains the output of pwd five times the date and then who am i which in this case is colt let's do date one more time or a couple more times let's run head and you can see it did not overwrite the entire file it just appends onto the end so you know date i don't use very much at all redirection though both with a single greater than sign which overwrites a file and two greater than signs is really really common uh the last thing i'll mention is that you can do something like this date redirect into today.txt that file does not exist in this folder if i take a look there is no today but if i do date redirect into today.txt we now have a today file it made it for us so the file does not have to exist in order to uh you know redirect output to it uh it will make that file for us if it needs to all right so we can do it with the date command we can do it with really any command that generates output as we saw i mean i could do if i wanted to ls or lsl that gives me a lot of text i could take that and then redirect that to a new file called you know contents how about that and if we take a look at contents we'll just use head for now this is what the first 10 lines are now there may be yeah i think there's some more that's missing but we're just doing the first 10 and we can see what is inside that file so that's the basic concept of redirecting and then of course if we use 2 greater than signs we are redirecting by appending to a file the output is appended to contents and now if we do head we'll probably need to specify you know i want how about just 40 lines of that file we can see all of this is in there all right so next up we have another command called cat cat and let's start by just taking a look at the man page for cat the name cats comes from the fact that it concatenates files cat but the first use i'm going to show you is something slightly different on its own if we just run cat i'm just going to clear here cat and then a file name like i have this uh song of myself i actually don't think there's we we overwrote that didn't we but if i do cat and then a file name it just prints the contents of that file in this case to my standard output to the terminal if i have and we had that contents file that we just made cat contents it gives me the entire file so it doesn't like head gives us the first 10 by default we can specify the first 20 lines the first 30 lines tail gives us the last 10 the last 20. cat gives us the entire file so i've got this song of myself file very long if i cat song of myself it prints out the entire thing there's a lot here you know i'm scrolling for a very very long time all right so that is something we can do but that's yeah sometimes i'll use that if i want to just check on you know what's in that file i don't remember what's it look like we can do that but there's a lot more we can do with cat as well remember the name cat comes from concatenate so we can actually provide more than one file name and it will print the contents of both of those or three or four however many files it will print all their contents together so on my desktop i have quite a few messy files here i've got one called letters so i'm just going to cat letters all right it just contains letters and then i have this one called words i'm going to cat words and there we are okay so i can cut them individually or i can cut them together just by separating them with a space and now we end up with one output again not very exciting but two different files for red and then concatenated together in this output smushed together so that doesn't seem that useful but where it gets more exciting if exciting to stretch but where it gets more sometimes useful is that we can then redirect that output to another file so i could make one file that is a combination of two or three or four other files or it doesn't have to stop at four i just don't want to keep saying numbers but we can take multiple files concatenate them together and take that output and save it into another file so here's an example of that i have three different shopping lists one for the butcher we can just take a look at that i need ground pork ground beef sausage skirt steak i've got one for the feed store for my animals i need to get chicken scratch chicken feed oyster shells i've got one for groceries milk eggs butter onions tomatoes all right so i want a master list still contrived but you know i want one list that i can take with me so i can concatenate all of them butcher feed store groceries and then i will take that first we can just see what it looks like here's the concatenated output but instead of printing it let's redirect it into a file we'll call it everything if i can spell everything okay and now we have a new file called everything let's take a look at it it contains the results of those three other files being concatenated so that can be useful right we can take multiple things stuff them together and put it in another file but as we'll see later we can also actually take multiple things concatenate them and send them to other commands not just send them to a file so we'll cover that later on when we talk about piping one last thing with cat that i'll mention is that we can use the dash n option to get line numbers so maybe not that useful here but if i go back with that super long song of myself poem if i do cat dash n song of myself pretend this is a file with you know some code and there's a problem in here i can find that line number and then tell my coworker hey it's on 1741. you would probably be in an editor but we'll also learn about some other commands like find and grep which allow us to search for things so we'll get there there are valid use cases for for wanting those line numbers to be available all right the next command we'll look at is called less less less is used to read the contents of files it gives us a nice interactive ui where we can scroll and it's just a lot easier to work with a file compared to looking at the contents that is printed out from cat so just as a reminder here i've got this super long file song of myself if i use cat it prints out the entire thing and i guess that's sometimes useful but in a super long file i've got a scroll forever yes i could use head or tail just to get you know the the very top or the very bottom of the file but this is a lot of scrolling so if i wanted to actually go through this and i wanted to read the entire poem or look at a massive log file from scratch all the way at the beginning i could use cat scroll to the beginning and now just use a terminal and scroll down but it's not that easy it's not a great interface but if i use less followed by the file name so any file name but a long one is ideal because you'll be able to see how useful it is less song of myself.txt now my screen changes it didn't just print out the entire text to my terminal window instead it opens up the less program where i see a page and then i can scroll down with arrow keys just like the man pages so if you remember with the man pages if we open up man some command our prompts goes away we're transported to a new world of man pages and we can scroll i can hit space to go one page at a time and there's quite a bit more we can do in less but first most importantly to get out of here cue just like the man pages so my my history my terminal is not cluttered with thousands of lines of text so that's one benefit but also of course i can read things and scroll up my own pace i can also do things like search so if i want to search in here my cursor is right here it's a little hard to see if i type a forward slash and then i type some phrase or something i'm looking for i don't know let's look for green i don't know if green is in here somewhere but let's see i'm going to type green and hit enter and there we go this is the first match the sniff of green leaves and dry leaves so that's one thing we can do by the way i mentioned you can scroll one page at a time down by hitting the space bar we can scroll up one page at a time by hitting b so b in space we can also use arrow keys up and down we can jump to the end of the file i believe by hitting g capital g yeah we need shift g it takes me to the very end of the file and then lowercase g takes me to the start so here's the very beginning uppercase g takes me to the end and as always q is how i can quit so this is great to work with long files it's just easier to navigate you can search for things unlike if you're just looking at an entire file using cats it's just all vomited on your screen all at once so that's less the next command we'll learn is called echo echo uh it's very simple it does one thing it takes whatever value whatever argument we pass it and it echoes it back it just prints it back it outputs it so that might not seem useful let's get out of here let's clear if i just echo hi well it just echoes high back to me it prints it out so yeah it is not that useful when you just run it like that but one really useful trick is to use echo with a piece of text and then redirect the output to a file so this is a great really fast way of making a new file that contains some little bit of text without even having to open up the file so if i needed to make some config file and it needs to contain i'm just making this up but it needs to contain something like you know username equals cult something like that it needs to have one line in that file well i could make an empty file i could open it up and then i could put this in there save it close the file or i can echo it and then redirect to a file that doesn't even exist yet so that file let's just call it config dots we'll just do txt so it's going to take this argument it's going to echo it back but instead of printing it to the terminal i'm redirecting it to a file that doesn't even exist it will make that file and put this piece of text in it so now we have a config file and if we use cat to look at it there we are it contains that line and i can also you know if i needed to add something to it i can do the same thing where i can append with two greater than signs so if i needed some other config in there i don't know how about key equals that that is now appended into our config file if we take a look there we are it has two lines of text in it so this is not how i would recommend editing files but if you need to make something quickly or just add a small thing to a file quickly this is a really great way of doing it echo some piece of text redirect it into a file so to summarize echo on its own some piece of text it echoes it back to you on the terminal it just prints it out but we can also redirect that and it's a great way to add some text to a file in like two seconds so the next command we'll cover is called wc it's short for word count and it does just that it counts the words in some input for now it's going to be a file but we can actually provide other inputs and it does more than just word count it actually will count the bytes and the lines so if you remember i have this very long song of myself file here i want to know how many lines are in it well if i run wc and then song of myself it tells me well there's three different values here the first one is a number of lines 1757 lines the next one is the number of words and then third this little chunk here uh that is the number of bytes and then the name of the file so if we look at the man page for wc you'll see that it tells us the order again how many lines how many words and how many bytes we can also say actually i just want the lines so we can use dash l or i just want the number of characters dash m or the number of words dash w so let's see how many uh let's see how many lines i don't want all that other stuff and we're gonna do wcl song of myself.txt there we are i want to know how many uh how many words dash w song of myself we get fifteen thousand seven six seven okay so that's one way of using word count but i'm also introducing a new concept right now something called piping so we're directly passing right now a file to word count but with piping we can do something very different we can actually take the output of one command and pass it as the input to a second command so we saw how to take the output of some command like ls and redirect it to some file this is taking output and then putting it in a file but what i'm talking about is taking output of a command and passing it to a second command so what if i wanted to know how many files are in here so if i do lsl this is a massive chunk of text right i can take this and i could i guess take it redirect it to a file and count the lines in that file or i can use piping so it's called piping because we use the pipe character located above the return key on the right side of my keyboard i take the first command lsl and then instead of just printing out the output i want to pipe it to the word count command wc and take a look at that we see the number of lines new line characters number of uh geez words and the number of bytes uh so what we just did was take lsl i could even do let's do al that will include hidden files if i have any here there's just two of them but we have 64 lines now so that's just one quick example but we can also do things like combine two different files using cat and then pipe that to word count and word count is not the only command we can pipe to i'm just introducing that one first uh i could even do date pipe that to word count if i wanted to know how many bytes are in there or how many uh words it's one line i don't know if i'd really want to do that but we definitely can but i have a couple of let's go actually to my shopping once again and i have if you remember this butcher file and feed store well actually let's do groceries so i have butcher and groceries i want to know how many things i have to buy so i'm going to combine those two groceries and butcher with cat so cat groceries and butcher and remember on its own it just smushes them together and prints it out but i'm not going to redirect it to a file i'm going to pipe it to word count and there we go if i just want the lines that will tell me tell me how many items right one item per line and it says nine and that seems correct right one two three four five six seven eight nine different things that i have to buy all right so that's an intro to piping it will pop up again and again as i introduce some other commands that are really more useful when you pipe things to them one more thing i just i'll show quickly i can combine piping and redirection if for some reason i wanted to take this output and then redirect it to a file called number.txt i can do that so this will run first concatenate those two files and then we're taking that information and piping it to the word count command which is just going to give us a number of lines in this case nine and then instead of printing that out like we did here redirect it to a file called number.txt there it is number.txt and if we look inside well it just has the number nine so that's a quick intro to piping next up we'll see some other commands we can pipe to the next command we'll talk about is sort so sort does what it sounds like it sorts information we'll start by just sorting a text file so i have this why don't we start with our everything file so let's take a look at that okay so it has a bunch of different items and i'm going to sort them with sort everything.txt now this is not going to change the file itself this is simply sorting the output it's going to sort what it gets from this file it will read it in sort it and print out the sorted information but it does not store it in that file and you'll see we end up with an alphabetical sort by default so butter chicken feed chicken scratch eggs ground beef ground pork it is case sensitive so an uppercase s comes before a lowercase s and you can actually tell it to not be case sensitive i believe if we look at man sort there is an option in here for where is that ignore case dash f um but this is great this is you know sorting a file alphabetically but just to reiterate it is not changing that everything file it is unsorted now i could redirect of course so i can do this sort everything and then put it into a file called sorted everything and now if we look at that sorted everything file it is indeed sorted we also can tell it to sort numerically so if i had a file that had numbers in it okay i have a file called nums i've just created oop nums it just contains five numbers here if i try and just sort nums as is it doesn't do a numeric sort it does well it sort of does it compares you know the first digit of each and a two so these both have a two that means i guess they come before 54 because that starts with a five but it's not an actual numeric sort but we have the dash n option that will now sort things numerically and there are other sorts that we have at our disposal we can reverse things with the dash r option so let's do that dash n r you can see we now have 999 first all the way down to the number two another option that can be useful has to do with duplicate values so why don't i echo 999 and i'll append that into my nums file i'll do that a couple of times all right so now when i recall my sorts for nums there's a bunch of those 999s in there if i want to only get the unique values i can use the dash u option for unique so let's do dash n u and now i only get the unique numbers sorted alright so that sorts we can concatenate and pipe information to sort we can do all sorts of things right it doesn't have to be from a file so i'll just show one more example of that let's take the butcher file and the what's another file i have groceries okay and if i want to sort those two i can pipe that oops i don't know if you can hear my cat there i can pipe it to sort and there we are it sorts what it received as its input so it wasn't just one file we took one command cat that gets an output we pipe it over to sort so there we go i could also do things like if i wanted to know how many unique numbers are in this numbers file right nums i could sort nums but i only want the unique so dash u n sort whoops not sort nums and then let's imagine there was like hundreds of them instead of what five i could pipe that over to good old word count and ask for how many lines so take this nums file only sort the unique value sort them numerically but instead of printing the value or the output to the terminal pipe it over to word count where we count the number of lines and the grand total is 5. so this just is to show you that you know we can take sorts and pipe its output to something we can redirect its output to a file or we can take some other command like cats and concatenate two files and then pipe the output to sort so that's sort next up we'll talk about the unique un iq command now the unique command is generally at least when i use it used in conjunction with the sort command so unique is going to let's just take a look at the man page first it reports or omits repeated lines so anytime you have a data set or a file that contains repeated information on different lines and you're trying to either consolidate it or ignore repeated lines we can use the unique command so just show an example i have a file here that i've just made called fave flavors it was uh let's say we run an ice cream shop we asked our our customers what their favorite flavor of ice cream was and we got a bunch of different outputs right chocolate vanilla strawberry a bunch of vanilla's rocky road cookies and cream but there's a lot of duplicated values now if i just run unique on this command or on this file fave flavors well that's weird it really doesn't seem like it works because i see a lot of duplicated values it seems like if it only gives us unique values or you know it removes duplicates we shouldn't see cookies and cream twice we shouldn't see vanilla twice or way more than twice well what it does is it doesn't actually just remove all duplicated values instead it removes adjacent duplicated values and that might seem weird right so we've got strawberry let's take a look here chocolate vanilla strawberry and then two vanillas well if we look at the output from unique we have chocolate vanilla strawberry one vanilla down here we had strawberry three times in a row over here it shows up once in a row when we use unique so it is going to look at one line and then the line after it and if it's the same then it's only going to print out one of those so generally i use this in conjunction with sort so if i sort fave flavors and then pipe that to let me just remind you what that looks like it's alphabetical so now they're all chunked together right cooking cream rocky road strawberry it's all together and then i can pipe that to unique and now we just get the unique values because they were all in a row and the way that unique works is it's only going to take one uh anytime there's duplicates in a row but you might be thinking didn't we just see there's a dash u option and indeed there is a dash view option for sort it kind of makes this obsolete but there's additional behavior to the unique command that can make it useful for example if i do man unique there's an option which is dash d which will only print out the duplicates so i only want the duplicates uh let's try that let's do well unfortunately they're all going to be duplicates aren't they if i do this dash d every single one of these flavors appears more than once but if i echo how about mint into fave flavors and let's do one more flavor uh how about uh pistachio or um how about rainbow sherbet okay so now we have two values that are not unique so if i remove that dash d here is all of the sorted unique flavors so we see a list of them but with dash d now i only want the ones that are duplicated so we no longer have rainbow sherbet and uh mint side note i've always said sherbet my entire life but uh i don't know i was corrected on sherbet so now i'm selfconscious some guess i'm sticking with sherbet um so there's another option instead of dash d we can use the dash u option to display nonduplicate lines so the lines that only appear once dash u and now we can see oh these are the flavors that uh only one person liked in our case we've got mint and rainbow sherbet everything else is duplicated so we don't see it showing up and then an even fancier option is that we can get a count of how many times each line appears with dash c so why don't i do that here i'm going to do sort all the flavors dot txt or fave flavors and then pipe that to unique and then dash c will give me a count and we can see all right there's five chocolates six vanillas one rainbow sherbet and what's extra fun is that we can actually take the output instead of just printing it out i can resort that numerically if i wanted to get a ranked list because they all start with a number i can do dash or sort dash n so sort all the contents of that file alphabetically which groups them all together then take that output and pass it to unique which is going to weed out all duplicated lines that are adjacent and give us a count for how many times each one appears but instead of printing that out pipe that to the sort command again where we will sort by number at the beginning and then we could even reverse it with r and we can see the most popular flavor vanilla so boring all the way down to the least popular mint which is this is not accurate i think mint is actually quite popular but anyway that is using piping along with the unique commands kind of a lot to take in so if you just need to sort the unique values in a file you can do the dash u option but if you want a count of how many times uh different lines appear if you want to weed out duplicated values or you only want an output that contains the values that are duplicated you can use the unique command now if you remember when i introduced the echo command if you happen to be somebody watching this entire thing from start to finish uh you may recall at least when i introduced echo i talked about expansions and how later on i would cover this thing called expansions well that's what i want to talk about now what i'm about to show you is not specific to the echo command but we'll be using the echo command to help illustrate uh how these expansions work so when i say expansion what i mean is that there are special characters and special syntax that we can use with various commands that the shell will interpret and expand into some other value and probably the simplest example is actually something we've seen before the tilde tilde expansion if i just echo the character tilde tilde has a special meaning i'll zoom in a little bit as we've talked about it is a shortcut that refers to our home or my current user's home directory so here tilde is slash user slash cold steel now when we echo it what we're actually doing is asking the shell uh you know print out tilde but it's not the character tilde right if it's in quotes then we get the tilde printed out what it's doing instead is it's it's expanding that character it has a special meaning before it even runs the echo command it's going to replace that or expand it to be this and that's what it echoes out so when we do things like cd tilde again the shell steps in and says oh i know that let me expand that and it turns it into slash user slash cold steel and that is where we see d2 so icd to tilde it's the same end result all right so there's other types of expansion though including dollar sign environment variable expansions so in our shell there's a bunch of environment variables available some of the more common ones are things like dollar sign path in all caps if i echo that you'll see that it's been replaced with a very long yours may be much longer actually than this it's not too bad if i run it over here on ubuntu i think i have quite a long path here nah not too bad either so it takes this and it turns it into or it expands it to the value of that variable now if you don't know much about environment variables don't worry about it but here's one more example user that's an environment variable for the current username okay now a more useful thing is path name expansion so path name expansion allows me to use special syntax special characters to match different path names so we've actually seen this before we just haven't called it path name expansion i'm in a directory right now well i'm in my home directory aren't i so there's a whole bunch of stuff here different files and folders um why don't i do this over on ubuntu because i have some more files to work with okay so when i type echo i'm just going to use echo again because it's an easy way to see what the shell is doing for us so it's just going to print back the expanded version of the star character so if i wrap the star character in quotes that's what we actually get echoed back but if i don't have those quotes and i simply echo star what i see is a list of every path name in this current folder so every folder every file name like you know pokemon.txt word.txt and then different folders like cleanup and copies i'm just matching everything so the star means every path here but i can narrow it down and i can say star dot txt and we've seen this sort of thing before again this is going to then be replaced with matching paths so this was replaced with all of that now if i do star.txt it's only going to match something that starts with anything but ends in exactly dot txt okay and so here we are we see our matches that end with txt now echoing them may not be that useful but i can do things like lsl star dot txt i want to print out long listing information about all text files in here and there we go i only see txt files and all their information so we also have another character we can use to match path names which is the dollar sign the dollar sign the uh question mark uh a question mark will match any single character so this would match any three characters in a row this would match any four characters in a row so let me show you an example if i echo and i'll do anything so a star matches anything and then a dots and then any two characters so this looks weird but it's saying anything that must then end with a dot and then exactly two characters i don't care what those characters are but two characters and oh we don't really match anything do we in this folder i guess we don't have any all right well let's try three characters and now we're just matching all our txt files and zip files it's not that exciting but just as an example if i were to touch app.py and you know app dot js and main.js all right and then i ran our original version here which is anything with a dots and then exactly two characters now we're matching those dot js and dot py extensions so i'm echoing them again that's not what we would normally do we might do something like ls or we could even do rm if i want to remove all those files this is kind of very dangerous and i don't know if i would recommend this but just as an example i could remove those files that have two character extensions that would be a very bizarre thing to want to do just all two character extensions but i can rm star dot question mark question mark so remove all files in here that end with two character extensions and i have it set up again automatically to ask me prompting me if i want to so i will say yes i'll remove all of them remove and remove all right so that's the basics of path name expansion next up we have some other types of expansion so we'll start by talking about curly brace expansion again i'll use echo when the shell encounters curly braces and i provide a comma separated list of values so i could do something like let's just do letters to start a b and c okay if i just echo a b and c it's not going to be very exciting but if i add something before or after let's do abc dot txt okay what this is going to do is create every combination of a followed by txt or dot txt and then b and then c and that's what we get a dot txt b dot txt and c dot txt so whatever these values are separated by commas i can create i can make files with them if i wanted to the shell is going to take this and expand it first so if i did something like touch and then how about um i did app dot and then in curly braces js html css and py if i wanted to do that i'll run it with echo first so you can see what it would make me app.js app.html app.css app.py and then if i wanted to actually create that i could use touch and that will make me all those files so now there's a bunch of stuff here why don't we narrow it down well only ls things that end in two characters or how about app dot and then question mark question mark question mark or how about a star all right and so we can see what we created we can also do numbers and provide ranges so if i echo 1.99 this is going to be expanded to the numbers between integers between 1 and 99. so i could create a bunch of files how about day and then let's do one to 365 if i was keeping some sort of journal i'm not making files right now i'm just echoing it but the shell takes this it expands it into this massive list of different numbers or rather different names day 94 day 95 and so on and then i'm echoing it but i could just as easily touch or make directory and create 365 different directories in a single line now there are other types of expansion uh we're not going to spend time talking about them but basically the concept of expansion is that the shell intervenes before a command runs expands some smaller thing usually it's small into a larger piece of text and then passes that to some command and we can use that to our advantage to craft short commands that results in creating hundreds of files or deleting a whole bunch of stuff or just matching a bunch of things by defining a pattern like we saw if we want to match you know anything that how about starts with the letter f and then ends in anything else i'm just echoing it and this is just echoing the paths that match this pattern in my current directory but then i could delete them all if for some reason i didn't want them to start with an f i could delete them all or i could move them all i could copy them there's a whole bunch of things we can do next up we'll cover the diff command which we can use to find the differences between two different files if you've ever used git you probably have seen the get diff command we will actually see what it relies on behind the scenes to generate a diff but first let's make two files or at least one file that is slightly different than another so i have this ice cream flavor five you know fave flavors file i'm going to copy it so copy fave flavors and i'm going to make another file called fave flavors 2 dot txt it's not very original all right so now we have two of them and if i compare the two with diff at the moment they are identical there's no difference so let's change something in fave flavors two let's echo another thing in there how about what's another flavor well let's just do mint again and i'll append that not with a single greater than sign two i want to append to fave flavors two dot txt okay so now that exists at the end of that file just that one extra addition of mint so if i rerun my diff between those two files this is what it tells me 24a25 mint now we could spend a lot of time talking about how this works but to read this change command here what it's telling us is that on the first file line 24 on the second file line 25 was added so if we change the direction if we instead compared fave flavors to to flav fave flavors just on its own now the output says line 25 on the first file line 24 and the second file was i don't know if the d stands for deleted i believe so you know appended added deleted we can have multiple diffs too in a file just if i quickly change something in how about in fave flavors two so let's open that up i'm gonna change something on line three i'm gonna do strawberry and cream all right i'm going to save that file and close it now if i do my diff between fave flavors and fave flavors two we see we get two different diffs right two different things that were changed on line three of both files it was changed from strawberry to strawberry and cream and then line 24 of the first file line 25 of the second file we added mint anyway uh this is one way of using diff but what's probably more common uh and more useful is to see both files side by side with dash y so that's one option if we pass in dash y uh although in this case um way zoomed in it's kind of disastrous isn't it on this screen size because i've tried to make things readable but if my font were quite small you would see it side by side and then lastly we have the dash u option which is what git uses behind the scenes to display its own diffs and this just gives us a different output if we look at mandif again and we go down to dash u output the num lines of unified context so it gives us some context around each change so let's do that again instead of dash y dash u and what we see here are the files that we're comparing and then context is saying from line one to six we can see what was added or removed uh and then same thing here we can see what was added so this is maybe familiar if you use git and that's the basics of the diff command next up we'll talk about the find command so find helps you find files or folders matching some file pattern but there's quite a bit to it and we could have a 20 minute video at least devoted just to the find command so i'm going to just try and hit the highlights here the first thing you should know is that we can find files and folders by a bunch of different criteria we can find based off of let's open up the man page based off of the name of the file the modification time uh the file size the type if it's a file or a directory or a sim link there are probably many others that i'm forgetting at the moment and i'm just scrolling through the man page here it's quite long as you can see so again we're just going to hit the some of the highlights here okay so the first thing is if we want to find files or directories we need to provide a location to look inside of so find inside of in this case dot meaning the current folder or find in the desktop or find in my animals folder and then we provide some sort of criteria something to search against in this case dash name and then some sort of name that we want to find so i'm just going to search on my desktop i have a bunch of files but find will search recursively so if i do a find dot and nothing else just find dot it is going to find every single file nested somewhere inside my desktop so there's a lot of stuff going on here if i scroll i mean you can see they're all nested they're not actually on the desktop they're nested multiple levels deep uh we didn't specify any way of narrowing what we're looking for but now let's try let's find everything that has in its name and then instead of quotes uh let's search for anything that has hm how about the number seven in it anywhere on my desktop or any folders nested in the desktop or folders nested in those folders and so on really nothing why didn't we find anything aren't there at least there's one file here that has a 7 in its name and the answer here is that it's looking for an exact match a file that has and it is called seven if i made a file called seven right here and i reran it it would work we found that file but what i want to do is find any file on my desktop or nested somewhere on the desktop that has the number 7 in it so this is where the special wildcard characters of a star in our case will come in a star is just going to refer to anything and then a 7 and then anything else optionally before or after so if i do this we now get a bunch of matches a lot of pokemon that i have for a different video i made that have a seven in their name somewhere but i'm sure there's some nonpokemon here we go morning day 27 nested very deep inside of this folder or here's you know file 257 so we found files that contain seven in their name so if i wanted to find all files for a particular type like all python files dot py i would put a star which again means anything followed by dot p y and it looks like there's just one let's try a dot j s we've got a couple of js files nested in my desktop now remember dots is where i'm searching inside of and that's just my current location but i could instead say i want you to search only within the stuff folder if i can spell it correctly it's not going to find anything but maybe i'll find txt files and there we go we only find txt files inside of stuff so we can also find by type i can find directories or files or sim links so why don't i do a find on my desktop once again and all that i want here are any entries anything that it finds where type is d for directory now i forgot to specify where to search we'll search in our current directory and i get a list uh these are all directories there's a lot here but no files if you notice none of the actual files are present no dot txt or js or whatever it's just the directories if i did type f i only get the files as you can see here these are all of course they don't have extensions so you can't tell but you have to trust me they are all files for each pokemon in this case or whatever you're seeing printed out these are all files there are no directories that i've been found now there's directories referenced in the path to each file but that's not the same thing as the actual directories being returned as a result here so we can combine them too maybe i want to find directories only so i'm going to do dash type is d and name as uh i don't know how about uh an uppercase um uppercase e we'll see if we find anything that contains an uppercase e and we do so only directories somewhere on the desktop where in their name they have an uppercase e so here we go uppercase e uppercase these are all directories now i can also do a case insensitive version if i do i name for insensitive now i'm finding everything that has an e it doesn't actually matter if it's uppercase or lowercase so we see things like right there there's an e in that directory's name there's an uppercase e and a lowercase e okay we can also do fancy logical things like use the or operator so dash or so let's give it a shot let's find uh anything that has in its name so in our current location dash name it starts with the letter e so actually sure let's do e so e and then followed by anything now remember if we put a star there that means anything can come before the e but what i want is it must begin with the letter in this case uppercase e so we get a bunch of the e pokemon and there's some others edgar ethel elvis instead of the chickens directory now if i also wanted to say or name starts with how about f star and now i have fall fungus as well as espeon and you know files that and directories that start with an f or an e uppercase only because i didn't do i name so that's just a taste of using the or operator there's also a not operator we can do things like search by file size how many bytes how many megabytes greater than something so for example to find files that are larger than 100 kilobytes but smaller than one megabyte we could run this right here so find where type is file f and size is plus 100k greater than 100k and size is minus one m one megabyte so let's try an example let's do uh find where type is file and size is greater than 100 kilobytes and there we are we get a list of files that are greater than 100 kilobytes if i left that size off we get way way more files we can also do things around time so if we want to find files that were edited more than three days ago we would do dash m time which is modified time plus three and then we get to the last little bit that i'm going to mention around find which is this weird looking thing dash exec this is an option we can provide where we then specify a command that we want find to run on each found result so this example is going to find all files in the current directory right type is file and on each one it is going to cat that file out it prints its contents now i'm not going to run that because on my desktop i've got a million files that it will print out but let's talk about this quickly so dash exec is just the option saying hey i'm going to give you a command i want you to run with each match and then here's the command the entire command we're providing we do have to terminate it with this backslash and then a semicolon that is how the terminal knows where that command ends and then this the curly braces opening and closing is going to be replaced it's a placeholder it will be replaced with each found result so let's try an example let me recall this line where we found files that were larger than 100 kilobytes we could verify the size of files one way at least is with dash l ls l rather right and we can see the file size here and there's a lot of them there's a couple that are larger but most of them are pretty small dash l is going to give us that long listing so what i want to try is taking these files that we find that are larger than 100 100 kilobytes and then telling find to then call lsl and then curly braces and then we need our backslash semicolon and of course my font is quite large here but what you can see is that for each one of those results if i just run find without dash exec these are the results right gg dot i think that's great gatsby.txt uh pokemon exercise nano exercise whatever these different files are they're all here but we actually executed lsl with each one and we can see that file size is large much much larger than the other ones we could do something instead like if we wanted to cat each file out but again there's going to be quite a few things printed out so all files larger than 100 kilobytes dash exec means i want you to then run each match with cat curly braces just concatenate them all oh my goodness that's a lot of stuff that was just printed out a lot of it is kind of messed up but there we are that is the result of executing that cat command with every single one of the found files that matched with our find command all right so there's a lot more to find you can do some really powerful things but that's just a quick intro next up another command that could have its own video for 20 30 minutes at least grep there are many articles many tutorials that are quite long that exist solely to explain all the different options and various ways of using grep so what it does is it helps us find text inside of files so the find command helps us find files right based off of their file name or different attributes but it's not searching in the files grep will search inside of files so the simplest way to use it is to run grip and then tell it some string or some piece of text or something that we're trying to find and then a file to search inside of so let me show you an example here let's clear this screen all this craziness i have this song of myself file here i opened it in less there's a lot of stuff in here and i want to find every time this file i don't know mentions green in it so i can do grep green song of myself.txt and it prints out to me the matches right it highlights them in a different color of every time in this file the word green showed up so we've got green leaves green and violet dusky green pale green eggs quintillion's green there we go we can also ask grep to give us the line numbers with the dash n option so we'll add that in right there dash n and now i'm getting the line numbers so 32 is the first one all the way to line 1026 i can also ask for some context if i use an uppercase c and then i provide an argument a number of lines i want in this case two that will give me two lines before and two lines after each match so let's try that c and then two and here we go so this is one match this is actually the last match on this line we have two lines before and two lines after uh here's another match right we have two lines after two lines before another option we can pass to grep is dash r which is for recursive uh and this is a bit different this will actually tell grep if i do grub dash r and then provide some pattern like chicken it's going to tell it to search recursively in my case right now just in the current directory and all nested subdirectories so instead of just looking inside of one file like hello.txt which doesn't exist now i can look inside of all files at least if i tell it a starting point i think the default is just dot okay so uh what we see here is a bunch of matches one from gg.txt or a couple a couple from sorted everything and everything feedstore.txt website.html greatgatsby.txt so these are all files that were nested somewhere in my desktop and they all contained chicken now uh it is important to note that it is case sensitive so if i did you know uppercase c no matches but i can make it case insensitive with dash i and now i get my matches again now what makes grep really powerful is that it can work with regular expressions which i'm not going to go over right now if you know about regular expressions you know the syntax you can provide regex patterns to grep to search against so you could find all matches of an email pattern or a phone number pattern and that sort of thing okay well i changed my mind i'm going to show a quick example i'm not going to explain any of it because regular expressions is its own crazy topic but what i'm doing here is using a pattern this is a regex that will match email addresses so i'm searching across recursively across in my case the home directory tilde for any matches to this email pattern alright so i didn't type this out myself just to be clear i found an email regex but i'm going to run it and you'll see a bunch of different emails that have been matched being at search.mozilla.org toolkit.mozilla.org toolkit at mozilla again firefox these are all coming from some uh documentation it looks like from firefox here's some other ones anyway the point is we can match these patterns across uh in a file or across our entire machine and there are tons of powerful regular expressions that you can write but we're not going to talk about how that works it's a whole separate topic anyway that's a quick intro to crap next up du disc utility i think that's what it stands for i guess i should verify that would be the logical thing it stands for uh well disk usage no i'm totally wrong i'm pretty sure it's disk usage anyway what we can do with du is find uh the sizes of files and directories on our machine so if i just run du in my current directory wherever i am it's going to give me an output of all the other directories in here and their sizes so you can see you know if i just pick one of these let's find something slightly larger here sure this tar demo folder is 32 kilobytes this wildlife folder is 16. this cleanup directory is 156 kilobytes and so on uh and then down at the very bottom i can see my actual current folder right here is dots is 36 megabytes i can provide a folder to look inside of instead of just my current directory i could say i want to know the pokemon exercise folder what's its size and it's uh let's see 24k we can tell it to give us a different format megabytes or gigabytes using dash g for gigs dash m for megabytes so let's do du we'll do everything here dash m for megabytes uh it's all just one maybe two if i do it on my mac here we may get some more stuff not a whole lot but some of this stuff here's something 410 megabytes here's something that's 25. now you may notice it's not actually giving me uh the unit it's just 1 or 0 or 10. if i use dash h which is for human readable it now is giving me a human readable size so 4k 24k but then also for some of these larger things we get you know gigs 5.7 gigs so this is what i use most of the time if i actually need to read something as a human dash h now here's kind of a nifty thing we can do if i want to find the largest directories on my desktop here i can do d u dash h for human readable okay and i can pipe that to the sort command now we're almost there it is sorting but the way that it's sorting is not exactly correct if you notice here it's doing a sort you know once again based off of the digits so it's saying you know 9.2 m megabytes is somehow smaller than 900 kilobytes so it's putting all the nines together that's that's a start but it's not actually sorting them so sort actually gives us an option if i go to man sort it gives us an option dash h oh where'd you go i lost it here it is human numeric sort so it sorts my numerical value but it takes into account prefix or suffixes like k or m or g so it's for human readable numbers so let's run this again we are going to get a human readable format from du of all the files on my desktop sort them with dash h to make it a human readable sort instead of the default sort and now if we go to the top we get our smallest files the kilobytes and down at the bottom we get our largest files and if i wanted to find the top 10 largest files for example i could then pipe that to tail that would be one option and there we go i'm getting the 10 in this case because that's the default for tail largest or i could reverse with dash r and instead get the head which will be the same thing right i'm now getting the sort is in reverse order and i'm taking the first 10 instead of the last 10. anyway that's an intro to the d u command the next command we'll see a nice and quick one is df not to be confused with du the du command showed us file sizes and folder sizes whereas the df command will tell us information about the mounted file systems how much space they take up and how much free space they have left so i'll just show you very quickly here if i run df with no arguments or options i'm going to see some output here yours will look different the file system so each individual file system and then the amount of size that it has been allocated how much it uses how much is available now this by default on ubuntu is in one kilobyte blocks it's not so easy to read if i switch over and use the dash h option for human readable now we get megabytes and kilobytes and gigs and that sort of thing okay so we can see things like here is this file system udev uh here's where it's mounted uh here's how large how much space it's been allocated and how much it's using uh i'll show you this on my mac as well so let's do that now i have to zoom out quite a bit just so that we can see the columns but what we'll see here is that some file system uh has been allocated up to 3.6 this is actually tip tebites uh not terabytes uh it's let's see it's a 1.1 times so 10 larger than a terabyte and it really doesn't matter the thing is i know this is a four terabyte computer uh the drive here so three point six terabytes makes sense anyway that's how much space it's been allocated but it's only using this file system at least is only using 10 gigs or you know here's another one this is my slash dev disk 1s2 blah blah blah blah and here's where it's mounted it's also has up to 3.6 tbytes to use but actually it's used 2.2 terabytes out of that anyway you may not really need to use this command but i'm just being comprehensive here one thing that can be nice though is if we pass a file or a folder as an argument to df it will tell us more information about the file system that particular file or folder lives on so if i wanted to know you know where's my desktop and how much space is that file system taking up i can do d let me just clear first i can do df h for human readable and then desktop and we can see this is the file system this is you know the capacity of that file system how much is available and so on so that's all there is to df uh and remember du tells us about the actual sizes of individual files and directories df tells us about i don't know if it's disk free or disk file systems or i don't know what the f stands for i was trying to look at the man pages and figure it out but think of it as disk free sure next up the history command now this one can be very useful especially if you have some long long commands you ran i don't know 20 or 500 commands ago and you want to rerun it and not have to type it yourself again or you don't know what it was that is what the history command helps us with so on its own if we just run history let's do it here on my linux machine so i'm going to run history here i'm going to get a bunch of lines as you can see there's a number next to each and then a command that i ran so we can see a history of all the commands that i've run so history was the most recent command before that i had man df and then d u dash m i had clear i had d u d u d u d u uh you know all these different commands um and let's say this is the command i want to rerun this is the grep that will search for regular expressions uh or sorry it searches for emails using an email regular expression across my entire machine i don't want to have to type this myself one option i guess it's just to copy and paste that definitely but there's also something called history expansion where if i have that number and your numbers are going to be different but if i have a number i can take it and simply run exclamation points and then that number 2064 and now it's running that command again it's finding all these matching emails across my machine so just one more example oh geez i need to rerun history and if you prefer you can actually pipe this to less so that command less opens up a program where we can scroll a bit easier we can page through commands one at a time i can find some command like i'm sure this one here that finds things that start with the letter e or f so it's 20 40. i can exit less and just run exclamation point 2040 and now it finds me all the files and directories that have an e or an f uppercase as their first letter another thing you can do is actually combine grep with uh history if you're trying to find some commands you ran a long time ago you know as you probably just saw there's tons of commands here and somewhere in this massive list my history list there was a command i ran and i know that it included the word i don't know cookie but i'm not sure where it is and i want to rerun that well i can run history and then pipe that to grep remember pipe that pipe character allows us to take the output of one command and pass it as input to another so then i can search for cookie and there's quite a few actually surprisingly where there are commands so we're just searching through the text returned from history using grep we found a match five or what six seven different matches and if i want to run one of these i can take that number and exclamation point that number so 1686 this is just going to make me a bunch of files so i even want to do that not really but i've already committed okay so you can see it made me those files i think it was cake and cookie and there's cookie cake is up here somewhere anyway that can be quite useful if you know somewhere in this massive history there was some command and it included some pattern or some some word and that's all you remember well you can use grep to search for it the next command we'll cover is ps so ps is a command that helps us inspect or view the process processes processes running on our computer so if we take a look at man ps process status is what it stands for i didn't actually know that i just always thought of process in my head anyway it's going to display information about currently running processes processes and by default if we just run ps i'm on my mac in this example with no other options or arguments it shows me a list of all the processes started uh by me the current user so uh what we see here we've got uh well first of all the process id we've got the time we've got the actual command you can see i've got a bunch of bash shells and uh and then really the only somewhat interesting thing i guess would be this python process i have uh i have a python server in a different tab that i've started but just to show an example i'm gonna start a node server in this tab i've got this app.js i'm going to run it with node here's my server it's running i started a new process now if i run ps again we see somewhere there we are that process right there okay so that is a process i started and we can see it right in this list it has an id and in a moment we'll also learn how we can kill a process where that id can come in handy but there's more to this command we can also view a list of processes initiated by anyone on our machine basically all the processes not just the ones that are user initiated by me so all processes to do that p s a x so this is a pretty common one v s a x we're going to see a lot more going on here so we still have you know that node server i started up we've got our bash instances and then a whole bunch of system stuff look at all these processes now you will see they get cut off here so if they don't wrap over to the next line i can't scroll it just gets cut off so there's a way around that it's a very weird option if we add on two w's a x w w now you'll see that they wrap around so i've got my short processes that i initiated here but then some of these are quite long like this google chrome helper renderer i mean it goes all the way down to what about there i think no actually here i mean that that's very long but it does wrap over instead of being cut off so something that can be very helpful is to combine grep with the ps command so that you can find some process and generally when you're trying to find a process at least when i'm trying to find something i actually might be trying to kill it which is again a command we'll learn shortly so there's this massive list and somewhere in here i do think i have visual studio code open but i don't know what its process id is that's this first column here i could search though so i can recall that command and then pipe it to grep and let's just look for visual to start alright well there's quite a few of those how about visual studio okay so here are all the matches for the visual studio code processes quite a few still wow all right didn't narrow it down all that much but here this is the one we'd probably want to kill the visual studio code.app now i wouldn't actually kill visual studio code this way you can just quit it or force quit it but when i cover kill just in a moment you'll see that there are some situations where you would need to do this you actually would need to find out the process id all right so that's a quick intro to ps there's a lot more to it as you can see there's some options we didn't really cover any of these you can filter processes by who they belong to or who started them you can change the display format you can add more information to be displayed anyway there's a lot more you can do but the basic concept is that it displays information about the processes running on your machine the next command we'll take a look at is top top i actually don't know what that stands for does it tell us not really it says display and update sorted information about processes i think it comes from the fact that it will show us the top most memory intensive processes or the top most cpu intensive processes so what it does if we just run top it's going to open up sort of a different screen we don't see our prompt anymore what we see now is a little dashboard that shows us information by default of the top that must be where it comes from the top most uh cpu intensive processes so you can see over here the command so i've got screenflow that's what i'm using to record this video i've got uh some core audio terminal the top command itself they each have a process id we can see a bunch of other information the memory that they're taking up the cpu percentage and we can also sort instead by memory so if i rerun this it's dash o m e m for memory and you'll see now this is highlighted and we can see they are sorted in order of how much memory these processes take up processes so chrome unsurprisingly is up top and then i've got uh these are i'm using parallels for my virtual machines i have windows running over here and then i've got uh linux running over here so that's what you see there i've got chrome again uh pdf editor the screenflow um anyway it doesn't really matter but what you'll see is different but we can sort things by the amount of memory they take up and we can see that process id which is useful when we want to kill something later on uh you need to reference that process id all right so that's top to get out of here type q that's the easiest way i think you can also get out with control c most likely yeah i just use q the next command we'll cover is kill kill we use this command to kill programs but it's actually a little bit more complicated than that it's not just a matter of saying shut this thing down or kill it there are a whole bunch of different different types of signals that we can send when we run the kill program so there's actually a lot of different signals and it can be very overwhelming and confusing if you try and understand them all i'll just quickly show you here if we run the kill command with dash l it's not going to kill anything it instead will list the different signals that we can send so there's things uh actually to make this a bit easier why don't we pipe that to less so i can scroll through it all right so we've got things like sig int and sig il and sig kill sig bus sig term sig charm is actually a pretty common one it's terminate we've got say kill signal kill let's see there's a whole bunch of these the vast vast majority i've never ever had to use and they all are supposed to be different they are supposed to do different things but what's confusing is that it's actually up to the specific program that you're trying to kill it's up to that program source code to handle these different signals okay so let's talk about some of the most common signals and the basic syntax essentially the way that we kill something is by using the process id we saw how we can use commands like ps and top to find a process id and then we specify a signal so we can specify a signal using the long form a word so hup that's a common one means hang up we can send you know term to terminate that's the default but what i prefer to do and what a lot of people do is instead you can use a number so as we saw here there's a number corresponding to each one of these signals so if i go back as i said term is a common one the number there is 15. kill is nine so we could send that signal too all right so if you're wondering what does this all mean when would i use one versus the other the way that i think about it um is that in general i try and use 15 first this is the gentlest way to quit something or to stop a process think about with the graphical user interface the different ways of of quitting or of shutting something down one option is to uh just quit your application and save your changes another is to quit and click don't save another option is to force quit the entire application another option is to unplug your computer these all are different ways of of quitting or shutting down a piece of software and that's kind of a silly version uh but the idea is that there are these different signals so 15 or sig term is a gentler way to quit it basically the idea is that your program that you're quitting or killing would have time to tie up any loose ends save any necessary state whereas on the complete other end of the spectrum we have nine which is what a lot of people use so a lot of the tutorials and docs you'll see just says to use nine which is the most brutal way of just shutting everything down and basically just force quitting a program and then there's a whole bunch of stuff in between but i like to try and start with 15 that allows things to shut down how they would normally and if that doesn't work then we use 9 which is just pulling the plug on the life support for that program all right so let's see how it works so just like a burgeoning serial killer we need to find our first thing to kill so fortunately i have a couple of node processes that i want to stop i want to kill if i do ps a here i have a server running uh two actual node servers uh here's the process id if we'll just take that first one and i wanna kill it so i'm gonna copy that id and it turns out that you know i can't stop this any other way normally you start a server and then you can stop it with control c or something but i've lost that window i don't have access to just type control c to quit the server so i need to kill it this way okay so i have the process id now the syntax is kill and then i can provide either a number like if i'm doing nine that is the brutal way of killing something that's the the just immediately kill we can provide the name kill or even the full name sig kill but i'm going to start with the default so if i just kill and then i put the process id in there this will send a term terminate signal that's the gentler way first that's the default so this is a gentle way that gives it time to close up shop and save its state if needed so if i try that i don't get any feedback and if i do psa again it's still there so it didn't seem like it worked just give it a couple of seconds sometimes we will just double check come back nope it's not working so now it's time for more aggressive action we're going to provide a signal and remember we can list all those signals if i do kill dash l this isn't that helpful to be honest uh it i mean it gives us a list but what does this mean what i generally stick with and by far the most common if you are gonna pass one through is nine but remember that's a brutal one nine is the kill signal and that's the one that just pulls the plug so we can pass that in kill let me just clear dash nine and why didn't i just show you it is here right there's that process kill dash nine and then the process id okay once again no feedback whatsoever psa and now it's gone now we just have this other node server running okay so that's the basics of the kill command i know it can be a little overwhelming but the idea is that you provide some signal and then a process id and that signal will be sent to some usually kill or terminate or do something to end that process next up in our killing arsenal is the kill all command so kill all is different from the kill command in that we actually can provide a name instead of a process id we can provide the name of a program that we want to kill and if we have multiple it will kill them all uh so if i happened just maybe happen to have multiple node servers running once again i actually just have them here so here's one and here's the other um i could just you know ctrl c and quit them nice and easy but let's just say i can't uh so i want to kill both of them instead of doing the process ids and all of this i can just do kill all and then provide a signal just like before with regular kill i can do kill or sig kill or nine and this is the most violent way of killing something kill all dash nine and then node so that is the name of the program i wanna kill once again no feedback unfortunately but let's see what happens well i don't see any node processes here and if i go to my terminal windows oh killed and killed so that is the basic use of the kill all command it doesn't require process id it's definitely less precise generally i use kill because i can isolate exactly what i want to kill but if i know there's multiple things or i just it's a pain to find the process id then you can use kill all next up we're going to talk about three commands that go together jobs jobs vg for background and fg for foreground so these three work in conjunction and they all have to do with running things in the background and well in the foreground so if we have some command or a program that happens to take a long time for example a command like this where i'm using find in the root directory so on the entire machine find all files that have changed in the last one day 24 hours so there's a lot of system files and a whole bunch of stuff it's going to take a long time if i just run it right now i'm going to get a bunch of permission issues but it's still running if you look down here it's going and it's going to take quite a while to check every single file on my machine so it's running in the foreground right now right meaning i can interact with it it's not well happening in the background um so i can stop it right if i do control c that just stops the whole thing um and there's actually something else i can do if i run control z what i can do is suspend it which kind of puts it in a state of uh well suspension it's not stopping it entirely forever it's not ending it it's pausing it so i'm gonna rerun that and by the way what i'm doing here is finding all those files and then putting it all eventually in a file called all changes or all maybe i should rename that to be all changed files or whatever we're not going to be using this to do anything i just am using it to illustrate that we can have these things that take forever so if i hit control z right now you'll see it says stops right here so this is slightly different than what happened earlier and now if i type the jobs command which is how we can check up on any jobs we have running we see this program is currently stopped okay so let's try doing something else what about uh the top command if you remember this it's going to show me all these different processes on my machine and how much memory and all the stuff they're taking up and i can use control z to stop this as well so ctrl c just gets me out of there if i do control z it actually stops that or pauses it and if i type the jobs command again now we have two jobs in here so two different jobs that are both control z they're both suspended now what i can do is selectively rerun or resume one or both of these jobs in the foreground like what we saw here is in the foreground or i can actually run them in the background so that they they keep going but i won't see all this text i won't see them in my terminal but they'll still be running so this jobs command is just how we check up on jobs see what their state is and they also have an id or a job number and that's important because when we want to selectively resume them we can use those numbers all right so the first command i'm going to show you after jobs is actually fg for foreground so if we run foreground and then we specify a number a job number that job will be resumed so if i want to resume the top command its number is 2. so if i do fg 2 there we go it is now running again and it's in the foreground so i could suspend it with ctrl z or i can just get out of here control c or q if i look at jobs now we just have this one job right this is my find program now i can resume this in the foreground by doing fg and then the number one or because it's the only job i could just type fg so i'm going to do that now and here we are it's resumed again in the foreground it's just going to take forever and maybe we'll get some permission denied stuff let's see if there's any text and if i grow tired of this i want it to run in the background i don't want to see all this taking up my terminal screen i want it in the background not the foreground i can suspend it and go back to jobs it's suspended i can resume it but instead of doing foreground one i can do background one whoops and that will resume it it will be running but i'm not gonna see it running so i'm gonna do that so it gives me a little message saying all right this is running and it's in the background and the way that we know it's in the background there's two ways one this ampersand means something is running in the background two if i type jobs it's telling me right here running so it is running but we don't see it running right we don't see all that text but by using the jobs command we can verify it is indeed running i could bring it back to the foreground if i wanted to you know foreground i don't have to specify one it's the only job and here it is it's in the foreground and that's really all that there is to this we can run things in the foreground in the background and we can use the jobs command to check up on them this is going to just take forever let's see if it ever finished i'm just going to quit or stop it uh let's look at our all changes file yep so it's got a lot of stuff in there and let me just prove this to you one more time that it does work so i'm going to remove that all changes file yep all right so now we no longer have that all changes file if you remember i said the ampersand is one way we can send a job to the background uh so here's another a very stupid program in this context uh sleep is uh just going to stop if i just run sleep five i'll just show you the man page this is a new command it just delays for a number of seconds so five seconds i won't do that long let's do uh sleep two seconds so you'll see nothing happens it's a delay for two seconds and then my prompt comes back so we can use this if we're writing a script or something where we need to stop to wait for uh data to come back or to wait for to make a user feel like something is taking longer than it actually is for better ui there's all these different uses but typically i don't run sleep unless i'm teaching it now i can run this in the background so let's do a long sleep like 50 seconds so if i ran this in the foreground again it's stupid to do this but if i did i'm waiting here for 50 seconds um and i can't do anything else so i'm going to control c and end that but if i run it in the background which i can do by just adding an ampersand so sleep for 50 seconds in the background that's what the ampersand at the end means now i don't see that happening here if i look at jobs it is running though it is a job it's running in the background and then i could bring it back to the foreground if i wanted to just like that and now it's running in the foreground all right uh so i'm just gonna stop it anyway and if i go back to jobs now there's no jobs all right so that's kind of a lot of stuff around jobs and foreground and background let's just recap that so if you have a program you run a command put an ampersand at the end it's going to run in the background if we don't do that but we want it to run in the background i say after the fact let's rerun my find command this long find command i could run it and then suspend it and then decide i want that to run in the background so i could get the job id i happen to know there's only one job but i could get that id and now say go in the background one and now it's running in the background and it will take a while eventually it will complete it's still running as we can see here it has that ampersand it shows us it's happening in the background i don't know how long it's going to take quite a long time but eventually it will finish next up we're going to talk about compressing files we'll first talk about the gzip command which is used to compress files it uses an algorithm called gzip there are multiple different compression algorithms if we take a look at gzip on the man pages it the whole idea is that it reduces the size of files using lenthil ziv coding lz77 so you know compressing is a very complicated um interesting but very complicated area of study and there are quite a few different algorithms but one of the most common on linux at least is gzip so the way that it works is that we have some file hopefully a larger file that we're trying to reduce the size of and we provide it to gzip however i would warn you it's not a huge deal but if you just run gzip with a file name it is going to take that original file compress it and replace the original file so you'll only have the compressed version that ends in gz that's just the extension that it gives it uh if you want to keep the original file you can do two different things this is a slightly clunkier way but the better option in my opinion is to use dash k i don't know if it stands for dash keep that's what i think in my head and that will keep the original file so let me just demonstrate this here i've got a somewhat large text file if i just uh cat it out it's a lot of stuff in there it's the result of running a find command and redirecting the output into this file okay so if i run gzip and i'll do dash k on that file we don't get any output which i'll show you how to correct in just a moment if you want some output but if i type ls we now have this file here all changes.txt so the same name but now it has an additional.gz.gzip extension if i do an lsl we can see the file size difference but actually let's make it human readable with lh for human readable pretty significant reduction in size almost 2 megabytes down to 200 kilobytes now i'm going to remove that so remove all changes.txt and uh i'm going to just show one more oh no i removed the wrong thing well that's annoying all right it's gone i don't have that original file if you remember when i talked about remove when you remove it doesn't go to a temporary recycling bin it is gone but the good news is we do have the zipped file the gzip compressed version and i can unzip that to get my file back so we'll just jump ahead and talk about unzipping so the way that we can do that is to use the dash d option to decompress that is one way of doing it and then there's also a totally separate command called g unzip which you can use which is basically the exact same thing there's a couple more options but it will unzip a gzip compressed file in the same way that gzip dash d will unzip so let's start with uh well why don't we do g unzip all changes.txt.gz all right i type ls and there we are i now have the uncompressed if we do lsl let's do lh 1.8 megabyte version okay so let me just show one more thing when we gzip it again so i have that original i want to keep the original and if i add dash v for verbose it's going to give me information about how much space it reduced or how much it compressed the file all right so i'm going to do gzip dash kv and then my file is all changes.txt and it says it reduced it by almost 87 if we do lh for ls we can see once again 1.8 m 232k so a lot smaller and then just one more time we can use g unzip or we can do gzip dash d for decompress on that file and it's going to ask me if i want to overwrite because what i'm doing here right i kept the original so i would be unzipping a new file with the exact same name do i want to replace it sure okay and now we're back to what we were at before it is well let's do h again 1.8 megabytes so i unzipped and that's kind of all that there is to that one thing that's important to know about gzip is that it will only zip individual files so it won't you know it won't take 10 files and zip them together into a single compressed file we'll see how to do that with a different command but just to show you what happens if i make let's see i have this one file let's make another file whoops just with some very small text in there i'll call this one.txt and let's do it again actually for 2.txt okay so i now have three files in here if i do gzip and i'll do dash k if i want to keep the originals sure g g zip dash k and then we'll do v as well for verbose all changes and then a space one and two i can provide multiple files and it does compress them but it compresses them individually so we end up with three different gzip files okay so it did not combine them it just compressed multiple so that brings us to our next command tar tar tar is a command that we use to create an archive which is basically a grouping of a bunch of files potentially a bunch of files together into a single file and then we can go and compress that file so the name tar is short i think for tape archive an older relic of uh days gone by but anyway the way that it works is it's kind of complicated there's a lot of options the man page if i just go to mantar it's very long lots of options but i'm just going to show you some of the most basic things that you might want to do primarily taking a folder full of a bunch of files and combining them down into a archive and then compressing that so that we have a single file that is compressed that we can then unzip later and then expand back into a whole bunch of files okay so the syntax the basic syntax is to run tar and then a couple of options to create a new archive to smush files together we provide the different files we want to smush together separated by spaces we provide two options c for create and then f is it's the way we provide the file name that we want it to create so if we provide f we must provide the archive name unlike when we zip a single file it can you know gzip can just use the name of that file and append gz but here we're combining files together so we need to provide an end result name okay so i have a simple oops let me go into that folder a simple folder here lslh shows us we've got three files lots of text more text and song of myself.txt i'm going to combine the three of these into a new archive so the way that i do that is tar c for create f is the file option so i provide the file name for the archive i'm going to call it um i don't know archive okay and conventionally these end with dot tar as the extension and then we'll just provide the file so song of myself what was it lots of text more text and then i'll hit enter and this will create a new archive file as you can see right there and this does not mean it's compressed to be clear okay it's just a single file if you look at the file sizes 3.6 megabytes well we had 1.8 1.8 and then 85 kilobytes so we did not lose any size along the way this is not compressed but now i could go and compress this if i wanted to but before we do that let me show you how we can unarchive to extract files from an archive we use the dash x option for extract c was to create x is for extract and if we just do x f and then we need to provide the file name once again this would be the archive we just created this will unarchive it in our current folder but we can also move them so we can provide a directory a destination with dash c and before that we can actually just view what's in the file if we use the dash t option so i can just show you that why don't i move my archive somewhere else let's move um why don't i just make a new directory i'll just call this somewhere and then i'll move my archive into somewhere okay so let's cd into somewhere all right so now i can show that dash t option which we can use to view the files uh that are inside of this archive so we have this let's just say i downloaded it i don't know what's in it well i can do a tar t f archive there we go it says hey there's three files in here i don't have them they're not out of that archive they're still in there all combined down into a single file but i can then extract them i'll just do it in the current directory so to do that it is tar x f and then the archive now i have those three files as you can see here okay and then again i could provide a destination instead if i want to extract them somewhere else with dash uppercase c okay so still no compression the next step is to combine compression gzip is going to be our algorithm along with archiving with tar so we can do this separately just to be clear i could do if i uh just remove lots of text more text and song of myself yes yes yes okay so i have this empty directory except for the tar i can compress that tar as we saw with gzip so gzip and then i'll do dash k to keep the original file if i want to archive.tar and now i have the compressed version okay so it's only 502 kilobytes compared to 3.6 megabytes so let's delete the original tar so rmarchive.tar and now i just have the compressed archive so this is really you know a bunch of files combined down into a single archive then compressed this might be something we download or something we get from some mysterious source now i want to get it back to the original files that are inside of it so i need to uncompress and then i need to unarchive so to uncompress or decompress remember we use gzip and then dash d and then the name of the file so now i just have the regular archive it's much larger right 3.6 megabytes now i need to uh on archive so we need tar. x for extract f so we provide the file which is archive.tar and there we are we get our original stuff back out okay so we can do it in two different steps like we did there make the archive then compress and then uncompress go in the other direction uncompress and then unarchive or we can actually use just the tar command to do it all together the tar command has a special option z for gzip which will also compress and archive with that gzip algorithm at the same time so instead of two separate steps we can do it at once so i'll just show that real quick let's do the same thing let's remove my archive i have my three files i'm going to combine them together with tar i'm going to do create i'm going to zip with gzip and then i'm going to do f so i can provide the file name we'll call this bundle this time dot tar and then space the files i want okay and take a look at what we get i should have probably named it with a dot gz extension but if we look at the bundle.tar it is compressed it's much smaller so you don't have to have that extension but you want that there if somebody else sees it so they know you know this is a gzip file and you need to use g unzip to unzip it so if i want to remove these files so we just have the single archive or the bundle file okay there we are now to unzip it and unarchive i can just run our regular old tar x for extract f provide the file name i don't even have to tell it to use g unzip so let's try it there it is remember it looks like this 500 kilobytes single file i'm going to do atar extract and the file name is bundle.tar and let's see what we get there we are we got the three files back out all right so we saw two ways of doing it first we can create a bundle or create a tarball and then compress that or we can do it all in one go if we have multiple files we want to combine and compress we can provide the dash z option as we saw here to create a gzip compressed file next up we'll talk about a fun command called nano nano nano is actually a text editor you can run directly from your terminal now there are other text editors some that are quite a bit more powerful than nano but they are also quite a bit more complicated to learn and when you're starting out you can really mess things up so things like vim if you've ever heard of vim powerful but really tricky to learn when you're starting out and also could have its own hour long video there actually are courses on just using it so we're not going to go into that but nano is another editor that comes built in that we can use and the reason it's good to know one of these editors at least and there are others there's emacs and the reason it's good to know them is that you can directly very quickly change files or make modifications add things onto files without having to go through the whole process of opening up an external graphical editor you know you can do things quickly so i don't use something like nano as my main editor i like using vs code or something similar but it doesn't mean you shouldn't know how to use it now the basic usage is nano followed by some file name we want to edit so what do we have here i've got a song of myself txt i'm going to open that up with nano so this is a file we've been using quite a bit throughout the course and when i hit enter you'll see that my prompt goes away i'm now in an editor i can use the arrow keys to move and i can actually immediately start editing and this is different if you ever have encountered vim if you start typing you're not actually going to be editing things immediately there's all these different modes and you might be messing things up significantly but i can start typing so if i want you know i can say hello there and i can use my arrow keys left and right just like a regular cursor up and down um and let's just start with that i'll make a little change there all right so i've made this change now i want to save this this is probably the most important part of working with nano is down at the very bottom down here is kind of a little toolbar this is a list of shortcuts the different commands we can use inside of nano and one of the most important ones is this right here control x this is how we can exit so if i do control x right now first it's going to ask me before you go do you want to save or not i'll save that change so i'll hit y if i don't want to save it i'll type n and if i don't want to quit i can do control c okay so i'm going to hit y to save and then it's going to ask me well do you want to keep the same file name do you want to make a new file name uh you know save it somewhere else i'm just going to hit enter and keep the original file so i'm just saving a new version of song of myself instead of a copy all right so it's still there and how do i take a look at the beginning of the file i just want to see if it changed head song of myself there it is we did successfully make a change now there's more that we can do so i'm going to reopen that file in nano and a couple of things first of all if you notice on the right side here uh i'm getting a little angle bracket uh greater than sign that is telling us that there's more text so you can actually turn word wrapping on or line wrapping if you prefer for it to wrap over but i think the default is for it to just scroll as you see there we have different shortcuts down here so if we wanted to search for example to find something in this file i can do control w all right so control w and then i can provide something i want to look for so i want to change the word green in this file so i'm going to type green and i'll hit enter and my cursor shows up right there on the first match of green now i can keep searching again if i do ctrl w and hit enter again see it already remembers green it takes me to the next match so let's just make this all caps and very long green all right uh i'll save and as we saw previously one way of doing that is by quitting and it will prompt me do you want to save blah blah blah but if i don't want to quit and i just want to save my changes i actually do have ctrl s so i just did it it doesn't show up down here there's far more options that don't show up down here i'll show you how to view them in a moment but ctrl s does save to the current file right it's not making a new file name it doesn't give you an option do you want to save this somewhere else it just saves to the same name okay so if i type ctrl g right here get help i wish it was ctrl h ctrl g is harder to remember we get a whole manual here that explains how it works and then explains all the different shortcuts so there's quite a few things in here we saw ctrl w to search forward we can actually insert another file into this file or into this buffer with ctrl r we can cut and paste so this is one that you know you've probably noticed control c uh and control v for copy and paste don't really work in the terminal control c has its own meaning uh just like control z has its own meaning to suspend a job anyway uh we still can cut and paste the way that we can do it is with ctrl k to cut it actually stands for kill and then u to revive or to unkill i don't know what the u stands for and that will basically take whatever we've cut out and paste it so i can show you that there's options to configure a spell checker we can display line numbers we can go to a particular line number if we know what we want with uh where's that control underscore there's a bunch more stuff so you know this is not a course on nano but just so you know there's a lot to nano okay so to get out of here ctrl x is going to close the help screen now as i said i want to show you cutting and pasting so if i want to cut a line i guess maybe i'll just type a line first hi there cut me out of here please all right if i do ctrl k it's gone and then i can move it down somewhere maybe here and ctrl u it revives it and i keep hitting ctrl u there we go it's just like cut and paste uh if you do forget about that we can see shortcuts down here okay so i'm going to save control s we also can do control o to write out if i wanted to create a copy or a different file name i could type that here so maybe uh you know song of myself 2 dot txt and this is my version i'll hit enter do i want to save it under a different name sure and then i'll get out of here ctrl x one more thing i'll show you you can actually create a new file with nano so if i need to add some text into something a file that doesn't exist i don't have to make the empty file first then open it with nano i can just do nano new file dot txt and now i have an empty file i can type my stuff in here save and quit control s control x and there it is song of myself too from the previous nano and then uh new file.txt okay next up we have the alias command the alias command allows us to define our own aliases our own our own little short custom commands that we can then reuse later on so for example if we find ourselves doing you know ls remember just gives us this information lsa gives us all including hidden files lsla gives us listed long format information for all files if we find ourselves doing that a lot we could set up our own alias so that we don't have to type all of that and maybe just have la for example so if we wanted to do that i want la to actually be lsla the way that we do that is by using the alias command so i'll show an example here i'm going to do alias and then let's just call this my i'm gonna do something really obvious first like uh my ls equals and then in quotes i'm gonna use single quotes there's a distinction here uh single quotes and then i'll do ls dash la just like that okay so if i type alias now i'm gonna see a list of all my aliases i actually have quite a few on here here's the one i just made already and if i try running it my ls there we go i have a new alias i could take something you know really long like if there's some find command that i use a lot let me just show an example here i think i have yeah like this one right here this finds some of the i think it's the top 10 uh most uh cpu intensive processes on my machine um honestly i never use it because i don't even remember this but if i run that it's a very long command relatively long i can alias it to something short so pscpu10 and there we are i need to sort of zoom out my font size is too large for me to make sense of this here but that's all right i'm recording i need that large font size the alias we just defined is not permanent if i close this window or even just open another window my ls huh it's not working it doesn't know what the heck i'm talking about so when i just define an alias like bobo right here equals i don't know how about just sleep for 10 seconds okay when i define that in my shell directly here it only exists in this exact instance right here it is not going to be created every time i open up a new terminal window or my computer restarts i lose it so if i want to make an alias last if i want to have it persist i need to put it in one of a couple different places it depends on what shell you're using if you're using bash if you're using z shell there are different configuration files now over here i'm using bash this is ubuntu the default shell is bash and if i go to my home directory it's actually where i am right now again home meaning my home folder not the folder actually called home it's confusing but my user's home folder colt um if i do ls dash a there are some of these special config files now there's actually on ubuntu there's one called bash aliases and that is a good place to put aliases however that is particular to some distributions of linux it is not something that you may not see it depending on what distro you're using so a safe place is going to be the bash rc file so it's hidden rc uh and i can open it up i'll use nano to edit it dot bash rc okay now i'm in nano i can scroll down and i can define my own aliases in here um so let's just i think i already have some here there we are uh so i'll just define some in here just as an example uh alias and i'm just going to write the exact same thing that i wrote earlier except i'm putting it in this file and what's special about this file is that when the shell loads up it will run this file and it will run these aliases first before i even have a chance to do anything else in other words it will know about all these aliases i define so um let's see what should we do in here i'll make it an alias called um count okay and count is going to echo and if you remember our expansion i'll just echo 1 to 99 i don't know why we do this but sure we will uh and then i'm going to save this file so this is nano the easiest way is just control s and then i'm going to exit with control x okay so can i run counts no i can't run count just yet i could open up a new window and it will run that bash rc file and now if i try running count hey it works alternatively if i don't want to do that i can actually source the command is called source my bashrc file and now i can run count in this same window now if you're on a mac the default shell is z shell as we discussed earlier you could switch over to bash if you wanted to and just type bash and now i'm using bash and i can define my files or rather i can define my aliases inside of my let's do lsa here lots of hidden files inside of my bash profile here that's where i could do it on a mac or more likely if you're using z shell which is the default shell the file we want to add our alias to is dot zshrc where are you z shrc right there so that is our configuration file for z shell so i can do nano dot z s h r c and scroll down i don't have to scroll down i can define my aliases anywhere in here but somewhere in here i can define an alias so let's do a different i don't know a different version of count these are how we write comments by the way so if you want to have a little note or you want to uh have something not take effect you can put a octathorp or a hash sign in front of it so alias let's call this one um hmm let's do uh i'll just do another i don't know count count again but this time on my mac count is going to be an echo about 1 to 365 sure all right and that's it we could also define you know l a more useful and how about ll which will be ls dash l and how about uh we'll do l a will be ls dash l a so now and actually why don't i do one more why don't i alias rm to instead be rm dash verbose so it tells me when it deletes something so i have that over on my ubuntu over here which you may have noticed so let's just define those three alias or four we have count lla and rm i redefined the rm command to actually be rmv so that dash verbose option is always there i'll save and exit yes i'll save okay so in a new window i can run my count command i have the ll command i have la which also does hidden files we can see my hidden files are showing up and then i did the rm command so let's just create a file called remove me and delete me now if i run rm on remove me and delete me oh well i i didn't fully expand delete and to delete me but still it shows me what it removed so let's try try one more time there let's rm delete me there we go and now it just tells me it gives me a bit of feedback as to what was deleted anyway that's the basics of using the alias command remember where you define those aliases first of all if you don't define them in a file one of these special files they will not persist which is fine sometimes you may not need them to but if you do define them and you want them to continue to exist every time you have a new terminal window make sure you put them in the appropriate file depending on whether you're in zs you're using z shell or bash or some other shell they all have their own config files and one last note about working with aliases and specifically with quotes there's a difference in uh bash between single quotes and double quotes when we have double quotes and we have a variable or some form of so remember there's this variable expansion where we have a dollar sign if i echo some dollar sign and then a variable like path or there's user the shell sees this and it expands that or it replaces it with the actual value for user cults and that is what is echoed out okay so if i defined an alias that i just wanted to i don't know how about well let's just use this example here that is going to ls the contents of our current directory if i do ls dollar sign pwd that's what both of these are one has double quotes one has single quotes the difference is that whenever we use double quotes that variable is going to be resolved the value will be set in stone at the the definition time when we actually run this originally so whatever that pwd value is originally it will always be that but if i use single quotes instead single quotes will be resolved or that variable will be resolved whenever we invoke this alias so this in other words will be dependent on when i run this it's not going to be the same thing every time versus this one here because i use double quotes it's always going to be whatever the value is i'll just show you here if i just paste this into my shell currently the value of pwd it's my current directory so if i do ls this it's printing the contents of my home directory but if i go somewhere else like my desktop and i rerun that it's still printing the contents of my home directory no matter where i am it doesn't matter that i'm on the desktop or if i go into uh i don't know this wildlife folder and i run ls this because i used double quotes when i defined that alias this was set in stone at that moment i defined it now if i instead did this so i'll copy that and i'll put this in here alias ls current it is exactly the same inside the quotes remember if i just echo pwd it's a variable and it's just the exact same thing i see if i type pwd but the difference now is that this is going to rerun every single time that i run ls current so if i go to my home directory and i run ls current it shows me the contents of my actual current directory uh it doesn't matter where i was when i defined this so that's an important distinction when we use double and single quotes next up we get to talk about one of my favorite commands it's not my favorite because i use it very much that'd probably have to be i don't know cd or ls or something like that you just can't get around using those all the time but this command x args i don't use very much at all but when i do use it it really comes in handy it's pretty nifty so here's the whole point of it xargs exists to take output from one command and turn it into arguments for a second command so we've seen how we can take something like well first i'll just show you this folder i have i've got some files player two three four five six all the way up to player nine or player ten um so we've seen how we can do things like take ls and then pass that to sort for example right and what's happening here is that the output of ls is being passed as the input to the sort command however when i say input i'm actually referring to something called standard input somewhat of a long explanation to really go into but the idea is that unlike other commands we've seen like when we touch and make files i'll make another file here player 11.txt and player12.txt these are arguments being passed to the touch command it's a list of values separated by spaces so when i run that we end up creating what two new files and they're in here but when we do ls pipe sort we are not passing arguments to sort and this is what's kind of confusing the sort command is set up to accept values through standard input and it's also set up to be able to sort things as arguments so if i provided a file like i have this file called dead players we'll talk about that in a moment it can sort the contents of that file as well so this is passing an argument versus this right here we're passing the output of ls to the standard input of sort anyway i say all of this because only certain commands are set up to work with pipes only certain commands like sort and there's a lot of other ones that will accept an input through standard input rather than through arguments but there are many that don't so for example touch is actually one i just showed you i can't take the output of one command and pass it to touch at least not without x args so let me show what i'm talking about i'm going to show you first what we can't do the problem that xrx solves so i have some files here player 1 through player 12 these represent players in some game and people die after each round of the game and we need to clear them out we need to get rid of the players that died so i have another file called dead players if i just cat it out here you can see it has the names or the files of the players who are dead so what i want to do is take this file whatever's in it and delete or remove those files from the actual folder now this could be you know hundreds and hundreds of dead players and we could have thousands i actually recorded this once where i did have thousands like when i say once i mean like 10 minutes ago i had thousands of players and then i removed half of them but i realized that the scale was too large you really couldn't tell how many were removed so i scaled it down we're dealing with 12 now and we're going to delete what five of them here so aside from me manually doing rm player one and so on the idea is that this could scale up we could have thousands of players and there's some some list we don't even know you know exactly what's in there but some list of dead players it could be hundreds what i want to do is take whatever's in that file and dynamically remove those files so whatever those names are what i can't do unfortunately is just read the file so we can cat it and then pipe it to rm that will not work because the rm command is one of those commands that is expecting a space separated list of arguments it is not expecting anything to be passed to its via standard input so that's what's happening here with this pipe it takes the output of cat and pipes it over to rm but ram is not set up to handle that so just complains it says hey you didn't pass anything in there's no argument so what do you want me to rm just like if i had run rm here this is where x args comes in the x arcs command will take or it will accept standard input which is what's coming in here from this pipe so cat the output is passed to the standard n of rm but rm doesn't want anything to do with it but if we instead do x args if i can spell it rm what it does is it's kind of like an adapter it will take that standard in and then turn it into a list of arguments that will work for rm so this is the syntax x args and then the command that you want xargs to provide the arguments to all right so we're going to take this list of dead players which when we cut that out it's basically going to take this and provide it to xargs xargs then says okay let me turn that into a list of arguments that will work for rm provide that to rm and now when i run it well we see we lost a lot of players they're now gone right i this could scale up again to be hundreds at one time we can take the contents this is a simple example take the contents of one file and then do something with those contents in this case we've removed files that have that had those names let's take a look at one more example uh what i want to do is run the find command just uh on my desktop in all nested folders and files uh to find how about files that are larger so size is plus one m so greater than one megabyte and this is what it finds for me okay but i want more information about these i actually want to then uh do ls dash l right so we get that long listing format but i want lsl only for these files which is what seven or so files so um if i try and pipe it to ls dash l well surprise surprise ls is not set up to accept values through standard input which is what the pipe does it is expecting us to provide arguments sure after the fact so we could do you know files that end in txt but that has nothing to do with our find command i want to take the results of the find command and then pass those to lsl in a format that it will accept so this is again where xargs comes in so this is the list of files that are greater than one megabyte and then i can do xargs oops and then ls dash l that's the command i want to run and here we are we now see let's actually do lh so i can get the human readable format for the sizes not very large files on here 1.8 1.8 megabytes 1.2 1.2 but these are all the files that we found from that find command uh those values were then passed to xrx xox stepped in and turned it into a acceptable list of arguments that was then provided to lslh and that's how we see this output so there's actually quite a bit more to xargs i'm not going to go into here you can read the man pages it's pretty powerful the different ways you can construct the list of arguments the different separators and delimiters and you can have it replace different things for you along the way you can limit the number of arguments it's quite complicated but what i just showed you are some of the more common simple ways of using it and that's the core purpose of xargs is to take standard input and turn it into a list of arguments that other commands will accept all right so next up we're going to talk about the ln command which is used to create links ln link now when i say link it's not a hyperlink or you know something from a browser a link in linux is or it may be a new concept to you it's kind of similar to the idea of a shortcut your desktop shortcuts on a windows operating system where you have some applications that are installed somewhere else it is not on your desktop they are installed completely in a different area but you have access to start them up you can reference them through the icons on your desktop so there's a link those icons have a little picture of whatever adobe photoshop that icon on my desktop when i double click it it is linked it's referencing some actual program that it starts up so the concept is similar we can have a file that is linked that points to another file so there are two types of links hard links and soft links we'll start by covering hard links which actually are not used as frequently but the idea is when we create a hard link we are creating basically a file that will stay in sync with another file now we're not creating a copy we're not duplicating a file it's different they are pointing to the same thing the same exact file so they're not diverging they're not copies it's not like using the cp command that's important to understand so let me show you an example we'll start nice and simple i've got an empty folder i'm going to echo i am original into a file called original.txt all right so i just made this new file we can cat it out and it says i am original and that's the only file in here now the syntax to make a hard link is ln and then the original file which happens to be called original and then whatever our destination or not destination but whatever the name of the link file that we want to create is i'm going to call mine hardlink.txt so if i type ls we have two files now or what appears to be two files uh this hard link file if i cat it out says i am original it has the same contents remember though it is not a copy it is pointing to the same file as this right here so if i change original let's echo this is more stuff we'll append that into original so if we cat out original we see two lines now and if i cat out the hard link we also see two lines and this goes both directions because they're both referring to the exact same thing if i change hard link uh change from hard link and i echo that into the hard link file which is a hard link to that original file this is what it looks like now and if i cat the original it also has that change so they are two things two arrows pointing to that same file in memory and this means if i were to delete well first if i delete the hard link the original file is still there it's unchanged but if i delete the original file my hard link file will persist it is pointing to that same thing in memory and that's what's a little bit confusing here it is not pointing to the you know this name original.txt it's pointing it's called an inode it doesn't really matter but it's referring to the same thing in memory just two different names for it so if i remove original i'll remove it it's gone but our hard link file that is still there that hard link we created and it still has those contents inside so that's a hard link as i mentioned it's not as commonly used then we have soft links and soft links are different the first thing you should know is that to make one we use the dash s option if you just take a look at man ln and then scroll down somewhere on here here we are dash s for symbolic it will make a symbolic link soft link instead of a hard link so what i'm going to do here is remove my hard link and i'm going to create a new original file so we'll echo i am original again into original.txt oh i did dot tt but that's fine um just quick quiz how would i rename that without moving it anywhere easiest way is just move command original dot txt is the destination and there we go okay so i'm going to make a soft link and to do that it's ln s the file that i'm linking to and then the new soft link or the sim link symbolic link i'm going to just call simlink.txt okay so what i have now is a symbolic link or a soft link and if i type ls you'll see if you have colors enabled it really depends on the terminal you're using your operating system your shell but for most terminals it will probably be a difference and for me it's bolded and it is in a different color cyan it doesn't matter what color it is and even if there's no color difference it doesn't matter if we do lsl we can see a difference as well if you notice here here's my original file here's the sim link file it has this little arrow pointing to that original file additionally over here we haven't really talked about permissions yet but there's a difference there's a dash here is the first digit and there's an l here as the first digit this tells us that it is a symbolic link it's a link anyway just like before if i change the original file let's do a echo change to original and then we will append that to the original file it now looks like this and if i echo or rather cat the simlink file it also prints out the exact same thing now what if i try and change this sim link file echo change to sim link and i append that to the sim link file all right let's see did that change the sim link and does that mean the original has changed yeah it goes both ways in this sense however where there's a big difference is if i delete the original file so i have both of them here right now if i remove original yes now we have this simlink.txt but it doesn't look very happy it's still there but it's showing up in red all of a sudden and if i try and cat the contents it says no such file or directory so it's this link that it's just pointing to something that doesn't even exist anymore so that's the main difference the symbolic link was pointing to original.txt and when original is gone that link is severed with a hard link a hard blank is pointing to don't think of it as pointing to the file itself but think of the hard link and original.txt as two different pointers to the same thing in memory so if i delete the original it's all right we still have the hard link it's pointing to that same thing in memory but here with a sim link i delete the original well now this sim link has nothing to link to and it still is there right we still see something show up but it's just completely dead inside now you might be wondering why would you ever do this why does it matter and this is one of the harder things to explain or to convince you of when you're a beginner and i honestly don't even use sim links all that much or any links although i end up working with people who do use them and so i you know need to be familiar and comfortable working with them it's pretty straightforward once you get used to just that dash s lns but let me show you an example um if you have python installed for me i have python i think it came preinstalled and ubuntu and i have a couple different versions i'm going to run an lsl on this directory user bin and then python i'll come back to in a moment but user bin is where binaries are installed uh and so it's where python binaries will live by default uh and there's a lot in here so first of all if i just get rid of this python thing there's a lot of different programs in here uh one of which i'm just going to focus on for now is python so if i do an ls dash l user slash bin and then anything that starts with python maybe i'll even do python 3 because i have python 2 and 3. what we see here let me clear everything else again and just focus on this what you'll see is that there's four matches there's user bin python 3.8 3futurized 3pasteurize and then there's this right here what is that that is a sim link and that sim link is just called python 3 but it's pointing to a specific version so when i run python3 that's the command i'm running when i run that right here it's actually a sim link and it's referring right now to 3.8 but this allows me to manage different versions i could then have 3.9 or threepoint you know python versions that don't exist yet or older versions 3.5 i can have them all installed and then whatever this sim link it's like a shortcut whatever python 3 is referring to is what version of python will run so i can manage i can have all those versions installed but only one that is actually run when i call python3 so one with this little shortcut and i run python3 and there we go it doesn't matter if you know python or not uh and it actually we have the same thing if i just do python star python 2 i only have one version installed but i have a sim link and i don't set this up myself to be clear this was just done for me when i installed python but python2 simlink is referring to there's a little arrow python 2.7 but i could also have 2.8 and 2.5 and then switch versions and when i switch versions python 2 will point to one of those versions so that's just a simple example but there are many ways you can use sim links for now though i just want you to understand that ln is a command and that there are two different types of links we can make we can make a hard link and a soft link also known as a sim or symbolic link all right the next couple of commands we'll learn have to do with users and permissions uh they're pretty important ones that may not come up all the time but when they do come up they are really really useful um so on linux we can have multiple users logged in at the same time um doesn't really happen for me i'm kind of just working on my own on this one machine and for most people i shouldn't say most but i imagine for a lot of you who are watching this video you may be the only person using your machine but it's important to understand that you can have multiple users all logged in simultaneously to your same machine it might be hard to do right you may not have the the multiple screens and keyboards and whatever needed to have different people logged in at the same time although it can also be accomplished virtually the point is it's possible there is a command called who not to be confused with who am i who am i tells us the username based on the current effective user id for me that's cold steel here on my mac who is going to tell us about the users who are logged in and like i said for me it's really just me uh but what we'll actually see if i type it on my mac is currently what five seven different uh well if you include this one eight but right here what we're seeing are seven different uh users it's the same user but they're each added here separately for each time i access or each time i log in via a terminal basically every terminal window counts as a user accessing so i have seven right now this is tty is it it's teletype i believe it's an old relic but anyway if i create a new terminal window just ignore it uh and then run who again we now see we've got a 4 which wasn't there before you may not see that but if i zoom way in it says last login on ttyso so um yep that's why we're seeing all of those there anyway not the most useful command certainly not right now and not for me because i'm the only user but if we're an administrator and we've got a whole bunch of people on a machine at once this could be pretty critical to know who is currently logged in next up we'll cover the su command which is short for switch user this command allows us to switch users to log in as someone else within a terminal show so you may have situations where you might need to do this maybe not it really depends on what you're working on and how your machine is set up but if you are an administrator for example and you need to do something on somebody else's account well all you need to do is run the su command followed by some username now i have a different user on this machine so remember i'm colt on this ubuntu uh distribution here right now that's who i'm logged in as but i have a user called elvis and when i do su elvis it asks me to enter elvis's password so i can't just switch users to be whoever i want without knowing passwords unless i'm a root user unless i have full permissions but i don't so i switch user to elvis i need to know elvis password and i think nope i'm pretty sure i just got it wrong i did this last night let's see there we go entered the correct password uh and you'll see my prompt changes now says elvis at my ubuntu and if i type who am i it now says your elvis but just to be very clear this is in one window over here i'm still cult so i haven't completely logged out and become elvis everywhere it's still my horribly messy desktop but i am elvis in this tab aside from what we see when i run who am i if i cd to my home directory well my home directory tilde if i do pwd is home slash elvis whereas over here i cd2 tilde and i do pwd home slash colt is my home directory so as elvis i can do things like well there's nothing in this home directory but i could make a file touch from elvis.txt and i have permission to do that but if i go back and i go into colts account or rather colt's home folder remember i'm logged in as elvis here not colt uh what happens if i try and make a file here called from elvis.txt i can't do that so i'm logged in as elvis but that doesn't mean i can do everything colt can do we have different permissions and that's something we're going to start to try and understand we'll walk through how permissions work but this is just a quick introduction to the concept that different users have different permissions they can do different things and if i went the other direction as colt you know i can make a folder or a file from colts here no problem but if i back out and i try and go into elvis's directory i can do that but if i try and make a file touch from colts.txt no luck i can't do that i don't have permission anyway uh that's the basic idea of using su you probably wouldn't do this just make a random folder or file in somebody else's home directory but if you do need to switch users that's how you do it you need to enter the password and then to get out of here i think you can type exit also you can just do control d or control c i believe now there's another option when we run su if i do man su there's this dash that we can provide and if you provide that dash let's see if i can find it here it will start the shell as a login shell with an environment similar to a real login this means it clears all the environment variables it initializes the environment variable's home shell user log name and path and it changes us over to the target user's home directory so remember when i logged in as elvis i was actually just in colt's home directory anyway it didn't take me to elvis's directory like a normal login would but if i instead do s u dash and then elvis i can also do dash l but it's so common that you can just do dash it's a very short option i'll type elvis password and it takes me right to elvis's home directory this acts as a real login shell and then to get out of here again i can type exits or it is control d i believe there we go okay so that is su to switch users next up we'll talk about the sudo command sudo which is short for super user do and the command allows us to run commands other commands as the root user or with elevated permissions so there's this concept of the root user a user in linux who basically has permission to do anything to create new users to change passwords to remove files and folders and we actually if i just run ls dash l here i'm logged in as colt what we see here in this third column is the owner of particular files and folders but if i keep backing out now we see you know my different users if i take a look at one of them like kitty kitty owns these files and folders in her his or her desktop or home folder rather but if i back out another level so here i am one more time now we see a bunch of these really important directories uh that i who owns who who owns you know the bin folder where i have things like if we just cdn there all our programs are installed who's in charge of that which user well if i type lsl we see root all over the place the root user is in charge or not in charge the root user is the owner of these programs these files and folders uh and that's just one example of you know the significance of root root can do all sorts of things like i said a root user can change someone else's password but as colt's just a regular old user i can't do that now there's something very important to know on ubuntu at least in many linux distributions the root user account is actually locked it's not accessible you can't log into it there's no password i can't just log out and log back in as root if i go to log out we will see yes i'll log out we saw the text root all over the place in my terminal but there is no root account that i can actually log in as so why is this well it's just how ubuntu is set up it was a decision that was made rather than having a single root account with a single password that you can log in as instead individual users i have four here colt kitty carrot and elvis individual users uh may be able to run commands as the root user and that's where this pseudo command comes in so how does this work it's not like it's a freeforall and every single user on a machine can run commands as the root user uh those permissions are are actually listed out in a particular file there's a lot that goes into it and managing those permissions but i'm just going to show you though is that when you create your initial user account so colt was my initial user account whoops i'm logged in now as colts and i'm looking at my settings i can see different users again none of them are called roots but some of them including colt which was the first account i made by default is an administrator so that means i can add and remove other users i can change settings for all users but that's not the same as being the root user and then some other users carrot elvis are not administrators kitty is an administrator when you make a new user you can decide that now that's just one basic difference or one basic toggle between permissions but we can get very detailed about who is allowed to do what but we're not going to go into that i just wanted to make it clear that this sudo command i'm about to show you is not carte blanche for every user to do everything so i'll demonstrate that okay so how do we use this sudo command the idea is that instead of using a single root password each user has their own password we enter that password it's going to prompt us for that password and then it's going to check do you even have permission to run this command as root so it doesn't turn us into the root user it doesn't give us permissions to do everything if we don't already have them it only allows us to do certain commands that we are specifically already permitted to do it's just an extra level of protection basically you have to type sudo you have to type your password so even if you have those permissions you can't just normally go around deleting everyone's stuff you need to run sudo in order to do that so if i wanted to edit some particular configuration file that affects everyone on a machine if i just tried to open it in nano i'm not going to be able to do that but if i try using sudo first i'll enter my password and it will check if i'm allowed to do that or not so let me show you uh let me get my terminal open so the file that we're going to look at is in slash etsy etc host that's the name of the file and if i just do an lsl on it remember this is a high up directory it is not located in colt's user directory or any other user it's above and if i run lsl we can see that the owner is the root user but again there is actually no way to log in as the root user in ubuntu so uh if i want to edit this file for some reason i could try running nano and it does open up i can actually read the contents but it tells me for you this file is unwritable so i can't make changes i'll get out of here but if i now prefix this with sudo super user do this so super user do this command it's first going to say enter your password for colts that's who i currently am and it's going to check if i have permission if i am granted those root permissions to edit this particular file so if i enter my password this is not the root password this is colt's password that i log in with and we see i actually am able to edit this file i'm not going to because i really don't want to but this is a file i can change now but if i go log in as a different user and remember we saw how to do this i can use su dash i have elvis as a user on this account i'll type elvis's password okay who am i i am elvis so if i try and run this nano etc hosts i also see hey you don't have permission to do that that's a file owned by root but if i try sudo just like i did as colt it now asks me for elvis's password so what is elvis's password well i'm not telling you but i know it i type it in and it tells me nope that's not going to work we checked elvis is not in the sudoers or sudoers file we're not going to really go into that but there's ways of managing who can do what it's more of an administrative process or a specialty that i'm just not going to go into here but it's important to note specific users can have different permissions who is allowed to do what as the root user and elvis doesn't have any so i can't edit that file as elvis but again if i switch back to being cult i'll just get out of here with exit and i run that sudo nano blah blah blah i already entered my password so it remembers it there just to be clear but you will need to enter your password when you run sudo your particular user's password now you've probably actually come across this before when it comes to installing software or installing new commands there's a command called tldr i don't have it installed and if i try typing it my shell is going to tell me i don't know what you're talking about but here are some things you could try installing so there's a command called apt install and then the package tldr but if i just run that without sudo i'm not allowed to do that because i'm installing something that is not even just specific to my user here it actually is specific or not specific it would apply to all users on my machine i'm actually installing a program a command that everyone can use so i can't just go around doing that i need to have permission so that's why we run sudo do i have permission to install this well i already entered my password again so it knows who i am and what permissions i have to do as root user i can install it so i will continue and it will take a little while to install the the point of this is not to show you how to install things by the way it's just to show you another situation where you would need to use sudo so anytime you're trying to make changes you run into a permission denied error you'll often be prompted to try it again with sudo first so sudo itself we prefix in front of other commands and then it will prompt us for our password and now i have this tl dr command just show it to you on the man page for it here we are anyway uh it really doesn't matter it was just about using sudo so it really depends on who you're logged in as and what permissions you specifically have been granted and that is something that can be tweaked it can be really down to a pretty granular level i haven't changed anything it's just that some users have administrator permissions on here some of them don't now not all linux distributions will have the root account locked so you can't log into it directly some of them you can but even then we still have access to the sudo command and we can grant specific users different privileges as root it's also you know on my mac i cannot run things with sudo and i often need to if i'm installing something that is systemwide same idea the next command will cover is the password command which is actually pass wd i guess those extra two letters are too long and this is the command we can use to change someone's password so there's two ways of using it you can change your own password by just typing passwd so i'm logged in as called i don't really i mean i guess i'll change my password then i'll change it back so it's going to ask me for my current password so i have to know that and then it asked me for my new password and let's do uh well i'm not gonna tell you and then i have to confirm it again okay i updated my password and you can just trust that it worked i mean i how would you really know i guess i'm not going to tell you what it was before or now although none of them are actually real passwords anyway but it did change and if i were to log out i would need to use that new password so i'm just going to change it back one more time current password whoops i messed up i'm gonna do that again so my current password i just changed it to my new one okay now i can also change someone else's password uh assuming i have root permissions uh so let's say i need to change elvis password he's forgotten it there's actually a lot you can do you can lock someone's password you can if we just go to man pass wd you can do things like expire an account's password which would force them to change their password next time they log in but it doesn't actually give them a new password you can make an empty password to disable a password for an account there's a lot here um i'm just going to show the basics so i want to change elvis password pass wd elvis well i can't do that right as colts i need to do it as the root user or i guess as elvis uh but as the root user is probably more likely right why would elvis need to change his password from my account uh so if i have permissions i'm the administrator remember on ubuntu i can't log in as root so this is the closest thing i'm an admin i have permission to do this but i have to use sudo so sudo password elvis is now going to ask me for my password not elvises it's going to ask me for mine and it's going to just verify are you even allowed to do that as colt okay now it's asking me for elvis's new password so i'm just going to change it to how about hacked okay and one more time and now i just changed elvis password i guess you know i could show it to you quickly if i do an su elvis if i try and use elvis's old password which was something involving the word taco it doesn't work but now if i log in as elvis using hacked it does work and then as elvis i could change my password again using password and i don't need any fancy permissions you can change your own password all right so that's the basic use of password it is past wd there is more to it as i said you can lock someone's password you can delete it uh you can expire it and force them to set a new one when they log in but again it comes down to you can change your own password or if you have permission as the root user you can use sudo in order to change somebody else's password the next command we'll cover is one of my favorites to say out loud chon or town change ownership this is the command we can use to change who owns a particular file or directory so let's talk about what that means to own a file or directory um on every file every directory let me just go home here i'm logged in as colt who am i um when we do lsl we see a whole bunch of information we're going to talk more about what this is in just a little bit permissions and then this right here this third column is the owner of the entry so in this case the owner of this directory files exercise is me cold uh the owner of music is colt this is pretty normal to own all the stuff in your home directory but if i go to somebody else's directory if i have multiple users let's go to kitty's directory so this is her home directory kitty owns almost all of these files and folders and if i keep backing out further we've seen this before root the root user owns all of these directories and files so the chon command helps us change who owns those files and that's important to do because the owner of a file is allowed to change its permissions to delete it potentially to read or to write to that file it all has to do with what we see over here which we'll get into in just a little bit but for now i just want to show that we can change the owner and then we'll understand we'll try to understand its implications later on when we talk about another command all right so i'm going to go back home and the syntax to change the owner looks like this tone and then the owner that we want to add as the owner so a user and then the file that we're trying to change so um i'm going to go into elvis's directory or maybe it doesn't really matter here i'll go into kitties kitty all these files almost all of them are owned by kitty if i wanted to if i wanted to change the owner of how about kitty's music directory the syntax would be change owner chone and then me colt that's the user i'm trying to add as the owner and then after that music now there is a bit of a problem i can't just change somebody else's you know i can't just make myself the owner of somebody else's directory uh all over the place like that is something i have to have permission to do and we've recently learned that we can use the pseudo command to act as the root user so that is one option here is if i have root permissions i can change the owner of any files sudo tone cult music so it's going to ask me for my password and then i enter it and i don't see anything but that's a good sign that means that i did have permission to do that and now you can see cult is indeed the owner of this music directory now again we haven't really talked about what that means for me to be the owner but i'll just show you for example if i were to go into the desktop and try and create a file touch made by colt i don't have permission in that directory but if i go back out and i go into music if i touch a file touch made by colt i do have permission now because i am the owner as we saw i did lsl i own that folder music one commonly used flag with chone is uppercase r which we can use to recursively change the ownership of all the files and subdirectories nested in a directory so i have this directory i just made called cat stuff and it has some files inside of it and then a nested directory with some other files and if i decide i want to make the owner of cat stuff kitty and this is all kind of silly and you probably won't just make a directory in your home folder and then make someone else the owner at least not frequently but just for demo purposes if i make kitty another user on my computer if i make her the owner i can do chone kitty and then i need the name of that directory which is cat stuff and i do need to use sudo even though it's my own folder that might seem weird like you should be able to change who owns your own stuff the way linux is set up that is not the case you still need to have root permissions now you can change the permissions attributes we'll talk about very very shortly uh if you are the owner um but you can't change the actual owner of a file unless you have root permissions and i already typed my password a couple minutes ago or seconds ago so i don't have to redo it and if i do lsl we see where are you cat stuff kitty is the owner but if we cdn to cat stuff lsl i cult still own all the files and the nested directory so to change that we can just rerun that line the tone line but we use the dash uppercase r to recursively change the ownership and now if i go back into cat stuff kitty is indeed the owner of all the nested contents if we go into toys same thing there kitty is the owner of those files okay now another thing you may notice when i run lsl let me go to uh how about kitty's home folder so we'll go slash home slash kitty instead of here when i do lsl on any it doesn't matter where but in this directory ls lsl i see a bunch of folders and files there's an owner that we talked about that is a single user who is the owner of that file but then why does it say kitty again or here it says pals forever what is this second thing this is known as the group owner this is a little confusing but every file on a linux system has an owner and it has a group that owns it and that group can have multiple people's people users who are members of that group and then the group can get its own set of permissions so this means that um you know i could be the owner of this file and i might be able to read write delete whatever i want and then members of the pals forever group might be able to read only but they're not able to edit this file they're not able to write to it so this allows us to have two different levels of permissions the owner can have some set of permissions what are they allowed to do and then members of the group that is an owner the group owner they also can have a separate set of permissions and it's all encoded in these weird little digits that rwx and dash is here we will talk about that very soon but what i want to show you right now is that we can just change the group that owns a file using chone now this is something you probably won't do very much and i'm not diving into groups and managing groups and creating new groups and changing members who belongs to a group that's all more admin stuff anyway not daytoday user stuff at least in my experience and with my students but it's worth knowing that we can use the shown command to change the group owner so i have this group called pals forever i can actually there's a command called groups i can see all the groups that i the current user belongs to so here's all the groups we've got uh movie club pals forever let's say i want to change the group that owns music from kitty and this is also somewhat confusing by default the group is going to be a group with your username so it says kitty and kitty but this is the group owner this is the owner owner all right if i want to take this music directory and make pals forever the group owner the syntax looks like this where we have the owner name a colon and then the group that we want to add so here if i want to keep the owner as colt i need to do pseudo chone cult colon pals forever and then music is what i'm trying to change so this will be the owner and this is the group owner lsl and if we look at music that group has changed now again the idea behind groups is that we could have 10 different users who are part of this group and they might be able to read this directory only but then the owner can read and write and execute and do everything so we can have these different levels so it's not just one person who's allowed to do things for the file we can selectively change these groups and add people to the groups but that again is a more advanced admin thing we don't really need to worry about all right so the next thing we're going to talk about is understanding when i do lsl the very first chunk of really bizarre looking text these characters here we want to understand what these are what they mean because we're also going to learn a command that allows us to change these so what we're looking at right here is for every file every directory these are the permissions or the file attributes they detail what the owner is allowed to do can you read write or execute this file uh what the group members who are part of the group that owns this file can do read write and execute and what everyone else can do can the world at large any user read write or execute so there's a lot to break down there's actually 10 digits here not digits 10 characters and the first character actually i'm using some of my slides i've made for a course on udemy if you're interested in a lot more of a deep dive into linux commands because this is just hard to explain without graphics or some visuals so anyway that first letter is either going to be a dash so not a letter that indicates that it's a file a plain old regular file id indicates a directory so we can see that already here's a file dot txt it has a dash that's the first character here's a folder or a directory it has a d and then for sim links i think if i just back out a little bit here they'll start with an l so here's a sim link here we can see we also have that arrow pointing to you know where the link is linking to and it starts with an l so that's the first thing that's kind of just a oneoff then we have nine characters which is actually three sets of three the first group of three tells us the permissions for the owner of the file or directory the second group tells us the permissions for the group owner or for members in that group and then finally the third group tells us the permissions for everyone else the world at large any other user that's not the owner or that is not part of the group that owns the file or folder now within each group of three we'll just take the first one so for an owner those first three digits they tell us the read writes and execute permissions for this file can the owner read write or execute so those three characters in a very particular order the read permission is first then the right permission then the execute and then it starts over read write execute for the group owner or group members read write and execute for everyone else so what do these three permissions mean well if we have an r in that first spot right here there's an r here there's an r here there's an arm that means that the file can be read if it's a file or if it's a directory it means that the contents of that directory can be listed okay so here i have a single file i've created called onlycoltscanread.txt and we'll learn how you can change these permissions but i've already changed them the first thing we see here is a dash that means that it's a file then we have those first three digits which are the owner permissions now the owner is colt and there is an r present here which means that i have permission to read the owner whoever that is has permission to read the contents of this file and i can read it okay then we have the next three which is all just dashes which means none of those permissions are present so this is the group permissions anyone who's a member of this group well they don't have any permissions here and then everyone else they also don't have permissions so that r would be that character right there there is no r that means whenever we have a dash that the file is not readable or executable or writable depending on the location of where that dash is so here if there's a dash that means the owner couldn't read it but there is not a dash there's a r which means we do have read permissions so let me demonstrate this if i switch over i'm just going to log in as elvis if i can remember the password uh oh that's not it all right let's try that again oh wait i think i changed it to hacked didn't i i forgot about that there we go all right so i'm now elvis who am i if i do an lsl well i'm not cult i'm not part of this group uh so i'm considered anyone else i don't have read permissions there's just a dash there if i try and cat the file out permission denied only colt can read that file or only the owner which happens to be colt okay so this pattern holds true for all of these permissions if there's a dash in any of these spots it means that that respective if it's the world the group the owner does not have that permission so here we can see the owner does not have execute permissions the group does not have execute permissions everyone else does not have write or execute permissions now what those mean we'll dive into but for reading as we saw if there's an r there that means the file can be read and if there's an r on a directory that means that we can list the contents of that directory so this is why as elvis i can do ls or lsl or something on this directory it's actually going to zoom out further or move back one level if we look here this is each user's home folder so we've got carrot colts elvis and kitty each user has rwx that means read write and execute but then there's an r present for everyone else for that world right everyone can still read these directories that doesn't mean i can change them of course but this is why as elvis i can go into colts directories and and list lsl i have that permission because i have that r attribute right there in that third set so remember first three that's going to be the owner members of the group and then everyone else and i currently and part of that everyone else i'm able to read the contents here but uh through some editing magic uh i did just change the permissions on the permissions directory here if you notice now there is no r present we'll learn how to change that in a bit uh on this third grouping which means that anyone who is not the owner or part of this group cannot read the contents of this directory now it is a directory so what does that mean remember the r character means that you can list the contents of a directory if it's a directory or you can read the contents of a file if it's a file well i'm elvis still if i try an ls that permissions folder i can't i can ls any of the others i can ls music i can ls desktop but when i try permissions i can't do that because once again we no longer have an r present there but if i switch back to being cold now i'm cold we can see i can ls permissions no problem because we have an r in that first grouping which is the owner's permission so i can read all right so that's our first type of permission read permission if there's an r present here here or here that means that either the owner members of the group or everyone else can read next we have this second slot which is for write permissions so a dash means no write permissions a w means write permissions so for a file that means that we can modify the file and for a directory this means that the contents can be modified you could change files you could make a new file for example you could rename but this actually only takes effect if the executable attribute is also set which is that third piece here so let's just focus on files so if we have a w present that means we can write to a file so here we have ilovekitty.txt the owner is cult there's a w there right here's that first group or i shouldn't say group but the first chunk 123 for the owner i can write to that file uh i can echo into it let's just do echo meow into i love no i need uppercase l no problem i'm cold i can do that if i cat it out we see it has meow but now if i switch back to being elvis put elvis's new hacked password in there i am elvis here if i as elvis try and add to that file if i try and open it with nano if i try and echo something into it well elvis is not cult so these permissions don't apply not part of that group parallels so these don't apply but it doesn't matter anyway because it's the same as the permissions for everyone else what we see here is that everyone has read permissions but no write permissions so i cannot write to that file if i try to echo um i don't know hi from elvis into i love kitty permission denied i cannot write to that file but i can print it out or read the contents because once again we have that r right there so i'm elvis that r applies to me i'm not the owner i'm not part of this group we have read but no write permissions and then what about this third slot here so that third slot is either going to be an x or a dash if it's a dash it means no execute or executable permissions if it's an x that means we do have executable permissions so what does that mean well it's easier to understand in the context of directories if we have a directory you'll see actually there's a lot of x's on directories by default everyone has x executable permissions on folders all that means is that we can cd into a directory so it doesn't matter who i am right now let's take a look at the wildlife directory there's an x present for the owner group members and for everyone else so i'm currently elvis i can cd into wildlife no problem i'm in there now if i behind the scenes get rid of that x i'll do it right now there we go there is no x there anymore we're about to see how to do that i'm going to go back to being elvis if i try and cd into wildlife now cd into wildlife permission denied we don't have an x there and for elvis that means he can't execute you cannot cd into that directory now members of the group parallels in this case anyone who's in that group can and then the owner cult can cd as well because that's the owners execute the group members execute and then everyone else is execute so normally you'll have x present all over the place for directories but i just removed it here to show you the consequences i'll go back to being cult and i can cd into wildlife no problem now it's a little trickier to explain what it means when we have a file for files that have an x present here so if i were to show you a couple of examples like this right here these permissions means that an owner has read write and execute permissions for this file no one else has any access whatsoever what does that x mean on a file it means that the file can be treated as a program and can be executed so if you write your own scripts you write your own programs and you want them to become executable you need to have that x there so we're not going to see that right now but i'll show you some examples of things that are executables if we cd back a couple of times we go into bin what we see here if i do an lsl are lots of x is present but these are actually files so these are programs as you can see so there's a lot of programs here uh once again i'm in slash slash bin rather is my path name right now binaries this is where programs are stored so uh if you know here's touch for example that is a program that i can run obviously we use it all the time or if we find let's see is there another simple one in here here we go here is echo so our echo program that we run that command it's defined right here it's a file it has some code in there and as you see it's x x x that means we can execute it as a program we can actually run it okay so what i want to demonstrate is a little odd but there's a program called ncal it gives us a calendar uh i'm going to make it so i can't actually execute that and then i'm going to undo it but i'm not going to show you how just yet i'm just going to demonstrate so if i do an lsl on ncal in slash bin here it is we see the owner which is root members of the group which is also root and everyone else has that x present that means anyone can execute this i'm going to change that so i just did that now i do ls dash l on ncal again this program no longer has an x right there it did just a moment ago now this means that only the owner which is root i'm not root only members of the group root which i'm not a member of can execute everyone else does not have that x there no executable permissions on this file so now if i try and run ncal oh permission denied i can't run that script i cannot use that command anymore because it's not executable so that x is very very important uh and you probably wouldn't go around removing those but just to show you what the significance is so to reiterate if there's an x present for a directory that means you can cd into it but for a file that means you can execute it so i'm going to undo that we're going to learn this command that i used to do it it's called chamod change mode but now if i run that lslncal i have that x back and now i can run ncal again okay so now we're going to learn how to use this command to change those permissions i just want to run through one more time what these three things mean well there's ten things i guess the first is a dash for a file a d for a directory an l for sim link and then we have three groups of three each of these groupings has three places the first is either an r or a dash and r means read permission is present dash means no read permission w write permission a dash means no right permission and then the final slot is for execute x means it's executable no x a dash means you don't have that permission so the first three read write execute are for the owner of the file or folder the second three are for members of the group that owns that file or folder and then the final three are for everyone else so what does this mean a little quiz here uh what do these this exact set of attributes mean first of all are we talking about directory file sim link answer for your moment or think about it for a moment answer out loud if you'd like we are looking at a file and we can see the owner whoever that is has full permissions read write and execute members of the group owner have read writes but no execute permissions and everyone else only has read permissions okay so now let's talk about how we actually change these how do we use this weird chamod to mode however you want to pronounce it command it first of all stands for change mode and it is the tool it's the command we use to alter those permissions and here's the basic syntax there's actually two main ways of using chamod of specifying the permissions and the first i'm going to show you is the easier one when you're starting out so we have the command chamod change mode and then the mode meaning how we want to change the permissions who are we changing permissions for what are we changing read write execute and are we adding or removing that permission and then finally the file that we're trying to change so this is where it gets a little tricky the first thing we specify is the who we have these different letters u g o and a so u is how we can change the the file permissions for the user which is the owner of the group it's a little confusing because o is actually for others anyway if we have u that means we're changing permission for the user g is for members of the group o is for others and a is for all of those then we have a minus sign a plus sign or an equal sign so a minus sign will remove a permission a plus sign we'll add a permission we'll come back to equals and then finally the permission that we're trying to change read writer x execute so let me just show an example to make it a little clearer here if we have g plus w what we're saying here is four members of the group add so plus the right permission so here's what it looked like before for group r dash dash after we run this it's now r w dash so we added that w there but only for the group here's another example here we have that right permission for uh owner and for group we have an a and that means all so everyone all three of these chunks minus remove the w the right permission so we go from having right here and a right here to now having no right permission no right permission and no write permission so let's show an example why don't i go back to my home directory as colt and let's see i've got this permissions folder inside of it i have only colt coltscanread.txt why don't i change it so that how about everyone so all of us can read the contents of this file so it's not going to have a great name anymore it will still be only colt can read but that's not going to be true so this is what it looks like at the moment i'm going to run chamod change mode and then i'm going to say everyone so a all i want to add the read permission so add the read permission for everyone and then the file lsl we now see everybody has an r so this means as you know if i go back to being elvis i can read the contents of that file now whoops only why don't i see it here oh jeez because elvis does not have permission to do anything in this directory remember if we back out one level here we are this permissions directory we can see there is no read attribute present so elvis can even list the contents of that folder so why don't we add that r back in with what we know what i want to do is change mode and i'm going to switch back to being colt change mode and what i'm going to do is change it for other so that's what the o if i go back here o means the world or others anybody who's not the owner or part of the group so here's permissions here everyone already has an r group the actual owner but i want to add this r back in so i'm going to say for others plus r add the read attributes for the permissions folder oh i'm in the permissions folder oh come on i gotta back out okay let's try that again for others add the read permission to the permissions directory here it is right now i'm gonna hit enter lsl and now what do we see on permissions there is an r present that means if i go back to being elvis i can now cd into permissions and finally i can read the contents of only colt can read because now we have permission to read both that file and the parent directory now go back to being colts and what i'm going to do next is show let's see how to revoke permission so we use the minus sign so i'll revoke let's go back to um well let's go back into permissions here's that one file i'm going to revoke the read permission for everyone except for me so i'm going to do that here so i'm going to do change mode why don't i revoke it for the group first to show that so i'm going to say group g minus r for the group members of the group remove or revoke the read permission on only cult can read and now you'll see there's no r present here i could do the same thing but remove it for others lsl we can see it's now gone now i can also do multiple at once so if i did this o minus rwx this means others remove read write and execute permissions so if i want to add how about full permissions read write and execute for everyone i could do chamod and then for everyone all i want to add read write execute on only can read and there we are our wx our wx rwx so it's now executable it's showing up differently it isn't actually going to do anything if i execute it because well it's not a script just a text file but anyway that's kind of the basics if i wanted to remove execute permissions for everyone you know i could do jamaad all minus x and now we we have rw dash rw dash rw dash so that's a quick intro to using chamod with this syntax now there's actually another syntax that we can use that is quite a bit more intimidating when you're starting out and i'm just going to alert you to his existence we can use octal notation which is base eight for these three digits of binary correspond to a file mode so zero zero zero is going to be dash dash dash one one one is rwx one zero zero is r dash dash so that's the binary here but each one of those in base eight is a single digit zero through seven it can be a little complicated to understand but as you can see here if you saw chamod seven five five what that tells us is for that first chunk seven is one one one meaning rwx five is one oh one right it's binary uh three binary digits is a single octal digit anyway our r dash x is what we end up with there i know it's kind of confusing it really is trust me if i have to teach this uh but there are some modes that are more common and you'll get used to them if you encounter them but you can always use the longer sort of englishy syntax that looks like this you know with the letters and plus or minus rather than having to worry about base 8 craziness but that is something you'll see now what about the equal sign i said i'd come back to this the equal sign is basically a way of saying in this example a equals r set for all set it to be only read permissions and nothing else so it it's going to reset every other value so let's see an example of this in action we just have this only can read file which is actually not accurate but if i do want to make let's say i want to i don't know i'm grasping at straws here uh i'll make it so everyone can read and only read so no write permissions no execute what i can do is jamaad everybody all now instead of doing plus read or minus w because minus w would subtract right except get rid of that get rid of that but if i do equals read what this says is that the only permissions that we're having ignore everything else and get rid of them is read for everyone for all so lsl and there we go everyone can read but nothing else if i instead if i just did a equals i can also do multiple like rw or rwx that's a long way but i can give everybody permissions and then if i went back and reran this so that it's equals r again that means only read get rid of everything else so we'll go from rwx rwx rwx to instead rr and just dashes for the read and write permissions all right so i know this is a pretty complicated topic uh there's a lot to cha mod not to mention just pronouncing it oh i guess i did not show we can also change permissions for multiple who at whose at one time so if i wanted to add write permissions only for the owner and the group owner i could do this chamod so the owner is you the group owner is g and then plus w for right and now we can see the owner and the group owner has that w there so we can have multiple values on the left hand side of that whatever plus minus equals and then again we have the octal notation which you'll see um you know 777 means rwx for everyone full permissions uh and you can spend more time learning this if you really care about it it is something you'll see in the wild but for now all i care about is that you understand the basic concept of these permissions and all these different different letters here rwx and dashes what does that mean what is the significance and then remember if we go back we talked about the owner and how we can change a file's owner using tone we can also use it to change the group that owns a file and then we can change individual attributes using chamod change mode that's a lot well we made it to the end we covered a ton of different commands maybe it's a little bit overwhelming maybe you're a little tired of seeing all the scrolling text go by but remember the point of all this is not to memorize and just become an expert on every single command overnight what really matters is being able to put the different pieces together to use the correct command when you need it read the man pages figure out how something works change what options you're using and just kind of duct tape it together when needed obviously some of these commands become second nature lscd touch make directory rm that sort of thing you get pretty comfortable using different expansions and redirection and piping and combining different commands but then some of these more niche commands certainly i wouldn't expect you to just remember and and honestly in preparing this sort of course i always have to look at the man pages and remind myself of all the different options and how they work so thanks again for joining me and remember if you are interested in my bootcamp you can find the link in the description and lastly thanks again to flavio for the excellent handbook all right well it was nice uh i guess recording this in a dark room and editing it in an equally dark room uploading it to youtube and being alone in this whole process but honestly who needs friends or companionship when you have the most sensual command man touch that's really all i need okay i gotta go get my cat to the vet