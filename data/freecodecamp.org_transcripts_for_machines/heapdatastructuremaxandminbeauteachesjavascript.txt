a binary heap is a partially ordered binary tree which satisfies the heap property it has some similarities to a binary search tree except the order is a little different each node has at most two child nodes the heat property indicates a specific relationship between the parent and child nodes you may have a max heap in which all parent nodes are equal then or greater to the child nodes so you can see the the biggest numbers on top and the smallest numbers are on bottom or you may have a min heap in which all child nodes are greater than or equal to the parent nodes so the child nodes are the biggest ones and the parent nodes are the smallest ones the order between child nodes on the same level does not matter so you have 10 6 and 12 here here we have 5 6 and 1. you can see that it goes from a small number to a big number to a small number the order doesn't matter if they're on the same level binary heaps are also complete binary trees this means that all levels of the tree are fully filled and if the last level is partially filled it is filled from left to right so if you see the example down here so here's level one then we have level two here level three level three is all the way filled level 4 is only partially filled because there's nothing over on the right side here but you can see it's filled from left to right binary heaps may be implemented as tree structures with nodes that contain left and right references like what i showed in my binary search tree video however heaps are more often implemented as arrays this is possible because of the partial ordering according to the heap property we can just compute the parent child relationship of the elements now this will make a lot more sense with this diagram here so if you see this array right here this is the array representation of this tree right up here the number 1 is 20 and that's the root you can see that right up here and then 2 and 3 are the child nodes 19 and 17 right here and now i want to pull your attention over to these equations up here so the left child is going to be i times 2 the right child is going to be i times 2 plus 1. let me show you what that means so if you look at 20 here which is at index 1 in the array also i should point out that there is no index 0. so when you're representing a heap you're just going to leave index 0 as null to make the math work out a little better so if we go back to index 1 well the equation for the left child is i times 2 so 1 times 2 would be 2. so yeah 19 is the left child and the right child is i times 2 plus 1. so 1 times 2 plus 1 is 3 17 that's the right child now let's say we go to number 13 here that's index 4 well if we go to the equation i times two four times two is eight so if you're index four and you go to index eight eleven yep that's the left child now if we start index four and we do the right child equation i times 2 plus 1 that's 9. so if we go to index 9 yep that's the right child here so that's how you can use these equations to find the left and right child from an array representation you can also figure out the parent so the equation for appearance i divide by two if we are on 11 that's index eight eight divided by two is four index four and this really should be floor i divide by two because you divide the index by 2 and then round down to the nearest whole number for instance 5 divided by 2 is 2.5 but if you round out it's 2 and then 2 would be the the index 19 here also you can see in this diagram that the last index is also the size of the heap size 10. this diagram is a max heap i'm going to show you the code for a min heap but in the same file down here we i also have the code for the max heap down here so you can check the link in the description so you can review this actual code yourself and you can review the max heap on your own but like i said we're just going to review the the min heap right now but before i show you the actual code i want to show you a visual representation of how it works when you're inserting and you're removing items from the heap those are the main two commands insert and remove and then there's one more i'll show you at the end but let me show you this representation here so you can see this is the array representation and i'm going to insert some numbers and you'll see them show up as a tree representation so let's see four you can see four goes at the top that's the the root node now i'm going to put in six six just goes down to the bottom there eight so as it builds the node one thing to keep in mind is that it's going to build one level of the tree at a time i'm going to put in 10 it's going to be on the very left side now so far i've been putting them in order but now i'm going to put in the number five here and when i insert the number 5 you're going to see this it's going to first go to the end of the array here you'll see the array which is going to first appear right down here and then it's going to move up to the correct position so let's see that so then as you see it checks what position to move it up to so i'm going to put in a few other numbers here see 16. three okay so you see it always puts in at the end of the array or the end of the tree and then it moves it up to the correct position now i'm going to just show one more where i put in one where it's going to put it put it down here and it's going to move all the way up to the top and it's a check one at a time to see if it has to move it up also another thing would just be removing when you remove you always just remove the smallest it's going to remove what's in index 1 which is always going to be the smallest and then it's going to pop the last node to the first node and then it's going to sort them so let's see how that works so did you see that so it moved the last node to the first node and then it has to keep checking and keep moving it down until it gets to the right position so let's move remove three okay so now let's go to the code and you can see how that works in the code so before we insert anything you can see that we've created a heap with an array that just has one item and it's the item null at index zero so when we insert something we pass in a number and we're going to push that number on to the end of the heap so if you pass in the number three there's going to be index zero is null index 1 would be 3. now if the length of the heap is more than 2 that means there's more than one item in the heap if it's less than 2 there's one or zero items in the in the heap and that makes things really easy but let's say it's it's a more than two so we're going to let the index equal heap dot length minus one so that means we're finding the last index in the heap while heap at that at the last index is less than heap and then see this equation right here that is the the parent equation so now we're saying if the last item in the the array which is the item we just inserted right here if the last item of the array is less than its parent well if it's less than its parent we're going to have to move it up because the smallest numbers have to be at the top in the min heap so if the index is more than or equal to 1 that means if we haven't reached the root node then we're going to do this now this is es6 destructuring syntax which just means we're gonna switch the node we just inserted with the parent node we're gonna we're gonna switch them so here is the parent node here is the node we just inserted and now we're gonna switch them so the node we just inserted is going to be first and then the parent node is going to be next so it's just a way to swap them for more information about the es60 structuring you can check out my video about that topic so if math math.floor index divided by two is more than one this just means if the parent node is not the root node because remember this is the equation for the parent node one is the index of the root node so if the parent node is more than the root node then we're going to set the index to map that four and x divided by two that's the parent node which if you remember up here we just put the number we passed in into the parent node so now the index is still going to refer to the number we just passed in because that number has went into the parent node and so now we're going to set the index to that node and since this is a while loop we're going to keep going through this and we're going to keep switching the the node to its parent node as long as it is smaller than the parent node else break so once it's not smaller than the pair no we just get out of this while loop and that's the insert so let's go down to remove it's a little more more code but it's some similar concepts so we are always going to remove the the top node the smallest node so we're going to let the smallest equal heap 1 so that just means that the first node and the array is the smallest node so that's the easy part the hard part is rearranging the array after you've removed that node so if heap.linked is more than two that just means we have more than one node in in the tree we're going to set the first node in the tree which remember was the smallest node but we're going to set this to the last node the last node in the array now gets moved to the first node in the array now we're going to heap dot splice keep that length minus one this just shortens the array by one so we just remove the whole the last index of the array completely since we've already moved that to the first index if heaped.length equals three that means there's only two numbers in the the tree and that makes things really easy just if one is bigger than the other then we just switch them this is the destructuring syntax again so if the first one is bigger than the second one then we switch it so the second one is bigger than the first one and then we just return the smallest if there are more than two nodes in the array that's where it gets slightly more complicated so we're just gonna set the index to equal one we're gonna set the left equal two times i and the right equals two times i plus one remember that was just the equations from up up above the equations right here we're just putting them into our formula down here now technically you would not need to put this equation here since we know that i equals 1 you could just put 3 here you could just put 4 here but this is just so you know we're using the equations from above so we're remember one is the root note so we're starting with the root note so while the root note is more than or equal to its left child or the root node is more than or equal to its right child we're going to do everything in here that means we're going to have to basically move it down and keep moving it down until we get to the appropriate spot so if the the left node is more than the right node then we're going to switch the root node with the left node this is the destructuring syntax again so we're going to just swap the nodes so for instance we would be swapping if we're on this node and this one we just swap those two nodes and then we're going to set the index to the left node so we're going to set the index to be the node that was at the top node but has now been swapped else that means the right node is less than the left node we're going to switch the node with the right node so we're just going to swap with the right node and then we just set the index to be the right node so the the node just moved down a little bit and then we set the index to point to the node that we just pushed down a little bit and then we have to set the new left and right node so we would set the left and right node to be the left and right of the the one we just passed down and then if the the left child or the right child equals undefined that means we're at the very bottom of the tree so we can just break out of this while loop and if it's not undefined we just keep going through until we find the place where the node that we're moving down the tree is not more than equal to the left node and is not more than or equal to the right node else if if the length equals two that means there should be only one element in the array so we just cut off the last element else we return null that means there were zero elements in the array to begin with and then we're just going to return the smallest element which is just the element we just set up here the last thing i'm going to talk about is this now a common use case for the heap data structure is for heap sort this is one of the most efficient sorting algorithms with average and worst case performance of o of n log n heap sort works by taking an unsorted array adding each item in the array into a min heap and then extracting every item out of the min heap into a new array the min heap structure ensures that the new array will contain the original items in least to greatest order so this is the function that you would use to do that keep sort the hard part is creating all the code we just already went over and this is just going to use that code so let result equals new array well heap.link is more than one we're going to do this.remove so we're going to remove the element on top of the tree and we're going to push it onto the result and we're going to keep doing that until we've removed all of the smallest elements and push it onto the result and it's going to put the elements in order well that's all i'm going to talk about for heaps feel free to check out this code and create your own heap and and add some items and remove some items just to see how it works thanks for watching my name is beau carnes don't forget to subscribe and remember use your code for good