develop as a 2d cross platform free and open source game engine. Wesley and Max teach this course. They're both game developers and teachers. And this course is the best way to get started with G develop. Hey there, my name is Wesley, and this is Max. And we're going to take you from zero knowledge to releasing a game with G develop. In this video, I'm going to start us off with the general layout of G develop. When you first download G develop, you'll be met with this screen. From here you can open an existing project or start a brand new one. When you click on create a new project, you'll be given a bunch of options for starter games and examples. We're going to skip all those for now and just go straight for a blank game. When you start from scratch like this, you need to add a new scene, which is where you'll actually make the game. To keep things organized, it's important to make sure that you give your scenes appropriate titles. Since we opened a blank game project, we need to open some of the panels. Up here in the top right corner, you'll see some of the options. You'll also have the ability to add a grid to your game project to help organize things. And to change the level of zoom. Let's start with the object panel. This is where you're going to import and manage your game objects. Everything from your characters to your tiles to your particle effects will all show up in this panel. We'll start by creating a sprite the most commonly used game object, you should make sure to give this a title that makes sense. Click add an animation, find the art that you want to use, and open it, be sure to click Apply to save any work that you've done. And then you can just drag the object straight from the panel into the game space. You can drag to click on multiple objects at a time and use the middle mouse button to move the scene around and zoom in and out. The next panel over is for object groups. It's a useful tool that lets you target a group of objects as opposed to each individual one when you want to do things with them. For example, I could have a bunch of parts and potions and food items and call all of them healing items. And then I can make a single event that makes it so that if the player is in collision with one of those healing items, they get healed, instead of making a different event for every single item in the list. Next up is the Properties panel. When this panel is open, and you click on an object, you'll get to see their position, Z order angle, and so on. And from this panel, you can actually control all of those things, moving them around changing their angle and changing the Z order, which is what decides whether an object is behind or in front of another one. And that's a good transition to talking about layers. With the Layers panel you can create different layers to place objects on. So you can create a foreground mid ground and background as well as UI layers and menu layers. Typically, you'll put most for game objects on the base layer, and have that camera following the player while having all of your UI objects and menus on different layers where the camera is stationary. From this panel, you can also add effects to layers, edit their properties, and toggle their visibility. Back to the Properties panel. You can also use this panel to resize objects. But be careful while doing this because changing an images resolution can really make it blurry. The last panel is for the instance list. This can be a useful tool for finding where things are in your game project, especially once they've gotten so big that you can't tell where things are anymore. You'll notice these window tabs up top, the start page and then your main scene page where all of the game building is done. And then that scenes event list where all of the black magic happens. But we'll get to that in another video. Up in the top left, you can open your project manager. And in the game settings, you'll find properties. This is where you'll do things like change the game's name, give it a version number, a package name an author, login with your profile, and change the games resolution, which is something you should definitely do because very few devices are defaulted to 800 by 600. You can also tell the engine here how to expand the game to meet the size of the screen that it's in, as well as tweaking the max and min frame rates that the game will run at. for mobile devices. You can choose whether the game runs in portrait mode or landscape mode, and then you can turn on and off anti aliasing. The only real reason you would turn this feature off is if your game uses pixelart. And if your game is running ads, then this is where you would slot in your app ID. You can also edit the game's initial loading screen from here. The rest of the project Game Settings has global variables, which we'll get to at another time icons, which are your desktop and mobile app icons and resources. Which is where you can go and see all the assets that are in your game file. There are a few options here that you might need, like when individual objects are blurry or if an object or sound effect is stuttering before it loads in. The rest of the Project tab has the scenes that we've already talked about external events and layouts, which we plan to explain in another video. And then functions and behaviors. And if you wanted to use the prebuilt extensions that include things like giving the enemy's health and different movement systems, then this would be the place to get those. And we're going to tackle that in another video as well. Let's close this project and open one of the starter games. You'll see that all of the games objects have loaded into the objects panel, as well as the events and the game itself. Now in the top left corner, the two last things to talk about are the Export button, which is what you would use when you're finished building your game and you want to release it to the public. And the Preview button, which is what you would use to play test your own game. When you click this button, it will play from whichever scene you're on currently, it'll open up a window, and I can just play one last thing that before you go. This is something that I didn't know about. Even though I've used the engine for over two years. And to see all these panels, they can all move. Now this isn't revolutionary. But this does allow you to customize your workspace and set it up so that it works best for you. Though this is probably not how the developers top people would use it. Next, I'm going to go over the object types in G develop. We start off with the basic scene. And on the right hand side you'll see the objects that have imported into the game. We're going to click on add a new object. And from here you're going to see all the options. We're going to begin though with the most commonly used object which is a sprite, which we already have labeled in the scene as the player. Sprites are able to have different animations where you add in each frame of the animation. Pick the speed that the animation plays at and decide whether or not it should loop. You can also label animations to make them easier to use later. To add more animations to a sprite, just click add an animation. Down here in the bottom left corner, you can edit the sprites collision mask, you can also edit points that are on the sprite on the bottom left hand side as well. Every object can be given behaviors and effects. Behaviors are prebuilt game logic that you can use to help make your game faster. So if we give the player character the platform or behavior, you can see there's a bunch of numbers in here that you can tweak. But you can leave those as default if you want to. And then if we give the player character, the drop shadow effect, we get a character that has a drop shadow, and one that can move when you press the arrow keys. A quick side note for the platformer behavior. If you don't give the ground that they're standing on the platform behavior, then your character will just fall out of the screen. Speaking of the ground, let's move on to the next object, which is a tiled Sprite, we use tiled sprites, because if you grab a regular sprite and try to change the size, it will scale, whereas tiled sprites will duplicate instead of changing size. So you can use this for a bunch of different things like level design and UI. The next object type is text, you can change the size, color and font of this object, and then write in whatever you would like to to fill it in. And then you can use the event system to change what's written in this object during your game. Next up is the particle emitter, you can use the particle emitter for a whole range of things. But the two most important parts are particle kind, which come in point line and texture, texture being one that you can import yourself to create whatever kind of particle you want. And the number of particles in tank. If this is set to negative one, the particle emitter will stay there forever in your game. If it's set to a positive number, then it will use that many particles and then stop. You can either place them in scene to start when the scene starts, or use the event system to spawn them where we need them. Next is the nine patch panel Sprite, you import an image. And then it's easiest to show you this from the wiki. You put the size of your margins into the nine patch panel Sprite. And then it will expand in the way that you see on screen, maintaining the ratios of the outside edges. And this can be used for dialog boxes, UI design, and a bunch of different things. The shape Painter is also easiest to explain from the example in the wiki. Basically, this can be used to create a range of shapes for UI way points, selection tools, and things like that. The text entry object is used to enter text, you create the object, put it in scene, and then using this simple event and the Hello World text object that we made earlier, the game will record and display what I'm typing into my keyboard. Next is the BB text, which is very similar to the basic text object. But you're able to do more things with fonts and effects. If you don't need to use these effects, you're better off just using the basic text object. The light object can be used to create some dynamic shadows, I just create the object, place it in scene, and then give the player character the light obstacle behavior. And then you can see that the light is being obstructed by the players collision mask that we set up earlier. The last object type video is pretty straightforward. You just pick the videos, opacity, volume, and then import the video, it's best to use an mp4 For compatibility reasons. And then you can control the stopping and starting of the video through the event system. Now that that's out of the way, we can start talking about the event system will begin with a scene that I've set up and go into the event sheet. From here, we can add an event. And we'll zoom in to make it more readable. So the easiest way to think of the no code system is to think of if then, so if this side, the condition side is true, then this side, the action side will happen. So I'm going to set up a simple event, I'm going to search for key pressed, and then type in D. And then for an action, I could search for this again. But I can also click on an object, and it will give me a list of things that will only relate to that object, I could search down this list to find the things that I want. But because I know what I want, I'm just going to type in force and select Add a force is going to give it a positive power in the x direction, and then zero in the y direction. And I'm going to leave it at instant because an instant force will only apply while the condition is true, whereas a permanent force will stay with that object permanently. And now when I press preview, and hold down the D key, the player object will very slowly move to the right. Back in the event sheet, I can add more events by clicking here, here, or by right clicking and selecting new event. Now I can drag this event over and turn it into a sub event of our original event. I'll add the action, rotate, select the player and give it an angular speed. I'm also going to increase the speed for the apply force event. And now when I press D, the character rotates and moves faster. What's happening is the main event is being checked to see if its conditions are true. And if those conditions are true, then it will move down and check the sub events. But if we drag this event over and turn it back into a regular event, it has no conditions. So when we preview the game, now, the character will be rotating constantly. But still, when I press the D key, it will move over. I can copy and paste existing events rather than just constantly creating new ones. And then I can modify this to make an effect a different object. Realizing that this might be a little hard to see, I'm going to create one final event, I could click on other conditions and manually search for the condition that I need. But since I know what I want already, I'm just going to search for at the beginning of scene, which is a condition that only triggers once at the beginning of the scene. And then I'll add zoom camera and type into. You can delete individual actions and conditions by selecting them and pressing Delete as well as entire events. And then you can press Ctrl Z or ctrl y to undo or redo anything you've done. You can right click an event and move it into a group groups are useful to help organize your project. Giving these appropriate names is incredibly important. There are a few other things that you can add to your event sheet like comments, which will help you label your game events to remind you of what each one does. A couple of the more useful event types that you can add are for each object, which is an event that will repeat every frame for every object of that type in the game. So if I have 20 player objects in the game, then it will repeat for all 20 player objects. Another commonly used event type is repeat, which, as the name implies, is one that you can set up to repeat X number of times per frame. And speaking of per frame, the engine reads the event list once per frame. If you go to the project manager, you can see that the game is defaulted to force the game to run between 20 frames per second and 60 frames per second. You can edit those if you need to. But I would generally leave this alone. Let's quickly talk about organization. And I'll show you why it's important after if we open up one of the starter games that you can use. You can see how nicely set up everything is with comments and sub events set up to make sure that it's easy You'd understand at a glance, rather than having to read every event to see what each one does. But you can further organize your game using groups to group everything together, you can then pick a color for the group header, and comments. To show you why organization is so important, I'll open up the events for a game jam game that I made. If you don't organize your events from the beginning, you'll find it getting out of hand really quickly, till you get to the point where it's almost impossible to fix anything in your game. Because you don't know where the event is, you can use the search bar to try to find it. But sometimes that's just not enough. And now that we have an event complicated enough to show you how this works, I'm going to really quickly go over how the engine checks events. So every frame the event list is checked. But it checks the event list from top to bottom, checking each condition from top to bottom. And then if that condition is true, then all of these actions will happen from top to bottom. Now that you know the basics of the event system, I can go over all the tools that G develop has integrated into the engine to help you jump right into making games. When you open G develop, you'll be given the option to create a new project or open an existing one. If you click on Create new project, you'll see a list of starter games and examples that you can learn from and build off of, which are all under the MIT license. Which means that you're free to use anything here for your projects that are just for fun, or commercially. If we go back to these starter games, and click on one, you can see that it's loaded in all of the objects and events required for this game. If I click on Preview, I can just play this game as is. Most of these starter games are just the base logic you need for that type of game. So they'll usually only have one example level in them. But you can build on those if you want to. If we go back to the game that I was using in the previous video, I can show you behaviors, behaviors or pre built logic that will help you make your games faster. You'll see that there's a bunch of these that come with the engine. But we also have community built behaviors created by other game developers that you can find by clicking here and searching those behaviors. A quick side note here, these community built behaviors are the same thing as community built extensions, the only difference being that they're filtered to only show you the ones that apply to the object. If you'd like to see the full list of extensions, you can find that here. If we go back to the default behaviors, we can click on top down movement and turn off rotation. And then we have a character that'll move around on screen when I press the arrow keys. So now if I go back in, I can add another behavior. And I'm going to pick draggable object. So now I've got a character that can move around with the arrow keys. And I can drag it around with the mouse. But now that I'm done with those, I can delete them. And now we'll talk about Pisco, the engines built in image editor. I've mostly used this to correct the orientation of an image by flipping it or rotating it. But you can use this to make brand new images or to edit existing ones. Next up is the sound creation tool. J FXR. If you put in the action play a sound, you'll see a prompt that will let you open up J FX are a tool that can be used to create a range of different sounds by manually correcting sliders, or by randomizing them like this. Next up is the engines Asset Library. If you click on add a new object, you can click here to create one from scratch. Or you can search the asset library, which is currently a manually curated collection of art assets that you can freely use in your games. When you click on an asset that you like, you'll be able to see which artists created it and what license the assets are under, you can click on the license to be brought to a page that will explain the license to you. The CC zero license for example, means that you're allowed to use these assets in your game, whether it be commercial or not, without having to credit the artist. Other assets in the library, though, might be under a different license that would require you to credit the artist. If you like a particular piece of art, you can click on the name of the artist and it'll bring you to more works by the artist. This for example is Kenny art, which is an artist whose work I'm actually using right now. So to continue using their art, I'm going to grab this background tile, click to add it to the game. And then I'm going to create a background layer and put the image on it. Making sure to put the background layer below the base layer so it's behind it And tada, my game now has a more interesting background. So those are some of the tools that G develop has brought together to help you in jumpstarting the game making process. You've got starter games and examples built in and community built behaviors. Pistol for image editing, J effects are to help you with your sound effects, and the assets library. So if I give the player character, the platform or behavior, give the ground the platform behavior. And we'll give the B the physics engine 2.0 behavior and then for giggles will give the ground the physics behavior as well. For the next portion, Max is going to take over and explain how variables work in G develop. So variables are used whenever you want to store some information about your game. For example, maybe the players health or the player score. And she developed a variable can live in one of three places. It can live in the scene, which is useful for things like a level score that is explicitly tied to a particular scene. It can live on the object which is useful for things like enemy health that are tied to particular objects, in this case enemies, or it can live globally, which is useful for things like say a player selected username that needs to be accessed from everywhere within your project. Let's start by taking a look at scene variables. As you can see, we have here a basic platformer. However, when we go to pick up a coin, the score does not increase. We can fix this using variables. Start by going to the scene properties and then clicking on the Edit scene variables button. Here you can view all of your seen variables and also add new ones. We'll start by adding a new score variable and setting its initial value to zero. Then when the player collides with a coin, we'll add a new change a scene variable action which adds to the variable score the value one. Then we add a new action without a condition which modifies the scene text object, we'll use the variable string function which allows us to access a scene variable from anywhere and then specify the score variable. And then finally put the text score in front using the concatenation or plus operator to join the text with the variable. Sure enough, our score counter is now working as intended. Next, let's take a look at object variables. Right now our slime enemy does not move and what we'd like is for it to move back and forth between these two markers. We can start by opening the drop down menu on the slime object and selecting the Edit object variables option. This will give us a list of all of our object variables on this particular object, we can start by adding a new direction variable with an initial value of left. Then in our event sheet, we can add to the slime a text of an object variable action, which sets the direction to left. We call this one the slime is in collision with the left marker. And then we can do the same thing for the right as well. We can then use the text of an object variable condition to test the direction variable. When it's left, we'll incorporate our game logic for moving the slider to the left. In this case, adding a force and setting the flip state. And then we can do the same for the right direction as well. And now our slime is no longer stationary. Note that while we've written all of the events ourselves for this example, to demonstrate variables, there's plenty of great behaviors out there to do this for you. We should have a video on behavior soon if that is foreign to you. Finally, let's take a look at global variables. Let's say that our platformer has multiple levels. If we look at the score as we transition between these levels, you'll see that it resets. While this may be what we want, we also might want more of a global score that stays the same when we transition between two levels. We can start by going to the project manager where we will find the global variables button then we can add these For variable much like we did earlier for the scene now all we have to do is change our scene variable action to the corresponding global one and then replace our variable string function with the global variable string function. And now, sure enough, our score will carry on through seeing transition. Very nice. Now that we've gotten through variables, I can show you the expression builder. So to begin with, I'll show you where the Expression Builder is, we go to the event sheet and pick an action, we picked the be enemy and select Rotate. And trust me, the engine can do a lot more things than just rotate an object. But it just seems like the thing that I picked the most. If I put a one in here, the be enemy will rotate at an angular speed of one. But if I go to the expression builder here on the right, you'll see there's a big list of things I can search from. These can range from the size and width of an object to the distance between two objects, which I'm going to use now. You'll see that I've multiplied it by one. And that's just to show you that this basically works the same way as an algebra equation, when you're sticking to numbers. So you can add, subtract, multiply, divide, use brackets, the whole nine yards. And then if we go back to the main scene, and give the player object, the draggable object behavior, and we press preview, we can then drag the player closer to the B. And as we do that, you can see it's slowing down. And that's because the distance between the B and the player object is getting smaller. So it's rotating at a slower speed. But if we move the player away from the B, it speeds back up again, because it's getting further away. So the number is bigger. Now let's get rid of that. And I'll show you an actual game related example. So I made these objects earlier, we have a hard object, that's a sprite, and they hurt object that's a tile Sprite. So if we put the tile sprite into the scene, within the camera's default border, and then put it on the UI layer that I made earlier, then we can build this first event where when I release the left mouse button, one time, we'll create the heart sprite object at the x&y position of the mouse, then we'll make a second event with the condition if player is in collision with heart, and then we'll make the action to modify the object variable of the player. If we click on this tool button to the right will be shown this objects object variable list. And since it didn't have any, I'm going to click Add and give it an object variable of health, and then two as the number. So now when I click here, it'll show me my options. And I'll select Add, because what I'm trying to do is add to the players health, and one. And then I'm going to create an action that shows that the player's health has changed. So if I select the heart UI object, and select the width of the object, I'll select it to set to and then click on the Expression Builder tool, search for object and select objects variable. Select the player as the object. And you can see I can click here again, to display this objects variables. I'm going to select Health. And because I know the size of the heart that I made earlier, it's 64 pixels by 64 pixels, I'm going to multiply this width by 64. This is only going to work because it's a tiled Sprite, if I pick the regular heart object, which is a sprite, it would just get all squished up. Now let's move this into its own event. So it's checking this every frame. And then as a final action, we're going to add, delete the heart. And just to show you that the player doesn't have to be the thing that gets the platformer controls, you can literally put these behaviors on any object, I'm going to put it on the heart. So what's happening here is that each frame we're changing the heart UIs size to match the player's health. And every frame that the left mouse button is released will create one hurt object at the mouse position. And every frame that the player is in collision with a heart, it will add one to the object variable health of the player object, and then it will delete that hurt. So now if we press preview, you'll see the health UI is up at the top showing two hurts because it's expanded to two times 64 Because the players object variable health starts at two. And now if I release the left mouse button, it creates a heart at the x&y coordinates of the mouse. And it does this every time I click. If I drop one directly on the player, you'll see that it's added one to the object variable health because it's being displayed up top and it will keep adding health as long as they keep giving it hurts In the next portion, Max is going to go over extensions. You'll see here I've made a fairly simple dungeon crawler with one enemy and one piece of treasure to find. As it stands, though, our game leaves a lot to be desired. For example, maybe we want to be able to hold down our mouse and shoot at a fixed cooldown rather than having to click a button each time. Maybe we want a smart enemy that can Pathfinder around walls to get to us, rather than just running into them. And maybe we'd like the one to point at the cursor. For a more interactive gameplay experience. We could try to implement this functionality ourselves, or we can use functions and behaviors known more broadly as extensions. Extensions allow us as game creators to spend less time reinventing the wheel and more time actually making our game. As an added bonus, you'll find that using extensions leads to a much cleaner event sheet, which will help a lot as your project grows. So let's take a look at how to use them. We can get started with behaviors by opening the drop down menu for an object and selecting the Edit behaviors menu option. You can then add a behavior with the added behavior button. And then you'll be presented with a list of built in behaviors native to do develop. There's also a plethora of community made behaviors available through the search new behaviors option. For this project, we'll select the fire bullets behavior and install it. And then we'll see it in our list of new behaviors, we can then add it to our object by clicking on it. And then we'll find the behavior properties here. These give us some more control over how the behavior will act. So in this case, we can set the cooldown when we fire a bullet. Now when we select our objects in the event sheet, we'll find that it's been basically supercharged with new abilities. In this case, our one now has a fire a bolt action, which we can use to fire bullets towards the mouse. Now, another problem with our game is that, well, our AI is a little bit more a than I, we can fix this by implementing pathfinding, which is just another behavior in our list, but with a behemoth of a behavior property list. We'll go over how to actually implement this in a future video. Finally, in addition to behaviors, there are also functions, which can be accessed from the Project Properties panel, followed by opening the function slash behaviors menu. This is where you can find community made functions as well as behaviors. As for using functions. Well, there are a lot like behaviors, but they're not tied to specific objects. They can do things like for example, align stuff in your scene, or in the case of this project, rotate a wand about a character and pointed at the cursor. looks much better now. But you think. Now that we've gone through everything that I consider to be the basics, we're going to build a game. More specifically, we're going to recreate asteroids. I won't be showing you how I'm creating these events, just the ones that I'm using, but I will be showing you what I'm doing. So to begin with, I'm going to be using this space shooter Redux pack. And I'm going to jump right into a blank game project. I'll create a new scene, and I'll create a sprite object named Player. For this example, I'm going to take advantage of the physics behavior that comes with G developed by default. And I'm going to start by leaving everything alone except for changing the gravity to zero, so that the object doesn't just fall out of the sky. So now we'll move over to the event sheet, and start with a player movement with the condition if the W key is pressed, and then the action, apply a physics force towards the angle the player is facing. And then I'm going to move the origin of the sprite into the center, so that we can use that origin point as the point where forces will be applied. And then we'll copy our condition for our first event, and then paste those for the A and D key presses. And then we'll apply a torque to the player object based on which key is being pressed. Take note, this is not just the rotate an object action. This is apply a torque. It's specific to the physics behavior. And I'm using this because I want to make sure that all of the forces are being applied using the same kind of rules. And now I have a character that spins out of control. The problem here is that the sprite isn't the wrong orientation. So I'm going to open up Pisco, change its orientation, and then save it. With that part fixed, I'm going to move on to firing bullets, using the conditions when the spacebar is released, and once. And as you can see, I've created the bullet object already. And since the bullet is a really bright color, I'm going to change the background of the scene to black, so it stands out better. And now for the bullet, we put the action create object and add a force and rotate object. But moving the Rotate action above the apply a force action, because we want to make sure that it's rotated before it starts moving. And the bullets orientation is off just like the players was. So I could go into pistol and change the orientation of the bullet just like I did with the player. Or I can add 90 degrees to the rotation and changes so that the players angle is the thing that tells it which direction to go. And after we tweaked the origin of the bullet, just like we did the player, it works just fine. Though I do have to change the Z order, so that the bullet spawns below the player and not on top. And that's the player basically done. Next, we'll make another event for the beginning of scene, where we're going to change the center of the camera to the zero point and change the zoom to 0.5. Changing the camera to the 0.2 so that we could easily do screen wrap. And zooming the camera out was just so that we would have a better scale for an asteroid game. Now let's add some asteroids will add in some animations and give them the physics 2.0 behavior plays a couple of scene. And we'll do that again with medium and small asteroids. And now because everything has the physics behavior, I can start knocking things around like marbles. And just like an asteroids, we're going to make it so that when you shoot an asteroid, it blows up into smaller parts. So we'll create a for each instance event where the object being picked is the big asteroid, use the condition. If bullet is in collision with asteroid, then we will create two medium asteroids, give them a random rotation, and then apply a force in whichever direction they're facing. And then we delete the original asteroid and the bullet. And then we do that two more times. With the only real difference being that the small asteroid doesn't spawn anything, it just gets deleted, we're getting pretty close to this being asteroids, we're just missing a couple of things. The most noticeable one is the screen wrap. So we're going to create a for each instance event. And for the object pick this time, it'll actually be the group everything. Because I put everything in one group, this games resolution is 800 by 600. And because we moved our camera to center on zero, then we can use this condition. If an object in the group, everything goes beyond 800 in the x direction, or goes behind negative 800 in the x direction, then it will have its exposition times find negative one, which will flip it to the other side. And then we just do the same thing for the y direction. And now we're almost there. The last thing that's needed for this to be a game is a failed state. So we're going to go to the project manager and look for the extension health. We'll add that to the project. And now we'll go to the player and select Health, giving a three as its total, and a five second cooldown until it can be damaged again. Then we'll create a tiled sprite and call it lives. Place it in screen into the default border of the camera, putting it onto the UI layer that I made earlier. And then we use the physics condition if the player collides with everything. Note that this will ignore the bullet because the bullet doesn't have the physics behavior. And then we'll add the action damage player from the health extension and then add an action to change the width of the tile Sprite. And then we'll copy that action and put it at the beginning of scene so that it modifies the width of the sprites at the beginning of the scene as well. And the one last thing we need now is for the players to die. This specific condition comes from the health extension, and then we'll delete the player. But on top of that, I'm going to create a text object called game over and put that on screen and have it hide during the beginning of the scene and show up again when the player dies. And that's how long it takes to recreate asteroids in G develop. The only real problem being that the game doesn't have any sound. And it isn't very much fun to play. It's technically a game, but it's missing all of its life. We need to add sound effects and screen shake and particle effects and all that stuff. So let's get started. For now, when the player dies, they just get deleted. So instead we're going to create a particle effect. To replace that. We're going to make sure that the ship has a minimum rotation and that there's only one particle in tank and we'll make sure to rotate the particles so it starts with a player stopped. And now we have a ship that kind of falls into space. And we'll use the second particle using some points to give it a little more flair. And we could definitely make our game over text look a little more impressive. So we're going to give it a custom font, this being the font that I use for everything developer related. And then if I give it the glitch effect from the effects menu, it will look like this, which is certainly an improvement. Next, we're going to create some debris for the asteroids for when they explode. And just like the ship, we'll be using the texture of the asteroids to make the effect. And doing this just makes it more satisfying to look at when the asteroids explode. A big problem with this game so far is the lack of player feedback. Specifically when you get hit, so we're going to go to behaviors, and add the flash or blink behavior to the project will slot that action into the event where the player gets hurt. And now you can see that the player flashes when they get hit. Another aspect of player feedback would be sound effects, something that this game really needs. So we're going to open up GFX there, randomize the sound effect until we get something that we like. And then title it laser fire and save it. You may want to put it in a variable for the sound here, but I'm just going to put it in 150. For now, for sounds that happen once in a while, you can just put one here, but for sounds are going to happen over and over again, you want to have a randomized pitch. Otherwise, you're going to drive your players insane. So to randomize something, all we have to do is type in random, and it will show us our options. And I'm going to pick random float in range, and put in 0.9 and 1.1. This means that every time the sound effect is played, it will pick a number between 0.9 and 1.1. To play at, I'll slide that action over to where the laser effect is actually happening. But we're going to do this for everything in the game, which includes a collision effect when the player runs into an asteroid and an explosion sound when the asteroids explode. And now we need just one more thing as far as effects go. And that's the camera shake. So we're going to add that to the project, and then go to the getting hurt event and adding it as an action. And there we go. And now for a little more polish, we gave all the asteroids a bunch of animations. So we're going to go to the beginning of scene event and use the action change the number of the animation. And this time, we're going to use random three, because the big asteroid has four animations, and the zero counts as a number. And now if we start the scene, you'll see that they've all picked a different image. And now for the somewhat tedious part of tweaking things, making sure that your collision masks make sense with the objects, and then play testing it. And then making sure that your speeds and densities are all the way you want them. And then you play test it again, and again. And again. And again. And again. And again. And again. And again. And again. And this is a bit subjective, but you keep play testing and tweaking it until the game feels good to play. Now that we've created a game, we should do a few things before we export it. So we're going to go to the Properties manager, go to game settings and open up properties. We're going to give the game the proper name, give it its version number, change its package name, make sure that you're listed as one of or the only author. Make sure that you've chosen the right option for how the game should expand in a screen. And of course, for mobile games, you want to make sure that you've chosen your device's orientation. And finally, make sure that you've put in a publisher name. One more thing to do too, is to give your game icons. All you have to do is click up here, give it a square image, and it will turn that image into an appropriate size for all the devices. Once that's all done, we can export our game, we go up to file, click on Export. And right now we're given two options, share with friends, which will give you a link that you can share with your friends or people that you want to play test the game or publisher game. You can build it manually if you know how. But I'm just going to click on the button that gets the engine to build it for you. We're showing four different tabs, starting with the web build, which will create a HTML file that can be played in browser. Next is the mobile export, where you can release an APK to be used on devices generally, or an Android app bundle, which is the kind of bundle that you need to submit a game to Google Play. The next type is for exporting a game to Windows, Linux or Mac iOS. And finally There's instant games, which are posted to Facebook with a Facebook developer account. Now, g develop is free, entirely free to use and export from. But there are restrictions for these automated builds. Because it cost you develop money to host the servers that they're built on. So with G develop, you get two free builds per day from mobile or desktop. If you pay for a subscription to a G develop account, you get more exports per day. But publishing a HTML build is unlimited. So excuse me for breaking the illusion for one second. Oh, no, I'm on a regular old PC. Okay, so we create a new folder called game, or whatever your game is called. Go back into the engine, click choose folder, find that folder and select it. And then just press export. So now all of the game's files are in this folder and ready to go. All you have to do is compress it to a zip folder. And that zip folder is your game. But let me quickly show you how to do it for a PC build. So we go to exports publisher store, make sure that Windows auto installer file is selected, and then just click package. And then you just wait. You'll get this notification here down at the bottom. And if you click that button, you'll get a periodic email that gives you some stats about your game. And if you just click that Windows button there, it will download to your download folder. And then you'll have your game on your computer. I hope this video was able to help anybody out there who wanted to try out g develop and making their own games, but just didn't know where to start. Thank you for watching, and best of luck with your games.