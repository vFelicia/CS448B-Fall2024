feature toggles can improve the workflow of your development team, and lead to quicker software delivery, Frederick osburgh from unleashed will show you how feature toggles can help you. Alright, so I brought with me, a friend of mine here today to help to introduce you to feature toggles. He is a brilliant engineer, and he's the creator of unleash, which is the largest open source solution for feature flagging on GitHub. And I'm really excited to have him here today to help explain feature toggles. So welcome, Eva. And thank you for being here. Thanks for having me. Yeah, it's my pleasure. I was curious, just to kick this off. You've been in the feature toggle game for quite some time now. And I just wonder, what prompted you to start feature toggling? And what was kind of the trigger to make this happen and create this? The system? Yeah, thanks for asking that. Actually, I started on the leash or exploring feature toggling concept back in 2014. And, and my kind of my goal or the mission, or the reason for starting with that is that I deeply care about develop proficiency. And I was working as a tech lead and a team back then, and, and we had already kind of automated how we release software to an environment, all our environments. So we had kind of the deployment pipeline all set up, and we could in theory, release whenever we wanted. And in our team, we had also decided to do weekly sprints, because we wanted to kind of have this extreme focus and ship features all the time. Because it makes sense. And also, we wanted to kind of learn all all the time. But I saw that we often fail to do releases every week, we couldn't kind of ship software every week. And it bugged me a lot, because we ended up with all these feature branches, long running feature branches. And it actually was quite hard to manage these feature branches, because there was a lot of changes. And I was kind of, you know, when you're working on a larger feature, take some time to write that code and get it right and test it a bit and get some feedback on it. And, and it feels like when you're pushing something to production, it needs to be like perfect, because you actually kind of presenting it to real users out there. And, and for me, this bugged me a lot, because they ended up us holding different feature branches back in kind of separate kind of local branches or test environments and stuff like that. But they were never merged. And we kind of postponed a lot of the learning. Right? And, and for me this, this was a nightmare. And I felt like my it was kind of cognitive overload. And I thought that there has to be better ways we should, we should try to ship some code all the time in smaller chunks, but but hide them from the users instead. And this was when I started learning more about trunk based development. And there were certain techniques to kind of succeed with trunk based development. And one of the techniques that a lot of people talked about was feature toggles, or feature flags. And I really loved that idea. And at this time, there was a couple of other open source solutions for this as well. But usually, they were kind of tied to a specific framework, or they were kind of very static, that it was just a file in your app. And you could kind of change the toggle, but there was less of a dynamic built into it that I really wanted. And this is why I started looking into creating something like in Asia, I really wanted something that could allow me to do trunk Base Development divider features into smaller chunks. Even though that complete feature was not releasable. The end user still wanted to have the ability to ship the code to production, just to get some learnings like does it really make sense? Does it work with production data is the firewall open all of that kind of things that we developer care about, but also that then I can know that a small portion of the feature is done. And I can start thinking of the next small portion of the feature instead of thinking about everything all the time. So just curious for the people that don't know what is trunk base development. So trunk base development is a very popular technique these days is kind of opposite to more like a Git flow where you use branches for everything. So the idea is that you mainly work on the trunk or the master branch or the main branch, you try to kind of all the time commit directly to that. That trunk branch is so that you never kind of having long running feature branches in parallel. This means that you you have all have developers in the team collaborating on the same code base instead of having local copies of the code base in different states? Right? Isn't that dangerous, though? Couldn't you like easily get something into the master branch that isn't completely tested? Or doesn't work? 100% yet, or Yes, exactly. And this is why you need feature toggles, because then you use a feature toggle to wrap that code so that you make sure that it's not exposed before the code is ready to be exposed. Right. So tell me a little bit more about that kiss. Just curious to know how that works, actually. Yeah, so so that kind of a feature toggle is actually a very simple technique, when you think about it, it's just kind of a small if statement that you've wrapped the new code in. And only if that feature toggle kind of evaluates the true, we should evaluate the new code. If not, we should use the old code. So basically, you can think of it like you're you're replacing the branches in your repository, with branches in your code instead. And this has, adds a lot of benefits. So it means that when you're using a tool like unleash, you can start then namak, Li changing who gets access to a feature based on certain criterias in a running application in production, so you don't have to get the redeploy or anything like that. Interesting. And this allows you to test early in production, you can verify the new thing you're working on, even though it's not completely finished yet, you can test it on yourself, and only enable it for your user in a production environment, tested with real data, make sure that the little part that you've already built actually works the way you intended to work. Right. So you have something that's not completely finished, and you hide it behind the flag so that it's not turned on, before you're actually ready to turn it on. But you're continuously putting that into the master branch so that you don't end up having multiple different states. That could clash in the future. Exactly. And, and working like this allows the team to really collaborate on the code base, and means that everyone will see your changes very fast, because it's safe to kind of just commit directly to the trunk and have that directly in and share between the developers, it means that you can basically refactor your code. And it's hard because there will not be kind of some new feature on a different feature branch that is not yet complete that you have to wait for before you can do this huge refactoring session. So there is a ton of benefit of working this way. Amazing is what about drawbacks? Like? Nothing is completely 100%. Perfect. So just curious, are there any drawbacks to using feature toggles? Yes, of course. And if you think about like a feature toggle is is kind of technical debt by nature, because you are having different version often of feature or the code itself, you have two implementations of something in your code base. So obviously, you would not want to have that for a very long time. But it really makes sense when you are kind of trying out new ideas or working on a new feature, or something like that, that really makes sense to kind of encapsulate that in a feature toggle. But we should also be a bit careful, because if you're just adding feature toggles, but never taking them away, allowing multiple code paths to coexist in the code base, that can be actually quite dangerous down the road. Because usually developers which team they might quit from your company. And it could be kind of like, down the road, you can end up in a situation where you have a lot of feature toggles, but you're not sure if you can turn them off anymore, will that work? Will your application still work? So you're kind of really depend on a certain state have that toggle. And when it comes to that situation, it's really about time to start cleaning up that and remove the dead code and make sure that you only kind of execute the code that you really want to execute. And there is other things there as well. And that is a will having a lot of features bill also make your code a bit harder to test actually because you will need to kind of test you will have a lot of different parts through your application give based on what what the state of the feature toggle will be if it's on or off or maybe it's a certain variant might not just be on but it could be divided between different implementations. And then you certainly communist that should you test All the permutation of all the toggles in your application, maybe not. But you should at least try to test the important ones, at least with kind of automated tests and make sure that what most of your user will, will end up seeing in production should obviously we are tested cobalt, and then there is a discussion if you're also need to test all the different feature toggle states, maybe maybe not, it depends a bit on which type of application you're working on, I guess. Right? So I'm actually curious about this. Because when we're talking about deploying multiple times a day, or, or getting to a point where we're releasing all the time, then obviously, a big part of that is having automated tests. So you know that the code that you release is actually working and functional, when you push it out to production. But when you're relying on a third party program, and I know that a lot of the feature talking solutions that exist today are like traditional SAS platforms, you set up your feature toggles there, and, and you kind of use them in your code, and you have to communicate with them. So you're kind of have this external dependency. And as you mentioned, that could be really hard to test. So how can you get around that? How can you make sure that you can test your code thoroughly, even when you have a third party that you have to rely on? Yeah, and that's actually one of the benefits of choosing an open source platforms such as unleash, because you can, you can actually just take the unleash open source, and that will be 100% protocol compliant with the SDK, the enterprise will obviously give you some more features. But you can take that and run this as part of your integration testing, if you really want to test the interaction with a leash. And then you can just kind of pre configure that open source instance, to be in a certain state so that you can kind of test all the states that are important to you. A lot of our SDK is also allow you to do testing, for instance, the Java SDK has a built in kind of fake ilish implementation where you can kind of set the toggles in certain states. But that's typically more useful in more like unit test cases where you kind of are building unit tests for us more portion of the code. But usually, that doesn't make sense. When you start integration testing or end to end testing, then you often want to actually have some kind of third instance running that is replicating what you're doing. And that's quite easily Tashi, with Alisha would say, interesting. And anything more you feel like, it's important to talk about when we're, we're talking? Yeah, I think I think there is a lot of things. And I'm sure that you will cover a lot of the important topics in this course. So I'm super happy that you're doing this course. I think in the end, there is obviously drawbacks with everything, there is nothing that comes for free. But as long as we kind of handle those drawbacks and take care of the technical debt, and make sure that we have some processes to also clean up that we set aside maybe a day a month or something to kind of validate the toggles were using Are they still relevant? I think the the benefits kind of outweighs the drawbacks. And I see that teams starting to adopt feature toggles or wanting to run with the trunk based development process seems to gain a lot of value out of using feature toggles. And to me it's kind of an eye opener has seen in in in real life, how it's accelerated the learnings from the software we're working on, and how we can safely release all the time in small chunks, get feedback on those changes. Are they working? Are they doing what we intend them to do? And kind of bit by bit building out complex features, which is a it's an awesome capability to have to be honest. Yeah, it's sounds amazing. So I'm really excited that you're here. And were able to give us this kind of introduction to feature toggling. So I want to thank you for taking time to do that. And now hopefully, we're going to be ready to dive into the code and start implementing that on our own, which is going to be exciting. Thanks for having me. You're welcome. Alright, so we heard a little bit about what feature toggles are and how you can use them. So now we're going to get into a little bit more. And I want to stress them in the most basic form. A feature toggle is just an if else statement. So what you could do is you could have a flag in your code that says whether or not something is are off. And obviously, if you're diligent, and you're able to remember to turn this flag on and off, when you're developing, or you're loading it from some kind of configuration file, that can be enough to just get the ball rolling and get started, because it means that you can go ahead and merge in your code at any point in time. So what we'll do is we'll take a look at how we can perform this and how we can implement it into the Free Code Camp code base. So let's get to it. Alright, so here we have the Free Code Camp website. And it's running locally on my machine. So let's just take a quick moment and go through what's here. As you can see, we're at the landing page right now. And we have this text in the middle, and the call to action that says get started, it's free. And if we scroll down, we have an S seen in section, we have an alumni section. And in the end, here, we have the certification section. So that's basically the structure of the landing page. Now, let's go to the top. And we're just going to focus on this part right here. And what we want to do is want to take this section right here, and we're going to swap it out with a new section. So we'll take a look at the code, we'll take a look at the new section. And then we'll take a look at how we can use a flag to toggle this on or off. So here we are inside of the Free Code Camp code base. And we're inside of index js. Now, the landing top component here is the existing component that corresponds to what we just saw on the main page. And we have this landing top v two here, which is the new design that we want to go ahead and implement. So what we'll do is we'll uncomment this. And we'll scroll down a little bit. And we have a piece of code here that we're also gonna comment in. And then we'll comment this out, just so we can see the changes that we make. So if we head back to the and now we can see that we have the new component in place of the old one, we still have one issue that when we have the header up here, that is a universal header. But we chose to include it in the new design in the this component. So what we'll go ahead and do is we'll go back to the code, or find the header components. And we'll take the universal now. And for now, we'll just go ahead and comment that out. And if we head back to the browser, now, we should see it update. And here we have the new landing page. So what we'll look at now is hiding this behind a flag, so that we can easily toggle it on or off. Let's head back to the code. And the first thing we'll do is we'll go ahead and create a new file and source both flags. Yes. And in here, we'll create a constant called new design on and we'll set it initially to be false. Now, what we'll do is we'll go back to our landing page. And we'll change this because it's not good to have a bunch of uncommented code around and we want this to be flexible, we need to find a way to be able to display either this component or this component based on the flag. So let's go ahead and import the new design on flag. And I get some help there from my auto importer. So now we have the new design on imported. And we'll use this to conditionally render one thing or the other. So we'll say const landing page component or landing top components Be precise. And we'll say new design on and if it's on, we want to render this part right here. Otherwise, and we'll denote that with a colon where you want the old landing page components Now we'll put it in. Right here. Basically, we're saying if it's on, give me this part, if it's off, give me this part. And then we're taking the value there. And we're rendering it inside the main container. Let's go ahead and see what we get. Now in the browser, if we head back, now we have the old landing page. But we're still lacking the universal navigation. So let's go ahead and fix that as well. So we're going to index TSX in the header. And we'll comment this back. And we'll do the same thing here. So we'll say new design on. And we'll use that to render the universal NAB. So navigation equals new design on then we want nothing. Otherwise, we want the universal navigation. So remember that the new design has the navigation built in. So we don't want anything in that case. If it's not on, then we want to render it because it belongs with the old components. So if we hit save on that, and go back to the code, or the browser, we now have the navigation back as well. So what this allows us to do, is we can go back to the code, and we can go to our flag. And we can flip this to true. And now we have one central state that controls whether or not we show one component or the other. Now we're soon getting to the really cool part. And the ultimate goal that we're trying to areas that we want to be able to quickly merge things back into the master branch and get things into production, without having to worry about whether or not it's 100% functional, because we can make the improvements as we go along and hide the feature from the user base until it's 100% complete. Now, what we have now, a flag that we can click on or off in our code, it's gonna work but it's a little bit brittle. You know, if you have a flag that you have to have a conscious relationship with, and you have to know whether or not it's on or off, when you push your code, it adds mental overhead. And it just it's it's one more thing to keep track of. And what could be really dangerous if you actually forget that you turn it on, on something that's not finished. And you inadvertently could push out something that's unfinished to your customers or users of your hobby project or whatever it is that you have running in production. So we need to do something to make sure that that can happen. So we'll jump back to the code. And we'll take a look at how we can make this flag a little bit more dynamic. So right now is set to true. And what I want to do is I want to use the process EMV node environment. And I actually want to say that if it is in development, then I want new design to be on. And if I hit save on that, we should be able to see the new design still, because we are in development, we are running the node process here in development, it's not in production. So let's go ahead and verify that and say that if we want the new design to be on in production, we have to be running process in production. And now you can see we get the old design or the current design. So that's gonna help us because that means that when we actually deploy this, if we have this set to development, we don't have to worry about this making it into production provided that we are specifying the correct parameters when we are running the process. Alright, so one of the pitfalls and we kind of mentioned that when we were doing the environment variable is that if you're just having a fly in your code, it can be quite easy. to risk not remembering to turn it back off again, like you're working on a feature, something's happening, maybe the babies are crying, or you're burning your food, or you have to run your minds elsewhere, and you come back in, you forget that, you put the flag on, and you commit something, and maybe you, maybe you get it into production, like, obviously, you'll have some other gods, right? You're a good developer, you have people reviewing your code, and someone's gonna catch it, I'm sure. But what if they don't like, it can happen, should happens. And you do have run this risk if you're not using environment variables, and you have the flag in your code. But there are easy ways to get around that. Now, another thing that you might experience is that you actually reduce the benefits of feature toggling when you're putting it in the code, because one of the big benefits is that you can actually use the configuration from an external location to toggle the feature on and off in your code without actually doing another deploy. And like that's the real magic, not the stuff that you can actually merge it in. That's good. That's nice. But the real magic happens when you can actually control your application from an external source. And you don't have to do a new deploy in order to, in order to get a new version of your code out there, you can just flip a switch, and there's another version of your code that will run live in production. So think about that, like you have a product manager or something that is launching a new feature. And he's at home, and it's Friday night. And you're trying to launch a new feature, because you always launch on Fridays, right? That's, that's a golden rule. But what if something goes wrong? Like he has to call up his developers, they have to figure out what went wrong. And then they have to deploy a new version? Well, what if he could just push a button and go on with his weekend, and then on Monday, we can go back to trying to figure out what's wrong. That's the real magic. And that's what we're going to take a look at in the next section. Alright, so what we'll do now is we'll focus on taking this flag that we have inside of our code, and we want to move it to an external service, so that we can toggle the feature on or off, and without having to redeploy our code. Now, the way we'll do that is we'll use a service called Jason min, which allows you to host Jason in the cloud, and you get an API URL that you can use to retrieve the Jason configuration. So let's go ahead and create our Jason configuration. And we have the Ben creation screen in front of this right here. So we'll go ahead and put in a Jason configuration here. And we'll start with the open curly brackets, and a key that says new design. And we want the default value to be false for now. Also, we have to make sure that we put this from private to public bin so that we are able to get the configuration without an API key, just for testing purposes. Of course, if you're running this in production, or you want a more robust setup, obviously, you want to have a proxy in between that can take care of hiding your API key on the server side. But for now, we're going to keep it public so that we can easily retrieve the information and then we'll take a look at how to use a proxy later on. So let's go ahead and hit create on that. And you can see now we have a access URL down here in the bottom of the screen. We'll copy that. And just to make sure that this is working, they sit in. And here you can see we have the Jason configuration. Alright, so now that we have that, we can jump into the code and start putting it together the pieces that we need in order to retrieve the configuration. Alright, so here we are back in the code. And we are in a component called default layer, which is a component that wraps all of the other components in this project. And this is where we'll add the logic for retrieving the configuration and it will use it to supply the configuration down to the components that need it. Now this is something I would normally use hooks for. But since we are using class components here, this is the method that we are going to work with. So to begin with, let's go ahead and add a constructor And we'll go ahead and take some props. And we'll say, super props. None, we'll initialize our state. And we want the state to have a ready property. And we're going to add a new design. That's going to be our initial states. Now, next up, we'll add a fetch feature toggle on figuration. And inside of here, we are going to get the configuration from our Jason bin. So let's go ahead and say fetch. And now we need to go ahead and retrieve the URL, we'll go ahead and copy that. And we'll paste that in here. And then we'll say, we'll get the result. And if the result is okay, so if it's 200, then we want to return press Jason. And then we'll take that Jason data. And we'll say if they get ready, is false. And we'll say this set state ready is true. And new design equals JSON dot new design. Otherwise, we'll say this set state. And we'll make sure we put this in the right place. And we want to return here. So if ready is not false, we will just want to put the new design through the Jason new design value. Let's go ahead and hit save on that. And then we need to add this here on the states. This we're referring to the class. And let's go ahead and throw an error here. If we fail to get the configuration, and we'll just catch and log it out for now. Alright, so let's go ahead and make sure that we call this function. And we'll go ahead and do that in the component did mounts, they'll say this fetch feature toggle configuration. And then I think we set the new design to be false in the adjacent bin. Let's just check that quickly. We did. Though, we'll clip this to true, just to see that we are getting the expected results. When we retrieve our configuration, we can also inspect the network requests. So let's go ahead and just log out the states in our render function. And then we'll head over to the browser, and we'll check out the behavior. Alright, so let's go ahead and open up our developer tools. And we can see that in our console, we have two objects. The first one is the first state. So we set new design to true and ready to false in the initial state. And then we have the updated state here where a new design is false and red is true. So we get new design from the JSON bin, and we set the property to be false. We can also verify this by checking the Network tab. So let's hit refresh here. And that's gonna capture all of the network requests. And we can see in the top pair that we have in the request, it's asking towards this URL, and the response is the base and then content. Alright, so now that we have that, let's focus on getting this data into the components that need it. So we'll head back to the code. Now we need to pass this state down to the header because we need to hide the universal navigation based on the flag And then we also need to get it into the landing page component. So let's take a look at this render function here. And we can see that we have a lot of links, you can see we have the header here. Let's go ahead and pass new design here and say this state new design. And then we are going to have to do a little bit more work in order to get it into the landing page component because we are rendering children here, which is basically the React way of saying that anything that is put inside of this component, when it's rendered, all of its children are going to be fit inside of here. So we can't access the children at the time they are initialized, which means that we can't actually pass the children props, or properties. So what we need to do is we need to go ahead and recreate the children. So we'll do react children map. And then we'll pass the children as the first argument. And the second argument will be a function. And we will receive the first or the child's as the first argument. And inside of this function, we want to take the child and we want to clone it and decorated with the new parameters that we want to pass down. So let's do react, clone element. And make sure we put return in front of that. And we'll say child, and we'll say new design, this state your design. Alright. So that should take all of the children, loop over them. And take each child make a clone and pass it these properties or this property. So let's go ahead and find the index page components. That will do index page. Now let's go in here in the index TSX part of the index page. And that's going to be the child that we're passing the prop two, so need to accept props here. And since this is a TSX file, we're going to be good citizens and create an interface. And we'll say new design is a Boolean. And let's say page is a string. And let's go ahead and pass the props here. And then we'll take the properties which is an object. And we'll pass them along to the landing page here. Let's open up that components. And we'll accept the parameter here. And let's go ahead and log this out. So now if we head over to the browser, and we open up the developer tools, we should be able to see a console log that says false. And we do right down here. So that means that we have successfully moved the data down to the landing page component. So let's go ahead and go back to our code. And we'll swap out the new design on here with the new design property up here. So we'll do this instead of our built in flag. And we are going to go ahead and do the same in the header components. Let's go ahead and find that which is up here. And we are going to say instead of new design on we'll say this box, new design. And currently, this is set the poll, so we expect our old landing page to return, which it does. And here we also have the header just a little bit slow rendering there. Alright, so to round up the section, we want to make sure that we can use the J S bin configuration to control which design is running on this site. And in order to do that, we need to make a few final changes to the code. So let's go ahead and jump back in. And you can see we already have built the functionality to fetch the configuration and to update the state. And now we need to make sure that we're able to get the new configuration once the configuration changes in the JSP. And the way we'll handle them is we're going to set up an interval. And that interval is going to refetch the configuration every five seconds. So we'll go ahead and set an interval here. And the function that's going to run is this fetch feature toggle configuration. And as we said, we want that to run every five seconds. So with that in place, now, we just need to go down here, and we need to make a change to this URL. Because we want the latest configuration every time we fetch against this. Otherwise, we would get the first version and not the updated one. So we need to make sure that we put on latest at the end here. And since we set up an interval here, we also want to make sure that we go ahead and clear that interval, should the components are not. There, if we hit save on that, we can head back to the browser. And as you can see, we still have the original view here. But if we head over to our J spin, and we hit edit, and we flip this state to true. And we go ahead and update the Ben. Now if we head back to our website, we have the new design in place, because we're now controlling the feature using the J S bin configuration. And there you have it. And honestly, this is easily one of my favorite things about feature toggling having the ability to just flip a flag like this. And then seeing the changes instantly reflected in your website running in production. I mean, that's incredible. Having the ability to release code with the confidence that if anything goes wrong, you can just turn it off. That's incredible. It gives you so much safety. And it makes you so much more efficient. As a developer, of course, you'll still write tests, you'll still take the precautions that you need to take. But just having that safety net, just having that level of certainty that if something goes wrong, you can just turn it off, makes it a joy to ride and release code because you're eliminating the element of risk. And honestly, that's like magic to me. Alright, so let's talk about some of the drawbacks of using this method of implementation. So earlier, we talked about the fact that if you're using built in feature flags into your code, you miss out on some of the benefits of using feature toggles. Now you can get some of those back by using an external configuration. But if you did, like we did, now, you have to be extremely careful, because when you're working with raw Jason, and that's controlling your application, it can be a little bit brittle, because Jason is a data format. And you need to adhere 100% to the format in order for it to work. So there is a very little margin for error. Now, in Jason bin, luckily, we have some protection. So we can't just put in any arbitrary value and hit update because it will say that it's invalid Jason and we won't be allowed to update. But what we can do is we can put in something like this, where we put in a string, which is valid Jason, but we put in the string false. So maybe we were doing something quickly, maybe we didn't realize that you have to use True or False without quotes for it to be a Boolean. But the result now is that we still have the the sign that we started with so we didn't actually So we make the update that we wanted to, we have to go back here. And we have to change this now to say, balls, and then hit the update button again. And now we get the result that we expected. So you can see that you have to be very precise in your instructions. And it's not something that you would let someone that's non technical in there. So you would have to kind of keep this in the developer family, which could be fine. But you need to make sure that you are being vigilant when you're working with this stuff. So that's one thing. Another thing might be that, as cool as this functionality that we've implemented is, and as powerful as it is, it's still a little bit limiting. The, you might want to give certain users access to the feature in production. Maybe you want to do a gradual rollout that rolls out to percentage of your users maybe want to have some metrics on who are getting access to this feature or not. Or maybe you just want to be able to connect from different applications maybe have more than one application. And they're in different programming languages. And you have to write these bindings for each application. And that's when you kind of start looking for an vendor of these things, because now we're talking about hours of investing into developing something homegrown. And there might be better or more robust alternatives out there that you can use for free. And that's what we're going to look in to in the next section, we'll look at some paid actors, we'll look at some free actors. And then we'll dive into the product that I'm working on, which is called unleash. Right, so we need want to do more than just basic feature tarwin, like rolling out to a percentage of your users having certain users get access in production, getting metrics, connecting multiple applications, you quickly find yourself wanting to look for a vendor. And I firmly believe that looking for a vendor in these kinds of situation is a good idea. Because every line of code that you write yourself, you're going to have to maintain and code is now in my mind, it's a living product, it lives over time, you're going to have to have a conscious relationship to it. It's not like you write it once, and then you're done, you're going to find that you have to work with this code again and again and again. And you have to either add capabilities that weren't there before, or you're going to have to fix something that isn't working as intended. So with that said, let's take a look at some of the vendors that you can use for feature totally. And there are a number of actors in the space that you can utilize. And I'm not going to go into detail on them here, but I will mention them. So you can make up your own mind. You have platforms like LaunchDarkly split, dyo, WVU, VWO, CloudBees, Optimizely, and harness, which basically, they operate this traditional SAS platforms. And then you have some open source alternatives such as GitLab, rollout, flipper, and unleash, which is the solution that I'm working on. Now, which solution should you choose? Well, I'm not going to tell you that. And first of all, because I'm severely biased, and obviously, I want you to use unleash. But secondly, it really depends on your needs. The vendors mentioned here all have their strengths and weaknesses. And they all have their unique development philosophy. And I will say this, though, when you're choosing a vendor, I think it's also important to take a look at the development philosophy and make sure that it matches your own. So with that said, I'm going to tell you a few words about the development philosophy at unleash. So first and foremost, we are huge fans of open source unleashed started as an open source product, and it still is one today. And 95% of our code is freely available on GitHub. And if that serves your use case, you can use that for free. No problem. And what's great about open source is that if you have a problem that we can easily fix, you can submit a issue and if we tell you that we can fix the issue because we have other priorities, you can always submit a pull request and fix it yourself. Or you can fork the code and make your own adjustments as you see fit. And in today's development climate, we believe that this flexibility is a key factor in order to succeed in bringing tools to developers, developers are curious beings, we like to see how things work. We'd like to feel in control. At least I know I do. And, yeah, I think that's important. Though. Secondly, we believe strongly in privacy. We don't think that solutions that claim ownership over organizations data is a sustainable way going forward. And this is why most of our SDKs are extremely privacy focused, we do all of the evaluation of feature toggles locally, to avoid leaking data back to our system. So if you're using our paid, hosted version, none of the data actually leaves your application, it all stays in inside of your ecosystem. And if you're using open source, you control the back end anyway. So there's no issue there. So with that said, I'm going to take you through the architecture of unleash. And we're going to go ahead and see how unleash can help you. Before we get started setting up the unleash open source, let's go ahead and take a brief look at the architecture just we know what we are working with. And we'll start by taking a look at the SDK 's. And SDK stands for software developer kit. And what it basically is, is pre written code in a programming language that handles the connection to the Unleashed API. So you will use the SDK in your own application and configure it to talk to the unleash API. And then the SDK will go ahead and download the feature token configuration at a given interval that you can tune and it will store it locally in memory. That means that you don't have to do an API call every time you want to check if a feature toggle this on or off, you're basically doing the evaluation and the lookup in the cache memory of your application. And that gives you a lot of performance. And it also means that none of your user data is ever shared back with the unloose server, whether or not you're using open source or using the hosted solution. And let's talk about the API. The unleash API is split into two parts. You have the Admin API, which allows you to do changes to feature toggles, add new ones, and update the future configuration. And then you have the client API, which is one that serves the unleash SDK case. And this API is split from the Admin API, because it's supposed to be really stable, rarely changed. And you can create a specific API key, that's read only. So that means that if you should lose your API key for the client API that serves the SDK as the attackers won't be able to use that to actually make changes in the configuration. So anything you can do and unleash, you can do via an API call. So we have an admin interface that we'll see later. But if you wanted to, you could do everything with curl commands, or you could wire up your CI pipeline to talk to unleash. So let's talk about the proxy. So remember earlier when we were talking about the J S bin integration, and we said that we might want to do this via a proxy. And one of the reasons for that is the added security layer. So when you're talking to API's, you usually want to limit who has access to the API. And you do that by generating a unique API key that will provide access to the holder of this key. Now, when we're working in the front end, or the client side, whether it be a web application, or an native app, like an Android or iOS application, you generally want to keep the secrets out of this area, because it's not a safe space. So what the proxy provides is a layer between your client side application and the Unleashed server that provides secure server to server communication, where you can safely store your API key. In addition to the security of the API key, the unleash proxy will only return evaluated toggles. And this is information that's already available in your source code. which is free for everyone to look at, if they have access to the developer tools and can inspect your code, so you are reducing the amount of information that's traveling to your front end to safe information, so to speak. Aside from the added security, you also get improved performance by using the proxy. So the proxy can handle around 2000 requests per second. And it's really easy to spin up and scale new instances of the proxy, because it's just a stateless Docker container. So that's going to give you an easy way to scale your application by adding more proxies and connecting them to the same unleash application. With that said, let's go ahead and set up a local instance of unleash and a local proxy, and start exploring the possibilities of using feature toggles. Okay, so now we're going to go ahead and get started setting up unleashed open source on our local machine. And in order to do that, we are going to use a software called Docker. Now, Docker is a way of taking something called Docker containers, which are small virtual environments that have all of the dependencies needed to run a piece of software and run that as a container on your machine. So basically, you're running a small computer on your computer, which has its own operating system, and its own dependencies. And it's already bundled for you so that you don't have to set up your machine to replicate these dependencies. And it's a really powerful way to get started just running software, if you want to try out new software on your local machine. So if you don't have Docker, make sure you go to docker.io. And you hit the get started button up in the right hand corner. And then just follow the instructions to set up Docker on your machine. And then you should have a mand called Docker. Once you're done that you can run in your terminal. So when you've done that, we are going to go ahead and open up the Unleashed documentation and go to the deploy and manage tab. And under Option One will have the option to use Docker. So there'll be some commands here that we are going to use. We modified them slightly for this example, because I've already set up some of this on my machine and I want to do it completely from scratch. So we are going to head over to our terminal and get started running these commands in order to set up long leash. Alright, so here we are in the terminal. And the first thing we'll do is we'll go ahead and create a network for Docker. So we'll write Docker network, create unleash nets. And that's going to give us a hash as a confirmation that we created the network. And now we'll go ahead and set up Postgres. So we'll have this command right here, we'll say docker run. And we are providing some environment variables. So obviously, if you're running this in production, you want to change the password, and make sure that you choose something that's really secure. But for this example, we are just gonna go with the defaults here. And we'll start the postgres on 5432, and we'll map it to 5001 on our local machine. So if we start that, we should see the postgres output, and right here we see that it's ready to accept an actions in the bottom. So now we can go ahead and open up a new tab in our terminal and we will use a Docker command to start the unleased server. So we'll do docker run. And we'll map that to 4242 on our local machine, and we want to make sure that we match the database host. And the database port is going to be 5432. So we hit Enter on that, that's going to start up the unleash application. And now we can head over to our browser and we can open a new tab tab here, and visit localhost or 242. And here we have the first screen that you get to when you open up the address in the browser. And as part of running the Docker container, unleash will set up the database. And it will run some migration and create all the tables. And it will also create a default user. So once you're here, you can go ahead and log in with the following credentials. So that's going to be admin, as the username and unleash for all as the password to go ahead and input that and login. And you're taken to the main application interface. Now, there's not much period. And we'll explore this in a second. But for now, we want to continue with the setup. And we still have to set up the proxy. And in order to do that, we need to do a few things in the UI here. So we'll go to the Configure drop down. And we'll open up API access. So in here, you can create and delete API keys. And we also have the API URL readily available that we need to supply when we are setting up the proxy. We'll go ahead and create our API token now. And we'll hit this button in the upper right hand corner. And that's going to trigger this dialog. And we're going to fill out the name here. And we'll call it proxy key. We're going to keep the token type to client, because that means that this key will be read only. So it's only going to be allowed to read data. We'll keep the project settings as it is and then we'll change the environment to development. And once we have that, we can create the token. And now we have everything we need to set up the proxy. In order to do that, we'll head back to the documentation. And in the left hand side menu, we have under unleash SDKs, the Unleashed proxy tab. If we open that up and scroll a little bit down, then we can see instructions on how to run the unleash proxy. And we are going to use this command right here. But I have prepared it a little bit. So let's go and head over to the terminal. And here we have the command that is going to start the proxy. So what we've done here is we've taken the API token that we just created. And the way we did that was we went to the UI. And we hit copy on this to copy the token to our clipboard. And then we went back to the terminal and we put the token in here. That's the API token that we created. Now, the unleash URL points to the local instance of unleashed running on my machine. And since I'm on Mac, I have to use host Docker internal for the proxy to access this port through the virtual environment. If you're on Mac, sorry, Linux or Windows, it's going to be slightly different. But I'm going to include documentation on how to get that done. So that you can follow along. In the top, we have something called unleash proxy secret, which is just a very thin layer of security. Like I said before, anything that's exposed on the client side is not really a secret. So the main security of the proxy comes from the fact that it takes the API key, and it hides it in server to server communication. And it doesn't give any other data out other than evaluated toggles and information that already exists in your source code. So while you will put up a secret here that will allow the clients that are connecting to the proxy to read from the proxy, if they have the secret, the main security is within the proxy itself. So with that said, you can go ahead and start it. And it's going to say that it's now listening on port 3000. And if we want to go and check if this is working, we can take this curl command here and copy that and head back to the terminal. paste this in a new terminal window, and you can see that we get response with an empty toggles array, which is what we expect. Okay, so now that we have the proxy running, let's go ahead and take a quick tour of the application, and then we'll create our first feature toggle. So we're currently in the main view, we will navigate to the project section. And here we have the default project, which is the project that we get for free when we start up. And this is the only project that we have in the open source version. But it should be enough for our use case. If you open that up, we have a view that gives you a little bit more information about the project. And we're not going to go through everything. But I want you to take note of the environment section. If we head over here, you can see that we have the default enrollment enabled. And then we have development and production as disabled. And this will be more important later when we start to do more advanced segmentation. And we want to decide who gets access to a feature. And we can segment that on environments as well. So for now, we're just going to turn this on. And we're going to head back to the overview here. And we'll go ahead and we'll create our first feature toggle. So in order to create a pitch toggle, we just need to give it a unique name. And we'll go ahead and hit create. And then we are taken to the total overview. Now, there's a lot of information here. But I want us to focus on this part in the middle. So see this traffic section right here. Notice how it corresponds to the environments that we turned on in the project. So since we turned on production and development, we now have the option to see traffic from those environments. And if we scroll a little bit further down, we have a strategy section. And this is an important concept in unleash because strategies are really rules that determine whether or not a feature should be on or off. And you can add these rules to any environment, and they will only be active in that environment. So let's take a look at an example. We'll go to the strategies section. And we want to navigate to the development environment, we don't want to add one to the default environment. And I'll explain why in a second. But let's go ahead and add the gradual rollout to the development environment. So what we see here is the configuration of the strategy. And we can adjust this to be 25%. And you can see that's reflected in the execution plan here. And it says that 75% of your user base is included. So if we save the strategy, now we can see that we have one strategy in the development environment, but the environment is still disabled. So in order for a strategy to be executed, we need to turn on the environment. And the difference between doing this and what we just did in the Project Settings is that when we set it in the project, we set a project by setting or all of the feature toggles that we create, that gives all feature toggles access to these three environments. But what we're doing here is we're saying, for this feature toggle, we want the strategies in this environment to execute. So it's a handy way to turn on or off an environment or a feature toggle. Now, what we can do is we can head over to our terminal. And we can try the command again to call against the proxy. And you can see that we're getting the page toggle in the first call, then we're getting in the emptier in the second. And then we're getting the feature toggle again in the subsequent calls. So what's going on? Well, if we take a look at the configuration here, we've set the strategy execution to be 75%. Which means that three out of four calls, we should get the feature toggle. And that's exactly what's happening. So if we bump this up to 100%. And we hit save, and we head back to the terminal again. Now if we go ahead, and we try to get the feature configuration, we should get it every time. Alright, so how does this work? How does the proxy now that we want to fetch the configuration from the development environment? Well, if you remember back to when we initialize the proxy, remember the API token part here. Or in here, we've specified the development environment as part of the API token. And actually, we configured that when we created the token. So if we head back to the UI, and we go to the API Access section, when you hit Create API token, you have the ability here to change the environment. So that determines which environment it's going to fetch the configuration for. Alright, so now we know enough to implement this in a real application. Alright, so we're back to the component that we started with. And now we've taken it out of the Free Code Camp codebase. And we moved it into a create react app project, just to reduce some of the mental clutter and overhead when we're working with this. And we've done some modifications that will use a feature toggle to turn on and off. And we'll go ahead and take a look at that now. So in the app js file, you can see what's currently being rendered to the screen. And inside of app, we have a conditional render component. And based on the condition that is given, it's either rendering the applet chatbot component, or the app without chatbot component. So currently, it's rendering this last component here. And you can see these are defined in the same file. So let's see what happens when we flip this to true just to get the visual confirmation here. And you can see now we have this chat button in the bottom of the screen, we can click that. And we can type into the message box here. And this is what we want to feature toggle. So this is our feature. And we want to turn it on for a subset of our users. So in order to do that, let's go to the unleash instance here. And we'll create a new feature total. We'll call that chatbots. And we'll go to the strategy section. And we'll add a bungee to the development environment. So we'll set it to be a gradual rollout of 0% to begin with. And then we will turn on the environments here. From here, we can go ahead and start connecting our application to unleash. And we'll do that by using the unleash proxy client or react. So we just need to follow the instructions here. And we'll start by adding the unleash proxy client to our project. So open this up and add the proxy clients. And then we can repair a little bit by taking this part right here. And going back to our project, and then we can paste this in. And now we need to make sure that the conflict is correct. So we'll swap this out with localhost 3000. And make sure we're on HTTP, the proxy key is going to be let's go ahead and check that. Some secrets are put that in as well. We'll set the refresh interval to be five seconds. And we'll change the app name to FCC play. Though the environment here is not related to the strategies that we talked about earlier, this was actually in place before we added strategy support. But the only thing that affects where you are patching, or which configuration you are fetching is the API key and the configuration of that API key. Okay. So with that said, we now have a config that we are supplying to this flag provider. And we should be able to add into our app component and start using our feature flags. So in here, we're going to grab a few things from the proxy files. So we'll import the use flag and use flags status. And what we can do now is we can say enabled equals US flag and then we need to pass the digital name here. So let's go ahead and make sure that this is the actual name of the future tutorial. And we can see that here. So that should be fine. If we now head back, we can go ahead and See his flag status and want to grab bags ready from this object. So if not bags ready, we are going to return a loader just a simple loader now. Otherwise we'll use the enabled flag to render the correct version. Let's log this out as well after the flags ready just to make sure we are triggering that events. So if we go back to the browser, and now we can open up our application. And if we refresh here, we expect to see the loading flash, and we expect to see the Boolean load down in the console. And we do so the SDK has successfully been wired up. And it's set up a polling in the background. So we go to unleashed now. And we change this gradual rollout to be 100%. That should be reflected, and we go back here, we should be able to see that the new components is being loaded, because this has been put to true. The now the conditional render is reloading the right component. So if we hit here, we open the Chatbot. And we can interact with it. And we can also go back to unleash and turn this off again. And that should propagate and remove the Chatbot. Nice. So I never get tired of seeing that. Even though this is just localhost. When you're doing this in production, it just feels like magic. And now we've seen how it behaves when you have that 0%. And when you have that 100%, which is what we expect. It's either 100% on or 100% off. But let's try changing the gradual rollout to 50%, for example. And we'll hit Save. And let's go ahead and refresh this page. And we'll refresh just a couple of times here. Because we would expect the chatbot to turn up 50% of the time, right, because that's what we set the gradual rollout to, but it seems like it doesn't. So there's something going on here. Let's copy this URL. And we'll open up a new incognito window. And we didn't get it there. Let's try this again. And not there either. So maybe third time's a charm. And not there either. So that's interesting, because it is a 50% chance. And there we have it. So here it turns up. And the reason that it turns up here, and if we refresh this, it's going to stay here. Because we are using the session ID to ensure that we get the same experience. So if we take a look at this call here, you can see that the session ID is sent as a parameter to the proxy. And as long as you stay within the same session, you will get the same experience. Because we don't want this to change just randomly, right, we want the users to have the same experience even if they reload the page in the same session. That's why in our other tab, we don't get the Chatbot, because we already received a version of the site that does not have the Chatbot turned on. And even though the percentage is set to 50%, we are now in the category that will not receive the feature. And this is quite useful, because we want to be able to keep a consistency in the way that the user experiences the site. Now, session ID that's quite limiting because the user might turn off their computer, they might go on their phone, they might visit a friend's house and use their computer and then the session ID can't be used in order to determine whether or not the user should get the same version because the session ID will be different from time to time. And maybe there's a way we can look at where we can actually keep it consistent. Even If the user changes their device, and to do that, we need to take a look at the English context. So, English context is used for a couple of things. It's used for strategy, standardization. It's used for stickiness. And it's also used to pass properties to custom strategies if you implement those. So there's a few fields here, like dynamic context fields that you can populate. And one is the user ID. Another is the session ID. And then we have the remote address. And finally, we have the properties, which is a map that you can very can put anything you want. Now, remember back to when we talked about the architecture, we said that when the SDK does the evaluation, it receives the configuration from the unleash server. And then it takes the context that it receives. And it merges the two together, and makes a decision on whether or not this is on or off. So to illustrate that, we're going to take a look at the code here. And this is the Node js SDK, which is basically what the proxy builds upon, it wraps around this SDK. And this here is the is enabled call for a feature toggle. So you received the feature toggle name. And you can see we received the context as well. And what is happening here is we're taking the feature from the internal repository of the SDK. So that means that the SDK has already fetched the configuration from the unleash server. And it will use that configuration together with the context and make a decision on whether or not this feature is enabled. And this is also why we recommend self hosting the proxy because the user data or context that you send from the client application, that's going to be used, as we just discussed, to evaluate the toggle in the proxy. And that's where the data flow stops. So the user data does not go to the Unleashed API. So if you self host the proxy, you have 100% control over your data. Alright, so now we've seen a little bit about the unleash complex, let's go ahead and implement this and see if we can use that to get a consistent experience for our users. So we'll open up the unleash proxy client documentation. And we'll scroll to the bottom and check the documentation here for the context. And it looks like we can take the use and least context hook and get a function here. So that's what we're going to do. If we open up our code, we can add the use and which context here. And we'll say Update context, equals use unleash context. And then we are going to add a use effect here. So we'll add that to the Import up top. And we'll say use effects. And we only want this to happen on nouns. And then we want to update the context with a user ID. And let's call this user one for now. And this should be enough for us to be able to provide a steady experience for the user regardless of the device. Because if we have back to the Alisha instance, and check out the gradual rollout strategy here, you can see that we have the stickiness set to default. And the default actually checks for a user ID in the context first, then the session ID. And if it can't find either of those, it's going to be random. And you can explicitly choose user ID or session ID here. But the default is going to look for first the user ID and then the session ID. So this should be enough for us to get a sticky experience. So let's check it out. If we go to our application, and we open up the developer tools, and we can now see that the costs that are being sent to the proxy, include the user ID here. So this means that no matter how many windows, we open up, we should get the same experience to remember when we did this before, it was a 50% chance that we would get another experience. But now you can see that the experience is the same no matter how many times I will open this new window. Let's try one more time, just to make sure we are completely sane. And we can see that we still have the same result. Now, let's jump back to the code. And notice that the value use a one here is hard coded. Now, this doesn't really make sense, because that means that every single user that visits your site will use this value to hash and get the same result, every time, what you typically want to do is you want to get this value from an API. And that's going to be a unique identifier for each user. And this will ensure that every user gets a different result. Alright, so we've taken a look at the gradual rollout strategy. And we've also been through the unleash context. And now we can also take a look at some of the other strategies that we have available to us. So before we start, let's go ahead and put the gradual rollout to serum. And we can go ahead and add a user ID strategy. Now, a user ID strategy is typically a strategy you want to use while you're developing something, because it will allow you to ask a set of user IDs that will get access to the feature. So you could have this behind a feature flag in production. And you could give access to a specific set of users, which could be the developers or maybe a product manager, or a tester or another stakeholder in the organization. So if we put in user one here, and we add this, now, we will see that the execution plan is updated. So 0% of the user base is included, and will give access to one user. So if we go back to the application, now we can see that we have access to the feature here. So we can go ahead and open up the Chatbot again. And now we can do exactly the same as we did with the gradual rollout, we can go ahead and either remove this strategy entirely. Or we could just remove the user. And if we now head back to the application, now we don't have access to the feature anymore. So that's completely based on the values that are sent into the context that we just discussed. So since I have user one, as a value here, I will get access to this feature if my user ID is defined in the strategy. So if I go ahead and go back to the strategy here and put user two, that's not going to work, because my user ID is user one. So if we go back to the application, we can see that we don't have access here. But if we go back to the strategy again, and add our user ID, and hit save, you should be able to see that the teacher now shows up again. And we can once again open up and interact with each other. Alright, so now that you've seen how to use the user ID strategy to give access to certain users, let's jump back to the Unleashed instance. And we'll have a look at the strategy is section here. Because what's really cool is that you can have as many strategies as you want. And as long as the environment is on, they will all be evaluated. And if any one of them return true for the given context, then the feature will be on for that user. So that means that if you have a gradual rollout set to zero, like we have here, then it will be on or no users. But we will also go ahead and check the user ID strategy. And since my user ID is user one, and I passed that in, I still get access to the feature. So every strategy is evaluated. And that makes it really flexible. Because you can add as many strategies as you want that constraint on different properties. And you can even create your own custom strategies and provide the implementation in code so that you can create strategies that don't really exist in the system out of the box, but that you need in the complex that you're operating in. So if we open up the sidebar here, we can take a look at the built in strategies. And we've already been through two of them. And the IP and host strategy work very similarly to the user ID strategy. So if we add the IP strategy, we need to provide an IP here. And once we've added that, and we saved the strategy, we can see that the execution plan is updated. But now we need to take this IP, and we need to add it to our code. So let's go ahead and remove our user ID, because we want to see that we don't have access to the feature anymore. If we jump back to our application, now we don't have access to the Chatbot. But if we go ahead and take this IP address, and we head back to the code, now we can add a remote address property here. And we put in the IP address. And let's go back to the browser. And now we once again have access via the remote address strategy. So all of the strategies have been evaluated. And this final one return true. So we get access to the feature because our IP address matches the value that is put in here. Alright, and now we've gotten our feet a little bit better with feature toggles. And we've seen how we can use branches to target different segments of the user base. So what I want to focus on next is experimentation. And sometimes, as developers, we want to develop different versions of a feature, and try it out. So we can determine which one performs better. And that's a process that keeps the users close to us. And that's important, because we don't want to just take a feature and run with it and develop something that we think is right, we want to continuously validate that we're actually building something that gives real value to our users. And in order to do that experimentation, and a B testing can be quite powerful tools that we can use to figure out which one performs better. And I'm going to show you how to do this in unleash. But before I do, I just want to mention quickly how we think about working with other services because we don't have any built in analytics in release. And one of the reasons for that is actually back to our philosophy. Because we believe that there's a lot of software being written today. And there's a lot of great work that others do. And, for example, analytics, you have great providers that provide a world class analytics experience. And we believe that it's our job to make as many integration points and provide as flexible as system as possible. So that you can use the great work of others, and combine services to gain a better experience. So we're not really focusing on implementing analytics in the traditional sense when it comes to experimentation, we instead focus on giving you the option of taking some provider that you're probably already using today. And pairing that with data from unleash. And then you can send that off to your analytics provider and do the necessary analysis on the data. So with that said, let's jump into it and see how we can do some A B testing with unleash. Okay, so here we are back in the unleash application. And we've done a little bit of cleanup on the Chatbot pitch toggle. As you can see, we removed some of the strategies that were here before. And what we're left with is the gradual rollout that's rolling out to 100% of our users. So we're going to use this feature toggle and set up an ad experiment. And in order to do that, we'll need to learn about a new concept and unleash old variants. So we'll navigate to the variants tab. And we'll go ahead and add a couple love variant a here and then we'll add another one. And now we basically have the setup that we need. We still need to do some work on the code side of things. But before we do, let's try and understand the weight distribution here. You can see that each variant has a weight distribution of 50%. And this means that if the percent of the year users that are visiting our site and that get access to this feature will get variant A, and 50% will get variant B. So let's take a very concrete example and say we have 100 users visiting, we have a gradual rollout that says that everyone visiting will get access, that means that 50 users will get variant A and 50 users will get variant B. But let's change the strategy just to see how that affects the weight distribution. So we'll change this now to 50%. And we'll head back to the variance. Now, let's take the same example. Again, we have 100 users visiting our site, we only have 50% rollout. So that means that we only have 50 users that get access to the Chatbot feature. And since we have a 5050 weight distribution, that means that of those 50 users 25 users will get variant A and 25 users will get varying B. So it's all relative to the amount of people that get access to the feature toggle. So you can think of strategy's sort of like a gatekeeper that lets people through or not. And then the variants can be thought of as pathways that we send the people that get through the gates, on after they are led through. So currently, we have variant a and variant B, which means that there are two possible pathways for the people that are lit through. And we could easily add more pathways if we wanted to. But hopefully that makes sense. And we'll now go ahead and implement the code side of this. So before we jump to recode, let's head back to the strategies. And we'll make sure that we set the gradual rollout back to 100%. And with that, we can check that we propagate this to the application. And we do so let's head into the code now. And we'll grab the use variant hook from the unleash proxy client library. And then we'll do variants equals use variant. And we'll put in the feature toggle name. So with that, we can go ahead and log this out here. And we'll open up the console. And we can see here that B got the variant A, which corresponds to the variant name that we added for one of the variants. You see. Here, we have the variant a here, so we automatically got one of the variants that we defined. Now, we also have the enabled true here, which means that we don't really need to use the US flag hook anymore, because we get both of the data properties in this object. So we'll go back to the code. And we'll remove the enabled. And then we'll say, aren't enabled here. And we'll pass the variant as a prop here to this app with chatbot component. And let's accept it here. So what we want to do now, based on this variance, we are going to render a different welcome message in the chat bot. So in order to do that, let's create a new function inside of the configuration here. And we will create a config method which is going to take a welcome message and it's going to return the configuration that we put in here but the initial message is going to be the welcome message. So we'll export the complete function. And then we'll head back to app J S. And we will rename this Okay, so let's remove the use flag here since we're not using that anymore. And we'll scroll down to our app with chatbot component where we are accepted In the variant as a parameter, now we're gonna do config equals yet conflict. And then we want to paste in the message here. And I've already prepared that. So we skipped some typing. But what we want to do is we want to check the variant name, like we're doing here. And if the variant name is variant A, then we want to have this folk message. Otherwise, we want to have this welcoming message. So we'll hit Save. And we'll pass this into our git config. And we are passing the config here. So everything is as it should be. So with that, we can go ahead and open up the browser again. And you can see that we get the welcome message here. And if we refresh, and we open up the Chatbot. Again, there we have the same message. So that's working fine. So let's see if we can trigger this message here as well, because right now we have been given a variant. And that variant is not going to change because we have passed in the User ID here. And that will ensure that the variant is sticky as well. So we'll get the same experience whenever we open the website. But what we could do in order to trigger or force a change is we can take this user ID here. And we can go back to our unleash application. And inside of variant B, we can go ahead and add an override. And you see here we have a context field called User ID. Let's put our user in there. And we'll hit Save. And you can see now we have an override on this variant. If we go back to our application now, and we refresh. Now we can see that we have another message. And that's in fact, the message that we provided as an alternative. Cool. So here, we use invariants, to change the messaging in the chat bot when we launched it. But that's a simple example. And if we take a look at the code, all we're really doing is we're checking the variant name, and then doing something based on that. So here we're changing the text. But it could easily be rendering a different component, or changing something within another component. It's really up to you, and what your experiment entails and how you want to go about it. But it's as flexible as it needs to be to cover the use cases that you could have. And here we only have two variants, but you could easily have three or four or five. And that's up to you and your your now let's talk about analytics. I mentioned briefly before that we prefer to defer to world class analytics providers. In order to allow you to integrate with providers that you most likely are already using today, I wanted to show you how we can use unleash together with your analytics provider and create a trail that makes it so that you can track a given variant through your application. So I'm going to show an example with Google Analytics. And I've already installed the React Google analytics package here. So let's go ahead and initialize it. And then we'll take a look at how we could do this. So what we'll do is we'll import react GA from react, da. And then we'll go ahead and initialize it. So inside of our application, we can put it in a use effect. We initialize it with the following parameters, and then this would be your unique Google Account Key. Alright, so let's see a few more changes. First of all, we'll create a variable for our user ID. And we'll put the user ID in here. And then we will paste that in here. And we'll replace the value here as well. And then what we'll do is we'll go down to our ackward Chatbot. And we'll go ahead and add a use factor as well. And we'll make it dependent on the variant. And we'll see if variants name and variant enabled. Let's do react, da. And we'll use an event here. And then we can send an event to Google Analytics, you can see the label application loaded. And let's go ahead and add the variants. That's going to be the variant name. And then we'll give it an action. This required property, we'll say location loaded with a with the variant name. And we'll also want to give the user ID here. That means we need to go up in our parent component, we need to pass in the User ID here. And we'll accept that as a parameter. And now, I have the ability to send an event to Google Analytics. And that event includes the user ID and the variant name. And that means now you have your baseline, because you have the user ID, and you know that which variant that user ID loaded up with. So if you're tracking more actions on your sites, for example, if you want the user to convert, or in this case, let's say we wanted to check whether or not the user is interacting with the Chatbot, based on the message, we could go ahead and add more events with the user ID and the variant name in other places of the application where it makes sense. And we know that the action has been taken by the user with this variant, okay. So that's the way we can track the user across the application, if that's what you want to do. Alright, so I want to show you a little bit about the metrics as well, because one of the coolest things about feature toggles systems, you can see the updates live. And you can see who is getting access to what feature or how many people are getting access to a feature. So when you wire up the SDKs, and you put up the API key, you'll start sending metrics based on the environment that that API key is configured for. So I currently have a script running that's calling against the API with an API key that's enabled for development. And we currently have the strategies set to 100%. So we have the gradual rollout that to 100%. So everyone who is asking against this API is getting enabled back for this feature. So let's go ahead and update this. We'll set the gradual rollout to 50%. And we had back to our application. Now, we're going to be able to see as this updates that more and more people are getting denied the access to the feature, and it's going to creep back towards the 50% mark over time. And that's how you can be sure that when you're setting a gradual rollout, or you're setting his strategy configuration that you expect is going to be enabled for a subset of your users, you could use the metrics to verify that that is, in fact happening. And now we can see that we're slowly making our way towards the 50% mark. And more and more of the users are asking for access towards the API or getting denied, which is what we expect. Right? So we talked about metrics a little bit. And besides that, there are some other methods for monitoring that you can do in Unleash. And if you remember, we talked to a bar earlier about technical depth. And we take it really seriously because you have to be able to clean up your code and remove feature flags as you go along to have a sustainable workflow, and you're working with pitch dollars. So I'm hearing the demo instance because it has a lot more feature flags available. And I want to show you the health dashboard that we built, which is sort of a work in progress, but We have an early version of it ready. And we can add on to the project. And this is a demo instance that anyone can log in and use. So there'll be a lot of projects here and a lot of data. Because it's kind of a sandbox that anyone can use some trial unleash. So if we head over to the health section here, you see we have a health rating, and we have a toggle report. And then we have all of the feature toggles in this project down in the overview here. And you get some information here, basically, the name of the toggle when it was last seen, which is when did we last register and SDK asking for this feature toggle. And so it's if it's never seen, then you've never connected up in SDK and started to use this feature toggle. But if you do have a value here, and then you know that it's a base, since this last was in use, which might indicate that it was used in a local environment, and not in a production environments, because if you're in production, you would expect it to be continuously asked for. And then you have like, you can see some more information when it's created. And there is an expired column, which basically, based on the type of each table you create, we use some internal data to calculate when it's expired. And for release toggle, that's about 40 days. Because that's what the research indicates that should be the lifetime or life expectancy of Tableau like that. So you can use this dashboard to get an overview over toggles that might be ripe for cleaning up, and it can help you in the effort to clean up your troubles and get rid of some of the technical depths. Alright, that's it for the course. And I want to thank you so much for tuning in giving me the opportunity to explain this concept. And I hope it's been a valuable lesson in terms of understanding how to work with feature toggles, and how we can use them to simplify your workflow and run experiments within your code. Now, if you're wondering where you can find on leash, we're on social media, obviously, but the most important part is the code that's on GitHub. We are after all, an open source organization. And you can go to the unleash repository, and you can browse through all the code. And if you want to contribute, there are opportunities for that as well. If you have any other questions, you can tune into our open Slack channel, or we'll be happy to help you along if you want to get started using feature toggles. Now, if you want to know where you can reach me, I'm on Twitter under at F Allsburg. Or you can find me at my YouTube channel, which is called Frederick Osbourne recording lessons here on YouTube. And with that, I hope you have a really great day