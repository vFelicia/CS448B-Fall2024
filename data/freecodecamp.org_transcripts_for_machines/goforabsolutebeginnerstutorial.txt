learn the fundamentals of go by building a full stack payment application go is a powerful and efficient language designed for modern software development you'll learn everything from basic syntax and data types to Advanced features like go routines and concurrency patterns Georgio tonson developed this course by the end of this course you'll have the skills to build robust high performance applications using go hey what's up everybody my name is Georgio and I'm going to be your instructor for this go programming course in this course you're going to learn everything that you need to know to get started programming in the go programming language although go is a relatively new language It's Quickly becoming one of the more popular languages for large companies to introduce new products and services and has been used in some very popular Technologies such as kubernetes and Docker this means that if you're looking for a job this is a very useful tool to have in your tool belt in this course I'll teach you everything that you need to know to get started programming and go we're going to go over all of the Core Concepts and go and we're going to build a backend for this beautiful minimalist frontend product store Page now the front end or user interface that I just showed you isn't so much going to be what we're going to be focusing on because go is primarily a backend programming language and by backend I I mean everything that happens behind this pretty web page to make the process and functionality of purchasing a product possible so essentially our Focus as backend Engineers is the internal functionality that happens behind the user interface which is hidden from the user which happens to be the most important part of any functioning application now if you've never built a website before or you've never coded before don't worry I'm going to to teach you everything from scratch and if you're a complete beginner again don't worry I designed this course for anybody interested in learning how to program using the go programming language you're not too old and you're not too young the cprogramming language is so Compact and minimalist that there's really not much in terms of memorization and I'm confident that I can help to get you over that initial difficulty curve that most people experience when they're First Learning a programming language I'm super excited to have the opportunity to be able to teach you the go programming language so I hope that you stick around and learn this beautiful and Powerful programming language so let's take some time to go over what we're actually going to be building here so we're essentially going to be creating the back end for this product page so this product page is essentially a place where a customer can select a product to purchase and the customer will input their information such as their shipping address and their payment details and when the customer actually fills out this form and fills out their payment details we're actually going to send those payment details to a payment processing platform on the back end and that payment processing platform is called stripe and this is Stripes documentation you don't have to worry too much about what's happening here now we're going to get to that soon but basically here's a list of test credit cards that we can use to actually test the functionality of our application so we can use this dummy credit card here and we can go ahead and put that credit card number into our checkout and we can put any expiration date and any CVC and when we select pay now it's actually going to send that request to the backend so actually if we bring up our backend here so I'm currently running our backend server on this system and if you don't know what I mean by that don't worry because we're going to get into all of that but this is just to give you a general idea of what we're going to be doing so don't worry too much about this part yet but yeah the code that we're going to be writing for the backend server is actually going to be capable of processing real credit card payments like we're actually going to be creating something that could be used in a real world situation maybe if you wanted to sell your own product and since that is the case you're going to learn a lot about how to protect the customer and security while learning the go programming language okay so before we get started there are a couple of things that I should mention so this entire course is going to be done on Mac OS it is possible for Windows users to follow this course but the OS Specific Instructions are going to be Mac OS specifically Mac OS monter version 12.6 and with that being said the next thing that we need to direct our attention to is the installation of the go programming language and a code editor but before we get to that point we're going to need to go ahead and select our LaunchPad and I want you to type into the search bar the word terminal and you should see this terminal application which comes default on all Mac OS systems now this application is going to be very important so there are some Basics about how to use this that I'm going to need to go over with you before we can install the go programming language so let's start by opening this terminal application now throughout this tutorial whenever you see me making use of this black box this is the terminal application that I'm using and you're going to want to become familiar with this application because this application's going to be used for many purposes in the development or programming world and for this course you're going to need to follow along with some of the commands that I execute within this black box and you don't need to have any experience with this I'm going to walk you through every command that I use and every time that I make use of this terminal I'll explain exactly what it is that I'm doing so for now let's start with our first command and we're just going to type CD into this terminal window so this here CD is a command and it means change directory so if we go ahead and hit enter you'll see that nothing really happened because when we type in the CD command without anything after CD it's just going to move us to the user home directory and what I mean by that is this so our current user is going to be shown here to the left of the at symbol so whatever your username is it's going to be shown here so that's the current user right typing in CD without anything after it and hitting enter is going to take us to this user's home directory so if we go ahead and select our finder here we should be able to find the current user's home directory and on Mac this home directory is hidden from us by default so we're actually going to change a couple of the settings for our finder here to make the explanation of this terminal more intuitive so let's go ahead and make sure we have our finder open and then in this bar up here we're going to click View and we're going to select show path bar and what that's going to do is it's going to have a bar down here that's going to show us exactly the path to the folder that we're currently in so if we select desktop it'll show the path down here so this is our systems HD and then we're in the users folder and we're in the conton user and we're in this user's desktop now this folder here that has the same name as the user that is the user's home folder so if we go to users here you can even see that it has a house in it this is the home folder for my user here so if we go into that folder we'll see all of these folders within that folder right if we go back to our terminal here and we type in the command LS it's going to list the folders in our current directory or the current folder that we're in and as you can see these folders here are the same as the folders here and you might be confused cuz this Library folder shows here but it doesn't show here but that's just another annoying thing that Mac OS does they hide the library folder from the graphical user interface for some reason there's a way to make it visible but I don't feel like trying to figure out how to do that right now but as you can see in our terminal we're currently in my users home directory so what CD does is it changes the folder or directory that you're in so if we want to move into one of these folders so say for example we want to move into the desktop folder relative to the folder that we're in we can move to the desktop folder so we can just type CD and then desktop since the desktop folder is in our current folder and this will take us to the desktop folder and you might get this warning here just hit okay and then you can see here what folder you're actually in currently and if we LS here we get nothing because in the desktop folder there's nothing right but we can actually create a new folder and call it Tex test and you can see it shows up on our desktop here because this desktop folder is in fact our desktop and now in the terminal since we're in the desktop folder if we list the contents of this folder you'll see that this test folder is now here and we can change directory to test as well and if we LS in test you see that there's nothing because in test there's nothing and if we change directory and we dot do slash it'll move us back one One Directory so now we're back in the desktop folder and if we do it again we're back in our home folder so this Tilda here means home directory so we can actually change to a directory by using the absolute path as well so we can do change directory Tilda which is home SL desktop SL test and this moves us back into this test folder and if we LS here we have nothing but if we add a new test folder inside of here and let's just rename it to avoid confusion we'll say test two if we LS here now we're now in test we now can see the test two folder so these are the basics of navigating the terminal so if we type in CD with nothing after it it's going to take us all the way back to our home folder the Tilda here and as you can see when we list the contents it's the contents of our home folder so both CD and LS are commands that I'm going to use quite frequently throughout this tutorial and these are the basic commands that you can use to navigate the file system of your computer via the terminal essentially all this terminal is is a way to interact and navigate the operating system without making use of the graphical user interface like the operating system doesn't need all of these pretty windows and application icons and everything to work you can navigate and run programs within the operating system entirely through the terminal the graphical user interface which makes everything look pretty and intuitive is actually something that's installed on top of the base operating system but anyways we're going to make heavy use of this terminal and we'll learn more about how to use this terminal throughout the rest of this course so whenever I say to open your terminal or make use of the terminal you're just going to go to this terminal application so for now we can go ahead and close that but we're going to need to revisit that soon once we install go but we can go ahead and move this folder to the trash and we'll move this to trash as well and we can go ahead and close the finder as well so the next thing that we want to do is we want to install the go programming language so with any programming language in order to make use of it we need to have it installed onto our system now some programming languages come preinstalled on your system and some don't and go isn't one that comes preinstalled on Mac so we're going to need to go install it ourselves so we'll open a browser and actually I can't stand Safari so I'm just going to download Chrome really quick so we can just go ahead and open a web browser and you can just type in go programming language and then you can click this first result and you can go ahead and select download now on this page you're going to be presented with all of these different options for downloading so obviously if you're on Windows you would use this one and for Mac users depending on if you're using an apple chip or an Intel chip you would pick one of these so I'm using an apple chip so I'll select arm 64 and Linux you would use this one so I'm going to go ahead and select this one and once the downloads complete I can just use this installer so I'll just hit continue install and put in my password here and once that's finished we can go ahead and close do you want to move go installer to the trash yes and once it's installed you want to go ahead and open up your terminal again and you want to type in go version and if everything installed correctly when you type in this go version command actually I typed in the wrong uh flag for the command it's actually just go version so let's go to the bottom here and I'll just type Go version and in that case you should see the version of go that's installed on your system so another command that we can use is the clear command and it's just going to completely clean up our terminal window and then we can just type go the go command and then press enter and then this is going to tell us all of the sub commands available to the go command and we'll get to what these do when we need them but we don't have to go over all of them right now so I'll go ahead and type clear again to clean things up now just like CD which is to change directory and LS which is to list the contents of the directory go is also its own command and all of these commands have their own doc documentation so for the commands that come preinstalled in the system you can type in man and then the name of the command and it'll show you the documentation for that command so you will see here LS command list directory contents and it gives you a whole bunch of additional information about flags that you can use to modify the command or make the command do different things like for example this a flag include directory entries whose names begin with the dot which are hidden files and directories so for example if I LS here you see that I just get the same contents of my home directory but if I do LS and then do the a flag you see that it now shows these files here that have the dot in front of them so these are like hidden files in your operating system so you don't need to know what all of these hidden files do I'm just trying to teach you what these modifiers do to the command so so same with the CD command we can type in man and then CD and it'll show some documentation for the CD command and we can also do man man because man is the command that we're using to show the documentation for each individual Command right but that in itself is a command as well and you can see the description format and display the online manual pages but you'll notice that if we type man go there's no manual entry for go because we installed go ourself that doesn't come preinstalled on the system so let me clear this so for go what we can do is you can type in go and it'll show you the different flags and sub commands available and If you read here in the documentation for the go command you can also use go help and then the name of the sub command for more information about that command so for example there's go clean which remove object files and cached files so if we type go help clean it'll give us more information about the subcommand clean so you can see here we typed go help clean and it gives more information clean removes object files from package Source directories etc etc now again you don't need to memorize or know any of this stuff this is just me trying to get you familiar with how the terminal works so we just installed go so now we have this new command the go command and we're going to be using this go command throughout the rest of this tutorial so again once you've installed go if you type in Go version you should get the version of go that you installed if that doesn't work then it means that you didn't install Go properly so that's how you install go so the next thing that we need to install is a code editor or an IDE so I can go ahead and close Safari and let's open Chrome again and we're going to go ahead and type in go land and you'll see this jet brains goand you want to select that and we're going to install the free trial version of goand so goand is actually a paid IDE but there's a 30day free trial that we can use which is more than enough for you to get through this course and you don't need to bother yourself too much with what IDE is just know that this application or this tool is going to be what we use to write and edit our code so you can see images of its usage here like we're basically going to be writing and editing our code inside of this tool so this isn't a very good comparison but just think of this as like the Microsoft Word for code so we're going to go ahead and hit download and then once it's done downloading we can go ahead and just move it to our applications folder and we can open our Launchpad and opened goand we'll select open so for those of you on an M1 Mac you might be asked to install Rosetta and when you hit install you might get this installation failure you can go ahead and hit done and then just type this command into your terminal so the command is software update D install D Rosetta and then hit enter and then you'll get this I have read and agree to the terms blah blah blah type A and press return to agree so you just type A and hit enter and you should be able to successfully install Rosetta via the terminal this way then we'll just hit clear and once that's installed you can just open Goan now and of course you need to sell your soul then go ahead and continue and once goand opens it's immediately going to open up this second window about licenses and instead of hitting this activate goand we're going to do start trial because we can use a free trial and if you don't have a jet brains account which I assume you don't we're going to hit register and you can go ahead and create a jet brains account so I'll just use my Google account now once once you've registered an account you should be able to go back to goand and log into jet brain's account but as you can see I've already registered my account and I've already signed up for a free trial but for you to do the same you're just going to want to log in to Jet brain's account and then once you log in successfully you should see this authorization successful screen and then you should be able to go back to the IDE and then there's a button here that says start trial and you should be able to just select that button to start your trial and after that you should get this message that tells you how long your subscription will be active and then you can just hit continue and at that point you'll be free to use the goand IDE for 30 days now before we get started we actually need to do one more thing so you want to go ahead and open up your terminal again and we want to type in CD to make sure you're in your home directory remember the Tilda means that you're in the home directory and let's go ahead and open our finder as well just so we can see what we're doing and we'll go to the home folder so remember home directory and home folder they're synonymous they're the same thing so if we list the contents here it's going to be the same as as the contents here so now we're going to introduce a new command called mkdir and this command stands for make directory so if we type in the man command and then do mkdir we can see that this command makes directories and a directory is just a folder right and I forgot to mention this before but to leave this manual page once you use that man command you can just type Q so in our home directory or our home folder we want to create another folder using this mkdir command and we'll call that folder go and then we'll just hit enter and you can see now that the go folder appears in our home folder and also if we LS here it's here as well cuz they're both the same place so now we want to change directory into the go folder and let's clear and here we can just open the go folder as well and we want to make three more folders mkdir the first one we're going to call PKG the second one we're going to call SRC and the third one we're going to call Bin and you don't need to concern yourself with what these folders are for right now this it's not important just know that the source folder is where we're going to put our project so the code that we're writing is going to go in this Source folder but actually this Source folder is supposed to contain all of our projects so let's say for example we had let's change directory to Source let's say for example we had three separate projects we would have makeer project 1 makeer Project 2 makeer project 3 so the source folder whenever we start a new project in go we're going to put a folder for that project inside of this Source folder so in our case we're just going to make a folder called go tutorial and in this folder is where we're going to put all of our code which is going to be the code that's going to be the backend for that frontend user interface that I showed you at the beginning of this video the one where the user or the customer can purchase a product so remember we're creating the backend for that user interface and it'll become more clear what that means as we continue throughout this course so we can clear this and actually we can just leave these example projects there just so you can see what I mean by this Source directory being where we centralize all of our projects for go so now we can close the finder and we can close the terminal and what we're going to do is in goand we're going to start a new project and remember this new project is in our home folder in the go Source directory and it seems goand already knows that except for the name of the project is wrong it's it's not awesome project so we'll go ahead and hit that and you can see our project in the source directory here go tutorial so the location of our project is in users your username the go folder that we just created The Source folder that we just created the Cod tutorial folder that we just created and we can go ahead and create this project now in the beginning you're going to have to wait for it to load up some things but while it's loading I just wanted explain something these idees or these code editors they're they're very daunting when you first look at them but honestly there's like only 30% of the stuff in this code editor we're going to be using there's so many tools and features and like quality of life stuff in these idees like a lot of the stuff you might not even use so you don't need to worry about how daunting it looks or if it looks overwhelming in the beginning you just need to focus on a couple of key things so the main main thing we want to focus on is this project tab here so this is our current project it's the tree structure it's like the folder structure of our project so right now this is the project folder right if we expand this it'll show the file that's inside of the project folder and actually this file was just created by the IDE so I'll show you what I mean by that in a second but first I need to explain to you another cool thing that's available in this codee editor or IDE you can actually use the terminal from here so if we hit this terminal tab it'll open a terminal here same as the one that we've been using but now it's just integrated with the IDE so if we LS here we see this go mod file and we can also CD and it'll take us back to our home directory and we can LS and we see all of the folders in our home directory same as before so our go directory is where our source folder is and in our source folder we have our go tutorial project and if we LS go tutorial we see that this go mod file is now inside of this go tutorial project folder and that's because the IDE or the code editor automatically created this file for US you don't need to know what this file is for right now so don't even think about it don't worry about it at all but yeah this project tab here is basically going to show us the structure the tree structure containing all of the files so we could even for example create a new go file here and for now we'll just name it main.go and you can even do simple application so it'll initialize the file with some code but it's just like the initial code for creating a application so we can just go ahead and let it do simple application so now you can see in our go tutorial folder we have this main.go file and it's a simple application so it has some code in it already and you're not going to know what this code means yet but I'm going to explain all of this in due time so if we clear our terminal here and we change directory to go tutorial and we LS again you you can see we now have this main.go file and this go mod file same as what's represented here in this tree structure now that is the setup now we're going to start getting into the fun part which is actually writing the code for our application okay for starters let's set up the front end for the back end that we're going to build so you can go ahead and open up your terminal application here and once you have that opened up you can go ahead and open up a web browser browser and head over to my GitHub page I'll have it linked in the description and you want to select this repositories Tab and here you'll see a repository called Go for beginners front end and what you want to do is Select that repository and on this page you'll see that there's the instructions for how to set up the front end for this tutorial so step one we're going to build the client app and The Client app is just the client for for our backend so it's just the front end for our backend and then it gives the instructions on how to run the client app or run the frontend app and also gives the URL where you can access that front end that I showed you earlier so what we want to do is we want to go up here to the top where it says code in green and you want to click that and you just want to copy this here and once you've copied that you want to go back to your terminal and just type in get clone and then paste in that URL that you just copied and from there you should be able to just hit enter and it should clone that repository or that frontend application to your home directory because currently we are in our home directory so if we LS here we can see that this go for beginners frontend folder has been added to our home directory so now we can just change directory to that go for beginners folder and then we can LS again and now you can see the contents of the actual repository here that you cloned this is these are the contents so we have a public folder a source folder and some files those now exist on your local machine in this go for beginners frontend folder in your users home directory so so once again if we go ahead and hit the finder here and we access our home directory and then we access this go for beginners frontend folder these are the contents that you just copied to your system and these are the files that comprise our front frontend application now this frontend application isn't going to be the focus of this course so basically the front end application is already prebuilt so we're not actually going to build this front end we're only going to build the back end that the front end needs to communicate with because this is a go tutorial so we're building the backend in go but for the purposes of actually integrating a front end with the back end that we build I prebuilt this front end that we can use to interface with our backend essentially so since it's already prebuilt we should actually be able to just run this front end from our machine right now as it is so we can go ahead and close close this and in our terminal we can clear and remember we're still in this go for beginners front end folder now in order to run this frontend application we're actually going to need to install a couple of things a couple of dependencies that are necessary to run this front end because there are some commands that we need to be able to install to run this but as I go through this just remember that these commands that we need to use and these dependencies that we need to install you don't need to have more than a basic understanding of what we're doing you don't need to understand what each command is or what dependencies are what you only need to understand that we're basically installing some things that we need in order to run our front end and basically from there everything is already prebuilt so let's just go ahead and attempt to follow the instructions so these instructions here let's attempt to follow them so it's saying that we need to run this command in order to build this app the front end app so we can just copy this and paste it into our terminal and hit enter but as you can see we get command not found mpm and that's because we don't have node installed now node is just one of the dependencies we need to run this frontend application so actually if we just copy this and head over to Google and paste that in there and press enter you can see this stack Overflow result will tell us like if it's not there install node.js again but basically what I'm trying to say is the reason I pasted that into Google is just to kind of give you an idea of how you should handle situations where you get stuck in the future but for now of course I'm going to walk you through all of this but that's just kind of a hint towards the future but yeah essentially we need to inst install nodejs so install nodejs now again you don't need to know what nodejs is if you're beginner you just need to know that we need to install this in order to run the front end so let's go ahead and select this download nodejs and I'm going to select the Mac OS installer and once I have the installer I can just select this and using this installer we can go ahead and install node.js and you will need to put in your password and from there the installation should be selfexplanatory so we can go ahead and close that and yeah we'll go ahead and move that to trash and now we should be able to do this mpm install command now you'll see a lot of noise while this MP install command is running but don't worry about it as long as you don't get an error things should be fine so let's actually just clear this up to make it look cleaner and we can go back up here and close this node.js download and now we did this first step so the second step is to run the client app so she we should be able to just use this mpm start command so we can copy that and paste it and hit enter now you might get something like this you can just go ahead and allow it and here we're getting the site can't be reached so let's go ahead and check our terminal for the the issue now as you can see we have an error here that's not allowing us to actually access our front end or run the front end and I actually already know what the solution to this error is so I'll just show you what it is so what we're going to do is we're going to clear this and let's just change directory back to our home directory and here you should type LS L and if you don't see a file here that says zshrc then you should create that file so I don't have that file so I'm going to create it and you can create it by typing in the command touch and then you can just put zshrc and then hit enter and if you lsla doz shrc you'll see that we now have this file that exists in our home directory so now I just want you to type in the command cat and after cat you're going to type quote export node options equals dash dash open SSL Legacy provider and then end quote now here you don't need to know what this is doing this isn't a part of the tutorial at all this is just the initial setup that we need to do so after you type that you want to put an arrow and then space and let me make this wider so you don't get confused by it looking like it's on a new line it's on the same line then you put zshrc and then there you should press enter and actually I just had a complete brain glitch we're not using cat command we should be using the echo command so we're going to type in the exact same thing that we just typed but instead of cat we're going to type in the word Echo and then press enter and to confirm that this worked correctly if you type in cat. zshrc it should show this export that we just wrote in this initial Echo command and once you do that you should be able to just type source. zshrc and then hit enter and lastly you want to type in EnV pipe grep node and then hit enter and you should see this node options equals open SSL Legacy provider now I know that was a lot but you don't need to understand any of what we just did this is just preparation for being able to run the front FR in application so if you can just follow the instructions as I presented them then you should be fine now we should be able to clear here and we want to change directory back to the Go for beginners frontend directory and once again we should try step two of the instruction so this one here mpm start and this should work now so now as you can see we have our frontend running as expected so if we go ahead and enlarge this you can see we have our products here and we can select a product so we should be able to input a address here and from there we should be able to hit next and here at the point where we reached the checkout we shouldn't be able to do anything yet because we haven't implemented the backend that needs to be called in order for a customer to check out and make the payment but if you're able to reach this point then you've successfully set up your front end for the back end that we're going to build using the go programming language so for now we can just close this and we can close this as well and here the front end application is going to be running so you just want to press contrl C and that will stop it from running and you'll get back to the command prompt and you can type in clear and yeah we've set up the front end so now it's time to start building the back end for the front end now let's take a couple of minutes to actually explain what we're building here up until this point you'll notice that there are some key wordss that I've been using that you may or may not understand yet and those words are server graphical user interface front end and backend now a server we can just think of as a physical computer computer and we'll get back to that later on in the course a graphical user interface or guei is the interface that a user uses to interact with an application or web application so if we think of the word interface in a general sense it's really just a device or system that two unrelated entities can use to interact for example two people from entirely different countries can communicate or interact with one another via a shared language that language serves as the interface between the two people similarly a human can interact with a computer via the buttons and navigation Tools in an application or on a web page those graphical buttons and navigation tools serve as the interface between a person and a computer more specifically the graphical user interface now the graphical user interface is the part of the application that the the user can see this part of the application is called the front end but in the deepest and darkest depths of the application in a place where no user has gone before there exists the core functionality of the application which is not visible to the user this is called the backend and all of the code that comprises this back end generally exists on a server so that means that the front end needs to be able to communicate or interface with the backend server right so our backend needs to provide an interface for the frontend application to use so that these two entities can communicate with one another now so far we've learned how the two entities human and computer can interact and that's via a graphical user interface right because a human can easily navigate a GUI using buttons and text inputs Etc and those interactions are relate to the computer so we understand how a human interfaces with a computer but how does a computer interface with another computer well a computer interacts with a computer by making use of an interface as well this interface is called an application programming interface and is more commonly referred to as an API now an API is a type of software interface and it just so happens to be what we're going to be writing the code for or building in this course so we'll be creating the interface that the front end will use to interact with our backend and through that interface the front end will be able to trigger certain functionality related to a customer purchasing a product from an online store okay so after everything we've learned up until this point you should have a firm understanding of what part of the application were built building here so let's go ahead and open goand and you'll recall that we made this main.go file in our go tutorial directory when we were going over how this IDE works and if you haven't created that file you can just rightclick on the go tutorial folder and then go to new and then hit go file and here you're just going to name the file Main and I'm pretty sure it should automatically add the file extension .go and remember you want to select simple application when you create the file so it'll automatically populate the file with this initial code so yeah with everything that we've learned up until this point you should understand that the part of the application that we're building is the code the backend code that's going to run on the backend server and that code is going to be the application programming interface or API that the frontend is going to use to communicate with the backend or interface with the backend and that project or that server code or that API code is all going to be contained within this project go tutorial so all of the code that we're writing for this backend is going to be in this go tutorial folder which is the project folder at go Source go tutorial so now we can start getting into how a go program actually works like what is a go program what is a go application essentially the application is this file this main.go file and the code contained within this file is the code for the application so essentially what we're going to be able to do is we're going to be able to write some code here and we're going to be able to run this file and when we run the file the code that we have written inside of the file is going to be executed so let me just show you what I mean by that and you don't need to understand what this package main Funk main means yet so for now let me just show you something so if we write in these brackets this fmt print line and we put inside of it hello world we've now written some code inside of this main.go file so if we run this file and don't worry about this this was automatically added by goand I'll explain to you what this import format does as well but first I just want to show you something so this main.go file if we run this file it should print hello world like print means it's just going to print something to the terminal so that's the function of this print line it's just going to print something to the terminal and what we want to print we can put it inside of these parentheses so if we wanted to print hello world we just type hello world inside of these parentheses and when we run this file it's going to print hello world so if we open our terminal and we can make this a little bit larger if we LS here you see our main.go file is here because we're in the go tutorial folder so we're in this folder right so we can see our main.go file and if you recall we installed the go command the go command is what we installed and if you recall further the go command has its own sub commands so if we go ahead and enlarge this for a second and we just type go and hit enter and we scroll up here you'll see that go has these commands so there's this list of commands here right and one of these commands is called run and it says here that it will compile and run a go program now right now you don't need to know what compile means but run a go program is pretty selfexplanatory it's going to run the program and if we scroll up a little bit here we can see how to to use these sub commands so the usage is here so first we'll type go which is the go command that we installed and then whatever sub command that we want to use and then arguments now in this case we're going to type go and then the command the sub command that we want to use from this list is going to be run and the argument is going to be the go file that we want to run so if we go back to the bottom here and let's just clear so we have some space and we can LS here so you can see we have our main.go file here with the code here that's going to print hello world right so if we type go run and then the file name main.go and then we hit enter you see that hello world gets printed to the terminal screen because that's what function we wrote here that's that's what we're doing in the code within this file so this G run main.go is equivalent to like when you run an application on your operating system like if you click one of the applications icons it'll start up the application right that's the same thing G run is doing like you can just imagine this main.go file is one of these applications but there's just no icon for it and when we type go run in the name of the file we're essentially clicking the application and starting the application so that's like a really simple explanation for what's happening here so our main.go file is the application right and we could actually name this this whatever we want we can go in here and we can hit refactor rename and we can name this hello. go and refactor it and now here we would type G run hello. go because that's the name of the file now right if we LS here we renamed the file to hello. go so we can go run hello. go and it will still be the same code because we didn't change the code here but if we change the code here to hello my friend and then we go run hello. go you see that what prints to the screen changes to hello my friend so that's the basics of how an application in go actually works we essentially write the code inside of a file with the extension. go and we can run that file to actually run the application now there are some other things in here that you might be a bit confused about so let me explain so first of all we have this function here this main this funk main this is called a function so if you look at this line here that says Funk main this is the name of the function and everything in between these brackets are the instructions for that function so we can even do this multiple times so we can even print four times within this one function so it means that whenever we run this function that's called main it's going to print this to the screen four times so if we hit the terminal again and we do go run hello. go you see that it prints four times right so this is a function so we could actually go ahead and create another function if we wanted to we can do Funk and then we can name the function whatever we want so I'll just name it my function and any instructions inside of this function would be executed if I were to run this function so what do I mean by run this function so I can actually take this and cut it from my main function and I can just put it in my function so now these instructions are grouped into my function and actually let's just change this to step one step two step three step four and I just did that because it shows you that when you run a function the instructions are ran in order so this one step one will be printed first step two will be printed second step three and four Etc so this function is just a function is just a a set of instructions it's just grouping together instructions so basically now our Funk main from our Funk main we can actually run another function so from inside of a function we can call or run another function so we can actually do my function and this is how you actually run a function or invoke a function so you put the name of the function and then you put these parentheses here to invoke the function so when we actually run this main function it's going to call this function which is going to run all of the steps in here so if we open up the terminal and we do go run hello. go again you see that it prints out step one step two step three step four and what just happened here is a key thing that you need to understand so whenever you run the hello. go file this is automatically going to call this main function it's not calling my function my function is being called from the main function so if we don't run this main function my function won't even be called so to show that let me remove this invocation or this call to my function from the main function so now when we run the file nothing's going to get printed to the screen because this my function isn't getting called from the main function and when you run the file only the main function is called if we run this file my function won't be called automatically only the main function will be called so if we go ahead and clear and we go run hello. go you see nothing gets printed and that's because we didn't call my function in main now this brings me to the important point this main function we can't change the name of this function like this function isn't our function to change this is the entry point to the application so every go Application needs to have this main function it's essentially you're telling go where the application instructions start so the entry point is the main function so regardless of what you name the file you have to have the main function inside of the file if we were to delete this and try and run the file with just my function in it it wouldn't work so when we try to run it as you can see it says function main is Undeclared in the main package which brings me to the other thing that's important about go main the main package every go Application has to have a main package now I know you don't know what a package means so let me explain so we can go ahead and undo that deletion now at the top of the file you see package main so this is the starting point of any go Application you need the main package on the first line of the file and to explain what a package is I think it's best for us to just create our own package so you can see how it works so let's see if we can do that so so if we go ahead and create another folder inside of our go tutorial folder so we'll do new directory and we'll just name it test and then we hit enter we now have another folder inside of our project directory called test and in here we can create a go file and just call it test now the IDE is trying to create a main package for this folder but that's actually incorrect you can only have one main package in a go program so essentially a package is just like a package of code so like a package of functions that can be used if that package is imported so let me explain what I mean so let's say that we have this package here called test all of the files that we create inside of this test package will contain the code and all of that code comprises the test package so let's go to our hello. go file and let's just take this my function out of it let copy it and then let's go put it into this test file and we also need to delete this main function and we need to change the package name to test and actually let's name this test package and we'll just refactor and rename this one to test package as well so this is a package here right we created a package so this folder is our package right and there's some code in this package so we have a function in this package and the function in this package will just print step one step two step three step four now in hello go we can import that package so we can type in import and quotes and remember the name of our project is go tutorial so that means that go tutorial is part of the path to the pack package so you can see here it'll automatically show up as go tutorial SL test package as the location of this package so if we select that we're now importing test package so if we go here in our main function we can type test package and then we can do my function but there's a problem here as well so if we hover over my function you can see down here on the bottom left of the screen it says unexported function my function usage so basically it's saying we're trying to use this function from test package that we created here we're trying to use this function but we didn't export it and exporting it just means that from within our package we allow other packages to use our function now in go the way that you allow other packages to use a function is very simple you just make sure the name of the function has a capital letter for the first letter so if we change my function to capital M my function the function is now being exported like now other packages can use test packages my function function so if we go back to hello. go and we change this to what it's actually called because right now it's not working because we changed the name of the function right so now we're trying to call a function called my function with a small M from text from test package but there is no function called my function with a small m in the test package because it's Big M so that's something important to note like case sensitivity is very important in programming so if we go here and we change this to capital M my function now we have no more errors so here we're importing this test package that we created and since we imported it we can do test package that we can do the name of the package dot the name of the function in the package and if we go ahead and run this if we go to the terminal and let's clear this and let's LS again so you can see we have our test package here right and we still have our hello. go file if we do go run hello. go you see it prints 1 2 3 4 because we're calling test packages function from our main function now you might be wondering like what what is all what's the point of all this confusion with these packages but it's really important that we organize our code so a very simple explanation this is the only explanation you need right now for the reasoning behind like using packages is we want to segregate specific types of functionality for example maybe we might create a package that's only responsible for like arithmetic and then we create a separate package that's only responsible for something completely unrelated to arithmetic like we just want to keep everything organize so that's a very simple explanation of why we might want to use packages for now that's all you need so back to our hello. go file so I said before hello. go is the entry point to our application and the entry point means that it's the starting point of the application so this is the start of our application so anything that we put in this main function it's going to comprise all of the steps in our application so maybe we want to call my function many times in our main function just think of the main function as the parent function to any other code that gets ran in your application and import is the keyword that we use to import another package now circling all the way back to what package main is package main is the entrypoint package to the application so you can really just think of it like this the same way that we're importing test package and running it here the same way that we're doing that you can imagine that when we run this gun hello. go go go the go programming language under the hood it's importing our main package and it's calling our main function and that's how it's executing our application that's how it's running our application so that's what the main package is and the main function is the entry point the start of our code the start of the application I hope that makes sense cuz that's very important for you to understand so at this point you should have an understanding of what a function is so remember this is a function and the keyword for a function is Funk when we want to create a function we'll type in Funk and then the name of our function and if we want to create a function that's public for other packages to use it has to have a capital letter at the beginning of the function name and if we want the function to be private like we only want it to be accessible from inside of our package we make the first letter lowercase so this is my private function so nobody can use this function outside of our package so if we go to hello. go and let's delete that and we do test package. my private function you see that we get the error unexported function my private function meaning we can't use this function from the main package so yeah that is what a function is and that is what the main package and the main function is those things are very important to understand now there's one more thing I want to explain as well so let me just delete this because we can't do that so if we go back to this test file you see here that we're importing this fmt package now this package we didn't create this package right and you might be wondering where this package came from and we're using this package here see the package name is fmt and we're calling this package's function called print line same way that we were calling this test package is my function we're doing the exact same thing here we're calling format the package format we're calling its function that's called print line and you can see it's a capital P because it's a exported function it's it's usable by other packages but you're probably wondering where format came from and format is actually part of Go's standard Library so go has a standard library of many useful packages that it has functions for common things that you do in the programming world like printing something to the terminal is a very common thing that we do in the programming world so it's a function available in go one of Go's packages and that package is part of Go's standard Library so there's many packages in go standard Library we don't need to memorize any of them or know any of them until we need to use them so right now it's okay to only know about the format package like we used it right so you know about it but you don't need to sit around and try and memorize things that you're not using whenever you're trying to find some functionality you'll end up needing to search for if it's available in GH standard Library anyway so there's no no no use in trying to memorize all of this stuff just know that when we're importing format here we're not importing our own package that we made we're importing one of Go's package that they made now there's another thing that we need to go over as well as part of the basics here so as you can see here we're able to pass in an argument to this print function so basically it prints whatever we ask it to print and that's because we're using and we're passing an argument to the function which brings me to the next thing that we need to learn about and that is function parameters or arguments so it's basically just a way to add more functionality or customization to a function like for example right now when we call my function we have no control over what gets printed here right like we have no control like it's always going to print step one step two step three step four we can't control that but the creator of the function can actually allow the person that calls the function to change what what gets called here and we do that by adding parameters to the function definition now let me take a step back before I explain adding parameters to the function definition so I just mentioned that when we call this function we have no control over what's being printed and since we're actually the creators of this function and the callers of this function so here we're creating this function and in hello. go we're actually calling this function function it's kind of hard to distinguish between the Creator and the caller because we're both in this case so when I say that when we call this function we have no control over what's printed I want you to imagine that as the caller of the function here we're the caller of the function like we're importing this function from this package and then we're calling it I want you to imagine that as the caller of the function we're not the creator of the function and what I mean by that is if we go to this test package we're calling this print line function from this fmt package right but we didn't write this fmt package so if this print line function doesn't give us the option to pass in an argument to print since we're not the ones responsible for creating this function we wouldn't have any control over that so that's what I mean when I say when we call this function we have no control over what's being printed here because this function gives no option to pass in any parameters to impact what's being printed like of course we can go ahead and alter this function to change what's being printed but I'm talking about when we call the function we have no way of impacting what's being printed because when we call this function these instructions are executed so I just want you to differentiate in your mind between the calling of the function and the actual function definition I want you to imagine that a separate person is creating this function definition from the person that's actually calling it so in that case we have no control over what my function does because we're imagining that we're not the ones who created this function we're just imagining that we're importing the package and we're using this function similar to what we're doing here we have no way of altering the way that this print line function works we can import it and make use of it but the the way that it's supposed to be used is defined in the actual function definition which we didn't have any part in making so we just need to conform to the constraints of the function that's provided to us so that's what I mean when I say we have no way to alter what's being printed here when we call my function I hope that makes sense but as the creators of my functions so now I want you to change roles in your mind now we're the creator of my function right and maybe somebody else wants to use my function so maybe somebody wants to import our package and use this my function function so as the people that actually defined this function remember the funk keyword is where we're defining the function if they want to use our function we can give them the power to alter what's being printed here by way of arguments and we Define them as function parameters so if we were to add some parameters into these parentheses for now we'll just add one parameter for example we can add the parameter step and we can put int here now you don't know what this int means yet but don't worry about it yet we'll get to it but we're adding this parameter here step so that means that the caller of the function which in this case is us but let's imagine that somebody else is using our package and calling this function now they're going to be required to provide an argument now you might be confused like argument parameter what's the difference and there really is no difference so the parameter is what we Define when we're defining our function so when we're creating the function we'll call it parameter when we're creating the function when we're defining these parameters that can be passed to the function and when we're calling the function we call it an argument like we're passing the argument to fulfill the parameter from the function definition so sometimes you'll hear the word parameter and argument used interchangeably so it might be confusing sometimes but basically the argument is what's being passed into the function and the parameter is the definition of what can be passed into the function so when we're writing the function we're adding this step parameter but when we're calling the function we're passing in an argument to fulfill the step parameter so if we go back to this my function we see that there's a step parameter and after we have this int word it looks like there's two parameters right but this is only one parameter and this int is just the data type of the parameter for example if we wanted two parameters we'd put a comma and we can just put another parameter and this will be int two so this is how we add multiple parameters to a function that we're defining so each parameter is separated by a comma so before it seemed like this was two parameters because we have step int but int is just the type of Step the step parameter and int is integer so it means that the the type of Step needs to be an integer and it's going to be a bit confusing right now because I haven't taught you about types yet but just bear with me I'm going to get to it so let's just stick with doing one parameter here and it's called step and the type needs to be an in so if we go back to hello. go you see that we're getting an error here because we need to pass an integer an integer a number like a step into the function and at this point we can start getting into the basic data types of go so in go and any other programming language we're able to Define variables and in go we do that using the keyword VAR which stands for variable and we're going to use VAR to Define a variable so we do the VAR key word and we put the name that we want the variable to be like we we put the name of the variable what do we want to call it like how are we going to reference it in our code and after the name of the variable we put the type of the variable so the data type of the variable and following the type we assign a value to the variable by using the equal sign so in this case we'll say that we're creating the variable called step and it's an integer and the value that we want to assign to that variable is one now what does this mean so basically this means that we're storing this value one in memory like we're saving it in memory and in order for us to reference it later on we're giving it a name so for example right now you'll see that we're getting an error here cuz it says unused variable step so like we're storing this value one in memory but we're never referencing it cuz we're never referencing the variable name but if we add step into here now the variable is being used and we're no longer getting that error so what does this mean this means that whenever we reference this variable step it's going to be the value one and it's a type integer so since we're passing step to my function we're actually passing the value one to my function so defining a variable is just saving a value in memory and giving it a name and we have to specify the type of the variable so if we go to my function now since we're passing in the value one as step we can use what's called a conditional statement to decide which one of these steps we want to print so we can do if step equals 1 we can print step one now this is a conditional statement and it's basically saying if step is equal to one then do what's ever inside of these brackets so if step were two in this case if we were passing in two as an argument this code wouldn't execute because this code in these brackets of this conditional statement will only execute if step is equal to one and you might be confused about us using two equal signs here so two equal signs means equals like it means the condition equals and that's because we're use we use one equal sign to assign a value to a variable right and that's like built into the programming language like so if we were to try and use one equal sign here go might think that we're trying to assign the value one to step but like you don't you don't actually need to understand in detail why we use two equal signs as opposed to one just know that two equal signs means equals to and for example less than is less than so if step is less than one then the code in this block executes and the same thing with less than or equal to or greater than or equal to or just greater than but anyways here we want to know if step is equal to one if step is equal to one then execute this code so this is called a conditional statement and so we we have something that we do if step is equal to one but what if step is equal to 2 3 and four well here we would add else if and then another condition so else if step is equal to two and then another set of brackets so else if step is equal to two we do what we put inside of these two brackets so we can take this and do that so if step is equal to two we'll print print step two and we do the same thing for three and four so we'll do else if step equal 3 we'll print step three and then else if step equals 4 we'll print step four so this is one way we control the flow of the application like we can do different things depending on different conditions right so if step is one step one will get printed but Step 2 3 and four will never get printed because we'll never satisfy this condition step equals 2 Step equal 3 step equals 4 because step is equal to one right so it'll print this and then all of this gets skipped and then the function will end now what if step is equal to something other than 1 2 3 4 well we can add at the end here just else and then the brackets here and we can just print step not support Ed so this means that we have a condition for 1 2 3 and four but anything other than that else else if anything else essentially then we're just going to say that step isn't supported so let's actually go ahead and test this out so if we go back to hello. go we're setting step equal to one and then we're passing step into my function and my function takes the argu argument step because it has this step integer parameter and it checks to see if step is equal to one and if step is equal to one it will print this it won't reach these else conditions if step is equal to one so let's go ahead and try that out so we can open our terminal here and remember we already have this code inside of our main function so it's going to run it's going to set the variable step equal to one and then it's going to pass step to my function and call my function so as you can see here we're still invoking the function or calling the function using parentheses but if there are arguments required for the function we just put the arguments inside of the parentheses so it should mirror what we have here so if we go back to hello. go and then let's just do go run hello. go you see that step one gets printed but nothing else gets printed because this condition was met but these other conditions were not met right so let's try changing the step right let's change this to step let's just do step four let's change it to step four so now we're assigning the value four to this variable step and we're passing that variable into my function and if we do go run hello. go you see that step four gets printed because we didn't meet this condition so then it checked for for this condition we didn't meet that condition so then it checked for this condition we didn't meet that condition so then it checked for this condition and we did meet that condition so it printed step four now let's do one more here what if we change this to 10 I'm sure you can guess what's going to happen here so let's just clear this and do go run hello. go and you can see we print step not supported because in our function we don't have support for step 10 it only goes up to four so if anything beyond that is passed then we're just going to say step is not supported so in this function definition we added a parameter called Step so the caller of the function needs to pass an argument of Step which is in this case we're passing in the value 10 as step and it's the same thing that's happening here in this print line function that we imported when we imported the format package print line expects an argument so we're passing an argument to print line and it prints whatever we pass it now let's go back to hello. go and continue with trying to understand what types are so the basic types that you need to understand right now for go are int which you just learned about int is a number essentially so if we were to create another int and we were to call it left and then we create another one and we call it right and we'll change left to five and right is 10 and we'll once again use print line from the format package if we were to print left plus right since these are both numbers left plus right is going to add these two numbers together and print them so for now let's delete this step and let's delete the call to the test package to avoid confusion so if we run this you see that 15 gets printed because we assigned the variable left this value five and we gave the variable right this value 10 so when we do left plus right we get the sum of those two values and we can do the same thing with subtraction or any other arithmetic for example so let's run it with subtraction and you see we get5 because 5 10 is5 so that is the int type the basic type int another type that we're going to be making use of is the string type so we'll say VAR name and we'll call it string and we'll set it equal to James so here if we print name let's delete this left if if we print name it's going to print this value James and as you can see here Prince James now this is a string value and a string value is just a string of characters and you can recognize a string by the use of these quotations here for example if we try to put an integer here we're going to get an error because this isn't a string this is an integer but if we were to add these quotation marks here it becomes a string so if we were to create left right and print left plus right here what's going to happen is probably unexpected to you as a beginner like you would think maybe it's going to add them together and it would be 22 right but it's not because it's not an integer so you can't do arithmetic on it so it's a string of characters so when we add them together we'll do go run hello. go we get one 2 1 0 because what it's doing is it's just concatenating the characters and concatenating just means it's just doing this it's just merging them together to a longer string of characters like you can't see the parentheses here but when it's being printed to the terminal it's actually printing a string and not an integer and let me use a different an example to kind of exemplify what I'm saying here so if we put James here and put Smith here and we select the terminal and go run hello. go you see that it just concatenates James and Smith and makes it into one string James Smith and strings can also include spaces so if we put a space here that's a character as well space is a character as well so it'll be James space Smith when we add them together so if we go go run hello. go you see now it's James Smith with the space now I encourage you to go and mess around with these types to kind of see how they work that's a general explanation of a string and an integer so remember integers we can use arithmetic on them but remember for Strings if we add them together it's just going to concatenate them so what do you think might happen if we try to subtract them well we get an error because we can't do arithmetic on strings cuz they're not integers they're not numbers so it says invalid operation left minus right the operator is not defined on string and this just means of course we can't subtract a string from a string because they're not integers and one more type that we need to take into consideration is we'll do is happy and we'll change this to bull and a bull is just true or false so let's delete these and we can change in here to is happy so when we do go run hello. go you see true is going to get printed to the screen now if we change this to false and we do go run hello. go you see false gets printed to the screen and you might be wondering how are these bull variables useful and to that I say you don't need to know how the bull variable is useful yet because we're not making use of it yet so don't worry about why it's useful yet you just need to know that there is a data type called bull which is true or false and we can assign that to a variable so yeah just keep in mind that we have these three data types and don't worry about these variable names I just wrote anything just to show these three data types so remember we have a bull which is true or false we have a string which is a string of characters and we have an integer which is an integer a number so let's go ahead and delete that so now at this point you should have an understanding of function parameters and their types so let me just explain a a little bit more about this function parameter so like the type has to be an INT it's required to be an INT if you call this function if you try to pass in a string it's not going to work because this function only accepts an INT so if we go and we do test package my function and we pass in this is a string you see that it's red here it's not going to work so it says cannot use this is a string type string as type int of course because it accepts only a type int and if we go to my function and we change this to string it's still going to break because now we're trying to compare a string to an integer and you can't compare the two because they're not the same type so if we changed these numbers here to string then we could compare them like you see the error goes away for this one but these ones are still wrong we're comparing a string to an integer and yeah I hope you understand what I'm saying with that but if you're not fully grasping this if you if you grasp most of it but you're still not fully grasping it it's fine to continue on with the video because things will become more clear as we actually use these things to build what we're building but if you completely don't understand what I'm talking about here I encourage you to rewind the video and go back and go over these fundamentals again because they're necessary you need to be able to understand these things to be able to continue with the rest of the tutorial now as we continue with the tutorial I'll introduce new things as we're building our backend and everything that I introduce I'll explain it so yeah I think it's okay for us to move on at this point so you should understand the following things at this point you should understand what a function is and you should understand how to export a function using the capital letter when you name the function you should understand what a package is and you should understand how to import a package and call a packages function and you should understand function parameters and how we can use them to make our functions more configurable or customizable by the caller you should understand what a private function is and you should understand that private functions can only be used within the package that they're defined so we actually didn't go over that part so a private function since it's not exported since we're not using a capital letter here it means that it can only be used inside of the package where it's defined so this private function is defined in this test package so for example in my function we could call my private function my private function and you can see we don't have to prefix this with the name of the package because we're calling the function from within the package so inside here we can call my private function but in our main package or our entry point we can't call my private function because let's delete that if we do test package my private function you see that we get the error here unexported function my private function and you also see here that we have to prefix the function name with the package when we're calling it from a package that's not the package where the function is actually defined so that's what you need to know about that and you also need to know about the main function like you need to know about how the main function is the entry point to the application and how the main package is the package where the entry point is defined and I already told you how you can imagine that this main package is being imported by go behind the scenes and you should also have an understanding of types more specifically the basic types string Bull and integer and you should have understanding with variables and how we actually Define variables by naming them and putting the type and then putting a value for the variable so yeah that's everything that you you need to understand up until this point if any of these things are confusing to you or you don't grasp them at least like 80% then I suggest that you go back and rewatch the part of the video where I explain these things because these are basically the prerequisites that you need to understand in order to actually build this API that we're going to build and like I said whatever new things that I introduce I'll explain them as I introduce them but those are just the fundamentals that's the Baseline understanding that you need to have in order to move forward so yeah if you've made it up until this point we are going to now start to actually build the API that's going to be called by the front end that we spun up earlier or the prebuilt front end that we downloaded and started up earlier which is the product page so we're now building the application programming interface that's going to run on the backend server that the front end code is going to call and if you don't know what I mean by that you should go back back and rewatch the part where I explained the key terms prior to explaining the fundamental things that you need to be able to code the project so yeah from here we can make our main function vanilla like we can remove everything from it and just have our main package with the main function with no code in it yet so right now this is just an empty application but it contains the minimum requirements for a go application so like explained for the go Application you need to have this package Main and you need to have the entry point so you can actually run this right now G run hello. go nothing happens but it actually called this function but there's nothing in the function so that's why nothing shows up here so we'll have this minimum requirement which is main.go and then this package we actually don't need this package this was just an example I just wanted to show you what a package is so you can close that package folder and just delete the whole folder and it'll ask if you want to delete the directory test package just delete it and we can just change the name of this back to main.go and now you should have a completely empty go Application the file main.go and that's just in the go tutorial folder the project folder so the next thing that we need to do is we need to start building our actual backend API so in order to do that like I explained before we're going to use a payment processing platform called stripe so the code that we're going to be writing here is going to make heavy use of that payment processing platform and you'll understand what I mean by that soon but first we need to make sure we create a stripe account so that we can make use of it it so you can go ahead and open up a browser and you can just type in stripe payment and you can just go ahead and select this first one here and then select start now and here you will create your account now I already have an account so once you've finished creating your account you can go ahead and sign in to your account now once you've created and set up your account and you've logged in you should be taken to this is dashboard. stripe.com and it should be/ test dashboard if you're not on the test dashboard then just put SL test dashboard in the URL and hit enter and you'll be brought to this test dashboard now the first thing that we want to do as soon as we access this dashboard is we need to look down here to the right side and see if you have these publishable key and secret keys and you're going to to copy this publishable key copy the publishable key click it and copy it to your clipboard and then go and open up your terminal and from your terminal you want to change directory to that front end that we downloaded before Go for beginners frontend and then you should change directory to the folder called SRC and then you can LS here and there's a file here called stripe payment. jsx I want you to open this file with a text editor that should be already preinstalled on your system if you're using Mac and it's called Nano so you'll type Nano stripe payment. jsx and then press enter so this should open the file like so and you should be able to use the arrow keys on your keyboard to go down down down all the way until you get get to this string here that has this long key in IT PK test 51 N9 blah blah blah and I want you to go all the way to the end here all the way till you get to the end quote and once you get to the end quote here I just want you to hit backspace and delete everything inside of the quotation marks and then you should be able to paste in that key that you copied from the actual dashboard of your account and when you paste it in it might mess up the spacing so just go all the way back to the beginning of the key to the beginning quote and then hit Tab and then backspace twice and after that you want to type in control X and it's going to say here save modified buffer answering no will destroy changes you want to type the letter Y to save the changes that we just made so just type Y and then it'll say file name to write and we still want to keep the same file name so you can just hit enter and that should save the file and after that you can just go ahead and close your terminal but yeah it's very important that you change that key inside of that file so make sure you do that and confirm that you have the proper key that's from your dashboard stored in that file and I can't stress it enough not having the proper key there will break the application for you like you won't be able to complete the tutorial so make sure you confirm that it's the proper key but anyways now that we have a stripe account we can start writing our backend code and our backend code is going to make use of that stripe account so if you recall our backend code is the server code that provides an interface for our front end to use to communicate so our front end is going to need to be able to send request to our backend server and this is the code that's going to handle those requests so that request is going to be sent over the Internet so the frontend is going to send a request to our backend server over the internet and that request is called an HTTP request so we're actually going to need to import one of Go's packages from its standard library that helps us to handle these types of requests coming from front in clients so let's just start off by writing out some imports now in go before you saw that we were importing single packages like this with quotation marks right but in go you can actually import a list of packages so instead of doing import import name of package we can just import all of them in the same list so let me show you what I mean so we want to import the package called net SL http and remember this is a package provided by the go programming language and we can use this to handle requests sent from the front end to our backend server but we're also going to want to import format again just for our testing purposes now instead of using the import keyword twice we can just use it once we can just do it like this so using these parentheses we're able to import multiple packages at once but don't get these parentheses confused with the parentheses that we use when we create and invoke functions they're not the same thing this is a completely separate thing this is just us importing multiple packages using the same import keyword instead of listing import multiple times so like I said we need to be able to accept the HTTP requests from our front end so we need to provide the interface for the front end to be able to send these requests and the way that we do that in go is we'll use this HTT packages function called handle Funk and this function is going to take two arguments and this leads us to something that we're actually going to need to familiarize oursel with in this goand IDE so as we discussed before these packages provide functions for us to use right so we're using this HTTP packages function called handle funk but there are cases where we're going to want to know more information about the function and how to use it so in that case in goand you can just hover over the function and it'll give you all of this additional information about the function so as you can see up here handle Funk takes the parameter pattern and the parameter Handler and it tells you that this pattern parameter is a string and this Handler parameter is actually a function and this function actually needs to take response writer and request parameter and both of these come from the HTTP package now this part is not necessary to understand fully at the moment so don't worry too much about this part just know that this handle Funk takes a pattern which is a string and a Handler which is a function so we're going to need to write a function to pass to this function and you'll see what I mean by that soon but first I need to explain to you what this pattern is and to do that I need to explain to you what it means to send a request to a server so I want you to imagine that this entire screen is the internet and let's say for example we have our server and our frontend at different locations in the internet so here's our server and here's our front end and maybe this server is hosted in some entirely different country or whatever the point is these two entities they're not hosted in the same location are on the same server so this is the backend server and this is the front end that needs to call the backend so how does the front end access the backend server Maybe This Server is hosted in Brazil or something so how does this frontend make a call to a server among many other servers on the internet because of course it's the internet so maybe there are many other servers so again we want to Target a specific server we don't want to Target any of these other servers like maybe this is Google's server maybe this is like Yahoo's server and this is the server that we want to Target for our frontend right so how does our frontend access This Server well it's similar to the way you know how to send mail to somebody in the real world you know their address and it's the same thing with the internet in the internet servers have addresses and I'm sure you're already familiar with the concept of an IP address so that's what I'm talking about here so the way that our frontend will access this server is by accessing its Associated IP address so maybe our server's IP address looks like this so that would mean that our front end can send requests to this IP address so maybe the front end wants to send a request it knows the IP address of the server that it needs to send the request to so it can send the request to that IP address now just CU our front end has the IP address to the server it doesn't mean that the front end can actually interface with our server because on the server's operating system there are actually these numbers called ports and these ports are basically at the OS level so you don't need to know about that just know that the server's operating system will have ports that are used for network connections like a server may or may not have ports opened for receiving Internet traffic from another location but in our case you don't need to think about any of that stuff we're just going to imagine that we do have a port that our frontend can use and the range available for ports is actually 0 to 65353 now there are some ports that are reserved and some ports that we shouldn't use and stuff like that Etc but again for this tutorial you don't need to know that much detail about this just know that on the operating system level the server is going to have a range of ports available and each Port can be used to connect to the server if the server allows it essentially so when the front end uses the IP address to call our server it also needs to provide a port so what that's going to look like is this so the front end will send the request so this is the request to our server's IP address including the port and in our case we're using Port 4242 so now our front end can send a request to our server using the IP address and a specific Port so that Port is going to allow our front end to essentially connect to our server because the port on the operating system level is used for the connection if there's no port to use then sending a request to just the IP address would be useless so in our backend code we're actually going to listen on this port so any request that comes into this IP address on this Port will get picked up by our server cuz in the code we're actually going to listen on Port 4242 but we have another issue here so like if the frontend sends a request to our server how does our server know what the frontend wants us to do the front end essentially sends us a request to do something right and the backend code needs to have some way of knowing what the frontend wants us to do right and if the frontend is just sending requests to our IP address on our port that we're listening on I mean we get the request but we don't know what the front end wants us to do with that request so that's why we need to provide the interface for the front end to use so the way that we do that is we provide API end points essentially it's like a path to a specific functionality so in our case our server let's just do some bubbles here is going to provide an endpoint called create payment intent and this endpoint is going to map to some functionality on our server so when we receive a request to this inpoint specifically we're going to trigger some code that creates the payment intent does exactly what this says so that means that our front end is only able to ask us to create payment intent if we only have this endpoint if the front end needs additional functionality they need to ask us to build that or ADD additional endpoints to support that additional functionality but in the beginning in this tutorial the endpoint is create payment intent so the front end is going to send us a request to create the payment intent and that's going to trigger a function on our code that will actually create the payment intent on the back end so you're probably wondering when the front end sends this request how do they specify a particular endpoint in this example create payment intent well they just appended this endpoint to the address when they're sending the request so it would look like this so instead of just having the IP address and the port we'd also add this part to the end so then when the front end sends the request to our IP address at our Port that we're listening on specifying that it wants to create a payment intent then in our code we know what functionality we need to trigger and we're going to be building this or writing the code for this and go so exactly what I'm explaining here right now having this end point mapped to some functionality in our code when the front end sends a request to that endpoint that's what we're going to be building here now this is a very simple explanation of how this stuff works you can dive deeper into like networking stuff and how domain names and IP addresses are resolved and stuff like that but for the purposes of this tutorial I don't want to go too deep into networking stuff because it'll just cause confusion when you're trying to focus on learning the programming language you really only need to know these surface level details to understand how a frontend sends a request to an API and how that request is mapped to some specific functionality on the backend server okay so now that you have an understanding of what it means to actually send a request to a server and how the URL is essentially the address for that server the pattern that's expected for this hand handle Funk is actually just the pattern at the end of the URL so for example when the front end sends a request to our server it's going to send the request to the address where our server is hosted right and since we're building the application we're hosting the server on our local machine and we're using Port 4242 but that's the base URL like that's the address for our entire server but the interface that we provide to the front end needs a specific end point like we want to essentially assign different URL paths to different functionality for example the first functionality that we need to provide to the front end is going to be called create payment intent so whenever the front end needs to initialize a payment so that's essentially when the user reaches the checkout page the front end is going to need to create a payment intent for that user or a better way of explaining it is the front end is going to need us to create the payment intent for the user so the way that the frontend asks us to do that is they send a request to a specific endpoint so for example we might have many different types of endpoints so a usual endpoint is like a health endpoint and this just checks to see if the server is up like the front end has no way of knowing if our server is running right because they're calling us from a different location or a remote location so maybe they just want to check and see if the server is up they can send a request to this health endpoint and we'd need to provide that functionality to them so for example here we're going to provide the functionality to create payment intent and there should be a forward slash here and in order to provide this functionality to them we need to give them the actual end point to call so in this case they'll call the create payment intent endpoint so it would look like this so this is the address the front end would send the requ request to to create a payment intent and if we wanted to give them the health functionality as well we'd need to create an endpoint for that as well so now at this point we're providing the front end with the interface to actually trigger our code but you're probably wondering so where do we write our code we're just giving them this address or this endpoint but there's no functionality triggered by any of this well that's where this handle Funk function comes in so if you see here it says handle Funk registers the Handler function for the given pattern so that means that handle Funk is going to register the function that we create and it's going to essentially map it to the given pattern so when the front end calls this end point or pattern we're going to have a function that gets triggered and that function is going to be called handle create payment intent now you can see this is red here right right and it's red here because we haven't created this function so we need to create this function so we can go down under Main and we'll do Funk handle create payment intent and remember this function needs to take in two things so if we go back to our handle Funk documentation here you see that the function they expect the Handler is the function they expect to be passed to this handle Funk as an argument and it's saying the function has to take in a response writer and a pointer to a request this star means pointer but you don't need to know what a pointer is yet just just know that it needs to take in response writer and request now this response writer and request comes from this HTTP package they're types provided by the HTTP package now remember the types that we went over string Bull and int well in go you can actually create your own types as well and this HTTP pack package created the response writer type and request type for us and we can use these types so when we create our function parameters we can say w that's what we're going to name the response writer and we can just from the HTTP package use the response writer type this type here and if we hover over this you can see where they're creating this type using the type keyword response writer and you don't need to know all of this stuff yet just know that this is a type that was created by the HTTP package and we need to accept that into the function that we use here now I know it sounds confusing but just bear with me things will become more clear so remember we need to pass the response writer and a pointer to request so for request we'll just call it R and the type that we need to use is pointer to http do request so now we've met the minimum conditions with this function to pass it to handle Funk right so now we can just finish writing this function and we can comment this out for now and I haven't explained to you what it means to comment out code so let me explain it now so just now I added these two forward slashes to the beginning of this line of code that makes the code commented out like when you run the program this code won't be executed it'll be ignored so for example if I comment this one out it'll be ignored as well so when we run Funk main nothing will happen cuz both of the lines of code have been commented out but if you remove those forward slashes they become active like this this line of code will execute when we run main now I just wanted to comment out this health one right now because I just want to show you how handle Funk actually works and also let me collapse this so you can collapse this side Thing by just selecting project and I'm just collapsing it so you guys can see all of the code here now you understand that in order for the front end to call our back end they need to use this address or if we implement this health one down here this address but right now we haven't implemented this or provided this to them we're just doing this one for now so remember the handle Funk basically registers the function that's going to be called whenever the front end calls this end point so the end point is just the path after the address of the server so the front end calls this endpoint this this function gets triggered so that means that if we do format. print line here and we just type endpoint called whenever a request is sent to this endpoint endpoint called is going to get printed to the screen now we'll get to that in a second so we need to actually remove this here this was just to explain but we can't have that there cuz it the code won't work in that case and you might see these green lines under our Imports here and if you hover over it you see that it says Imports are not sorted and that's just because our Imports aren't in alphabetical order so what we can do is go has its own formatter that like organizes your code for you so if we hit project again and we rightclick our main.go file you can just go ahead and select reformat code and then it'll say optimize Imports make sure that box is checked clean up code make sure that box is checked and then you just hit okay and as you can see it reorganized the import so that they're in alphabetical order so whenever you've wrote some code just go ahead and get in the habit of formatting it using this reformat code tool but let's minimize that again and we're not going to add the health end point yet because I just want to show you guys how this end point is working like how it's going to trigger this function now right now we have the end Point maps to a function right but we don't have any code that's telling this file that it's going to be a running server like if you recall last time we were running our go file this funk main would execute all the code inside of it and then it would just be done after that right but for a server for an API for Server code we need what's called a long living application like the the application needs to run continuously because it needs to always be listening to these requests coming in from the front end right so that means that it always needs to be running so servers need to always be running servers active servers always need to be running so we can't have it finish this Main and then stop running we need it to run continuously and this HTTP package provides that functionality for us as well and it provides that functionality with a function called listen and serve and this function needs to take in some arguments as well first of all it needs to take in the address and in our case the address is just going to be Local Host and then Port 4242 and we can check what else it needs to take if we just hover over this so we see it needs to take an address which is a string and a Handler but we don't need to worry about the Handler part in our case we're just going to put null for this or nil in go so nil just means nothing like we're not going to pass anything there so you can see here is a pred declared identifier representing the zero value for a pointer a channel Funk Etc like whenever you want to know what something is you can just hover over it and the IDE will explain to you what it is so we can hover over this HTTP package and it tells you package HTTP provides HTTP client and server implementations so just get in the habit of trying to read this stuff and understand what's happening here right anyways so we can hover over listen and search and it says listen and serve listens on the TCP Network address addr which is the variable this variable here that is expects this argument here that it expects so it listens on that address and then calls serve with the Handler to handle requests on incoming connections so when the front end connects to our address depending on which path is appended to the address like with which path comes after 4242 it will Tri trigger whatever handle or function is associated with that endp point so running this is actually going to run the server but there's something new here that I need to explain to you so like this function as you can see here it has these two parameters right but it also has another type here right and that's because this function actually returns a value but it only returns a value if an error occurs now that's a bit confusing to understand so I have to go ahead and explain that to you right now so if we create a function here and we'll just call it Returns value in the beginning when we were creating functions we just did it simply like this and maybe we had like a parameter like something which was a string right and when this function gets called it just executes whatever code is inside of it and then that's it right but actually functions are capable of returning things back to the caller and how to do that is after the parentheses where the function parameters are you'll put the type of value that gets returned now this function is required to return something so you get this red line here right it says missing the return statement at the end of the function a return statement you literally just type the return word and you return something but that something has to be the same type that you're saying gets returned here so this is where we're saying what type of something gets returned so if this is int then it's going to say this is an error we're returning a string here but it should be an INT right but here let's say it's string so that means that we can do this so they can pass in something as a parameter right and that parameter is a string right we're expecting a string as the argument so we can just return that back to them and maybe using something for the argument and the return value is a bit confusing but I think you'll understand the point so let me just go ahead and comment out this code here in Main and then we'll just call return Returns value we'll call it and we'll pass in the value that we want to be returned something so what do we want to we'll just put hello I will return this back to you so now since this Returns value actually when we call it it's going to return a value we need to catch that value right so we can catch that value by creating a variable and we could just call it cot value and it's a string and we set it equal to the result of this function so this Returns value is going to return this string that we pass into it right and we want to catch it and store it in this cot value and then after that we can print it so we'll just print cot value and and I spelled format wrong here so I think you can guess what's going to happen here but let's just run it anyway so we can see what happens so we'll do go run run and we Chang the name of the file to main.go so and as you can see what gets printed is hello I will return this back to you now this is very important to understand so it basically combines everything we've learned up until this point and it also includes returning values from a function so we're creating this variable here right remember a variable is a way to assign a name to some value so that we can reference it later so we're assigning this cot value name to the result of this Returns value function and this Returns value function takes in the argument which is a string and it just returns that string back to us and that's represented here this is telling us the return value of this function is a string so since when we call this function it returns this string right back to us this string just gets put in this box this cop value box or variable and then later we can reference that cot value because we named it right and then we can print it and that's how return values work in functions so let's go ahead and delete this and let's delete this cop value as well and this print statement and we'll uncomment this and now back to the reason I had to explain to you what a return value is this listen and serve returns a value as well it returns type error remember the type that comes after the parentheses where the parameter are defined in the function definition that's the type that's being returned from the function so we need to accept a type error so here when we call this function we need to catch its return value in a variable and it's the error so we'll just call it error and it's type error now we've reached another important checkpoint in go go whenever there's an error expected to potentially return from a function so whenever a go function returns an error it doesn't mean that whenever you call the function an error will be returned it means that there's a potential for an error to be returned so it means that it's possible that when this function gets called an error gets returned but it might not return an error so listen and serve basically it's going to start our server our long running or long living application it's going to run our server and listen to requests coming in but if there's an error with listen and serve then it'll return an error and in that case as the people writing the code we need to handle that error so we need to potentially accept the error so we're assigning the error to this variable so if listen and serve returns an error it's going to be put in this box in this variable but we're not doing anything with that variable right now so even now with catching this error if it happens we're not doing anything with it so we still wouldn't know if there's an error so what we need to do is under this VAR error error equals listen and serve we need to check if that error exists so we say if error not equal nil so if error is not nil so remember I told you what nil is nil means it's like an identifier for nothing so if the error is not nothing meaning if there is an error then we need to do whatever is in these brackets here and in our case if there's an error we're going to use Go's log package another package that we'll import and then there's a function in that package called fatal and you can see here that log automatically gets imported by the IDE and there's a function in that package called fatal and this fatal function is just going to basically print out what the error is then it's going to completely exit the application so we need to pass it the error and this is how error handling is done in go so any function that potentially returns an error we're going to need to check and see if that error gets returned from the function and if it is we're going to need to handle that error in some way now you don't need a deep understanding of this point just yet just know that that's a general overview of how error handling is done and go so for this particular listen and serve function what we're doing is we're running the application continuously and we're just listening for request coming in and if there's no error then we'll never get to this point but if there is an error it'll get caught into this variable and then we'll do whatever code is inside of these brackets now I know that was a lot to understand so I think we need to solidify this knowledge by actually testing this code out and I encourage you if you're following along with this tutorial to be writing out and testing out everything that I'm explaining here because it's one thing to just hear me explain something to you but you're not going to fully grasp and retain the information unless you actually take action and do what I'm doing like follow along with what I'm doing and practice and mess around with things and Tinker like that's how you learn how to code like you don't learn how to code by just listening to somebody talk and explain things to you because it doesn't matter how detailed I am in explaining these things if you're not actually following along and getting a feel for how this stuff works so I just want to put that out there because I don't want you guys to be wasting your time like you really need to follow along and really try to get a feel for these things so let's go head and test this and we're going to try to solidify your understanding of how to handle HTTP requests in go like how to create this API like right now what we're creating is the API that I told you about before the application programming interface this API is used by the front end so let's go ahead and get our hands dirty and try and test this out so before we can test this out we have to install a tool and this tool is going to allow us to act as the front end without actually being the front end and you'll see what I mean once we install the tool so what you want to do is you want to just go ahead and open your browser and just go to Google and search for Postman and you can just select this first option here and we're just going to download the desktop app so I'm using Mac so I'll select the Mac one and I have an apple chip so I'll use the Apple chip one once that's finished installing you can just go ahead and unzip it and after you unzip it you can just move this to the applications folder and we can just go ahead and open up this application called Postman and it looks like mine is a bit broken but I'm just going to hit Skip and go to the app and that looks fine anyways what this tool is going to do is it's going to allow us to send HTTP request the request that I explained to you before to a given address or URL so what we're going to do is we're just going to put the URL inside of this bar here and it's hard to see cuz my app is messing up but we're going to put the URL into here and then we're just going to send the request to our server and our server is actually going to be running on our local machine so actually let me just quickly explain to you what I mean by that cuz that might be a bit confusing now you should recall from the explanation about the server and US sending the request to the server from the front end a diagram that looked something like this so in a real world situation or a situation where our application is actually deployed to a production server requ would come in from the front end wherever it is to our backend server remember this is the request but while we're actually developing as you saw before we were running our front end on our server so if we just make this larger and we can move that so while we're developing our front end's actually running on our server and while we're developing another thing that's running on our server is the server code which is that's that's normal for the server code to run on the server right but this is is what it looks like when we're developing the front end's running on the server and our server codes running on the server so when we're testing in development we want to send a request from the front end that's running on our server to our server code or our API that's running on our server the go application so this is the go application which is different from what we wouldd be doing if this were actually deployed to production in production the front end wouldn't be running on our backend server it would just be running somewhere else and it would be sending requests over the Internet to the server but while we're developing it's running on our server so that means that the address that the front end needs to send requests to is the same address that it's running on it's the same server but that's just because we're developing this application on our local machine in this case the server is our local machine but in real life we wouldn't run a backend server from our local machine but while we're developing we use our local machine your laptop or PC or whatever to host both the server code and the front end application just so you can have an easy development flow so if you understand that your local machine is actually the server in this case while we're developing then you also understand that your local machine has an address or if you don't understand that I'm explaining that to you now so your local machine it has an ADD address it has a local IP address which is an internal IP address and this IP address is just called Local Host but that's just a name for an actual IP address like under the hood your local machine has an internal IP address that is 127.0.0.1 but this IP address can be referenced by just using the name Local Host within your system because there's actually a file that Maps this IP address to the name Local Host so they're actually interchangeable you can use this IP address or the name Local Host as the address if you want to access your local systems internal IP address so that means that we have this internal IP address and both our frontend and our server are using the same IP address but they're using different ports that's why we're able to run both of these on the same system or server or computer because they're running on different ports so what's essentially going to happen is we're going to run our server then we're going to run our front end and our server is going to be running on one port which is 4242 and our front end is going to run on some other Port but in order for our front end to send requests to our server code our go program it's just going to need to send a request to Local Host at this port so it'll send the request to Local Host 4242 and sorry if that's too small using the endpoint so that's what this Local Host means and when we run the server I'll show you a little bit more of what I mean about this but this is essentially the setup that you'll usually use like for your development flow when you're developing an application or an API you'll usually have a setup similar to this you'll be running everything from your local machine even the server code but when you actually deploy to a produ uction server the code gets put onto another server like maybe like some AWS server or Google server something like that the actual backend isn't going to run from your local machine your local machine isn't powerful enough to handle the type of traffic that go like that hits a typical like web application that has any level of popularity so this is just how we're developing we're developing on our local machine and this is how it's working so I hope that makes sense okay so I actually ended up needing to install an older version of Postman because the newer version was just wasn't working for me it was just broken so I installed an older one so if you need to do the same thing you can just go to Google and type in download older version of Postman and then I just selected this one and just selected this link provided here and then I just went down to downloading Postman V8 and I just downloaded the V8 one for 64bit Mac OS because it's still possible to run it on this M1 Mac using that Rosetta thing I believe so yeah that's the one that I'm using if the newer version works for you then you don't need to do this part but if the newer version is breaking for you like it was for me then you can go ahead and download an older version and I'm just going to dismiss this update available because the update doesn't work for me and yeah it's pretty much the same thing like we need to put the URL or the address to the backend server in this uh text input here and then we'll just send the request so remember with this we're emulating the front end like we'll be sending the same request that the frontend is going to be sending to our backend server this just gives us an easy way to trigger the requests getting sent to the backend to test our backend so let's go ahead and open goand up again and let let's just continue where we left off so before we go ahead and test this endpoint like the calling of this endpoint using Postman there are a couple of things that I still want to go over or I want to elaborate on some things that we already talked about so first of all I want to elaborate a bit more on error handling and go because I think there's still some things you might be confused about even after the before explanation so the first thing I want to elaborate on is this error type so this error type is a builtin type provided by go so just like string and bull and int go provides this error type as well and functions that return errors they return this error type so I want to explore that a bit more so let's just create a function here really quick so we'll do Funk returns error and remember to return something we have to put the return type here so this function is going to return this error type now this function either has to return an error or it has to return nil so for example if we do return nil you see that we don't get any errors and if we do return some string you see that we do get an error so it has to either return an error or nil and we can actually create our own errors using a package from go standard Library called errors and then we can use a function from that package P called new and we can just say an error occurred we just pass a string into this function and as you can see here we're getting no error because this new function returns an error here so new returns an error that formats as the given text so it's basically changing our string into an error so what we can do is we can go ahead and add a function parameter which we'll just call password and and it'll be a string and what we can do is we can have the caller of the function pass in a password and if the password is correct we can return nil so no error and if the password is incorrect we can return this error so we'll just say VAR secret password string equals super secret password and then we'll say if password equals secret password return nil else return error invalid password so what this is doing is we're going to have the caller pass in some string as a password and in the function we're going to define the actual password right so this we're defining the actual password then here we're checking to see if the password passed in by the caller of the function here is equal to our secret password and if it is if it's equal then we'll return nil there's no error so we'll just return nil else if the password is not equal we're going to return this error here invalid password so if we go back into Main and again we're just going to comment this out and we call returns error and we pass in wrong password now in this case we're passing the wrong password so an error is going to be returned by the function right but right now we're not catching this error so I'm sure you can guess what's going to happen if we run this function then so if we do go run main.go you see nothing happens so an error actually was returned from our function but we have no way of seeing it as the person developing this code or as the person debugging this code we'll have no way of knowing what happened the application is just not working but we don't know what's happening because we're not C catching the error and we're not handling the error so in go it's your responsibility to handle the errors so if you're calling a function that's going to return an error you need to catch the error and you need to catch it in a variable so we'll do VAR and the conventional name variable name for errors in go is er RR for error and then the type is error and we'll set it equal to returns error right and you're going to see the same pattern a lot you're just going to always see this same pattern here if error not equal nil then do something so in this case we're not going to do log fatal we're just going to print the error so here we're catching the error that gets returned from this returns error function into this variable called error err which is the conventional name that we use in go when we catch errors and then we're checking if that error is nil cuz remember if there's no error we'll just return nil right if if the password is correct we just return nil but if the password's incorrect we return the error so that means that we need to check if the error is not nil and if it's not nil it means the password was incorrect which means we received the error and that's when we're going to print it so let's go to the terminal here again and do G run main.go and now you can see invalid password gets printed to the screen because we actually handled the error that time and we're just printing it to the screen but there in in a usual scenario you'll actually do something to handle the error depending on the functionality of your application but you don't need to worry about that part right now just know that we need to catch and handle the errors otherwise they'll just be hidden from us and we might be writing bugs into our code or something and we have no idea what's going on so that's what is meant when we're doing if error not equals nil even up here for our call to this listen and serve function like the function will either actually return nil or return an error but in the case for the listen and serve function it's actually a little bit different so I'll show you what that what what's happening here as well so first let's go ahead and delete this and we can delete this returns error example function and we can remove the comments from here now the way listen and serve works like the way the error handling is happening here is a bit different like of course the same Concepts apply like we're going to catch the eror and if it's not nil this in this case we're going to completely shut down the application but let me explain what I mean by that so listen and serve like I like I told you before is what's allowing us to create a longlived application like the application's going to run continuously so in the case of listen and serve nothing should actually ever be returned it should always just run continuously so if any anything is ever returned from listen and serve it means that there was some issue that's why here we're using log. fatal cuz log. fatal will completely exit the application so in the example before we were just printing out the error right we weren't like completely shutting down the application when we received the error but in this case an error is actually fatal to the application like if if listen and serve isn't working our application isn't working so we need to just completely close the application so the way listen and serve works is it won't return anything it'll just keep running and if something happens then it Returns the error so in our case if something happens we'll catch that error and shut down the application and print the error to the screen basically but in our code we should never actually reach this line we should just the application should just be running here and we should never actually reach this line unless something bad happens and let me show you what I mean so if we do G run main.go you see that the application is just running continuously like you see nothing's being printed but our our terminal prompt is never coming up again cuz the application is just running right now so the program's just running right so in order for us to stop this program right now we'd have to press contrl C and as you can see now we can input commands into our terminal so when we actually run this server code the server is just supposed to run continuously it's not supposed to stop it's supposed to keep running and actually let's change the name actually we can change the name of this file so it makes more sense let's change this from main.go let's hit refactor rename and let's rename it to server. go and then hit refactor so now our file is called server. go because that's actually what it is this is the server code like when this code is deployed to some production server it'll run on the server so we do run G run server. go on the server and then now our server code is running like it's it's going to it's a longlived application it just continues to run and it's just while it's running it can listen to request from the front end it can listen to and receive the request and handle the requests so right now as this servers is running we're the the code is on this line of code here it's just running listen and serve it's just running it continuously now if there's an error then an error will be returned from this and the the server will stop running so let's try and see what that looks like so we'll press contrl C here to stop the server again and let's move this out of the way so let's see what happens if we put some invalid address here so let's just change this to invalid and then let's go back to our terminal and try to run the server now and let's enlarge this here so now as you can see we ran the server and it tried to listen on the address we provided but the address we provided was just a string that says invalid there's no Port so the port is missing in the address so in that case the error got returned and it got put into this variable and then we checked to see if the error is nil the error wasn't nil so we logged the error and this is the error that got logged so we can actually comment this out and we can just do format. print line something bad happened and then let's try and run this again and now you can see it prints something bad happened because when the error wasn't nil we just logged our own message but before we were logging the error that was actually returned but you'll also notice that we didn't use log. fatal we just used print line but the application still ended but that's because if this function returns an error then it's not going to run un continuous anymore like if it's returning an error it means it's stopped so then we arrived at this line and we printed it and then this block of code was finished and then the function is finished but yeah that's how the error handling is working with this listen and serve with this longlived application and that's how air handling in go Works in general so I hope that makes sense to you because we'll be continuing to use this error handling throughout the rest of this tutorial so anyways we can go ahead and start testing out our endpoint now actually wait there's one more thing that I wanted to go over so it's quite simple actually so this handle create payment intent function so if you remember when I first introduced functions to you I just I explained how the definition of the function is this here like this is where we're creating the function right and then I explained that to actually call or invoke the function you have to use the the parentheses right and in this case we need to pass in parameters or arguments here so we're getting an error under the parentheses but the point is invoking or calling the function you need to use the parentheses right but you might notice here we're not using any parenthesis we're just passing the function and this is because we're not calling the function here like we're not invoking the function here we're just passing it to this handle Funk function and this handle Funk function is going to call the function for us and actually to explain what I mean by that I have to actually show you so let's go ahead and create two functions here so we're going to do Funk function one and function one is going to take in function two as an argument so we're we're going to create a parameter called function two which is going to be a function that takes in no arguments so it's just going to be a function that takes in no no parameters and when Function One receives function two it's going to invoke function two so we're going to actually use the parenthesis here because function one is actually going to call this function two and then we'll create function two and just keep in mind that this function two doesn't actually need to be called function two like function two is the name that we're calling it within function one but we can pass any function that fulfills this type a function with no parameters into function one and it'll be called function two within this function so actually to show that let me just name this something other than function 2 so we'll do Funk another function and it takes no parameters and what this function does is it prints another function was is called so now inside of here once again let's comment this out we're going to call function one so we're going to call function one but Function One expects us to pass in another function so we have to pass in the other function that we created which is called another function so we'll pass that in another function but as you can see when we're passing it in we're not invoking it like that's going to cause an error we're not invoking it because we're we're not the ones who who are going to call it it's going to get called inside of function one so we're just going to pass in the function so we're actually we're invoking function one and we need to pass in another function as an argument so we're going to invoke function one and as you can see function one's definition is here and what it's going to do is it's going to actually invoke function two and function two we're passing in another function as function two here so then this is going to get invoked which means this is going to get printed to the screen so if we go to the terminal here and let's clear and do G run server. go and as you can see another Funk was called because in go you're able to pass actual functions as arguments to other functions and in programming this is called a language that supports first class functions so the fact that we're able to pass functions as arguments to other functions means that the go programming language supports first class functions but the reason I explained that is because I want you to understand what's actually happening here we're passing in this function here right but we're not invoking it but this handle Funk function that we're passing this function to it's going to invoke this function for us only if it receives a request to this end point so that's exactly what's happening with this handle Funk function so that should be clear to you at at this point so let's go ahead and delete that and now finally we can get into testing out the actual sending of requests to our server so remember whenever this handle create payment intent is invoked we're just going to print endpoint called and this will only be invoked if our server receives a request to this create payment intent then this gets invoked so handle function is basically mapping this endpoint to the calling of this function and when we do listen and serve the HTTP package internally it knows which endpoints we're listening on because we Define them here so we're defining this this endpoint here with this functionality and internally this HTTP listen and serve it knows about this line of code that we have here where we're assigning this endpoint to this function so when we call our end point from our front end or in our case from Postman cuz we're going to use Postman to emulate the front end we're not going to call it from the actual front end the post Postman is essentially like instead of sending the request from the front end we're just going to send it from Postman and it's easier to test that way but later on we'll also test it with the actual front end so you'll be able to see it done both ways but for now we're going to test it with Postman so we're going to run our server and we're going to send a request from Postman to this endpoint and what's expected to happen is this function should be called which prints out endpoint called and remember the address that's being listened on is our local host which I explained to you and actually you can also use 127 0.0.1 that's also the same as Local Host as I explained to you before so if we did this G run server. go you see we get no error it's running on Local Host which is this IP address which is your internal IP address it's actually called the loop back address but like if you want to dig deeper into that then you can go ahead but for the purposes of this video the explanation I gave you before of what the Local Host IP address is that's good enough so let's stick with calling it Local Host though just because it's easier so this is our address that we're listening on and this is the port that we're listening on so on Postman we should be able to send the request to this address this port this endpoint so let's try that but first we have to run the server so let's clear and do Go Runs server. go and our server's running actually to make it easier to see that our server is running let's contrl C on that and right before we call listen and serve let's just log. print line and we'll just print out listening on Local Host port 4242 so whenever we run the server right before it starts listening it's going to print that it's listening so we can actually see that the server is running so we'll clear this and do G run server. go and now you see it gives the date and the time that's because this log package's print line prints the date and the time and then it says our message listening on Local Host 4242 and actually to make it look more like it's listening we could put dot dot dot here so now we have listening on Local Host 4242 so now we should be able to go to postman and actually send a request to this address at this end point and then in the terminal here it should print endpoint called so let's try that so let's go and open Postman and we'll just do local host 4242 slash create payment intent and let's try and send this now down here you see that it says that the response that we got was 200 okay and 200 just means okay essentially it's the standard response for a successful HTTP request so 200 is the standard response when the request was successful so if we go back into goand we should see that endpoint was called now what do you think is going to happen if we try to call an endpoint that doesn't exist on our server right now we only have create payment intent right so what if we call some other endpoint that we don't have so maybe let's try and call the health endpoint that we never made and then we hit send you can see now the response is 404 not found now 404 the requested resource could not be found that's because we don't have the endpoint or the interface for the health endpoint on our server code so the response is that resource isn't found that endpoint is not found but we can go ahead and add it here so let's go ahead and add another handle Funk and we'll call this one Health and we'll name the function handle health and now we need to create the function handle health so we can just copy this function and we'll change the name to handle health and we'll change this to okay and then we'll need to restart our server so we'll do go run server. go and then let's go ahead and try and send a request to that endpoint again and now you can see we get 200 status okay so if we go back here you can see okay gets printed to the screen but that actually doesn't tell the sender of the request anything because we're printing this to the serers terminal like the the sender the person sending the request to our server doesn't get this message but just like it's possible for the sender to send us a request it's possible for the server to send the sender a response so now that's what we need to go over we need to go over how to send a response back to the person sending the request so let's go ahead and contrl c and stop our server and let's write some code in our health endpoint to send a response to the front end or the person calling our server letting them know that our server is running and up now in order to explain how we can send a response to whoever is sending the request to our server I need to introduce another concept to you so we're going to come back to this health handle health function and for now let's just comment everything out in main so I need to introduce the concept of storing a list of values in memory so so far we've learned about storing single values in memory as variables so for example maybe we have VAR name String equals James so that's how we store a a single string value a single name but what if we want to store multiple names in the same variable so instead of just having name what if we want it to have a variable names plural well in that case we need to use what is called a slice and in go a slice is a list of items essentially and to declare a slice we would use these two brackets here so we'd first put the two brackets and then right after those brackets we'd put the type of item we want to store in the slice so for example if we want to store multiple names string names then we'd put these two brackets slice of string essentially and what that looks like is we'll set it equal to and essentially what we're trying to create is something that looks like this so just a list of names enclosed in these brackets right but you notice we have an error here and that's because the syntax in go for actually creating a structure like this is actually a bit confusing to be honest so let me show you how to actually create a list that looks like this in go so we're trying to create names right and it's a slice or a list of string value use as the names so in go we have to actually put the type like so and then here we have to put these curly brackets and now as you can see we no longer get an eror here so we're essentially creating a list of names and the names that are included in the list are these names so if we were to print names and we can just delete this single name and open our terminal and do go run on server. go you'd see that it prints out this list of names James Bill and Jack and these lists are actually zero indexed so what I mean by that is each one of these names can be accessed using an index and an index is just the count from zero to the last name so this list here or this slice has three names in it right so the length of this slice is three there's three names in the slice but the index starts from zero so actually Jack here isn't the third index it's the second because it would be 0 1 2 so if we want to access Jack we can print names to the index two and then we go to terminal G run server. go and as you can see now it prints the single name Jack so that means that if we want to get just the individual name the first the first name in the list it would have to be zero because they're zero index remember 0 1 2 it's not 1 2 3 it's 0 one 2 and this applies to any programming language the lists are zero indexed so if we want to print the name James we have to print name at index0 and as you can see here we just use these brackets to access a specific index of names so we'll do go run server. go and you can see now it prints James and as you can probably guess Bill the index would be one so if we want to print Bill we will change this index here to one so that is called a slice in go which is just a list of values now this slice in particular contains strings right but what if we wanted to contain something else so we can change the type to for example int and of course we have to change this to int but now you see we're getting is here because these aren't ins we can't store strings inside of a slice of int so we need to change all of these to inss so we can do 1 2 3 and actually to make it less confusing let's just do 50 60 and 70 and if we print names zero it's going to print 50 so as you can see it prints 50 so it's the same it's the same concept it's just we're changing the type so in go you have to be specific like you have to say what type for everything that you declare so that means that go is a type safe language but there are other programming languages out there that are dynamically typed where you don't have to specify the types of variables but in my opinion that's just a recipe for disaster so it's good to have the strictness of the type safety in my opinion so anyways that is is a slice and go and we're going to need to make use of that when we're actually responding to whoever sends the request to our server so let me show you what I mean so let's go ahead and delete this and let's remove the comments from our main code and let's go back down here to our handle health function so here's where we actually realize what this response writer and request is so remember the functions that we passed to handle Funk they need to take in as parameters the response writer and the request types which are provided by the HTTP package and the reason they need to do that is because these types are the types that we need to use to both respond to the requester and read the request from the requester for example when we're responding to whoever sends the request to our server we're going to use this response writer which we have as w here so w just stands for writer it's just a short way to do it like you could if you wanted to just put writer here instead of w and here you could put request and maybe let's just do that to be more verbose so you can kind of understand what we're using these variables for or what we're using these parameters for so we're not going to print okay anymore so when the requestor sends a request to the health inpoint we want want to send them a response that essentially tells them that the server is up and running and the response is going to be a slice of btes now it's going to look super confusing right now when I write this out but don't worry I'm going to explain it so just bear with me so first we're going to create a variable and we're going to call it response and the type of this variable is going to be a slice of bite and we have an error here because I forgot to write VAR so remember you have to have VAR when you're actually assigning values to these variables actually there's another way to do it where you don't need to use VAR which I'll show you in a second but first let me just show you this so we're going to create a slice the same as the one I just showed you but the type of the values inside of the slice are going to be bite now bite I haven't introduced this type to you yet so I'm introducing it now essentially I'm going to tell you what it is now but first let's let's finish writing this out so we're going to create a variable called response and it's going to be a slice of bite and we're going to set it equal to slice byte parentheses server is up and running now let me explain this part so this syntax here where we're using parentheses here after the type this is the Syntax for converting one type into another type now let me show you what I mean by that if we have VAR sum number type int and we set it equal to 22 and then we do string parentheses and then put some number in there and we set this to VAR number as string string equals here we're converting some number which is an integer into a string so if we were to print number as string it would look like this it'd be a string version of this integer because since we're using the type plus the parentheses after and we're putting the number in there we're converting this number which is an integer into a string here and that's the same thing we're doing here we're converting this string that says server is up and running into a slice of bytes now what a bite is I have to explain what a bite is so actually let me cut this from here and let me put this in Main and once again comment out our main code for now because it's important that you understand this and then let's just do let's let's let's assign this string here to a variable to make it clear that it's a string so we'll do VAR response string string equals server is up and running and then we'll change what gets passed into here to response string so now we're creating the response string variable here which is this string and then we're putting it in here which is going to convert it to a slice of bite and then let's format print line response and let's open our terminal and go run server. go now as you see here it's printing out this list of numbers right and this might be quite confusing to you but let me explain to you what this is so each of these numbers is a bite because remember this is a slice of bite and a bite is just a utf8 encoding now that's going to sound confusing right now but I'm just going to show you let me just show you what that is so we can go to Google and we can type in utf8 chart and then we can go here and select this utf8 code page and we can go down here and we'll see this chart here right and we can go back to our editor and we can see this bite here is number 83 right so keep 83 in mind now in this chart we can search for the number 83 so here 83 so the decimal value 83 is equivalent to all of these different values right so in HEX 83 is equivalent to this in utf8 HEX 83 is equival equalent to 53 and the character that it's equivalent to is a capital S so the Latin capital letter s now it's the 83 is equivalent to the Latin capital letter S and if we go here and we see this string here the first letter of the string is the capital letter s so that means that each one of these characters is a bite and that's including the space here so if we do if we count it so 1 2 3 4 5 6 7 so the seventh bite in here 1 2 3 4 5 6 7 32 should map to a space so if we go back to Chrome and we go for 32 so 32 here the decimal value 32 you can see here it's space it's the character space so that's all a bite is a bite is just the what it maps to the decimal value of the character so what we're doing here is we're converting this string into a slice of bittes so it's taking every character in this string and putting it into this list of bytes as its bite value so if you literally went through each one of these letters and the spaces included and even the punctuation included every character in this string if you went through everyone and translated it using that chart this is the list you would get and that's what we're we're doing we're converting the string into a slice of these bytes here and that's because when we send the response over the wire this is how we have to send it and when the requestor receives the response they're going to be able to on their end translate this stuff back to something that's human readable but you don't need to know the details about that you just need to know that when we send the response in go we need to send it as a slice of bites so I hope that makes makes sense so now you should know what we're doing here we're converting the string that we want the receiver to read into a slice of bite and I just explained what bytes are so now we can move this stuff back to where we got it from our handle health function and don't forget to remove the comments from your main code so now we have the response that we want to send to the person sending the request to our server to check the health so we want to send them the server is up and running so now to send the response to them all we have to do is take our writer which is this variable here that that HTTP package provides for us we take the writer and we do the function write and if we hover over this function you see that WR takes a slice of bite and it returns an integer and an error now we don't need to worry about this integer return value Val but we do need to check the error cuz I remember because remember I told you in go we need to we're responsible for handling errors on our own so if an error gets returned we do need to handle it so since this right function takes a slice of bite we can just pass in this response that we just created up here because it's a slice of bite but we need to handle the error and ignore this integer so to ignore the integer so in go okay so here's a New Concept so in go go you can receive multiple different values in a response from a function so like for example if we created a function here called returns multiple here we could return multiple things we could return a string an INT an error so in this case we want this this function can return this function will return three things right three values so return string and int and let's not do error cuz I don't feel like importing the error package let's just do bull and a bull so this function is returning three separate values right so that means that when we store the response from this function in a variable we have to store three different values so if we go here and we try to do it with just one value so let's do VAR something string equals returns multiple now you see if we do this we get an error it says assignment count mismatch one we only have one variable that we're assigning a value to but it expects three cuz you can see here Funk returns multiple returns string int bull but we're only catching a string so here we need to catch three values but to catch these three values in a clean way I need to teach you a new way of actually assigning values to variables so to catch all three of these we can do this now you'll notice some new syntax here so usually we have to use VAR and then the type with the name of the variable right and usually we just use this regular equal sign to assign the value to the variable right but here we're using this weird colon equal sign right well this colon equal sign is like a shortcut like go can actually infer the type based on the function like the function tells go that a string int and bull is returned so go can just infer from that that these three variables should be inch string and bull and the same if we were to create a string we can create this is a string and we can do the colon equals and we could put string here and go knows this is a string so it can infer that this is a string so this is actually okay we can do this way so this is like the shortcut to this long long way that we've been doing it but the reason I've been doing it the long way is because I wanted you to learn about the variable keyword and assigning specific values with specific types but from here on out we're going to start to use this shorter syntax like this this shortcut here with a colon equal signs and have go just infer the type of the variable so these are perfectly valid lines of code the only reason they're red here is because we're not using the variables so go wants you to use a variable if you assign a value to a variable so if we did format. print Line This is a string it's no longer red and the same thing would happen if we printed these but yeah this is the easy way to actually assign a value to a variable without needing to write VAR and then the type and all that so we can remove that and here we can actually just do colon here and you can see there's an error because we need to delete the this and delete this but now you can see go just infers that this is a slice of bite so the colon is very useful you can just use this instead of needing to write out the long stuff that I taught you in the beginning and we're doing the same here so we're take we're we're receiving three values from this function and we're using this colon so go can just infer the types and from from left to right like the same order that the values are returned so the same order here so the string is the leftmost value the int is the middle value and the bull is the rightmost value so when we return it we do the string as the leftmost value the int as the middle one and the bull as the rightmost value so we're returning three values and we could do like format. print line and we can do it for each value and I keep accidentally forgetting the T and in this case some string would get printed first then the int would get printed and then the bull true would get printed now I explained all of that the part about returning multiple values from a function because this writer. write function it returns two values but one of the values we want to ignore so what we can do is to ignore a value we can just put an underscore and then we don't want to ignore the error of course so we can do it like this so this right function returns an integer and an error we want to ignore the integer so for the first variable we just put an underscore we just ignore it and then the second one we use the conventional name ER r r for error and remember we need to check and see if the error is nil that's how we handle errors and go so just get in the habit of doing this so if airor not equals nil then we have to do something and in our case we're just going to print we're just going to print the error we're not going to do anything crazy we'll just print the error but yeah you're going to see this if error not equals nil all over go code and you're going to need to write it all over go code as well so just get used to this pattern here so we we catch the error potentially catch the error so if the error is not equal nil we'll do this code here but if the error is equal nil then we skip this part and we'll go down here right but the function doesn't have anything after this so the function would just end so now when we send a request to this handle health via Postman we're just going to send the response server is up and running and then that's it the function's going to end if there's an error sending the response the error will get printed and then the function's going to end so let's go ahead and run the server and try this out so we'll go to the terminal let's clear G run server. go so now our server is running so now let's go back to postman and it's going to just keep asking me to update anyway so we have our Local Host 4242 health will send the request now as you can see here we get a 200 response which is means it's a successful request and we received the message server is up and running because we returned that in the response we wrote that to the response that's what the response writer is it writes to the response that gets sent back to the caller which is right now it's us sending the request from Postman so if we go back in here and we stop running the server this is this is the point of the the health the health check end point we want to check the health of the server so if we go back to postman so remember we're we're an entity that's not part of the server so like we don't know if the server is running or not so we would want to what if we wanted to check and see if the is running we'd send this request to the health endpoint and you see we get could not send requests because the server is not running so we'd know then like oh the server is not running we can't we can't access the health endpoint like we we check the health server is not running so if we go run server. go send the request again now we know the server is running so that's the response writer that's the writer that's where we're we're we're writing to the response that gets sent back to the caller but the request is the request that we receive from the caller so we're going to leave this health check code here because we want to have the functionality for the caller of our server to be able to check the health but let's also see what this request does and we'll just test that out in our actual handle create payment intent endpoint so we don't need to print that anymore so here let's also change it it to change the variable name of the parameter to request and writer just to be more verbose and I don't know it's a bit long so it's kind of hard to see but yeah the end of this function you basically know what it is it's the request and the writer those are the parameters so if the person sending the request actually sends us some type of message in the request we could actually read it inside of this function and coincidentally in our handle create payment intent code that's actually something that we're going to have to do and we're also going to have to make sure that the person calling this endpoint is using the proper request method so when sending HTTP request there are different request methods that you can use so if we go to postman here this here is the request method so if you hit this drop down you can see all of the methods available to us now in this tutorial we're only going to be working with the post method but if you want to dive deeper into the rest of the methods feel free to do that as well but we're not going to go too deep into all of the methods in this tutorial but the names of the methods kind of give you a general idea of what each one does so maybe there's an endpoint to delete some resource on some server you would use delete or maybe you want to patch some resource or copy some resource but the most common ones you're going to see are get and post so those are the ones that we'll focus on so G is the one that you use to retrieve data from a server and posts were generally going to be trying to provide data to the server so for example our health check inpoint we could just use a git the git method because we just want to get some information so what gets returned from the server the information the server is up and running that's the information that we want to get but in the case of creating customer payment intent we want to post some data which is basically information about what the customer wants to buy from that product store Page we want to post that data to the server we want to send that data to the server and with that information the server is going to be able to do something to to create the actual customer intent which I I haven't explained exactly what that part of the flow is yet but I'll get to it but first I want to go over the fundamentals that you need to know to actually do this so we need to make sure the request method is a post method on our server and that's for when they call the create payment intent create payment intent when they call this endpoint this endpoint we're going to require it to be a post method endpoint and we can see what the request method is by using this request variable or parameter which is the type request from the HTTP package so let's see what I mean by that so we're going to say if request. method so as you can see this request parameter the HTTP package provides the functionality to check the method of the request in its own type that it gives us that HTTP request type which is here so we can check the request method so we say if request method is not equal to post then we can do something now let me take a step back here you probably have never seen this before so this just means not equal remember equal when we check if something is equal to we do two equal signs but to check if something's not equal to we'll do exclamation and then equal not equal so if request method is not equal and I said you never saw that before but actually we've been using that for this if a is not equal null so I should have explained that earlier but I hope you understood when I was saying if error not equal null but yeah this means not equals so if request method is not equal to post we want to return an error and actually the HTTP package provides a function for us to return the error or to return specific types of Errors to the caller without actually needing to write to the response writer manually like we've been doing with the health endpoint so with this endpoint we wrote wrote to the response writer this message we did it manually right we us the writer's write method here but here we're just going to use the HTTP package. error and this function takes in the response writer and the string that we want to return as an error and the error code that we want to send them now the code is the part that I've been showing you so the code is this part here so if we go back to postman this is the code so if the resp response is successful the code is 200 right well there's multiple different codes for different types of response in the networking and programming world so the HTTP package actually provides all of these for us so let me just show you what I mean so we can pass in our writer right which this error we're passing in this response writer and this error function is going to to use this right function for us we're not going to have to do this it's going to do it for us under the hood so we're going to pass in the writer and we also have to pass in the error string and the code right we don't even have to write out the error string ourself we can just use HTTP do status text which is another function from the HTTP package so status text and you can see here status text returns a text for the HTTP status code so so here we just put in the code so HTTP Dot and the code that we want to use is the status method not allowed code now you can see here all of these codes that the HTTP package provides for us so we can just type status method not allowed now this is provided for us by the HTTP package as you can see status method not allowed is going to be translated to the code 405 so this is the code that we send the HTTP Response Code that we send when somebody tries to send a request using a method that we don't support for that particular endpoint so this endpoint we're creating it so that it only supports post so if it's any other method we're going to say that we don't support that method by sending the code 405 and these codes are are convention like these codes are used throughout the networking and progam progamming world like so a 405 is a universal thing so you don't want to just be making up your own status codes or whatever you need to look up the proper status codes for the proper types for the types of response that you want to SP that you want to send and this HTTP package makes it easy for us because it provides basically the code given the name of the error that we want to return so status method not allowed like we don't want to allow anything other than post so this error HTTP error function takes the writer then it takes the status text the status text is created by passing in the code to this status text function then the status text function it knows what text to send back as the error because it knows the code it knows what the code means basically it knows the code 405 means that the method's not allowed so the text that it's going to send back is going to basically say something like the method's not allowed and you'll see what I mean by that soon and then for the code we put the same thing HTTP do status method not allowed and this is just going to be the code not the not the text just the actual number because we're not passing it to the status text function like here and then after that we're just going to return and return in this case just means like return out of the function like the function's finished we want to finish the function here if they send a request that's an invalid method we want to send that response and just finish the function we don't want to continue with the function but if they do send the right uh method then this will get skipped over so we wouldn't return out of the function and we'd continue down here with the rest of the code and you'll see what I mean soon but first let's just test this part here where we're resend where we're sending this HTTP response basically saying that the method's wrong so let's open our terminal and restart our server go run server. go and let's open up Postman and let's do a get request to this endpoint now remember we only accept post requests to this endpoint and let's send it now as you can see here we get 405 method not allowed and you can see the text method not allowed the text that got sent back that got written to the response based on just passing this 405 into that text function so let me show you so remember this is taking the writer and then the error as a string so this method which is just a number 405 is getting mapped to a text to text and maybe I can just show you what I mean by that by printing so if we do format print line HTTP do status method not allowed and let's just take this and put it into our main function and let's comment out our main code and let's just run this and see what gets printed and actually I need to put a t here now let's stop running the server and do go run server. go again and you can see it just prints the number 405 because this is just a variable name for the number 405 that the HTTP package provides now that means that we could even just change this to 405 but that's not a good way to do it because it's possible for us to put the wrong number in here or something or maybe we don't know the exact code that it's supposed to be and it also makes the code harder to read so yeah but when you pass 405 into status text it's going to print out the text version of the code so for example if we just copy this and we paste it and we do format. print line so now we're going to print the result of this function we're going to print what's returned from this function so we could do go run server. go now you can see it gets printed is method not allowed because we're passing in the code to the function and the function Returns the string it Returns the string value of the code I hope that makes sense so we can delete that and let's uncomment our main code again and now let's go here and do print line and we'll do request method was correct so when we run the server now if a request gets sent to this endpoint with a method that's not post it's going to return the error right and actually let's change this back to the actual one that's provided anyways if a request gets sent to this endpoint and it's a method other than post then of course we're going to return this this error the status 405 error right method not allowed but if they do send a post method this gets skipped and then we go down to this line of code and then after this gets printed the function finishes so if the method's post then we should see request method was correct correct so let's run the server open Postman and let's send it again with the wrong method you see 405 method not allowed but now let's send with post so you see 200 which is an okay and then we go back to goand and you see request method was correct so what we're doing here is in this block of code we're validating that they're giving us the right request method if they're not we're going to return an error if they do give us the right request method we'll continue with the function and from there we'll continue with the functionality of handle create payment intent but before we write out the rest of the functionality for this function I need to actually explain to you the flow of what's going to actually happen when a user wants to purchase a product on that frontend web page and the frontend sends the request to create the user's payment intent to our backend server because I haven't explained that yet and you need to understand that to understand what's actually being built here so let's get into that explanation so the stripe payment flow is going to involve three entities and those entities are the frontend the stripe server and our server where we're writing the API in go so stripe has its own servers and its own apis and both our server and the frontend are actually going to be communicating with this strip server so what's going to happen is if the customer wants to buy a product they will select the product they want to buy and go to the checkout page when the customer hits that checkout page on the front end a request is going to get sent to our server and that request is going to be the create payment intent request now when our server receives this request to create payment intent from the customer our server is going to send a request to strike API to create that payment intent so the actual payment intent gets created on the stripe server so let's just say this this purple ball is the payment intent so when we send the request to stripe to create the payment intent it's going to spit out this purple ball and send it back to us and this payment intent actually has like a secret key associated with the customer that the frontend sent the original payment intent for so our ser is going to return that secret key to the front end so we'll say customer key so this customer key essentially Maps this payment intent to this customer now something important to note here is stripe has access to this same payment intent so essentially stripe just sent us a copy of this payment intent so stripe has this same payment intent and ours is essentially just a copy of that one so just to recap step one the front end sends the payment intent to our server step two we send create payment intent to the stripe server step three the stripe server creates this payment intent object and gives us a copy of it and that object has an Associated key with it then step four our server sends that key back to the front end so now the front end has the key for the payment intent that we requested to be created by the stripe server on our server so now when the customer actually confirms their payment the front end has a stripe library or like a stripe backend built into it like so the front end that I prebuilt for you it has the functionality built into it so it can contact the stripe server so when we return this customer key to the front end when the customer confirms their payment on the front end the front will send a request to the stripe server to confirm payment and how does the stripe server know whose payment we trying to confirm well when they send the confirmed payment request to the front end they provide the customer key in the request the stripe server can then associate this customer key with this customer's payment intent because remember the payment intent object is still on the stripe server as well so once the payment is confirmed on the stripe end stripe will send a response back to the front end telling the front end the payment was successful and then from there the front end can redirect the customer to a su payment successful page now there are some Advanced things that would need to be added to our server code and to this overall payment flow if we were to actually deploy this to a production server for example since the front end confirms the payment with stripe directly using the customer key our server doesn't at the moment have any way of knowing if the payment was successful so additional functionality that we might want to add to our server later on down the line is we would want to create what's called a web hook which is basically an API endpoint that we provide to the stripe server so Stripes so the stripe server can send us a request telling us that the customer successfully completed their payment but we're actually not going to do that in this video maybe I'll create a second video down the line where we add that functionality but we're not going to add that to this server for this video so this is the payment flow so remember the front end sends the create payment intent request to our server then we send a request to stripe telling them to create this payment intent object stripe creates the object and gives us a copy of it that object contains the customer key associated with this payment intent we send that customer key back to the front end then whenever the customer confirms their payment on the front end the front end sends a confirmed payment request to the stripe API or stripe server with that customer key stripe then Associates that key with the payment intent object that it has on its server and will confirm the payment and send a response back to the front end saying the payment was successful and we can access the funds for the payments that we receive by logging into our stripe account that we that we logged into earlier the one where we had the stripe dashboard and we had to copy our keys so that's how the payment flow is working with stripe and our backend API so I just realized that I've been showing you guys all of these tools provided by the HTTP package such as this status text function and like these status methods that the HTTP package provides and you're probably wondering like how do I know about all these tools provided by this package for example this this HTTP package is one of Go's packages in its standard library right but like how do I just know that we can whip out these tools like how do I know about these things that we're using and essentially before ever working with this package I didn't know about these tools so how do I know about them now I guess is what I'm saying so this is a very important part of programming so I should have mentioned this sooner but actually this is probably one of the main things you'll do as a programmer and that is reading documentation so basically if we go to the top of the file here the package that we're using all these tools from is this net HTTP package right and this is a package in go standard Library so the reason I know to use all of these different tools provided by this package is because I read through their documentation or rather I started reading through their documentation when I first started making apis in the go programming language so their documentation is quite extensive so of course I didn't read all of the documentation but I've I've read a lot of the documentation for the things that I use the tools that I use provided by this package and I just want you guys to get in the habit of doing that because that's basically how you're going to build things on your own when you're not following tutorials you're going to have to look into different packages provided by the language and there are external packages as well that aren't provided by by go like that aren't part of go standard library but are still very useful packages that the community uses so for example we can just search for this net HTTP goang and it'll take us to the go programming languages like package page and all of the packages in goh standard Library the documentation for all of them can be found on this site here and this site provides information about like getting started with the package the things that the package the type of things you can do with the package additional information there's a whole index here that tells you about every aspect of the package so essentially when I'm building something and go I'll for the packages that I'm using I'll go online and I'll read through their documentation to see what tools are available to me and I'll just make use of those tools as as I see fit like if I see something that's useful to what I'm building I'll just make use of it and then from doing that you start to familiarize yourself with certain tools like this HTTP package is a very common tool in go so like you'll find yourself using it very often as a backhand engineer So eventually you start to become familiar with the different tools that it provides and you start to kind of get like a ro routine going when you build an API maybe you have like a skeleton that you always use to create your apis or something like that and that's basically how I know about all of these tools that I'm that I'm using and showing to you provided by this package in particular and any other package that I use I know about the tools because I've read through the documentation for them online so like you can do the same thing with this goes log package like there's a lot of tools available to us in this log package as as well so we can just go back to go here and then docs and then hit standard library and we can just look through here and look for the log package so you see the log package here and you also see the format package which we've been using a lot as well but yeah you can see the log package here and you can click the log package and get more information about that one and this is how I'm getting information about all these packages as I'm building things so you're going to need to get in the habit of doing this as well as a programmer you're going to have to get in the habit of reading documentation and understanding how certain tools can help you to build things and when you become more advanced you're going to need to start learning how to reverse engineer code and understand how code is working cuz sometimes people write code and there's no real documentation to tell you how the code works or how you can use certain tools provided by the code so you have to learn how to reverse engineer code as well but that's a more advanced technique for now I just want you to know how I'm actually coming up with these things like this status method not allowed here like how did I know that this even existed it's because of the documentation and also you can actually go to where this exists in the HTTP packages code by pressing control or command and then click and if you hit command click it'll take you to the actual code where this is written like this is the code where it's saying that this value is equal to 405 and these are all constants like they're variables but they're variables that don't change like we it would always this variable would always be uh 300 the value would always be 300 for this variable because it's a constant and you can see here we use the keyword const to make these constant variables so if we go back to our our code here here if we type in const does does not change and we set it equal to does not change if we go into Main and we try to assign does not change a different value so does not change equals another value if you hover over this you see that we cannot assign to does not change because once we set a value for a constant it can't be changed can't we can't assign a different value to it but if we create a a regular variable so does change and we'll use that new syntax I taught you can be changed and then we change does change to it was changed you can see if we do print line does change the first time and then the second time it's going to print a different value the first and the second time we print it oh and that's another thing I forgot so this colon here it can only be used the first time you assign a value to a variable the second time you don't need to use it so if we hover over this here it says no new variables on the left side of the colon equals because this variable already exists here we already declared the variable here so if we're using this it's declaring and assigning the variable but we only need to assign a value to it not declare it because we already declared it here so we can go ahead and remove that so that's the difference between declaring and assigning a variable so since we're while we're at it let me just explain that as well so we can declare a variable without actually giving it a value so we can do VAR variable name and we can just say it's a string and then later on we can do variable name equals some string and then we can print it now this here is declaring the variable like we're setting this variable up and we can assign values to this variable but we didn't assign a value here as you can see we're just declaring that there's a variable named variable name that's going to be a string and here is where we're assigning a value to the variable now this syntax the semicolon and the equals it declares and assigns the value to the variable the same way we were doing it before when we were doing VAR variable name String equals something when we were doing this before we're both declaring and assigning a value to the variable and that's what this does this is a shorthand syntax to do this long thing declare and assign the value but you can also declare a variable without assigning a value to it and then you can assign a value to it separately so that's the difference between declaring and assigning a value to a variable so this does both right so since this does both if we try to do it again it's an error because it's trying to declare the variable again because this shorthand syntax also declares the variable for example if we tried to do this again it would be an error you can see variable name redeclared in this block and let me change the name of this so it's not so confusing so let's just call it something and now here you see something the variable named something redeclared in this block you can't declare a variable twice you only can do it once now that went a little bit off topic but yeah that's declaring and assigning values to variables and that's constants as well and going back to what I was explaining before get get comfortable with using the documentation or reading through documentation for tools that you think might be interesting to use like as you become more familiar with programming and you start to like it more you're going to actually start to get excited if you if you read the if you get a chance to read some document mentation about a tool that's interesting to you like maybe some new tech will come out and then the documentation page might seem exciting for you to read cuz you know that you can like read through the tools available to you and and think of things that you can build with it so just get comfortable with reading the docs that's how I'm coming up with this stuff like this constant using this constant here using this function and also another cool thing you can actually read the code for the functions that you use from these standard Library packages as well so like again you can press command and click and it'll actually take you to where the function is defined like this is the function definition and the people that wrote this library for go like wrote this code just like you're writing code for whatever it is that you're building so this is the function status text and it takes in an integer and it returns a string as we already know and then this is the code for it it's really just a long switch statement so if the code is some code it'll return some text and it's just a super long switch statement and a switch statement is essentially like if else statement that we went over before so like if code is status unauthorized return unauthorized Etc but you don't really need to know what a switch statement is right now because right now we're just making use of the if else conditional statements and they serve the same purpose there's some situations when you might want to use a switch instead but we don't need to worry about about that right now so anyways we can leave that but yeah that's how you like dive deeper into the code that you're using like the libraries that you're using like you can check the code you can read the documentation try to understand things that you're using try to dig deeper and see what's happening under the hood like that's how you become a better programmer like reading other people's code reading documentation learning how things work and you eventually become a better programmer when you do stuff like that but anyways sorry for the long rant but yeah so let's move on with the rest of this tutorial so it's time for us to actually finish writing the code for this handle create payment intent function and essentially where we left off was receiving the request from whoever is sending us the request receiving that request and checking the method right we checked the method and made sure it's post for this endpoint but remember I told you that post a post method is sending some type of like payload to our end point to actually trigger some sort of action and the action needs to use the payload that's provided in the request so what I mean by that is we're going to receive from the front end a structure of data that contains the information that we need to actually create the payment intent object that I told you about so we're going to create that object in code and we're going to use the information provid it to to us in this request to create that object so let me show you what I mean by that and to show you what I mean by that I need to introduce to you another type in go which is called a struct so we're going to say VAR req for request since we're already using request here we won't use that req struct and then brackets now if we hover over this you can see that a struct is a sequence of named elements called Fields Each of which has a name and a type so this is essentially going to be the Paradigm for the data that we're receiving from the person sending the request to this endpoint and what I mean by that is we're going to define the structure of the data that gets sent to this endpoint and whoever sends requests to this endpoint is going to be required to conform to that structure we're creating the structure so let me show you what I mean by that so we're going to list the fields that we need in the data that gets sent in this request so the first field is going to be product ID and it's going to be a string and when they send it to us we're going to define the format of what this field is supposed to look like and you'll see what I mean it's going to look confusing right now but I'll show you what this means soon so we're going to put product ID here and then the next field is going to be first name and all of these fields are going to be strings and and we're going to do last name address city state ZIP code and Country and as you can see here it's getting a little bit messy like the type names aren't lined up so we can go here and rightclick our file and do reformat code and as you can see it lines things up all nice and pretty so we can close that so when a request is sent to this endpoint we we're going to expect the request to be this structure so we're defining the structure here and what we're going to do is we're going to take the request body from here and we're just going to put it into our own request structure and by the way all of these have to be capitalized so just keep that in mind and they need to be capitalized because we need to export these values and we need to export these values because we're we're going to need to pass this into another packages function so they're going to need to be able to use or access these values and if we do them in lowercase they won't be exported the same way to export a function from a package it has to be capitalized it's the same with this so let's go down here and now that we have the structure that we want the request to be in we're going to use another package provided by go called Json and then we're going to do new decoder and we're going to decode the request and see this Jason here if we go up to the top you can see it automatically got imported this encoding Jason but anyways we're going to decode this request so here we're going to do request Dot and what we're decoding is the body of the request so we'll do body now if we hover over body here you see body is the request body so remember this request is from up here this is the request coming from the front end or in the case when we test this it's going to be coming from Postman cuz we're going to be sending the request but this is that request and the request is going to have this body attribute like it's going to be the body of the request so let me show you so if we go to postman here when we're make when we're sending this post request down here there's a tab called body and in here we can select Raw and we're going to provide the body and it's going to be in the same format as that structure that we built in our code because if we send it in a different format we're not going to accept it so I'll show you what I mean by that in a second but the request body is going to essentially look like this it's going to have these brackets and remember I told you that the way that we're asking for it to be formatted in the request is like this so in our code we're we're we're calling it product ID with capital P and capital I and they're like together but in the actual request we're going to expect it to be snake case so this is called snake case so we're going to expect it to be all lowercase and each word is going to be separated by an underscore so it's going to be product ID first name last name address one address 2 city state ZIP country so here we'll do product ID and we'll call it test product ID so these are all going to be key value pairs so this is the key and then this is the value so product ID the product ID's value is going to be test product ID so here we have our request body and the way that we're writing this is actually called Jason so instead of having it as text we're going to change this to Jason and when we do it that way it'll actually give us some like syntax highlighting and it'll tell us if we're doing something wrong in the Json format so Json is just a a way to format the string data so this is what Json looks like essentially like key value Pairs and we're missing a comma here so after every key value there should be a comma and all these keys and values should be enclosed in these brackets so this is our request body and in Postman so you don't have to keep writing this stuff out you can actually just save this so now it's saved here but this is the request body so let's go back to the code now you see here we have our structure we're going to receive a request body that's in Json so that's why we're using this Json decoder like we want to decode the Json and then we want to put it into this go code structure so we're going to take the request body that's in Json format and we're simply going to decode it and when we decode it we have to decode it into a pointer to the object that we want to put it into so this is the object that we want to put it into this and symbol is just a pointer but again you don't need to understand pointers for this so just know that we're decoding this Json request body and we're putting it inside of this object here this structure here so we're storing it in memory in this structure so we can actually reference this structure and reference the individual Fields passed in so for example after this line of code we're actually going to be able to do like request. City and that's going to give us like the value for city that was passed in from the request body but first we need to actually check this for errors because this returns an error so we're going to have to do error equals and you guessed it if if error not equal nil will log. print error now actually if we get an error from this it potentially means that the person sending the request here sent the request in the wrong structure so actually what we're going to need to do is we're going to need to send an error response if this gives us an error but first I just want to show you how this code is working so we're going to return after this so it's going to return out of the function we're not going to keep doing the function after that we're going to finish the function if an error gets returned there and let's test out what we have so far so let's run our server G run server. go and let's go back to postman so let's go here and let's send some invalid structure so let's just copy take this out for now and we'll just send like text this is invalid and let's go ahead and send that and you see that we get a 200 okay response here but that's just the default that gets returned when we don't return a response from the function so let me show you if you go here you can see that we got an error that says invalid character T looking for beginning of value but the reason we got a successful response is because if we don't use this writer like if we never use this writer we get to the end of this function and we've never written any response to the writer the the default response that gets written to the writer is a success so what we actually want to do is if there's an error here instead of printing the error we want to do the same thing HTTP error again like we did last time and in this case the error can either be something internal like some issue with the Json decoding or it can be an issue with the way that the request was sent to the server and usually we'd want to actually validate each parameter sent to the reserver in the request but we're not going to do all of that in this tutorial so we're just going to return an internal server error if we get an error from this decoder so we need to pass in the writer and for the string we'll just pass in the error but since the error is type error we have to convert it to a string by doing this so as you can see this error function on this error it returns a string so this is how you return an error as a string and then the code will be HTTP do status internal server error and then what we can do is we can print out all of these values so you can see them coming from the actual front end so we can do format. print line and then remember it's in this request object here so we'll do request DOT first name last name address one address to city state ZIP country and we can go into our terminal and let's restart the server and now when we go back into Postman we can actually we can change this back to Jason and then put in our actual Jason object and we can send it and as you can see we didn't get the error returned to us so that's good news and as you can see here everything got printed to the screen first name last name address one address two city state ZIP code so that's how we're receiving the request body using this request up here from the person sending the request to the server and this is where we're defining the structure so we're decoding that Json object into a go structure and then now we have access to these values and we can now use these values to actually finish writing the code for this endpoint now this endpoint actually the the most important value that we need from the request is the one product ID this is the one that we're going to use to create the payment intent because with the product ID we're going to know the price of the product so we know how much we're going to charge the user now this data here is to send the product to the user but this data isn't going to be used on the stripe end like we're not sending this data to the stripe server this we're going to well we're not going to in this tutori tutorial but this what we would do with it is we might say for example store this data in a database with like an order number and then associate the order number with that customer's uh payment intent somehow and then later on when we received confirmation that the customer confirmed the payment from stripe then we could access that customer's like shipping information in a database or something and send the product but in this tutorial we're not doing the database for this at all we're only going to focus on the payment so what we're going to need for the code that we're actually going to write is this request product ID which is the first field in this Json object and it's also the first field in our G struct so now we can start writing the code to create the payment intent and to create the payment intent we actually need to import some packages from stripe so stripe actually has tools written in go that integrate with go code so if you go to your your web browser and you type in go stripe you see this go library for stripe API so you go to this GitHub page and you scroll all the way down to the documentation and it tells you how to install it here installation so essentially what we're going to need to do we don't need to do this part because goand already did this part for Force so let's just try to First write the code for creating a payment intent and then doing the Imports after that so let's see if we can do that so to write the code to create a payment intent we first need to create the parameters that we need to pass to the stripe API to create the intent so we're going to say pams equals and then the and symbol stripe do payment intent prams and we're going to do it like that so we're going to go back to Chrome and here we're going to use this command here to install the packages and let's go back and inside of our directory our project directory we can paste this command and paste it in and then press enter so then it added those so now we should be a to go here and import them actually it's saying it's indexing the dependencies okay so it added that for us then so now if we go back down here this is working fine now okay so this here comes from the stripe library and so does this payment intent perams so this is basically a struct as well so we just created a struct right so to request for a stripe to create the payment in intent object for us we need to give them these parameters here and they're not all required only some of them are required so let's fill those in to create the pams so these are the pams we're going to send to the stripe API and then based on these pams the stripe API is going to send us the payment intent object so the first Pam is going to be the amount and the amount is going to need to use Stripes type called int 64 and an amount and the way that we're going to do this amount is we're going to create our own function called calculate order amount and it's going to take in the request. product ID now let me explain what we're doing here so we need to give a value to amount to give to the stripe server and I explained to you we have to send this information to the stripe server so they can send us the payment and sent object back the same one that I explained when I went over it with the Blackboard now stripe has its own N64 type and whatever we return from our function we need to convert it to Stripes int64 type and remember earlier I explained to you how to convert one type into another type remember I told you for example we can do string and then put an INT in there and it would convert this in into a string which would end up being looking like this so we're doing the same thing here with stripes own int64 type we're converting the return value of this function we're going to create into Stripes own int64 type so we need to create this calculate order amount function so we can go down here under our health function and we'll create another Funk called calculate order amount and it's going to take in a string which is the product ID and remember this product ID is coming from the request remember we're asking for product ID in the request and this is how we're going to know how much to charge the person CU we only have a select number of products and based on the product ID we know the price of the product and I'll show you what I mean by that soon so we're going to need to take the product ID into this function that we create and our function is going to need to return a normal int64 so go has go has a type called int64 as well and you don't have to know what 64 means just think of it as an integer it's just a differ size integer just think of it as an integer and we're going to return int 64 from our calculate order amount function and our calculate order amount functions going to be simple it's just going to return a price depending on what the product is and we'll just go ahead and use a switch St statement here so switch statement is basically just a conditional statement so we'll do switch product ID and then we'll do brackets and we'll say case and if the product ID is forever pants will return the price for forever pants and we'll say they're 26,000 but this is because we're doing the money in cents so this is actually just $260 and then we'll do case forever shirt and the forever shirt's going to cost $155 and we'll do case forever shorts and the shorts will be $300 and if it's none of those we'll just return zero and it actually should never be none of them but we're not doing any validation on the input from the person sending the requests so it's possible so we'll just return zero so this is our calculate order amount function and here to get the amount for this struct that we're going to use to send the request to the stripe API we're going to call the calculate order amount function with the product ID which is going to be the name of the product so it's the product ID is either going to be forever pants forever shirt or forever shorts and it's going to return the corresponding price and that price is going to get converted to stripes in 64 instead of goes in in 64 so that's going to be the amount and the next field that we need to fill in and let me just clarify here this is the same thing as if we were to do if product ID equals forever pants return this if product ID equals forever shirt return this but switch is just like a cleaner way to do it like we can just do switch and product ID if product ID is this one then return this if product ID is this one then return this if product ID is this one then return this so it's the same thing it's like a conditional thing anyways so after we add the amount to that struct we need to add another field and that field is going to be currency and we're just going to default this one so it's going to be a stripe string and then we're going to just convert into a string stripe. currencyusd now this currency USD is provided by stripe and the type is currency strip's currency type stripe has its own currency type so that's why we need to convert it into a regular string here and then we're converting the regular string into Stripes string now I know that's kind of confusing but you don't really need to know the details about that actually I think they stripe should make it so that you can convert their currency type into their string type but apparently you can't so I tried it this way and I'm actually not able to convert their currency type into their own string type so it says cannot use stripe currency type currency as type string so yeah we need to convert it to a string first and then convert it into their string but anyways that's currency so after we fill in currency we need to fill in this automatic payment methods and this one's going to be stripe do payment intent automatic payment method pams now I know this is starting to look really confusing but again this is only a struct so this is just another struct provided by stripe it just has a really long name so stripe wants us to provide an automatic payment methods field for this payment intent param struct so like each of these are parameters that we're going to need to give the stripe API to create a payment intent right so that's why this struct is called payment intent params this one here it's called payment intent params because it's the parameters that we need to ask stripe to create a payment intent so the parameter one is amount parameter two is currency and the other parameter we need is this automatic payment methods but this automatic payment methods the value for this parameter is another struct and this struct is called payment intent automatic payment methods perams which is a long name but all they want is a bull here and it says when enabled this payment intent will accept payment methods that you have enabled in the dashboard and are compatible with this payments other parameters so basically in the dashboard that I showed you earlier where we got those keys from if we enable this we can use the payment methods that we have enabled on the dashboard so we're just going to go ahead and pass a bull of True to this long name here so we'll set enabled the field enabled equal to stripe bull true and you'll notice if we hover over this struct the field that it expects is enabled and it's a bull so we're filling in the field and we're giving it a value of a bull but it has to be converted to a stripe type but we're giving it the value of true so that's all of the payment intent prams we need to use I know there's a bunch of them here but we only need to use these these three thank God so now we have this payment intent params object that we can send to the stripe server and request that they create the payment intent so this thing that we created just now that we filled in it's going to be assigned to this variable here pams and we're going to pass this pams variable to the stripe server and I know this is getting a bit tedious but just bear with me I hope that I'm able to to help you to understand what we're doing here so once we've created the pams for the payment intent we can actually send a request to stripe to create the payment intent so we'll say payment intent and error cuz it potentially returns an error equals payment intent. new and this payment intent here also comes from stripe it's a it's a package from stripe just it's just that goand auto imported it so we go to the top up here we see that we have this package payment intent from from strip go so we're calling this payment intent function called new so this is how you create a payment intent you call this new functions you see function new and the prams it expects is a stripe. payment intent params and that's what we created here so this can go in here so we'll do params and if you check here you can see that EX it expects a pointer and we're giving it and we're creating a pointer here this is a pointer we're creating but remember you don't need to know about pointers yet that's something that you'll learn later on so yeah we're passing in this object here with these values that we've created here so we're passing that into this new function and since it potentially returns an error we have to handle the error if one exists so if error not equals nil in this case we'll return an internal server error the same as this one from when we decoded the Json we're going to return that if the error is not nil so we're doing the exact same thing here if if creating the payment intent with the stripe server returns an error to us we're going to return an error to the front end with the error as a string and an internal server error status but if we're successful we'll have the payment intent because look we're in we're assigning payment intent to this variable payment intent right so that means that we'll have the payment intent if we don't get an error here so down here we'll have the payment intent and remember when I showed you in the Blackboard the payment intent going to have a customer key like a secret ass assigned to it and it's going to be called client secret this is the customer key that I was explaining to you in the in the Blackboard using the Blackboard so remember this client secret is going to get sent back to the front end and then when the customer confirms the order the front end's going to send this client secret and the order confirmation to the the stripes payment confirm API and that's going to confirm the payment for the customer so we need to send this client secret back to the front end but first let's go ahead and test out what we have so far so we'll just print this for now so print line now remember this new function this new function is actually going to call Stripes API like there it's going to call stripe server so it looks like it's just a function in our code that just handles that just triggers some code in this package right but this code that gets triggered actually sends a request to Stripes API to create this payment intent and Stripes API Returns the payment intent to us here they either return the error or the payment intent and when we get the payment intent it's actually from the stripe server and we're going to print the client secret that we got from the stripe server and this is still all of this code is still inside of our handle create payment intent endpoint so let's test this out let's go ahead and yeah test it out and we have to make sure when we give the product ID we have to use one of these so yeah let's run our server go run server. go and let's go open Postman and let's change our product ID here to one of the ones we actually have a price for and let's send this and actually we got an internal server error and that's because we didn't provide so you can see let me try and make this larger so you can see the response that we got from the API and our API is actually just returning the response that we got from stripe when we try to send the request so strip type tells us you did not provide an API key you need to provide your API key in the authorization header so I forgot to actually show you that we need to do this so when we're calling Stripes API from our server so we're calling when we're calling Stripes server from our server we need to have a key an API key to access their API so that's why we got the error here we didn't provide the key so you need to go to your stripe dashboard so open the brow browser and do stripe stripe dashboard and stripe login and sign into your stripe account and once you're sh signed into your stripe account on your dashboard you're going to see this secret key here now this secret key is the key that you need and it's just a test key so don't worry but yeah this one you want to copy so you're going to copy this secret key and then you're going to go back to your go code and let's minimize that and we're going to go back up to our main function area now in a real world situation you'd never store your key any type of secret key or any type of Secret in your code in your actual code this is like a huge security vulnerability but this is a test key and this is a tutorial so yeah I just need to make that clear so you guys don't think that this is a common practice or something you should do in a real world scenario in a real world scenario this is not how you should hand handle your secrets so I'm just going to do stripe. key so this is a variable from stripe and we can set it equal to the key that we just copied so this stripe key if you hover over it key it says key is a stripe API key used globally in The Binding so if we assign our key to this to this variable that comes from stripe stripe's going to be able to use this key when it makes calls to the API so when it makes a call to the API down here in this new function it's going to make a call to the API and it's going to use the key from that variable that we just gave it but I have to say this again this is not something that you would ever do in a production application you'd never just store the secret in the code like this like right in the open this is just a test key and this is just for purposes of teaching you how to do this and teaching you the go programming language but this isn't a practice that you should get in the habit of doing but of course I don't have time to teach you how to actually handle secrets in an application in this tutorial because it's not the focus of this tutorial but just just please remember that that this is not don't don't get in the habit of doing this but anyway so this is our API key we're assigning it to Stripes key variable and stripe's going to use it when it calls its own API in this new function in this new function here where we're we're asking stripe to create the payment intent and send it back to us so we can go down here contrl C and let's clear that and go run server. go again and now let's go back to postman and let's send it again now this time you see we got a 200 status okay so that means if we go back to our code our server here you see that our our customers secret the client Secret gets printed to the screen and again we're not going to be you're not going to want to print this secret to the screen you never want to print secrets to the terminal but we're doing this for testing purposes and of course this isn't a real client secret this is a test client secret so anyways just keep those things in mind so we've got the application working up until this point so now we just need to send this client secret back to the front end so the front end whenever the custom customer confirms the order can actually use this client secret when sending the confirmation of the payment to the stripe server so to do that we're going to create another struct and we're going to call it response so the same way we created this struct for the request up here we're going to create another one for the response that we're sending back to the front end because we're going to send it back to them in Json basically the same way they sent the request body to us so we'll just call this response and it's going to have client secret and it's going to be a string and it's Jason equivalent is going to be client and we'll do Secret we're not going to do snake case this time because the front end is going to use camel case so let's we're going to send it like this so now we have this structure right that it only has one field which is client secret but it's empty right now so this response is empty so we need to take this response do client secret and we need to assign the client secret a value of this client secret here so from the payment intent that we got here we can get the client secret so we'll do payment intent. client secret so now our response has the client Secret in this field here so now we can send this response back to the caller of our API endpoint so now instead of decoding the Json like we did before so before remember we were decoding the Json because from the request we're sending Jason this is Jason see here Jason so we're sending Jason to the server so we need to decode that into go code right so we needed to decode it into go code but now we're doing the reverse we need to convert go code this struct here is go code right we need to convert this struct into Jason so now we need to encode so we need to use json. new encoder and we need to encode it into what we call a buffer so we'll just say VAR buff is bytes. buffer and you don't need to know details about this bytes. buffer here so just know that we need to send it back in bytes and I explained to you some stuff about bytes when we went over the slice the B slice so into this buffer we want to encode our response so this response here so this response we want to encode it using this encoder into this buffer and remember this returns an error so we want to do error equals and then do if error not equal nil and then we need to handle the error and remember I forgot I told you we can't declare a variable again remember so we have to not use that since we already declared this error up here somewhere here so we already declared the variable so now we can just use error equals here and then if error not equal nil we're going to do the exact same thing that we did with when we were decoding which is the same thing that we did here as well when we sent the request to the stripe API to get the payment intent object we're going to return the same error in this case an internal server error so if we can't encode this response then we're going to return this error to the person sending the request but if we can after it's encoded we're going to send it back to the person that sent the request to this endpoint and we're going to do that using our writer remember the writer that we used before it's at the top of this function the writer here we're going to do writer. header do set and we're just going to do content type application Json now all this is doing is it's adding a header to the response and it's essentially like a tag that we're adding to the response that labels this response with content type Json because we're sending back a Json object to the caller so we're sending adjacent object similar to this one but ours is only going to have one field which is the client secret but we're still sending adjacent object back so here we're just essentially adding like a tag to the response saying that it's adjacent object and then after we do that we need to actually do something that's going to look super complicated but I'm going to explain to you what it's doing so we're going to do io. copy and we're going to pass in our writer and that buff that we created now if I hover over this copy so IO is another package from GH standard Library so if you scroll to the top you see that it automatically got imported now if I hover over this copy you see that copy copies from source to destination until in file eof means in file is reached on Source or an error occurs now into file just means exactly what it says into file so imagine that that Json object is just a stream of data and we're streaming it into the writer that's all this io. copy is doing so it says copy copies from source to destination until end file so once that stream reaches the end there's nothing left to stream into writer right so at that point the entire buffer is has been written to writer and that's essentially what this io. copy is doing in simple terms so we'll go ahead and it's going to return an it it potentially returns an error so we have to do error equals and then if actually it returns something else too but we're just going to ignore it so we'll do if a not equals nil in that case we're not going to be able to return anything because we've already we'd already be done with the writer at that point and the writer is how we return things to the caller the person calling our endpoint so at that point we would just print line if there's an error we'll just print the error and I forgot to add the the package and that is everything for this endpoint that is the code for this create payment intent endpoint so at this point you can go to project and let me close that and format your server. go file and now we can go ahead and test this out so so here we're creating we're sending the request to the stripe server to create the payment intent and it's sending us back the payment intent object in this payment intent variable here and then we're printing it here but we don't need to print it anymore that was just for testing then we're creating a a response struct this is the structure of the data that we're going to return and I'll show you what that is in a second so this is what gets returned to the person calling our endpoint this this is what the structure is it's going to have a field client secret with a value then we're setting this client secret fied in this empty struct to the client secret which is inside of the payment intent object here the one that we got from the stripe API and then we're creating this empty buffer and then we're encoding our response the one that we created up here into adjacent string essentially and then we're adding this header here which is essentially like just a tag saying that this response is going to be of type application Jason which is Jason and then we're copying from that buffer that Jason string into the writer and the writer is the response writer so this is what the caller of the API is going to be able to read from so let's test it out so let's stop running our server and then do go run server. go and let's go to postman and the moment of truth let's send this request and as you can see what we get back is the this Json structure that has a field client secret the same as I showed you in the backend code and it contains the client secret so we've successfully implemented our backend and now all that's left to do is connect it to the front end so yeah this is the response body so this is the body that we send to the front end and the front end is going to take this client secret and when the customer confirms the payment the front end's going to send this client Secret in a call to the stripe API to confirm the payment and from there you should be able to view the payments in your stripe dashboard now let's take a second to actually have a look at this dashboard so we can actually get a feel for the flow that I explained to you in the Blackboard by making use of this dashboard before we connect the front end so we'll get back to connecting the front end soon but let's just go over this dashboard so make sure you're logged into your dashboard and since we've been messing around with um our backend code and attempting to send requests to the stripe API we might have some data on our dashboard already some unexpected data so in order to test this out let's go ahead and click this developers button up here and then at the bottom here you want to select delete all test data this is going to delete everything that may have been created as we were trying to test things out and we'll just do start deletion and you need to confirm your password to delete and then just hit continue and once the data has been deleted we can go ahead and test this out so we're going to start by testing it out just using Postman so we're going to first test out the payment intent like I want to show you guys what it looks like when the customer creates a payment intent but we don't confirm the payment yet so if you select this payments tab up here on your dashboard in all payments you should see nothing right now because we deleted all of the data there should be just this here but if we go ahead and open up goand and we start up our server so we'll do go run server. go and then we open up Postman we're going to send a payment intent for the product ID forever pants so if we go into the code and we go down to where're we're actually defining the prices for the products in that function that we created called calculate order amount we can see forever Pants cost $260 so this is $260 in cense so if we go to postman and we send this request to create a payment intent to our back end we get the client secret back here and we can go ahead and copy this client secret and then we can head back to the dashboard and we can refresh this payments page and now you'll see here that we have a payment it's an incomplete payment because it's only the payment intent the customer hasn't confirmed the payment yet but it's for $260 and if we select it and we scroll down if you press command F to search the page and then paste in that client secret that you got from the response and you have to delete part of it cuz it doesn't show the full thing so you're going to just delete all the way back until you get to where it says secret here and then delete this underscore secret uncore and if you do that and then you press enter you see that this is the payment intent that we received the client secret for here so we've created the payment intent and we can see it on our dashboard and if you scroll up here you can see that there's no customer information or payment method information or anything like that because that's going to be updated on stripe or populated on stripe once the front end sends the confirmation of the payment to the actual stripe server so now we need to connect our frontend to set up the functionality to actually complete the payment so we can go to home and there's one thing that you definitely need to check here to make sure this is working and we went over this before this publishable key this key is needed on the front end the front end needs to provide this key when it calls Stripes apis so that point in the video where I told you to update that file on the front end with this key it's very important like it won't work you won't be able to confirm the payment if you haven't updated this key on your front end code so let's go and open our terminal and let's change directory to that front end code go for beginners front end and let's LS here now remember in this folder there's another folder called source so we change directory to source and then we LS here and in this Source directory there's a file called stripe payment. jsx and actually maybe we can just open this file with goand even though it's not a go file I'm pretty sure we can still just open this file with goand so it's easier to see so let's go to goand and we can stop running our server for now and let's just select project here actually we can just hit file up here and then just select open and then here you should be able to open this go for beginners frontend in the source folder and you should be able to open this stripe payment. jsx file so select that file and then just hit open now let's minimize that so you should be able to see in the code here we have this thing that says const stripe promise and load stripe and in there we have this key you need to make sure that this key is the key from your dashboard so if you go to the dashboard it has to be this publishable key if it's not there your front end is not going to work it's not going to integrate with our backend correctly so just make sure you did that and now all we need to do is go back to our terminal and let's just change directory back One Directory so let's move back one folder so you should be back in the Go for beginners front in folder and let's clear and then open your goand IDE again and you can leave this page once you've changed that to your publishable key and then you can just select terminal and we need to run the server again so we we need to have the server running so our front end can connect to it so we'll do G run server. go and with the server running you can open up your terminal again and in your terminal you should be able to just type in mpm start and this should open up the product page at Local Host 3000 SL product and from here you should be able to select a product so whatever product you select that's going to be the price that shows up for the payment on your stripe dashboard so for example I'll select this shirt I'll just select buy now and from here you should simply be able to input some fake data so I'll just put in like John do but you can actually put in whatever you want here because remember we're not going to add the functionality to actually store the shipping address and stuff like that in the database for this tutorial so although this will be sent in the payload to our backend we're not going to do anything with it at the moment so just go ahead and put in some dummy data here and then you can just hit next and at that point after you hit next after inputting that dummy data and we end up on this enter your credit card information page that means that at that point the payment intent has been created so on our backend or rather when the front end reaches this page it sends a request to our back end immediately to create the payment intent so on our backend we should have already sent the request to the stripe server to create the payment intent so we should be able to see that on our dashboard so if we go to the dashboard and we go to payments again you should see the payment here for whatever product you picked so I picked the one that cost $155 so it created the payment intent for that one and it shows is incomplete right now but once I confirm the payment on the front end this should become complete so if we go to our front end here you notice that we need to input credit card information now stripe has test credit cards that we can use that actually will work for this like we can the the credit cards will get sent to uh Stripes API and those test credit cards will actually work so let's go to Google and type in stripe test credit card numbers and here you see test cards just select that and we can scroll down here and we see this is one of them but there's actually multiple different ones that we can use give me one second so if we scroll down to here here we see that there's different ones depending on whatever brand you want to use so all of these cards simulate a successful payment and the billing country for each test card is set to the United States so let's just do American Express we'll just copy a card you can do whatever one you want just copy one of these card numbers and go back to the page and just paste it in and you can see it shows up as an American Express card and actually for the CVC you can use any three digits and for the date you can use any future date so as long as it's not a date in the past the expiration can be any future date so we can just do 01 2024 and then the CVC we can do any three digits and for the email let's just do a test email so you can just do like email gmail.com and you can select this save your info for secure oneclick checkout with link or whatever but you don't need to do that so you can just hit pay now and when you hit pay now our front end's going to send a request to the stripe server using the customer like the client secret for that payment intent that we originally initiated when we picked the product that we wanted to buy and it's going to confirm the payment and that should show up on our dashboard so let's hit pay now and you see we get directed to this payment successful page or payment has been processed successfully you will see you will you will receive email confirmation of your order shortly and we didn't implement the email confirmation there wasn't enough time so don't worry about that but now if you go back to your dashboard and you refresh this page you should see that this payment is now succeeded and if we select it now there's customer information so we have the customer email here we have the credit card information here and for me it's converting it to JPY because I'm in Japan but you get all this additional information here because when the front end sent that payment confirmation to the stripe server stripe updated all of the information for the original payment intent so now this is no longer a payment intent this is an actual payment successful payment it starts off as a payment intent and then once it's confirmed it becomes a successful payment and that is the front end communicating with our backend and everything is now integrated so we've integrated our front end here with our backend server that we have running on our local machine which is communicating with the stripe servers and we've successfully implemented this product payment application and like I said there are more things that we can do to make this application more realistic like actually storing the customers shipping data and creating a websocket for stripe to send us a request to our server letting us know that the payment confirmation is complete and all of those things but of course we don't have time to get into that in this video this was an introduction to programming in the go programming language so I didn't want to overload you with too much complex information so as it stands right now you can have customers purchase products on a site or whatever and you can just manually go and check which customers actually purchased a particular product and actually I recommend that you try and build this out more to to make it more functional like more functional in a real world situation and I think that would be a good learning opportunity for you but actually there's one more thing I need to mention as well so this front end it runs on Local Host uh 3000 right now right and right now we're just using regular HTTP but actually whenever you're dealing with sensitive data like in general these days you shouldn't be using just HTT P so if we actually hit this thing here it says your connection to this site is not secure you should you should not enter any sensitive information on this site for example passwords or credit cards because it could be stolen by attackers now the reason for that is because we're running this on our local server we didn't Implement TLS and what that would look like is it would be https but if we hit enter here it doesn't exist we're not we don't have we don't have TLS on this site so actually the site is insecure as it stands right now you wouldn't deploy this to production without using TLS so if you go to Google and just type in what is TLS and we can just hit this one from internet Society so it says TLS or transport layer security encrypts data sent over the internet to ensure that ease droppers and hackers are unable to see what you transmit which is particularly useful for private and sensitive information blah blah blah like well not really blah blah blah because this is actually very serious so if you're ever to deploy something like this to a production environment you need to use TLS because if you don't when the customer in inputs their information and their credit card information and it gets sent to the backend server that payload that's getting sent to the backend server can be intercepted by anybody with access to whatever Network you're on so if you're in like a Starbucks or something somebody in that Starbucks on the same network can just intercept that payload and read your credit card information from that payload because when you don't use TLS those payloads aren't encrypted and you know that a site's not using TLS when it's just HTTP and not https so the beginning of a URL has that HTTP part right so if it just says HTTP like this that site's not using TLS don't put any sensitive information don't even use that site because in this day and age all sites should have TLS so I I feel like it's important to stress that like if it's de deployed to a production environment it should say https like you should use TLS you should be encrypting the payloads that you're sending those requests should be encrypted the ones that you're sending to the back end if they're not they can be intercepted by anybody on the network and that information can just be extracted because there's no encryption on that payload it's just visible like easily visible like you can just read it it's human readable you can just use wire shark or something to to intercept the packet and just read all of the customer sensitive data so I I went on this rant because it's something that is important to stress whenever you're talking about building some sort of payment service or some sort of payment application or anything that involves customer data like you need to be very careful about customer data so I had to mention that even though it's sort of a complex topic if we were ever to to deploy this to production or to a production server or something or anywhere other than just our local environment where we're testing it we would need to take the time to actually learn about TLS and understand the implications of not using it so yeah that's just the last thing I wanted to leave you with I hope that you'll take some time to look into this because it's actually a very important part of programming especially if you're making applications that involve any sort of customer data or anything like that so yeah I just wanted to mention that but but other than that we've officially reached the end of this tutorial I sincerely hope that I was able to teach you something and if you have any questions or you get stuck anywhere please leave a comment in the comment section I answer all of my comments so even if it takes me some time to get back to you I'll answer your question and I'll help you out so yeah I also have a Discord that'll be linked in the description and it's linked on the channel description and stuff like that but yeah if you've made it to the end of this and you're able to complete this tutorial you should have enough of a grasp of the go programming language to start attempting to build some things on your own or at least expanding on this application that we built together and I encourage you to do that as a final note if you've enjoyed this content I put a lot of effort into the videos that I make I really try to take the time to help people to understand things like this that are seemingly complex or difficult to understand so yeah if you're interested in those types of videos then go ahead and subscribe to the channel and leave a like of course if you made it all the way to the end of this video you should leave a like because I doubt you finished a 5H hour plus video without actually getting something of value from it so yeah in that case you should leave a like so other people can get exposed to this type of content as well anyways congratulations on completing this tutorial and I'll see you in the next one