let's talk a little bit more about Big O notation and time complexity specifically you're going to see Big O notation with the O which represents the function that you're looking at or the algorithm whatever it is you're evaluating and N which represents the number of elements that are in that function right now you do not have to be able to look at any given algorithm and immediately name its Big O notation or write it's Big O notation but what we are going to do is get a little bit more comfortable with relating a problem that you need to solve with how that could possibly be written in Big O notation let's go over some simple examples now o to the one o with one being n is an example of a static amount of time that an algorithm would take so if it was a simple algorithm it doesn't matter how many entries are in an array the amount of time that it's going to take to execute that function is going to be the same every time that's pretty much ideal it really depends on your problem you're trying to solve where if that's possible or not but that's a great and very efficient way to do things o log n these might be some words you haven't heard since math class I know when I started doing this I hadn't um a divide and conquer type of algorithm or a binary search is where binary specifically you're going to divide up whatever you're searching through into two pieces and only search one of those halves at a time that way you can either determine where it is or you can rule out 50 % of the entries o n is where it directly and linearly connects with the entry n so the amount of time it would take you to read a book directly correlates with how long that book is that's not exponential it's very very straightforward um next o n log n that's a merge search it's a little bit more complex than a binary search so like searching through a deck of cards in a specific way you don't have to understand it completely just know that there are different levels of complexity for Big O notation now I drew a bunch of x's in between here because this is where you start to get into the danger zone this is o n the^ of two exponential um so checking a list crosschecking a list and what you already have in your grocery cart you're doublechecking two different things you're looking all the way through your list and you're looking all the way through your cart if the entries aren't very big that's fine but if you're looking through every cart or the entire store with a list that is you know the size of the dictionary that can get really really long really fast that is exponential anything you're writing that is exponential and in its bigo notation is probably not going to be a great solution long term like we were talking about scaling before think about the future of your site just because it works for you and maybe one other person if you have hundreds of thousands of users that is going to slow everything down to the extent that it's not even usable anymore that's going to be a really big deal now obviously o to Infinity like I'm going to flip a coin until I get ahead that in the worst case scenario another thing we need to remember that could be forever um it probably wouldn't be um depending it could be the first time but we're looking at worst case scenario here what I want you to take away from this is using Big O notation you can look at your code and figure out if it's really going to be a good solution for the future of your site as it grows with more data more users anything that is exponential or below or depending on the algorithm itself it really might not be very practical