so in this series of tutorials we'll see how to build a reddit clone application using spring boot and angular we will be using spring boot spring mvc spring security with jwt authentication spring data jpa with mysql database to build this application so without wasting any time let's have a look at the application we are going to build just a small note you can find the link to the written tutorial of the series by clicking on the link in the description section where you can check out the complete source code of this application and there is also a written companion for each part inside the tutorial so you can go through it at your own pace as i said before we are building a reddit clone so reddit is of course a very popular website that needs no introduction and this is how our homepage looks like i have copied some of the css from reddit to provide a similar look and feel for our application we have our header section with the reddit icon on the left side and the login and sign up buttons on the right side we have our home page where you can see different links which are posted by the users each post has a voting section where you can either upload or download a post you can also see there is a comment section here which shows how many comments are there for each post you can click on read post button to see the post and comments for this post if you want to create a post you need to be logged in so first let me register quickly by clicking on sign up button and providing my details and once you click on register button you're navigated to the login page you can also see a nice roaster notification here on the top right side so after the user registration we have to activate the account before we log in for that we receive an email to which contains uh the activation link for the account in this application i'm actually using a fake smtp server called as mailtrap instead of a real world mail server so all the mails which we sent from our application are sent to this mail trap inbox you can see that we have already received an email with subject as please activate your account and here as i am using a free account we can only see the text version of this email even though we are sending an html template as the email body so let's copy this activation link inside this email and open this in the new tab and you can see that our account is activated successfully now we should be able to login let's go back to our login page type our credentials and click on login so now we are navigated to the home page so first let's create a subreddit and then create a post inside the subreddit i will click on create subreddit button give a title and description for the subreddit and click on post now let's create a post i will provide the title so you can see that we are navigated back to the home page and this time you can see the post we have just created it shows the time as just now now let's log in as a different user and in the home page i can upload or download this post we have just created before so uh let's upload this and you can see that the upward icon now turns to green and even if you reload the page it shows a visual indication that the user has uploaded this post the same thing applies also of course for the download of the post and the last thing is as you can see on the top right section we have our username if you click on that we see a menu and let's click on profile and in this page you can see all the posts and comments which are created by the user so that is how our application looks like and the next step would be to actually start coding i will be first developing the back end and then we will see how to develop the front end so to create the backend project the first thing you have to do is to go to start.spring.io website this is the place where you will generate our project with all the required dependencies for this project we will add spring web as we are using spring mec we will add a very useful library called as lombok this library helps us to generate the usual boilerplate code in java like getters setters constructors equals hash code methods etc and the next thing is we also need spring security spring data jpa mysql java driver and lastly we will also add java mail sender dependency once this is done you can click on generate and and the source code will be downloaded to your machine now let's unzip the project and open it in your favorite ide i will be using intellij for the rest of the backend development for this project and for the frontend i will be using visual studio code so i open the project in intellij now the first step would be to create the domain entities for our application so let's expand this package structure and go to the root package and inside this package i already created two packages called as model and repository inside the model package we have all the domain entities we need for our application the first one is the post entity it contains a field post it contains a free post id which is annotated with id and generated value with a strategy of identity next we have a field name which has at not blank annotation so when we validate this entity before saving it to the database if at all the name field is either empty or null we will get a validation error with the message as post name cannot be empty or null next we have the field url which can be nullable followed by the description field which can also be nullable and is annotated with a lob annotation because we can have large chunk of text stored inside this description section we also have a vote count for the post followed by a reference to the user of the post we have many to one relationship here and a join and lastly we are storing the time at which the post is created through the created date field and this field is of type instant and also we have a reference to the subreddit entity with a manytoone relationship and a join one thing you may have observed here is we don't have the usual boilerplate code for this entity like the getters setters and constructors because these are generated automatically at compile time using the library called as lombok the first annotation we are using here is at data annotation this is responsible to mainly generate the getters and setters for our class it also does some other things if you're interested you can check the documentation for this annotation and the next we have a gpa annotation entity followed by the all aux and works constructor annotation which generates the constructors for the class and we also have a builder annotation which will generate the builder methods for our class this annotation mainly uses the famous builder design pattern to create the objects for a class with data you can check the link in the description to know more about this builder pattern before we go any further to enable lombok in your ide you have to install lombok plugin you can do that by pressing ctrl shift a and typing plugins and inside the plugin window search for lombok and make sure you install this plugin and restart the ide after that press ctrl shift a again and type enable annotation processing just make sure that this checkbox is activated and click on ok by doing this intellij will detect the lombok annotation and generate the related code at compile time if you are using any other ide i have added a link in the description to the lombok website there you can find step by step instructions on how to enable lombok on your favorite ide the next entity is subreddit we have the usual fields here the id name description a reference to the list of post with one to many relationship the created date field and reference to users with many to one relationship the user entity has the user id name password email created date and enable fields so here the user is enabled after completing the email verification process which brings us to the verification token entity whenever a user is registered we generate a token we store it in the database through this entity and send this token as part of the activation link to the user whenever the user clicks on that link we look up the user associated with this token and enable that user we will discuss this functionality in detail in the next upcoming videos and next we have the vote entity which stores the votes by the user we distinguish whether a vote is either upward or downward using a needham called as vote type the cnam has two possible values upward and downward and of course we have references to the post and user entities and both of them has many to one relationship that leaves us with the last domain entity comment it has an id text a reference to the post and the user with the many to one relationships for both of them and a join and we have the time step at which the comment is created through the a date field of type instant so the next step would be to create repositories to store these entities inside the database i have already created the repository package and all the interfaces we need so let's go through them one by one first of all we have the post repository which is extending the jpa repository which is taking the post and the long as generic arguments post is of course our entity and long is the type of our primary key and this interface is annotated with at repository annotation next we have the subreddit repository which is also extending the jpi repositories and taking subreddit and long as generic arguments followed by the user repository and next we have a word repository and lastly we have the comment repository now let's configure the database in our project for that open the application.properties file inside the source main resources package and add the following properties the first one is a property for mysql driver class name we will use the driver class of the com mysql cjdbc package the next property is the data source url will provide the jdbc url of our database schema we will see how to create this shortly using mysql workbench next up we have our username and password of the database followed by the hibernate dialect property here as we are using mysql database version 8 we are providing the mysql5 innodb dialect as the value for this property next up we have our ddl auto property i'm going with the value as update for now but if you are developing a production grade application you will give it a value of none and perform all your database changes through migration scripts using libraries like flyway or liquibase just take a note of this point and lastly we have the initialize and show sql properties as true now before we run our application we have to make sure that the schema already exists in your database here we have provided the schema name as spring reddit clone now let's open mysql workbench and once you are connected to the local database in the bottom left side corner of the screen you can find the schema section just right click over there and select create schema as i have already created the schema i won't be creating it again just make sure to add the schema name here and click on finish to create the schema and also make sure you put the same schema name inside the spring configuration pack inside the application.properties file now that should be it for the initial setup if you go back to intellij and go to the main class the spring reddit clone application class just click on the green arrow to the left side and click on debug this should start up the spring context and the tomcat server at port 8080 so inside the root package let's create another package called less config and inside this package let's create a class called as security config this class as the name suggests holds the complete security configuration for our back end the first thing we are going to do is add the add enable web security annotation to this class this is the main annotation which enables the web security module in our project which we have added to this spring security starter dependency after that let's extend our class using web security configure adapter this is the base class for our security config class it provides us all the default security configurations which we can override and customize in our application to do that first we have to override the configure method which is coming in from the base class this configure method takes http security object as input and inside this method we will disable csrf protection for our backend we are disabling it because csrf attacks can mainly occur when there are sessions and when we are using cookies to authenticate the session information as rest apis are stateless by definition and as we are using json web tokens for authorization we can safely disable this feature next up we will allow all the incoming requests to our backend api whose endpoint url starts with slash api slash auth and we make sure that any other request which does not match this pattern should be authenticated so we are done with the security configuration for now let's create the endpoint to register our users i'm going to create a package called as controller and inside this package i'm going to create a class called as auth controller and i'm going to add rest controller annotation on top of this class followed by the request mapping annotation which takes the value slash api slash auth now let's create a post mapping inside the class with value as slash signup let's also create a method called as sign up and to this method we will be giving an input of type register request through this class we'll be transferring the user details like username password and email as part of the request body we call this kinds of class as a gto that means a data transfer object i am going to create this class and put it inside a package called as dto and to this class let's add our lombok annotations at data at all logs constructor and lastly nox constructor now let's declare the fields the first one would be username followed by email and lastly the password field now let's create a class called as auth service inside a new package called as service this all service class contains the main business logic to register the users that means creating the user object and saving it to the database and sending out activation emails etc i will create a method called as sign up inside the class which takes in the register request object as input and the first thing we have to do is to create an object for the user class and we will map the data we have from the register request object to the user object first one would be the username email and password fields the created field i will pass in the value as instant dot now this is the java 8 class to get current time and lastly by default we will disable the user so let's set the value for ease enabled as false and once the user is successfully validated we will set this value we will set the enable flag as true before saving the user object to the database we have to make sure that we encode the password storing the password in clear text is a very bad idea so imagine that if your database is compromised you have to make sure that it would be very hard for the hacker to actually crack the password that's why we encoded using different hashing algorithms which makes it very hard to decode the passwords one of the best hashing algorithms we can use in this scenario is the bcrypt hashing algorithm spring security provides us a class which implements this algorithm called as bcrypt password encoder now let's use this class to encode our passwords i will go back to security config class and here i will create a bean for the password encoder as the password encoder is an interface we have to create a bin manually inside the configuration class and whenever we are auto wiring this bean we will get an instance of type bcrypt password encoder now let's go back to our service and autobuy the password encoder now let's call the encode method of the password encoder before setting the password field for the user and that should be it spring will now take care of encoding the password now it's time to save our user inside the database for that let's first automate the user repository in our class and inside the signup method let's type user repository.save and pass the user object to the save method now it's time to do some refactoring for this class you can see that we are using auto wired annotation there is no there is actually nothing wrong with using auto wired annotation but it is not usually recommended to use it because we are using field injection here and spring recommends us to use constructor injection whenever possible so i will add a link to a very good article which explains why to use constructor injection over field injection but just make sure to check that link i will not explain it in detail in this video but so let's remove this ultraviolet annotation and declared our field as final and usually we have to create a constructor and set the variable for our fields and set the variable for our fields but all this is taken care by the h haulocks constructor let's add that to our class and lastly let's not forget to add the transactional annotation to this method as we are interacting with the relational database now let's enhance our registration process by sending out account activation emails for this the idea is to generate a verification token right after we save the user to the database and send that token as part of the verification email once the user is verified then we enable the user to log into our application by setting the enable field as true let's create a method called as generate verification token which takes user object as input and let's generate a random token here we can do that by typing uuid dot random uuid this will generate a unique and random 128 bit value which we can use as our verification token now it's just enough to send now it's just not enough to send this token through email and forget about it we also need to purchase this token in our database so if the user chose to verify the account after two or three days we may not have this in memory at the time so it's better to save this token in the database and whenever the user has verified the email here we will look up the token and then enable the user so i will create an object for verification token and pass in the user and token details now let's auto wire the verification token repository and save the token to the database and also we will just return this token back to our signup method right now it's time to send out the activation email for the users as first step we need to add some additional dependencies to our project if you want to send html emails from our application we will use a template engine called as time leaf which enables us to create html templates and use those templates to send the emails let's go to our pom.xml file and let me add the timely starter dependency now let's go to the source main resources folder and inside the template folder here we create a html file called as mailtemplate.html and inside this file i will paste this html code which contains a span tag and here a variable called message is injected through timeleaf's text tag back inside the service package let's create a class called as mail content builder this class contains a method called as build and this method takes the email message we want to send to the user as input and we set this email message inside the time leaves context object we are doing that by using the set variable method of context and lastly we will be passing the html file name and the context to the template engine through the template engines process method so at runtime timeline will automatically add the email message to our html template okay now it's time to send out email messages let's create another class inside the service package called as mail service let's add an annotation to this class the usual service and at all logs constructor annotation let's create a method called as send mail and this method takes the object of type notification email as input if you go inside the notification email class you can see that it encapsulates all the details we need for an email such as recipient subject and body of the email let's go back to send email method and i will quickly paste in some code here and now let me explain this so we are constructing an instance of type my message helper inside the lambda which creates an instance of type my message prepared my message preparator and to this my message helper we are passing in the data like the sender information we are hard coding it as springreddit.email.com this can be any fake email address you like but here as we are using a fake smtp server it doesn't matter if you want to use a real world smtp server like gmail or something else then you have to give a real email address here or else it won't work so moving on we have our set to set subject and set text methods we are just mapping these fields from notification email object but for the set text method we are calling the build method of mail content builder object so this method will return the message in the html format lastly we are using the send method of the java mail sender class and we are logging a message called as activation email sent but we have a compilation error here because we did not define this log variable anywhere for that we can use the slf 4j annotation from lombok which will create an instance of slf4j logger object and inject it into our class so we have this particular code wrapped inside the try catch block and inside the catch block we are throwing a new exception called as spring reddit exception with a message let's create this class and place it in another package called as exceptions this clash should extend the runtime exception class and inside the constructor we will call the super method and pass in the exception message so you may ask why are we doing this what is the purpose of doing this right so let's discuss about this briefly in our back end especially when we are building rest apis exceptions are pretty common in our code so whenever those exceptions occur we don't want to expose the technical information to the user for instance like illegal state exception null pointer exception or socket exception something like this we should ideally present this information in an understandable format we can do that by creating custom exception like this spring reddit exception and pass in our own exception messages you can either create multiple exceptions for each use case in our application or create one exception to your whole application and reuse them everywhere in your code alright so we have covered all the logic to send out the emails but one thing we still need to do is to configure the smtp server details in our application for that we are going to use a fake smtp server called as mailtrap you can use this service to test your code which sends out the emails first of all you can go to mailtrap.io and make sure to sign up for the service and after signing up you can get and after signing up you get your smtp server details inside the inbox these details look something like how you see on the screen you get a host of the mail server a port which we can use and a username and password so let's configure these details inside our application.properties so i am going to copy these properties here we have a spring mail host port username and password all these details you can get through the mailtrap service and lastly the protocol we're going to send emails would be smtp okay now we have configured our smtp server and created our mail service we still need to call our mail service from our sign up method let's do this back inside the odd service class let's inject the mail service class and write after this and right after the generate verification token method i am going to type mail service dot send and we are going to create an object of type notification email and to this email the and to this object the first argument would be the subject let's pass in a string please activate your account as the first argument the second argument would be the recipient for that we type user.getemail and the last one is the body of the email i'm going to paste in a string here this string contains a url which redirects the user to our server and to this we are going to append a verification token so whenever the user clicks on this url we take the token from the url parameter and look it up in our db fetch the user who created this token and enable that user that's how the flow would be so the remaining part here is we have to call this signup method from our auth controller let's do that back inside the controller i am going to inject the odd service class and call the signup method and so if the registration is successful we have to send a message to the client we can do that by just returning a response entity which takes a string as the first argument and will pass the string user registration successful and the second argument would be an enum value okay from http status enum okay we are ready to test okay now we are ready to test our registration flow let's start the server and go to postman so i am using a rest client called postman to make calls to our backend here i'm making a post call to our sign up endpoint with the user details in the body now let's click on send and we go to response brock and we got a response back from the server as user registration success the first thing is let's check the database and check if our user is really saved and the password is encoded or not so inside the mysql workbench you can see that we have our user test user 5 and the password we have typed as password 5 in the initial request but you can see that the password is encoded inside the database now let's check if we got the email or not let's open our mail trap inbox as you can see we already got the email and you can see the activation link in the email if you copy this activation link and open it in the new tab nothing happens because we did not create the endpoint to activate the user let's do that now now inside the auth controller let's create an endpoint which contains get mapping with value as account verification followed by token which acts as a path variable now let's create a method which returns a response entity of type string with name as verify account and as we are passing the token as the parameter inside the url we have to add path variable annotation to grab the token and now inside the method let's call auth service and this time we call the method verify account and pass in the token to this method of course this method does not exist yet so let's also create it so here we have to query the verification token repository by token which we receive as input to the method so here let's type verification token repository dot find by token and pass the token as input of course this method definition does not exist in our repository so let's create it and this find by token method should return an optional of verification token entity so back inside the verify account method let's store this written type into a variable and as we are returning an optional here in case if the entity does not exist we can call the oral throw method and throw the custom exception with message as invalid token all right now we have to query the corresponding user who is associated with this token and enable that user for that let's create a method with name fetch user and enable which takes verification token as input and inside this method let's get the username by typing verificationtoken.getuser.getusername and store this written type inside a string variable called username now let's type userrepository.find by username and pass in the username as input let's also create this method inside the user repository and this returns an optional of type user now let's also call the oral store method and to this method let's pass in the supplier which throws our custom spring reddit exception with message as usual not found with name and we will append the username to the end so now let's store this result inside the variable user and let's enable this user by typing user dot set enabled as true lastly save the user inside the database and mark the method as transactional now let's go back to our auth controller and let's return a response entity back to the client by typing written new response entity let's pass in the first argument as message account activated successfully and the second argument would be http status dot ok ok now it's time to test the user verification let's start the server register with the new user and test the verification process okay so you can see that we received the response accounts activated successfully as expected now if you observe carefully an interesting thing is our api call to register users took more than 10 seconds to complete that means the user has to wait for 10 seconds after he clicked on the sign up button in the ui this is because we are sending a verification email after storing the user inside the database this kind of operations are very expensive and takes time to complete so as we are contacting an external mail server so of course there will be delay and this response will be slow what we should do in this case is to execute the code which sends the verification email asynchronously by running this part in a different thread if you're not aware of what is asynchronous processing i suggest you to google about it i will also provide a link in the description to know more about this but so fortunately in spring um running this piece of code asynchronously is not complicated spring framework provides us with asynchronous capabilities which we can use whenever we required to enable that we have to go to our application class and on top of the class just type at enable async this should already enable the synchronous processing through and now let's go to the piece of code which is responsible to send the email that would be the send email method inside the mail service class and on top of this method type at async so that is it now our code should run asynchronously and the response time for register users api call should be much faster so let's restart our server and test it again so as you can see the api call is taking very less time and looks far better than the previous response time this is the advantage with asynchronous processing anytime taking any time taking task can be executed asynchronously so these long running responses won't affect the user experience an alternative way to do this is to use message queues like active mq or rabbitmq but this these are too heavyweight for our use case right we don't have um we don't need to provide reliability to the emails but you want to put it we want to keep it simple so but if you are using this email sending functionality on a larger scale uh using this rabbit mq our active mq would be recommended so let's have a look at our authentication flow how would look like on the high level before we go and implement it so first of all we have a client who wants to login to our server the client makes a login request to the server by providing the credentials the server receives this information and validates the credentials and if they are matching it creates a json web token and sends this information back to the client the client uses this token to authenticate itself for all the consecutive requests it's going to make to the server so once the server receives a request with this token it first validates this token whether it's the same token which is generated by the server or not and after the successful validation it responds to the client with the required data before we dive in and start coding i would like to take a moment and explain you how the authentication mechanism works in spring security this is a high level uh overview because there are also lots of hidden uh functionalities and hidden components used in this uh in this uh in this authentication mechanism and because we are implementing in spring using spring security is not so straightforward if you are not clear what you are doing its very easy to get lost and confused okay here is the diagram which shows us the high level flow which is followed inside our project these are the main components we will be using to create our authentication mechanism the first thing is of course our auth service which we will receive which will receive the authentication request and inside this odd service we grab the username and password from the request and create a username password authentication token class we will pass this class to an authentication manager which takes care of all the authentication of its which takes of authenticating our users this authentication manager will use an interface called as user detailed service which can fetch the user details from multiple sources in our use case it would be database if the user details are incorrect we get an exception at this stage and if they are correct the user details are passed on to authentication manager which returns an authentication object back to the odd service so at this moment our authentication is successful so as you see in the previous diagram we will create a jwt and send it back to the user as a response so this is a bit indepth explanation of the authentication flow i hope it is clear for you without any further delay let's start coding all right so the first thing we need to do is to update our security config class we have to create our authentication manager for that spring uses a class called last authentication manager builder so let's configure this for that let's create a method public void configure global and now let's inject the authentication manager builder to this method using method injection we can do that by adding authentication manager builder object as input and adding ultrawide annotation on top of this method inside this method now we can use the authentication manager builder and since for this object we have a method user details service this method takes input of type user details service though we have saw so we saw what this user detail service does in the previous in the previous diagram so it mainly loads the user data from different sources in our case it would be database and provides the user data to spring so as this is an interface we have to create an implementation class so let's create a class called as user details service impul which implements the user details service interface now inside this class let's override the load user by username method this method takes the username as input and returns the user details object let me quickly paste the logic we are going to use in this method so first of all we are acquiring the user repository to retrieve the user based on the username if the user does not exist we throw a username not found exception this is the exception which is provided by spring and with that user object we create another object which is like a wrapper with the same name user this clair this class is provided by spring framework which implements the user details interface and here we are just mapping the user details to this user class and lastly we are providing an authority called as simple granted authority for a role called user so now we have the core part of the user authentication let's create the logic where we receive the request from the client so for that let's open the auth controller class and here let's create a new endpoint with a post mapping with value as slash login let's create a method by the name of login and to this method we'll pass an object of type login request so this is the same dto this is a similar dto we used for register for a registration functionality called as register request and let's create this login request class and this class contains mainly two fields a username and a password and let's also add the necessary lombok annotations uh namely data all aux constructor and nox constructor now let's go back to earth controller and type odd service dot login and pass the login request object as input to this method let's create this method inside all service now what we need to do here is to implement the logic to authenticate the user as we saw in the diagram minutes ago the auth service contains the logic to create username password authentication token and use authentication manager to perform login to do that first we have to autowire authentication manager into the odd service class if you read the documentation for authentication manager we can observe that this is an interface and for an interface if we do not mention explicitly what kind of bin to create spring throws an exception because there are multiple implementations of authentication manager so we have to create a bean inside our security config which extends the web security configure adapter so let's do that so whenever we auto wire authentication manager spring finds this bean and injects it into our class now let us continue the implementation inside the earth service class let's type authentication manager dot authentication and here we are going to pass an object of type username password authentication token by typing new username password authentication token and passing the username and password from the login request object as the constructor arguments okay so let's go back to our diagram and see where we are we implemented the part where we create the username password authentication token we pass this token to authentication manager's authenticate method which in turn calls the user detail service we also implemented the logic to read the user from database and return the user details to the authentication manager so now this authentication manager verifies our credentials in the background and if they are matching it returns us an object called as authentication that means we have implemented the authentication functionality but not completely we still have to create json web tokens and send it as a response to the client so before we create the functionality to create json web tokens we have to add some even dependencies so open up the bom.xml file and make sure you add these three jwt dependencies the jjwt api jwt impel and jjwt jackson so now let's create a class with the name jwt provider i will create this class in a separate package called as security let's add the service annotations to this class and now let's create a method public string generate token and this method takes an object of type authentication as input and inside the method i will type dot get principle let's cast it to user object and store it in a variable called as principle now we have the user information we can create our jwt by using the following code so here we are using the jwts class to construct our jwt we set the user name as the subject for the json rib token and to sign the json web token we should provide a key which we will implement shortly once we provide the subject and sign the jwt we get the token retained in the form of a string and now coming to the key in this example we'll be using asymmetric encryption that means we'll be using a keystore to sign the json web token specifically the private key of the key store to sign our json with token i'll quickly copy the required code and we'll explain you how we can use private private key to sign the json with tokens all right now let's go through the code first we have a field called as keystore and we are initializing this field inside this post construct block which is goes inside a method named init we are providing a keystore instance of type jks to the field and in the next line we are getting the input stream from the keystore file with the name springblog.jks this is the keystore file i also used for my other tutorial series build a blog with spring boot and angular if you're interested you can also check out the series inside the description section so once we load the input stream from the keystore you have to provide the input stream to the load method of the keystore followed by the password of the keystore and after that we just have to read the private key from the key store and pass it to the jwts class to sign our json web token to read the private key should mainly provide the alias of the keystore followed by the password of the keystore and this particular code throws so many different exceptions so as a best factories we are wrapping all those exceptions and just throwing a custom runtime exception with an understandable and meaningful exception message now let's call the generate token method of our jwt provider class from inside the odd service before that we have to store the authentication object inside the security context we can do that by typing security context holder dot get context dot set authentication and to this method to enter this method called pass in the authenticate object so if you want to check if a user is logged in or not we can just look up the security context for the authenticate object for the authentication object and if we find the object then we can be sure that the user is logged in and if not the user is not logged in so now let's inject the jwt provider class inside the odd service and back inside the method we will call the generate token method of the jwt provider and of course this method returns a string which is our authentication token now we can send this back now we can send this token back to the user to send this token we will use a dto called as authentication response let's create this class inside the dto package this class contains the fields with name authentication token and username both are of type string so now inside the login method let's create an object for authentication response fill that object with our token and the username and then return it back to the controller and inside the controller let's add a written statement to our call to the login method of the auth service and change the written type of the method to authentication response so now it's time to test whether the login is working or not but before that make sure that you have this springblog.jks file inside the resources folder or else the jwt creation won't work so now let's start the server and make a login request using postman so i made the login request using the account i have created before and you can see that we received the token the authentication token and username as response back from the server in the last video we saw a sequence diagram which provides a high level overview of the authentication mechanism in this video we're going to dive deep onto the fifth point where we validate the json web token on the server so this is how the actual process looks like the client makes a request to the server the request is intercepted by a custom filter called as jwt authentication filter this filter will retrieve the access token and validates it if the validation is successful the request will be forwarded to the corresponding controller now let's go ahead and implement this functionality so first of all we are going to create a class called as jwt authentication filter inside the security package and this class extends the once per request filter class and we're going to overwrite some methods and inside the do filter internal method we will intercept the request and fetch the token from the request headers because the client sends the token to the server as part of the request headers by following the bearer scheme so inside the two filter internal method i will call a method called as get jwt from request and this method takes in the http servlet request as input so to get the token from this request object we have to get the authorization header from the request we can do that by typing request.getheader of authorization let's store this value inside a string called as bearer token and this token is now sent in the structure you see on the screen so it starts with the term bearer followed by a space and followed by the json group token to get the token we have to exclude the term bearer and just retrieve the term and just retrieve the token we can do that by using substring method of string class so here i am going to type bearertoken.substring of 7. so let us store the token inside a variable called as jwt and now let's go to the jwt provider class and create a method called as validate token this method takes in the jwt and as the name suggests it is responsible to validate the json web token if you remember in the last video we used asymmetric encryption to create our tokens by assigning them with the private key from our key store and now we will validate the token by using the public key we can do that by typing jwts dot parser dot set signing key and here we're going to pass in the public key for that let's create a method called as get public key and here i will quickly copy paste the implementation which is very similar to the get private key method implementation but here we are going to call the getcertificate method of the keystore so we will get the certificate which goes by the alias name of the keystore and then we call the method get public key which returns the actual public key from the keystore and of course as this piece of code throws some checked exceptions willing to catch them and read through them as a runtime exception and now back inside the validate token method i will call the parse claims jws method and pass in the json web token which we are receiving as input and if this particular piece of code is executed without any errors we can be sure that the json web token is validated so in the next step we are just going to return the boolean value true so now let's inject the jwt provider class inside the jwt authentication filter class and call the validate token method so now if we have a valid token we have to load the user from the database and set the user details in the spring securities security context to do that first we have to get the username from the token we can easily retrieve the username from the token because we are using it as a subject when creating the token i will go back to the jwt provider class and create a method called as get username from jwt which takes the token as input inside the method i'm going to get the body of the token which is nothing but the claims and from the claims object i can retrieve the subject by typing claims dot get subject so this is going to be a string let's return this value from the method and also let's change the written type of this method to string back inside the jwt authentication filter class let's call the get username from jwt method and now we have the username again i'm going to copy the code which retrieves the user from the database and sets the user details into the security context first we are constructing here so here first we are constructing an instance of type username password authentication token and then storing this inside the spring security context so now the last part is to call the filter chain if our token is valid spring is going to find the user details inside the security context and it will fulfill our request if not it will throw an exception which we will see at the end of the video okay so we implemented the validation part now to test this we don't have any secured apis so let's go ahead and create one api to create and read subreddits let's create a class called as subreddit controller and the first thing we have to do when we create a controller is to annotate the class as rest controller and for this api we're going to provide the request mapping as slash api subreddit let's also add the usual lombok annotations we are going to need and the first method we are going to implement is the create subreddit method this method will follow a post mapping and as the request body we will send the information in the form of a dto let's call this dto as a subreddit dto and let's also create this class so basically to create a subreddit the information we are going to need is just subreddit name and description but we are also going to read the subreddit information for that we need the id of the subreddit and lastly the number of posts which are inside the subreddit let's create all these fields inside the dto and provide all the required lombok annotations okay so we should always try to avoid to write business logic in our controllers the responsibility is to receive requests from the client and delegate them to the service layer so to implement the functionality we are going to need a service class let's create this class inside the service package with the name as subreddit service and inside this class let's create a method called as save which is responsible to create and save the subreddit information to create the subreddit first we have to map the information we need from dto to subreddit entity let's create a method to do this mappings which is called as map subreddit to dto inside this method we're going to use the builder pattern to construct our subreddit entity and we'll just return it back to our method we can also use some mapping libraries like mapstract to make our life easier i will introduce that library in the upcoming videos but for now let's concentrate on creating the api and test the token validation logic so we have our subreddit entity let's save this inside the repository for that we need to first inject the subreddit repository into a class and later just save the entity by typing subreddit repository.save after saving the entity we can set the id field inside our dto and return it back to the controller back inside the controller let's inject the subreddit service and call the save method let's store the written type and return it back to the client but we just won't return the subreddit detail we will wrap the dto using spring's response identity class in this way spring provides us some sensible default information as response to the client we will type response entity dot status as it is a post call and as we are creating a subreddit the appropriate written type for this kind of rest call is value 201 in spring this value is represented by the enum created and lastly let's include the subreddit dto as the body of the response entity and written it back to the client now let's also quickly create an api to read the subreddits for that i will create a get all subreddit method which supports get mapping now let's create a method called as get all inside the subnet service and the most important annotation we forgot to add before is the at transactional annotation as we are using a relational database to guarantee consistency we need to add the annotations to all the methods which are going to interact with the database for the get all method we will add the transactional annotation with readonly flag as true so inside this method let's simply call the find all method of the subreddit repository and now we should do the mappings from subreddit entity to the subreddit dto let's create another method to perform these mappings and here let me quickly copy the necessary code as we are not doing anything complex apart from just some simple mappings once this is completed return the dto back to the controller and the controller will return this tool and the controller will return this dto with appropriate http status all right so we are coming to the end of the video before we go ahead and test our validation logic and apis we have to make sure that spring security knows about our jwt authentication filter class so let's go to the spring security config class and inside the configure method let's add this line of code which is http security dot add before and to this method we are passing the jwt authentication filter followed by the username password filter so now spring tries to first check for the access token the jwt token before trying the username password authentication scheme with that all the configuration part is completed so let's go ahead start our server and test our implementation so after starting the server open your favorite res client i'm using postman and here i've already prepared some requests to show you how it is working first of all i have made a login request with some credentials and i received a token as response so we are going to use this token inside the bearer scheme and make a request to create the subreddit as you can see the request was successfully completed and we received back the id of this update now let's try to read all the subreddits also for this i have prepared a request and here you can see all the subreddits i have in my database lastly let's test the negative case that means what happens if we try to send an invalid token to the server so let's go to the authorization tab and remove the last character from the token and send the request so as you can see we got back an error message from our server if we put back the correct access token and make the request again you should see all this updated information so let's have a look at what is mapstruct if you go to the mapstruck.org website you can see in the home page it is written that is a java library which generates the mapping code uh the mapping logic in our application that means if you have two two objects and you want to map the data between these two objects we can use mapstruct to generate the mapping code by just using some annotations if you scroll down you can see the section map struct in two minutes here we have an example where we have a car object and a car dto object so if you want to map the data between these two objects first usually what you will do is create a new car object and then use the setter methods to set the data for each field and imagine if you have like five or ten fields or more than ten fields in the pujo class then you have to write the mapping code manually so this will be pretty uh sometimes may be complex and also mainly it's pretty boring to write this kind of code so we can just ask abstract to generate this kind of code automatically by just writing the method definition which takes in the source object as input and we provide the target object type as the written type of the method and that's all we have to do mapstruck will then generate all the required mappings at compile time and so we will actually see how it generates the code and what kind of code it generates very soon but i hope you understand what is abstract so let's go ahead and install this library in our project okay so let's go to the documentation section in the home page and under the apache maven section you can see the the library details in the form.xml file so let's just copy these details into the corresponding section of our pom.xml file we need to copy the dependency and the plugin so the only change we have to do here is to add also the long block dependency to the annotation processor parts because lombok is also a library which generates code at compile time in our project so if you forgot to add this lombok dependency you will get some compilation errors in your project so so that's it for the installation we are ready now to use the mapping map struct in our project so let's start by creating some mappings in our subreddit service first of all i'm going to create a new package called smapper and inside this package i'll create a new interface with the name subreddit mapper and now let's animate this interface with headmapper and pass in the component model value as spring the first method we are going to define is the map to dpto method so this method takes in the subreddit object as input and returns us back the subreddit dto object so if we compare the fields we have id name description posts created date and user fields inside the subreddit and inside subreddit we have id name description and post count so we have some fields which with the similar field names and also types so maps track will identify and generate the mapping logic automatically for these fields and for the remaining field the number of posts this is just an integer field we have to create mapping from list of post to integer that means we have to just return the size of this list we can do that by creating a new method called as map post so which takes in a list of posts as input and inside this method we will just return number of post dot size so that means we're just returning the size of this list so we can tell to maps to use this method when mapping the post field by just annotating by using annotation called as app mapping with target as number of posts and here we are using a method to do this to use the mapping and here we're using a method to do the mapping so we will just use that method in the form in the field called expression so we just type expression and we pass in the java so let's try to compile this interface if you're using intellij you can type ctrl shift f9 and now you can check the implementation to see the generated code by mapstract let's create mappings from subreddit dto to subreddit entity we can do that by declaring another method but in this case we just add an annotation called as inherit inverse configuration so this and annotation will create the mappings similar to map subreddit to dto method but instead this time it will create mappings from subreddit gto to subreddit entity and in this case actually we can ignore the post field because we have to set this field when creating the post now let's also compile this code and check whether the mappings are created or not so as you can see we have generated the mapping successfully also for this method now it's time to refactor the existing code by first removing the mapping methods and replacing them with the methods from subreddit mapper so in the previous video i forgot to add an endpoint to retrieve a subreddit based on the id so let's quickly add this endpoint inside the subreddit controller i have created a method called as getsubreddit which takes an id of type long and this is also a path variable and i've also added the get mapping annotations which takes the id as the value inside this method i'm calling the get subject method of the subreddit service and this subreddit so and this get subreddit method is actually retrieving the subreddit based on the id and then doing the mapping and then returning the value and then returning the subreddit back to the controller all right now let's start our application and let's try to create a subreddit and see if the mapping is working correctly or not okay so now let's go back to intellij and let's start creating the api to create and read post the first thing we have to do is to create a class called as post controller and let's annotate this class with the usual annotations rest controller request mapping with value slash api slash posts and the last one is all aux constructor annotation so i will just copy paste all the methods which we are going to create here so the first one is a post mapping which is of course used to create new posts for this methods we are taking a post request as input and let's create this class inside the dto package and this class contains the fields post id subreddit name post name url and description and the remaining methods in our controller are get mappings we have one method to read all the posts in our application one method to written a particular post and another method to return all the posts under a subreddit and the last method is to return posts which are created by a specific user okay so let's implement these methods inside our post service class of course it's not existing let's create this class first inside the service package and let's add the service and all logs constructor annotations to this class now let's create the method save which takes the post request object as input now here we have to create the mappings from post request to post entity i have so i have already created a post mapper interface for this so let's go into that interface and you can see the first annotation we have is a mapper annotation from abstract on top of our interface and the first mapping method you see is to create a post from the post request object so to create a post we not only need the post details but also the subreddit and the user details we'll be passing these details through the post service class to this method and you can see here that we have mappings for the fields created date subreddit user and description and the first mapping for the field created date here i'm using the expression property and passing the value as instant dot now so this value will be mapped to the created date field inside the post object next one is the for the fields user and subreddit so here the field names are same between for these two objects that means post request and post so we can go ahead and remove these mappings because of the field name matches in the source and target objects then we don't need to explicitly mention the mappings that will be taken care by mapstruct the last mapping is for the field description here we have to mention that the source is inside the post request object that's why we put the value as post request dot description in the same way we have the other mappings for the method called as map2d2o and here we are mapping from and here we are mapping from post object to the post response up so the first mapping is for the field id inside the post response and here the source is the post id and followed by the post name description and url and the next mappings are for the fields subreddit name inside the post response but this for this field we are get using the subreddit the name field inside the subreddit inside the post class that means if i go into post we have the field subreddit and if i go inside subreddit we have a name field so we want to map this particular field to the post response subreddit name field so that's what we are inferring here through this post through this annotation we will be mapping the subreddit dot name field to the subreddit name field inside the post response the same applies also for the username field so as i said before we can remove the mappings whenever where the source and the target names are the same so let's do that now let's compile this interface and see whether the mappings are generated or not i will type control shift f9 which is the shortcut to compile in intellij and if you click on the green button here you can see the implementations which are generated by mapstruct let us go back to the post service class inside the save method let's implement the necessary logic we have the post request object and to construct the post object we need the subreddit and user details for that we need the subreddit repository and odd service classes let's inject these two dependencies to our post service now i'm going to retrieve the subreddit from the subreddit repository by typing subreddit repository dot find by name and pass in the subreddit name so if there is no subreddit with this name we are going to simply throw the subreddit not found exception next we need the details of the user who made this request we can get the user details by calling get current user method inside the odd service class now we have all the needed objects to get our post object so so let's inject the post mapper into a class and after that i am going to type postmapper.map and pass in the post request subreddit and user objects as inputs to this method and lastly and lastly let's not forget to add the written statement to the method okay now we are done with the save method the important thing here is to add the transactional annotation let's add it on top of the class and after that we have to implement the method to read the port and after that we have to implement the method to read the post by different criteria that means to get one post get so that means to get a single post to get all posts and to get the post by subreddit and users i'm not going to bore you by tapping all the usual find buy methods so just to make it quick i'm going to quickly copy paste and the required code so we have the method get posts here we are reading the posts by querying the post repository by id using the find by id method and if there are no post with that id we are throwing the post not found exception and if we do find the post then we are using the map to dto method from post mapper we defined and returning the post response back to the controller similarly we have the get all posts method and for the get posts by subreddit we have to first read out the subreddit details by id and then query all the posts by the subreddit then we get a list of force back from the find all by subreddit method which is defined inside the post repository interface and here we are going through each post inside the list using streams and mapping the post object to the response post response object and finally we are collecting to a list and returning it back to the controller the same thing is happening also here for the get post by username method so i'm not going to go into much details i hope it is clear for you what's happening inside this method before testing before testing this let's go to the post controller class and you can see that for every method inside this controller i am wrapping the response we are getting from the post service class with the response entity object so this is a class from spring mvc so through this object we can return the different status codes for different scenarios that means for instance if we want to create a post usually if we are creating a resource in rest world we should return http status as 201 that means created we can do that by using the status method and here i am passing the http status dot created enum value to this method similarly for the get mappings we are returning an okay status that means http status 200 in this in this way we can have nicely in this way we can nicely control what kind of responses we are sending back to the client so okay so as we are through with this it's time to start up the application and test the functionality we have developed so far so i will be back once i have started the application so we are going to test our post api now first of all i am going to login to our app and get a valid json web token from the application once i receive this token i am going to use it to create a post so here i am going to throw in some dummy data quickly and call the slash api slash post api with the http post method so as you can see we received a 201 response back from the server that means my request is successfully so that means my request is successful actually to be honest we have to return the id of the post here so just the user knows what what is the id of the post he has just requested to create but we can add that in the next sections for now let's go ahead and test the get functionality so as i mentioned before we are going to create the api to manage comments in our application before starting the code let's go ahead and see what all the endpoints we are going to create in this video so i opened the link for the written tutorial here and if you go to the section implement api for managing comments you can see a table where we have our required mappings along with the http method and the name of the method we are going to implement inside our controller so the first one is an endpoint to create comments in our application that would be a post mapping and the path is slash api slash comments the next one is the mapping to retrieve comments for a particular post here we have a get mapping and we are passing the post id as a uri path variable and similarly we have our last mapping to retrieve comments for a particular user which also takes the username as the uri path variable so now let's go ahead and start coding inside the controller package i am going to create a class called as comments controller.java and and the first thing we are going to do is to annotate this class with the usual rest controller annotation and after that the request mapping annotation and the value here would be api api slash comments lastly let's add also the lombok annotation or logs constructor now let's create our first method create comments and annotate it with the post mapping annotation as this is handles uh as this is going to handle the post request this also contains a request body so let's add the request body annotation and now we have to create a dto class called as comments dto which represents the structure of the request body so inside this comments dto i'm going to quickly copy the necessary fields and paste them and also the annotations we are going to use so we have the fields id post id created date text and username and here the text would be the actual comment posted by the user now let's go back to our comments controller class and here we have our request body now we have to convert this object into our comment entity and save it to the database as usual we are going to handle these logic inside our service class so let's create a comment service class inside the service package and add the needed annotations i'm going to create a method called as save which takes comments dto object as input now we have to map the data inside comments dto to our comment entity so if i open the comment entity class you can see that we have the fields id text post created date and user and we have the fields text inside our dto as we saw before and the field created date will be generated dynamically and all we need is a post and user to construct the comment object now if you open the comments dto you can see we have already the post id and username fields so we just have to query the post repository and user repository interfaces to retrieve the corresponding user and post objects so here i'm going to show a small tip if you're using intellij if you want to see multiple editors at once we have this very good option to split the screen vertically and also horizontally so that if i want to compare the fields i just can right click on the editor name here and select split vertically now you can see more than two editors at once this will come in handy when you are dealing with uh the projects which have lots of lots of files and also another tip is if you want to switch between windows you can use control tab this is a key combination this opens up a switcher window and there you can see the file history you have your file history and then you can navigate through that by pressing tab while holding the control key so this is the shortcut i use every time to navigate between the files in the history okay now back to our comment service class and let's inject the post repository and user repository into our comment service and inside the save method i'm going to query the post repository by using the find by id method and by passing in the post id so as this returns an optional if the post is not available we can call the orals throw block and inside that we will pass in a supplier to throw a post not found exception next thing is we have to determine the order of the comment so for that instead of using the username we can check who is the currently logged in user and use that object to create our comment object for that i need to also inject all service class into our comment service now we have all the necessary information all we need is a mapper which can map our comments dto to comment objects so let's quickly create an interface called as comment mapper which is inside the mapper package okay so i've already prepared all the method definitions and mappings inside this comment mapper interface the first mapping we have is for the map method which takes in the comments dto and the post and user and returns the comment so the first so the first mapping is for the field id so we are ignoring this uh id field because the id will be auto generated whenever we save the object to the database so there is no need to specifically mention the mappings here that's why i've used ignore equal to true value inside the annotation the next one is for the field text here we are taking the text value from the commons tto object and mapping it to the text val text field of comment object and the next mapping is for the created date field here we are evaluating an expression a java expression and i'm passing the java.time expression to the java to the expression field abstract will evaluate the instant.now expression and will take the written statement and map it to the createdate field so you may ask me why did i mention java.time.instant instead of just writing instant because whenever map struct creates the implementation class for this interface it will not add the import statement to the class because we did not mention how to so there is no explicit so there is no way to add the import statement to the implementation class so that's why if we provide the fully qualified class name then map then there is no need to add import statements specifically so these are the mappings we are providing explicitly next up is the method map to dto here this is a straightforward we have just a comment object coming in as an input argument and we are constructing and returning the comments dto object here and the first mapping is for post id here also we are going to use the expression field and we are going to pass in the java expression comment dot get post dot get post id because we have the post id inside the post object and similarly we are going to map the user name to the common studio object by using the expression comment.getuser.getusername now let's go back to our service class and inject this mapper inside the save method i am going to type commentmapper inside the save method i am going to type commentmapper.map and pass in the comments dto post and for the user object i am going to make a method call to auth service or services getcurrentuser method which returns us the currently logged in user so now let's store the written type of this into a variable and to save the object we need a comment repository so let's inject that quickly and save the object to the database okay we are done with the save logic now we have to also implement the functionality to send a notification email to the author of the post so that means whenever a user submits a comment on the post we will send a notification email to the creator of the post if you remember we have already built the mail sending functionality previously and so we can just reuse those code and so we can just use that code so i'm going to go ahead and inject the required components into a service and paste in the required code and we will have a look at it what's going what's it and we will and we will use it and see what it is doing so you can see we are first building the body of our email by using the mail content builder once we get our email message we can send the email by using the mail service dot send mail method and inside this method we are passing the notification email object where we pass the subject line of our email followed by the email address of the post author and followed by the email message so once we execute this one we are already sending the email message asynchronously to the user we have completed the implementation part inside the service now let's go to the controller and inject comment service and call the save method now we have to send the response back to the client that the comment is created we can do that by returning a response entity which takes the http status object as the constructor argument as we are creating a resource in the rest world we'll send back the response as status 201 or created so we have an enum value called as created inside http status enum so we will return that value so we will use that value inside the constructor argument of response entity let's create the implementations for our two get mappings the first one is the get all comments for post method which takes in a path variable of type long with name post id inside this method we are calling another method inside the comment service with same name get all comments for post and we are returning the response back to the client by adding the written type of this method call to the response body and finally we are sending the http status as ok for this rest call now let's create this method inside the comment service and inside the method we have to first query the post repository to find the post by id and as this method returns an optional we can use the oral throw method truth to throw a post not found exception if we do find a post then we store it in a variable and we will find all the necessary comments which are associated with this post by using the find by post method as this method returns a list of comments we use the stream and map functions in the java 8 to map the comment object to comment dto object by using the map2dto method from the comment mapper interface finally we are collecting the result back to a list and we'll return it back to the controller now let's create our last method get all comments for user which also takes in the path variable of type string and with variable name as username we are calling the get all comments for user method inside comment service and if you go inside that method we are first querying the user from the database and then querying all the comments by the user using find by user method inside the comment repository the resulting list of comments we are streaming and then mapping them to comments dto objects and returning the list of comments dtos object back to the controller we are also returning back the response entity to the client similarly to our previous method by adding the written value from the service to the body and the and the http status as okay all right we have completed the implementation of the api to create and read comments let's test our implementation now by first starting up the server and opening the postman client so let's open our controller class which is named as vote controller and here we have the annotations for our class the rest controller rest mapping and our logs constructor and the risk mapping is for the value slash api slash votes and inside this class we have only one method which is a post mapping so it's just its main purpose is to submit a vote um for a particular post and we are receiving a vote dto object as a request body as input from the client and if i drill down we have two fields in this class one it is a vote type and the post id so vote type is an enum which contains values for either an upward or downward and we also have a direction field inside this enum so for the upward we have the direction as one and for the downward we have direction as minus one and if you go back to the word dto the other field is an identification of the post so it would be just post id back inside the controller i injected the vote service class and inside the vote method of the controller i called the vote method of the vote service class so let's go ahead into the word service and this method is first retrieving the post which needs to be updated with the vote so as this find by method returns an optional we are using the orals throw method here to throw a post not found exception in case if we don't find any post and if you do find then we are storing this written type inside the variable so the next query is an interesting one we are finding the recent vote which is submitted by the user for this post so as we are using spring data here spring data jpa i created the method find top by post and user order by vote id descending so what does it query do so here we are first finding the user by post and the user information order those results by vote id in descending order and get the top one so what that would be so so we are just getting the recent vote by the user for a particular post so that would be the latest vote by the user so once we retrieve this information we want to do some validations here so we want to make sure that the user is able to either approach or download only once consecutively that means if i uploaded a post i should not be able to upload the post again because i'm the same user and i cannot do the same actions consecutively the only value reaction at the time is to downvote so here we are doing this validation and after that we are making sure that the vote is uh present and if the vote existing is the existing vote type is equal to the requested vote type then we throw an exception with the message because we cannot throw the we cannot vote in the same direction twice in the row so now after this validation we do either increment or subtract the vote count of the post by one based on the word type and finally we have to map this vote dto to vote so and then we save this inside the database the same also apply for the post so here in this method we are manually mapping uh the all the fields so because i don't like to create the mapper when we are creating a small mapping logic just mapping logic and it's just one method so it's better off putting this method inside the service itself so and what we are doing inside this method is to use the builder method inside the wood dto so we have this builder annotation which will be generating the builder method at compile time and so this builder method is used to construct the object of what dto so and as this builder methods name suggests it builds the objects by making the code more readable and easy to understand so this is there's a design pattern behind this method called as a builder pattern and you can read more about builder patterns and if you want to learn more design patterns in general i highly recommend you know going through the book head first design patterns this is a book which introduces you to the design pattern and it's a very good book okay let's move on and go back to the controller so after saving the vote information to database we just return a success response back to the client with status as ok now we have to include the vote and comments information when user is retrieving the post so i have added some additional fields inside the post response class i added this comment just for you to understand i will repo it now so these new fields are number of votes for a post the number of comments and the last field is duration so this field shows us the relative time duration of the post creation time so we are calculating this using a library called as time ago so let me open the github page of this library it's just a cortland library so we can also use it in our java project here in the example you can see that the time is displaying as four days ago a month ago and also you know just now so this is how you see the time stamp in sites like reddit and also stack overflow so let's go back to our project i can quickly show you the dependency information of this time i go library inside the form xml file and here we have this dependency followed by the kotlin libraries the kotlin standard libraries because this is a kotlin based library and we need to add also these dependencies to our project the first one is the kotlin standard library for jdk 8 and the kotlin test junit dependency and for this dependency kotlin standard library jdka to work with our project we need to also add a maven plugin with called as scotland maven plugin so this is including in the compile phase so whenever it finds some kotlin specific code it make sure to generate the java code for it and we are filling this value inside our post mapper and if we go to the post mapper if you notice that i have changed this from an interface to an abstract class here because uh we have to add because we have added four new fields into inside our dto and we need some dependencies to fill these details in the mapper that means for comment count we need access to the comment repository and for vote count we need to access the vote repository and also the odd service is used to calculate the votes uh word count so let us see what we have what we have changed here so after changing it to the abstract class i automate these dependencies as as i said before and our first method is a map which maps the post request to the post object and here we have set the word count to zero because whenever we are saving the post the default vote count should be should be zero right there is no need to put any value here so that's why i use the constant field inside the mapping annotation to send the value as 0. if i click on the green button you can see the implementation here of this particular abstract class so if you scroll down there is uh so there is a line of code called post dot word count as zero so the next method here is the map to dto method here we are mapping from post to post response and the newly added fields here are the comment count and the duration fields so the first common count is actually we are getting this written type from a method so here we have this expression field which is calling the comment count method using for taking the post as the input and this comment on method is just returning the comments um size of the comments which are which belong to a particular post so it's just returning an integer and the next one is the duration so this is where we are using the time i go library inside the get duration method we are using the using method of the time i go library so this takes in a long variable as input and to get that long variable we are using this get createddate function which returns an instant and on this instant we are calling a method called as to epoch milli so this converts the instant to a long long type and it basically calculates number of milliseconds starting from first january of 1970 until now so until the created date so if you go inside the documentation now you can see it returns the number of milliseconds since the epoch of first january 1970. so the good thing here is we updated our mappings and we didn't even touch the post service class because of this changes because we just updated our post mapper class methods inside this class and by creating this mapper we are able to decouple the mapping logic with with the actual business logic which is handled inside the service so that's always a good thing to decouple our components right so we have made all our changes we can start our application and inside the postman client as usual make sure to log in and get the authentication token back from the server and use that authentication token inside the builder token section and let's submit a vote to the server now i created this body so i have provided the watch type as download and provided a post id now let's test and send this request and see what it happens and as you can see the server responded with status that means with status 200 that means okay now let's see if the vote count is also included in the post response so now i'm going to call the end point to get all posts so here you can see that for the post id which i used before the vote count is 1 as we have downloaded this post so that means our implementation so that means our implementation is working as expected and let's also test another case so if we try to download the post again that means one more time you can see we have received the message you have already downloaded this post okay and the last thing i forgot to mention is you can now see the duration field inside the response this is channel this is changing dynamically now as i've you created this post long time back you are seeing these dates here like two months ago and six days ago as you are aware we are using json web tokens for the authentication mechanism and the main advantage of using these tokens are they are stateless and easy for the server to identify whether is request coming from a valid user or not so this may so this behavior makes implementing a perfect logout solution for the json web token based authentication scheme in the backend application very tricky and also difficult having said that there are four possible ways we can implement the json web token invalidation mechanism so the first one is to obviously delete the token from the client's browser so this is for sure a must when we have to implement the login but there is a possibility that a hacker may have already access to the json web token and this and that is the reason we have to find a solution to invalid the token also on our back end which brings us to our second point which is to introduce an expiration time for our tokens and make them as shortlived as possible so ideally we have to give an expiration time of 10 to 15 minutes for our json web tokens and here i will be using the terms the json web token and access token interchangeably from now on so but the downside here so as i was saying before but the downside here is once the tokens are expired we have to ask the user to log in again which is a terrible user experience so we can be sure that this solution is bad the third solution is to introduce a concept called as refresh tokens which builds on our point number two but the idea is to provide the user an additional token called as reference token at the time of authentication so we use this refresh token to generate a new access token whenever the access token is expired or about to be expired so in this way we can keep on rotating the access tokens and when the user logs out we can just delete this refresh we can just delete this reference token the last solution is when the user wants to log out we just store the token inside a database and once we have done that we check each token each request and check whether this request and check whether this token is inside the database or not so if this if it is part of if it is inside the database then we throw an error because this token is not is not valid anymore and as i said before this solution defeats the purpose of using a json web token because we're using a state and we are doing a database lookup for every request so even though instead of using the relational database if we use an inmemory database like redis we can hugely info improve we can hugely improve the performance of this particular solution so of ideally i guess a combination of 0.3 and 4 would be the better solution in other use cases but in our use case we will just go with the third solution and we'll see how to implement this refresh token mechanism in our application the first step here is to introduce expiration time for our access tokens to do that i am going to open the jwt provider class and inside this class i am going to inject a value from the properties file called jwt.expiration.time let me also add this so i also added this property inside our application.properties file with the same name as a key and the value as 900 000 so now we have to change the generate token method to include this expiration token so i can do that by adding a new method called set expiration and this method takes in the date object as input so for that as we have a long we can use the instant.now dot plus millis of the plus millis method call to convert this long to an instant object and from there we can use the date dot from method to convert this instant to a date object and let's also add a getter method for this expiration time as we will use this method soon let's open authentication response class and here we will add two new fields the first one is of type string and it's called as refresh token and the second one is an expiration date which is of type instant now let's open authentication service and inside the login method we will enhance the response we are sending back from the method so i'm going to add the expiration date to the response by first getting the expiration time in milliseconds from the jwt provider class and from there i'm going to calculate an instant from the time step by using the instant.now plus milliseconds method and for now we can just pass in the refresh token as empty string and so if you try to perform login so what we will get is one json web token one and one refresh token which is empty and an expiration date now next step is to implement the refresh tokens part first i am going to add a post mapping inside the auth controller class which takes a request mapping value as refresh slash token and this method is taking request body of type refresh token request this is a new class i have already created and this class contains only one field called reference token and this field is annotated with not blank annotation and if you add a valid annotation before the request body spring will automatically throw an error if you pass in an empty or null value as refresh token i did not implement this validations anywhere else in our application but in a real world application we use this validation mechanism very frequently so now inside this method i am going to add a method call to refresh token inside the odd service class and let's create this method so before so before doing any more implementation let's leave this aside and create a class with name refresh token service this class will be responsible to create delete and validate the refresh tokens so the first thing i'm going to do is to add in a method called as generate refresh token and here i'm going to create an object for refresh token and this refresh token is uh so we so we are going to store this refresh token inside the database if you go inside this class you can see that we have the usual data entity and all logs constructors the long block and the jpa annotations and the first field here is the id and followed by the token and the created date so we also have a repository created for this refresh token which is similar to all the repository we have so inside the refresh token service i am going to create a new object for the reference token and set the token so for the token the value would be uuid dot random uuid so this will so this will create a 128 bit unique random uuid and i am going to convert this uuid to a string and we will use this as our refresh token and for the created date i am going to pass in the present time by using the instant.nav method and after that i am going to save the token by just using the save method of the refresh token repository and the next method is the validate refresh token so this method is just takes the token as a value this method just takes token as input and we are just going to look up for this token using the find by token method and as this method returns as an optional we are going to use the oral throw method to throw a spring reddit exception saying that this is an invalid refresh token the next one is a delete refresh token method so this is just the normal delete method so we are just calling the delete by token method inside the reference token repository by passing in the bypassing in the token so if the token is not there inside the database spring automatically throws an illegal argument exception in this case now i'm going back to the refresh token method inside the all service class and here let's inject the refresh token service and down here inside the refresh token method first i'm going to make a method call to validate the incoming refresh token if the token is invalid then there will be a runtime exception and if not the execution goes on to the next step which is to generate new token we can use the generate token method inside the jwt provider class but if the jwt is already expired then there will be no user information inside the security context and as we need subject while creating the token which is the username we can just create another method called generate token with username and inside this method i'm going to pass in the username which is coming from the refresh token request as the subject so let's call this generate token with username method from our reference token method and let's store the written value as string variable called token now i'm going to construct authentication response object using the builder method we have our newly generated token the refresh token which is coming in already from the request the expiration date of this new token and username let's go back to auth controller class we do not see any errors inside the refresh token methods that's good and now let's go ahead and create our last method called log out which also has a post mapping annotation and here we are going to receive again the reference token request as request body from this object we can retrieve the reference token and we can call the delete refreshed and we can call the delete refresh token method inside the refresh token service to make this work let's inject the reference token service class inside the auth controller and lastly we can return a response entity with status okay and body as the refresh token deleted successfully okay so a quick correction inside the login method of our auth service class so here in the authentication response we are sending an empty string as the refresh token so instead of that we will be sending the generated refresh token by calling refresh token service dot generate refresh token so this will return us the string and we will pass this to the authentication response okay so that's it we have covered all the points to implement refresh token mechanism in our application let's start the application and test it so we'll be using angular 9 which is the latest version as of today when recording this video and i am going to use visual studio code as my ide for developing the frontend application so first thing first make sure you have the latest angular cli installed on your machine and after that open a terminal and type ng new and here i'm going to give the project name as angular reddit clone we'll be using angular routing in our project so i'm going to type y and for the style sheets we're going to just use the css and now angular cli is going to create all the project files and install the project for us and i will be back after the installation is completed so as you can see the installation is completed now and the project is initialized successfully as a git project okay now i'm going to type cd space angular reddit clone and after that i will type ng serve and our application should start successfully at localhost 4200. so if you face any problems while starting up the application one of the root cause may be the incompatibility between the versions of angular cli and some dependencies of angular this usually happens when you are running an older version of angular cli so to troubleshoot those problems i have a section inside the written tutorial based on the angular cli version you may have to change the version number of the angular dev kit dependency to be able to start the application successfully so if you open the address in the browser you can see the default homepage of the application alright so the next step is to install bootstrap in our project so in the terminal inside the project folder npm install save bootstrap this should install the latest bootstrap to our application once the installation is completed you can see that the bootstrap is added to the list of dependencies inside the package.json file now we have to update the angular.json file with the location of the bootstrap css files because the angular cli by default will exclude the bootstrap css files when creating the bundle when starting the application so we can instruct a cli to include these files by going to the angularjson file and inside the styles array we have to provide the location of the bootstrap css file just above the definition of styles.css so i am going to type here node modules bootstrap dist css and there we have the bootstrap.main.css file so i'm going to provide this definition inside the angularjson file and save it okay now it's time to create our first component we will start off with the header component we can create the component by typing nggc which is short form for ng generate component and the name of the component we are going to create is header so this will create all the needed files inside the header folder okay so in this series i'm going to mainly focus on the angular side and i'll be explaining the concepts of angular so i'll just copy paste the html and css part and some bootstrap is involved so to start things off i will first copy the needed html to the header.component.html file so you can see that we have a header tag and inside that we have a nav bar to the left side of the nav bar we have the reddit icon this is an svg icon which i copied directly from the reddit website and to the right side we have the login and sign up buttons so before checking how this html looks inside the browser first we have to add the app header selector to our appcomponent.html file so i am going to delete the existing code inside the app component html and and i am going to type app header inside the file so now when you open the application you should see this huge reddit icon to the left side of the screen and to the right side we have the links for login and sign up now let's make this look nice i'm going inside the header.component.css file and i'm going to paste again the required css here so now if you open the browser you can see that we have a very nice nav bar where to the left side we have the reddit icon followed by the edit icon followed by the logo text and to the right side we have the login and sign up buttons all right i know i told you our backend implementation part is completed for a dead clone application but before starting to develop our angular application i thought it would be good to also show you the procedure to document the rest apis we have developed in that way we can refer to the documentation whenever we need to write the logic to make rest api calls to our backend so now let's see why we need to document our rest apis in the real world you will be obviously developing a rest api so that other clients can consume it in our case the client is an angular application it's always the best practice to create documentation for our api so that the other developers can understand what they are working with so in the real world having this documentation is very helpful and improves the user adoption of your api and this also makes the maintenance of the rest api very easy all right now to implement this documentation in our application we will be using an open api specification called as swagger and a library called as springfox which allows us to automatically generate the documentation for our rest api by following the swagger specification so as a first step open the bomb.xml file and add the following maven dependencies the first one is springfork's swagger2 and the next one is springforks swagger ui both these dependencies are on version 2.9.2 as the latest at the time of recording the video after that make sure that there are no errors shown inside the pom.xml and now i'm going to create a class called as swagger configuration inside our config folder inside this class i am going to add the configuration annotation and here i am going to enable swagger in our application by adding enable swagger to annotation and inside this class i am going to create a bean the name of the bean can be anything you like so i'm going to create it as reddit clone api and here we are creating and returning an object called as docket and according to springfox documentation a docket is a brief statement of the contents of the document you can configure this docket object to decide what shows up inside our swagger documentation for now we will use the defaults except for the api infos here we are calling a method called as get api info which returns an object of ipinfo inside this method we are providing the details of our api which are like the title version number contact details and licensing information if you want to have a simple rest api documentation this is a very good starting point and this configuration should be sufficient now we have added the configuration class let's import this configuration inside our application class i am going to import this configuration using the add import annotation in this way at the application startup spring will invoke springfox and springfox is going to scan all the rest controller components in our application and the corresponding details for the stress controllers and generate the rest api documentation for all of these let's start up the application and check whether we are able to see the documentation or not once you open the browser go to address http localhost 8080 swaggerui.html and as you can see that we received at 403 error so this is because spring security is not going to allow access to this resource because we have configured to block all the requests without the token we have already added some exceptions to our security configuration so we can also add the swagger ui.html and some other parts to our exclusion list so this helps us to display the rest api documentation webpage once this is completed restart the application and open the url inside the browser now you can see the complete western pa documentation for our application so you can see we have all our rest controllers which are defined inside our project here in the swagger documentation we can see what are the end points which are there in our application including the http methods they support we can also check the models these are the request and response classes which are also called as dtos and we can also see the example values we can provide to the request payload and which data type they support and lastly you can also see the documentation as a raw json by clicking on the url localhost 8080 v2 api docs so in the part 10th of the video tutorial series we have already created our angular application created the header section which contains the buttons for login and sign up so in this video we are going to implement the signup functionality and for that let's go ahead and implement the signup functionality for that i'm going to open the terminal and type nggc or slash signup this will create our signup component in a typescript html and css file inside the auth sign up folder now i'm going to open the written tutorial and copying the sign up component html file code from there and paste it inside our project after that let's also copy the css file to the signupcomponent.css now before checking out how this looks inside the browser you have to add a route from the sign up button on the header section to the sign up page if you check the signup anchor tag inside the hydracomponent.html file it's pointing to the path signup let's add this path to the approaching module.ts file where we declare all the routes which are there in our angular application and here i'm going to update the routes array with the route information for signup component now let's go to the browser and check if you are able to navigate to the signup page after clicking on the sign up button on the header section so perfect it works now let's handle the form input inside our signup page using reactive forms as a first step let's import the reactive forms module inside our appmodule.ts file i am going to add reactive forms module just below the approaching module and also make sure that to add the import statement for reactive forms module from angular forms after that let's declare a variable called as signup form which is of type form group inside our signupcomponent.ts5 and inside the ng on init i am going to type this dot sign of form equals new form group and inside the form group i'm going to declare the found controls for the fields we have inside our signup form the first one is the username field so here i'm going to type new form control and pass the form state as empty for now and the same thing also applies for the other fields email and password we can also add validations for this field let's update our form control by adding validators dot required for each field and especially for the email field inside the signup form we will also add validators dot email to check the input value for email field is in the valid format or not all right so we have made lots of changes inside our signup signupcomponent.ts file we have to sync these changes also to our html file so now let's open signupcomponent.html and first let's declare the form group directive for the top form tag and pass the variable signup form next we have to assign the form control names to the input fields inside the input tag of the email field i will type form control name in square brackets and provide the value email with single quotes if we do not provide single quotes angular will check for a class level variable with name email but we declared this field as a form control so by so by adding the single quote angular understands it as a form control value i am going to add the form control names also for the username and password input fields and lastly let's add also the code where we display the validation errors for each field so just below the input tag i'm going to add a span tag and inside the spanning tag i'm going to add an ngif directive and type signup form dot get the single quote dot valid and sign up form dot get email again with single quote dot touched and let's add text please provide valid email so what's happening here is we have added the validators inside the form controls for each field so if the given form control is invalid signupform.getemail.valid will return either true or false so if the given field is changed by the user and the value provided by the user is not valid we will display this message let's copy this and also adapt it for the username and password fields now let's check how this looks inside our browser i am going to select the input field inside the email and then click somewhere else so you can see that we receive the message please provide valid email address the same thing should also apply for username and password fields perfect okay now if there is an error let's show the input with the red border for that i am going to open styles.css file and type and type input dot ng invalid dot ng touched and then i'm going to provide the border as one pixel solid with red color okay now let's save okay let's save this and go back to the browser and if i try to change the input field and click somewhere else on the page you can see the error message along with the red border on the input field okay now it's time to take the input from the form and make a http call to our backend api before that let's check the swagger documentation we prepared so i'm going to open the url http localhost 8080 swaggerui.html and under the out controller expand the endpoint for signup and here you can see the payload which is accepting that is we need a username email and password so we already have those fields inside our form so let us create a model in our angular application to encapsulate these fields i am going to open i'm going to go inside the signup folder and create a file called as signuprequest.payload.ts and inside this field i'm going to create a signup request payload model interface with fields username email and password okay now let's declare this model inside of component i'm going to give the variable name as signup request payload and i'm going to initialize this model inside the constructor here i'm going to provide an empty string value for each field all right now we forgot to add the ng submit directory to our form which handles the on submit action so let's quickly add it and this ng submit directive should call a method called as sign up let's also create this method inside your component and inside the signup method i am going to read the values from our form group one after another and assign them to the fields inside the signup request payload i am going to access each field by using the get method on the signup form and accessing the value property which returns the value of the form control now we have our request payload object ready next step is to make the http call to our backend we will make that call in a separate class called azure not service so let's create this service i'm going to open the terminal again and we'll type nggs auth shared this is going to create an odd service dot ts file inside the auth shared folder perfect so let's open this all service class and declare a method called as sign up and inside this method we have to make the http call for that we need access to the http client class inside angular let's inject this class into our service through the constructor and after that let's come back to the sign up method and type this dot http dot post and here i'm going to paste the url for the sign up api and we'll be receiving the signup request payload as the input for this method so let's pass this object as the request payload and lastly let's add a return statement for this method and declare the written type as observable of any also as the response from the backend call for the signup call is a string we are going to change the written type as text so now before accessing the http client inside our service we have to declare the http client module inside the module.ts file so let's open the file and declare the http client module now let's inject this all service class into the signup component.ts file and inside the signup method i'm going to type this dot all service dot sign up and i'm going to pass in the sign up request payload as the input as this method returns an observable i am going to subscribe to this return type and add some console log and lock the response so now let's open the browser and check viewer now let's open the browser and check if you are receiving a success response or not so here what we are receiving is an error response which says the request is blocked by course policy and our preflight request doesn't pass the access control this we are receiving this error because our back end is blocking the request because we did not specify any course policies yet so let's configure them by the way if you are not sure what is cause i'm not going to go into the details about that i have already created a separate video in my previous builder blog with spring boot and angular series i will add a link to the description you can check that video and come back so please check the video for more information so now let's go back and open our intellij ide and here i'm going to create a class called as web config inside the config folder and i'm going to add the configuration and enable webmec annotations here on top of the class and i'm going to implement webmvc configure interface for this class and i'm going to overwrite the add course mappings method and this method contains all the course related configurations which we required for the back end and here we are actually accepting the request from all is from all origins to our backend if you are developing a production grade application you may want to not do this and read more about what are the right way to do but for now this configuration should resolve the problem we have with our registration so let's restart the backend application and try to register one more time so now you can see that we are receiving the success response from our backend so in the last video we implemented the sign up functionality let's go ahead and implement the login now the first thing i want to do is the first thing i will do is of course create the login component for that type nggc login in the terminal this will create all the required files after that open the blog post which is linked in the description and copy and paste the html code for the login page and paste it inside the login.component.html file and next also copy the css code to the login.component.css file now if you compare the css files of login and signup components you can see that the css classes login and sign up share the same code so let's extract this code from this files and put it in a commonplace styles.css file the next step is to configure the routes for our login page so so when you click on the login button on the header will be navigated to the login page we can do that by first opening the approaching.modules.ts file which is the place we declare all the routes in our angular application and then i will be updating the routes array with the path for login component after that is done let's open the logincomponent.ts file and let's configure the form group with variable name as loginform and i'm going to initialize the form inside the ngoninetblock here we are defining the form controls for two fields we have inside our form which is username and password and we also have defined the validations that these fields require when submitting the form now let's open our login component html file and sync the validations we did in the component.ts file just below the input text for username i am going to add a span tag which is going to access the form control information through login form form group and here if the user has touched the input and did not provide any value we will display the message please provide a valid username now i am going to do the same thing also for the password field and in this case we will display the message password cannot be empty if you open the application in the browser and try to click on the input field and click away on somewhere else on the page you should see the validation message and also the border is marked as red all right so let's move ahead and write the logic to make an http call to our login rest api similar to what we did for signup rest api let's try to access our swagger api documentation at http localhost 8080 swaggerui.html and you see we've got a 404 error this is because after enabling the web mvc for the course configuration in the la in the previous videos we broke the swagger configuration because now the spring mvc does not know how to handle the web jars which is coming as part of the swagger spring fox library and that below function just below the course mapping method so in this method we are pointing to the location where the web charge and the swagger ui.html can be found in the class path after that restart the application and refresh the shraggerui.html page and we should be able to see the swagger rest api documentation again expand the art controller and click on the login api section and you can see this api accepts username and password has the request payload and it returns the odd token reference token username and expiration time as responses so now let's go ahead and create the models in our wrangler application to hold this data back to the visual studio code let's create a file called login request.plo.ts inside the auth login folder and let's define an interface called request payload with field definitions for username and password both of them are of type string and i'm going to also create a file login response payload.ts under art login and also here i'm going to create an interface with fields auth token refresh token expire set and username now let's open the odd service class under the auth shared folder and add a method called as login which takes the login request object as input and inside this method let's make a post call to the login api here we want to specify the written type as login response by passing in the generic type to the post method and let's use the pipe method and map method from the rxjs to map the response to and let's use the pipe and inside that we will use the map method which is part of rxjs and we can access the fields which are part of the response here now inside this method we are going to store these details inside browser's local storage for that we need to add a dependency to a project called as ngx web storage let's add it to our package.json and run npm install once it is completed we can enable ngx web storage in our application by adding the ngx web storage module to the app module.ts file just below the http client module i am going to declare ngx web storage dot for road and and also make sure to add the import statement from the ngups ngx web storage package all right now we are ready to access the local storage from our application so let's go back to our auth service class and inject the class local storage service from ngx web storage and once it is run let's store the token and user information inside the local storage by typing this dot local storage dot store followed by the key and value of the data we're going to store now the last thing remaining is updating our login component so let's do that by first declaring the login request payload variable just below the form group declaration and i'm going to initialize this login request payload object inside the constructor next i am going to create the login method and read the username and password values using the login form form group variable and assign it to the username and password fields inside the login request payload object and after that i'm going to call the login method of the or service by passing in the login request payload object and as this returns an observable let's subscribe to this and add a console statement called as login successful now we are ready to test our implementation so let's restart the application to reflect the changes we did to our app module the trees file so now i'm going to open the application inside the browser and try to log in so you can see that we don't see that nothing happens on the screen but if you open the console you can see the message login successful and let's open the application tab under the local storage and let's open the application tab in the console and under the local storage you can see the auth token and refresh token information along with the username and expiration time as a first improvement let's add a toaster notification to the application so after every successful sign up and login the toaster notification should look something like how you see on the screen so first i'm going to open the package.json file and add a dependency called as ngx toaster we're going to use the version 12.0.1 as of now because it is compatible with angular 9 and after that we have to run the npm install command to install this dependence after that open the appmodule.ts file and we have to add two modules here the first one is browser animation module which is coming in from angular animations and the next one is toaster module so for that we have to type toaster module dot for root which is coming in from the ngx stores to dependency next we are going to inject the toaster service inside the sign up component along with the router class and inside the signup method on receiving successful response you are navigating to the login page and we are also adding a query param called registered with value as true so we are using this to notify the login component that registration is successful in the case of receiving an error response we want to display an error notification so now let's go to the login component and here we are going to inject the router and toaster service classes and additionally we will also inject the activated route class to the login component to access the route parameters which is coming in from the signup component inside the ng on init method we are subscribing to the query params from the activatedroute object and in case we receive a query parameter with the value for registered as true then we display the success notification message sign up successful using the toaster.success method and the next thing is we are setting the value for the field register success message we will be accessing this message inside the login component html file after the successful registration inside the login method we are subscribing to the response we are receiving from the allservice.login method and in the case of successful login we are navigating to the view to url and then we are enabling the success notification with the message login successful if we receive a failure response from our login call we are setting the value for the boolean variable ease error and inside our html file we have an ng if statement which displays the error and asks the user to retry now let's go ahead to the main section of this tutorial which is to handle the reference tokens in our angular application our backend server which we have implemented expects the json web token for each request and it checks for this token inside the authorization http header so we have to make sure that our each request going from our angular client to the backend server contains this token this can be achieved by using a special component in angular called as interceptor the concept of the interceptor is similar to the servlet filters in java in our case we need an interceptor which modifies each request going to a backend server by adding the token information to the header and of course we also maintain the logic for reference tokens inside this interceptor when the client sends an expired token to the server the server responds back with the 403 error and at that point request a new token using a refresh token and using that new access token for subsequent requests now let's go ahead and implement this logic in our angular application i am going to create a file called as token interceptor.ts under the app folder and this file contains a class called as token interceptor which implements http interceptor interface inside the interceptor method we first read the token from our local storage using the all service dot get jwt token method which is just retrieving the authentication token from the local storage if the token is valid we will be setting the value inside the authorization headers if our json web token is active this will this is how the process works now if the token we are setting to the headers is an invalid token we receive an error response from a backend in that case you have to prepare our client to make the reference token call to the backend and when we make this call we have to temporarily block all the outgoing backend calls for this user and once we receive a new authentication token from our backend we are going to release all the requests again so we are able to fulfill this functionality with the use of a boolean variable called as ease token refreshing and a behavior subject called as refresh token subject which in our case acts as a semaphore to block the outgoing calls the main reason to use a behavior subject instead of a subject or an observable is because the behavior subject can have a value assigned to it so when we receive the new token from the refresh token method we can assign the token to the behavior subject and access the new token inside the interceptor coming to our refresh token method if we check the rest api documentation this method takes in two fields as input the refresh token and username so we are constructing this object inside the refresh token method and making a http post call to our backend for this post wall we are receiving the login response object from our backend as response and we are storing the new authentication token and username values inside the local storage as we discussed before we are setting the new access token value to the behavior subject and setting the ease token refreshing field value to false or else all the outgoing calls will be failing with the 403 error okay now before we test this implementation we need to create a home page component in our application for that i am going to type ngc home this component retrieves and displays all the posts we have in the database so for that now open the written tutorial and copy the html under the create home page component section and paste it into the home component html file i will be explaining what's inside this file in the next tutorial but for now as we are just testing the refresh token functionality let's leave this as it is so so i'm going to create a new service using the command ngg has shared post so this will create a class called as post service under the shared folder and inside the constructor i'm going to inject the http client class to our post service and let's create a method called as get all post so now let's go ahead and check our rest api documentation so you can see this is just a normal catch call and we receive an array of object which contains all these fields which are related to the post so now let's go back to the vs code and create a file called as post model dot ts and inside this file i'm going to create a class called as post model which contains all the fields in the rest api documentation all right now let's open the home component class and here i'm going to declare a variable called as post which is of type array of post model and inside the constructor i'm going to first inject the post service class and i'm going to call the get all post method of the post service and subscribe to the response and assign the response to the post variable inside the component finally we have to add route to the home page component so open up the approaching module.ts file and add an entry to the routes array just above the signup route information and specify the component as home component all right so there's a lot of changes we have done we also need one small change before we go ahead and test the implementation we forgot to add the css entry for the ngx toaster library inside our angular.json file so let's quickly add it just below the styles.css declaration so let's restart the server just to make sure that all the configuration is up to date and test our implementation first i'm going to register as a new user and let's see if the sign up successful notification is visible or not so we can see this notification that's good now let me quickly activate this user or else we will not be able to login and now let's try to log in you can see we are able to see the toaster notification with the message login successful and we are also able to see the post information which is coming from our end this looks ugly but for now let's leave it we will make it look decent in the next tutorial but in the last episode we just dumped in the html code for our homepage into the homecomponent.html file let's go through it step by step and try to understand the code so we just have a container div and inside that we have another div with class row then we divided this row into two columns one with the width of nine units and the next column with a width of three units inside the first column we have again a div which displays the post information as seen in the comments and this div element contains ng4 directive which is looping through all the posts which we are receiving from the post service so if the post variable contains four posts for example this day will be repeating four times and inside the div we again have two columns the first column has one unit of width and as you can see in the comments this section is used to mainly display the vote information for our posts and inside this deal we have two icons one above and one below the vote count div this element displays the vote count for this post so these icons are coming from the fort awesome library we will install this library see how to start working with this icons and so the next column contains the post information this div is 11 units wide and here as you can see we already have all the post information we need this column first contains the subreddit name and after that the name of the author of the post and also the duration that means how much time back this post was submitted by the user the next field is the post name followed by the description and the number of comments which are associated with this we have another icon in the section an icon for comments we will also shortly see how this looks now let's install the fourth awesome icons in our project the first dependency to add inside our package.json file is angular font awesome followed by font awesome svg core and free solid svg icons dependencies these are the latest versions for each of these dependencies at the time of producing this episode if you somehow provided an older version number vs code automatically suggests to update to the latest version so you just have to click on the section and run npm install after running npm install we have to enable the font awesome module in our project so i'm going to open appmodule.ts file and add this module information under the imports array and also make sure to add the import statement for this module from angularfont awesome library now we have to import the required icons into our home component.ts file from the free solid svg icons library so i am going to import the icons fa arrow up fa arrow down and fa comments and these properties are already tied to a html file through the icon property so we just have to declare these properties inside our homecomponent.ts file now if you go ahead and open the application inside the browser you can see the up and down arrows along with the icon for comments but one thing which looks strange is that the home component and the header component are overlapping we can fix that easily we can fix that easily by adding the css to our styles.css file we basically added a margin top value has 63 pixels for a body if you go and check the application you can see now the home component is not overlapping with the header component anymore okay now let's go ahead and try to break down this home page to different components for that i'm going to use the screenshot of the final version of the home page to get an idea how we are going to refactor this page so in the homepage we have many posts to the left side of the screen and to the right side we have the sidebar section where we can create post and subreddits and we have another section where we can view the subreddits which are created in our application so we are going to divide this mainly into four components the first one is called as post tile component which contains the information needed for each post and inside this component we have a voting section which contains an up arrow a down arrow and the vote count we will create a separate component also for this section called as vote button component the next two components are the sidebar component and the subreddit view sidebar component so let's go ahead and create those components one by one i am going to put those components inside the shared folder under the app folder because we can reuse these components to display in multiple pages now let's copy and delete the code which is displayed just below the display post comment you can easily copy the code by first collapsing the step element to just two lines and after that let's delete this code open the post style component.html and paste this code as we are in a different component now we no longer have access to the post variable inside the post style component as we are reading the post inside the home component we have to either move the code inside the post style component or pass this variable pose as input down to the post style component i would prefer to move the logic from the home component because from now on this component serves only as a placeholder so i am going to go inside the file and remove the injected post service class and also the method call to get all posts from the home components constructor and add it to the post style component.ts file let's also transfer the font awesome icon properties to the post style component.ts5 so the selector name of this component is app post tile let's go ahead and declare this inside our homecomponent.html file we should also add some css for this component for that i am going to take help from the written tutorial under the post style component section copy the css under the poststyle.component.css file and paste it inside the project now inside the post style component we have to extract the vote button component so i am going to again collapse the due section with class call mg1 copy and delete it open the votebutton.component.html file and paste that code now to display the vote count inside the vote button component we need also access to the post information so for that let's provide the post object as input to the word component so i am going to create an input property called as post of type post model let's copy the selector for the wordput component and declare it inside inside the post style component.html file enter the selector tag passing the value for the property post let's also copy the necessary css from the written tutorial and copy it inside our votebuttoncomponent.css file next up it's time to add logic inside the sidebar and subreddit sidebar components also here i am going to copy the html and css code from the written tutorials and paste it inside our project now for subreddit sidebar we have to read the subreddits from our backend and display them under the section let's quickly have a look at our swagger rest api documentation and you can see that we are receiving the following properties as response for the subreddit api call for that first let's create the service file which makes the http calls to our backend i am going to create the service using the command ng gs which stands for ng generate service subreddit subreddit this should create a subredditservice.es5 under the newly created subreddit folder now let's also create a model class which holds the response from the subreddit http call i am going to create a file called as subreddit response.ts and i'm going to create a class which contains the field id description name and number of posts inside the separated service first i'm going to inject the http client inside the constructor and i'm going to create a method called as get all subreddits inside this method i am going to make a http call to the get all subreddits api let's add the array of subreddit response class as a generic argument for the http get call and specify the written type as observable of array of subreddit response now let's open the subreddit sidebar component file and inject this updated service and inside the constructor let's add the call to the subreddit.getall subreddits and let's subscribe to this response and assign the response to the subreddits variable which is declared inside the component this property is already bound to the html as we have an nga4 directive which is displaying the subject names for all the subreddit responses now one thing we have to observe here is the list of subreddit response can contain any number of records and if you just reiterate and display all of them and will face problems while rendering the section that's why it would be a good idea to limit the number of values we display in this section and if there are more than say four records in the array we'll only we will display a view all button which takes us to a new page and display all the subreddit information for now let's add this view all button to our section we can add that by declaring a boolean flag first inside the subreddit sidebar component called as display view all and inside the subscribe method of the get all subreddits call if the response contains more than four entries we will use the splice method to take a subset of only four values from this array and display those values inside the section or else we just assign the array as it is to the subreddit property before checking our refactored home page inside the browser we have to make some additions to the vote button component.ts file we have to move the fa arrow up and fa arrow down properties from the post tile component.ts to the woodbutton component.ts file and lastly i am going to copy the selectors for sidebar component subreddit sidebar component and add them to the right column of the homepage html file now if you open the application inside the browser you can see the list of course along with the vote button component the left side of the page and on the right side we can see the sidebar which contains the create post and subreddit buttons and below that we have the sidebar with subreddit information along with the view all hyperlink let's start off by generating the components required to create the subreddits and posts inside the terminal i'm going to type ng gc subreddit slash create subreddit which stands for ng generate component with the name create subreddit under the subreddit folder and after that i am going to type nggc post create post which generates the required files for the create post component in the previous episode we have already created the buttons for create subreddit and create post inside the sidebar as we have now created the components we have to add a route from the create subreddit and create post buttons to this components inside the approaching.module.ts file let's add two entries with part create post and create subreddits which point to the respective component after that if you go to the sidebar.component.html file you have defined the value for the click directory as go to create post and go to create subreddit but we are missing this method definitions inside the sidebar component so let's go to the component and here i am going to implement these two methods we have the logic to navigate to the create post component inside the go to create post method and we also have the similar logic inside the go to create subreddit method where we are navigating to the create subreddit route now let's go ahead and implement the logic to create subreddits from our angular application i'm going to open the written tutorial and click on the section create subreddit and i'm going to copy the html and css code and paste it into the files inside the project inside the create subreddit.component.html file we have a form which contains the form group with value create subreddit form and an ng submit directive which calls the create subreddit method inside the component inside this form we have a div which contains the heading for this form create subreddit next we have an input of type text which holds the title of the subreddit we declare this field as a form control by using the form control name directive after that we have a text area which is another form control which holds the description of the subreddit next we have two buttons create and discard and we have an on click event which is bound to the methods discard and creates updated for these buttons using the click directive now let's go ahead and implement the required form groups form controls and methods we need inside the create subreddit.component.ts file so inside the component first we declared a form group of variable creates updated form which we saw before in the html file and we are initializing this form group inside the constructor with fields title and description each of these fields are assigned to a form control object which contains a validator which validates that the value for the fields title and descriptions are not empty next we also declared an initialized subreddit model object if you remember we have created this class in the last episode while refactoring the form component then we have the create subreddit method which reads the form control values for fields title and description and then we are assigning it to the subreddit model object after constructing the object we are calling the create subreddit method inside the subreddit service where we are making a post call to the create subreddit rest api and returning an observable inside the component we are subscribing to this observable response and when we receive a success response we are navigating to the list subreddits page and if we receive an error we are throwing an error using the throw error method from rxjs lastly we have the discard method which takes us back to the home page so here we are navigating to the list subreddits page but this route and the components do not exist yet let's fire up the terminal and create the components by typing ng gc subreddit slash list subreddits to create the components and html css files now again i'm going to take the help from the written tutorial and here i'm going to go to the section show all subreddits and copy the html and typescript code and paste them into the project so inside the list dot component.html file we are using an ng for directive to loop through all the subreddits which are stored inside the variable subreddits and for each subreddit we display the name and we have an anchor tag which has a router link with the value view subreddit followed by the subreddit name this route does not exist yet we will create it soon and inside the other column to the right side of the page we have the sidebar component now if i go to the list subreddits component we are calling the get all subreddits method of subreddit service inside the ngoninet of the component we are subscribing to the response and assigning the response to the subreddit object which is of type array of subreddit model if we receive an error response back from the get all subreddits call we throw an error using the throw error method of rxjs all right now let's register the route for slash list subreddits to the list subreddits component inside the approaching.module.ts and after that if you remember in our home page we have a separated sidebar component which contains a link to display all the subreddits let's go ahead and update that router link value now let's open the application and try to create a subreddit and as you can see we are navigated to the list subreddits page and we can also see the subreddits we have just created let's also test whether the navigation is working from the subreddit sidebar so yes it's working perfect our next task is to implement the functionality to create posts we have already created the components and the supporting source files in the first section of this episode before we start our implementation we need to install some dependencies to our application to create the post we need some kind of editor so for that let's use this editor called as tinymce with all these fancy controls and options we can integrate tinymce into our angular project by typing the below command npm install save tinymce angular this should install and add the tinymc angulardependency in the package.json file next we will enable tinymce in our project by adding the editor module to the appmodule.ts5 alright so before starting the implementation let's refer our swagger rest api documentation one more time to see what is the request payload we need to create a post so here under the post controller so here under the post controller under the create post section you can see the payload which takes the fields description post name subreddit name and url you can ignore the post id as this is auto generated so let's create these fields inside a class in the angular project i am going to create a new file under the create post folder called as create post payload and inside that i'm going to create a class which contains the fields post name subreddit name url and description all right now we need the html and css code for create post i'm going to again go to the written tutorial because i don't want to spend time writing the html and css code i think there is nothing special in that so we will just emphasize in the angular part so what we have here is in the html file is a form tag which contains the form group and ng submit directives inside the form tag we have the create post heading followed by the form control inputs for post name and url we also have a drop down list which contains all the subreddits in our application we need this because each post should be assigned to a subreddit and the interesting part here is the editor tag this i copied from the tinymc page if you go to the documentation here you can see all the steps required to install the editor in our application which we have followed before and lastly we have the buttons post and discard so now let's see what's inside the post component so we have declared and initialized the create post form variable of type form group inside the ngoninit method and inside the form group declaration we define all the fields which our form contains and we also added the validators to this form control next we are reading all the subreddit information as we have to display them in the drop down when creating the post after reading them from the subreddit service we are assigning the response to a subreddits variable next we have the create post method which first reads the form control values and creates the create post payload object once we have the necessary data we call the create post method inside the subreddit service which is making the http post call to the create post rest api this method is returning an observable so we subscribe to the response and once we receive a success response we navigate to the home page or else we throw an error using the throw error method from ngrx library lastly we have a discard post method which redirects us again to the home page now let's test our implementation i'm going to open the home page and click on the create post button on the sidebar section and i'm going to provide the necessary details here so you can see the cool tiny editor we installed looks something like this so i'm going to use this controls and provide some text and click on the post button and you can see we have navigated to the home page if you scroll all the way down you see the html code instead of seeing the text in the expected format this is because the tinymce produces html code as the output and we are saving this html code inside the dp under the description field first of all there is a security risk by storing the raw html inside the db but we will talk about it later but for now we have to change the way we are rendering this information inside the post style component so let's open up the post style component.html file and under the div section where we display the description i am going to change the interpolation to a inner html directive and pass the value post.description to it this will render our text as html and now we are able to see the text as we expect so in the last episode we developed the logic to create the pose in our application but we still don't have a way to drill down and read the post information let's create a component called as view post so i'm going to open the terminal and type ngc post slash view post to generate the view post component under the post folder so you want to display this component when the user clicks on read post button on the home page so first i am going to add a click event for the read post button in the post style.component.html file which calls the go to post method by taking the post id as input and inside the post style component we first injected the router class from at angular router package and added the method go to post where we have logic to navigate to the url now to make this work we have to define the route to view post component inside the approaching.module.ts file so i have added an entry inside the routes array where we are mapping the path viewpost to the viewpost component the next step is to write the html code for the viewpost component i am going to refer to the written tutorial here and copy the html and css code from there okay now let's see what we have in this viewpost component html file we are displaying the vote button component using the app vote button selector and passing the post object as input to the component we did not yet implement the voting functionality in angular so we will cover this in the next video which will be the final video of the series so moving ahead we have some sections where we are displaying the fields subreddit name username name and description of the post as we saw in the previous episodes our description of the post contains html code generated by the tinymc editor so to render the html we are passing the description to the inner html directive now if we looked into the viewpost component we injected the post service and activated route classes into the component and we are trading the post id which is passed in as a query parameter using the activatedroute.snapshot.params property i am going to access the query parameter id and the value is assigned to the post id variable in the next line we are calling the method post from the post service which takes the post id as input and inside this method we are making a http get call to our backend this method returns an observable of type post model so we are subscribing to this observable in our view component and assigning the response to the post variable the next part is to add the functionality for the users to submit comments i am going to refer to the written tutorial again to copy the html and css code okay the difference here is we added a section to display form to submit comments we named this form group as a comment form and we have an ng submit directory which is calling the post comment method inside the viewpost component we will have a look at this shortly and inside the form we have a text area with the form control name as text and submit button below the text area besides this form we have a section where we are looking through the comments and displaying each comment along with the username of the commenter now let's have a look at the view component and first of all we have declared and initialized the form group called comment form we also declared and initialized an object of type comment payload which contains the fields text post id username and duration these are the fields which are expected as part of the post comment api call so inside the post comment method we are first reading the value from the form control with name text and assigning the value to the text field inside the comment payload object after that we are calling the post comment method inside the comment service i created this service under the comment folder and injected the service to the view component if you go inside the comment service we need the http client class to make the backend calls so i injected this class into the service and after that there are two methods defined in this service the first one is post comment method and the second one is the get all comments for post method which takes in the post id as input and makes a get call to retrieve all the comments for a given post we are calling the get all comments for post method after receiving a success response back from post comment method call and once we receive a success response we are resetting the value inside the text area to allow a new comment whenever we try to reload the viewpost component we have to load the post information and the comment information from our backend for that reason in the ngoninet method i am calling these two methods get post by id and get comments for post before we go ahead and test our implementation let's have a look at a bug which we have in our token interceptor.ts file if you are following along with this tutorial from the beginning chances are that it's not so hard to replicate this bug in fact we have not one but two bugs let's have a look at them the first one is inside the intercept method where we are retrieving the token from the local storage and inside the add token method we are cloning this request and adding the authorization header we are cloning this request because the initial request object is immutable but we are not passing the clone request but the initial request as it is to the next dot handle method this is causing a 403 error because we are passing an invalid jwt and expired jwt to the back end the second one is inside the handle errors method if we try to make multiple http calls at the same time at that point of time the auth token is expired we will try to refresh the token multiple times in this case we added an if condition we allow the reference token request only if there isn't any existing reference token process going on so in our case the first request wins and request a refresh token but the second request will fail silently to fix this bug we will add an else condition and we will use the filter on the behavior subject until we receive a nonnull response then accept the first entry in the behavior subject using the take method and finally we will use the switch map method to take the new token and use it to make the request now let's go ahead and start our angular application using the ng serve command by going to the address localhost 4200 so you can see there is only one post in the database right now because there were some test data issues because of missing references of the foreign keys so i have just cleaned up all the posts in the database and tried to create recreate them from the ui i also suggest you to do the same so i'm going to click on the read post button and here you can see all the post information the comments which i've already created before so let's try to create one more comment and you can see all the comments are loaded successfully without the need to refresh the viewpost component now the next task is to display the username in the header section right now we are always displaying the login and sign up buttons so before we make any changes we have to install one library called ng bootstrap we will use the drop down menu in this library so let's install this library using the following command i'm going to reference an image here because i've already installed this library but you can first we ran first we are going to run the npm install save ng bootstrap command and after that i run the and after that we are going to run ng add angular localize command because there are some compatibility issues for the internationalization future between angular 9 and ng bootstrap library after running these commands we have to enable ng bootstrap in our application by adding the ngb module to the appmodule.ts file now we are ready to make the changes so i'm going to open the written tutorial and under the section displaying username in the header section go to the header component html and css files copy the code and paste it into the respective files so we basically updated the header component by adding a drop down from the ng bootstrap library we are displaying this drop down based on the value of ease logged in flag if the flag is true we are displaying the drop down and the options in the drop down are profile and log out so we have some functions defined through the click directive we will be implementing the go to profile we'll be implementing the go to user profile function in this video and we'll cover the logout in the next one the user is not logged in we are just displaying the login and signup buttons as we have before alright now let's open the header component.ts file and here we are assigning the value to ease logged in flag through the ease logged in method inside the alt service where we are retrieving the token from the local storage and we will be returning and we are returning a true or false value based on the availability of the token we have also defined the go to user profile method where we have the logic to navigate to the user profile page we don't have this component yet so let's create this component by typing the command ngc user profile in the terminal and once again i'm going to open the return tutorial and i'm going to go to the section displaying user profile and i'm going to copy the html code under the user profile component.html file and copy it inside the project so in this page we should display all the posts and comment information the user has submitted so we have some welcome text here along with the number of posts and comments submitted by the user we are using this we are using this app post style component here because we want to display a list of posts and lastly we are displaying all the comments which are posted by the user to use this post style component inside the user component we have to make a small refactoring in the previous episodes we had the logic to read post from backend inside the post style component now we have moved this logic away from this component so instead of making a backend call this this component receives this pose it should display as an input so as part of this refactoring i also changed the home component now we are reading all the posts inside the constructor and passing them as input to the post tile component we are doing the same thing also in our user profile component if we open the user profile component we are reading the username we are doing the same thing also in our user profile component we are reading the user name from the query params using the activated route class and we are calling the get all posts by user method to read all the posts by the username we are just making yet another http get called to the backend and inside the component we are subscribing to the response and assigning the response to the post variable so we also calculate the number of posts we received and assign it to the post length variable lastly we retrieve all the comments created by this user by making a get call to the backend the same thing applies also here we are subscribing to the observable and assigning the values to the comments and comment length variables so let's open the application and test the what you have implemented so now you can see a nice drop down to the right side and if we click on the profile button nothing happens because we did not update the routing module let's quickly because we did not update the routing module for the user profile path so let's quickly add the entry to the routes array for the path user profile now if you try again we can see the user profile page and here you can see this particular user have logged in has posted one time and commented three times you can also see the post and comment information in this page so all right before we conclude this video i'm going to point out two small changes have done to the back end the first one is inside the get post by user method inside the post controller i forgot to add the path variable annotation so we are going to add this path variable annotation and we are going to rename the input variable from username to name or else you will get an error when trying to call this api so the second one is inside the postmapper class for the post for the method map we have added an additional mapping for the field user so without this mappings if you want to try if we were creating a post it will not save the user information okay we have already created the vote button component in the previous video when refactoring our homepage we have the upward and downward icons and inside the html the click directive for these icons is calling the upvote post and download post methods but as of now we are not doing anything inside the components before starting the implementation we need to create the word service class where we can make backend calls to the vote api so inside the terminal i am going to type ng gs shared slash vote this will generate the vote service class under the vote folder which is inside the shared folder inside the class we are going to first inject the http client class and declare a method vote which makes a post call to a vote api if you open the swagger documentation we need two fields as part of the request payload vote type and post number i have already created a class called as word payload which contains these two fields and field vote type is an enum called as word type where the possible values are upward and downward back to the vote service the vote method takes the payload as an input and here as i said before we are making a post call to the backend now if we look inside the vote button component we have first injected the vote service our service post service and toaster service classes through the constructor we declared and initialized the vote payload object inside the constructor then we have upward post and downward post methods where we are setting the word type for the vote payload object and calling the votes method and this vote method is setting the value for the post id field which is coming as input from the parent components and after that we are calling the vote method of the word service class which returns us an observable and then we subscribe to this returned observable and in the case of a success response we are updating the word details like the vote count and also an indication whether this post is either uploaded or downloaded by the user the upward and downward fields are newly added to the post model this helps us to decide if a post is either uploaded or downloaded by the user if the user is not logged in then we obviously don't see any indication whether the post is supported or downloaded so we are receiving these fields from the backend so let's jump into intellij idea and inside the post response class you can see the two fields upward and downward these two fields are mapped inside the post mapper class under the map to tto method i've added two mappings for each field where we are calling the methods is upwarded and is downloaded which in turn calls the check would type method which finds the latest votes submitted by the given user and compares it to the vote type which is being passed in and we are doing this only if the user is logged in if not we just return false so the next task is to implement logout in our angular application implementing the logout on the front end is a simple task we just have to delete the stored jwt and refresh tokens along with the user information from the local storage after that we will make an api call to the backend to delete the refresh token so that it won't be possible to rotate the json web tokens we can quickly have a look at the swagger documentation so here all we need is a refresh request payload object which we can construct it on the fly so first let's go to the header component html5 where we are calling the logout method inside the click directive of the logo pattern we are just calling the logout method inside the earth service where we are making a post call to our backend this call returns a string as response which we are just logging to the console then we are clearing all the details which are stored in the local storage like the username authentication token refresh token and expiration time as we are in the service i would like to show you a small change added to the to the login method so here after storing the token and the user details in the local storage we are emitting two values from this class the first one is the boolean flag called logged in and the second one is a string called as username so these two output variables are actually used in the header component so you can see these two fields are marked with output decorator we are subscribing to these two fields inside the header component and whenever the user is logged in the earth service emits these values to the header component and we can see the user name and the dropdown information in the header section at the time okay the next task is to protect the secured routes in our angular application that means some of the routes in our application should only be accessible when the user is logged in in angular we have a concept called guards which tells the router whether to allow the navigation to a particular route or not so there are different types of guards but we will use the can activate guard in our scenario to generate a guard we can type the command ng g g auth auth which stands for ng generate guard with the name auth under the auth folder you will be prompted to select the kind of interface you would like to implement as i told before we are implementing a can activate card so you can select the can activate option and press enter now the guard should be created successfully inside the auth guard class i first injected the out service and router classes and inside the can activate method we are first checking if the user is locked in or not by calling the is logged in method from hot service if the user is logged in then we return a value true or else we redirect to the login page all right now the next step is to configure the guards in the app routing module so i am going to open the approaching module.es file and inside the routes array we are going to add the can activate property for the user profile create post and create subreddit components and as this property takes an array and we just have one single value we just have pass in the value auth guard okay we have implemented a lot so let's open our browser and start testing first i would like to check whether the logout is working or not so let's first open the developer console and under the application tab local storage make sure that we have the token and user details now open the application let's log out from the application and check the developer console again you can see that the values are not there anymore so that's good but if you check the home page you don't see any posts or subreddits inside the sidebar section this is because the end points which are supposed to expose this information are secured if the user is not logged in then we don't provide the token as part of the request and we don't get any response back so we have to exclude these two endpoints in our spring security configuration i am going to open intellij one more time and inside the configure method of the security config class let's add entries to permit the calls to the get all subreddit and get all post api notice that i specifically mentioned to permit only the get calls that that means spring will not try to authorize this calls for the token in this way even the visitors can see the post in our application now i'm going back to the visual studio code and here i'm going to show one last change i did to the token interceptor class inside the intercept method i added an if condition where we first check if we have a valid token and the local storage or not if yes then we add this token to the authorization header or else we just send the request without any headers on it in this way we prevent unnecessary errors in the back end because in the previous way we used to always add the authorization header even though the jwt is null or undefined this fix brings us a bit of consistency to our authorization process so now let's go back to the application and now you can see we are able to see the post and subreddits in the home page even though i'm not logged in now let's try to log in and if i try to click on the upward icon you can see the green color and if you try to upload again you will see the error message as a toaster notification saying that we have already uploaded this post so the only possible action is download and if you try to downward again i again see an error message with a different message now that you cannot download the post you can also upload and download from the post page so let's click on the read post button so we can see that the color indication is also visible in this page now let's try to upload and the arrow turns green again so all right that brings us to the end of the episode and also the end of this tutorial series it was very exciting to produce his videos and i appreciate all the encouragement from you guys so thank you very much for that