Thomas petrol is a popular instructor and excellent developer. In this course, he teaches how to build a live streaming flutter app using a Gora thanks to agora for providing a grant that made this course possible. Hello, everyone. My name is Titus Petra, I am a YouTuber, Google Developer expert for flutter and Dart, and also developer evangelist at agora. And this course will be covering a live streaming application where you can have multiple live stream feeds from multiple people coming into a director application, the director has control of whether they're muted, whether their videos on and whether they're on the stage at a lobby, and then for those people that are in the stage, their video will get transcoded together and sent out to any streaming platform that you want. I say this course is an intermediate level course. So if you're completely new to flutter, I recommend taking a look at some of the other Free Code Camp courses. I know they have some great ones for beginners. And if you're completely new to Gora, I'll leave a couple of resources in the description. So you could see how to implement simple video calling features with it. I will also be using ver pot for state management. I'll be explaining a little bit about what state management is and how we're going to use it here. But if you want to dive a little bit deeper, I'll leave some resources in the description too. And lastly, I'd like to thank Freako camp for giving me this opportunity. And let's get into the course who got a little cold in your head to put on a sweatshirt. But like I said, this app is a little bit more complicated. So I wanted to break it down to visually, we're going to start off with a homescreen. On the home screen, we're going to have to enter two fields. One is the name of the room. The other one is your name. And as me two buttons, because technically, we're going to have basically two apps within one app, we're going to have a participant view, but we're also going to have a director view. So the first view is going to be the participant view. Now this view should look like any other normal video call you can have, you'll have an End Call button, a mute button, and a switch camera button. Within the participant view, you're basically saying you're going to be a participant within the video call that a director controls. So what you should see is basically what's going to be going out to the public, the people that are going to be going out to the livestream platforms, they're going to be the people that are on the stage, splitting the stage in this next part. So this is the basics of the director layout. So the director basically controls how the whole video calls going, and who actually gets pushed out to the live stream and who doesn't. So you'll have first the lobby here. So when you first join as a participant, you'll be put into the lobby, then the director will have the ability to bring you into the stage. And then you will be basically live. And the director will also have the ability to bring you back to the lobby if you misbehave, or something like that. At the top here, we'll put basically what streaming platforms you want to go to. So let's see YouTube and Twitch. If you haven't heard that, at the bottom, we'll have a menu for stuff like End call and start and stop live stream. So as you can see, there's a lot of stuff going on in this director application. That's where state management comes in. Not to be perfectly clear, you don't need state management here, you could definitely make this app work without it. But in my opinion, adding some sort of state management solution kind of cleans up the code a little bit and makes it easier to work with. So what is state management. So if we take a look at this application, within the director part of it, we have a lot of different states. So we have stuff like who are the people on the stage, people in the lobby, what platforms we're streaming to whether the live stream is live or not, and things like that. So depending on how big your application is, and how much of the state objects you're gonna be using on different pages, you might want to split it up into multiple state objects. So you could have something like a state object for the people on the stage, a state object for people in the lobby, state object for what type of platforms you want to go to, and a state object for whether the stream is started or not. But for this, we're going to keep things simple, we're just going to have one state object for everything director related. So something like director, state. Now within here, we'll have active users lobby users is live variable to tell us if we're live or not. And which destinations we want to stream to. So that is the state that we're going to be managing for this application and the whole director page. So this whole page will be reactive to whenever this state changes. So anytime you update this, the our director screen will react and update the UI to match whatever needs to match. And of course, when you click buttons, so let's say there's a plus button to add a destination here. Whenever we click, it will go to a function that changes and updates this destination, which updates the state which updates the screen. And thus, we have a nice simple flow for how things get updated within our application. Hopefully that makes sense. And for the participant app, since it's simple enough, there's not too many things to manage. We're not even going to use any state management for that. So how do we choose the gore for this project? Well, first I worked there, so I'm a little bit biased. But also it makes building something like this a little bit easier than other competitors, and also has a very powerful backend. So you know, you'll be getting quality and reliability and all that stuff. Now that your platform will be taken care of all the video feeds are coming in and putting them together sending them out to live streams, but also using signaling between the director and all the participants, whether they're muted or whether they should be in the lobby or the stage and stuff like that. Alright, enough explaining things. Let's show how this is actually built. So we're gonna start off with the old flutter create command. And we're gonna call this app streamer. Demo. Okay, jump into the directory and open it in VS code. And here we have our basic flutter app. And there we go, we're running the basic flutter demo application. And before moving forward want to add in all the dependencies that we need. So he said, the main thing is going to be running on his agora, we go to the package manager for Dart, we type in agora, we will see three agora plugins. Now we're going to be using the gore RPC engine and the Agora RTM. But I want to show you what a gore UI kit does, too, because it's really quick and simple. So we have added a gore UI kit here. So this is used if you want to set up a simple video call application. Now the plan is to expand this to allow all the complex features to So technically, what we'll be building here should also be possible with UI kit in the future as well. So that's why I want to show it to you a little bit. So in order to add UI kit to your project, you only really need to add three lines of code, we need to create an agora client, I need to pass in a gore connection data and enabled permissions. So we're gonna need two permissions for a video call, we're gonna need a camera permission, and a microphone permission. Now that said, your connection data is a class that we need to add. And you'll see you'll need app ID and challenging. So what the heck is that? Well, if you go to console dot agora, that IO, you'll see a screen like this, now that have a list of all your projects, you can create a new project. But for us, we're just going to be using this project that already have. But you should see something very similar. Only creator, you might see a screen like this. And you'll have a thing called App ID right here. So this is basically creating an a gore app for you. And you'll be able to use your services and you'll have 10,000 free minutes of the services every single month. So we're going to be copying this app ID and bringing it into our code. North not be showing you my app ID this whole time, I'm gonna have a new file, and I'm gonna call it app ID. And here on define const, app ID equals and then insert hap ID here. Name this file with lowercase and underscores, that's fine. But then you're going to want to insert your app ID here, but I'm going to put in my number. So there we go. Mine's in there. And we can type in app ID here. And it will import our app ID file. And we can use that constant variable here. For our channel, we're just going to call it test for now that we want to initialize that client. And then we're done. So all the Gore said is this initialized, and we will just want to display a stack of widgets. One of them is going to be the gore video viewer, which will show you the actual video, you pass in the client. And then we have a Gora video buttons. So we could have an called button and stuff like that. And that's a full video call application. Before I can demonstrate though there are some permissions we need to add. So on the Android level build gradle, we need to add that at the end of the repositories. So we can add that in here. Then Add a Device Permissions, which we already did Android manifest file, add this required device permission to the file. So there we go. Now this video call should be working. And we should be able to launch it and showcase it. Alright, there was apparently a bug that took a little while to figure out but there was either a new Android version or new permissions handler version that was released. So you want to make sure you say your target SDK version and your compile SDK version, both to be 31 by default, and flutter projects as 30. And something doesn't like that with permission. So with 31, everything works. And you just see an app like this will ask for your permissions. Let's give it permissions to do all that. And this little image is something we'll see throughout the video and is the little fake camera emulator from Android. Let me join another device just to prove to you that this works. And I forgot since mine is an iOS device, we're going to have to add these two things to the info dot P list file. So iOS runner info dot P list and add these two keys in here. Now save that. This time, hopefully it will work. And there we go. Here I am. So that was the core UI kit. And while you can do a lot of things with the core UI kit, you can actually do a lot of customizations. There's a couple small things you can't do right now that we're working on adding in. So we're going to need to use a core API called a gore RTC engine. So the core RTC engine handles all the video and audio related stuff. But then you also need to add a gore RTM, which is real time messaging. RTC stands for real time communication. RTM stands for real time messaging. And you can imagine the messaging is to send signals between the peoples so we can have control of everybody within the call. So those are going to be the packages driving the core a core logic. Then we're going to need the advert pod. We're going to use flutter River pod, that's for the state management. And then we're going to add a couple little small things like shared preferences, we're going to need this because we're going to have to have a UID of a person that we're going to generate randomly, and we're going to store it. So we don't have to create a new one every single session. There's other ways to get you IDs, for example, from Firebase, nah, stuff, but we're gonna do a simple route and a shared preferences just makes it easier for you to store things locally. And then we're gonna have a couple neat little UI packages, one's going to be called App, pop up menu, just like it sounds, it's just a little pop up menu, they're gonna have a modal bottom sheet, which is a nice little thing that comes up from the bottom, so you can add some information in there. And then last one, circular menu. So really, there's three main ones driving the actual logic behind everything that happens, then shared preferences just to store things locally, easily. And then three UI packages, its UI elements that we could definitely make ourselves bow, why not use the things we have out there. Alright, so everything is set up and ready to go. Now I have a way that I organize projects, it's similar to the MEU architecture approach. And it's a nice way to keep things organized within your app, so that you can keep building up and building up on it. So I have a folder called controllers, that's not a folder, I have a folder called models, pages utils. And sometimes they even have a folder for widgets. But in this case, we're not going to need them. So the app ID goes within the utils. We don't need to look at that anymore. So utils, as you could see is utilities, stuff they use throughout the app. But it's not really a feature or anything like that. So for example, I put my colors in here, different colors that I have for the app. And I can't even think of many other examples of things I put in here. But it's nice to keep those organized. Then pages like it sounds is a different pages of the application. Models are the data objects. So the different types of data that you hold within the application. And then controllers are the main things that drive the whole application. So if you remember how we're using river pot for state management, and then we have that director state that we talked about, so that director state is going to be within the controller. So you can actually add the file so we can envision it even better. So we will have a director, controller. And here we'll have the director model, which is the big object that we're going to be using to control the whole application, then we will have a simple stream dot Dart, this is going to have the information for where we're streaming to, and a user dot Dart for all the people that are going to be within the call and any data that we need to hold for them. Then pages, there's only three pages here, we will have the homepage, we'll have the director page, and then we'll have the participant page. Okay, so everything is set up, we're ready to start adding some code in here. So we can remove this homepage class, remove all this. And we'll just call it home, we can leave all that as is remove the title, we don't really need that. Now, since we're using river pirate want to wrap this whole material app with a provider scope. So there we go. This provider scope basically a widget that stores state, we're storing state for the whole application, so wrapping it around this whole material app. Now this homeless, we have a problem. But we'll add a stateful widget here called home. Now we can import that. And I think we can even make it custom. There we go. So we're pretty much done with this whole main page, we won't be touching it much more. Now the home screen, if we take a look at our design, we want the home screen to look something like this. Whether you're a participant or director, it's actually going to be a little bit different. Because one, we're going to need a username. And then we also need a channel name. So instead of adding channel name here, we're just going to put it in the first screen. So in the channel name, username and then two buttons. So first, we need to create a scaffold. And then in the body, we're going to have a center widget in which we will have a column. Within this column, let's center everything. And that children will be two text fields and two buttons. So the first text button will take us to participant. And the second text button will take us to director. And actually let's go and set both of those up. So for the child of the participant, we're going to have a row with the word participant and the little icon icons and be a live TV because you're going to be pretty much joining a live broadcast. And the child for the director will be the word director and a little cut thing so you know you know that you're directing something or you're in charge of something. So let's set up our participants screens as well. So we have a stateful widget called participant and then in here we will just do a simple scaffold with a body center Text, participant. And let's just copy the same thing to director just to make sure everything works. By the way, you can click Ctrl, D to do what I did here. And I just changed all the wording to director. Now in order to get that next patient is to navigator dot push and then send our page route for the specific widget that we want to push on. So we want to push the participant widget here. And then do the same thing for the director, except here, we will push the director page. Alright, so now we can actually run this to make sure at least navigation within the app works. Alright, we ran into a little bug that then let us run. So in this Mavenlink, I had WWW dot jetpack to IO, if you have this, or I accidentally led you to have this make sure you remove that. And then your coaching run. So we have an app that looks like this. And I think if we click into it will be taken to the director screen. And if we click participant will be taken to the participant screen. So our whole flow for the application is working. Now we just need to make this look a little bit nicer. So let's create another folder in here we'll call it assets, this assets folder, we will put all our images and things like that. So let's put it out into the main directory. And there's the assets. In here we'll have the strimmer, you can't really see because it's a black background. But you just got to trust me that this is the this is the right logo, not to actually to actually add it into our app, we have to go to the postback diamo. And here they have a commented out section that shows you how to add assets, but we're just gonna add ours in, and it's in the directory called assets. So now it's ready to use. So at the very top, we'll have image dot asset. And our path is assets slash streamer dot png, that a little space between this and the next section, we'll give it a height of only five as some text like multi streaming with friends. And these can be constants, because they were not going to change, add another size box to give some space in between the titles and the text fields will have a height of 40 here. And then for text fields, we'll do something a little more special. So first things first, we need some controllers up here. So we'll have a channel name controller and a user name controller. To format this to look a little nicer, we're going to wrap it in a container, I'm going to give it a specific width of media query width. So this is the width of our screen, and we're going to multiply it by point eight, five. So it's going to take up 85% of the screen. This will make it more responsive for the different apps that we have. Now within a text field, we'll have a controller this will be the username. And then some decoration. And this decoration is just going to give it a nice little border and have the text username in there. So nothing too special. Now we want to size box again, of height, eight here, for example. And I'll hit copy paste the same thing here. And notice a convert to size box because we're not really using much else within here. We're not using many of the container things. So size box works here as well. And here we will have the channel name and change this to channel name. Alright, let's run that. So there we go. It looks looks pretty nice. Now, now there's one more thing we need to do is we need to add properties that we pass in here. So we have a channel name and username, but we need to actually pass it into these specific widgets. So there's the participant screen, we're going to need the channel and the username here. And then for the director screen, we actually don't even need the username, we only need the channel name, but director won't actually be within the call. So we don't need to see his username anywhere. But we run into issues here because we're not passing the specific things we need. Just simple to fix channel name, we take the controller we have, and we get the text from it. Same thing with username, we take the user controller and take the text from it. So this is taking the controller that we have set up for each of the text fields. So when you're typing, there's a nice little thing in the background that has all the text for you and we're retrieving the text value from it. And then we should have one more problem at the director where we do something very similar town name, we take the channel name controller and retrieve the text. So now each of these screens should have the correct values that we need, and we should be good to go. Alright, so for our next part, we're gonna start implementing the participants are things the participant is going to be a lot simpler than indirect or so. So hopefully it'll be a good transition from implementing something a little bit simpler. And then we'll step it up another level. By adding it into the director, that participant still has a lot of things that we need to take care of. And, and since this is a more complicated app, there's going to be a lot of functions that the participant has to execute on as well. But, but we'll take it slow. And hopefully by the end, you'll have a good understanding of how all these stuff works together. So the biggest thing we'll be emphasizing here is how agora RTM and agora RTC work together. So if you remember, our TM is real time messaging. So it's signaling is how we'll be able to communicate information between people. So send like mute requests and all that type of stuff. And then I go to RTC will be the actual video call happening. So on the participants are things we will need RTC engine, which is going to be handling the actual video call. And then for RTM, we will have a client and then we also have a channel. So within the core RTC engine or Gore RTC package, this client and channel logic is within this RTC engine thing just made a little simpler to use. So you could add video call a little bit easier. So the gore RTM, everything's broken down to exactly how things work behind the scenes. So as I said, the gore RTC engine will be the actual video call, they'll go RTM client is you logging into a gore RTM itself. And then a gore RTM channel is joining that channel. Actually, let's go and initialize this, and you'll see exactly what I mean. So here we're creating the actual engine. And then if we go to join channel, you'll see you have to give a token, which will give as No. But then we need to pass in a channel name. So this channel that you pass in here does the actual initialisation very similar to how a RTM does this initialization for this channel. We're actually not going to be doing this yet, but I just wanted to show it to you. So we created the instance of our engine. Now let's do same thing with our client. And for both of these, you notice we pass in our app ID that we created for gore. So now we have a connection with the engine and the client to our agora project. So by default, a core RTC starts with only audio, so we want to make sure we enable video so we could actually see the video streams, and then set this person's channel profile to live broadcasting. There's three types of channel profiles, there's live broadcasting, a normal video call, and a gaming one. So we're going to be using a live broadcasting. And you can either be a broadcaster or an audience member, they will be a broadcaster in this case. Alright, so the basics are initialized, and we're ready to move forward with it. The next thing we want to set is our event handlers. So these event handlers get triggered whenever some sort of event happens within our application. And there's a lot of them, we're going to be implementing a lot more of them. But for now, let's just do one to showcase how it works. So we have joined channel success, you can hover over this, and our occurs when the local user joins the specified channel. So we'll do here will actually have a list of integers with the users that are within this call. Now, whenever this person joins, we'll have users that add I'll add their UID to this list of users. I actually want to set state so we can update the UI with this specific user shown. This logic isn't Howard's gonna end with because we're we don't want to just display the current user that Johnny wants to display any of the active people within the stage of the director application. But we'll handle that a little bit later. So okay, here we set up the callbacks for the RTC engine. Now if you remember, we have an RTC engine, and then we have our TM client and our TM channel. So those have callbacks as well. So the RTM client is your connection to the actual Gore RTM thing. So there's like a personal connection to the Agora system. And our team channel is the channel that you join. So this is like everybody in the channel will be on the same channel. But you will be the only one on that specific client. Hello, editor, Titus here. So I messed up my wording a little bit there. He won't be the only one on the client, but you will have an individual connection to the client. So this client has callbacks, like on message received. And this callback has a message and appear ID so we go to the definition of this. So this callback occurs when the local users receives a peer to peer message. So when you get a specific message from a separate user to you directly, this callback will execute and we'll just print out private message from this user with the message of this. So I don't think we'll actually be needing to use this call But I thought we would include it because I think it helps you understand what a client and what a channel is. But there's one that we will definitely be using as on connection state changed. So this one will give us two variables will give us the current state. And the reason. So the reason is why this connection state changed, and the state gives you what's the current state. And you notice these are integers. And we're gonna figure out what those integers mean, by going to developers on a gourd the IO go to documentation, and documentation, go to API reference. And we're working with the real time messaging. And currently, there's no documentation for the flutter SDK for this. But for now, I don't know it's coming soon. But it has the same exact things as the Android SDK. So we can get status and error codes and go to connection state. And then there's connection change reasons. So connection state, we have connection state aborted is equal to five. So if our state is equal to five, which means this connection state was aborted, you want to leave the channel, want to log out the client. And we also want to destroy the client. We could even add apprenticing logged out. So whenever our connection state is aborted, we want to just basically clear out everything that we had going on. Now we can even go to connection change reasons, we'll get see these numbers and elegant figure out if you want to do something specific for whatever reason occurred, we can do that. But we're just going to keep it simple for this example. Okay, so those were the callbacks for the RTM client. Now the last one is a callbacks for the RTM channel. So these are channel one messages. This is what we're actually going to be using to mute people and all that stuff, because we want to send a message to every art everybody in the channel, and then the person within that channel checks if they're supposed to mute themselves. And then they will go ahead and mute if their UID is passed to this channel message. So first, we're going to use a simple example of member joins. So you can see these printouts happen whenever someone joins a channel, that's also have one for member left just so we can have all this information. And the last and most important one will be will be called on message received, where we'll get a message from the channel and they'll tell us which member actually sent this channel message. So you notice these callbacks are named exactly the same. So we have on message received here, and our message seed here. But remember, this is for the client, which means you're sending a specific private message. And this is a channel wide message. So this is like a public message to everybody within the channel. And again, the documentation it says occurs when receiving a channel message. We're going to implement this later. But for now, we can add another print statement here, that just tells us the public message. Alright, so there we go. I know this might seem a little complicated. But once you actually understand what's going on here, hopefully it's not too bad. So the last thing we have the callbacks declared, We have everything initialized, there's only one thing left to do on essentially join all these channels. So first things first, we actually need to login with the client to agora. And here's where we run into the next problem. So we need to give a user ID to this client. Now there is a way around this where you don't have to use a user ID. But for this application, we actually need to because we're going to be using RTC and RTM. And they need to have matching user IDs. Technically, the user IDs don't have to match. But you have to be able to connect an RTM ID and an RTC ID. Since we're going to be using these UID to control all the users, we need to figure out a method to create these IDs. And to do that, we're actually going to pass in a UID as well here. And then down here, we could do widget that UID. And it actually needs to be a string. But we pass in as an integer for a specific reason that you'll see real soon. So then we create our channel. And you remember, we passed in at the top the channel name from that text field, we got do that by client create channel, we get the channel name from the text, we passed it. But we'll probably notice something here. We're creating the channel. But we're assigning callbacks on the channel here. That doesn't really make sense. So we want to move this above the channel callbacks. To be honest, we could probably move it all the way up here just keep all the callbacks together. But, but this works just fine too. So next step is take that channel and we want to join. So we have the RTM part completely figured out. We logged in the client, we created the channel and we joined the channel. Now for the RTC. We have a very similar approach. We have the RTC engine, but all we have to do here is just join channel. And it does all of this stuff for us. And actually define the engine as a late variable. So we don't need a question mark here. By the way, if I went over that too fast, this late variable is with flutter 2.0 means we're going to initialize this before we use it. And we know that for a fact because we're doing it in a net state. we're initializing it up here and we will be using it down here. So we'll For sure be initialized. Again, here, we're not going to be using a token, channel name will be the same channel name, optional info, we'll put no. And optional UID, we actually need it now. Because we wanted to have a matching UID to our RTM client. So that's why we need that UID. Okay, so the initialization, everything should be done here. I say UI isn't built yet. But I think that's the less complicated part. So I wanted to get this out of the way. Now I know one thing we're missing is this UID. So let's go back to the home and figure out a good way to do this. So we're going to implement the UID here just to keep things a little less cluttered. And we're going to do that in a very simple way. If this is a real application, I'm not sure if that's the best way to do it, it probably wants to have some sort of authentication service like Firebase or something like that, to give you a UID, they keep track within a database. But where's it going to create something simple. So during the initialization, we're going to get user UID. And if you remember, we added a package called Shared Preferences. So this shared preferences just store something locally. So the first time we run this will generate a UID. And then we'll just store it locally, and reuse that same UID that we stored locally, for any future video calls a function called Get User ID. And then we need to import shared preferences. So this get instance, loads and parses the preferences from this app from the disk. So all we have to do is try to retrieve that local UID. And we'll have two scenarios, we'll either retrieve an actual stored UID. So that means we don't get a no value back. In which case, we will set our UID right here to the stored UID. Or we haven't created one yet, and then we will create it. But this should only happen once. Now I won't type this whole algorithm out. But let me explain it. So get the current date and time in milliseconds since epoch, how do you pronounce it I don't know. But it should give this exact time and anytime further in the future won't be the same number. So this number is a little too long, we need to have nine digits for Gore to work. So we take three digits from the front, which are the numbers least likely to change, and we set those nine digits to the UID. Once again, that should only happen once, and then we should be good. So now we can pass the UID to this participant. And finally, the back end of our participant side of things should be done. Now time to serve the front end. Alright, so we have the UID. In here. Now, the only things that was left is actually updating the UI. Actually, there's a couple more things left, we have to add some more handlers here. So for this, we're gonna have to do a little bit of logic here to send the users the current users information. And when this person leaves, we want to clear all the users that we're seeing to then also on message received, this will be a big part of the application. So we'll have to implement this. But for now, let's just focus on the UI, get this looking right. And then we will be able to see our video call with just this current user, we can actually add this lead channel handler in here. So whenever we click Add, call or leave the channel, we clear all the users in there too. And now we can move this to do inside the join channel success and rename it to add join channel logic. Alright, now let's move on to the UI. So we're gonna have a scaffold with a center, and then a stack of widgets. Two widgets we'll have here is a broadcast view, and a toolbar. So broadcast, you will be the actual video feed, we'll see. And then layering on top of it, we'll have a little toolbar so we can end the call and things like that. So for the broadcast view, we'll have we'll have a child of expanded because we wanted to fill up the whole screen. And then in here, we will have a an RTC local view and a surface view of that local view. But we need to import that can do that right under the RTC engine. So keep the remote view in here because we'll need it. Let's ignore that prefix because I don't know I think it looks a little bit nicer this we can of course, follow the recommended library prefix if you want but we'll keep it like this for now. So on this tastes are local a gore view and makes makes a view out of it pretty much. And apparently we don't even need the container how for the toolbar, I feel like it's easier just to show it all to you at the end instead of typing it all out piece by piece. So we will have four buttons. You'll see a lot of errors right now because we haven't implemented anything else because I wanted to take a step by step but we'll have four buttons. Each one of them will do some symbols. So this one will toggle your mute this one on the call. This one will disable your video and then this one will switch your camera. So each one of them has a function and execute and some of them will need to hold a state actually. So for this one, this button, it will look different depending if you're currently muted or if you're not muted. Same thing with the video disabled. So let's add those two states in here and they We'll start out as false. So you're not muted in this case and your videos not disabled. And now to actually implement these functions. So first we have the on Toggle mute function. And this one, we will just set the state of that muted variable to not be muted. So that just changed the state locally. But now we need to change that state within the actual video call. So we do engine dot mute local audio stream aways, and we just set it to the variable whether it's mute or not. So this will work for both cases, whether we mute or unmute, we'll have something very similar for on Toggle video disabled. So this is for the button that turns everybody off and on. Sort of mute local audio stream will have mute local video stream as sort of a muted variable, we will have the video disabled variable. So almost exactly the same change the camera is even easier. You have on switch camera. Here, we just call the engine and everything will happen magically. And then finally, the last one is on call end, where we need to pass in the the build context. And all we will do here is navigator that pop the context. So we go back to the previous screen, they might say that doesn't really end the call that just jumps you out of the screen. But we're going to handle that in a pretty nice way where we will add a Dispose method here. So here we'll basically clean up this whole video call and whole RTM connection so that we have a fresh slate whenever we go back into it. So first things first, we want to leave the channel for the video call hash. Before we can do that we can clear the users that we have. So clear this local variable of users that we have, that will leave the video call channel, and we can destroy that video call engine overall, then this is the RTM channel, we can leave this channel as well then log out of the client, this is the RTM client again, and then destroy the RTM client as well. So we take care of the local state, we clear it will leave the channel and destroy the video call. Then we leave the RTM channel, log out of the client and destroy the client as well. And there we go. So that so that's a nice way to handle all that and call stuff because whenever you leave, even if you click the back button, it will all execute this and call logic. So now we should be actually able to run this project, how it will just see the participant. And when you click the participant button, you'll be jumping in a call with just yourself. And we should be able to see that person that says we're running it on Android, the way it works is they have like a emulator camera, which is just this little pixelated image that they showed that pretends like there's a camera there. Well, we ran into some issues, I tried to debug it a little bit. So if there's no users there, I put out so that shows no users on the screen. But if we try to join, you'll see no users at first, then the user joins, but it's just a black screen. And when we leave, we get an exception called. Now this is because we missed a very important step, we need another package called permissions handler. Now at this package, we'll be able to ask for permissions to the camera and to the microphone. And you can't really have a video call without permissions to that. So that was what we were missing. So we're going to need two permissions, we need permissions to the camera. And we need permission to the microphone. And we need to request both those. So this is for the participant you and we need to do the same thing for the director view. Actually, I'm not sure if it's necessary for the director. But if you want to add some functionality where you could bring the director in as well, then you definitely need this. So now let's try to run it one more time. Alright, so username is Titus show name. What is called tighter skin join as a participant law to allow while using an app. And we want to allow while using this app. So we have no users the beginning. And then we get this little Android emulator. Beautiful. Now we should be able to mute this emulator. And you'll see the state changes here should be able to turn the camera off. And I think this doesn't work because it is an emulator. So there's no camera to really turn off. And we can switch camera because that works. There's like the back camera of the emulator. And then we can of course end the call and they'll jump us back here where everything gets destroyed. Sorry, that's the basic part of this application. Hopefully you understood all because it's only gonna get more complicated from here. Or actually maybe it's not that much more complicated. But there's definitely more pieces being added on to what we already have here. So if you understood this participant section, this is, I think, the most complicated part of this whole course, the rest, we're just gonna be adding on more stuff and making it all work together nicely. Okay, so you got the participant mostly handled. Now it's time to start with the director app. wherein I come back to the participants. Once we have the active users and the people, the stage users all set up so that we can send them over here and we display a different view. But now if you remember the director application, so first, we want to set up this director state. This is going to be our state object that the director part of the application responds to whenever changes. And here, we're going to have the active users, lab users and then some other little things. But let's focus on these active and lab users first. So this active users is the one thing that we're going to have to go back to the participant side of things, because we want to not display just yourself, but we want to display the active users within the actual call. So let's set up our state, we need to first create our director model. So this is the actual data piece that we will be tracking. This is this specific state. So this is what types of data we're going to be tracking. And we'll have our PI create an instance of this data and use that instance as our state object for the application. So we will have a class called director model, I realized my file naming isn't the most consistent for these I just have stream. And this one is Director model. But I think it just made sense in my mind, because we have a page director, we don't want to have a model director and controller director too. So just to differentiate this a little bit from the director page. So within the director model, we'll take a lot of things we had in the participants side of things. So remember, when needed an RTC engine, linear a client on either channel, so we will need those same exact things within our director. And for now, we're just going to have three more things in here. And that is a set of active users, a set of lab users and local user. So sets are pretty much lists, but you can only have one occurrence within that list. So we're going to have a list of active users, our list of lab users, and then the local user, which is the director. And here we could add a constructor. So we start off with an empty set of both users. And then we will add a copy with method. So I do this using an extension called Dark data class generator. And they do Command period, and you can generate a copy with class. So this will allow you to change one thing within the object and still have the object. So let's say you added a lab user to the active user, you can copy with the instantiation of this director model that you have, except add a value to active user and remove one from here, and then you'll have a new state object. And before we go forward, we're actually going to change something up a bit. So I'm going to create a user class as well. So this user class will be called a gore user. type of data will need here is a UID. Whether we are muted or not. Whether the video is disabled, then a name for the user and the background color that isn't too important, but it makes it look a little bit nicer. And I'll show you later. Again, we need to create a constructor for this. Answer. Same way as we did before, we will create a copy with class. So if the user goes from muted to unmuted, we can change this one variable and have an object with the new state. Now go back to this director model, we can actually change all these ants to be a Gora users. Now we're ready to go. One more thing. Let's jump back in here. So we have this list of users, we actually want it to be a list of Gaura users. Instead of just adding the UID, we will add an A Gora user with UID of UID. So we can keep things consistent throughout the app. Alright, next thing is setting up the controller. So this is the workhorse of the application the behind the scenes state manager of the app, we'll be using ver pod like I said, if you're not familiar with VO pod and state notifiers. Specifically, there's some tutorials in the description that are recommended take a look. But a state notifier pretty much holds this state. You can create functions in there that update it, that we call those functions through this director screen. So we call those functions they update the state that says it's a state notifier it will notify whoever is listening to update their current UI or whatever it is they need to update because the state has changed. So that's the gist of a state notifier. So to use a state notifier you need to create a state notifier provider and we're going to go one step further and auto dispose it says auto dispose basically whenever we stop using this provider it will dispose itself. Now within here we need to give the type of what our state notifier is going to be and also what kind of state We'll be managing. So let's create our state notifier, we will have a director controller that extends state notifier. And the state that we will be managing is called a director model. Now there's this reader that you will see us passing in this reader is super important. So this allows you to read the state of anything within the provider scope. So any controllers that you have within the provider scope, and if you forget what the provider scope is, it's this thing that we surround the whole application with. So anything within this has access to that read, are able to access any other controller that's within our app pretty much. And during the first demo, I used another provider somewhere else, but in this case, we might not even use it. So in here, we need the type of our state notifier. So we can just actually copy this, paste here. And the second thing we need is that the type of the state we're holding as director model, then all we need to do here is return this director, controller, with our reader. All right, there we go. So our state is all set up. Now, we won't be doing anything right now with the state. But just know it's there. And we're ready to work with it whenever we need to. But the thing we're going to do now is actually set up our director screen before any of this. So to do that, we're going to just take the scaffold and wrap the whole thing with a consumer widget. Now, this is consumer, which has a requirement argument of builder. And we'll take this scaffold and return it just like that. So what is this consumer to explain the consumer, I went to the documentation, you can find all this through the river pod dot dev website. And the reading about providers and there's a consumer over here. And what they say about consumers is that it can be used to listen to providers inside a stateful widget, or to rebuild as few widgets as possible when the provider updates. So this is the thing that actually listens to the changes within our provider, in this case, a state notifier provider, and updates our UI, to look how we want it to look based on the current state. So in here, you will see this watch thing, we will use this watch to look for the director controller, dot notifier. So let me type one more thing out and explain these as well. So we have the director, Mark model, which will be our director data. And we will watch director controller. Okay, so what's going on here. So when we just watch our director controller directly, we we get this director model. So we get the current data within that provider. When we do director controller dot notifier, we get the director controller. So we get this first part. And if you see if we actually hover over the notifier, we get the director controller here. So the structure controller will give us access to all the functions or need to update our data. And this data will give us the current data that we need. So just as a quick example, we might do director notifier, dot new user, or something like that. But then we'll have a text widget that is tracking the director data, active users element at one muted. So this is a live example. But pretty much, we have one thing that will do the actual muting of a specific user. But then when we get that user, maybe user one out of the active users, we can read it state from the director data. Okay, so now everything's ready to go. And now time to implement all these features. So we're going to start off with the initialization and pretty much them joining the call, want to initialize this video call and actually join the call from the director point of view. Now it won't be showing the director camera or anything, but we still want him to be within the call so you can control everybody. So the two main functions are going to be joint call and then also leave call. Now that joint call is going to be a little bit more complicated, but leave call if we go back to the participant screen is going to be the same exact way as we did here. Except this time, we don't need to clear any users because we're holding the state within this director controller. You notice we get some errors here because we don't have a private variable of engine declared. But remember, we have a state of director model and the director model has engine client and channels. So we can do is we can create a cursor like this and then just type out state DOT engine and everything will work but we'll get this because in this case the engine isn't delete variable. It's actually something that we're will have to make nullable due to The way this whole directory controller setup. So that's how we're going to leave the call. Now to initialize it, we're going to break it up a little bit, we're going to have a function called initialize, which will be a local function that does all the initialization. Summary, the two main things is we need an engine and a client. Same way we did here want to initialize the Gora, first thing to do was create the engine in the client. If you remember, we created the channel a little bit lower in the whole process. And that's exactly how we're going to do it here. Actually, to make it easier on ourselves, we could literally just copy paste this here. But we're declaring these here. So we need to set them or TC engine to that, and then import this as well. And also import a core RTM client and import app ID. Now initialize it, but they're initialized into local variables want to actually add this to the state. So since this is a state notifier provider every single time, we want to update the state, we have to set it with a new state variable so so we're not amending it, use a change notifier for that, or a state notifier, we're setting a completely new thing. Of course, for this initial time, that obviously makes sense since we're creating an object for the first time. But this is a key point to remember about state notifier and say notifiers providers is that you're going to have to update the state every time and reset it to that state variable. And that's why we implemented that copy with function here. Because we could take all the previous things that we don't want to change and copy with the new values. Okay, so we have initialized, now need to do this whole middle section. And then again, we go to the participant side of things, and we could pretty much copy paste this, obviously, we're going to need to update specific parts. But the essence is very similar. So wherever we see engine, we need to do state DOT engine, wherever we see client, we do state DOT client mesh, you get some issues here, because this is named the same thing, but we're going to change it to st instead. And now the last one is the channel, we can change to state DOT channel. So I'm joined channel success, we don't need to do anything here, we're just going to print out director and the UID. So we can just see if they joined here, leave channel, we don't really have to do anything here. And the rest of the event handlers will handle a little bit later. Sir to log in, there's no widget necessary. Because we're actually past the channel name and the UID. We can just remove that. And actually the one thing that is definitely hard to catch here is we're setting the state channel. If you remember I said I mentioned we reassign that state variable every single time if you want the UI to update. So this doesn't really work for us. What we want to do instead is state DOT copy with channel and then pass in this channel that we're waiting for. So now this will create the channel and we'll be able to access that state channel whenever we use it. So now we got all the setup for a Gora, an RTC and our TM setup. And we can close this function a little bit until we need to add those event handlers. And it won't clutter up too much stuff. Let's close this initialize and, and we can even close this leave call. So now we want to test it out and make sure that we get this director and the UID printed out. So like I said, we're going to do that in the Init state where we try to join the channel. And in here, since we don't really care about the return of that, we're going to read our director controller that notifier click the Join call function. And we have a channel name that is passed into this widget and we have a UID that's also passed into this widget. Or so I thought I guess it's not passed in yet. So we want that to be passed in. Alright, we've got on the home screen and then Director screen now as well. So this context read, if we look at the description, it reads a provider without listening to it. So just watch, we're listening to all the changes and we want to update depending on what's going on here. And here. We just read it and we forget about it. So we would just call that join call function, let it do the rest and we don't even have to worry about it. So okay, then I think the director applications should be working now. If we run it, we should see our emulator pop out a director with the UID print out just like that and then we'll know everything works on this end. Okay, so we were able to get to this screen, we see that the store ID is 634657764 and we joined the director sees something very similar So username, we'll go with Titus, Titus here, click director, we get to the director screen and director Boom 634657764, the same exact UID as you got there. So it seems like everything works, we're able to join the call. Now we can move on to the next section. And that's actually bringing on people into the lobby and into the staging, managing multiple users within the call. And we're going to do that by going to the director controller, and then there's join call function. So remember, I said, we're going to add more events to the event handler, we're going to have an event for user joined, and user offline. Now in this first section, let's just print out that the user join. So we can have all the details in there. And here, we're just going to have to implement two functions. So we're going to have add user to lobby, okay, I need their UID. And then when the user jumps offline, for whatever reason, we want to remove user. Again, wanting to define which user we want to remove. Now, let's close up this joint call function and implement those two functions. So the first one we're going to have is the Add User to lobby and remove user. And we see these errors that we had here go away, now we just need to implement them. So these two functions are actually pretty straightforward, we just need to add a user into our lobby users set. So let's get into since since this is a state notifier, we need to reset that state variable. And we'll do that with a copy with me to update the lobby users value. We're going to do that by taking the old lobby users. And I forget what this what this is called again. So this is called a spread operator, you put these three dots before a list, and you get all the values within that list added into the previous list. And same thing works with sets. See, we're taking all the lab users putting them in a list. And then at the end, we will add another lobby user. So be defined as an a gore user. Eu ID, we're getting that passed in. We want them to be muted at first. They want their video to be disabled at first as well. The name, we don't have that part sorted out yet. We'll actually instead of naming a weight, we'll name it to do to dude. And background color. We also don't have this sorted out, but I'll set it to blue for now. We'll do that real soon. But let's implement the remove users. And then also allow them to be moved into active users as well. So the Remove user is actually a little bit more complicated than the Add User to lobby since we need to check in both the lobby and in the active user state. But it's still not too bad. So first, let's create some temporary sets. And then all we have to do is loop through all of these people in the active users list and in the lab users list. So you see this as a nice for loop that goes the length of the active users checks if the element at that user is equal to the UID, which we want to remove, and if so remove it from that list. And once we have that update the state with our new active and new lab users. Now we're going to switch a little bit to the UI side of things. So we can actually see this stuff working in action. But before we do that, we're going to set up the base of the next two functions that we're going to need to add. So we had add user to lobby remove user, but there's two more functions that we need. And that's to be able to promote the user to an active user while they're in the lobby. And to demote that user from an active user back into the lobby. And I guess before we even go to that, maybe it makes sense to actually implement these, they're not that much more complex than these other functions. So to promote the user, the lab user to an active user, we want a temporary lobby of all the current lobby users. And then this temp color and temp name is this name and color that we're assigned right here. They're obviously not initialized, but we want to pass that value on to the active user as well. So similar loop, we loop through the temporary lobby, we check when the UID is equal to the UID that we want to promote, let's say this temporary color that we have. So from the cigar user, we're just copying this these values into a temporary variable and then removing that person from the temporary lobby. After remove it, we need to set the state again. So now the active users will be the previous active users plus a new agora user with UID UID. Background Color equal to temp color and their name will be equal to temp name Okay, So recapping, we updated the active users to have the new active user. But remember, we also update the lab users to use the new lab users without the specific person in there. And now we could pretty much copy paste the same exact thing. So very similar code for the demotion process. But wherever we see, lobby, want to change to active. And then wherever we see active, want to change that to lobby, the only difference here is we want to make sure they are muted, and that their video is disabled. Okay, so even that's added and no, so the management of all the users going between the active users and lab users is all complete. Now let's implement the UI so you can actually see it in action. So for the UI part, we might go a little bit faster, just because the UI I think matters a little bit less the how the actual back end of it works, I think, is the most important part of this course. But I still wanted to cover the UI here. So we have our whole scaffold wrapped in this consumer widget. So if you remember, this will keep watching our state for any changes. And we'll be able to update our UI whenever any of those change. So inside the scaffold, we will actually be doing a custom scroll view. Because we can have a bunch of people within the call within the lobby within the active users and want to be able to scroll nicely. And then this will be implemented using slivers. So the first section will have a sliver list. A sliver child list delegate. And here we'll just add a nice safe area where for now we're just put the word director in there. So if you don't know what Slivers are, Slivers are pretty much little pieces of code that work well with within a scrollable view. And so the sliver list is very similar to just a widget within the sliver. So like a nice row, within a sliver view, or within a custom scroll view. So the next part is we're going to check whether the users are empty or not. So I take the director data and see if there's any active users. And if it's empty, we will just display another sliver list that says this is an empty stage. But this is where it gets a little bit more interesting. Here we'll add a sliver grid. So for the sliver grid, we'll need a delegate and a grid delegate. So for the grid delegate, we're going to define something called a sliver grid delegate with Max cross axis extent. So this section pretty much defines how big each of your children are going to be. So here, we define the maximum extent of the cross axis for each title, we wanted to take up half of the screen, I wanted to have some spacing in the two. And the way we get half the screen as we get as there needs to get the size object. And we're just going to define it up here, because we'll probably use it in a different section as well. So we define the size by doing media query context, dot size. And this determines the size of how many pixels is the size of our screen, pretty much. So we take the pixels of our screen divided by two, that's how much each grid element is going to have. But we also want to have it give us some spacing of 20 pixels. And that will give us the look that we want. Then there's a delegate, which is the actual child. So this defines what we want each child to look like and how many children there is going to be. So here we'll use a sliver child builder delegate. So in here, I just decided to cut and paste to make a little bit easier. But let me explain to you. So at this sliver child builder delegate where we get the context and an index for which child it is. So total child is going to be the active users dot length, so how many active users we have. And then each child will have the following design, where we'll have a row, and we expand it, and then create this stage user. Now the stages here, I'll just paste it in. And then we'll set up the rest of it and show you what the UI looks like and go through this in more detail. I think it's kind of hard to imagine just with words, okay, and then we put a little divider in between. So once again, using a sliver list. And here, we'll just do a divider with thickness of three, and then some indents on the side. And then literally a copy paste of this above thing for active users, except the same thing for lab users. Now, again, we need to implement this lab user, but I'll just copy paste in. It's the same layout as the staged user. But I think it'll just be easier to showcase when you could actually see the UI as well. So I think that's the UI for the most part I know there's a lot of higher pacing here but we're going to go through it right now. After we started up so I could actually showcase you with an example app and, and what each part actually does. Okay, so we have user name. We'll just call it director says username doesn't really matter channel will go to Tada. Click director. And we should see this weird director text at the top. It's there for a reason right now, you'll see it soon. But we could have just added an empty container there. Actually, let's let's do that just to make it just to make it a little bit less cluttered. So with an empty container, it's a little bit less cluttered. And we have the stage and the lobby here, now actually need to join from a different device for the first time. If you remember, in the director controller, when we said when we joined, we have a color of blue, and the name has to do, that's what we get here. This is why we set the colors. So we're going to let the people input their colors and have their names appear here. But for now, it's to do and the color blue. So this is the design that we have. And there's actually one piece I missed to make it look a little bit nicer. Actually, within the scroll view, let's add some padding around this. And we could actually keep it at eight. So now it's going to look a slightly bit nicer. So back to the lab user, let's see what we did in order to get this UI. So use a clip, our rec service takes the rectangle that we created, we created the blue rectangle and takes off a little bit of the border. Now in this case, we actually check if the video is disabled before showing our stack of widgets, FS not disabled will actually show their view. And I realized this probably isn't necessary anymore, because as a lab user, your video should always be disabled. So we could simplify this a little bit. So in this clip the rectangle we have a container that has the color of blue that we pass there and with. So this is the we take the lab user, and at that element, we take their background color value. So the background color value is blue. And for some reason, there's some air with this background color will display black. And if there is no name, we display error name, but we take that lab user at that specific element, and we display his name. And this one we have to do so I guess we could have not added to do or color. In this case, we would just get black and an error name. And then this is all within the stack. So on top of it, we have a little container with again, a border radius of 10 to fit into the corner. And that's that's what this is. So it's like a little button that fits into the corner. We made it a little transparent black. And whenever we press on it, we will promote this user to an active user. And if we set everything up within the director controller correctly, or press this button, we should be taken into the stage. The video should come in of me. And we should have a very similar UI on the stage. So let's try it out now. Tada. So here we go. So for the stage user, we have a very similar UI, we'll have the same rectangle that we had here. I said now we actually care about the surface view that we would have. And then we want to put buttons on top of that service view. So we'll have different buttons, one to either bring the user back into the lobby like this, or to turn off their video or to turn off their audio, and the video is turned off, we'll have a nice video off screen. Then this section takes that background color that we have from the user puts at the bottom corner, and then tastes their name. And as they hear, as long as you know their names available. I noticed we have these buttons over here. So I kind of said some of the functions out because these aren't implemented yet. But when we click on these will toggle the other users audio and the other users video, these buttons have a very similar setup as what we saw in the lab user, except there's three of them now. And they also change colors depending on the state. So when the video is disabled, this will be red on the video is enabled, this will be white, and same thing with the mic muted. So that's what the stage user widget looks like. So the next step we're going to do is actually implement these toggle user audio and toggle user video functions. So these, when we see the word toggle, that's when we're doing it as a director, we're toggling them on and off. But there's one thing to remember is that the participant user can actually click these toggle buttons on their own side. And we need to update these states based on that as well. How to do that through the event handler where we will find there some functions to check whether the user has updated the audio or video, we will be adding four new functions here. So first one will be toggle user audio will need to pass in which index of the user is so in the UI, we actually know which active user needs to be toggled so we could just pass the index directly make it a little easy on us. And then if we want a muted we will send a message to mute and otherwise want to unmute. Send a message to unmute. They might be asking why are we sending a message instead of unmuting them directly so This mute functionality is actually going to be a sending a request for the user to mute themselves. Actually, maybe that made some more clear to start with the update user audio then. So this gets a little bit complicated, because again, we need to rewrite the whole state object here. So we're going to do is actually take the whole agor user, we're going to find the element where the UID equals the UID, we pass in, we're going to set that to a temp variable, however, a temporary set of active users, we're going to remove that specific temporary user, I'll add that user back in with whatever mute state that it needs to be added in with, now we just reset that state or reassign that state with the new active users. And that should totally work fine. Now, there might be a better algorithm to do this, there might be a simpler way, a more efficient way. But this works just fine. Now, let's copy this function. And change this to update user. video instead. So same logic, here, we're going to find that user within the Active Users list, we're gonna create a temporary set. But then instead of copying muted when a copy video disabled, now need to execute those functions when an event gets triggered. And the event that we want to get triggered is remote audio state changed, and for the other one will be remote. Video state changed. And here we will check. His state is equal to audio remote state decoding. And if we take a look at it, what this means it means remote audio stream has decoded and plays normally. So that means we're unmuted and we should be playing. And then we can actually just call that update user audio with the UID and muted with false. Then otherwise, if state is equal to audio remote state, that stopped, want to update user audio to be muted, in this case, very similar thing here. So we need to change this to video. And change this to video disabled. So you can actually test this out on our device to see if it updates to the correct color. Alright, again, the username doesn't really matter. Channel name, Thomas will go to director. Nobody here. I'll join on my end. Here we have a participant. I'll bring this person into the stage. And there we go, I'm muted. And you can see the red icon. By turn on my camera, you see video off and camera turns off. I turn it back on, everything seems to be working well. Okay, so that section was if the user mute themselves on there, and so we have it updating accordingly. Now as last part is we need to, we need to be in control of them as well. So we have toggle user audio and toggle user video, we had toggle user audio, almost implemented. Yeah. So we need to be sending a message to mute and unmute them. And this were our Gore RTM comes in real handy. So we're going to send them a message, they're going to mute themselves. And then through this function that we implemented up here, update user audio, we will get their updated state here but they will pretty much be muting themselves. So we want to do here is take the state and it's going to be a channel wide message. So we're going to send a message and the message is going to be formatted like this. So yeah, our Chem channel from text that our Tim channel RTM message from text. And if we're already muted that means you want to unmute and we want to make sure to give the UID of who we want to unmute. So our message is going to say unmute followed by UID. Same thing here except here we are no muting what that Id are looking copy paste this and change this a toggle of user video. Instead of muted. He will just say a name If enable, we'll use the word disable this UID. And then if it's already enabled, we will enable it. So the next part of this is we need to accept these messages and do the correct actions upon these messages. But in order to not jump around everywhere, let's add all the other RTM send messages in here. So if you remember back to this drawing, to participant, you, you shouldn't be seeing yourself, right, we need to be seeing all the people within the stage. So we need to somehow send all the users that are within the stage to the participant. And that's going to be the last type of message that we're going to be sending. So we're going to send audio mute and unmute messages, we're going to send video enable and disable messages. And we're going to send active user messages. So these are going to meet need to be executed every single time something changed with the user. So all four of these functions, we'll need to have some sort of active user message. I'll actually create another util here. We'll call it message that Dart. Now these helpers are going to be used to make it just slightly easier for us to work with sending all the list of active users. So we're going to have a class called message. And it's going to have a function inside that returns a string, because our team message needs to be a string. And we're going to call this son active users. So we need to be passed in a set of agor users will need to be turning this set into a string value. So our string will start with the keyword active users followed by space, the space is important, then we set up a four loop to go through all the active users. And let's actually set up our return to return the user string. Out in this for loop, we're going to append on to the user string. So the user string plus active users dot element at this specific index, we take their UID turned into a string and then add a comma after that. So this is where our messages are going to look like. It's going to look like active users, which is a keyword we're looking for, and followed by UID, UID, UID, UID. Okay, we're going to send out this string. But when we receive it, we actually need to parse that specific string and get that list of users again. So let's create that function here. So we want the list of gore users. Parse active users, I'll pass in a string of UU IDs. So before this step, we will look for a space within the code that will tell us that this is active users and we will send the string of UID UID UID UID. So this the type of string that we're going to retrieve here, so I'll create a list of the strings and split them where the comma is out here to be turned into a gore users. So we can use it within our app. So we'll need to loop through all the gore users who will check if this is an empty string, because remember, we're parsing on every comma. At the end, there will be an empty string here with nothing. So I want to get to that point want to continue out of the for loop and keep keep going. Before we get to that part, we want to take all the users and we want to create a gore users from that UID. And we get that from the list of strings that we have. We parse it, turn it into an integer and set it to our UID. And finally, we're ready to return to users. Right? That was a little bit more algorithm heavy. Hopefully, this all makes sense. We're basically working with string manipulations. Now going back to Director controller, so so we need to add it to these four functions. So when we add the user to lobby, we want to set out send out a message of these active users so that the participant can update their own screen. So we take the channel, send message, or message is going to be a Gora RTM message. From Text we're gonna call that message class we created and say send active users and active users we're going to send as the current state of active users because we already just updated that state right here. So we updated, the state is new and ready to send out. Now when we promote them to active user can copy that same thing. There'll be a new user. But on top of that, we want to add two more messages, want to unmute that person, and we want to actually enable their video as well. We don't want to have them come into the stage and their videos off and everything, that'd be a mess. So now when we're demoting them to a lobby, we want to do the opposite of this. Well, except for that last line, we'd still just want to update with the current state of the active users. But in this case, you want to mute that user and want to disable their video. And lastly, when we remove a user we'll send them to new active users as well. And we don't have to worry about muting or muting them because they're gone. Okay, we're getting very close to the finish line here. So next part is we want to retrieve the states with the participant side of things, I want to address those actions that are those messages that are being sent over, we want to listen to them and do the correct thing. So you remember these messages, we were sending out our channel wide messages. So we're going to be using this section a lot. So this is where we'll see our message and which member sent it and all that stuff. So first thing we need is to parse for that space that we added. If you remember all of our message definitions, we have that first identifying word either enable mute, on mute, disable, or active users, followed by a space. So we're gonna split that text into a list of strings based on where the spaces now we're gonna set up a switch case statement, we can look at the parsed message and position zero because we know there should be two positions total, the first specific word and then the rest of the message. So in the case that we need to mute, we will check the parse message and position one will check if it's equal to our UID. So we need to set the state of muted to equal true, since we want to meet this person, and insists that only does it locally like on our side of the app, we want to also let the engine know that this person has muted themselves. Now this mute local audio stream will trigger our director controller event for remote audio stay changed. If it's muted or stopped, this will execute. And then the rest of the logic executes. And I can imagine we'll have something very similar for the other cases. So we'll have the case of unmute. Where this is just false. And this is false. And now we'll have the case of disable and enable. Or this will be video disabled. And this will be mute video stream. Last one is actually becomes pretty easy for us as well, because of how we set up that parts active users function. So we get active users as the first part of that parse message. Let's add a break in here. So we don't forget, all we have to do is set state and set our current users to message parse active users. UID is going to be parsed message at index one. He just can't be a setter, because it's final, who made a final, I didn't make a final was supposed to be. Okay. So all the messages are accounted for. Now one of the last things we need here is to actually show the UI of all the users. So toolbar is pretty much done. The main thing we had to do is is broadcast you. I think I'll just copy paste this in here because again, it's it's not the most important part of this application that we're dealing with. And this reminds me we need one more thing to add in. So this active users so want to have this variable called active user to know if they're on the main page or not. Because we don't want to display all the buttons we don't want to have them the ability mute or change their cameras if they're not even on the screen. And let's actually change this name to local user active because we Have the active users over there, I don't want to get confused. So we'll update this. And I explained that logic in a little bit, but let me update the buttons first. So we have the mute button here, want to check if the local user is active, if he is active, then we want to display that Material button. But if he's not just display an empty size box, then call button we do want because we wanted them to be able to leave the call. But the video disabled button we don't want again, same situation as above, we'll just create an empty size box. And then switch camera, we again don't want this. And if it's not active, then we want to display a sized box again. Alright, so there, the buttons are updated. Now let's go through the view a little bit. So as broadcasts, you gets all the render views that we have. And the render views function, we have a list of all the users. So we have the gourd user with the UU IDs. We go through that list. If the list is equal to your own UID, then you create an RTC local surface view. So that means it takes your camera view. And that's what we're going to be using. And we're going to be putting the user's username at the bottom as well. And then so if we already did a check to see whether you are in the active users list, so if you are then check if local active gets set. And that's how we set the local user active thing. Otherwise, we will use the RTC remote surface view. So this means a surface view or a video view that is not coming from your own device. And then again, same thing will have their username at the bottom right. So you get these stacks of different views. And now we need to set them into a grid of what we want to look like. So if zero, you take up the whole screen, if it's two, you take up the top and bottom. And then if you have three or four, you set them into their own view, if you want or need to add even more, you can with a golfer you can add up to 17. And I think that might be increased soon, even. I mean, he's expanded views just put this into an expanded role pretty much. So that's that's the UI, the core thing you want to understand here is how the gore logic works here, the UI is I'm not as worried about alpha or UI key don't even have to worry about that in the first place. So okay, let's run it. Let's see if it works. Okay, so we will first try out the director part where we'll try to mute the people. So when we join will see is blue to do again, on my side, I see only and call button, but we'll showcase that here as well. And then we bring the user in here, we should be able to mute them. So let's try it out. There it works. And I can actually see our mind, we'll swap the roles around and then I'll show you there too. But I can show you here, we turn off the video, and makes the video off and everything's working well. Now, let me show you this from a participant point of view. So if we join as a participant received and call button with nothing else. So this is the lobby, we don't see anybody in the lobby, but when we try to bring the person in, you will see we had the name director, and we have that little Android emulator. And now I won't see my mouse here, I'll click mute on the other end. And you see the state updates here to be muted, and I can turn off the video. And those still see it here locally, because we don't update the UI to do anything when our video is off. And we're still technically on the stage, we see the status updated. So okay, everything seems to be working well. So last thing we need to do is add some logic to generate the color and send the name of the user to the director. And we're going to do that within the participants to join channel success. So this is when you successfully join the channel on your own. And I can actually remove this users that add here. Because we're not relying on this anymore, the director is sending us all the information for what users we actually need to display. I actually saw a little hiccup on my second device when this first launched, because I saw the screen pop up for a second and then go back to nothing. Because we added that user here on this joint channel success. But then as soon as we received the message, we set that back to nobody. So that was a bug that would have totally been hard to spot. So let's generate a random color and then also give the name that we want to pass. So to get a random color. We're just going to do random dot Next, double multiply by that by all the colors and turn it into an integer. And to send these we're going to be using a local attribute that we can get access to from the director directly. It's a good way to phrase it, so on to add or update local user attributes. This attribute is going to be name and color. So see these local attributes take in a list of maps. So we need to create key value pairs for the name and for the color. So the first one is the name. And then let's get the color. Color, the key will be color, and random color.to string to string as what we will want to pass here. So on the director side of things, if you remember when we first joined, right here, we just set it to a to do and colors blue. Instead, we're going to get the user attributes. And we do that by asking the client for the user attributes for this specific UID. And to access them, we just get the key value pairs, we'll look for a name. And to set the color, we want to get the integer, and then user attributes. Color. Okay, now unless I'm missing something, we should have colors here. So there we go, we joined, you'll see we got a random color, we see the name Thomas, if we leave, join back, oh, should get another random color, I believe, a darker green. Hopefully, they're not all going to be greens. Yeah, we've got a nice orange here. If we bring them into the call, we'll see the same orange with the name down here seems to be working great. Nice. So all the core logic with the lobby and active users and sending RTM and RTC messages is all done. We're getting all the people within the call. And now the only thing left to do is to actually stream them out to all the other platforms. And to me, this is the most exciting part. So if you remember, we had this model set up called stream, but we never added anything to here. Let's change that. So first, we're going to create a Num called stream platform, we'll add YouTube, Twitch and other they'll have a class called stream destination. This will have a string platform and a URL where we want to stream. So this is a very simple class, we just want the platform and then the URL. So this section even though it might seem like it should be complicated with a gore, again, it's not too bad. So let's close all these functions just to make our code a little bit more readable. And at the bottom here, we're going to add a couple more functions. And before that we need to update our director model to because we're going to need to store a couple more things here. So first, we need a Boolean for his life. So know whether we are currently live streaming or not. And then we will need a list of stream destinations. So that we know where to stream to. And then we need to update that copy with function. But again, we need to fault for that. So we're going to start with false. And our current destination starts with zero. Alright, so now that we got that data in there, we can go back to Director controller. And we could work with that now. So we'll have data for whether we are live and all the destinations we want to stream to. So the first function, we're going to want a start stream, second function will be called Update stream. So if the user gets brought to stage law, the stream is live want to update that user, we want the ability to end stream, then a function for publish destination. And we're going to need to import this enum as well. So add publish destination is when we click we want to publish to YouTube, or Twitch, we will add that into our destinations. And then if we add it, we need an ability to remove it. So these are actually the last functions that we're going to need within our controller. One thing we want to do before diving too deep into that is whenever there's a change with the active users want to check if it is live, and if so want to update that stream. So this is the scenario when you get promoted to an active user. This is the same scenario when we demote to the lobby user. And then also the same thing if we remove the user. While this isn't always going to be the case, it doesn't hurt to update the stream just in case. So now to add publish destinations. We want to give the ability for people to add a publish destination while they're already live. So if you're already streaming on YouTube, you want to add it into Twitch real quick. You can do that and it should update. So here if we check state that is live. If we're alive we want to take a state engine Add publish stream URL. So our past in this URL and transcoding enabled was set to true. Now I'll give a little bit more insight on what that actually means a little bit later. And then whether it's live or not live, we want to update the state with the new destination. We'll do that with copy with then destinations. And very similar to how it did the users, we want to use the spread operation, get all the destinations and add a new stream destination. Let's platform platform URL URL. So to remove a published destination, we got to do something very similar. So check if it's live, if it is want to remove published stream URL, we don't need transcoding. And then we do a little bit of logic here, where we loop through all the current destinations, we check if we check for the location of the current URL that we want to remove, we remove it, and then we set the state with the new locations, and we can return we don't need to loop through the rest of it. So that's how we add destinations. And that's how we remove destinations. Now we actually have all the data we need to finish up the UI, we have the complete director controller with all the pieces, we can finish that up. And then the last thing we're going to need to do is implement these last three functions, then we can show you the fully working application. Alright, so for the UI, we have the little section at the top where we want to add all our streams and things like that. And actually, since this is all gonna be UI stuff, we can just launch this app and see our changes get updated real time. Actually, before we get into all that, we want to wrap our custom scroll view in another widget. And this widget is actually one of the packages that we installed. Called circular menu. So let's take our custom scroll, you wrap it with a widget. We'll call it circular menu, just like the package wants. So items is required. That's the required field. And then instead of child it should be background widget. So a circular menu puts basically a little floating menu thing above our whole view. So we have the items. But we can also add some things like alignment. Or gonna align it to the bottom right in change the toggle button color two colors, black 87. And might as well give it a little bit of a shadow just to give it a little extra spice. Now for your login to this director channel, we should see an error pop up because items cannot be empty. Alright, I'll add some items. So in here, when you're going to need to define circular menu items, this first one is going to be a big End Call button. So we never want to end that call, we will call the director notifier leave call and then pop out of this context. So go back to the old screen. And then a second item we'll have in here is check whether we are live or not. If we are live at a button called end stream, where we call the end stream function that we haven't yet implemented. And if we are not live, we will call start stream and the colors will be orange for both of them. And this one will be a video cam icon and then this one will be a cancel icon. And then we also do a little check here before we started to make sure that there's at least one destination and where we want to start the stream to. If not, we'll throw an error called invalid URL. Alright, so let's try again and go to the director. And we should hopefully see a nice little button in the bottom right. There we go. Now if we click this button, you'll see an end call and a start live stream. So and the call will take us back to this screen and go back into the director. Alright, so that section is done. Now the next is this safe area that we just left an empty container for now. So that was on purpose, we're actually going to turn this into a row. So for this one, we're going to use another package that we added in, called the pop up menu button. And we're going to use it in conjunction to this modal bottom sheet as well. So the pop up menu button takes in the item builder, where we'll need to return a list of pop up menu items. We're gonna need to turn this list at the end. And before we return them, we need to fill it up with all the different things we need. So this part is going to be where we're adding the actual stream destinations. And everything within here needs to be a pop up menu item and it will have a child and the value. And the reason we had that enumeration that we declared as because we Want this value to be to be for YouTube. Now the child will be a simple list tile. And just like that, we have our first pop up menu item, then we'll add a little divider in between using the pop up menu divider. And that's put in the wrong spot. There we go. And I'll have a load divided between the next section where we can copy paste the same thing. Call this Twitch, made the streaming platform twitch. And then copy this a third time to add an other field. Alright, so we have our pop up menu defined here. But there's a couple more things we need to add in. So the icon going to use a similar icons to add. And there's some functions you can implement like on canceled where all we'll do is just print you have canceled menu, then we have on selected. So if you actually choose something, and this is where this value comes in very handy, we can create a switch case statement for this value. If it's a stream platform, dot YouTube we will do one thing. If it's if it's Twitch, we will do something separate. And then lastly, we will have a shape of rounded rectangle border with border radius of border radius circular of 16. All right, there we go. So the next big thing is when we actually picked one want to have a little bottom sheet pop out. So for YouTube, we will have a function called Show YouTube bottom sheet, where we'll need to pass the context and the director notifier. Because we'll need to access that function to add the published destination. Alright, so let's create this function. We will do it up here. And before we implement this, let's go over how to actually stream something to YouTube. Sorry, go to YouTube, you're ready to go live. And click this go live button. And you will have this stream key and you'll have a stream URL. And those are two things you're going to need to do an RTMP push to YouTube on Twitch to get a stream key as well. But but you can go to stream that twitch.tv/ingests. And it'll tell you what the actual URL you need. So you take this URL at the beginning and then add your stream key at the end. And using those two values, you can actually RTMP push your stream to both of the platforms. So I need to input that here. Okay, text editing controller with the stream URL, then copy that and have a stream key. And for this return, we actually wanted to be want to return a bottom sheet here. And we get that from show modal bottom sheet. So we have the context. And within the builder, we actually need to build out this form. And nothing too complicated about this one. We just basically fill out a column with all the things that we want to add. So first add a little text, then some space between the next thing, then a text field for our stream URL, text field for our stream key. And then a nice button at the bottom that says Add. And this goes to our director notifier and does the Add publish destination, we add a YouTube destination. We take the stream URL, add a slash and add the stream key to the end. And that's our URL for the stream destination. So this guy I was reading earlier had a different way to set up the put stream. So they said do RTMP slash slash Twitch ingest server slash app slash stream key. And the way I found this Twitch ingest server was going through OBS, but I have a feeling this would work just fine. So maybe maybe you want to make this your URL and make it more clear to your users how to how this all works. But yeah, the main point is that your app actually goes gets a twitch so try these out. And maybe this is actually simpler to use, just guide people to this website and then they could find it plus had a very similar function for Twitch. So the way I had it was using this old method with our TMP slash slash slash AP. And then string key. Again, just going to the direct and just sir might be easier. So feel free to update this as necessary. Okay, those two are implemented. Now it could show Twitch bottom sheet, we have context and director notifier. All there. Now when we click on this, we should see these options pop up. Sorry, we had this first pop up menu button. And right after that pop up menu button, we're going to loop through all of the destinations and return some more pop up menu buttons, what the actual streams. So number, the item builder needs to be a list of things even though this is just one thing the child will be stream button with the director data and destination for that specific one, or define what this stream button is in a second, and then the same three functions we have the odd cancelled, you have cancelled the menu on selected, instead of adding a published destination here, we will be removing a published destination what that specific URL again, and then very similar border. So last part of the UI, we want to add the stream button. So this will return a widget of stream button. And we're going to pass it a stream destination, we could set up a nice switch statement. Depending on the platform. If it's YouTube, we want to return a container with a child text that says YouTube style it to be white, give it a little bit of decoration. And then since it's YouTube, we want to make it red. Give it a little bit of padding a little bit of margin. And there we go. So YouTube wants to find we'll have a very similar thing for Twitch, instead of red here we'll have purple, instead of YouTube, we will have twitch and the rest should be the same. And then lastly, we have the other will make this color black. Change this Twitch to other. Okay, so finally the UI should be done. Let's run it. So again, we have this director Chowning tatis, let's join it. And we'll see this nice plus icon at the top. If we click this, we'll see a bunch of options, YouTube, Twitch other let's click YouTube will see this pop up stream URL that's just put in for now youtube.com Just as a test stream key, whatever. We actually had some sort of overflow there. But anyways, add that in and we should see YouTube we can click on YouTube to remove it. Now let's figure out what this is all about. So we need to add this is scroll controlled, and set this to true for our bottom sheets. And then we won't have that overflow problem. And we did on this one. All right. Now in this case, we go to YouTube order flow. Might want to add some sort of checks here. But we just want to make sure it all looks nice first. Go to twitch. Add in there we have multiple things. Okay, remove them and add them as necessary. So UI is all there. So now the very very last thing is we actually need to push this stream to our streaming platforms. And we actually have this all set up. So we have n stream and we have start stream already and set up to go. And we only have three functions to implement there. There's an update stream and streaming start stream update streaming. Remember, we call this whenever the active users changed. So that's already handled. So this is also called whenever we need. So last thing is just just implement them. Let's start with the empty string because it's the easiest one. So we loop through all the destinations. And remember to add a publish destination, we do this add public stream URL to mu do remove public stream URL. So all we really need to do is loop through and remove every single public stream URL, just like that. And then we set the state to state copy with is live false. And that's how you end the stream. Now for the start stream. We need to create a list of transcoding users. So if the active user is empty, we should probably do some sort of error checking. Find this case we're going to pretend we don't like error checking and move to state Active Users length equals one. So the best showcase what we need to do with this transcoding is to look at this this drawn out image. So transcoding means we need to define the width and the height of each user and where their location is within that block. So here, when we only have one, we have a use it as 1920 by 1080. And their index is 00. For this one, we have two users, each user will have the resolution of 960 by 1080. And this one will start at 00. But this one will start at 960, and zero. And then so on for we're going to do it up to eight users. By the way, if you prefer reading through a blog, this will also be in the description. So back to the better code. So this is what that looks like. So like I said, if we only have one user to start, this will be 00, which will be 1920 by 1080. If we have two users, first of all, start at 00 960. By 1087, we'll start at 960 comma 09 60, by 1080, and so on and so forth, up to eight users. Now then there's this live transcoding variable we need, are we passing passing those transcoding users that we just defined, and set the total stream height and width to 1920 by 1080. Then on the engine, we set, live transcoding with the transcoding that we just declared, that means we are now live with the transcoding with these configurations. And then similar thing as we did for the end stream, we want to do for the start stream where we go through every destination and want to add publish stream URL. And the second variable is whether transcoding is enabled. And that is, so we set that to true. And then is live also to true. Now last one update stream. So for updating, we're not really changing. Whether we're live or not, we're not changing or adding any published stream URLs. Those are done here, right when we do the Add or Remove. So all we need to do is update the transcoding whenever the users get added. So copy paste all this paste on the update stream. And that is it. That is the last line of code for the fully functioning streamer application that allows you to stream with multiple people that you have control over and allows you to stream to multiple platforms at the same time. Now I understand that some of this might have been a little bit complex. But this is a complex application complex use case. But I'm hoping that a lot of you, after looking at the proper resources, were able to follow along and see how a gore actually made this a lot easier than it would be to make from scratch, I honestly don't know where I would even start trying to implement this without a guru. So let's see this final product in action. We're gonna run this app and I have a YouTube account. That's not the official YouTube account. And the nice thing about YouTube is it lets you see your stream here before actually going live on like Twitch and makes you go live instantly. I found this out from experience. But we'll be able to run and stream our stream to here and we'll see all the changes update, it might not be as smooth here because I'm running an emulator on a stream. And then we'll be using two other devices to stream into the actual streamer app as well. So this user will be the director. So you could see this all in action, we'll use a channel named Titus. On join us director. Now we can assign the YouTube stuff right away, and paste that in here. And then copy paste the stream key in here as well. Now for this one, we might want to hide it in this case, especially if you're live streaming this app. You don't want people to see this, of course. But for now, we don't really mind, I'll just change my stream key right after this. So you won't be able to use it. So you have added a destination. Now let's also run the same application, the iPad that I have connected. And let's open up a new instance of the terminal and run a third instance on the iPhone that was available here too. So the first device is there. We'll call this user named Titus. I will see his show up here. If you guys are part of the flutter community, and you know me, you probably know my good friend, Robert, that's also on YouTube. We'll pretend like he's the other person in here. So there we go. So let's say we bring this user in, and what I'll do is mute them right away so the two devices don't start echoing with each other. Alright, well should be ready to push the stream live. We click this button, start live stream. And we see we have a connection here. So one thing to remember this whole app, everything we see here is running on a Gora. So this will probably be relatively fast. But when it starts going out to YouTube, and there we go, we finally see it when I started going out to YouTube is going to the CDN using RTMP. So we'll have a little bit of a delay Someone can bring this other user in. And let's meet them here as well. And you can see pop up here too. So our apps fully working, we're gonna bring them in, we could take them out now, and update just like it should. And there you go. You see this layout updates, just how it's supposed to as well. So you can add twitch and all these other streams and stream to all of them. And if you want to enable the stream right away to both of them, whenever you start streaming from the app, click this auto start and then the Twitch will automatically start and then YouTube will automatically start. So there we go. That's the app I like to call streamer. Now if you'd like to learn more about flutter development, or just overall developer entertainment comm subscribe to my youtube channel at Titus Petro. If you're interested to learn more about a gore and how all this video SDK in this real time engagement works, go subscribe to their channel at agora and over I really appreciate you watching until the end of this video. This is definitely the longest video I've ever made and probably the most complex project that I've tried to explain with a video. I'm hoping most of you are able to keep up with it. If you have any questions make sure to put them in the comments. I'll try to answer them as much as I can. And lastly, I'd like to thank Freako camp for giving me this opportunity and hopefully I'll see around here some more