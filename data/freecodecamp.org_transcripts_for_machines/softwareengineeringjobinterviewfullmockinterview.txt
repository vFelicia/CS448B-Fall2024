are you ready to Ace your next technical programming interview in this video Keith Galley conducts a mock fulllength realworld coding technical interview with Kylie Ying for a software engineering role learn how to use object oriented programming and dynamic programming to solve questions and get the job you want most people will probably agree that one of the worst Parts about finding a job as a software engineer is the technical interview during these programming related interviews the interviewer will expect you to work to a solution optimize it and write code or pseudocode on the spot the reasoning Behind these interviews is that they will help the interviewer understand your ability to understand the problem ask questions go deeper and optimize the solution how much do you understand data structures and algorithms and ultimately what is your coding level and what is your coding ability today I paired up with a good friend of mine Keith Galley who has a data science focused YouTube channel and he is going to be mock interviewing me so this interview might look like what a real software engineering interview looks like I don't know what question he's going to ask so it's going to be as much of a surprise to me as it is to you and I will be coating on the spot so here we go welcome to the interview how are you doing today I'm good how are you I'm doing pretty well um we're gonna probably just jump right into this interview I'm just curious are you familiar with coderpad because that's what we're going to be using throughout I think it might be easiest to kind of share code yeah cool all right so we're going to kind of just jump right into the the problem so for the purpose of this problem and let me share I just want to make sure you can access this coder link so I'm going to share this and I recommend maybe sharing your screen or I guess we also can just work off of this so I should be able to see here what you typed in I open the chat I can click on this link and it'll take me to the coder pad my name is Kylie and I will enter and so I can see that you're in this coder PAD as well and then here I am yeah and just to make sure that you're comfortable here you want to just run like a couple simple lines of code you can try just running this print hello world if you want yeah so if I run this it'll say that I ran a line of python it prints out hello world so I think it works perfect okay so let's uh kind of jump into the problem so just to give you some context we're going to start with about 20 minutes of design objectoriented design however you want to design this code and then we'll spend probably the last 20 minutes working on more of an algorithms question so that gives you just a little bit of a scope uh you don't necessarily have to accomplish everything you know I know that we have limited time but to kind of give you the context of the problem imagine that where designing a book system so an online Cloud reading application and you can pretty much imagine that we're building a product that is similar to an Amazon Kindle but specifically for short stories so we're kind of in our own Niche they might be Indie stories they might not be you know found anywhere else people could add their own stories um and basically what we want to do to start this problem off is that we need help designing the actual application we needed help designing the code that could Implement an online Cloud reading application and there's a couple things that we're looking for and this is very openended you can implement this how you want but a few things and I'll paste these into the coder pad that we're looking for I'll just paste it below um oh yeah okay you can fix this up and I'll delete that Top Line okay so a few things that you're looking for users have a library of books that they can add to or remove from users can set a book from their Library as active um the reading application remembers where a user left off in a given book and the reading application only displays a page of text at a time in the app in the active book exactly awesome um so so let's see essentially what we want to do is create a library where users can interact with this Library they can look at a book and set it as active and then this application will also just remember where they left off and display whatever page that they're currently looking at in the active book is that correct correct correct okay and then more specifically do you want me to kind of give like a high level implementation or um how do you want me to start this so I really want to just think about you know what components would be important this is I would say an objectoriented design question so I'm just thinking about how you would think about structuring uh I guess the base of a program like this so obviously we're not going to build this full application but I'm really curious about how you're structuring that kind of that core structure that core um Foundation right so let me make this uh smaller over on this end so people can see all this and let's type up some more notes so uh the things that jump out to me are that you need to be able to remember all books so if I type this we need to have all books in the library and we need to um remember active book and then we want to remember page uh remember page I guess last pages in all books and then we want to display a page in active book Okay so um by this all books in the library is that more so I guess how are we representing these books are we are they just like strings do they have a page number and then the string of text how is that formatted is it like HTML I think it's up to you how you want to um store the books within like this programming structure so you can kind of decide what makes sense for that I think the important things is the actual text of the book as well as the title of the book okay okay and and you can implement the uh the details of like the pages and all of that yeah yeah okay so I think that there's two things that jump out to me here right it's we need one class we want one class representing a book and then we want another class perhaps representing a library so a collection of books and so in this uh book specifically you just mentioned that we want the title as well as the like pages in the book yep or like I could rename that the content yep exactly um in the book and then for the library we have a collection of books and then I would also argue that this page uh or sorry that whatever the active book is would would be at the library level because um because we just want to toggle which one is active amongst this entire group right yeah and then actually so this last page in the book what I want I think I'm gonna put that under the book because it's book specific so I think it would make sense for every single book to just remember the last page so um user looked at okay so I like how this is represented and then I think uh kind of diving more so into the implementation I think for the title A String would make sense here because I mean a title is just a string yeah um the pages and the content in the book so the things here are the pages are ordered right when you go through a book They're ordered and there's a specific amount of content per page and so I think something that would make sense for this is just a list because I think a list is ordered it's a collection of items and um and we can't I mean I think like a set you would lose the ordering a dictionary you would lose the ordering and you would also over complicate things a little bit you could have the page numbers as the keys but then um but then a list would also do the same thing but kind of in a more elegant manner and then finally uh a tuple okay you could also have a tuple but um I don't think there's a reason to use like a tuple over a list in this specific example yep or like vice versa like I I think that you could choose from either one so I think here I'm just gonna use a list of um I guess strings which represent per page so like each string represents whatever's on an entire page and then the last page that the user looked at this would just be some integer and this would be an index into this list of strings so I would have to remember that this you know there might be an off by one error here um because in Python we start at zero but like naturally when we're reading a book we might start at one yep now for this library for this collection of books okay well so for this active book um I you could either use a Boolean where you set one book to active and the rest to inactive but I think that that would be kind of excessive because every single time we toggle a book as active we have to toggle everything else as inactive right you can't have two active books yeah yeah okay yeah that makes sense okay so then I think in that case instead what I would rather do is have some sort of um a string or some sort of like an ID matching system where we have like one um variable that's set to the active book and that might be the title or the ID of a certain book in the library so maybe maybe we can just add ID here um and maybe I can make that also a string or an integer or something yep and I'm going to add a question mark to kind of just say like maybe we could Implement that but I'm not sure if we'd want to right now um so this would correspond to ID so uh this would just be some variable and then this collection of books so I guess like when we display this page in an active book um I actually so I think that this week this might have an advantage being like some sort of a lookup table because we have a certain sense of an ID right and I think what could make sense here is having the ID correspond to the book object that we Define up here so yeah this could be a book object right and so um we don't really need this idea I think that if all the titles are unique then then we don't need this ID we can just we can just use the titles as the IDS uh but in some cases in the real world not all titles are unique and so that's what an ID might might come in handy um and so I'll leave that like what are our assumptions here can we assume that the titles are unique or should I be using this ID structure I think I like the ID structure because yeah we're not necessarily going to know that everything's unique so I think this is a little bit more robust okay awesome so I think um this representation looks good to me so I'm just going to go through uh the requirements again just to make sure that I've covered all my bases so here I want all books um okay so I want a library books that I can add to or remove from and so here I have a library and anytime I want to add to this Library I can just add an ID I can add the book If I want to remove um from the from the library then I can just simply delete the key item pair or the key whatever pair key value pair um I can set a book from their Library as active and so here I have this active book and we could always say like if there is no active book then we set this To None or something like that um the reading application remembers where a user left off so we have that here right the last page that the user looked at and not just in the active book and then um displaying one page of text at a time in the active book so we have the active book we can get the book object from that and then we can go to the page that the user last looked at by indexing this value into this list so I think we've covered all the bases here cool um let's do a couple things I guess I think as a starting point and this doesn't have to get too crazy but I would love to just see some you know python pseudocode or even some python kind of code just to like maybe flesh out one of these classes I just want to yeah uh you know look at that a little bit and how you would actually start writing this code yeah sure so so for example here I let's start with the book um and when we define a class let's initialize this so when we initialize a book we definitely should pass in the title and then um the content right I'm assuming that when we add a book these things have to be given to us and then I'm assuming that when we add a book we don't have a last page that the user has looked at is that an okay assumption yeah I like that assumption okay so we can set the title of this book just equal to whatever the title is uh the content of this book and I'm going to assume that these are given to us in the formatting that we want so the title is a string and the content is a list of strings that correspond to the pages um and I'm gonna create a variable last page and I'm going to set that equal to just zero I could also probably set it equal to negative one or something but I think zero makes sense because that would be the beginning right yep and um and then we need to come up with some sort of an ID so typically maybe we would have some sort of function that takes in the title and the content or maybe the author or something and like returns a unique ID um but I think maybe something that we can do here just very simply is uh have some sort of counter in the library and then every single time we like at add a new book we can just associate that counter with that book and so then we know that they're all unique and um and they all have their own IDs would that make sense yeah that that makes sense okay so then I would have to pass in the ID um yeah and so what I'm actually going to do is self.id equals ID uh and then yeah and so then uh for example we might want like a display page right in this book and so for that then we just want to return um whatever is at the last page of the content and I guess let's build on this a little bit another useful function you know obviously you want to start at the the last page but let's say we're starting to turn the page what might that look like right and so if we're turning the page then all we want to do is increment the last page right and so we might do self.last page and we just increment that by one um and then we could call display page after that uh if we assume that like we could if if we assume that these two go together so if we assume that when we turn the page we want to display that page then I would just return display page yep like that um and then actually I'm just going to go ahead and code up this Library as well so this Library we have this collection of books and then also the active book so rather than initializing a library with books I think let's just add them um to this so initially this collection might just be an empty dictionary and then the active book might be none right so then um when we want to add stuff so add to collection a book what I'm going to do so there's either the user could like or our API could like return a book with the uh with the title and the content Etc but since we're we said that we would pass the ID through like the library because we might have like a counter like some sort of ID counter I mean this is not the best way to do it but I think this is like a a fine hack for right now um just to make all the ideas unique what we can do here is um we can also when we want to add a book just pass in the title and the content and so then our new book is going to be a book as we've defined above with the ID and um the title and the count or the content and then after we create this new book we want to increment the ID counter uh and then we also want to add this new book Into The Collection right so I'm going to add self.collection um and I'm going to make the ID whatever the ID of the book is so actually I'm just going to call new book dot ID because I think that's a bit cleaner and this is going to be the new book and then we increment the counter by one so this is us adding to the collection um so of course we want to remove from the collection and so we want we said that we wanted to remove based on the ID so all we have to do is I think there's this delete in Python I'm not sure do you know keys okay is there a remove I think that there's I mean it should auto complete here in the coder pad oh isn't it Dell isn't there a Dell um I mean I think the biggest thing is is it going to be happening in place or is it going to be happening and creating a copy um I I understand yeah so we want it in place from The Collection I understand what you're trying to do so the exact details is is not super super important to me okay yeah so anyways this is removing from The Collection um and when we set active book again we want to do this based on the ID so I'm going to make self.active book equal to whatever that ID is uh and let's see so the user has a library of books they can add or remove from we did that sending a book as active Okay and then remembering where user left off so we've actually taken care of that already implicitly in our um book uh class and then the reading application only displays a page of text at a time all right so then here we can say Define display page and actually we don't even need the the ID of the book because we already have the active book ID right and so what I'm going to do is I'm going to go into my collection um and I'm gonna get the active book like this so yep blah blah and I'm going to click or I'm going to do dot display okay and then of course we also have this turn page that I could um to put up as well yep so you get the idea but so we wanted oops turn that page um I do think that some like drawbacks here are that uh okay so one thing that we could have done is instead of this active book instead of saving the ID we could have saved the book itself and I think from a pythonic standpoint that might make sense but then in the future if we're using some sort of database or something an ID would make more sense because that's easier to store in like a table um and if uh and okay also for this display page you might see that we've called this display page and turn page up here in the book and the reason why I did that rather than um rather than just call like self.book.content last page like book dot last page or something was because I think that like for example this should be independent of how we implement the book right so we want to keep those as kind of block like separate blocks as possible and so here what this allows me to do is when I go back to my book like if I decide to scrap this implementation Implement something else I know that I would just have to implement the methods display page and turn page for that to work um and like these functions should work this this looks good to me I like the start I think that this uh definitely lays out the foundation of what I was looking for with the requirements of this application so nice work with this couple quick followup questions before we kind of Branch into more of an algorithms uh type question as the followup here one question is you know let's say you have an older reader and their vision isn't as great so they need to make this the size of the font bigger so kind of keeping that in mind that you might have this variable font size how might you I guess refactor or change or modify your current structure and you don't have to actually write code here let's just discuss this to account for um that increase in size yeah yeah so I so when we increase something in size like I'm just thinking about intuitively on our like phone screens or something um that type that tends to shift the content right so like some page that might hold a hundred words or a hundred characters at you know um a small font size might only hold 50 if when you double that font size so uh for the book instead of having this list what I might do is I might just save the entire book as a string and um and based so I would let me just edit this in here because I think it's easier to visualize what I'm saying but so I would might I might have like a font size equal to um I guess we could just use like the traditional like 12.5 or like yeah whatever uh but when we have this font size we could come up with some sort of um characters per page calculation right and so that would be based off the font size so calculate so this is going to be pseudocode now this calculate doesn't actually exist but calculate uh based on that font size um and I'm commenting it out so it doesn't have any errors but then uh when we do calculate that then what we can do in order to get our um in order to get this display page thing would be instead of indexing into this content which is now just a long string of characters what we can do here is we can return um we would have to do some sort of calculation right so we would need to we have this characters per page and we can multiply that by whatever the last page is and um so this would give us like kind of the starting index of this long string of characters to start uh the content of that page start index would be this and then what we would want to do is um what we want to do is then return the self doc content from that start index until the start index plus the number of characters on that page so that would be our end index so actually let me just write that out to make things a little bit more clear so now essentially what I've done is we have this variable font size which we can calculate characters per page depending on that font size so that might be more characters or less characters depending on how big the font size is and then our content instead of a list of strings is now just a really long string of characters and I guess some assumptions that I'm making here are that uh this would just be approximate so for example if we had a backslash n which is like a line break right that might just end up counting as a character or two characters but the assumption is that um that would be approximate per page or maybe that we're using sort of some sort of like mono spaced font or something like that um but essentially now that we have the characters per page and then just a long stream of characters that represents the content we can index into that content depending on like based on the last page that we know and so what's really cool here is that when we do Turn the Page uh we can just end up calling this so this is kind of that granularity that I was talking about yeah that that makes a lot of sense to me and definitely you see the advantage of having that function that you can change by having to implement something different uh one last quick I guess followup and then we'll we'll move on to the algorithms portion of this interview um I'm just trying to think you know at a high level let's say that we wanted we had multiple users in this system and they all shared books so like you know they might all share the Harry Potter books or something like that like books are common among all of them how might you modify this yeah uh given that you know some of these qualities of a book might be shared between users because they're all trying to access that same book does that make sense yeah so um yeah yeah for sure so I I think that when we start to you know have like multiple people um involved like this this these books might get stored somewhere for example in like a sequel table right and so then when that happens we would still want to maybe store like the ID the title the content in that table now the only changes would be that the these sort of customizations are um are per user but the book and the content those are for this entire group of people and what we can do I think is um is instead of this ID counter being like Library specific we can start identifying books by their IDs on a more like uh global scale right and so you know this was kind of just a hack to make this ID thing work and be independent and be like unique but for example when you put something into a SQL table you can also have an ID associated with those entries and so maybe when we add to the collection if we see that the title and the content is already in the table then we instead just return the book that's already in that table or something like that yeah okay I think that makes sense to me uh cool I I'm yeah happy with this discussion I think that we can move on to the second portion I guess do you have any I guess last questions on this before I move on or last things you want to say um yeah so no last questions I think that the last thing I want to say is also like it would really depend on like how you implement this like group of people right like so my immediate thought was like a SQL table but that doesn't have to be the only way um so yeah I think okay cool I think it would depend on that um all right awesome uh let's yeah switch gears and I'm probably going to just comment this out in case you do want to run some code and there's any errors or issues in this so I'm just going to comment this out but I'm going to leave it here just so we have it to look back at and I'm going to just indent this a bunch and we're going to just start at the top of the screen so don't mind all the stuff at the bottom all right so another important component of our book reading system and this is completely independent you don't have to reference any of your past code is I mentioned this is for short stories and you could have independent Indie authors you know adding these short stories so they're not going to be you know the classics not going to be those types of titles they're probably smaller authors so one thing that we want to avoid in this system is plagiarism so my task for you is to design an algorithm that would be able to detect the two most likely books that would have plagiarism in them it's like that the the two most likely books that pop up as a match for potential plagiarism uh in this in a library and we can Define as we can Define most likely as meaning they have the longest shared common section of text so we're looking we have a library of books and we're looking for the two that have the longest shared common section of text and we specifically might want to know how many characters that section of text is so you can imagine if it's sharing a single word obviously not an issue but if it's sharing six paragraphs that's going to be a problem so does that make sense right so just to clarify some things what Keith really means here by substring is that for example if I have a string such as learn what are substrings of this well one possible substring is learn another possible is earn because these are strings that are using characters that belong to this string learning another possible one is earning oops now you might say Okay Kylie all of these are consecutive in terms of the characters so here all of these correspond as characters that are next to each other but in this specific example Keith is not actually asking okay it has to be a consecutive substring instead what Keith is asking is just any substring which means that as long as the letters are in the correct sequence you can skip characters if you want to so for example here leg would actually also be a substring or an so for example right here we have earn as a substring of consecutive characters but down here I could rewrite it as a substring where there's actually a gap of two characters in the middle but this would still be a valid substring so it doesn't have to be consecutive we just need all the characters to be in order from left to right let's see let's start off with kind of a naive solution for that um well one thing that you could do is literally come up with every single combination of like substrings for both of these uh and then compare those and see which two substrings are the longest right um but there's a lot of different combinations for substrings and so I think that we should come up with a more elegant solution um let's see so one thing that I'm thinking is we should have pointers that start at the beginning of both yep strings and kind of move along until one of them detects a shared character so or like when until one of them takes like the first shared character so here actually like I would say the first shared character is H right um and so here we would have like like the two pointers kind of be this uh maybe I'll go from the bottom but here and here right and so we look at the next character and we realize okay they're not the same so then we want to keep going um but one downside of this is that well okay what if I want to start comparing from here and here right okay and then I move it over and like these two have like two shared characters so I think that there's still this question of there's a lot of different combinations here um so I think you're on the right track though I like I like this and then okay so far yeah okay um yeah so I know that here I want kind of these pointers that are moving and then I just want to be able to align them right I think that's the that's the key here is this alignment and so now I think we just have to figure out how to make that alignment work um I'm kind of thinking like like one thing that we could do is kind of have more of a base sentence and then one where when we have like so for example if I if I made this my base sentence then in the other sentence I would want to search this sentence uh for each character so if I have the I here then like my first I would start looking from here and then maybe I would start to look from here right but I think that that would end up also being kind of long because for every single character in here you would have to iterate through this entire thing and do the whole matching process um and so I'm does that make sense why that's like maybe not the most optimal yeah that makes sense and I guess what would be the runtime of that uh it would be o of N squared because well I guess if we have one sentence o of N and one sentence o of M it would be o of n m because for every single character we'd have to run through the other string um M times and actually okay so like if my base sentence is like like what is the worst thing that can happen is like a base sentence like this right and then you're searching the worst case example would be like something like this right where like if I have an i okay well I have to go through each of these and so yeah I guess we would have to go through until like they don't match anymore but then that would just be the very end of this so like maybe I can add like an a at the end of that so then I would actually okay so that I would say it would it might be o of N squared M where n is e yeah I think that makes sense to me I think that we should come up with a different solution I'm trying to think of how dynamic programming word work because I do think that this this might be a dynamic programming problem um I'm not sure of how to formulate it yes let's um I think that you're on to something here I think I'm trying to think of a good ways to kind of kick you off here um I mean I would say let's just lay out let's assume that this is dynamic programming uh I think as a good starting point maybe we can talk about sub problems here and try to Define that and maybe that will help us get to our solution or also maybe just to find a base case and maybe that will help us get to the solution so I think let's assume that dynamic programming can be used here let's maybe just start trying to figure out sub problems and maybe a base case yeah yeah so I definitely think that the base case would be pretty simple and it would just be if there is a match right between the two like if the two sentences equal another that would be or okay let's think about all the possible base cases so it'd be if there's a match um or maybe we've iterated through everything that we can and we're comparing like an empty string to nonempty or even empty to empty which is when we would know that we're at the very end right yeah so for example with this match I mean by like um read to read like that would be an exact match so I I think the difficulty of this problem is that is that we can start anywhere in the texts right and I guess if we were trying to recurse through this um or if we if we were trying to go through this with dynamic programming what I would kind of want to do is say okay either like like s is the start of some substring in this sentence or it's not right and if it's not then we want to move over and we want to say okay well then is like H is um a substring or the start of a substring from this other sentence or it's not and we want to kind of continue that process um and so if for example H is a substring then we would want to figure out what the longest substring longest matching one is and then that would essentially like skip us over a few yep a few uh blocks and so I think another way to kind of formulate this might actually be like how many how many characters can kind of almost subtract from the two um and I might uh I might jump in here just I think you're on the right track but I might provide a little bit maybe more of a launching point just because I want to be considerate of our our time here um I think you're on the right track I think that let's maybe try to Define this like with a single line expression like a single line recurrence type expression um because I think that if we can build up to a you know build up sub problems to that final state that will help us so let's say we have sections of text a and I'll put this in uh CR with a is one of our sections of text and b is another one of our sections of text um and basically that could be uh hello world or something you know in world uh just world or something like that um we can assume that yeah basically what we could start doing here is we can imagine that we wanted to find the longest match between a and b and you could Define that as from character index 0 to character index 0 here so like the longest common subsequence here or substring of a b 0 0 would be our kind of goal State because we would want to find if we're working backwards let's say we want to find all the way to the beginning but to help us get there you know we could probably see if uh you know what is the longest substring at different indexes so if you know maybe index three index five so like this would be the I guess last character five would be like the last character of B and I I guess keeping this in mind can we Define this in such a way where we maybe we can uh define an equation that would help us work up to that final goal which would be the entire sequence okay so if we're using kind of these a b strings as example um let's define some like like find uh largest substring or something um and we might have string a string B right so and you're saying okay let's do index a and index b as well and start those off with zero that would be our recurrence relation and so I guess what we'd want to do is find the longest substring between yep these um and we want to increment yep one or the other yep right so like that uh or or if string a equals string B then what we'd want to do is find the longest substring um um we want to increment both of these indices apparently oops sorry so I meant string a at index a and string B at index B like this so then we'd want to increment both of the indices and we want to add one right because this means that we've found a starting match um and what we'd want to do is actually take the so here um and if you want to just write pseudocode here it's fine too for me possibility okay that makes sense to me yeah so let's just do all these possibilities and so then if the two then we have this like third possibility right and what I would want to do is uh take kind of the minimum why is this giving me an error oh so then I would want I would want to return the max of possibility one possibility two okay let's write pseudo code possibility one possibility to and then possibility three only if it makes sense to me if applicable and and then with our base case we said that it would be if one of them is at the end so let me add that in here so maybe like if uh idx a is equal to the length of string a then we want to return zero or or here or idxb is equal to the length of string B um yeah so then for our longest substring this makes sense now because with each index we have the possibility of Shifting it over one and trying to compare this sentence with this entire one uh or Shifting the other one over one comparing those two yep indices or those two substrings from there on or if they are a match then we also have the third option of moving both of them over so actually I should go from here and then because uh this fine longest substring repeats all that on the next character for those two then we repeat that process again and we add one every single time to that um so I think logically this makes sense now one thing might also be that we start to kind of uh recurse a lot on the same indices right because we're trying all these different combinations and if we move them both over by one then um then we kind of are iterating overthrew them a lot so I think that one thing that we could also do is Implement some sort of memoization so here like maybe hold on I lost the oh here we go okay so then like if I so if the memorization is is none then we might want to start this with some sort of uh it could be addiction I think that also what could make sense is like a list of lists right so like maybe negative one because there's no such thing as a negative onelength substring um and I'm gonna multiply that by the length of like string a for example yep and then this whole thing by the length of string B and so essentially I have this table of of yeah I always get confused with the direction of these things but I understand the goal of this length string a and length string they basically create a table that stores some of these values yeah exactly yeah yeah and then in order to store that here then we would want to create like the index a index B I might be these might be backwards but we would want to store that essentially and so um then we'd want to add a case of like if uh if like this memo yeah at index a index B these might be backwards again if that's negative one then we want to return or sorry if that's not negative one then that means that we've already found the answer so then we just want to return whatever memorize there um and so at the very end we'd want to just return memo like that and let me just think about these indices quickly so uh the first one is string B so actually if I just swap these two that should make it work uh because first we'd index in 2A and then we'd index into B yep so yeah yeah if I just swap those two that would work cool um uh yeah this makes sense to me I guess my last question I think that this is the approach that I was uh uh kind of thinking about as far as dynamic programming goes my last question is what would be the run time of this um you know memoized uh dynamic programming solution um okay so here we are going through all of index a or all all string a and all of string B right by incrementing these indices until we hit a base case so so there's no way to avoid going through both of them um and and incrementing one but not the other and so we essentially have to fill out this entire memoization table in order to figure out our answer right yep which means that it would be a benefit and then my last question I know we're running right up on time is I guess given the context of the original problem was you might have a library of books how would you leverage this find commas longest substring to I guess find the two most uh like the highest probability matches in the entire uh library of books um I think that so here now that we have this find the longest substring with string a string B and we have all we have so we let's suppose that we changed uh the implementation of this book to be this like long string of characters for the content then that means that what we can do for this fine longest substring is just pass in like book a DOT content and book b dot content and figure out the longest substring between the two of them and we can do that for all the combinations of books um unique combinations of books and if we find for example okay well so the prompt is to detect the two most likely books that have plagiarism so we would just return the two books with the longest substring but you know maybe we want to say like any any books where more than 30 of the care you know more than 30 of the book is uh or maybe even like ten percent um shares the same substrate and like we might call that majorism uh that's all I have thank you uh for your time I guess quickly if you have any questions I guess for me or any questions about these prompts before I uh head off okay so note to the audience that in a normal interview this would be a time when I would dive deeper and ask questions about um you know Keith's work or what you know he enjoys about the company um and if I you'll find something in one of his answers that I'm really interested in I'll dive into that a little bit more but because this is just a fake interview and I don't really have any questions about Keith's company because the company doesn't exist um yep that makes sense to me and I I did not give you any context really to work with here so we don't have to repeat what we did with uh the video that posted on my channel but cool that's where we can interview uh switch gears yeah all right so now let's switch over to the feedback section uh session um do you want to go through your notes and kind of just share what was good yeah it was bad your overall impression I think this was an interesting session because I like wanted to squeeze as much as possible into this like oftentimes you might see like a smaller fully objectoriented design or a smaller uh only algorithms but I kind of wanted to get both because ultimately from my perspective as an interviewer like I feel like having both Concepts is how I actually evaluate your programming skills because a single algorithm doesn't tell me that much as far as um your your actual talents and like if you'd be a productive member of our team and also the objectoriented design might not say everything either so I like the combination but it was a bit like it is a lot of information so feedback wise let's start with object oriented design I think solid overall I think that you hit like the key points um I think some of the things that I I'm thinking about with regards to your solution is you hit all of like the key things that I was looking for so like all books in library remember active book remember last page in all books display a page in action book I think you did a good job with like the basic class structure to capture all of that I think what I would have liked to see if I was to be like nitpicky and and looking for even better Solutions is I might look for even further breakdown of classes so like I think um there was some things that could have been broken down further where I think maybe you could have a display class even that could kind of separate the the details like you have the book class that has the title the content but then the display class can handle like the font sizes the characters per page all that and just isolate that functionality um yeah so that was like one thing that I picked up on is just I think that it's tricky in an interview setting but I think that to isolate different components and make it easier to fit all together I think further breakdown of these classes could have been beneficial um and then my other kind of like nitpicky comment in criticism would be like I think the the way that the IDS were structured wasn't um necessarily like the the most easy to understand uh so I guess providing some more details on I guess adding robustness to these IDs I think like one thing that would have been interesting I guess it didn't ask about this specifically but um the concept of like okay how could you then maybe if you only had a title in the the book contents how could you maybe grab that ID retroactively or like would you want to do that so like maybe some more robustness in how the IDS were set up so that uh you didn't have to have know the system to necessarily get an ID um does that make sense yeah yeah for sure I definitely think that the ID part was one thing where it was yeah like I would have rather just used the title of the book or like some combination of like the title and author and I think like for example um at like an actual Library they have like their code or whatever and they have their system for you know if it's fiction or whatever genre it is and then like uh some combination of I think author that I don't really remember um that they use to ID books and I think that that probably would have been like a better solution is if we had like the title and author and yeah it is tricky because you don't have access to that nice Library I think the key thing that you did well with the IDS is that you knew that had to be unique you didn't want to have collisions and by mentioning like titles might have collisions that's super important because that would cause all sorts of headaches for us um let me see what else I wrote down I mean again like I'll reiterate like this was a good solution this was a solid solution this would be like something I'm looking for so like my feedback is more nitpicky and like how could things be improved further I think another way and this is kind of similar to breaking things out from you know a book class and then a display class to actually put that onto our Kindle Cloud Reader but I think another way you could have maybe broke this down in a logical manner was when I asked that last followup question which was basically you know you might have many users in this and now we need to be able to each user needs to have their own like last page for each book and all that I think that your answer could have been a bit more nuanced there I think one thing that you could have maybe mentioned is we could have potentially used like super classic subclassing to maybe have like you know a base book class but maybe there was like a user book class that built off of that class book that you know everyone shared ID everyone shared title everyone shared content but all those user specific things could have reused some of that previous code but built off of it so that would have been an interesting idea too yeah yeah that's all I have for the yeah object oriented um portion uh any I guess other comments on that section cool and then I think for algorithm solution um I think throughout the interview you did a good job of explaining your thoughts super super important to anyone listening to this uh don't just write something down talk through what you're writing down as you're writing it that helps me make sure that I know what you're talking about that makes sure that I know that you're on the right track or off track so you did a good job both in the objectoriented design as well as the algorithm just explaining what you are thinking and the pros and cons so like one thing I liked in the algorithm section is you know coming up with a very naive solution to start I like seeing that kind of iterative approach see that you're kind of working towards more Optimal Solutions so I liked the idea of using like every single substring and these two but then realizing this is not optimal I liked then you're kind of building and taking that and being like okay maybe that's not the best approach but let's take a base sentence and a you know a new sentence and uh you know start going character by character in the base sentence and compare it to the you know comparison sentence I think that that was you know a you know you're working towards a better solution it's going to be better than that every substring approach but still not quite optimal and kind of realizing that there was more improvements that could be made there was a challenge in how to get to the dynamic programming solution I think we maybe lost some of those details you would normally have included on like the Nuance of this and how you might improve it so like I would have also liked to hear mention not only of herb tense but also like punctuation if we have to you know keep that in mind so if someone changed periods exclamation points should those still match or should they not match all of that um and then just kind of getting to the dynamic programming uh I think this was definitely like a challenge trying to figure out how to formulate this so I definitely had to help a bit more I think in an optimal like perfect run through uh you would have had you've gotten a little bit further without me having to prod but I think the nature of dynamic programming is unless you're reviewing it and like really like studying it and staying on top of it like in the real world you don't have to know this type of stuff uh you're not coming up and like designing from scratch dynamic programming you're usually looking at notes and all that so like I was you know I'm okay in an interview setting having to prod a bit uh but you know that's I guess the difference between a good interview and a perfect interview is like the nature is I had to provide a decent amount of details and kind of help you get to a recurrence and then once I gave you that starting point the launching point of the recurrence uh you did a great job running with it that was definitely like the optimal longest common subsequence or substring type solution with recursion and memoization to help get us to the optimal so it was nice to see that once you had an idea of what we needed to do that your Rams will run with it and knew exactly you know where you could Implement an optimal solution I think that's all I have I'm rambling on a bit but hopefully those notes make sense and I think we can further discuss yeah I definitely think think that this longest substring was a slightly more challenging problem based on like um you know the problems I've done on the code or like the ones that I faced in like actual coding interviews um but that's not to say that it's not like a good problem right I think it's a really good problem to ask and to kind of figure out um you know what are my strengths and weaknesses and I think that one thing that you know you've probably learned from this is that okay you know maybe I have certain ideas that are there and I like needed a little push in trying to formulate it properly but then once you gave me just like a structure to formulate it then I was able to take that and be able to uh run with it right which I think that you know from an interviewer's standpoint like when you're interviewing it's not just about can they do it or not it's also about how would they you know how would what would an interaction with this person look like right and so actually one thing that I really liked about this was that it it seemed to be pretty collaborative and it seemed to be very casual rather than like me taking a test um and so you know what that tells me as somebody interviewing is oh yeah like if I do get stuck like this person would be able to give me a hint and then I would be able to take that hint and do the rest of the problem um so yeah I mean I do wish that I was able to just get that in formulated but I think that also dynamic programming is typically tricky like that and it takes a lot of it just takes practice kind of to yeah and I think that you make a good point where it's like this was definitely the dynamic programming question was a hard question uh and I think sometimes once you feel like you're off track and an interviewer like oh shoot I don't know the answer to this like I'm screwed I think realize that you might be purposely given a hard question because then you can identify a larger range of candidates so like you know maybe the tippy top is like it's it's instinctual for them to like realize how to solve this with dynamic programming but I'd say like the strong half of this they won't know it right away but they'll be able to work themselves to it so like don't get too flustered this is not to you this is to a general comment to anyone listening don't get too flustered by like getting stuck you're oftentimes expected to get stuck uh you're human so you're going to get stuck it's how you rebound it and I think you did a good job mentioning you know you rebounded well and and that's what's important still like a very strong interview because you were able to work to the solution and it was a hard problem yeah I will also mention I think one other thing that a lot of interviewers do tend to look for is probably testing so I do think that um yeah you know it's a good it's a good signal you know we were running out of time but I think um for both the for the interviewer it's a good signal if the interviewee brings up testing and says oh like you know I like the solution but in order to verify my answer I would like to test it or I'd like to run it or something like that um and I think with in terms of what the interviewer is looking for is that they want you they want to see that you're going to be a good software engineer right and I think testing is a big part of that equation and so I think that um I think that just mentioning maybe hey like these are a few cases that I would have ran through if I had extra time or you know here are some of the edge cases like I think this might work for most cases but there might be some sort of edge case here and there that I should have like gone through um I think those would be yeah that's a great that that should also be a component that testing is super important so seeing that and it is challenging because we did kind of run out of time so like I feel like you didn't hit some of those things that you probably would have hit if we had all the time in the world one thing that's interesting I saw this on Twitter or LinkedIn as an idea I don't know what your thoughts are on it I think that it's a pretty solid idea I would kind of be impressed if a candidate did this but I could see it going either way is the someone mentioned they were like a a um data analyst at Google and in the interview process like they screwed up I think a couple queries a SQL queries and after the interview they like you know calm down like they collected their thoughts and they like emailed the interview interviewee interviewer like the solutions like oh like I goofed up there this is how I would have solved it if I you know had a little bit more time they followed up with like some solutions so it'd be interesting I don't know if you think it would be a good idea or a bad idea I could see it going over either way but to like follow up and be like oh I didn't get a mention these testing cases this is what I would have done uh I think it's probably situation specific because it could be kind of weird too I don't know I'm just throwing that out there as an interesting Avenue if you feel like you wanted to redeem a bad interview or something like that and like have some Saving Grace yeah well I definitely I definitely do think that that is like I don't think it's necessarily I don't think it would be a bad idea under any circumstance I think that okay maybe your interviewer would never see that and they find it a little bit strange or maybe they've already submitted there whatever but I don't think it can hurt um and if anything I think it shows dedication and it shows that you know you couldn't solve this problem but you took time and you thought about it some more and you didn't give up and then you did come up with the right solution and you followed up and communicated that yeah I think it yeah it's situation depended if I feel like my interview went great I probably wouldn't need feel like the need to do that but if I feel like oh shoot that was like I was I'm so much better than that at that point it can't hurt to do something like that and just keep it casual keep it like yeah hey I thought of this thanks again for your time yeah uh take care like uh okay so now after the interview I just wanted to follow up with you guys that interview if I walked away from it I would have been like all right well there are certain aspects that you know just like Keith said there are certain aspects that signaled you know I was probably a strong candidate but I personally would have walked away from that being like dang there are some parts that I probably could have done better on like I needed his help a little bit I probably could have you know eventually gotten if I just had a bit more time to think or maybe today was just not my day and that's just sometimes how these interviews go you can't do perfectly on all of them now a few notes about my implementation specifically I use pseudocode because Keith the interviewer specifically said it was okay too and in this specific problem I really wanted to focus on the algorithm and not really kind of get uh you know get into the syntax of things and so for me uh python is almost basically pseudocode so most of it was very pythonic um but I come to doll out because I was too lazy to get that Max part working because I wrote like possibility three if applicable and I was just a little bit too lazy to like actually yeah Implement that and then also there was some underlining that just wouldn't go away and that was really bothering me so that's why I also just turned it to uh an entire comment now some things to remember about interviewing in general so don't be scared to ask questions turn the interview more into a conversation because that also gives the interviewer a signal of this is what I'm like as a teammate this is what it's going to feel like when you're working with me now during the interview I would always recommend repeating the question to the interviewer just so that uh you can check if you actually understood the question and then from there maybe even ask clarifying questions um and I typically start with something known as the naive solution which is this this is the first thing that I thought of and this solution would work but it's kind of this uh very Brute Force solution where it might take a lot of time and it might not work you know in my time out for these super long strings or these super long data files or this very large array or something like that so it's very very unoptimal but you know it is a solution and then from there that's when I start brainstorming okay well this sucks in terms of timing so let's figure out how we can optimize it so that we can make it run faster and from there if you can find the optimal solution then you implement it the best way and you are good to go all right thank you guys for watching today uh best of luck if any of you have software interviews coming up you know be confident