Learn how to create and deploy a full stack web application using Svelte, Vercel, and Postgres, and they'll do it all on your browser. Hello and welcome to the Full Stack Development Course. My name is Mike Nikles. I am your instructor for this course, and I will talk about myself and my background in just a little bit. Before we get to that, I want to introduce you to the course, the technology stack, and a little bit of how we are going to be developing this. Now, why do we do a full stack web development course? I've been in the industry for a couple of years. And one thing I noticed is that there's a lot of information online about web development, different frameworks, different technology stacks. There's a lot of information about backend development, and there's a lot of information about how to build and model your database and your backend systems. Now, what I think has been missing is this entire endtoend full stack web development, like what, how do you connect the website to the backend? Like of course there's REST APIs, there's GraphQL. There's different ways of communicating between the frontend and the backend, you can find that information online. It's again, like anything else, a lot of stuff out there, but how do you really connect the front end to the backend? What are some of the best practices, some gotchas to watch out for? And the same is true for the connection between the server side or the backend and your database, right? You could use raw SQL queries, you could use an object relational mapping, an ORM, you could use a NoSQL database where you persist JSONlike data or documents. But again, how exactly are you going to do that? And in this course, I am going to teach you the full end to end from building the web application, connecting it to an API, and then persisting data in the backend in a database. We will be talking about the entire thing, we will also be deploying that into a productionlike environment, so that at the end of the course, you have what it really takes to start your next project. Whatever you are going to build by the end of this course will be the starting point for your next project. So you don't have to build all this, gluing together by yourself. Let's talk about where we are going to develop that. Most of you are very familiar with your local development environment, where you have a bunch of tools installed, a terminal, probably, some kind of command line interface, and probably some editor of one sort or another. In this course, I'm going to be using something called Gitpod.io, Gitpod is providing developer environments in the cloud for each task that we're going to work on. So imagine instead of, you know, curating and maintaining our local environment, where we install certain versions of Node or Java, what we get is a new environment, always cleaned from scratch, automatically set up for each task we're going to work on. We will get into that in more detail as the course progresses, and I will introduce this as we go. One thing to keep in mind is if you do prefer your local environment, that's perfectly fine. You can follow along with everything we do by using your local environment. There's no problem with that. Let's talk about the technologies. You can see on the screen, on the website, we will be using a framework called Svelte. Svelte is currently in version three. It's been stable for a while, and it's used in production by a number of big companies, the API slash backend, and also the hosting a framework for Svelte itself will be SvelteKit. SvelteKit as you can tell by the name is developed by the same team. And very recently, the founder and creator of Svelte, Rich Harris announced that he is joining Vercel fulltime so Svelte is now backed by a large player in the industry who really cares about making the web faster. Lastly, we need some kind of database. In this course, we're going to use Postgres. We will be talking about other databases at the very end when we talk about next steps, and you know, this is a stack that I chose because I'm very familiar with it, and I think it is future proof in terms of what you learned and what you can apply at your work or in your next, you know, free time project. over the next few years. Lastly, we will be using two deployment platforms, one is Vercel, we will deploy the SvelteKit application to ourself and serve our web application from there, and secondly, we really use something called Railway, a hosting provider where we will be hosting Postgres and you'll see how easy it is to set up a Postgres database on Railway connect with SvelteKit in Vercel and get everything up and running. That is a very high level overview of what are we going to be talking about and how are we going to be developing this. Let me also give you a little bit of background about myself so that you have an idea of what I'm talking about and why I do have the experience to teach this course and help you with your next fullstack application. So I have been a web developer since 2000, so it's been a couple of years and the web has gone through a number of transitions. You know, things like jQuery. Well, first of all, PHP and jQuery came out, a whole bunch of different things happened since then. React is very big, lots of people using that. And then I started using Svelte about two and a half years ago when it was at version two. And I've advocated for it ever since, and, you know, with the recent announcement of Vercel backing Svelte, I think this is a really strong framework to use for a course like that. Now at the moment, I'm a developer advocate at Gitpod, and that's obviously why we will be using Gitpod for this course, and I will be introducing the concept, as I mentioned before, it's not mandatory to use it, but it is there to give you an idea of what the future of development looks like. You can find me on my blog at mikeNikles.com. This is where I share, you know, any of the open source project I launch or release. You can go there and have a look. There's a bunch of Svelte related content. There is React related content from the past. So go check that out if you're curious about what I talk. Next, you can find me on Twitter @MikeNikles, same handle as my website URL. And this is where you get to see my daily thoughts. It's usually about full stack development. It's about mentoring. I talk a lot about career growth. I wrote a book about that as well, giving you tips and tricks on how to manage your career in the software industry, so yeah, do check it out on Twitter, definitely lots to share there. And a couple notes on my previous life before I joined Gitpod, I spent a few years at Google where I helped enterprise customers migrate their workloads from onpremise to the cloud and, you know, kind of help them with the migration and digital innovation as we went through that, I spent a few years at Mobify, a company now acquired by Salesforce, where we built mobile friendly ecommerce sites on top of a desktop application. So imagine the desktop site that wasn't mobile friendly Mobify would kick in at run time and convert that entire website into a mobile friendly UI and learned a lot about, you know, monkey patching, all sorts of things when I was at Mobify. Prior to that, I did a couple of years at Layer 7, that was an APA gateway security company. My role there was to train and teach the product to customers of Layer 7. So as you can see, I've been around for awhile. I've had different hats around my own business for awhile, and now I'm here teaching the full stack web development course. And with that, let's get started. All right let's have a look at what you will learn in this course. A couple of things I already talked about, Svelte on the front end, SvelteKit to build the API and host the web application, Postgres for the database Vercel to serve the website and the API and the Railway to host the Postgres database. I talked about that before so no change on that. In addition to all that, we will look at TypeScript. So the reason that we're going to use TypeScript is because I want to show you a fully typed environment where we actually can use TypeScript and autocomplete for our database model. So if we have a database model called todoitem, and that has a number of columns, we can then use that autocomplete in TypeScript to access the values in these calls. This is all possible because of Prisma, a tool that we are going to use in order to generate these types based on a database schema. Now, Prisma will also help us to run all the SQL queries and abstract all that from us. So even though we are using SQL database, Postgres, we have not actually going to write any SQL queries. It's really beautiful, you're gonna absolutely love it, I can promise you. There will be an interface generated or a client generated by Prisma, where we can just use it with TypeScript, call functions on it, and it will fetch data from the database, do all the SQL queries, conversions and all for us. The last thing we're going to dive in is NPM scripts. You may have heard of tooling like gulp or other tools that help you glue together your development environment and start, you know, dev servers and watch for file changes and things like that. We will simplify that in my personal opinion, by using NPM scripts and basically have all the scripts that we need in order to test, deploy and develop the application. This will all be part of NPM scripts inside package, JSON file at the root of our project. This is at the high level, what are we going to learn. You do not have to be an expert or even the beginning any of that, all you need to know is basic JavaScript skills. The rest I will teach you as we go through and as it becomes necessary. So don't expect to be a TypeScript expert by the end of this course, however, if you have never heard of TypeScript or have never used it, you will be just fine going through this course. And I will guide you and teach you everything you need to know in order to develop this project. The same is true for any of the other technologies that we are going to be using. Fantastic, with that, this gives you a good overview of what we're going to be learning. Now let's move on and look at how we're going to build our developer environment. There's one more thing I want to talk about. And you also noticed that I have slowly disappeared from the screen. That's just so that we get the full real estate here to focus on the course. And I will be back later to show you a few more things. Now, what I want to talk about is one more thing that we are going to learn that is called Gitpod, now with Gitpod, you can spin up fresh automated developer environment for each task in the cloud in seconds. Now that's a fancy way of saying that instead of using your local development environment, what you get is a new developer environment, fully automated for every task we are going to be working on. You will see how this works as soon as we start coding very shortly. But for now, I just want you to be aware of this. And as I mentioned just a little while ago, you don't need to use it, but if you do want to see what it looks like and how it works, definitely give it a go. You get 50 hours for free per month. So plenty of free time to actually get through that entire course together with me here. So with that in mind, check out Gitpod.io if you're curious, otherwise let's quickly move on and get into the project overview and discuss what application we are actually going to develop. Okay, now, today we talked about what do we will learn, let's have a look at the UI of the project that we are going to develop. You can see where you're going to build a todo application, and I'll explain in just a second why we focus on the todo application. The UI you see here is developed by the Svelte team, and you get that out of the box if you create a new Svelte application that uses the default template. Now, why are we copying something that already exists? Because this course is about full stack web development. So I don't want to spend time building the UI, and instead we will use something existing and we'll spend the time in the course, focusing on deploying, gluing the things together, writing scripts and automating a lot of the process for the deployment of the full stack application. What did you want to talk about though focusing on the why we chose a todo application. And the reason for that is very simple. A todo application gives us everything you need in order to build your own project once you're done with this course. To get started, we have to create todoitems. So we can tap here to add a new item. They will teach us how to send new data to the backend from where we will persist it in the database. You'll always need that functionality, no matter what application you build. Secondly we will learn how to read the items that we created. So that teaches kind of the opposite way. We're going to go to the database and ask for information that will be sent to the backend, and from there to our front end application. Next, we will learn how to update an existing item by checking it off or marking it as done. That will teach us how to go to the database and edit or update an existing item that's already persisted. And lastly, we will learn over here, how we delete an item from the database. If you take the initial letters of create, read, update, and delete. You, get the acronym CRUD that you may have heard of or read about before CRUD is the foundation that you need for any project that you will be working on in future. So if you know how to do that as part of a very simple todo application, you can apply that exact same concept to your next billion dollar idea that you will be developing. With that out of the way, I want to move on and give you an introduction to the architecture of the entire endtoend stack so that we can see how the front end, the API and the database all communicate with each other. Now that we've seen the UI of the todo application, I want to talk about the endtoend architecture. What is this going to look like once it's all deployed onto Vercel and Railway? The very first thing we will be working on is the front end, we were going to build that UI. It will not do anything when we click on any buttons, but at least we will build the user interface with all the different states and all that, so that the real focus after that can be on the rest of the architecture, all the stuff that's white at the moment. So let's have a look at what we are going to build. As I mentioned, we will be using Svelte for the front end to develop that web application. Now, in order to serve the web application to our users, we have to host it somewhere. And the hosting for the web application will happen on Vercel and we will be using SvelteKit. They have to same logo, but Svelte on the front end, SvelteKit on Vercel to host the application. Also in Vercel, in SvelteKit on Vercel, we will have the APIs exposed for the front end. So if we look at that, we will have the frontend make API requests to a REST API hosted on Vercel, in SvelteKit for example, to fetch all todos. So a get request slash todos and then the SvelteKit API will return a JSON object with the list of the todoitems that you can see in the UI. We saw that just a few minutes ago. In order for SvelteKit to return that JSON, we need to fetch it from the database. So let's have a look at how this looks like. Somewhere we'll have to write select star from todos, sent that query to the Postgres database that is deployed on Railway. The Postgres database will return the SQL response that contains the rows from the database for all these items that are persisted. And then it will be sent to SvelteKit and returned to the Svelte application in the browser, from where we can then render the JSON and display this beautiful list. You notice there's a missing piece. And that missing piece is Prisma, a library we are going to be using that helps us translate from the requests that we get in get todos, we will be able to just call a few functions, telling Prisma to go get our todos and Prisma will take care of writing the SQL or generating the SQL that will be sent to Postgres. Equally, when the response from Postgres comes back onto Vercel, Prisma will be the first point of contact to take that raw SQL response, convert it into JavaScript objects that we can then turn into JSON responses that are being sent back to the browser. So Svelte on the front end, sending an API request to SvelteKit from where we use Prisma in order to send a request to the Postgres database. On the way back when the response comes back, Prisma converts the SQL response to JavaScript objects, SvelteKit creates the response for the browser, sends it back, and the browser displays the todoitems that we fetched in the first place, a very standard three tier application. And this is exactly what we're going to build as part of this course, so let's move on and get started with coding. Okay, let's get started with the initialization of our application. First things first, we need to create a Git repository somewhere so we can host to code start creating pull requests. You can do that on Bitbucket, Gitlab or GitHub. I choose GitHub here, but this works with any other hosting provider as well. So at the top right, I'll start by clicking the plus new repository. I want this to be part of GitpodIO, fullstackwebdevelopment, that's the repository name. I want to make it public, so you all have access to it. And you can look at the source code and follow along as well as I want to add a read me file just so that we have some content in the repository when we get started. Let's create a repository and that only takes a couple seconds. Now we've got this all set up and we are ready to initialize our SvelteKit application so that we can then build the front end and eventually deploy that application to Vercel. The first thing you notice on my screen is that I have a green Gitpod button that I added here as a browser extension. If you're interested in following along, and I recommend you to just experience what it is like to develop your application in the cloud and access it through a browser, you can install that Gitpod button by opening a new tab and Gitpod.io/docs and search for browser extension and the References browser extension. You can click the Chrome link if you're on a Chromium based browser or Firefox if you use Firefox, I believe there's a safari extension as well that you can find as well. So once installed, then you will see that green button, if you don't want to install that for some reason, you can achieve the same behavior as the button does by going to your URL in the address bar and prefix the URL with Gitpod.io/hash that's Gitpod.io/hash, that works for GitHub, Gitlab or Bitbucket repository URLs. When you hit enter, that will start a Gitpod workspace for that specific URL that you provide. The only difference between using the URL and using the button, is that the URL navigates away from your repository page. Whereas the button over here create a new environment and opens a new browser tab and then starts to workspace there. So I prefer the button just many for that reason. And also it's easier than changing the URL. Before we do any work, we don't want to work on the main branch. So let's quickly create an issue so that we can do our work in the feature branch, and then merge that branch back into the main branch when we are ready for that. Let's call it initialize the application. We submit that. And now we are looking at an issue and we still have to GitPod button, so at the same concept applies prefix the URL Gitpod.io/hash or install the browser extension. We're going to click the button here. You see it opens a new tab. It creates a developer environment from scratch, and that's every time we do any work on an issue, we use a brand new environment and we will later automate this so that it will download dependencies, start the dev server, start the database, it will all do all that for us. So we don't have to do any of that manually. So that's a pretty good start. What we're looking at here is VS Code accessed through a browser, but also we have access to the terminal. So if we go to the hamburger menu, terminal, and new terminal, what do you see down here is just a Ubuntu based operating system where we can run commands that you can run locally as well. And we can use to have just as a local environment. By the way, if you prefer to work on your local computer, then you can certainly clone the repository and follow along locally. The alternative is that you could still leverage the high powered computers that you get through Gitpod, but use your local VS Code, so again, through the menu at the bottom here, you could say, GitPod open in VS Code or GitPod opening VS Code insiders, depending on which version of VS Code you have installed on your local computer. What that does is it will basically start up VS Code on your local computer and connect to the GitPod environment in the cloud. So you would leverage CPU and memory and hard disk space provided by Gitpod, but access it through your local VS Code instance if you prefer to do that. In my case, I prefer the browser because you know, it's simply opening a tab, but you can use any of these ways to follow along with the tutorial, there's no much difference. All right, we have a repository with a read me file that has no content basically. What we want to do next is create the SvelteKit application so that we can initialize that application, commit and close that issue. In order to do that, let's go over to the documentation for SvelteKit. So kit.Svelte.dev that's kit.Svelte.dev, hit enter. And on that page, there's a bunch of good information. The docs are very valuable, but what we care about at the moment is how to get started. NPM init, Svelte dot next and the name of our application. In our case, we already have an application created when we created the Git repository. So let's just copy the first part npm_init_svelt@next, we copied that part, and in our terminal, in the terminal, we can paste that. And then we can just instruct the command line interface to use the current directory instead of giving it a application name. If we give it a name, it would create a directory for that. But we are already in the full stack web development directory. So npm init svelte@next . It's asking if we want to install that package, we say yes, that was a very quick, downloaded a few things. And now it is telling us that this is beta software, expect bugs and missing features, that's just a warning as well. SvelteKit is used in production at numerous companies, including Gitpod's marketing website. So this is not really a concern. Just something to be aware of that there may be breaking changes, but the documentation is extremely well done. And it tells you how to migrate if there's something breaking. The next thing we noticed is that the directory is not empty that's because we already have a read me file. In our case, we can safely say yes, that we want to continue, so we press the Y. And now it's asking us which Svelte app template. You have two choices here. We can choose the SvelteKit demo app, which gives you three pages. And one of the pages is the todo application that we are going to build. The other alternative is skeleton project. That's what we are going to use because the skeleton project gives you a very bare minimum foundation, very little configuration, very little code exists. And that's really the best way for us to go through the entire full stack web development from the beginning, building the web application and documenting or talking about every single line of code that we we're going to write. So by the end of it, you fully understand why the code is there, what it does, and what its impact is to the overall application. So which Svelte app template? Let's choose skeleton project for this question. The next question is, do we want to use TypeScript? The answer is yes, that will help us when we start to introduce Prisma as well as when we work with the code in our application. So let's say yes for the question, whether to use TypeScript and then yes lint for code linting. We're going to say no, that's, you know, either way works, but for the purpose of this course, we're going to say no. And Prettier for code formatting. I highly recommend you do that in your project. Once you went through the course and do more familiar with the full stack web application development, in the case here, we are not going to configure this as part of the course. So we are going to say, add Prettier for code formatting. No. There we go, a updated read me file. So we can close that tab. The other thing we notice is that it gives us some next steps. The first is NPM install to get all the dependencies and run all the scripts, so let's do that. NPM install in the command line that downloads a few necessary dependencies, such as Svelte and SvelteKit, and the other step was to git init. We don't need to do that because we already have a git repository and git add, and git commit, we will do later in a slightly different way than using the command line interface. What we do want to do too is NPM run dev, that will start our development server, and we can have a quick look at what we get to start with. So let's run that, NPM run dev it starts the server on localhost port 3000 and GitPod, notice that there's no service running on that port, so it prompts us to open a preview or open a browser. If I click open a preview, you can see that the simple browser pops up right within my editor so that I can review the code of my application right here. The alternative is if we go to the footer and we click on port 3000, you can see it switched to the remote explorer tab on the left side. Port 3000 has an option in the middle to open the preview again, same as before, or on the right side, If we press the globe, we can open a browser which opens a new tab. And now we can inspect that web application just the way we would do an old local computer. Okay, that's a pretty good start. I think we satisfied the requirement of the first issue, which was to initialize the application. What are we going to do now is commit these changes merge it into the main branch. And then we will follow up and go through the folders and directories that exist in here created by the init script when we created the application earlier, so that you understand all these files and what they do. All right, in order to commit and push these changes, we can use the source control tab on the left. If you're familiar with the command line interface, we can control C in the terminal, cancel the server, and you can use the git commands right here. That works as well. Let's use the UI for now. So we have to give it a commit message. We're going to call this initialize the application, and we can click the button with the check mark up here to commit. Alternatively, with the text field focused, you could do command enter or control enter depending on your operating system and get the same result, but click the button for now. It is asking us that or telling us that there are no stage changes, that's because we didn't stage any of that. And it offers us to automatically do that for us, and then commit the files in this case, we're going to say, yes, that's what we want. Take all these files and commit them. Wonderful. We have it committed, we have not pushed it to GitHub yet, so we could press the publish changes button right here. And then we can go to GitHub, create the new pull request, and merge that into the main branch. The alternative and I believe faster way is to use that icon next to the commit, the one here that says create pull request. If we do that, you can see that it automatically creates a pull request for us. One thing we want to do is update the name of the title that defaults to the name of my branch, and that we'll talk about the branch in just a second for now, let's change the title to something more readable I need a description, I like to say which issue we are closing. In this case, it's number one. If you don't remember which issue you're working on, you can always look in the footer where you have a branch name with your user name slash the name of the issue dash the number of the issue. So if we look at the issue here, it is initialized the application number one, the branch name is the same. Now you remember, I never actually created a new Git branch. All I did was I started to Gitpod developer environment from that issue by clicking the Gitpod button. So Gitpod is all about automating your developer environment and making you more productive. Now it knows that in 99% of the time, when you open a Gitpod developer environment from an issue, you're probably going to work on that feature and you want to eventually create a pull request to merge back into the main branch. So GitPod is smart enough to just create that branch for you with a sensible default, in this case, it's user name slash issue dot title dash a number. We don't have to do that any time by ourselves. It's just done for us. So if you don't remember what issue number you're working on, check the footer. Next up, we can create the pull request. And it's telling us that there's no upstream branch for that name, that's fine. Please publish it for us automatically. We can say publish branch that pushes the branch, creates a pull request in GitHub. And you can see now we have a preview here of what that PR looks like, and we could even merge it right away from here. What I want to do instead is go back to GitHub and show you what it did for us. It created a pull request, it linked it to our issue number one, because I said close issue number one. If you go to the PR, see this closed issue number one. That's how GitHub knew that they are connected. And usually we would ask a colleague to go and review that. We will do that by ourselves in just a little bit. For now, we can safely go in here and say that we would like to merge that pull request. So we say merge, and we confirm. Now that merged the PR, you can see it's merged. We don't need the branch anymore. And if we go back to issues our issue got closed because the application is now initialized. We still have that environment running here. And what do we want to do with that? If you work locally, then you would keep that environment, you would switch back to the main branch, pull down the latest changes we just merged. And then when you work on the next issue, you would create a new issue, create a new branch. You know, start working and do that over again. With Gitpod because we get a new environment for every task we work on, we can either just close the browser tab and that environment will automatically shut down a few minutes later. Or we can explicitly go to the hamburger menu and say, Gitpod, stop workspace. And then it starts to shut down and it will eventually disappear. We no longer need that, we never have to come back to it. If for some reason you do want to get back to an old environment, you can always go to Gitpod.io/workspaces, and you will get access to that or click open workspace from this tab, which would open it again if you needed to. The dashboard will show you a list of existing workspaces. As I said, there's very few reasons where you really want to go back. We are done with that, so we close the browser tab. We don't need the documentation either. Goodbye. All right, back to the main page, we now have our application initialized. So let's dive in and learn about each of these files, what's important and how we can work with these files to build our application. Fantastic work. We already merged our very first pull request. There's a few more to go until we have a endtoend fullstack web application. Before we do any more coding though, I want to go through and make sure you fully understand what the different files and directories are within our project. If you are already familiar with a SvelteKit application, then feel free to fast forward 10, 15 minutes or so to go to the next section where we will continue with the coding. If this is the first time you hear about SvelteKit, I highly recommend you follow along and learn about the configuration files, the NPM script, and the source code so that you later understand where each file is and what they do, and what's their purpose. So we could review the files and code right here. I think a VS Code environment is a bit more familiar for most people, so let me start a new workspace on Gitpod, straight on the main branch. And use to walk you through and explain the different files and directories. Okay, that should only take another second. We don't need to get started page, let's have a look, so the arguably most important file in this entire application is the package.JSON file. If we open that up, you can see that it has a name of version and that's a good start, you can start tweaking that as you go. Now, the other thing to look at is the dependencies. The first thing you notice is that it only has a dev dependencies. So when you build a Svelte application or in this case SvelteKit application, then Svelte itself is not really a framework that needs to be part of your production dependencies. In fact svelte is a compiler that converts or compiles our Svelte files into pure JavaScript that can be deployed to the browser where the browser then just parses that. So it's very little overhead. And the performance therefore is quite good on the browser side, because there's a lot less code to download, a lot less JavaScript to parse and execute. So because of that, you notice that the Svelte dependency, as well as the Svelte JS slash kit dependency for our application framework, they are both dev dependencies. The other dev dependencies you notice is Sveltecheck preprocess, we'll look at all that later. What we also want to look at is the scripts. There are a number of interesting scripts that need to be talked about, the first one is dev. If you're going to run that out would be NPM run dev, we saw that a few minutes ago, it uses a binary called SvelteKit that's provided by our SvelteJS/Kit dependency. SvelteKit takes a number of arguments. If you pass in dev, it starts a local development server that also provides hot module reloading. So we can make code changes and we see the changes in the browser without the need to refresh the application. The next script that's defined is build. Because Svelte is a compiler, before we can deploy the application. We have to run the build script, which goes through our entire application, compiles all the files and generates an output into a directory here as well, the root, we will see that later. That directory will then be consumed by adapters., we will talk about that when we get to deploy the application, but basically it's an intermediary format of JavaScript files and other files needed to deploy. So the build step compiles the application, creates that output, and then we'll skip on, and we look at preview. Preview allows us to start a local preview based on the generated output from the build script. So if you run NPM run build, and then NPM run preview, you get a preview of your application the way it will look in production, so no hot module reloading, no development server running. This is really much more closely reflecting what the production environment is going to look like. There's two more scripts I want to quickly talk about, this is check. So check allows us to use a package or a binary called Sveltecheck. This is very handy because it's kind of like ESLingt, which checks your JavaScript code, Sveltecheck reviews your Svelte files and gives you a warning or hints if certain things are missing. For example, if you have accessibility issues in your website, such as missing attributes for accessibility on your images or buttons, the Sveltecheck binary will tell us about that and give us the output in the console so we can then address it and make sure that the applications we build are of the highest quality. Checkwatch is basically the same thing, but it runs continuously. So while we're making code changes, if we run that in the terminal, it will continue to output any potential errors, and we can fix that while we're working on the application. The package script that we skipped so far is really something more advanced that we don't really need to worry about right now. But if you were to develop a library that you want to publish to NPM, you could use to packet script to help you with that process. For the time being, we can safely ignore that and move on. So that makes up the content of the package JSON. The next thing that's important is the Svelte config file. If we look at that, you can see that there's a couple of things going on. The first is the config options that we export contain a preprocess property. And this basically just informs the Svelte compiler how to prepare the code. So if we were to use SASS or other features in our CSS, for example, we could configure that here and the Svelte compiler would take that into account when it processes the code. The other important property is kit. And one thing you notice is there's an adapter defined at the moment. This is using an auto adapter provided by SvelteJS. So later we will replace that with a Vercel adapter so that we can deploy to Vercel. If we were to deploy to Netlify or CloudFlare workers, we could install the appropriate adapter, replace that line, and we would be good to go. We will do that later in the course. The next thing is a target. And you can see the comment. This is telling the application where to render the Svelte app. It's similar to what you might be might have seen in other application frameworks, where you have a difficult root, with an id root. So it is under source app HTML. There is a if with an ID Svelte, this is where the content of our Svelte files will be rendered into. Let's have a look at that src/app.html next. So source, app.html. This is the entry point where we can specify HTML, all the attributes we need there. We can specify the head, the body, anything that is shared across the entire application. It's a good place to define common meta tags that do not change like, you know, the charset put in the favicon, viewport things, all that. Later, we will learn how we can populate the head with additional information, for example, the page title, which changes depending on the page we are on. And also down here, we see that div with id Svelte where eventually the Svelte application will be rendered into either server side, if we do a server side rendering or on the client, when somebody navigates from one page to another. Okay, the next important directory is under source and it's called routes. And within that, we have a file currently called index.Svelte. If we open that up, you can see there's an H1 element with a welcome to SvelteKit content, as well as a paragraph that says, visit some link to read the documentation. That code is what's eventually added into that Svelte body here. So if we were to quickly go to the hamburger menu, terminal open a new terminal. And we run NPM run dev, remember that starts our development server. And oh, of course, that doesn't work. We have to first NPM install. We didn't have any dependencies installed. And with the dependencies installed, now we can run NPM run dev. And that spins up port 3000 Gitpod tells us about that. We can preview, see, this is the code I was talking about in the routes. So if we make this, we can see there's a div ID Svelte H1 in paragraph, which maps to, what we have here, H1 and paragraph. Alright, we will add some syntax highlighting to that file very shortly, for the time being, the VS Code that we are using here, doesn't have the Svelte extension installed, and that's why we don't see anything yet, but that's an easy fix we'll do in a few minutes. Good, so let's get rid of this and close all these terminals. Good. The other thing I want to briefly touch on is the tsconfig.json. Because we select the TypeScript as a framework that we're going to use to build this application, SvelteKit automatically created that configuration file for us, and it has all the things we need for this application. So there's no need to understand each of these properties and configuration values, if you are curious, the TypeScript documentation contains notes about each one of those you can mouse over and then just click the link to the docs, but as I said, there is no need to understand what is going on here. It is safe to assume that the Svelte developer team made a good decision here on the defaults. So we can trust them, that they did the right thing for us. Good, that concludes the introduction to the files. So you know, it's very basic for now. Really, all we need to know at the moment is source routes, index is our index page in the URL. If we were to create a about us page or any other route, then Svelte uses a file based routing. So if we do routes new file, and we say aboutus.Svelte, and then here, we would have an H1 called about us. And if we were to go and start to dev server again through the terminal and NPM run dev, if we go back to the tab that we had opened previously, we can now go to the URL and do slash aboutus. And then we see the content of the about us page. So this is how you can create multiple pages. In our case, all we're going to do is use that index page to build our application, but it's good to know how you can extend your application to add additional content. Fantastic, so this is all we want to talk about for the time being. Let's now go on and continue with the setup of our developer environment and this environment here, we just use that for a showcase purposes. So even though I have changed files here, I can just say, go to the menu here and say, Gitpod, stop workspace. And I don't have to worry about these changes. They will never interfere with my new environment that I'm going to create to work on as my part of the next task. So we did that, we can close the tab. We also don't need this anymore. And we are back to the GitHub repository. So with that, let's swiftly move on. The next section of this course is only for people who follow along using Gitpod, the automated developer environment. So if you prefer to work on your local computer and don't want to experience the way it works on Gitpod, then feel free to jump down to the description and click ahead to the next section. For anybody who does want to work on Gitpod and do remember you get 50 hours for free every month. So that's a good opportunity to play around, get an idea of how this way of working helps you and makes you more productive. What are we going to do now is configure Gitpod so that when we start a new developer environment for this project, we want to Gitpod to run certain commands automatically for us. We also want to configure the VS Code in order to make sure everybody who works on this project has the same VS Code extension, so everybody gets a great experience out of the box and if they want to, they can install other extensions that they personally prefer. But at least there's a base set up that makes for a great experience for everybody who uses that project. So let's go ahead and configure the Gitpod environment. We have an issue created already called configure Gitpod. If we open that up and as we did before we click the Gitpod button to spin up a new environment. That takes a couple seconds just to pull down the necessary container image and start the IDE. There we go. Now in order to configure Gitpod, we have two options. One, we can go to Gitpod.io/new. If we go there, we can create a new project. We can select the organization or account, and then our repository, and then follow along the instructions on the screen to configure the project. Now I prefer to add a configuration file to my source code so that the configuration of the developer environment is also part of the revision history so we can see what changed and when did it change and maybe also the reasons behind some of the changes. So the way we can do that is we can create a new file at the project route. So if we right click into the black area around here, we say new file. The file name we want to create is .Gitpod.yml which stands for YAML, GitPod.yml And within the file here, we have certain properties that we have to define in order for Gitpod to pick that up. What we can do is we can do autocomplete with control space, and it gives us a number of top level properties that we can specify. Now, if we don't know what they do, the easiest way to learn about that is to jump over to the docs on Gitpod.io/docs. And on the left side, if we go to references, they say .Gitpod.yml reference, and you can see that all the options, including sub properties are defined and welldocumented in here. So if you get stuck or if you're not sure what to configure, this is your goto place for the configuration file. Now for us, I'll walk you through the key things that we need to make sure are configured. When we start a new workspace, you saw it a few minutes ago, we have to run NPM install, and then we have to run NPM run dev, and we have to do that every time we start a new workspace just like in your local environment, you have to start a dev server every time you work on your project. Now with Gitpod, we can automate that. So there's something called a tasks property. And as you saw, if I use auto complete for that, tasks, it automatically gives me a dash. And then it lets me type something here. So again, if we use autocomplete at that level, it gives me a few options. So what do we want to do for now, we'll look at other ones later, but for now we need an init task, so we can say init. And init is something that runs every time somebody pushes code to the GitHub repository. Imagine your colleague, they merge a pull request into domain branch, and as soon as that happens, something called GitPod prebuild kicks in. So GitHub notifies Gitpod about the change, and then Gitpod kicks off a prebuild where it looks for to GitPod YAML file and automatically execute whatever commands we specify within the init tasks. So in our case, we want to always download and install to dependencies for our project, as soon as somebody changes code. So we can see NPM install for the init task. Now there's one more thing we want to add to that same task. So remember one dash equals to one task. The other thing we want to add is a command right here, the command executes when somebody starts a workspace. So at this time, NPR install already executed on the Gitpod server at some point before somebody starts to workspace. So what do we want to do every time somebody opens one of these workspaces? We want to start the development server, NPM run dev. So with that, we can now open the workspace. Anytime we open a new workspace, the server will already be started for us, and we are ready to start writing some code. And before we go any further, let's validate that these changes do what we expect them to do. The way to test that is to keep this developer environment, so if we look at the URL, we are currently on an environment called copperthrush, we want to keep that, and we want to start a second environment where we are going to test these changes. So the way we can do that is in source control, we can add a comment here to commit the tasks that we configured. So add init and command tasks. We can commit, then we say, yeah, please do a stage and commit that. And we create a pull request remember, right next to the check mark, we can say create pull request, and that's eventually we will want to call this pull request, add Gitpod configuration. And we want to close issue number three. Remember down at the bottom, you can see in the branch name, which issue number we're working on. For now, we are not done with that pull request, we want to do more work, but we want to just test these two tasks, these two lines. So let's make it a draft so that everybody else on the team knows we're working on it. Yep, same message. We don't have an upstream branch, please publish that for us. All right, we don't want to run that, all good. Ignore that error, that's not relevant. Okay, now going back here, we do have a new pull request. Add Gitpod configuration. Here, we can see that we added these two tasks to the GitPod YAML file. Now in order to test that new file that we created, we can go to the conversation tab. And what we can do is start a second Gitpod workspace. Again, remember the URL starts with copper, and if we open a new one, it is now emberdragonfly. That developer environment here is completely separate from the one we have in the other browser tab. The differences that the amberdragonfly Gitpod environment uses the new configuration file that we added to the branch. So look at that, there's some stuff from VS Code. We see that a service is available on port 3000 and in the terminal we noticed that our application is already running on port 3000. That is pretty incredible because we didn't actually do anything, we just automated at once, and now everybody who uses this project in a Gitpod environment gets all of that automatically. So what is the next thing every developer is going to do when they work on this project? Everyone who works on that and wants to make a code change wants to validate their changes. So the very next step literally everybody would do is open that preview URL of our development environment. So wouldn't it be nice if we could automate that as well? Yeah, you guessed, right, we can definitely do that. The way we do it is that the environment we just tested, whether the application starts up, amberdragonfly, we can close that we no longer need it because we already tested and validated the changes to the Gitpod YAML file. So hamburger menu, Gitpod stop workspace. We're going to throw that away, never needed again. Now back here in the copper environment or our developer environment where you can clean some stuff up and back in the tasks, we can now add something else at the top level, which is called ports. And we know that our server starts on port 3000 right, in order to preview the web application. So we can say, Hey, Gitpod, if you see a service listening on port 3000, then do something for us, now we don't need the visibility private that's the default behavior if we don't configure it, so it will leave that out. But what we do want is control space., and then we want to configure the onopen. Onopen, you can mouse over and get more details about that. But this is basically when Gitpod recognizes a service listening on the configured port, and then it will do something for us. So we have a few options here. We can ignore it, this is helpful for, you know, a database service or something that runs to use a hot module, reloading. Ports like that we don't care about, we can simply ignore them. Notify is the default behavior that pops up that little box at the bottom here we saw before, where we can open in preview or open in browser. And we have these two options as a default here as well. So in our case, we want to open a browser window automatically so that we don't have to click that link in the terminal, let's do that. There we go. That is now going to open a new browser tab with the preview automatically. So let's have a look. We're going to go back to our source control. Quickly doublecheck, we added a ports, all right, so let's commit that saying configure port 3000 behavior. Yep. Same thing. This time around, we already have a pull request, so we don't have to create another one. All we can do is just use these three dots or click the sync changes, either way. Three dots and push or sync changes. And this will say, yup, yup, it will pull and push all the changes. Go for it. Fabulous. We're moving back to the pull request where we now have that configure port 3000 behavior as a new commit message. In order to test that and make sure that the developer environment does open a new tab, same as before, we click the Gitpod button, open a new environment, and you can see there's a prebuild in progress. That is because my environment is already configured. So prebuild means it is running the init script that we configured into GitPod YAML file. That happens only once, we were just too quick, that hasn't finished, that's why we saw it in the URL on the UI, but there we go, now it starts coralllama environment. Again that's the third developer environment and it also opens a tab for our preview. That's pretty cool, it doesn't ask us anymore whether we want to open a preview or open a browser for this port. That's the VS Code pop up, we can just say no. Get rid of that. Okay. That's pretty cool, now let's have a look. If we go to the preview environment and we inspect the website, you can see vite connecting... And if we wait a couple of seconds, it will try to reconnect again. What's happening here is that SvelteKit under the hood uses what's called vite. And that provides a hot module reloading functionality that we want to leverage. Now, unfortunately by default, the vite server runs on port 3000, localhost3000. The problem we have is that our web address is a public URL on a Gitpod.io subdomain. So you noticed that was a reload and it didn't actually successfully connect. That's not a big deal. We can configure vite in order to do the right thing, it keeps doing that reloading here until we configure it. So we are running on an HTTPS URL that is this super long URL here and no port, which means HTTPS default port is 443. So what we need to do is we need to somehow configure SvelteKit to use this URL, to connect to the hot module reloading server, instead of using localhost 3000 by default. Let's have a look and how we can do that. First we are going to stop the server and what are we going to do next is we're going to close or actually keep the same environment here, remember the old one we had, where we configured the tasks and then we pushed it to GitHub? That environment is something we could keep working on, but it doesn't really make much sense because it's outdated by now, we started up the new environment based on the new configuration. So we can basically just stop this, stop this environment now and no longer worry about it. We'll shut that down. Close the browser tab. Now we are working on that pull request that we opened up. Okay, so we stopped the server down here. And the next thing is in the Svelte config file, we can come in here and down in the, in the kit configuration, we can add a new value. So what do we want to do here is vite and then it's called server, you can see, we get nice autocomplete for everything. And then the property is HMR for hot module reloading. There's two properties we want to set. The first is client port, as I mentioned, the default is 3000 and the other one we want to set is the host. And again, by default, this is localhost. The question is, how do we change this port to 443, and this host to whatever URL we have here? That URL changes for each environment, so we need to find a way to dynamically load the URL and configure the Svelte environment. So luckily the Gitpod environment provides a command line interface that's called GP. So if we open the terminal a bit bigger here, I can show you how this looks. Let's clear this. If we type gp url, that gives us the URL of our environment, matches the URL up here, right? However, our URL has the port in front. So gp url accepts an argument, if we pass the port number at the end and we hit enter again, it gives us the preview URL of that port that we specified. And this is the URL that we want to specify for the host, and then port 443. We could somehow try to hardcode that, but not everybody uses Gitpod yet. So we have to also make sure localhosts 3000 is configured for people who work on their local computer still. Let's have a look, how we can do that. The easiest way is to use an environment variable where we specify whether we run on Gitpod or not. So the place to do that is in the Gitpod YAML file, what we can do here is in the command. So when the new development environment starts up, we want to run that gp url 3000 command and save the results, that URL in an environment variable. That means if somebody starts the environment in their local computer, none of the code in the Gitpod YAML executes because they use a local environment, they don't get the benefits of this automation, which then means the environment variable that we're about to set does not exist on the localhost, let's have a look how this looks like. So here we want to do export, let's call it HMR_HOST and that equals, and then two back ticks, gp url 3000. And then start the dev server. Now, HMR host after this line looks equals to this entire URL, HTTPS, blah, blah, blah. So let's have a look. We can take that HMR host and in the Svelte config, since this is just a regular JavaScript that executes, we can use the process.env for all the environment variables and have a look at whether HMR host exists. So we can just do a shorthand, which means if that URL exists then process env host, otherwise localhost. So that means we can now run this script either locally without Gitpod or on Gitpod. And the host is always set correctly. One small tweak we need to do is that the HMR host is including the HTTPS or the protocol as well. vite doesn't like that. It just wants to host because it uses web sockets. So it will then change HTTPS to web socket protocol. So we can use JavaScript here to basically just substring the HTTPS// So we'll do sub string and HTTPS// .length. This will get rid of that of that part. What I mean is .length in here, so that it counts the character here, and then start from the beginning of that URL gets starts at this point here, and it takes 3000 and the rest. The other thing we want to do is if we have the HMR host variable set right here, then the port is 443. Otherwise the port is 3000. So this work around here in the Svelte config, let's make this a bit bigger, get rid of that. The few lines here that'd be added as a workaround allow us to run the HMR hot module reloading on Gitpod, and also make sure that people can still run the project locally and also get the benefits of hot module reloading. So there's quite a few changes. It's definitely a good time to go and test that in a new environment, before we do that, you can imagine that if we have more than two commands, like even now we have this one and this one, if we had two or three other commands, this will start to get really hard to read. So there's a little bit of a better way to write that. If we add a pipe here and we moved that to a new line with two spaces indented, remove the end, make a new line, we can now add as many commands here. Starting dev server. So we can add as many, and they all run one after the other. So it's a bit easier to read and definitely easier to maintain as we go forward. We don't need the echo, so we can get rid of that line. But now we want to go and test this in a new environment. So let's go to the source control and commit these changes, configure HMR, oops on Gitpod and localhost. Alright, commit these changes. We can close that preview. We no longer need this or browser tab, get rid of that. And we want to sync the changes. Here, we'll push, all right, go for it. I can probably stop showing that from popping up. Nice. Heading back to the pull request. We have a new entry. That's the changes we just made in order to spin up an environment on these changes. You know how this works by now, click the GitPod button. It spins up a new developer environment that now contains that HMR host environment variable. So let's have a look at what happens. It's good practice that you always keep at least one environment running here in case, you know, something went wrong with your configuration, or you run into some issues with the changes you made, but just good practice to keep that around. There we go, look at that, we got the new browser tab. We saw that before, if we inspect this now, then we can see that vite is now connected to the development server. So once we go back and we start making code changes to that Svelte file, as soon as we save to changes, that page will reload and display the updated code. So that's nice, now we know that our new environment, which is now beigecondor, we know this works and the configuration that we made in the previous one was correct. So at this point, it is safe to come in here and close that environment. So hamburger menu, Gitpod stop workspace. That's going to shut down, eventually. There we go, and we close it. Okay, very nice. So we now have HMR running, hot module reloading works. We have a bunch of automation to install dependency, start a dev server. And what do we want to do next is, let's look at the source roots, index.Svelte. This is not ideal. Not having any syntax highlighting makes it really hard to move along and start writing code. The solution for that is to install the Svelte VS Code extension, which is going to help us with autocomplete, it's going to help by the way that syntax and all that kind of stuff. The way to do it is just like you're used to, extensions over here. And then we can look at the recommended it already suggests that we install Svelte for VS Code. So if we click on that, usually you would click the install button, but that installs it only for yourself, and if you have other team members, you want them to have the same experience and you want the extension to be installed for them as well. So the way you can do that is if you look at that page on Gitpod, click the little settings icon here to manage the extension. And then there's a menu item called add to Gitpod YAML file. And we click that. Then we can close the extension view here, switch back to the files, or the explorer. And now we can see that the file changed. So let's look at that and see what we find. There is a new section that it was added, VS Code extensions and then the ID of the VS Code Svelte extension that basically just tells Gitpod that every time somebody starts a workspace, to also install whatever extensions are listed here, you could add another dash below and add additional extensions that are needed for your project. One thing we do notice is that it's underlined. So there's something wrong with it. And that's expected because if we mouse over, you can see that the extension is not installed. We only added it to that file so that the next time we start the workspace, the extension will be automatically installed. Now we have an option here to say quick fix and fix that for us. So if we do what we can say, install the Svelte extension, or we could start another workspace. And then the Svelte extension will be automatically installed for us. So for now I'm going to opt out to just ignore that morning. And then when you start the next workspace, you will see how the extension is automatically added for us, and we don't have to do anything. Now there's one more thing I want to configure while we're here. But before we do that, let's quickly make a commit here at the Svelte VS Code extension. Okay. Quickly commit that because it's a unique change we made. So the last thing we want to configure in the Gitpod.yml file at the route is the prebuild. So let me show you for GitHub, we can say that GitHub prebuild and we can give it a couple of settings. So the first thing we want to do is every time our main branch changes, we want to automatically run the init script. So in order to do that we use master and then the value for that is true. The other thing we want to run a prebuild is every time somebody creates a branch, irregardless of whether there is a pull request or not, but we basically want to also run the init script on branches so that if somebody was to preview a branch without having a pull request, they would get the same benefits of having NPM install already executed. So the way we do that is we can just say branches true. And lastly, we want the same experience for pull requests. So pull requests, true. Again, if you want to see what other options are available, head over to Gitpod.io/docs, references, Gitpod YAML and then you can jump down here to the prebuild and see what else is available. So let me just add that to the top here. Hold on. See this URL. Let me just see, I think my syntax is wrong for comments in YAML, there we go. It's a hash, not slash slash. So comment easily to find that, we know about that, good. So this is a good place to check that in as well. And now Gitpod that will automatically run a init script. If for some reason, you know, you don't configure that prebuild setup, then what happens is when somebody starts workspace they would have to wait for the init script to complete. So it would just run as part of each workspace startup, but you definitely want to enable prebuild because they will then automatically run, you know, well before somebody starts a Gitpod workspace. And it will run every time the code changes on GitHub. Okay, configure Gitpod prebuilds, gonna push that as well. And we have two commits, we want to push that to GitHub and make sure everything's showing up, yep, it's right here. So with that, we could quickly go and have a review refresh, see our latest changes. So we configured in init task that runs NPM install, that happens automatically every time somebody pushes code to GitHub, the command exports the dynamic URL for our development environment URL. And then we start the server. If we see something on port 3000, which is our web application, then open a browser. We also install the Svelte extension for better syntax support in these Svelte files, as well as we configure prebuild so that they run whenever there is new branches or pull requests or changes to the main branch. Lastly, we updated the Svelte config. We created a vite configuration where we specified a client port and host for hot module reloading so that this works on Gitpod, as well as on localhost. This looks pretty good. We can now go and ready for review, ask somebody to review that for us, and then go ahead and merge the pull request. We don't need to branch, and we also don't need that environment any longer. So we can close that and close to preview as well And the docs. Good with that, we now have a fully configured Gitpod developer environment that installs everything we need, runs all the scripts we need as well. And we can move on with the next few tasks. And we want to do next is build the HTML structure of the application. So we've got an issue open already called develop HTML structure, before we get to that, let's have a quick look again at the UI. So what are we going to build is just heading the form fields, the lines for the individual items, no CSS, no functionality, we'll do everything at one step at a time. So stay tuned for more afterwards, but for now, just the bare bones HTML structure. In order to do that, we got an issue. So we're going to start working on that. And we learn about Svelte, we learn about different ways of using Svelte's functionality, so that if you're familiar with another framework, you can, maybe map the concepts between the two frameworks you know Svelte and whatever you're familiar with already. Okay, we have everything set up, that looks good. Our environment looks okay. And the first things first, that page here is our index page. We want to change the title so that it says todos, and start adding the HTML structure. Under source roots, we have the index Svelte file. And you can see now that we have syntax highlighting, that's because we configured that in the Gitpod YAML file. We said, please automatically install the Svelte extension. So back in the index file, we don't need the paragraph, that is not needed. The H1 is just saying todos for now, so that it maps the todos we have here. Now below the todos, what do we want to do is create that + tap to add a todo. That's really a input field of type text that's wrapped in an HTML form so that we can submit that eventually to a backend where we can then process it and persist in the database. So in terms of HTML structure for that first part of the user interface, we really just want to add a form, so we can use the form autocomplete here. It asks us to provide an action. We'll leave that empty for now. We also leave the method empty that you can see us has some options, we'll work on that when we start to build the functionality of the application to actually add and update items. So it's a form, and within the form, we want to add an input field of type text, because we will be adding the text of our todo into that field. We also want to give it a name, we'll need that in order to identify that text input in the request later when we submit it. So let's stick to text, we could name that anything, that's up to you, text for now does the job. We also want to add an aria label so that screen readers announced this input field and people who use a screen reader understand what this is for. So in this case, it's add a todo. And lastly, we want to add a placeholder. And if we look at the mockups, the placeholder we want to add is that + tap to add a todo. So we'll do that, + type to add a todo And we close that. So that's, you know, basically giving us the initial setup. If we look at the preview, you can see we have an input field with the placeholder. It doesn't quite look like the mockup yet, but we'll get to that a little bit later when we apply CSS to the application. Let's have a look at the mockup what's next. We're going to have a dynamic number of todoitems. We don't really know how many, and that obviously changes when we add and delete the items. So we'll have to somehow find a way to show this list dynamically. For now, as I said, we care about the structure, so there needs to be some kind of check mark here, some kind of text, now, also, when you click on one of those texts, we want to convert it into a text field so that we can type and update, the element, todoitem, and also some button here to remove the item. So that sounds to me like 123 different HTML forms so that, you know, when you click this, we can submit the request to the backend and check if that's done, same for the delete button, remove it, let's start, have a look at what it looks like. The elements are below the create a todo form. So we could come here and start writing the HTML structure. Instead, I think this is a good time to introduce you to Svelte components, just like any other framework, you can organize your code by writing multiple components. The way it works in Svelte, and especially in conjunction with a SvelteKit, is that under source, we can create a new directory and let's call this lib a new folder, lib, and within lib, we create a new file and we call this todoitem.Svelte. And here we are going to focus on one line item. And then once we built that, I will show you how we can include it in the UI. Very straightforward. The first thing we'd like to do is most likely at some point we'll have to style that entire row, so for example, when it's checked off, you can see there some opacity happening here on the entire element. So it's probably a good start to just wrap everything in a div here. And then the first thing is that a check mark here. So that's a form with some value inside. We can then submit later, so let's add a form, no action for now, no method for now, either. And then we'll add an input. The input will contain the value of the todoitem, whether it's marked as done or not, but we don't really want to show an input field for that. We could use a checkbox potentially, and you know, style that to make it look like a, make it look like a circle. For now, what we can do is just make a hidden input field. We can say type hidden and give that a name as well. In this case, we call it done and then a value. For now, we don't know whether it's checked or not. So we'll just leave it empty until we get to the point where we start to style the application. The next thing is we need a button for that circle with a check box. So let's add a button here, the value for the button for the time being anyway is that we can just call it Done/NotDone. Eventually we'll change that and use some CSS to make this better, but that does the job for now. We also want to make sure the screen readers announce this button properly, so we say mark done/not done. Then people know what's going on. Once we start adding functionality and we know which todoitem in particular, that we are entering, we will be able to dynamically update this text to show the correct aria label, whether to mark an item as done or not done. For now, we don't know that, so we'll make it more generic, and also that reminds us later that we have to update this. Okay, that is the form for this check box. Next we need to work on that text that's shown here. That's exactly the same concept so we can type form. We don't know the action yet, we don't know the method yet either. What we do know is that we want an input field of type text, and we don't know the value at this point, so just add that. And the other thing we want to do is, you don't see it in the mockups, but when we click on that to edit it, we want to show a little save icon right here next to the delete. This will help visually tell people that they have to click that button or hit enter, but it's not obvious that enter is going to save it. So we'll show a little icon here. For now, we'll add a button to just have a placeholder there and then deal with that later. So the button will eventually be the save button and as well here, we want an aria label called save todo that marks the second form and the last form over here is the one to delete an item. Same concept, again, we can probably start copy pasting some stuff here. So well, one day form, and we want to close that again. Action method, we don't know. What we do know is that we'll want the button here. That again for now, just says Delete. Once we use CSS, it will be a nice trashcan and aria label to tell the screen readers that this is to delete a todo. Very good, that gives us the forms we need for that element. Now in the UI, we don't see any of that yet. So what we have to do is switch over back to our source, routes, index.Svelte. And we have to import that component, that todoitem component we created, the way to do that in Svelte is very interesting and also extremely handy. So what do you see right now is pure HTML, this is no JSX, no, you know, library on top of HTML or anything like that. It's just HTML the way to browse that or understands HTML. In order to import a component in Svelte, you can add your scripts that are needed on this route or in this component particular right to the same file. So at the top, it doesn't have to be at the top, by the way, it could be below as well, but I prefer it at the top. You can add a script tag, that's a regular HTML script tag. And within that, we can say import todoitems. This is going to be the name of our todoitem component. And where do we want to input it from? One directory up, we are in routes, so one up and then lib, todoitem. That imports the todoitem, now it's not used, so it get a little notification here, but we can come down here and say todoitem, render one of them. We go back, you can now see that besides the input field to add a new one, we also have the Done/NotDone button, the input field to edit one, save and delete, not pretty, but it's all the HTML that we need in order to render an item. As you can imagine, adding three of them renders three todoitem lines. So I'm going to show you one more thing. If we were to move things around, such as let's say, we moved out todo application into like sub folders or change things around. What we would have to do is go and update the relative path that is used in our input statement here. So in SvelteKit, there is a convention where if we want to access anything in the lib directory, we can just remove the relative path and use the dollar sign. So a $lib, that automatically points to the source lib, you can see that up here in the tool tip. It points to the source lib todoitem as well. So it automatically replaces that. Now we can move that input statement anywhere in our code, and it will automatically resolve to the correct endpoint or directory here in the file system. So that's a neat little trick to help us load that todoitem. There's one more thing we want to do while we're working on the HTML structure. It's setting a title for the application. At the moment, if we inspect that and we go to the head, you can see that there there's some meta tags. They come from our source/app.html. There's some scripts, some styles, but there's no title. So remember if we go to src/app.html there's the meta tags I just showed you. There's no title, we could add one here, but then it would be the same title for the entire application. So in order to populate that dynamically created Svelte head, what we can do in our index file somewhere up here is use a special component called Svelte colon, and you can see there's a few of them. The one we care about right now is head, we use that. We can now put any HTML elements that are valid within the head inside of here and Svelte will dynamically populate that when the different pages load. So the element we want to add is title, and we want to call it todos. Now you notice that it already reloaded, hot module reloading kicked in, and the title now says todos. And if we update that and we save, then it immediately updates as well. So that's nice, but let's make an agreement that the title should always reflect whatever the H1 element is here. Okay, so that the H1 on the page maps to the title in the browser window, that's happening right now because we wrote todos twice. Fair enough, but if we were to change that todos title here, we would have to remember to also change it here. So I'll show you how you can use the variables in Svelte and reference them within the HTML. Let's create a variable called title. And the name for that is order value is todo by the way that name, variable name could be anything. It could be page, title whatever you want it to be. In order to use it in your HTML, we can select these two with command D or control D to have multiple cursors, so we delete the hardcoded texts. We use opening curly brackets, variable name, closing curly brackets. And now you can see the todo here and here, is still the same. If we were to make a change, then the browser updates, as well as the todoitem here. So this is how you can use variables within your HTML in a Svelte component. So we'll keep it like that, that's probably a good start. And it's a good reference as well if you want to update that later. Excellent, I think this is a good spot to declare that issue as complete. We did develop the HTML structure, that is all in place. Now this goes back to todo, and we can go ahead and commit these changes. I personally like to do a quick self review before I commit it so that, you know, at least I had another look at my code before I push it, make sure there's nothing obviously wrong that would just stand out. And then here, we want to call this, use the same develop HTML structure, commit that, yep. And we can go ahead and write from here, create a pull request. We don't need, quick update that a bit, structure, and we want to close issue number five, and we don't need to make it a draft, we are ready to go. So create published branch that will do the work for us, there we go. We are ready for somebody to review that for us. What we did was we updated the index file by setting a title, using the Svelte head to modify the HTML used within the head tag. And then we created a form for the creation of new todoitems. And we render a Svelte component called todoitem that we import from the $lib slash todoitem $lib is a naming convention that's configured within SvelteKit to automatically point to src/lib. This is our Svelte component for a todoitem, three forms. First one to mark an items done and not done, save todo and delete. So this looks very good. We can commit that and then move on and start to apply just a bit of CSS to make it more look like this so that this is a bit easier to work with as we progress and start to add functionality. All right, we go and merge that pull request and delete the branch. And as we were used to, we don't need our preview, we can close that. The same is true for our developer environment. We don't need that either, we are done so we throw it away. There we go. And that's merged. Issues are gone and we are ready to go and work on the next step. Okay, with all the HTML elements in place, we are now going to add CSS so that the web application looks like the mockups. If you remember, this is the end result of what we want to achieve and let's get started with that. So we have an issue, apply CSS styles, where we can start a developer environment and continue with our work. What are we going to learn here is how to apply styles in Svelte components. There's a few options, different ways. We'll talk about that. And basically the end result is we want to turn what do we currently have here, the unstyled todo application, we want to turn that into what we see right here in the mockup. Okay, switching over to our developer environment. We don't need any of these things at the moment, the server is already running, so we'll just keep that up and running. Maybe the first thing we can do is inspect the web application so that we can then look at CSS, different styles and keep an eye on what's happening. So with that, let's get started and apply CSS to this application. The first thing I want to show you is how we can use regular CSS files to style the application and use the styles that we add across the entire application so that we can put certain default behavior in place that applies to the entire application where like we define style attributes such as the font family or primary colors and things like that. So we want to do this by creating a CSS file under source. So let's say source and then new file, and we'll call this app.CSS. Okay, this is a regular CSS, there's nothing fancy about this. The first thing we can do is turn that white background that we currently have into more of this gradient approach that you see in the mockup. The way to do that is we target the body element of the web application. And for now we can just say the background color equals to a hash value is so B9C6D2, that could be, you know, whatever you need for your environment later. So with that, it's still white because we haven't actually loaded that CSS file, the app.css is an arbitrary name that I chose. You could name this file anything you like. So before we go any further, let's just make sure the changes we apply are actually visible in the developer environment. So in our case, we have a source roots index file. And in this file, what we can do is import the CSS file that we just created a little while ago, so if we go to the script, this is where we import the todo component as you remember, we can also import the CSS file, which lives two directories up. And there is the, oops, my apologies, it's one directory up and app.CSS. So with that, if we switch back to the todo application, we now have the grayish background. So that's one way to load the CSS file, now, one thing I want to show you is if we were to add a second route, so under source routes, new file, we call this about us just as a test and within the about us file, we create the header for now that we see, we changed the URL. If I were to switch to about us, it did not apply that change to the CSS background here. And that's because as you can guess in the index file, we import a file, we don't do that in about us. I could create a script tag and import the CSS file as well, but that would not be very scalable. So instead there is a special file we can create at any level within the roots tree. So if there were subdirectories, we could create more of these files and the file is called __layout So we within SRC/roots, __layout that Svelte this file contains code that applies to all the routes within the directory where it's defined as well as all subdirectories below that. So what we can do here is we can import that CSS file at the layout level, which then applies to about us and index and anything else within that directory or its subdirectories. So going back here, let's remove the CSS import from the index file. And in the layout, we are going to create a script tag and import that CSS from here. If we go back to the user interface, we noticed that the about us page now shows the background, but it doesn't show the title anymore. And the same is true on the index page, completely empty, but the background is there. So we need to render the content of whichever page we are on, whether we were on the route page or on the about us page. We need to tell Svelte to render the content dynamically depending on the URL. And the way we can do that in the layout component is by using what is called a slot. So SLOT as a component and now Svelte dynamically replaces line number five with the content of either the index file or the about us page, depending on the URL we are on. If we switched back, we have our style todos back and on the about us page, we have the title. All right, that is a good place to keep that. If we wanted to add additional HTML into the layout file that applies to the other files in the routes, we could do things like wrap the slot in the main HTML element, and maybe below we could add a footer where we say copyright, something like that. And then in the UI, the, if we were to, if we were to save that and then go back to the UI, we would now have the copyright here, the footer, as well as on the index page copyright as well. Okay, that gives you a good idea of how you can extend the application and share some code across multiple routes. As always the Svelte documentation at Svelte.dev c ontains a lot more information about the feature of slots and how you can use them in your own components to nest certain functionality, as well as how you pass prompts from the parent component to the slot and vice versa. For the time being we don't really have a footer, so let's get rid of that. We also don't have an about us page, so we will drop that as well, but we will keep the main and the slots so that we can use our CSS file back on the index page. Good, so we know we no longer need that and we don't need this index file at the moment either. Good, so this is a good place to be, to understand how we can load the CSS. Now, what do we want to do is apply a few more things to the website in terms of styling, we're not quite done. We are actually far from done, so back in the CSS file, what we can do is first of all, this color is our primary color that we want to use across the application. So in order to not have to repeat that hex value, we can use is pseudo element route. And then we can specify a CSS property here called primarycolor and use that hex value that we have down here to define the primary color value. And now anywhere in our CSS, we can, instead of copying that hex we can just use the primary color variable. So we'll do var and we use primary color, autocomplete makes that super easy. So in order to create the gradient that you see here, we need at least one more color so that we can specify the gradient from this point to this point in terms of the colors. But we are going to add two more, just so that we have three colors, so secondary color, and the value for that is D0DDE9. Again, these are just values I took from the example, but you can use your own brand colors. And lastly, the third one, tertiary color, and for that, we used the hash EDF0F8, nice. So this is not really a CSS tutorial, but just make sure the application looks all right, we'll apply a background and we can use the linear gradient for that, and just add a few values here. So we wanna rotate by 180 degrees and then use the three colors that we defined to specify how will we are styling this. So let's have a look here, and secondary. And the last one, there we go. Now, if we go back, we have the gradient that you can see. The problem is that it happens kind of three times, two and a half times. And the reason for that is that our body is not really spanning the entire height of the window. So we can fix that fairly easily by updating our body definition and add a min height of 100 view point height. And now if we look at that we get that gradient across the three colors, nicely applied. The other thing I want to do is see that marching on the left here? I want to take full control over that and not let the browser interfere. So one workaround for that is to just basically set a margin of zero at this level so that we can use our own margins eventually to apply here. Now you see there's aligned all the way to the left. Good, so this app.css file is a good place to define all sorts of global CSS properties. One more thing we could do is, all of that doesn't make too much of a difference, but just want to show you in case you have your own custom fonts, so we could specify the font family here, and I don't know, pick one or use your own. If you have your own font that applies as well to everything. Good, one other thing we want to do if we look at this page versus the mockup, the todo text is centered, and we can just agree now that this is a design decision that we want to apply to all the H1 elements across the entire project, once we add more pages, we want the same behavior. So again the app CSS is a fantastic place to configure that. We can say H1 and text align and then make this center as well as just specify a font size of, let's say 2rem. This then applies a cross the board and makes all our pages look the same, exactly same. And just because we are here, if you wanted to apply a media query or really any CSS, because that's just a regular CSS file, there's no special use case or anything. We can use media queries as well, if we were inclined to do so. For example, we can change, if we had a min width of, let's say 720 pixels, we can apply a different font size, for example, for the H1, as you know, something for you to work with. So anything you can do in CSS, you can do here. It applies to the todoitem depending on the media query that applies. Okay with that, we learned how we can apply CSS across the board. Now for the styling of the actual todo app here, so the different rows, the opacity here, the margins, all these things. That is CSS that we don't want to apply to all the pages, right? The todo application may live on one URL maybe slash todo or something like that, and we only want this CSS to impact that one component, which also means that the browser doesn't have to download that CSS for every page the user navigates to. We only want the browser to download that check mark, for example, when a user actually looks at the todo application, so with Svelte, the way we can do that is straight in a Svelte component, we can write CSS and make sure that this applies only there. So let's have a look at the index file under source route. So we don't need the global CSS file anymore, but under source, roots, index.Svelte, we can, besides the script and the HTML, we can add one more thing. And that is a style tag. So a regular HTML style element, and within this, we can use CSS to target our element within that component. For example, if I were to target a form like this in regular CSS, if it's in the app.CSS file, anything I put in here into that definition would apply across the board, across the entire application. Because I'm specifying this style element within my component or my route here, anything I put here, even though I use form like this as an element, it only applies to that form within the component. So any CSS is locally scoped to the component, which makes it very easy to reason about what happens if I change anything in this form definition, it will not impact anything outside the component. Super easy to make changes down the road without worrying that, you know, you accidentally may have broken the form layout on a different page or a different part of the application. Now we are not gonna target the form like this, but I wanted to show you how this works. What we are going to do though is basically wrapped the entire application in a div just so that we can target it and apply things like centering of the element and things like that. So let's first create that div here and then move our entire application inside of that div so same code as before, but wrapped in a div element. Now let's give that a class, so class todos. And now within the style element that we defined here, we can target that todos div and apply CSS. The few things we want to do here is we want to specify a with of 100%. We also want to limit the maximum width in case somebody has an ultra wide monitor. We don't want this to stretch all the way from the left to the right. So let's set a max with of 42rem because you know why not 42? And let's put a margin around of something like that to center it. And with that we can switch back and you can now see that there's a much bigger margin. And if we inspect that part of the application where we have our todos, you notice that there's no margin at the top left and right. And if I was to change the size, this moves along and the margin adjusts accordingly. Okay. One thing you do notice is that Svelte created its own S dash class name. This is just so that we Svelte can uniquely target that element with CSS so that nothing we have to worry about it just happens under the hood for us. All right, the next thing we want to do while we're here is we want to target that new input field here. And as you see in the mockup, it doesn't really have a background, so, or a border or things like that. So let's go back and define the dot new class. And right now, Svelte is telling us that there's an unused CSS selector. And that's because we specified a dot new class here, but we actually didn't use it anywhere in the HTML. There's no new class anywhere applied. So this is a nice feature of the Svelte compiler telling us that, Hey, you have this element here, but it's not used so you may as well delete it and save the browser from downloading a few bytes by not having this definition. So that will come in handy, you'll see the benefits of that once you start refactoring your application, you may move, let's say that form somewhere else and forget to include the CSS. Then you will get that warning and you can move to CSS along with the form so that everything continues to look the way you want it to look. So what do we want to do for the input field here is first of all, just add a bit of a margin here. They are a bit too close together, and that's easily done by first of all, going to our input field for the new todoitem. And we have that wrapped within a form. So we can target that form either with just form, or I like to be a bit more specific and do use a class name, and call it new. And now we still have an error, but it's only telling us that please don't use empty rule sets, it recognized that we have a class with new so that warning is gone. And then what we want to say is just margin here, tiny a bit of margin at the bottom that applies nicely right there. Good. The other thing for the element, the input element itself, we can target that as well by creating another class so dot new, and then within that new form, we target the input element like this and that then applies CSS for that specific element. What we want to do is a couple things, first of all, it's a little bit bigger than the rest. So let's say font size 28 pixels, and then we want to stretch it, stretch it all the way and give it some padding, such as, oops, sorry, 1em, 0.3, this is, the values here, you know, I'm not making it up, that stuff that's in the default template. So since we're not really focusing on the styling part, we can freely copy that and apply, so basically let me add all that in one go. It's a bunch of things that apply only to that input field within the new class. So now this looks a lot closer to what we eventually want it to look like, but we do notice it has this border around it. And so do all the other elements when you select them. We want to get rid of that, and we want to get rid of that everywhere in this form. We could add the CSS to remove that border to the app.CSS file, and then it applies to all the input fields across the entire application. For the purpose of this course, I want to introduce you a concept in Svelte where we can target all the input fields in the current component and its children. So let's look at this structure real quick. We have an input element here, and then we have input elements within the todoitem. Remember under source, lib, todoitem. We have additional input fields. So if I were to come here and let's say up here, well actually after the new makes probably a sense. If I came here and I would just say, input the styling of that input class would only apply to this input not the children because of the local scope that I explained earlier. However, Svelte does allow us to target this one input here and the ones in the components used. The way we do that is we limit it to that todos class or that element here. So we say dot todos. And then instead of just input, we have to use a Svelte specific configuration, so global input. Now that means target the dot todos class. So this element on line 35 and then globally within that, all the input fields, that's how we can apply styling to that input and to the todoitem inputs inside. What do we want to do for these items is remove that border. So border 1px solid, but we make it transparent. And if we go to look at that, that border disappeared, and if we click, we still get the blue border around it. Same here, same here, but the other border disappeared, we can fix that in the same way as we did here, just that we have to use a pseudo element saying that target that element when it's focused. So same thing to start with, but instead of targeting the input only, we want to target its focus visible state, and then the values we need there again, no need to type all that. This is not the main purpose of the course. We'll add a bulk shadow, bit of border in red and outline none. If we look at that in the user interface, we now get this red border. So we know that's the element we are currently typing in same here, automatically applied to all these fields. With that, we styled everything we can in terms of the new input field. It's now time to move on and style each individual item so that instead of having these buttons and all that, it turns into this nice one row with the important stuff that you see in the UI. For that, we switch to source, lib, todoitem. And over here, this is where we can start applying the exact same concept as we did in the index file, where we create a style element. And within the style element, we can create definitions and target the different elements that we have. So one note here, even though we define the style element at the top, we could define it at the bottom if you prefer that, there's no order required. Script, style, and HTML, you can order these three within a Svelte component in whatever way you are most comfortable with. Good. Let's do a couple of things before we apply the styles. First of all, let's use some class names so that we can target individual elements. First things first, the wrapper div for an individual line item, let's call this todo, and then we need to target that button so that we can turn this Done/NotDone button here into a circle with a checkbox. So this is the button here, and we want to target that with a class. Let's call it toggle. Next thing we want to target the form that allows us to edit a todo item and save it. So we can call this class, stick to the same name as we already used for other purposes, so text. And we also want to target the button, which will turn into a little save icon when somebody clicks in here. By default, if nobody clicks, you see nothing. If somebody clicks on the text, then that save button turns into a little icon. So we have to target that, and the way we do that, as we add a class name here and we call it save. Lastly, we need to target the delete button. Let's give that a name, delete, and then let's start adding the CSS required to turn this all into a nice line. All right, first things first, starting with the todo wrapper, so todo. For that, we use grid, but we could just equally use flex if you're more familiar with that, I'm going to paste all the CSS in here. Again, no need to go through and describe all that. But it's basically just applying a few styles so that things look like the way they do in the mockup. But there's great CSS courses out there that dive into a lot of more detail around this. So have a look what we got, everything is now aligned on the single line, so that's a good first step. Next thing you want to do is focus on that button over here, and actually all of the buttons, because we can, we can apply since they're the same styles to all of these three. So the way we can do that is target the todo wrapper and then all buttons went in, so all three. And for all these three, we want to specify just a couple of things width and hide the same number so that we can apply a background position, 50 50%, which makes it a circle, remove some colors and make sure we don't repeat any of the background. If we have a look, that gray background that the default button had is gone, we still have the text. We'll drop that as soon as we have the icons ready, and that will start to look a lot better. Buttons look good. The next thing we want to style are the input fields, so input. And for that, we only have really one input in this case that's visible, this one, oops, the input here is hidden, but this input is visible, so for that we use flex. And then we'll see why that is as soon as we add the image. Not much changed here until I click, you can see that edit field eventually. Next up, let's go and focus on the toggle button. So two ways I could say dot toggle, that would target that specific button. Alternatively, I can say, I want to target the button with the class toggle, really up to you. We can do that and give that some CSS here. Oops, in here. Now, if we look at that, you can see not much changed yet because we don't have the image yet. We'll do that very shortly. Next thing we want to do is target the text down here. So let's have a look. Oops, there we go. I want to say dot text and the values for that, paste them here. Okay, now this is giving us a lot more space because we are applying that display flex and flex one. We now have a lot of space to type and edit our todoitem eventually. Good. Next up is the button for the save element. So the right here, save button let's replace that text. So for that, we remember we have a safe class, so we can target it with a definition like this. And the content, we can paste. I'll talk about it in a second here. So what do you see is that opacity is zero by default, which means we don't see anything at the, by loading the page, and the background image is just a SVG that is inlined within that component. The reason for that is that this is such a small SVG with so very so few characters. It is probably more performant to include that here rather than downloading an external SVG file to display. So if we look at the page, you can see that we don't see that save button anymore. If we inspected, it is still here, dot save capacity is zero, so if we get it back, we see the icon. We also see the safe text that's because we had a placeholder there, we no longer need that. So we can delete the text of that button. So now if we inspect that one more time, we can uncheck the opacity and we see the icon. So what do we want to do next is when the input here is focused, we want to show that icon like this, but only when we have to focus on that input field, if we don't have to focus, then we don't want to show that. So CSS allows us to do that in a fairly easy way. And basically what we say here is that we want the, we can, we can do this. So to do within that element input, focus, then target that. And what do we want to do is a little bit of a transition so that is a bit smoother, let me say opacity 0.2 seconds. And the other thing we want to do here is the opacity itself, we want to set it to one. Now let's have a look. If we click on it, you can see that this slowly appears, well, it's not very slowly, but you can see that the icon appears with a slight delay, same here and here. Now there's one more thing we want to do. If somebody manages the application with their keyboard or uses the web app with their keyboard, when they load the page and they hit tab, it goes into the input field to create an item. If we hit tab again, we go to the done button. One more time, we focus on the input. And you can see the input focus is what we just specified. Now the problem is if we tab again, the focus now is on the element to edit, but because the focus is lost on the input field, we also lost our edit icon. So we can easily fix that by just adding a second definition here, which is if the save button has focus, then also show the save button. So now if we do that again, we come from here, tab, tab, and one more time, now we still see our icon. So people can use the keyboard to navigate this application, which is extremely important to make sure this works. All right, lastly, let's go and focus on the delete. So the delete icon is a image, just an SVG, again, we're going to inline it like we did for the save icon and we it an opacity so it's not too strong. If we look at that, you can now see the delete icon. It is a little bit, almost invisible. What we want to do is remove that delete text. We no longer really need the placeholder because we have the icon. We do this, looks better. And now a nice touch here is that if we mouse over the button, we want to kind of pop it and show it highlighted. We don't see it in the mockups. And just so people visually can see that the trash bin can be clicked. And the way we can do that is we can focus, create that delete and on hover and again, thinking about people using the keyboard. Also when it is focused, then same transition as we used for the edit icon opacity, 0.2 seconds. And we want to show it at its full opacity. So with that, if we mouse over, that becomes fully visible. If we use the keyboard and we go and select the trash icon or focus on the trash icon, it also becomes a capacity one. So the only thing that's left is the done, not done button. And let's add that last. The reason it's last is because until we actually know whether an item is marked as done or not, we don't really know if we should show the checkbox or just an empty circle. So let's add the CSS and then we will comment it out until we have the functionality to make this work. All right, at the bottom, targeting that Done/NotDone item the way we do it is we have a, we have a sorry, class called toggle here. This is how we can target that specific element. Let's go to done toggle to target that specific one. And let me copy the background image for that checkbox, just so that we can have a look. Again, we don't need to text, since we now have an item or an inline SVG. Now, one thing you see is I used to classical done, so let's just drop that for a second and just start with toggle. Assuming that every item is toggled by default. We now have the check mark for that. Now, whether or not the toggle is on or off, we don't know as I mentioned, but eventually we want to show that when it's checked,. So at some point when we have the functionality, we will basically just add a dynamic class here called done. We will do that programmatically when we know which item we render, and then when it's available, then we want to do certain things versus others. So for example, that checkbox, the total. We only want to see it when that class name eventually gets added here, so for now let's rename that to dot done, and it's still here. But if we render the UI and the done item is not set, so if it's not checked, then we don't want to show the checkbox. All right, the other thing we want to do The if you look at the mockup, that entire row, we want that to be with an opacity of, you know, almost zero, so that it's kind of like blurred out. The way we can do that is we can just target that done element, so if we do done for that entire row in here, we can say, oops, we don't want to transform. And we want an opacity of let's say 0.4 and we'll give it a little bit of a drop shadow to just match the mockup. And then again, if we add this done back, what we have now is you can see the little, how do you call it, opacity, 0.4, blurring that out. The last thing we want to do is I noticed we forgot the circle, so let me have a look at what are we missing to get the circle to show up. I think we added the, where was it? We did add the toggle here. I think that doesn't get applied, one second. I'll do some live debugging here. Order none, uhhuh, okay. Let's just hang on, we'll figure this out. There's certainly something missing. It does have a border one pixel that shouldn't matter, oh, there we go. All right, we got that. We got that back by being more specific about that. All right, all good. So with that we have everything in place to either mark this as done, not done, but for the time being until we know when an item is done, let's remove that. And because we don't have to done, the compilers telling us that these classes are unused. So we will comment this out just for the time being, and also leave a comment here so that we don't forget to bring that back. once we have the API endpoint to tell us whether an item is done or not. So todo uncomment when the API endpoints are available. Good. So we're back. Everything looks as if it was not marked as done. We can start adding text. So with that, we looked at two ways of using CSS, whether it's through an app.CSS file at the, at the root that applies to the entire application or whether it is within a style tag right here in the component where it is scoped to that specific component. And with that, we can go ahead and make the change, we can commit these changes. So set a quick review, todoitem, we did a bunch of stuff here to make this all look good, added some class names, the layout, and remember that a wrapper around all the routes within the directory, where a file is specified. And we import the app CSS file here. And lastly we added some styles to the main file so that we can style the UI. So that looks okay. We seem to have the functionality in the UI for that. Go ahead and commit that by saying apply CSS styles. We committed, yes. That looks good. Now let's have a look up here, we have the issue. We don't have a pull request yet, so let's have a look what is going on here, if we publish the changes. Nope, we don't want to do that. If we go to pull requests, we'll go through this UI for this time. We don't need any of this. Close issue number seven, just double check, yep, looks good. And we see create pull request. And with that, we have the application fully styled. All the code is here, we remove the text we no longer need, looks good. We can go ahead, and you know, in real world, we would ask a colleague to review. We go ahead and merge this confirm. We no longer need the branch. We also don't need our preview environment as well as the developer environment. That is a thing of the past, stop workspace and get rid of it. That's a pretty good spot to be in. So we're going to move on and look at what are we going to build next. We now have a web application that looks pretty good, but it still doesn't do much. It has no interactivity in terms of adding or updating any of the items. Before we add that, let's have a quick look at the architecture to remind ourselves where we are. We have to developed the front end UI with Svelte and we leveraged SvelteKit to run the dev server and help us parse the URL and load the correct content. What are we going to do next is develop the API so that we can send requests to the backend, parse the data and persist an item, for now, just in memory, but at least we can then play around with the user interface and see all these things working together quite nicely. As always we have an issue created, it's called develop CRUD endpoints and watch I've defined here are four sub tasks in order to satisfy this issue, so we will need a post endpoint. So HTTP method of post on the slash todos.JSON endpoint. This allows us to create an item, a get endpoint at the same URL to load all the items that exist in the array for now. And then we want to delete an item. The path for that is todo slash the random user ID of the given todoitem dot JSON, as well as a patch endpoint. We will need that to mark an item as done, as well as to update the todoitem's text. So with all that in place, let's start with the post endpoint so that we can then go to the user interface and create a new item as a first step. So we're firing up a Gitpod workspace for that specific issue. And then we will learn about API endpoints that are provided to us by SvelteKit. There we go, we have our newly styled web application. Let's inspect it so that we can start do some debugging there. We are not going to use much of the elements inspector today, so we'll switch over to the network tab, which is what we are going to be using a lot more to see what's going over the wire from the browser to our backend. Back in the editor, we can start by having a local where we have to put our files in order for all that to work. As always, I want to quickly show you under kit.Svelte.dev/docs. If you want to dive deeper into the topic, you can see under rooting, there's an endpoint chapter, clicking that gives you all the details you need to know in order to build an endpoint. The most important aspect of that is that each file that is used as an endpoint will have to export certain functions, that map to the HTTP methods that we want to use. So in this case, this is a get endpoint. We can explore other ones as well to do post, patch, delete. We'll see that as we go through, but if you want to dive deeper, this is definitely a fantastic piece of documentation here to go read about that, as well as the chapter about body parsing, which I will talk to you when we start to use it. Okay, so, first we need to understand what endpoints are. At the moment we have the source directory and then routes, in here, we have Svelte files, so index for now, we previously had a file called about us dot Svelte. Whenever SvelteKit sees a file in the root directory or its subdirectories that ends in Svelte, it becomes an endpoint, which it becomes a URL that renders a page. So in our case, this is the route page, maps to this file. If we want to expose an API, we can do so by creating files also within the routes directory that end in dot TS for TypeScript or dot JS if you use JavaScript. Now SvelteKit is then smart enough to determine the file ending and parse the file differently and the behavior of that will be different too, but it does use the roots and the file system here to determine the path of our API. Now, if you recall, in our issue, we specified that we want a todo slash JSON endpoint to post our item. We can copy that todos.JSON, and under routes, we want to create a new directory called todos. We could call this API slash todos. We could call it whatever we want. Let's just pick todos for the time being. And within that, we want an index file because we want a todo.JSON so we can do right click, new file, index.JSON.TS for TypeScript. And within that file, we can now create an endpoint that replies or response to a get request. So bear with me, let's create that. And then I'll show you what we did. So we can say export const, get for an HTTP get request. That's a function. And for now we'll keep it very simple. What we have to return from this function that's defined in the documentation is basically an object that contains a status code. So let's call it 200 because we want to show whenever it goes, okay, as well as say body, in this case, we can say hello from the API. So let's go have a look. If we go the URL and we go to slash todos.JSON. Todos.JSON exists because we created a todos directory with an index file. So SvelteKit automatically creates a todos.JSON URL. If we hit enter, we can see that the response is hello from the API. And if we look at that in the network tab on the right side here, let's have a look. We can see that the headers or a get request and the status code was 200. That's what we specified in our code. So that is the simplest endpoint that you can imagine. It doesn't do anything as you can see, it just returned some texts, but this is what we eventually need in order to return all our todoitems, as well as to add new ones. So in order to do that, let's start by first learning about TypeScript and how this can benefit us in this situation here. So the first thing you noticed when I created that is I had to type all that by myself. It didn't actually do any autocomplete for me. So let's for now just add a line at the top here, and I'll explain what this line does. So if we say import type and request handler from SvelteJS/kit, this is importing a type, a TypeScript type called request handler. Now what that request handler does is it contains a lot of information about that function, what parameters it gets, what returned valued, expects, and all that. So we can come here and this is now TypeScript, so if you have a JS file, then that will not work. What we can say that get function. I want to annotate it as a request handler. And now if we remove these two items, copy this because I'll need it again. If we do that and I use autocomplete control space, it is now offering me the properties that are allowed in this return object. So this makes developing a lot easier because now I can just say, all right, I know I need a status and I want this to be 200. What else do I have, a body, hello from the API. So TypeScript really just gives us some pointers and suggestions and helps us write more robust code that follows the specification. So we'll do a little bit more of type of the TypeScript definitions for our own code in just a bit. But I wanted to give you an idea of some of the benefits of using TypeScript. Again, if you don't use TypeScript in your project, just drop this and the import and everything else works exactly the same way. All right, so we're going to leave this for now, but if we look at the issue, we agreed to work on the post request first. So let's do that. We can create the post endpoint just exactly the same way we did the get. So we can say export const post, and that's also request handler. It's a function and it eventually will return some stuff. We'll work on that in a second. Okay. Now there is one more thing we can do, and that is a parameter that's being passed in here to our endpoint, one of them is called request. If we specify that, then we can leverage TypeScript again to give us some information. So let's talk about what we want to do. When we are on the index page, let's go back to look at our application. We want to type something in here, like first issue, or first todoitem. And then we want to hit enter and send that data to our backend API and then read it from the request and persist it, okay. So what we can do is the request handler, which gives us information about what's coming in the request and what we have to return comes in handy here again, because let's say we want to print just so that we can test this before we do any more work, the request, and you can see it gives us some suggestions, what the request provides, there's a body, there's a bunch of other things, we currently care about the body, which will be the content of our todoitem here, whatever we type we want to read from the body. So request.body., and then we don't have any more details here. Now there's one more trick we can do with TypeScript. And that is the request handler. We can use a few more details. So this is getting a little bit into the nitty gritty of TypeScript, but basically bear with me. We can use the less than and greater than symbols. And what we can do here is not worry about the first argument, so ignore that, just an empty object. But then here, we can say FormData, and I'll show you in a second where that comes from. But now if we, if we do a dot here, we basically taught the TypeScript with the second parameter here, what is the type of the body that we're dealing with. And it's saying FormData. Now it gives us different functions so we can call here. One of them is get that we're going to be most interested in. And if we open that, you can see that it expects a key. So let's have a quick look at mdn FormData. If you search for that, you will eventually end up here. And the FormData interface provides a way to easily construct a set of key value pairs representing form fields and their values, interesting, form fields and their values. Let's have a look, in our index file, we have a form for the new item and we have fields in here and remember that name equals text. So what that means is if we submit that form to the post endpoint that we defined, we will be able to access that text property here. So from the body, we want to get the text. That text maps to that text, if I rename this to item name, for example, I would have to map this one here as well. For now, we'll stick to text. We'll read that text and we eventually will return it, so oops, I don't know where that comes from. Nevermind. Maybe if we close it reopen. All right. So let's see, we have a post endpoint. How do we send data to the post endpoint? With the get endpoint, it was easy, we could just use the browser to access the URL because the browser sends a get requests by default. For the post request, well, we can use the regular HTML form, which is right here, interestingly enough, we have a form. The action attribute here is the URL that we want to target. So in our case, it is todos.JSON. As you remember todos.JSON is this file. Now we want to target the post endpoint. So we can say the method, which refers to the HTTP method that is being used, we want this to be post. There's a lot going on, so let's have a look. We'll clear up some stuff here. And we come here and we submit that form. So if we hit enter, it gives us a 404. Now let's have a look why this is happening. We are calling a post endpoint todos.JSON. Say, if we look at the request itself, it's getting a little bit small, but you can see that endpoint todos.JSON post endpoint 404. And if we go to the bottom, we have, see if I can find it, oh, it didn't work because we have a 404, okay, let's fix that first. So 404 happens because we did not return any object from here, remember here, we had a 200. So for now, let's say we want to return a status 200 in a body that maps to whatever we send in. So let's copy that and paste it here. So whatever item name, or item value we put, we'll just return. If we go back and go to the index page and one more time, say first we submit, you can see that we ended up on the todos.JSON URL and the server returned first. If we go back and we say, second, now it says second. So we know that we can send a value in here read it from there and do something with it. Another one to remember is if we don't return an object from here, the default is 404, not found. So always make sure you have a return with the correct status code. Good. One thing that I don't like is the fact that we end up on this todos.JSON endpoint URL. That's really not userfriendly because we don't want to navigate back to add another todoitem. So what we can do is deal with that. The reason this happens is because that's the default behavior, when you submit an HTML form,. In our case, we can deal with that quite easily, so instead of doing 200 return or response code, we can use something called 303. This is a special HTTP code used to tell the browser that we want to redirect after submitting a form and what we have to do, we don't have to return a body because the browser doesn't care what was submitted, but we can return a headers object and within that, because it's a 300 redirect, response code. We can say location, back to our page. In this case, we want to go back to the root page. Let's see what that does to our user experience. We start at the root, we add our first item. We hit enter and we're back here. We didn't even see the other page because that other page never loaded because we gave it 303 return code. That brought us back to here. So that's nice. Now the problem is we don't see the item and that's obviously because we didn't do anything. We just locked it in the console. So if we scroll down in the terminal here, you can see that printed here. So the server side console log shows up in the terminal here, and we need to do something with it for now because we don't have a database yet, let's create an array of todoitems and we make this in array, voila. And also we don't really want to keep that, so let's say todo, persist in database. Once we have a database, we will come and replace all that to persist it over there. So in here we can now say todos, push and use, oops, let me just copy that, that'd be quicker. Requests body get text, that's the value of the todo we create. So todos push that text. And now that means every time we create an item, we add the text of that item to the todos array. With that, we can know the change our get endpoint, instead of returning the hello from the API, what we can return is all our todoitems. Very nice. If we go back and we add first and we add second, and now we go to the slash todos.JSON endpoint. You can see we get an array first and second. All we need to do is when we load the index page, before we rendered a component and before we even returned anything from the server, the server has to call that todos endpoint, to fetch the existing elements, and then render one line per todoitem and then return all the HTML to the client so that the client doesn't have to make another HTTP request to fetch the items. This is called serverside rendering and SvelteKit makes this super easy. Now, before we do that, we probably need to persist more than just the string. Somehow we also need to know whether the item is checked, so mark this done, and we also want to probably keep some kind of date as to when it was created. So let's make this change first, and instead of persisting, just a string here, we want a persistent object or a todo item. Now, remember how we use TypeScript here to help us navigate that code and implement autocomplete? Right now the todos array can persist a string, but I could also, let me just show you that real quick persist an object with a property text, that would work just fine. So this is okay, but we can do better. We can use TypeScript to help us and ensure that we only persist the correct type into this array. How does this work? Just like we used a request handler, we can create our own type for TypeScript, and then say that in this array, we only want todoitems. So how do we do that in SvelteKit? You notice there's a file under source, SRC, global.d.ts If we open that up, we can define our to do type right here and it will be available to us across the entire application, hence global.d.ts. D stands for the TypeScript Hence so what do we want to do is we can say type, it will be a todo type equals, and don't get confused by these brackets. This is not a regular JavaScript object, it's a TypeScript type definition, so we want a created at, and that will be a date. And we want a text, which is a string as well as a done, which will be a Boolean. This is probably a good start to kick things off and allow us to specify what kind of type we want to store. So now, if I say that the array of todos, we can use to type here and say that, Hey, I only wanted todoitems persisted in here, and this is an array of those. If we mouse over, you can see that this is an array of todo types. Okay? So that's good, and you immediately notice at the bottom, it is complaining now. And if we mouse over that error, you can see that type text string, which is our text request body get texts, this line. So that type is missing the following properties from the type todo, created at and done. Interesting, let's have a look. If we were to use autocomplete, huh, that's cool. It is telling us that there's two more properties that we need to specify. One is created at, and that's just a new date right now. And then I think there was another one. Let's do that again, yeah, there's done as well and done, when we create the new todoitem, then done is false to start with. Now TypeScript is satisfied because we are now creating a proper todoitem with a created at, a text and a done, it's no longer complaining that we cannot push that into the produce array. So this is pretty good. Now we know whatever element is in this todos array is of type todo, and it has three properties defined. We're making good progress. What's still missing though is the fact that it's not actually showing our items. So as I said, we need to load all the existing todoitems when we request that page from the server. We can do that in the index.Svelte file. What we have to do is, and that's well documented in the SvelteKit docs, but besides the script tag that we have, we have to create another tag, another element. It's also a script, but it is a little bit more special than that because it has context equals module. So this is how you can differentiate the two. Every time a component gets rendered, this script gets executed and the script module only gets executed once across all the instances, but this is the place where if you're familiar with like Next.js or others, where you would call, like get the initial props or places like that, where you can fetch data from the server before the component is rendered, this is what we want to do, and because we're using TypeScript, we can tell that script that we will use TypeScript within. So we can say language is TypeScript. The convention here is that we need to export a function called load that SvelteKit will automatically call as part of the server side rendering. So let's export that function, const load a regular function. It's a good start. And we want to leverage TypeScript here as well to help us with the parameters that are being passed in and kind of the return values we have to specify from this function. So at the top here, we can import a type and it is called load. We grabbed that from the SvelteKit package, and then we can annotate this load function by saying load and just like that, we can now see what we need to return. So if we say return and we use autocomplete, there's some error, maxage, props, other stuff in here. So eventually we'll specify the right things here, but thanks to this TypeScript type that we specified, we are not able to see these autocomplete items. So one other thing we want is at this point, this is where we want to fetch the data from the backend API, right? Remember from the slash todos.JSON, it's empty now because we restarted the server automatically when we made code changes there and our array got erased from memory, but we want to call that endpoint, get that array, and then render each array item in here. Okay, the way we do that is we get an object as a parameter. And one of the values in there, or one of the properties is called fetch. If we use that fetch, not to confuse that with the regular fetch that you get in the browser, this is a special fetch that's provided by SvelteKit. So always make sure you use that. This is where we can now call that endpoint to get and fetch our todos, so fetch slash todos.JSON. And this is an async call, so it's returning a promise. So let's change our function to async and then leverage a wait here. So the response is a wait fetch. Now, if the response is okay, again, you can see TypeScript helping us here, if it's okay, then where you want to convert the response and get these todoitems out of it, so todos equals await, JSON response there. Now that array contains the same elements as that array because we return it as part of the party in this get request, which we call with the fetch function here. All right. Having these todoitems, we need to pass them to our component, so that down here, instead of rendering three static todoitems, we want to render X amount of todoitems, depending on how many have been added to the array. So if we use TypeScript autocomplete here, you see one property is called props, and that's exactly what we want to do. We want to use the props to be passed into that component here. So props is an object and we just want to pass in the todos which creates a todos property that is being passed into the script. So we can come here and I'll teach you how to do props in Svelte. The way it works is the syntax for that is export let todos. That gives us a prop called todo that's exported from this component so here is where we specify the props we want to pass in down here. You can see that it's complaining that we don't have type defined. So we actually have the to do type right, that we created in global.TS. So we know that this property is going to be of type todo, so we can say, this will be an array of todoitems. And because we know using TypeScript, we have to let the script know that we use TypeScript. All right, that was a lot, but basically we exported a load function that executes on the server when we do a full page refresh, which is currently the case. If we were to navigate from one page to another, then the client side would, the browser would call this load function and do a client side fetch. But in our case, because we always refresh that page, ignore that error, because we all just reload the page, that fetch actually executes on the server, the load function, and then calling fetch. So we go grab that and we return if everything is okay. We passed the todos array into here, and then we currently not using it anywhere. So it's giving us a little warning. We will do that in a second, but before we move on, let's deal with the error case in case something goes wrong with our fetch, what we can say is if the response is okay, we return, so that means that down here on line 13, the response was not okay. So what we can do is we can fetch the message and we do that from await response, dot text. So basically, oops, that should be JSON. So basically whatever we get back from the server, it will contain a message object, we haven't built that yet, but that's just preparing us for later. And then what we want to do is we don't want to return props because if we return props, we indicate that everything was okay, so we can return an error. And that's just a new error with the message that we receive. The nice thing about that is that if we return an error then the SvelteKit will automatically render an error page instead of our component. Alrighty. We now have the todos array that contains whatever elements are in the array on the server side. Now we have to use that to render todoitems depending on how many we have. So basically we need a for loop or in Svelte's case, an each loop. This index for that is that you use the open curly brackets, hashtag each, and then you specify which array we are iterating over. So that's our todos array. And then what's the variable name of the individual todoitem of this array, so as todo allows us to access to individual item from the array, with the variable to do, and then to close it, curly brackets slash each closes the loop. Now it's telling us this is an empty each block, please don't do that, that's fine we can have that todoitem render and we do not need these other two items we have there. Let's have a look. Nothing rendered because we have nothing added yet. We go to first. And we now have one item in the array. It doesn't show anything, and I'll show you that in a minute, how we fix it, let's do another one. Two items, nice. It doesn't show any texts or anything because we still just render a todo item that if we look at the details under source lib todoitem in the HTML, it doesn't literally do anything, it's all empty, that's why we just see two empty elements. So first things first, we need to pass this todoitem into the component. And remember in Svelte, export let is how you specify a prop so we can do the same for the todoitem. So up at the top, we don't have a script yet, we add script. We also want to use the TypeScript here. So language TS, and we say export let a single todo of type todo. And we get a warning because we're not using it yet. That is changing right now. The only thing we have for now is the text property, remember in the API post, we set the created at, which we don't display in the UI, where you set a text, which is the value we entered and had done, that's false, in the todoitem. We can now go down to this section here where we have a text input field, and now we can say value equals and then just like in the index where we used curly brackets to access a variable, we can do the same here and say todo and dot text because it's a string. With that, we can go back and in the index file, we now see that this is complaining, saying that todoitem, and that's because we use TypeScript. It's telling us that it's missing a todoitem. So we can just come here and say to do prop is this specific todoitem here in Svelte. Since the name of the variable and the name of the prop are the same, we can use a shortcut and just basically drop this and say curly brackets todo. That will pass in that specific variable. And now you can see, we have first second. If we were to add third, we would get third it as well. Now, keep in mind. The way this currently works is that every time we add an item and hit enter, you can see that there's a lot of requests. That's because we first sent the request to the todos endpoint where we get a redirect to the homepage, and then the browser reloads the entire page and all the development stuff, hot reloading loading everything. What that also means is that what we just built works even if we disabled JavaScript, let's have a look. In our developer tools, we go to settings, we scroll down to the debugger section and we say disable JavaScript. And if we come here, we reload the page and we add a fifth item. That's still a works because all we're doing is we're using HTML forms and a post submission. So there's no JavaScript involved at all. We will later improve this so that if somebody has JavaScript enabled, we will just send an Ajax request and not reload entire page. But for now it's really interesting to know that the application works even with JavaScript disabled. Alright, we built a lot and there's a lot more to do, but I think this is a good point to commit the changes, because if we look at our issue, we already created the post endpoint as well as to get endpoint, they are done, so it's probably a good time to commit that so we can check these two off before we move on to building the delete functionality and then the patch to update the items. Okay. So quick review, we created the new type called todo that has three properties in the API. We created a new index of JSON.TS files under source, routes, todos. This is where we have a get endpoint that returns whatever array elements we have in that todo array. We also have a post endpoint where we create a new todo item every time somebody sends a post request, we read the text value from the body, and then we redirect back to the homepage to get that experience of adding an item and then seeing it displayed in the UI. Okay, that's a good start. What are we going to do next is in the commit message, we can say that we add get and post endpoints. We can go ahead and commit these changes and create a pull request that, let's use a better title, develop CRUD endpoints. And here we say, we want to close issue number nine. We are not done yet, so we make it a draft. There's two more endpoints we have to implement, but this is a good start, publish, and with that, it will have added that CRUD endpoint. So let's check this off. So our team members know what's the status. We can switch here and we now see the files we changed. Good, so with that, we could continue to work on that environment, but I think it's a good time to take a break, go grab some food or drink some water. So what we'll do instead is we just shut down this environment here, we'll stop it. We'll get rid of it, preview done. And we will come back and then continue with the new environment, just so that you see that it doesn't really matter how many environments you start. Each one is completely independent. All right, so continuing on with the other patch and delete requests now. Let's have a quick look at our issue to check what's next. So we've done post get, now we're going to work on a delete endpoint. And as we specified, we want this endpoint to live at a /todos/uid.JSON endpoint, where you currently see the colon UID, this will have to be a dynamic part of the path in the URL, where depending on the todoitem, where we want to delete that part, we'll update as we click the delete button in the UI. So we'll see how we can do that in SvelteKit. And also we will have to create a unique identifier for each todoitem. So with that, let's switch back to the pull requests that we already started and start a new environment so that we can go ahead and develop that delete endpoint at that specific URL that we specified in the issue. Here's our new developer environment. It also opens up the application preview, which is exactly what we want. We inspect that and select our network tab so we can keep an eye on what is being sent between the client and the browser. Okay, now we can, first of all, start by creating the new endpoint file. So let's have a look under source routes todos. We already have an index.JSON.TS file, which we created previously, where this file contains our post and get endpoints. Now, in order to create the endpoint with the dynamic UID, what we can do is under the todos directory as well, we can create a new file and we can call this [UID].JSON.TS that naming convention with the square brackets tells SvelteKit that this part of the path is going to be dynamic. And it will change depending on what ID we send. So let's create a file. And then just to test real quick, what is going on here, let's create an get endpoint so we can use the browser for testing, so as you recall from the previous endpoint we created export const get, and that's a function, and we'll just do this very quickly without any TypeScript definitions, but basically we get a request here. And what we have to return is the, an object that contains the status of 200 and a body. And for the body, what we want to do is we want to use request.params.UID. So, oops, so what we have is the params object refers to any path, any part of the path where we have square brackets. So in this case, UID that's wrapped into brackets, turns into a property on that params object. And we can access that by simply calling a request.params.UID. So what we can do now is if we go back to the browser where we have our application running, we can go to slash todos slash and then a dynamic part of the URL, so that's our UID, let's say ABC.JSON. And if we load this page, you can see that the response is ABC, that's because as I said, we just read that params UID and return it as a 200 response. If the todoitem UID was 123. You can imagine if we change this to 123, then the return value is 123. So this is great. We can then dynamically generate this URL when we are in the user interface and click on the delete icon next to a todoitem. Now, before we do the UI part, let's first complete the API for that endpoint here, so that when we built the UI, we can immediately test it. Okay, so what do we have to do in this file, first of all, let's import the types for the endpoints here. So same as we did in the index.JSON file, where we have that request handler, we'll grab the same type and we import it here as well. Now we can say that endpoint is of this request handler type. And the other thing we can do is we want to change that get endpoint to a delete endpoint. Now delete is a keyword in JavaScript that we can not use, so the actual name is just DEL for delete. And now if we use the request dot, we get this autocomplete, because we have the request handler defined. So TypeScript knows what's going on here. Now we have a bit of a challenge here, first of all, let's get rid of this just for a second. The challenge we have is, even though we can access that UID we need to somehow remove the correct item from this todos array right here. Unfortunately, we don't have access to this array because it's in a different endpoint. And from this file, there's no easy way for us to go and access that array. So what we're going to do instead is we will refactor that code a little bit, so that anything related to actually creating or adding a todo or updating or deleting, we will move that into a separate file and the index.JSON.TS and the [UID].JSON.TS, both of these endpoints will then leverage that new file to interact with the todoitem. This also makes it easier a little bit later when we switch from an array that we persist in memory to accessing the database, we will have just one place in the source code where we have to make that modification. So doing that refactoring now is a good point to bring us into good shape for later. So one thing I can teach you now is that, as I said, any file within the roots becomes an endpoint if it ends in dot TS or JS, or a page if it ends in dot Svelte. Sometimes just like we do what we want right now, we want to create additional helper files that we can use, like in this case to consolidate certain functionality. We could, if we wanted to move that into lib, but that really starts to convolute the lib directory and add a lot of stuff in there that isn't really used across the entire app, but only in certain places. So there's another convention in SvelteKit, and that is if a file in the roots directory starts with an underscore, the SvelteKit router ignores it and does not create a path for that file. So we can leverage that knowledge and under source routes todos, we can create a new file called _api.TS. And this is going to be our file that we can access from both of the other endpoints that we created. All right, the first thing we want to move in here is that array of todoitems. So we'll grab that, remove it from here and add it to our API. So with that thing moved over here, we know, we can ignore this warning for now, that'll fix itself in just a second, what do we want to do now is we want to export a function here that we can then call from the different places such as the get and to post endpoints here. And we will do all the behavior related todos in there. So let's create that function export const API. For now, it doesn't have any parameters. There we go. So now what we want to do in here is depending on whether we want to create or delete or update an item, we want to execute different functionality. So if you recall, let's have a quick look back in the index file. When we look at the form where we create a new item, you see that we specified the HTTP method as being post. And we also know that when we load index page, the server receives a get request from our fetch here. So that fetch slash todos by default is an HTTP get request. So we want to kind of like an if else situation in our API, where we say that if the HTTP method is get, then please return the array, if the HTTP method is post, then please create an item for us in the array. So what do we need in order to determine that is we need the request object because we need to access that HTTP method. So I'll show you how we can do that. First things first, let's go grab that import statement again for the, oh, sorry, not the request handler. What we can do is in the API, you want to say, we want to request and the type of data request, we can fetch that from the SvelteKit packet. So import type request from SvelteKit. Now, if we go to the API and we say the request is of type request, we will get all the autocomplete functionality that we need. Now, if we have a look in both cases here, we eventually return that object. So that depends, the value of that object, the return object depends on whether we do a post or a get. So I suggest we will move that code also into the API so that in this file here, we can just make a call to the API and return the result. So we don't have to do any more code in here. Let's start by running a switch statement. So switch and the value we want to check, as I mentioned is request.method, which is going to be either post or get or patch, things like that, as we go through. Now, let's also make this uppercase just to be sure in case it is being sent by clients in different format, lowercase or uppercase mixed maybe. Now the value we want to look for here is get. In the get case, we want to return all these todoitems. And in order to do that, remember here, we had a body and a status of 200 and the todoitems. So what we can do in here in our API, above the switch statement, we can specify a body and that's by default empty. And we can specify a status that is by default 500. Now we set this to 500, which represents an internal server error, just so that if somebody sends a request with a method that we did not add to our switch statement, the default behavior will be a 500 error, which indicates that whatever the clients try to do with their method here is not implemented yet, so right now, if somebody were to send a post request, they would get a 500 error, as soon as we returned that. Now, in the case of get, we know that the body has to be the array of elements. We had that over here previously. Now we no longer have the array here, however, we do have it here in our API. So we can say body equals todos and status equals 200. With that we rebuild the functionality that we had in the index.JSON.TS file. Lastly what we want to do after the switch statement is we want to return that status and the body so that whatever we set in the switch statement will get returned down here. Now, for the post request. So first of all, before we get to the post, let's clean up the get request. And the way we do that is by importing the API we created. So we can say import API from the API file. And then the fix down here, the code change is that instead of just returning that object, we can remove that and we do need to get the request because our API expects that. And then we can say return API and pass the request. Now this just becomes a oneline function here where we call that API that we specified here, then the switch statement will fall into the get case where we set the body and the status, and down here, we return body and status back, which then gets returned from this function, and we are back to the behavior we had previously. The benefit now is that everything is consolidated in that API script. Let's do the same with the post endpoint. So in the switch statement, let's add a case for post. So don't forget the break statement, otherwise we'll run into the next case and that will have unexpected consequences. Okay, in the post case, let's see what we have to do. We need to push a new item into the todos array, just like we did here. So we could potentially create that item inside of our API right here, by reading the values from the request. Another way to do that is to add a parameter to the API, which is a todoitem. And that will then basically help us create the item for the array. So either way it works. I think for now, what we can do is right here, we'll create the item and then we will pass it into the API. So let's say that our API also requires a todoitem. And the type of that is to do remember we created that in the global.d.ts, there's our todo type, so we can tell what properties we expect. Now in the post scenario, we want to add, so push the todoitem into that array and then the body and status, in the post case, we can go grab that from here, you'll see it was status 303 and headers and location. So this is interesting because that return object is different from the return object that we had down here. Now for the time being, let's just take that return here. And because we're working on a post, we can come here and exit early to return that status 303 because we don't really want to return the body that we don't have, also we need the headers object for the post request. So we don't want to, you know, deal with that down here where sometimes the headers is available, sometimes it's not, we'll just move it in here for the time being. All right, now, if we go back to that index file, what do we want to do now, here is basically call that API. So same as we did above, and we'll fix that error there in a second. So again, we want to return API. The first parameter is a request and the second one is the object that represents our todoitem. And then we don't need any of this anymore. So that's good. Now we noticed that the return statement up here, where we call the API and to get request is now red underlined. And if we do that it says that it expected two arguments but it got one, that's because we added that todoitem for the post requests, but when we have a get request or maybe later delete request, we don't really have a todoitem. So what we can do in TypeScript is after the parameter name, we can add a question mark to mark this specific parameter as optional. And now the API accepts a request or a request with a new todoitem. So so far we have refactored the code that we had previously, the get and the post, and because we have return statement here, we don't really need the break, we can remove that for now. Now we did all that work because we wanted to add a delete endpoint. So we have the wrapper here and now what we can do in that specific file, we can leverage what we already built in the API file. So if we import the API here and that lives in that API file, we want this to be a return API request. And then we want the API file to worry about the details of how to implement that. The way we do that is when we have a delete request, we expect the HTTP method to be delete, right? So we have get, post, and now we want a case for the delete endpoint. And I want a break from that. The response status for a delete request is going to be 200, so status 200. We do not have to specify a body for a delete request because the item gets removed and doesn't exist. So we'll keep the default, which is an empty object, but we have to remove the item based on the UID from the array that we have up here. Eventually when we have a database, that will be super easy, we just say, you know, delete from the database with that ID for now, because we just persist that todos array in memory, we have to manually just go in and filter the existing array, but not include the element that we want to delete. So the way we do that is todos, we set a new value for that. And then we basically filter, we filter that and we say that we want the todo.UID not equals to remember request.params.UID gives us the unique ID. And what we notice is that an individual todoitem does not have a UID because at the moment, if we look at that global.d.ts file, there is no UID specified. However, because we need that UID now to identify an item, we have to extend our todo type by adding a UID property. And that will just be a string. So UID now exists and our API no longer complains about the UID not being present. However, if we look at the index JSON file, we know we're getting an error here because we create a todoitem that does not include a UID property. Now this is again, the beauty of TypeScript, really to help us identify these kind of box before we even go to production. So what do we do? There's a good way, and a temporary way to do that. The good way would be to import a UUID package and create an actual UUID, or we can do a little workaround, which is fine for now, but eventually that UID will be generated for us by the database, so we really just add a temporary UID for now. And what we can do is UID equals, it has to be a string. We specified it as a string type. So we can use string literals here and say Date.now, which gives us the milliseconds when this item gets created. Again, don't do that in production, definitely don't do that if you have two requests coming in at the same time, you will have a conflict of two items with the same UID. So do not do that. Todo replace with UID from database. This is something that we will fix once the database exists and we can create the item in the DB, but for now, at least we get a UID. And when we delete the item, we have access to that and we can remove it. So this is a pretty good start. Now, what do we want to do next is go have a look at what do we have to change in the UI in order to call this delete endpoint. The place where we click the delete icon is under lib todoitem. In here, you know, that we have a prop for our individual todo and down in the forms, you can see here, we have the delete todo button. Now the action is the endpoint that we just created. So that endpoint lives at slash todos slash let's just make UID.JSON. The UID has to be dynamic depending on the item we render. So if you recall with the curly brackets, we can access the variables. So we can remove that and just say curly brackets and todo.UID again, thanks to TypeScript, we have that autocomplete of the new field available. And as we set the method that we want to use, we'll look at the API, deleting something in a REST API is an HTTP request with a method of delete. So in our todoitem method, we want to say delete so that the API knows what to do. Now, let's have a look at the user interface. So we'd go back to the index and there seems to be a bug somewhere, let's have a look okay. Just temporarily because of the changes we made. Okay, let's clear this, clear console and let's add an item. So that worked. And now if we inspect the button real quick, you can see that the form now points to slash todos slash the unique ID that we created based on the date dot now function dot JSON. So this is just like before, when we did slash todos slash ABC or 123, we have a delete method, so that should all be good. Now let's see what happens when we send that request. So we go to network, clear this, clear the console, and we delete the item. Interesting, we get a 404, it says not found slash todos blah blah blah dot JSON. What is going on? Let's have a look. There's our requests that ended up in a 404, but clearly we know that exists because we just created it. And if we click on it, we notice that the request method was "get". Now, why would it be "get" when we specified "delete" in our method here? So unfortunately I have some bad news and the bad news is that an HTML form only supports get method or post. Very unfortunate for us because we can not use delete. However we don't want to change our API and put all our code to delete and update items into the post handler. Because if somebody were to build, let's say a mobile application for our todo app, they would expect the REST API to provide a delete endpoint. So this is really on us to find a workaround for our web application so that we can still make this work, but rely on the delete endpoints, even though HTML forms don't actually support it. The way we can do that in SvelteKit is back in our todoitem. We have to conform to the post endpoint or post method because that's the only thing we can do. So we'll change this to post, but we use a query parameter here, and that's just something that we agree on. There's different ways we could solve that. This is one way to do it. So what we say is that let's append an _method parameter, and we call it delete. Okay so we are in the request object that our API eventually gets. There will be a created parameter called _method equals delete. So that will help us identify where do we want to do a delete. Even though we are actually sending a post request over the wire. Now we could go into the API and here where we say, switch request.method. I could show you that request.query. We could go and fetch that _method parameter, and then we could check if that is delete, then do something, but again, we don't want people who want to build on top of our application, but using our APIs to create URLs that contain this created parameter, they can just send an HTTP delete request, and that should work, so we have a little feature here that we can use in SvelteKit. Basically when that request is sent from the browser to the SvelteKit application, we can intercept the request before it reaches our API and the place to do that is a file that lives in the source directory, new file, and the file is called hooks.TS. Not to be confused with hooks from other frameworks that you might be familiar with, completely unrelated things, same name, different ideas. So definition of the hooks file, again, it's documented in the SvelteKit docs, but what we need to know is if we export a function from here called handle, we can do things there before the request is sent to our API. So let's do this export const a handle function. And if we want to make our life easier to see what we have to do, what the parameters are, there is a TypeScript definition for that. So if we import type handle from the SvelteKit, we can then annotate our handle function with that. And right away, it's telling us that, you know, type void is not assignable, which means our function currently doesn't return anything. So we do have to return something here, but first of all, we also get some parameters that are important to us here. And if we inspect that one thing we get is the request object and a result function. So in order to return the right value here, we have to call the resolve function and pass in the request object and all this happens asynchronously. So we have to make this an it async function and here return, await resolve request. There we go. Or to make this a bit more clear in terms of what's going on, we can const response equals this and then return response. All right, let me explain. So all we're doing here is we call that resolve function and we await the result. The request is a parameter we pass in. And then when this is all done, we get a response object that we have to return. So this is the default implementation of that handle function. So where do we do this? Or completely comment this out and remove the file. We get the exact same behavior, however, in line number four here, where we say await resolve, this is when SvelteKit actually executes the code in our API. What we can do is before we do that resolve call, we can intercept and modify that request object. So what we want to do is we want to check if the query parameter _method exists. So if this _method exists, we want to take the value and set that value as the request method so that when we get to the API, request.method is equal to delete. Okay, now let's see how we can do that. First, right above that, we can use an if statement to inspect the request.query. And if it has that _method endpoint, then we want to change the request method. And we want to set it to the value from the request query, get method, and then let's just also make it uppercase. You don't have to, but it's probably a good practice to keep this as uppercase, okay, so now if we have that parameter, we override the request method and set the value to whatever we pass in into URL. With that we now can go back to the UI and this all failed horribly in the meantime, which is okay, we'll go back to the index page, clear this up. We add our first todoitem, okay. We reloaded the page, that worked well, and now if we click the delete button, what happened is that we got a status code 200 and our endpoint was still a post request, fine. That's nothing we can do about because of the HTML specification, but we ended up on the endpoint URL and we got an empty object. The empty object comes from the API file, as I said, the body's an empty object. In the case of delete, we remove that todoitem and we returned status code 200. But just like with the post request where we had to do a redirect back to the index page, we need to do the same for our delete request. Now, just to show you what happened to the server, because we executed this line, but we never saw the result of that item being removed. If we go back to the index page, you can see that the item is gone. So the API actually works, just the redirect didn't happen back to the index page. So one way to fix that is to copy that return down to the delete as well, or really the pattern that starts to emerge when we look at that, is that if the request.method is not get, then we want to redirect back to the homepage. So we can do that down here, that will be a lot easier to read, so if the request.method to uppercase, is not equals to get, in that case, we want to do that redirect 303. So we can take that code and replace that with a break and then move it down here. So now in the case of post or delete, it will automatically redirect back to the index page as a 303 redirect. So now there's one more thing we need to do to satisfy the REST API specification, and that is when we do a post request. When we add an item, the return value of that API call has to be the newly created item. So after we do a todos.push and add it to our array, we need to set the body equals to that new todoitem. And the status code is 201, which is the HTTP created status code. That is basically a good point to go back and see if that if statement here worked and let's have a look at that. So we add an item and when we click on the delete button, it reloaded the page and the item disappeared. This is basically all we need in order for the delete endpoint to work at the moment. So we did a lot of changes. I think it's a good point in time to commit that because if we look at the issue and we were working on, the delete endpoint is now implemented, so let's go have a look at the changes. First of all, we created a new UID JSON endpoint with our delete request. We consolidated a whole bunch of code into an API file where we now have a switch statement. And depending on the HTTP method, we process the request and do certain things. So we returned the elements, or we create a new item in the array, or we delete the item that we specified in the request URL. And then if it's not a get request, we want to redirect back to the homepage, so that people don't end up on that empty page of the endpoint. And in any other case, we just returned status and body. Fantastic, this is a good place to be at this point. One more thing we want to quickly review is HTML forms only support get and post methods. So even though we would like this to be delete, we worked around it by using a query parameter _method where we specify what HTTP method we really want it to be. And thanks to the hooks file in the source directory, we can intercept that request and overwrite the method based on the query parameter that we specified. And then our way to resolve here calls our API and the request method is now correctly set to delete. Okay, let's go in and make some change, make commit of all of that, push it to our existing pull request and then move on to updating an item. So we see add delete endpoint. And we sync the changes and back to the pull request, we have the delete endpoint here. So here we can close all that again, the environment we don't need any more, drop that. And with that, we have the issue here and what is left, delete is done, it's now the patch endpoint, which you can see based on the URL, follows a very similar pattern in order to also implement that, so let's do this now. We're making great progress with our issue. We've done three tasks already, we have one left, which is updating a todoitem. It lifts at the same URL where we need a UID to specify which item we're updating. And if we look at the user interface real quick, there are two things we need to implement. One is the checkbox. So marking an item as done as well as somebody can edit a todoitem by clicking on that text and changing what's in it, and then use the save icon to persist these changes. We will split that up into two parts. So the first thing is we're going to work on that editing text, and then we will work on editing the check mark last. So edit text, let's implement that now. And then we should be in good shape, so develop CRUD endpoints, this is our pull request, still in draft and we spin up a new developer environment so we can work on that endpoint. Should be fairly quick, and there we go. Lots of stuff getting up and running, cool. So why do we want to do is... We don't need this. Over in source, routes, todos, we created already a file that has a dynamic UID where we have the delete endpoint. So right next to this, we want to export the patch endpoint. So that we can update the item, same concept, export const patch, and we use TypeScript annotation in just a second. For now, we just specify the function. All right. Now, a quick look at the post endpoint. Remember when we get an HTTP body that is being sent to us. So in the patch request, what will happen is the request will contain the new text that we want to add. So we need to use the same annotation as we had here so that our body, we will get the autocomplete for the get functions based on the FormData that will be passed to us. So we can copy that from the index file. It's the same concept here as well for the patch. All right, now, looking at an index file again. Remember when we have a post endpoint, we create an entire todoitem like this with all the properties that are required for a todoitem. Now in the case of a patch, we only get a text property. So all we get is going to be a request.body get text, so let's have a look what happens. We want to do the same as with all the other endpoints. So return API, and then we want to pass in the request, but we don't have a full todoitem. So we want to just pass in a partial item, and in this case, all we have is a text, so request request, yeah, it's all red at the moment. That's okay, we'll figure that out in just a sec body get, and then the text. This is the same as we had here. So request body get text and paste that here. It says it cannot find a request that's because we need to specify it as a parameter that we get passed in, same as a delete request. But now it's saying that it's missing properties. So UID created that. That's because if you recall the API file over here, it expects a todoitem that is passed in. It is optional, but if we do pass a parameter, it has to be a complete todoitem. So we have two options. One, just like we specify this parameter to be optional with the question mark, we could go to the global.TS and make all these optional, but then that kind of defeats the purpose of using TypeScript. So alternative here is that we just change the type in our API file. And instead of a todoitem being passed in, we can say that you can send as an argument, you can pass any record or any object that contains a key value pair. And the way to do that with TypeScript is that we replace that todo with a record of string and string for the time being. And what that does for us is, so we've got to close this. So we can now pass a object that contains text, which you say a property and the string has the value. And with that, this allows us to pass in a partial todoitem. So now, to be fair, this is no longer a todoitem. Really, this is more of a data parameter. So to just name that more appropriately, let's change it to data because it's not a full todoitem. Now, what we have is TypeScript is now telling us that, Hey, you have an array of todoitems and you're trying to pass in something that is not a todoitem. So even if you changed this to data, which is our new name, it will still complain. Now we know as a fact that the data we pass in the case of a post request is indeed a proper todoitem because in our index file, right here, we specify that the object we pass is a proper todoitem. We'll look at that in a second, but for now what we can do, we can tell TypeScript that, Hey, we are, we are sure, we know what we're doing. So we can say that this is a todoitem where we pass in that data. The reason it's still complaining is because I said here that we want the record to be of string and string. But if we look at the todo definition in our global file, not everything is a string, some are dates, some are Booleans. So the way to get around that is we can say that we don't actually know what the value is, it's unknown at this time. So we can say unknown. And with that TypeScript is now satisfied that here we explicitly say data is a todoitem. And we can say that with confidence because in the index file, in our API, we know we created a todoitem. So with that, we go back to our patch endpoint, and that now properly creates this object that just contains the text, which is our new item that we will create. Good, now, patch request we currently don't have a handler here in our Svelte, sorry, in our switch statement, let's change that right now. So what we do is after the delete, we're gonna add a new case for patch and eventually break from it. And the status in this case will be 200 once that's all good. But just like we're here in the delete case, delete an item. We now have to go find the correct todoitem. So basically we're going to loop through that array. We look at each item in the array. If we find the item that has the correct UID, we will update the item's text, and that is some JavaScript array work here. So todos.map, an individual todoitem we're going to look at, and what we do here is that if the todo.UID maps to the request params.UID we get passed in, then let's update that item's text equals the data.text that is being passed in. And we notice it's a string in that case, because in our patch request, we set the text property to a string that we get from the request, so we can tell TypeScript, Hey, trust me, I know what I'm doing. That data or text is of type string. So that's when we find that item, we update that todo. And then in all the cases, we want to return the todoitem from our map, and now at the end of this, we have an updated todos array that contains the new text. The last thing we need to do is under lib todoitem, we have our form at the bottom. We already added the delete endpoint. And the patch endpoint, as we know, is in the same URL, just a patch. So the safest thing to do here is to copy that URL from the delete and move it up here, but it's not a delete method, it's a patch method, and then again, limitations in the HTML form is that we have to actually send the post request, which as you recall, our hooks.JS file will revert or override the request method if that query parameter is available. All right. One last thing is our input field doesn't have a name attribute yet. And as you see here, we are using the text value. So let's go to our item and specify a name equals text. Whatever you put here, it doesn't have to be text, it could be anything you want, but it has to match what's in our endpoint that we read here. That's the only thing you need to worry about. All right, let's have a look. Let's do some inspecting and let's add an item first. Let's also add a second item and then let's change the text of the first to "first item" and persist that item. Now we have first item, if we were to reload the page, just to make sure first item is still here, and with that, we implemented the edit functionality of a todoitem. That was a lot less work than the previous time when we had to delete endpoint, because we already reused a bunch of functionality, like the _method hack we did to work around some limitations we have with the method we can use in the form. All right, let's have a quick look at what's going on. We created a new patch endpoint right here. What we do is we call the API and we pass in a new object with just a text property that we read from the request body. The API, instead of expecting a todoitem, it now expects any object in here. And we used a little bit of TypeScript magic to tell TypeScript that we know for sure in a post request, we get a todo type data. And then we implemented a patch where we loop through all the todoitems in the array. If we find the one that has matching UID with the request parameter, we update the text, from there, we return all the items and the 200 status code back to the browser. All right, this is all we need for now, so let's commit that, add patch endpoint update text. All right, yes. We're going to push that, close all our views here. Don't need a developer environment anymore, and now. I may have just closed that a little too early. So I'll show you how you can get your developer environment back, if you go to Gitpod.io/workspaces, and then you can see it here. That's the one that was 14 minutes ago. Yeah, it has unpushed commits, so I shut that down just a little bit too early, not a big deal, we can click the dots here, we can open that environment back up, and that is just going to take a second and give us our environment back. So as I mentioned, this is, you know, if you have enough patience and wait for the push to complete and you don't have to do that, but since I didn't wait long enough, we can just come back here and switch over here and then click that sync changes again and wait until it gets properly pushed. There we go. And now we can go ahead and shut that down again. So good lesson, if you do need to get an environment back for whatever reason, GitPod.IO/workspaces, and you will get access to this. Alrighty, with that in place, we have one more patch to implement that is to make the checkbox work. And then once we do that, we are feature complete in terms of the API, we can then add, read, update, and delete todoitems. Let's go build that last piece and then have that application feature complete in terms of the API. All right, let's move on, go and start a new workspace and then build that edit feature for the marking an item is done part of the application. This one should be straightforward because we already built an edit feature for the text of a todoitem. So we can leverage that exact same code that we have in place already. Let's go have a look at how this works. All right. So starting out with the endpoint, we go to source, routes, todos and the [UID].JSON.TS file. Now, at the moment, we only deal with a text property that is being passed in by the web app. So if we add one here real quick, when we edit this text and we submit it, then that body has a text property. What happens though, when we click this button and we submit a form to the same endpoint as the edit endpoint here? So let's have a look in source lib todoitem.Svelte. If we scroll down to the HTML, we have this input field where we have a name done and the value doesn't exist at the moment. So the value we want to put in here is either nothing or true if we want to mark an item as done. So let's have a look. Basically we can use the curly brackets to access the todo item, and let's do this first, todo.done. So if the item we are rendering is marked as done, then if somebody clicks on the circle, the value we want to set in this field here is an empty string. Otherwise we want to add the value of true. So that then basically just toggles between true and an empty string, depending on whether the item is toggled or not. Now with that, we also can update that aria label here, because now we know whether the item is done or not. So let's do that, so we can say mark todo as, and then the string here depends on whether the item is done or not, so if it's done, then we want to say not done and otherwise done. So now this says that, if the todoitem is done, then mark todo as not done, so flip it. Otherwise we mark it as done. Alrighty. In order to test that, we need to go back to our source, routes, todos [UID].JSON.TS. And now because we have a name equals done, we get an additional parameter here potentially. So let's go in and also specify the done property. And what we want to do is if the request body contains that done value, then we want to make a Boolean value out of it, so request.body get the done. And if we don't have the done property available, then we just say undefined, all right, let's go have a look at the API as well, so in our API file, _API in the patch section. Up to this point, we only deal with the text value, but now we also have a potential done value. So they will never be set at the same time, it's either text or done that will be available depending on whether we clicked the button on the left or whether we updated the text. So we can deal with that in our API by just simply checking here. If the data dot text is available, then we want to set that. And the other thing we want to check is that else, we can say we're dealing with the done property so we can see data.done, and we know this a Boolean, because we set it to a Boolean or undefined. Now, if there were more features or properties, then we could refactor that slightly to make it more readable, but this does the trick for the time being. And we can, you know, use that as a good starting point. Going back to the todoitem Svelte component, we need to provide the action and the method. Now that's the exact same as for the editing text, right, we are going to the same endpoint so we can copy that URL action from here, paste it, and the method as always is post. And with that, let's have a look at the user interface. Let's inspect, get the console back in case there's something interesting there. So first we set that, let's add a second one as well. Nice. Now let's check the second one, mark this as done, and it didn't update the user interface. Hmm, why would that be? Let's see if we reload. Same thing, now, the reason for that is, remember when we styled the web application, we commented out some of the work because we didn't have a way to mark an item as done. So now remember here that CSS, we set that a uncomment when the API endpoints out available. Now guess what, the NPI endpoint are now available. So we now have a way to say whether this todoitem is done or not, remember the todo.done property, we have access to whether an item is done or not. So let's first uncomment that code. Svelte immediately tells us that these are unused CSS selectors, both of them. And that's because we need to dynamically add the done value here. So we could use the same concept where we say todo, done, then at that, otherwise don't add a class name. Now let's have a look, and just like that, the second item is now checked. And visually you can see it is marked as done. If we uncheck it, it works, we can check this one, uncheck, perfectly valid, but ohmyGod is this convoluted, look at all this code to specify whether this item should have that class name or not. It seems to me like this is a lot of code that it's also very fragile because there's an empty string. There's a done here. So let's have a look at what Svelte provides us to make this a little bit more maintainable. Instead of doing some string manipulations right here within the class attribute, we can use a second attribute, which is a class and then colon. Now, what we add here, after the colon is the name of the class we want to add conditionally in our case, this is done value. And in order to specify whether or not we want to set that class, we can use equals todo.done. Now Svelte conditionally adds or removes that class from that element depending on whether the value in the curly brackets is true. Just to make sure this works, let's go back and add an item. There we go, well, okay, it reloaded from the server, so it's all good. We can drop it. All right, that works. If we had a variable in our script at the top that is called done, then we could drop that entire part here as well.. We don't have one called done, but if I were to go up here in the script and I would say, const done equals todo.done, and we now can do that. So if the variable exists that has the same name as the class name we want to add, we can just say class and the name, and then Svelte will automatically toggle that. Now I think this is one way to do it, I don't think it's necessary in this case, there's a lot of good use cases for that. In our case, I think this is fine enough to just read from the todo object directly. But that gives us basically the user interface where we can add items, we can mark them as done. We can remove them all by using the user interface. Now I showed it once before. I think it's worth mentioning again, to just remind you, if we go to the developer settings and we go to debugger and disabled JavaScript, that website, I can reload it just to make sure, I can still go ahead and work with that API and the website exactly the same way as we've always done. So there's no JavaScript whatsoever being used right now to make this web application work. And this is something that I think has been forgotten a bit recently that the web could easily work without JavaScript. And it used to for a matter of fact, many years ago. So I think it's very important to keep that in mind, there is a lot of people that have low powered devices to access the internet and JavaScript is making this hard and slow for many people in the world. So if we do want to provide a slightly better user experience for people that have JavaScript enabled, then we can do that. We can enhance this application so that if JavaScript is available, we are able to leverage it. And instead of, you know, doing a full page refresh, if I delete an item, that does a redirect back to the homepage and reloads the entire page, all this code, we can speed that up and we'll do that next. But for now, let's close this preview, have a quick look at what we've changed in our code. First of all, we added a new done property when we call the API. The API is extended so that our patch can deal with text and todo done text and done properties. And lastly, we have the todoitem updated where we could finally uncomment our CSS when a item is called, I will mark this done. And we then learned how we can add a class dynamically to an item or an element here, depending on whether an item is done or not. Alright, this is a good place to commit all that. So we call this add the patch endpoint and the value for it is mark as done, for example. Okay now sync the changes. Make sure you wait until that's all done. And we have that available here. So now it's a safe time to shut down our workspace. That'll disappear, and with that, we can also go back to our issue and we have that patch implemented. With that, our pull request is no longer in draft, ready for review. Somebody on our team can help us review the changes. And then we can go ahead and merge that PR, delete the branch. So with that, we have fully functioning API ready to go, and the application is nice and working. So we're going to look at a few more things now and make good progress throughout the course. So stay tuned, more to come. Okay, what do we want to do now is leverage a feature from Svelte called actions in order to enhance the HTML forms for visitors of our application that have JavaScript enabled. So we've got a new issue called enhanced HTML forms. We start a new Gitpod workspace for that specific task. And what we're going to do now is basically find all the HTML forms that we have and use this new Svelte action that we are going to create that will help us to make an AJAX request instead of a full page refresh. I'll show you what I mean by that. If we come here and we add a new item currently by hitting enter here, you remember it reloads the entire page. It adds the item, and then redirect back to the homepage, which means it downloads all the CSS, the HTML, and all the code. We really want to just make an AJAX request to the endpoint, add the item to our array in the API, and then update the UI accordingly. So the way we can do that is by using Svelte actions. And Svelte actions are very powerful tool. Welldocumented at Svelte.dev but I'll walk you through and teach you everything you need to know. The first thing we want to do is create a new action and an action is really just a function. So I like to have them under source lib, and then in the actions directory, and in our case, we're going to call it form.TS. So in here we just have to export a function and the name of that function will become the name of our action. So export const, let's call this enhance because we will enhance the HTML form with additional functionality in case JavaScript is enabled. So it's a function and that's basically it. Now with actions, there is a parameter being passed to us by Svelte that represents the HTML element that we use the action on. So in our case, we will use that enhance action for HTML forms. So Svelte automatically passes us a form. And with TypeScript, we know this is an HTML form element, and this is passed into us into this action. So before we go any further, let's see how we can use that in the code of our Svelte component, we copy the name and we go to source roots index. And here in the top, we want to first import our new function or action, same thing. So import enhance from, and remember the shortcut to go to a source lib. We can use the dollar sign lib slash, now we can see our new actions directory, and within that, the form file. Alrighty, with that we can go down and we'll start by enhancing the form to create a new todoitem. So we can use an action by saying use, and then the name of our action. As I mentioned Svelte provides a reference to the element we use the action on. So this is on the form element and that's why the parameter we get is a form parameter into our action. So let me show you what happens. Before we go any further, let's just do console log action executed for example. If we switch to the UI and we clear the console and we reload that page. You can see that as soon as the HTML form gets mounted to the DOM, we can see that the action got executed. Okay, so now this means at that point, we can start to interact with the form using JavaScript in our action to intercept the submit request. And then instead of doing a full page reload, we can just send an Ajax request before we get there. I'm going to show you one more thing that is extremely important to know when you build actions. And in order to do that, I'm going to rename that text form mounted to DOM. Now, anything you do in the enhance function here or in your action, keep in mind that this action gets executed every time the HTML element gets added to the DOM. So if we navigate from one page to another and we come back, that enhanced function is called again. Let me demonstrate that so that we can then see a few things. I'm going to under source routes, I create a new file called aboutus.Svelte. And for now this just contains an H1 element, about us, and a link that brings us back to the homepage like that. And that will just move us back. On the index page itself under the title, I'm adding an anchor that brings us to about us so we can navigate between the two pages easily. All right, do that, clear things. We reload the page and you can see that the form is mounted to the DOM. And now, oh there we go, had to refresh, hot module reloading kicked in. So it got mounted to the DOM. And now if we click the about us, we load the about us page, and if we go back, you can see that the form mounted to DOM appears again. This is extremely important to know, because anything we do in our action happens every time the HTML element gets added to the DOM. So navigating between back and forth, we have to somehow clean up everything we do in here. For example if we were to add an event listener or create something in memory or whatever, we'll have to clean that up when the HTML form gets removed from the DOM. So when we navigate away from the page or the element gets removed from the DOM, for any other reason. To do that, the convention is that we can return an object from our action that contains a destroy function. And in that destroy function, we can print form removed from DOM. And now if we have a look at the console, when we load the page, you can see the form, mounted to the DOM. When we navigate away, the form was removed from the DOM. And then when we come back, the form is mounted again. So anything we do in the action, it is very important that we undo, you know, in air quotes, everything we did so that we have no memory leaks, and we don't accidentally add multiple like event listeners. And then all of a sudden our code executes multiple times, things like that. So with that knowledge in mind, let's have a look at what we really want to do in order to make the user experience a bit better for people with JavaScript enabled. When somebody actually, before we do that, hold on, let's clean this up, we don't need the about us page. And in our index file, we no longer need the link. We've proven that this does what it's supposed to do. So now when somebody submits this form, we currently send, or we let the browser send an HTTP post request to the endpoint that we specified in the form here. And then that redirects us back. So what we really want to do is we don't want the browser to take care of that. If JavaScript is enabled, we want to tell the browser, Hey, thank you for your service, but we don't really need your help here. We can take care of sending the content of this text field, to the API, process the API response, and then we'll update UI automatically. So we don't need to reload the entire page. The way we do that is in our action, under source, lib, actions, form, we have access to the HTML form. So what we can do is we're going to drop these console logs because we know they do what they're supposed to do. So here we can say form.addEventListener, and we can listen to the form's submit event. That's when the browser usually kicks in and does its post request to the API, and we need to give it a function or a listener that will be executed when that event happens, so let's call this handleSubmit, and then let's create a function here, handleSubmit, and as I said, anything we do in our action, we have to undo it in the destroy function. So when we move away to another page, we want to say form removeEventListener, submit, and the event listener we want to remove is our handleSubmit function. So with that, we have the basic structure in place of our action, where we add event listener, when the DOM, the element, it gets added to the DOM and we remove it when the element gets removed from the DOM. So what do we want to do when a form gets submitted? The very first thing is we want to tell the browser to not do the default behavior. As I said, the default behavior is to send a post request to the endpoint that is specified in the HTML. So in this case, send in a post request to that todos item endpoint. Let's not do that. Now, because this is a regular event listener that we added, we get a parameter passed in here, which is called an event. And that's just of type event if we wanted to use TypeScript here. And on that event, we have a function that's called prevent default that tells the browser, Hey, don't do your default behavior. I will take care of it. So let's see what that does to our user interface. Clear out, network, clear. Alright, we add a second item and we submit, I think that did not load, let's try it one more time. Clear, add a third item and submit it. If you hit enter, nothing happens. And that's exactly what we want. And that's also what we said, don't do anything. However because we told the browser not to do its default behavior, it is now up to us to make this HTTP request to the backend. So let's have a look. Whenever we deal with an HTTP request, it's probably a good idea to wrap it up in a trycatch because things could go wrong, the API could be unavailable. There could be any other errors that may occur. So if that happens, if we do get an error for some reason, let's just say console.error for the time being fetch error and eventually specify what is wrong. We'll do that in a second. Okay. How do we make an HTTP request from a website? Well, the solution to that is using fetch and we have to go to some kind of endpoint here endpoint, alright, now fetch is asynchronous, so we have to await it and we will then get a response. Since we use now await, we have to make the handler asynchronous, we'll do async. All right. We'll figure it out, that endpoint in just a second. But for now, we now have a response that if something does go wrong, then we can do something with it. So the let's change this here to could not submit the form. And the error we get is whatever error we have. All right, first things first, how do we figure out what's the endpoint of our form? If we look at the index file, the endpoint we want to use this value within the action property. Remember that our action we are defining here is generic so that we can use it for any form on the application. We don't want this to be very specific to just one form. And the good thing is that if we look at the form elements that we defined under source lib todoitem, and we go down all these forms, they specify the action attribute that we want to use for our HTTP request. So the good news here is that we do get a form passed in as an attribute here, or as a parameter. So let's have a look. What if we look at what's inside that form, do we have, ah, we have the action property. Okay, that's exactly what we want. We want to use that action as the URL for our request. So this is a good start, now, if we don't specify any more parameters for the fetch call, then the default request method would be get. But as you know, we want this to be post like here, so we can just like access the action attribute, we can access the method as well. So we can pass in a second argument to the fetch function and we call this method and the value is whatever we specify in the form method attribute. Alrighty, there's one more thing we need to do. So in the case of creating a todoitem or updating an item, we need to send the fields, the input fields that we specify within the form. And in order to do that, we can leverage a pretty nifty feature. So let's specify, let's say a body and the way we can do this, we can use new FormData, pass in the form. Does this look familiar, FormData? In fact, I still have it open as a tab. We looked at that earlier on the Mozilla developer page. And if we switch over to the roots todos, the UID or the index, so index.post here, remember we specified the FormData that is being sent as a body. This is exactly what we're doing here. We create the body as a new instance of the FormData. And now in our request, we can specify a body attribute. And since it's the same as the variable name, we can just leave it like that instead of doing this short form is just using body. So now we are sending a request to the action with the correct method and the body, but there's one more thing we can do that is, we can specify that we accept a JSON response. So let's have a look, we can pass in headers as well. So headers, and what do we say here is, Hey, we accept application/JSON, and this will come in handy in just a second and I'll show you why, for now, let's just, you know, make this request, we get a response, and then we want to do something with that response. So let's go here and say that if the response is ok, then we want to console log API response. And for the time being, we just say await. So what is happening here? We basically just pick the JSON response that we get from the server and what just print it into the console. If something goes wrong, let's say else, we want console error, fetch error. And we will just take whatever the response text attribute is like, if something happened there, then the response will contain some information of what went wrong. And we can leverage that to display an error message in the console for now. Okay, so we did a lot of stuff here. Now, what do we want to go check is what happens when we submit that request. Let's go back here and let's reload the page. Clear all that. Let's go and create a third item, and we submit it. Interesting, look at that. First of all, it didn't do any redirect, which is, you know, kind of good news, however, it tried to, see this? So a post request 303 is the response code. And it tried to redirect back to that index page. So why is that, well, because we configured it that way, obviously, there's a POST request. And if we go to our API source routes todos API, you recall that we say that if the request method is not get then redirect to the index page, ha that's a problem. We only want to do that redirect when the browser submits the form on its own, so when JavaScript is disabled. If JavaScript is enabled and we submit the form through our action right here, in that case, we don't want to do a redirect and instead we just want to return the response and then we parse it here and we print the value, right? All right so let's have a look at how we can go about that and make sure we can differentiate whether the browser submitted the request or whether we did. Now, I already did a little bit of work here upfront. I added a new header that says accept application/json. The browser doesn't do that when it submits the form, the value for that is different in that case. But because we are specifying application/json by ourselves, when JavaScript is enabled, we can leverage that in our API file and enhance our if statement so that we are not only looking for the request method, but it also checking the header that we specified. So here we say and request headers accept, that's the one we specified is not equals to application/json. Probably a good time to move that to a new line, okay, with that, we now have the check so they shouldn't do a redirect anymore when we sent the request, let's see if that's the case. Because we changed our API file, the server reloaded, and it cleared our items. That's okay, we'll just add them again. So we add a first, that, okay, hang on, let's clear this, it will be easier. We'll do that again. We'll add a second. And now look at that, we only have one request and if we move things around here a bit, you can see it's a post request, the status code is 201, and you can see that the payload was text second, that's what we created. And the response that we got back from the server is a full todoitem, including the created at, the UID, the text, done false. This is fascinating, this is all we really need. And in fact, all we need to do now is update the user interface to make sure we showed that item in the UI. At the moment, if I were to refresh the page, you can see that our two items are here. That's because the GET request fetches everything from the server and displays it. But we want to do that dynamically. And the way we can do that is because we're dealing with JavaScript, we also can modify that list and do so in a pretty dynamic way. Let's look at how we do that. At the moment, when we have a successful result, we just print API response out to the console. So if we look at that, I disappeared because I reloaded the page. We can do it again, if I add a third item, we can see the API response here. Now let's take that information and update the user interface. And the way we do that is, instead of just printing, we have to update the user interface in the index file. Let's have a look. In the index file, we have that enhance action. So somehow when the request is made to the server from our action, and we get the response back, at this point right here, we need to update the user interface here. So the number of todos that we have in this array, we need to push in our new item that the server sent back to us. With that, we can then let Svelte to do the rest of the matching and just rerender that array and display a new todoitem. But how do we access that array that we get in as a prop? There's some good news. And the good news is that we can pass additional parameters to our action. The form is given to us by Svelte, but we can add our own parameters as well. And that's exactly what we're going to do, so in order to make this more flexible going forward, let's add an object as an additional parameter. And what we will pass in is a function that we named result. Why do we do that? Because this enhanced action will be used across multiple forms. The behavior of the success case is going to be different. When we add an item, we want to add it to a list. When we edit it, we want to update an item. And when we delete a todoitem, we want to remove it from our list in the UI. So because of that, we basically pass in that function, again, you could call it whatever you want, but then instead of printing that text, what did we will do is we will call that result function here, and we will pass the response. We could pass the todo object or whatever. The fact that I'm passing response allows us to be more flexible in the user interface, where we could read values from the response such as the status or things like that, if we wanted to, you know react to that in certain ways. This is, you know, up to you how much you want to pass through here, in our case, we'll pass the response and let the user interface deal with whatever it wants to do with that. So that's good. Now, how do we get access to that? How can we pass that result in here? Very straightforward, TypeScript already tells us that it expects two arguments, but it got only one. So we're missing that object with the result function. So here's how we can do that. Similar to how we defined the conditional class. Previously, we can say, useenhance, and then equals JavaScript, and then the object here. So what's going on, the inner brackets represent the second parameter here. So that part, and the outer brackets, they are there just like we used them down here to tell Svelte that we are doing some dynamic work here. All right, so now what we need to pass in here if we do control space, it expects a result property. So let's do a new line result. And the result is a function we are going to specify in our script where we push an item into due todos array. So let's have a look. We'll just call that for now, processNewToDoResult. And then let's go define that function up here. So const equals, let's make a function first, and then as you remember from the enhance action, we call the result with an argument called response. So that means that in our index file, oops, sorry, process new todo result, we get a response. Pass in parameter. We can use TypeScript to specify what type that is. And what do we want to do here now is read the item that is being sent back to us, just like we printed it to the console here. We can use that await res JSON, grab it, make sure we remove that line because you can only call that JSON function once on a response. So remove that. And in here, we can now say const new todo equals await response JSON. And we have to mark this as an async function because we're awaiting. Now, this is an object that contains everything we need to know about the new todoitem. We saw that in the console previously with the UID, created at, all that information. Excellent, now all that's left to do is update the, todos array inject that new object. So you would be inclined to likely do, todos push new todo. Now in Svelte, that doesn't quite work because in order for Reactivity to kick in, and Svelte to rerender that todos array, what do we have to do is reassign the array of that variable, which is not a big deal. We can change the code here and say todos equals a new array with the old todoitems plus the new todoitem appended to it. And with that, we can now go back to the user interface and reload that page, there was a lot of code going on. And first, second, third, let's go clear some things and add our fourth item. We hit enter, and you can see one request to the backend. The fourth item shows up instantly in the UI, but it didn't clear out our input field, that's a bit annoying. The user experience here is not great, so we can easily fix that back here at the end, once we updated the list, it would be great if we could clear that form and reset it to its default values, which would be an empty string for the input field. So luckily in our action, where we call the result, we also have access to the form that we are using. So we can just pass that in as a prop as a argument here, form. And then in the index file where we have our function, we now also get a form which is of type HTML form element with that, we can now say form.reset, and that will clear the form back to its default values. Let's have a look. First of all, let's delete a few things here. All right, clear that. So we'll add our third item and we hit enter. It gets added and the form gets immediately reset. Okay, this is a very nice, one request, if JavaScript is enabled, if we go here to the developer settings we disable JavaScript and we were to add a fourth item and submit that form, you can see that now the submission happened by the browser and it used the 303 redirect to come back, but the functionality still works even if JavaScript is disabled we used that before, we saw it. But if it's enabled, we get that nice little performance boost by just sending a single request and then use JavaScript to perform the addition to the UI. Nice. So we created the functionality to add a todoitem and we have a very generic form action that we call enhance. Now let's go ahead and add that enhance function to all our other forms as well. So marking an items done, editing and deleting. The way we do that is we switch to the todoitem component, and at the top we import the action. So we can go to the index file and grab it from here. Now, even though the index file and the todoitem are in different places in the file system, thanks to the $lib, we can just copy paste that import. And now we have our enhance function here. So the first thing we want to do is let's start on the right side and do the delete action, first, go down. This is our delete form with the delete todo functionality. So over here, use, enhance and pass in a result. And then we call this, let's say, process, the deleted todo result. And we go and define that function up in the script. So now we have a challenge, in order to delete that todoitem once it's removed from the server, that function will be called by our action, but we don't really have access to the array of todoitems so that we can remove it from that array. The only thing we have access to is that item that no longer exists. So we have to find a way to access the todos array in our index page, just like with the adding a new item, we can get the existing items and add a new one. We need access to deleting an element from this array. The good news is with Svelte and Svelte components, we can just use a prop the same way that we pass in the todoitem. We can also expect a prop to be a function that we can use to delete that item. Let's see we can export, let our function, and just like we specified todoitem to be a todo type. The prop here is going to be a function that receives a rest parameter, which is a response, and it will have no return value, so avoid. All right, now, all we need to do is back in the index file, we now get an error saying that the todoitem expects the additional property that we just specified. And the way we can do that is we add it here just like the todo, we can pass in a new function that doesn't exist yet, but it will in just a second, where right here, next to the one, we create an item, we can say const equals and make this just a function. Alrighty. And then remember it receives a response, actually let's do this differently. I'll show you another trick, let's delete this. And instead what are we going to do is we're going to define the prop here, but instead of writing the code off, we'll write it right in line. The reason we do that is because we need access to the existing todoitems so that we can read its UID. So this is a regular function. We can just pass that in here. And we say todos equals, and then we filter them. And we say that an individual todo, if the UID is not equals to the todo UID, then keep it, otherwise drop it. So now we'll remove the current todo, if the ID matches to the one that we are filtering through. Let's see what that does to the user interface. Let's just make sure we have JavaScript set correctly. Yup, JavaScript is enabled. We clear console and we delete the fourth item. Yeah, okay, we have to refresh the page real quick. Let's try that one more time. And we do delete the third item, that sent a request, if we look at the details, was a post request, but it had the method delete in the query parameter. That was our workaround for the form. And then what it did is remove that item from the UI and from the server. All right. So what's missing now is editing both marking as done and adding the text. This can be achieved the exact same way as we did for the delete and the adding a new item. So let's follow that same pattern. In the todoitem itself, we already have a prop that we passed in here to delete the result. Let's add a new one process updated todo result. And then in our forms, further down, here we go, we want to add new actions, so we used that same enhance action enhance, and we want to pass in the result being that. And the same is going to apply to the first form where we check it off as done. So here, we may as well just copy that entire thing. There we go, we can paste here. And with that, we now have to specify the behavior of that function. And as we noticed, this passed in as a prop to our todoitem component. So in the index, it will expect that we define that function here as well. So we don't really need to do much other than just passing that in and making sure everything is fine. So hold on, probably a good time to clean this up a bit add the new properties on new lines. And then we also had the, oops. This new process updated todo, and in this case, what we could do is define that up in the scripts, doesn't have to be down there inline. So we can say const equals a function. And as always, what we get passed in here is a response of type response. It will be async And what we do inside now is we do const, similar to how we fetched the new item, we say, give me the updated item. So const updated todo await JSON, and then the updated todo, we need to go through the list of todoitems and update the array with the new item that was updated. The way we do that is todo equals we map over all of them. And here we just say that if the current item we are iterating over, if the UID equals to the updated items, updated to do the UID, then return our updated item and otherwise just return the one we already had in the array and don't bother about it. All right, now, one thing we forgot to do when we built the API is that you see that when we update an item, we expect the server response to include a copy of the new item, just like we do when we create an item, the server replies with the newly created element. We need to update our API to also include the updated todo item from that response. If we go back to the API and we look at the patch case, you notice that we have a status, but we have no body. And if we look at the post, we return the element that we received. So in the patch case, the element we want to return is whichever element that was just updated as part of this map function here. So we can specify this by saying body equals, and then we'd just go find that element in here. So if the element we are iterating over its UID maps to the request params UID. Then please, you know, give us that element and we'll return it back into body, send it to the client where we then update the UI. So let's have a look at what's going on here. Let me clear all this. And we add a first item that went ahead, added the item, it downloaded, you can see the images here, inline SVGs, because it's the first time we have that edit button. We can now rename that to first item that just sends a request to that endpoint, nothing else. And then the UI gets updated automatically and we can mark them as done as well, that's the other feature we built. You see it's another request marking is done and we can get rid of it too. So with that, we developed a web application that works with JavaScript disabled. And if somebody has JavaScript enabled, we enhanced the forms to leverage that and use Ajax requests instead of full HTML form submissions. This is a good point in time to commit, we did a lot of work here, but this was all necessary to make sure our application behaves nicely for everybody depending on their preferences and settings of their browsers, whether JavaScript is enabled or not. Let's do a quick recap. The first thing is we made a small change to our API so that the PATCH request now returns the updated element. We also enhanced our function here saying that we only want to do to redirect if the browser submitted the HTML form. If the client accepts an HTTP or an application/json, then we don't want to do that. Most importantly, we added a new action called enhance. The action receives a form that represents the element where we used the action and an object with a result function so that we can update the UI when we get a response back. As an exercise for the viewer, you could go ahead and enhance that second object to expect an error function as well, so that if something goes wrong, you could call the error function and update the user interface to show to the user that something went wrong and they should retry again. I'll leave that up to the viewers as an exercise, since we want to move on and, you know, focus on building the full, all the backend stuff, the API that connects to the database and persists the item instead of just using an array in memory. Okay, so this is a good place to commit all these changes and close that PR that we're about to open. So enhance HTML forms. We'll go ahead and push that and then create a new pull request that we want to slightly rename, make this a bit more readable. And here we say in the description close issue number 11. And with that, we can create a pull request. All right, give that a second to do all this work. Now, if we look here, we have the new PR and we are ready to merge and move on so merge PR, delete the branch. Just as a reminder, never review your own code. Always ask a colleague to do that. I don't have a colleague available right now, so I'll do this myself and then our developer environment on Gitpod, we can go and throw this away, no need for that anymore. And with that, we completed that part where we enhance the HTML forms so that we can now leverage Ajax requests where needed It is no time to move on and look at the rest of the architecture. So let's go ahead and start working on the database. Okay, time to move on. Before we work on that database setup for our developer environment, let's quickly recap where we are in the architecture. We've developed the frontend with Svelte. We developed an API using SvelteKit. We had our REST API in SvelteKit exposed so that we can communicate with the frontend and vice versa. Now it's time to focus on the second part of the architecture, where we persist the todoitems in the database instead of where they currently are, which is in memory on the server. So having a look at the final architecture, we're going to start with a Postgres database in the developer environment so that we can test the endtoend flow from the front end through the API via Prisma over to the database and all the way back. We want to do all of that in the local developer environment or in our case on a Gitpod workspace so that we know all the code is in place before we deploy the application to production. If you follow along on your local computer, this is the point where you have to go over to the Postgres website. And so PostgreSQL.org and click the download button here in the banner or up in the header, there's a download link as well. And depending on which operating system you use locally, please select the appropriate installation instructions here and follow along to set up that database on your local computer. If you follow along using Gitpod, then all we need to do is just make a oneline change in our gitpod configuration in order to get access to Postgres. So that's what I will be focusing on in the next couple of minutes. So we have an issue to install and start the dev database. We click the Gitpod button to start a developer workspace for that particular issue. And that is pulling the container image just like it's always done, it will also start the development server. So we will see the preview of the web application. At this point we don't need that because we are not focusing on the frontend so we can close the tab. And we are now back on that development environment. So the developer server here, we can go work on. We don't need to get started and if we open the Gitpod YAML file in the root at the moment we have not configured which image we want to use. So which Docker container to use as our environment. That totally fine and Gitpod just uses a default image that comes with a various languages and frameworks preinstalled. But now we have a special interest in getting Postgres installed, so we have two options. One, we could specify a Docker container in our source code and then tell Gitpod to use that Docker container. So if we have special libraries or operating system dependencies, we have full control over what the base image looks like for our developer environment. However, in our case all we care about is that we have Postgres installed and started. So the way we can do it is we can use the image property and we specify Gitpod/workspacePostgres. So this is an image that Gitpod maintains and provides to people who use the environment here. If you want to see what else is available, head over to github.com/gitpodio/workspaceimages. And you will see a list of other images you can base your environment on. So if you work in Flutter or with a Flutter application, you can use that as a default image. The same for PostGres, the one we use MySQL, MongoDB, and a few others. As again, as I said, if you want your own Docker image, that's an option too. And the Gitpod documentation explains how you can configure that. In our case, all we need is the workspacePostgres. And because we are now starting a development server for this Postgres database, Gitpod will automatically realize that there's a new port available on 5432, which is the default port for Postgres. So if we do nothing else, other than adding this line for the image, every time we start a new Gitpod developer environment, we will get a popup at the bottom here saying that a service is listening on port 5432. We don't really want that because we don't need to know. We know what the database is installed and running, so we can add another port definition to our ports array, where we just say port 5432. And when we open the workspace, we want to ignore that port, that just makes sure that nothing gets displayed at the bottom yet, the port will be available so we can connect with a database client. That's all the changes there are for this pull request. We literally just added one line here to base our development environment on a new image that contains Postgres. And we said that let's ignore port 5432. Next step is we commit these changes and create a pull request. Now I already did that offcamera so for the time being, I can just shut this environment down and close it, and then you can see, I already have a pull request here. If we look at that, then you can see that I made the same changes, GitPod workspace Postgres and port 5432. If we start an environment based on that new configuration file, so we click the Gitpod button on the side, and now it's using that new underlying Docker image that contains the database. So we're going to give that a second to download all the dependencies and spin up the environment. And then we can see that port is available, and also, we now have a CLI to connect to the Postgres environment, that database that we started up. So let's just wait until things start up. There's the preview of our app, we don't need that. And back here, we can close to get started. If we're heading over to the Remote Explorer, you can see now we have a new port available 5432, that is our database. And if we open new terminal, so on the right side up here, we can click the plus to create a new terminal. And now if we type psql, then that connects us to the Postgres database that is installed on our computer in our environment here the GitPod environment. And now everybody who works on this project using Gitpod, they will automatically have Postgres installed and started up as soon as the workspace is ready, and they don't have to follow any instructions on how to download Postgres onto their local laptop. This is all automatically configured for them. This is a great point in time to commit, we already did, we have a pull request and we validated that we can login to that database. So we are going to shut this down. And we know we satisfied that PR. So we installed and started a dev database. We can now go ahead and merge that pull request, confirm the merge, drop the branch. And with that, we are now ready to start the integration with the database and the API. What an exciting part to be working on next. We are finally going to find a way to connect our API with the Postgres database that we installed in our developer environment, just minutes ago. As part of the architecture, we are going to work on that Prisma part here, so the glue, if you wish between the API and the Postgres database, it will help us interact with the database and the database's response, depending on what we do. And we can just use TypeScript or JavaScript in this case where we can call methods to add items and fetch items and Prisma will do all the hard work of converting between SQL queries and JavaScript objects. If you've ever worked with an ORM before or have written your own raw SQL queries, Prisma will be an absolute mindblowing tool and seriously increase your developer experience. We will see that as we go through the configuration, if you combine it with Gitpod and automate a lot of the steps, then you'll get the best of both worlds. Now, before we dive in, we are working with prisma.io. So having a look at that, lots of information here, fantastic documentation that they've put together with all the details we need to know. I will walk you through everything we need in order to get this application up and running. And if you need more or want to learn more, then Prisma.io is the place to go. Okay, in GitHub, we have an issue ready for us, use Prisma ORM. So we'll spin up a new Gitpod developer environment. And once that's ready, we can start by installing the Prisma command line interface. That's a NPM package that helps us integrate with Prisma and run certain commands to make things easier for us. So giving Gitpod another second here to spin up the environment, and then we'll be off to the races and can get started. Here's our editor. And in the second, we will also see the terminal, our preview of the web application, which at the moment we don't need, this is a bit of a distraction. So we'll just close that browser tab and get rid of the get started section. We also don't really need the development server to run so we can click into the terminal control C to cancel that, what we do want to do, clear, is we want to install that Prisma CLI. And the way we do that is by typing npm install D so that it gets saved as a dev dependency. And the package name is prisma. If we run that, it gets it all installed. And now we can access the node_modules bin directory, where we have a Prisma executable. And this is how we access that new package's CLI, that's a lot to type. So the alternative to that path is to use npx and then the name of the CLI that we want to call. Before we go any further, I want to show you what Prisma Studio is all about. Prisma Studio is a web application that connects to our database and we can then inspect the tables and the rows and the columns of our database. So we can validate that the information we send from the API to the database gets correctly persisted or updated, depending on the action we perform. So in order to start the studio, we can see npx prisma studio and start that by hitting enter. At this time, this will fail and we will see why. Error, could not find a schema.prisma file. So the schema.prisma file contains the necessary information for Prisma to understand everything it needs to know about our database, such as what's the database provider, what's the URL to connect to it, and what does the database look like in terms of its schema, what tables are available, what columns are within these tables, and what kind of types are these columns. So if we read the error message carefully, we noticed that at the bottom, it tells us that the default location of the file is a Prisma directory slash schema.prisma. So if we take that path, we copy it., and in our root, in the editor, we create a new file for Prisma slash schema.prisma that generates the file that we need. And now we can go ahead and start editing it. You saw I tried an autocomplete, that didn't work. The reason for that is that we don't have a VS Code extension installed that understands this file. So we can head over to VS Code extensions and search for Prisma. There's an insider and a stable version. I prefer to stable version, so we click on it. And over here, you remember that from the Svelte extension that we installed earlier under manage, if you say, add to Gitpod YAML, that will ensure that everybody who opens this project on a gitpod workspace will have the Prisma extension installed by default. Just to show you it ended up over here under VS Code extensions within the Gitpod YAML file. Currently, we don't have it installed, I just added it to the file. So we can either start a new workspace with that new configuration file or easier way is to hit the quick fix link and say install prisma extension. That doesn't take very long and once it's installed, then the line will disappear. And now if we go back to our schema file and we use autocomplete, control space, we now have access to the properties that we need to define. One more thing I'd like to do for future us and our colleagues, in a file like this, where it may not be obvious where we can find more information about it. I'd like to just add a comment, learn more about this file in the docs and the URL for that is HTTPs and pris.ly/d/prisma.schema, quickly double check that there's no spelling mistakes. That looks good, all the information you need in here. As I said, the Prisma team did a fantastic job documenting everything. So we'll drop that. And what we can do now is define our datasource, datasource DB, and then the values inside, lets use autocomplete, it asks for the provider and the provider we want is in our case Postgres. So we have other options here as well. We already know we install the Postgres database, so we'll choose Postgres and still something missing, which is the URL. The URL is depending on your environment, so generally speaking, the format of a Postgres URL is Postgres colon slash slash, and then the username that you created in your database. In our case, because we use the Gitpod Docker image as our foundation for the developer environment, I know the username is Gitpod, and then @ the host name, so localhost in our case, slash the name of the database we want to create. So this in theory works just fine in our local development environment or here on Gitpod. But when we deploy to production, this is no longer going to work because that path is going to be something completely different that we need to set dynamically. So luckily the Prisma schema file allows us to use something called ENV. So this is a way for us to use an environment variable instead of a hardcoded string. And what we want to do here is DATABASE_URL. So with that, we now have to set the DATABASE_URL in our development environment. One way to do that is as you also see in the docs here, we could create a .env file at the root and configure the environment variable there. Another way since we're using Gitpod is we can go to the Gitpod YAML file, and in our tasks, we currently have one terminal indicated by the one dash here. So here we can just add env and then say DATABASE_URL. And the value of that is that Postgres localhost URL that we defined before. So now we know that when we start a new workspace, the terminal with the server will have that DATABASE_URL available, so that's pretty neat, that's all we need for the time being. Let's go back to the Prisma schema, so the schema.prisma file, we have to configure a few more things here. The next thing is we need a generator. As I mentioned briefly, when I introduced Prisma, based on our database schema, Prisma will generate a JavaScript slash TypeScript client that we can load into our API and then interact with the database. So what'd we do here, we specify a few parameters for that. So we do generator client and bunch of things it's asking for, we'll start with the provider. And the value is, there's only one prismaclientjs. The other thing we want to do is specify the binaryTargets. And that is important because as you see in the description, it specifies the operating system on which the Prisma client will run to ensure binary compatibility of the query engine. A lot of text, what it really means is, right now, the Gitpod developer environment uses a Ubuntu operating system. If you follow along in your local computer, may you may use Windows, or you may use MacOS as your environment. What we're doing here is we're just indicating that the binaryTargets we want the client to generate is whatever, I'll show you, whatever the native environment is. That's all the documented, but native means in this case, it will generate it for Ubuntu, when we deploy to Vercel, it will generate it for whatever operating system Vercel uses to run our API. So that gives us the peace of mind, we don't have to worry about anymore. Lastly, and arguably, most importantly, we have to define a database schema. And what that means is if we look at the API just real quick source, routes, todos _API, remember that todos array that we specified? And at the moment, this is just an array, a variable living in memory that needs to move to the database, so in the database, we need a table that can hold all the todoitems that we add to our web application. So we are lucky in so far that we have already a Todo TypeScript definition. So let's head over there and look at what we defined. That definition is under src global.d.ts. And you can see, we have a UID, created at, a text a done. So let's copy that so that we make sure we don't forget any of the properties. And we move back to the schema. And then what we define here is called a model and the name of the model, you can roughly think of that as the table name as well. So that would be todo, and within that, we can specify the properties. So for now, let's just paste our TypeScript definitions. And now we just have to update the syntax to match the syntax used within our schema Prisma file. That's pretty straightforward, so we do it all in one go. We remove the colons, replace them with a space. And then the next thing is that String is a capital S, so is it here, so is Boolean and date is actually more specific a DateTime and we also need to drop all these semicolons. And with that, we are almost ready to go. It's still complaining about an error. And it's saying that each model must have at least one unique criteria that has only required fields, blah, blah, either mark or field ID. Now, what that means is remember in the API source, routes, todos, index.json. Remember we created that UID and we used Date.now, which as I mentioned earlier, never ever do that in a production environment. And we even left a note saying that, replace that with the UID from the database, nice spelling mistake, okay, so at this point we have access to the database. We are literally defining the schema right now, so we can now drop this line. We no longer need to create it. And what we do instead is we remove that, and in our schema, we can tell the database to use that UID field as the unique ID. And in Prisma, we can use the @id for that, and also we want to give it a default value. And the default value, we can use a function to create that global unique identifier based on the cuid spec, so I'll use that. And with it, every time we create a todo record in the database, the database will automatically add a default value to our UID, and we will provide the created at, text, and done. Okay, that was a bit of configuration here, now, the error we received in the console before was that this file didn't exist, so we couldn't start the server. Now there's one more thing we need to do. Remember in the Gitpod YAML we specified the DATABASE_URL as Postgres localhost blah blah? If we were to commit these changes and start a new Gitpod workspace, that would be available, but at the moment, if we do echo DATABASE_URL, we actually, we have it because I think I already ran it, but that, we have to make sure this environment where it was to set, so we do have it, and now let's try to clear this and run npx prisma studio. Give that a second. It is saying that services available in port 5555. We can close that preview here, but if we open a browser, it opens up the Prisma Studio and you can see that it shows us all the models we defined, so in this case Todo model, that's the only one we defined in our schema down here. So if we click on that, it gives an error, unable to run script. Let's have a look invalidate, blah, blah, and then here the table public todo does not exist in the current database. That is true because we never actually created that table. The only thing we did was we defined the model, but we never told Prisma to create that table in the database. We could go to the database and manually run a SQL query that, you know, create table with these fields. But the whole point of using Prisma is that we can automate all that. So let's stop our studio with control C and I will show you how we can ensure that the database is always up to date. So the command we can use to make this work is again, we use npx prisma migrate dev let's see what happens, basically migrate, is going to look at the Prisma file it's going to see that there's a todo record. And when it sees that record, it will then go to the database and check whether the database matches what's configured in our schema. And let's see what happens at the moment, just FYI, the database is empty. So there's going to be a discrepancy between what we expect the database to look like with the todo table and the empty environment in the database, let's run that command. Alright, so let's walk through that together. Prisma schema loaded from this file, excellent. Datasource db is Postgres, mhm very good. Schemas, public and localhosts, 5432, that looks all good. And now it's noticing that the database doesn't match the schema. So it is asking us to provide a name for the migration. So at this point we really just initialized the database. So let's call it init. We say init and hit enter. All right, let's give this a second, and then we're going to go back and review everything that was going on here, it's a lot. We specified init as the name of the migration. And then it says the following immigrations have been created and applied from the new schema changes. Something in a migrations directory, blah, blah, blah. And then your database is now in sync with your schema. Let's look at that file, look at this, there's a SQL file. Prisma migrations. There's a directory here and a SQL file. If we look at that file, oh my, look at this, it generated the SQL that is necessary to run against the database in order to create that table with the necessary columns, such as the text, the Boolean, the done, the UID. It also created some constraints on the primary key being the UID field. That's incredible. All done for us, all we had to do was just specify what we wanted to look like. Good, let's go back to the terminal and see what else went on here. And then it says that your database is now in sync with your schema. So not only did Prisma generate the SQL file, it also ran it against the database. Very cool, we had literally nothing to do here. It just did it all for us. And then it ran generate, and it did a bunch of npm stuff here, blah blah, blah blah, all good. And at the end it says, generated Prisma Client to node modules @prisma/client That is something we're going to look at afterwards. For now, just note that in this directory, we now have a client that we can use in JavaScript that is fully aware of the schema of our database. It knows about this todoitem. There are functions available to us that we can leverage to find, update, and delete records. We'll get to that in a second. For now, I want to go back and clear the terminal and then go back up and run that Prisma Studio again. I'll take a second, I'll close to a preview and we can ignore that because we already have the tab open. And if we go back to the, reload that page, let's have a look. We are now looking at the todo table and you can see there's a UID, created at, text. We could add a record from here and go ahead, change the date, add a text, change the value of the done and commit that, we'll do that later, but for now, just know that Prisma Studio gives you a way to access your database through a web browser. So we'll discard the changes. One more thing I want to do. Anybody who works on this application sooner or later is likely going to need access to that Prisma Studio, but they may not know the command npx prisma studio, and we want to make this so easy for them that they don't even have to run the command, again, we can automate it. Let's imagine we start a Gitpod workspace. And in one terminal, we run npm install and fire up the web application. In another terminal, we automatically start Prisma Studio and then we open the preview in a new browser tab of Prisma Studio. Let's see how we can do that, just like we configured the init task here. We can create another one and we don't have any init for that. We only have a command and command is simply, npx prisma studio, and we also need to specify the environment variable so that Prisma Studio knows how to connect to our database using the DATABASE_URL environment variable. And with that, it will automatically open two terminals at start up of the workspace. And lastly, it will start a new service on port 5555. So let's configure that port down here by saying four times 5, 5555 and on open, we want to open a browser window automatically. So we will have two browser windows open one for the application and the other one for the Prisma Studio. There's a lot going on in this file. Generally in this PR we made a bunch of changes. I think at this point, we can go ahead and review and then almost ready to commit and start working on the integration with the API. I think the, let me just have a quick look. Yep so there's one more thing we need to do before we move on. Remember how we manually created the migration, we ran Prisma migrate dev? We can automate a little bit more. Let's assume somebody starts this developer environment. And at the very first time, their database is always going to be empty because every environment is going to be built from scratch. So in order to make sure the database is always in sync with our schema, that we specify here, we want to make sure that that Prisma Migrate dev command automatically runs before we start our SvelteKit application. So that's an easy fix. All we need to do is open the package.json file. We already have a dev script. Now in order to run something before the dev script, we can either come here and say, prisma migrate dev && SvelteKit dev. However if we want to run more commands before we start the dev server, this starts to get really hard to understand. So here's a little trick that NPM provides. We can take that and then take the name of our command and create a new command or a new script called pre and the name of this one here, let me show you, in this case, we are talking about, we want a dev script. We want to run something before the dev script runs. So we can say predev, which means it runs before the dev script. And we wanna run prisma migrate dev. This is nothing, you know, no matching, that's just a regular NPM feature. And with that now every time we start our dev server, if we came here and ran NPM run dev, we hit editor, you can see that Prisma Migrate dev runs first. And then it starts to development server and our application is up and running. So let's have a really quick look at the output. Prisma Migrate dev same output as before it loaded the schema file, connected to the database, but now it says already in sync, no schema change or pending migration was found. That's because of the migration we ran before. The schema, our model here is already available in the database. That's why it doesn't run anything. The next time we start a workspace on Gitpod, this will not be the case, the database will be empty. And Prisma will a automatically run our migrations in order, based on the date that's in the folder name here. So with that, we have a lot of code that is ready to get committed. And that's exactly what we're going to do next. Time to head over to the source control and do a quick recap of what happened, make sure we don't have any bugs. So we added a new terminal that runs npx prisma studio. We have the new environment variables, and we also open a browser for Prisma Studio. We added the VS Code extension so everybody gets the same experience when they edit the schema.prisma file. We added a predev script, so that our web application always has the database up and running. And the latest changes are applied before we start the dev server, so predev. We added to Prisma CLI as a dev dependency, and you can see it also automatically added a Prisma client dependency, that was added automatically when we ran the migrate command the first time, so that we can then use @prisma/client in our code to access a generated client to connect to the database. We'll see that in a couple of minutes, the probably most important file that we worked on as part of this part is the schema.prisma file. We specified that we work with a Postgres database, the URL is from an environment variable and the provider for the JavaScript client is prismaclientjs. And at the bottom we have the Todo model. And this is where we now generate a UID automatically with a cuid specification. So it'll be a random generated ID that we'll see in just a second. Lastly we made a small tweak to the API and the tweak was that we removed our very bad workaround here to create a UID because now the database will do that for us and we no longer have to do that manually. So with that, let's go ahead and commit these changes. So add Prisma & init migration. We can commit this and create a pull request here. Let's call this use Prisma ORM and we will close issue number 15. Now we only just configured to Prisma Client, the CLI so far and set up the migrations. We have a little bit more work to do to update the API and leverage all the configuration we put in place. So we'll make this a draft and we go ahead and create the branch and the pull request up on GitHub. That only takes a couple seconds. And then once it's ready, we can go ahead and close the Prisma Studio here and let's go have a look, see if that worked. It doesn't seem to have pushed that let's oh, it's pending, okay, let's see what's going on. I think we can have a look. Review no matching. Okay, maybe what we can do, let's just give it a second, maybe there might be some hiccup here, it seems to be loading. Nope, maybe that was it. Not yet. Let's cancel that here in the console and have a look what's going on. What if we push manually, maybe we'll get it around. It could be some GitHub issues. We had something going on yesterday as well. All right, that created the branch and we should be able to create that pull request manually, that's no problem at all. Call this use Prisma ORM. You don't need any of that, just close issue number 15, I believe it was. And then create a pull request. There is many ways that lead us to Rome. So all good. We want to convert it to a draft and keep working on it before we mark this ready for review. Good with that, we can go ahead and shut this workspace down, close the tab, and from here, we'll now move on and start to use that Prisma Client that got generated for us and use it in the API so that we can then persistent read and update items in the database. With the Prisma configured in the environment and the studio automatically starting up, it's now time to update our API in order to leverage all the work we just did. So firing up a new workspace to get us going. And then we will also see for the first time how the updates we've made to the Gitpod YAML file will impact a startup of a new workspace. So it will start two new browser tabs, one for the application preview, just like we've always had. And then a second one that is going to show the Prisma Studio web application, where we have access to the database to look at tables and the content of the table. So we can validate that the API properly persists the changes that we made in the frontend. So this is a fairly straightforward part of the course. All we will do is update the API file and replace that todos array that we've had so far with functions to interact with the database. Just giving Gitpod here another couple of seconds to pull down our base Docker image. And then we should be off to the races. That sometimes takes a couple seconds more than on average, but ultimately it is still super convenient to have all that just automated so anybody who works on our project gets the benefits of the work we did throughout this course without fully understanding what needs to be installed and what needs to be done. All right, we got our two browser tabs. One is the application, one is Prisma Studio with the Todo model, that's currently empty nothing in here and we get all of this preview data we can safely ignore. Good. Let's get going, so down here in the terminal, you notice that on the right side, there are now two terminals. The second one that's currently highlighted is the Prisma Studio. And the first one is the one that runs our web application on port 3000. So you can navigate between the two if you want to start or stop any of the services. Okay so the main file we're going to work with today is source, routes, todos, _api. Now we moved all that code into this file a while ago, and now we're going to actually see some benefits of that because any interactions we've had with that todos array is now consolidated into that one file. So now that we're going to replace that with the database table we created. We can just update to code below here to leverage calls to the database. So when we ran the migrate dev command from Prisma, so in the package.json our predev script, prisma migrate dev, that generated our Prisma Client. If you recall, in the terminal, if we scroll up just a bit, it generated the, it used the migration and applied it to the database because we started a new workspace, the database was empty, and it also generated that Prisma client into node_modules @prisma/client. Okay, now that client, we will see that in a second is fully aware of our database model. And we can import that because it's in the node_modules directory, we can input it like we would any other package. So at the root of our file here at the very top, we can add a new line saying import Prisma from @prisma/client. And we can then use that instead of, you know, todo.push, for example, we can use that new Prisma import. Now there is one gotcha. and that is related to a temporary workaround we need to implement until everybody moves to ES modules. So that line import Prisma from Prisma client works well in our environment, but once we deploy to Vercel, we'll need to import this slightly different. Long story, there's some information online, but we basically want to extract that for the time being into separate file and allow us to deal with that workaround. So just bear with me as we go to source, lib, and we create a new file here called prisma.ts. And within that, we basically implement the loading mechanism of both approaches, one that works on our development environment and one that works on Vercel, and then we will use that in our codes, in the API file so that we don't have to deal with any if else statements and whatnot over there. So the way we do that is we import Prisma, but also we import star as PrismaAll from the Prisma Client. So as I mentioned, depending on whether we run on our environment here or in Vercel, this one, or this one will be undefined, one of the two, and it's the opposite way, depending on the environment we're on. So all we need to do now is we say the actual Prisma Client is either Prisma if it's available, so TypeScript, we can use question mark. So Prisma Client or alternatively, PrismaAll again, if it's available, dot PrismaClient. And then we see export default, the PrismaClient. And now with that, we don't have to worry anywhere else in the code, whether this approach loaded the correct client or this approach did with the star as Prisma Client, all because in this line here, we basically just pick either this or the other one and export to Prisma Client. With that in our API, we can simply say import the PrismaClient from remember the shortcut with $lib/prisma. And now we can use that Prisma client just like we would if we imported it regularly according to the Prisma docs. A small little workaround that we need to make this work on the local environment or in Gitpod here, as well as on Vercel. Now, the probably most exciting part of this entire course is that we can finally get rid of this todos array and no longer the todo items in memory and lose them every time we restart the server. So let's celebrate by dropping this, hooray, is gone, we'll never have to worry about it again. Instead what are we going to do is we create a new instance of that PrismaClient. Let's call it, Prisma equals new PrismaClient. And now you'll see the power of Prisma in just a second, if we take this and we start to go through all the places where we access currently that array, and we replace it with a call to the database, let's check this out. So here we want to fetch all the todoitems that are persisted in the database, so let's look at this. We use Prisma dot and now the autocomplete show us a todo property with that todo, we can then say find many. And you can see there's code examples right in the docs. So that get all todos is const todos equals await Prisma todo findMany. So we'll do findMany. We call that and this returns a promise. So we'll say await and we make this an async function. Unbelievably cool. You can tell I'm really excited about this. This is such a game changer to how we've developed with or interacted with database from JavaScript in the last 20 years, Prisma really sets the bar high with that approach. That's literally all we need to do, and as you saw, we had full TypeScript support for our todoitem. If we were to go into the Prisma schema and start to add more models or update the model, every time we start a dev server, the new client will be generated and we would have access to these new fields and functions and everything immediately through TypeScript autocomplete here. Okay. The next thing is we want to create a new todoitem. So far we just set todos.push, now, this is no longer the way to do it. The new way to do it is that we say await prisma todo, and guess what, create, ah, so cool. And within that, we have autocomplete, which asks us to provide a data property. We will happily do that, and as part of that data property, you can now see that it's asking for created at, done, text and an optional UID. Again, fully autogenerated because of our model. And we know what these values are, so let's go ahead. Top to bottom, created at is the data dot created, oops created, what did we call it created at? And we know this is a date, so we'll tell TypeScript that. And then we have done, which comes from data.done, that's a Boolean. All right. And we have the text, which is data.text as string. And with that, we now have a new item created in the database. So that push is no longer needed. Now here's one thing we have to change. And the reason we need to change here is so far our post endpoint added to UID right here. This is no longer the case, but when we add an item to the database, the response to the frontend has to include the UID, or basically it has to include the todoitem with the same data that we have in the database. So we could, you know, use Prisma to go fetch the newly created item somehow. But the better way is that the create function actually returns the created item for us. So we can just say, body equals and drop this part here. Now we create the item in the database and when that's complete, the response we get back from the database is newly created item that contains the UID. Moving on, let's see how we can delete an item. This doesn't exist, but we can say await Prisma.todo dot, let's see, do we have a delete? We have a delete right here. And what do we want to do? In the docs, It says that it wants a where clause, where we can specify which element we want to delete. All right, let's have a look. We'll pass in an object with a where clause. And it's suggesting that we provide a UID. Let's do that. We know that the UID we want to delete is the one we get from the request params.UID. And that will take care of removing that element. We can apply whatever response we get back to the body if we wanted to. That's all good. Lastly let's look at how we can patch an object in the database. So none of that is needed anymore. As well as the body, we will do that in one line, body equals await prisma todo and then guess what, there's an update function. And the update function wants an object, let's have a look data and where, okay, we are already familiar with the where. So we can just use that. We know it wants a UID, which we have. And also it wants a data property, which presumably is going to be the data we want to update for the given todoitem we selected up here. So data, we have data, text, and todo done. So let's say done, and the value for that is data.done. And the other thing is the text. And that is data.text that we want to put there. Okay, now we don't need that code from before, we don't need that. That looks good. And what we can do now is go have a look at what this looks like in the user interface. So first of all, let's go all the way to the bottom here. This looks good, seems to compile. If we switch over to the application, let's inspect the network tab. So here we'll add a first item, that seemed to have worked, something happened, at least we show it in the UI. Let's look at the requests. Todos JSON, all right. We sent the text, and in return, we got an item. There's our new UID generated by the database. Definitely a lot more unique than our timestamp that we had before. Again, a reminder, do not use Date.now as a UID, never ever. So very cool, let's look at Prisma Studio to double check if that item actually got persisted. So heading over to the Prisma Studio tab, and there's a little refresh icon, voila, we have our very first todoitem persisted in the database, which means that we could now stop our server. Let's do that. Stop our frontend server and start it back up, let all these scripts run and do what they need to do. All right. There's a new preview, and guess what, it shows our item still here because we fetched it from the database. Let's have a look at the done column, it's currently false just to make sure updating works as well, we check it. We come back and refresh, and this now says true. And lastly, for good measure, first item persist in the Prisma Studio. First item is now persisted. What a wonderful time to be a full stack web developer. So many tools that make life so easy. And we now have TypeScript support basically from the database all the way to the frontend. And if we were ever to change anything, TypeScript would yell at us right away telling us to update our code and match the new code we want to implement. Okay, let's close the Prisma Studio, close out preview, and commit the changes that we made. We finally were able to drop that todos array that we now replace with database calls, and you can see, we have the Prisma instance of the Prisma client, and that now autocompletes our todos and the functions we can call on that todo object. With that, let's go ahead and commit that. We're now using the Prisma client. All right, let's commit. Yes. And then since we already have a pull request open, we can just sync our changes and let GitPod send that up to GitHub. And here we go, we now got that code in here. And that marks the end of that pull request. So ready for review, ask our colleagues to have a look. They can go through, see all the changes we've made to the different files as part of this pull request, our migration autogenerated and our file here with the schema where we defined what the table looks like. And then the update to the API, where we replaced the in memory array of todoitems with calls to the database to assist and update, all that. Wonderful and with that, we can go ahead and merge that pull request, and then move on and start to look at some more things in order to deploy this application to production merge it and delete the branch. Good, that's all cleaned up. That environment is no longer needed, we'll stop it, get rid of it. And that marks the end of this issue that we worked on. What an exciting time. We now have our full stack application that is running perfectly fine in a local developer environment or in a Gitpod developer environment. We have a frontend API and the database, everything is connected, everything communicates and what's missing in this course, and to wrap it up is in order to use that application, we need to deploy it to production. So for that, we have two tasks ahead of us. The first one is to deploy a Postgres database to Railway. And the second task is to deploy the API and web app to Vercel. We will start with the database so that when we deploy the API, it will be able to connect to the database right away. All right, first things first, we had over to issues. We have two issues left. One is to deploy a database on Railway. That's the one we want to work on. So we fire up a new Gitpod developer environment. And once that is ready, we will be able to make a couple of changes just so that when we deploy the application to Vercel, everything works and is in place the way we expect it to be. So here is our developer environment spinning up and it fires up Prisma Studio, which we don't need right now. And our web application preview, we don't need that either. So all we really need here is the package.json file where are we going to make a couple of changes. So we can cancel that Prisma Studio, we can control C and switch to the other terminal here. This is where our application runs. We'll cancel that as well for now. And what we now need to do is in the package.json file, you remember, in development, before we start the dev server, we created a predev script where we run the prisma migrate dev command. This helps ensure that the Postgres database is always up to date with the latest migrations that exists under Prisma migrations. Now this, as the command says is for development, but when we deploy to production, there might be changes to the database schema that we have to apply to the production database as well. And in that case, we don't want to run Prisma migrate dev. We want to run a production level command for that. Now, when do we want to run that command? When we deploy to Vercel, the Vercel adapter for SvelteKit will automatically execute the build script. So, or in other words, Vercel will actually execute the build script and the SvelteKit command line interface here, that will then execute the Vercel adapter and deploy the application. And we'll talk about that when we deploy the web application, but the build script is something where we want to run that command to update the database and migrate if there are any migrations. The problem is we could run that build script in our local environment as well, so this would be confusing. We wouldn't want to update the database by running the build script locally. So luckily there is a script that we can leverage. So if we add a new script to our package.json file, and we call it vercelbuild. This script is only executed when we deploy to Vercel. And at that time, this is the perfect place to upgrade our database. The way we do it is we use Prisma, prisma migrate, just like we did in the predev script, but instead of dev, we use deploy and then once that's done and the database is updated, we can say && npm run build. So that Vercel then kicks in, first deploys the database and then runs the build script for the web application. So let's quickly run that build script. So the one we're going to execute here npm run build, let's run that in our environment to see what actually happens when we deploy to Vercel. So npm run build. And it is now telling us that it could not detect a supported production environment. And that's because we are not actually running on Vercel. So because in our Svelte config, we use that adapterauto, it tries to determine where we are executing this command from. And because it doesn't see this environment as being Vercel, it automatically basically gives us that error. Now I spend a lot of time in the SvelteKit source code, so I know that if we temporary export a variable called Vercel, and we give that, let's say a value of true. And then we run that and NPM run build script again, it goes through the same steps and now it determined that we are on Vercel. So we basically just, you know, cheated a little bit, but this is only temporary because I want to show you what happens on Vercel. So the first thing we noticed is that he created a new directory called .vercel_build_output, and within that directory, we have a functions subdirectory and then node, and then render. So that index file here within the render directory, this is our generated code, it's very long, but that's basically our generated code for the application that we developed, our service side application. Now, when we deploy to production in that directory here, we need to include our schema.prisma file, that needs to be available so that when we run Prisma migrate deploy, Prisma can find the schema, and in the schema, you'll remember, it has the information on how to connect to the database, what database it is and all the schema information. So because of that, we want to run a script after we build that directory, so we can say here in the package.json file, postbuild, so it just like we had a predev that runs before the dev script, we have a build script and if we say post build, that script runs after the build completes. So what we want to do here is copy our prisma/schema.prisma file. And we want to copy it into that render directory that we have here, so let's right click and see copy relative path. And then in our copy command, we'll paste that so that we go from .vercel_build_output into here, functions, node, render, add a slash at the end. So that copies the Prisma file. And there's one more thing we need to copy that are these binaryTargets. So they get generated by default into the node modules directory and within the node modules, under the, @prisma, we have a directory here called engines and within the engines, you can see the lib query engine debian open SSL something something, that file or a similar name, depending on what environment Vercel runs needs to be copied into that same functions directory. So that way we can do that is just like we copied that Prisma file. We can add another copy command, and this time let's go back node modules, Prisma engines. We want to copy that relative path. So from that directory under @prisma engines, we want to copy everything that contains query and the place we want to copy it to is the same one here under the Vercel build output functions, node, render, we'll drop that at the end here. So that makes sure it copies these query files, if there's more than one, it would take all of them, put them in the right place. And the other thing we can do just in case we were to run that build script again, let's ignore the Vercel build output because we don't really want to commit that that would be bit of a mistake. So in our gitignore file, we can say that we do not want that Vercel build output committed to Git, so that's good. All right. Few things happened here. We basically just prepared the application so that on Vercel it makes sure that it runs prisma migrate and then npm run build. And after the build in the post build script, we copied the schema to the function on Vercel and we also copied query files to the same directory. Okay. Let's go and commit these changes. So configure, configure, Vercel build, and post build scripts. Alright, and we'll commit that. Yes. And we can open a pull request. So let's call this deploy database on Railway and this will close issue number 18. Alright. We'll say create, yes please publish. Let's give that a second to do its job. And we now have a pull request that contains these latest changes. So as part of the deploy database on Railway, we also actually have to go create that database on Railway. So the way we can do that is we go to Railway.app. And even if you're not logged in, we can just say start a new project and provision Postgres database that runs for a few seconds. And now we have a Postgres database running. You can see that this is a temporary project and will be deleted in seven days. That is because I am an anonymous user. I will eventually claim that so that the database stays online and you see all this working in action. For now, this is all we need. One important aspect is if you click on the Postgres link on the left here, we can then eventually see some data. But for the time being, if you click on connect, you can see our Postgres connection URL listed right here. This is something that we're going to need when we deploy to Vercel. So let's just keep this browser tab open and we will come to that and copy it in a second. For now, though, we've done the work that is necessary to deploy to Vercel. And we have a few scripts here that are needed to make sure the database in production is up to date with the latest schema and we can deploy. So we are good to go and can merge this pull request into the main branch, drop the branch, and go ahead and shut down our workspace. Alrighty, and we can now go back to issues where we have one left, that's deploying the application to Vercel and then configure it so that it can connect to the database we just deployed, let's go and do that now. Last step of this course, we have to go ahead and deploy the web app and the API onto Vercel, and if we compare to the architecture this is the piece right here, where we have to go and deploy that and then make sure it can properly connect from Prisma to the database we just deployed a little while ago. Okay. Here is the best news that you can possibly imagine. When it comes to deploying a SvelteKit application to, at the time of this recording, Vercel, Netlify, or CloudFlare, you don't have to do any code changes. The reason for that is that in the Svelte config file, we have an adapter that is being imported that's called adapterauto, and that is used here. As you recall, from the very beginning, adapters are used by SvelteKit to prepare the application for the different environments. So if you deploy to Netlify CloudFlare or Vercel at this point in time, then you don't have to make any code changes. If you're curious what the latest supported environments are head over to kit.svelte.dev/docs, scroll down in the navigation until you get to adapters where it says supported environment, and you have a list here of supported environments. So the three are here, we are deploying to Vercel. So we are in luck and we don't have to actually make any code changes. The only thing we have to do is log into Vercel. So make sure we create an account, pick the right team, and then you can say new project. And from the screen, you select the organization or the account, and then the project you want to deploy, in my case, that's the full stack web development project. So I can import it. You can see that it automatically recognizes this as a SvelteKit project. So it analyzed my code in Github and it saw that this is a SvelteKit app, no need for me to make any changes. However, if we look at the environment variables, there is one thing that we want to configure, which is our DATABASE_URL that we configured locally or on Gitpod as part of the developer environment. In production, we also have to specify a DATABASE_URL, so that Prisma knows how to connect to the database. The value that we want to add here comes from the Railway.app, remember we created a Postgres database here and it has a Postgres connection URL. So we want to copy that. And over in Vercel at this as the DATABASE_URL, we say add, and with that, that environment variable is available for Prisma to pick up and we then can say deploy. And you can see down here, it starts to build four seconds ago. It's running all the necessary scripts in order to build the SvelteKit application. It will also run the post build scripts that we specified so that the database will be populated with the table that is needed as well as all the other things that are necessary to make this work. Lots going on. We can see here that one migration found in the migrations. So it applies that. This is happening because we specified that Vercel build script, which runs Prisma migrate deploy. So this is why it said, Hey, I'm running this migration and applied to the database. It does a bunch of other stuff. There's two warnings we can safely ignore that's okay. And eventually we are uploading the build cache to the server. And I have seen this page getting stuck at certain times, and it looks like this is one of those days, so this has been running for a minute, which is a bit longer than it usually takes, which is fine. What we can do is instead of waiting here for that to never finish, we can just go back to the top and click the back button here. That brings us to that page where we can input a project. So if we just click at the top on our team, we can now see that we have that project configured here. And if we open it up, we get a nice little preview of our todo application. And over here, we have the URL available to us. So if we click on that, you can see that fullstackwebdevelopment.vercel.app is our production environment. And if we come in here and we add an item saying, first, we can enter this, hit enter and see what happens in the database. Let's do that one more time. There we go. And now we have the first item added to the database. If we head over to Railway and we select the data tab in our Postgres database, we can see that Prisma created a migrations table, that's okay. Prisma will manage that, nothing for us to worry about. More importantly we can see the todo table that now contains our first todo item. If we were to go back to production, mark this as done, and then head over here, you see that this done column changed to true. And we could go ahead and add a second item and even a third item. This works just like it did locally. And we could even go ahead and remove certain items that would then reflect what we see in the database. First and third, true and false, true, false, first and third. What an exciting time, truly how we deploy web applications as a full stack developer has dramatically improved over the last couple of years, thanks to amazing companies, such as Vercel and Railway development of these applications as well is dramatically changing. Thanks to developer environments in the cloud by using Gitpod.io. With that, we can head back to our issue. And one thing we want to do here is take that URL and leave a note saying that application deployed to this URL. We leave that comment and we can go ahead and close that issue. This complete the coding part of this course. Amazing work, congratulations on making it all the way through. You now have a full stack web application available here, built with Svelte, SvelteKit, using Prisma to connect to a Postgres database. And all of that is deployed to Vercel and Railway. Excellent, congratulations, you have developed a full stack web application, deployed it to Vercel, deployed the database to Railway.app and connected all these pieces together so that this is now a really good foundation to build anything on top of it. Let's quickly recap what we've done and how you can move on and do more features, development on that, or add other things you might be interested in. First off we created a user interface with Svelte that was really the basic foundation that we needed for the web app in order to create todoitems, update them, delete them and display all of it. We then moved on and created a SvelteKit backend API. There was a REST API with endpoints to create, read, update, and delete todoitems. We used REST or HTTP to connect to that backend and returned JSON data to display in the UI. At the very beginning, we started off building that application with JavaScript disabled. So we used the regular HTML form elements and post requests to submit the data. We then enhanced our forms with Svelte actions, which allows us to intercept the HTML form submission, and instead do an Ajax request. So we don't have to reload the entire page for every action that we do. So we now have a front end that works with JavaScript. It also works with no JavaScript enabled in the browser. In the second part of the course, we went ahead and used Prisma, an ORM to let us connect to a Postgres database. This really simplified the entire integration with the database, we did not write a single line of SQL code. All we really did was using generated TypeScript and JavaScript in order to connect to the database, we were reading data, updating data all by simply just calling functions within our JavaScript and TypeScript files. Lastly when we had all this working in a developer environment, we then deployed the web application to Vercel and we deployed the Postgres database to Railway.app where it is now running so that we can connect to it from our production environment. When we developed the project, we did all of that in a Gitpod developer environment. So you notice that for every task that we worked on, we started a new GitPod workspace. And this is the concept of what ephemeral developer environments or are all about. You start in an environment, it's fully automated, it started our developer server, installed dependencies, and we then basically could just write our code, stop the environment, and for the next task, we opened a new environment to do the work we wanted to do. Amazing achievement, congratulations, once again, this is a full stack application that you can use as a foundation to do further work and build your own projects. Let's spend a few minutes talking about what's next. How can you further enhance the application in order to deepen your knowledge about the technologies that we used and the different providers where we deployed the application as well as the database? The first thing I want to bring up as a suggestion to look into is trying to deploy the web application and the API endpoints to a different hosting provider. As part of the course, we used Vercel and I introduced you to the adaptor concept of SvelteKit. So an easy kind of next steps would be to maybe deploy this entire application to Netlify or CloudFlare or any other hosting provider that you might be familiar with. So this would be a good next steps, minimal code changes in order to get it resolved. So you would get some quick success by looking into this. Another suggestion would be to play around and try to use a different database. Maybe you are not familiar with Postgres. Maybe you are more familiar with MySQL, try to change the database to MySQL instead of Postgres. Read up about the Prisma configuration, how you can change that and, you know, try Railway or try Planet Scale or any other database provider. See if we can connect the API to that database system and learn about that part of the backend development in this entire stack. Lastly, a third suggestion to look into might be to enhance the project. Right now, this is a very simple todo application where everybody who is using it, they'll get the same list of todoitems. Now it would be more helpful if for example, there were people you could assign items to, and of course, if you just had your own lists, so add some kind of authentication to the system where, you have to log in with GitHub or maybe email address and password, and then you could add due dates where you say that this item is due by Friday. So try to learn how to persist that in the database. And overall this could really be an application that you can build out as part of your learning journey for the full stack application development. Alternatively, you could take what we built, use the concepts and build something completely different. I would love to hear what you come up with based on the course, so do reach out and let me know. Otherwise let's wrap this up with a few more words about the overall course. With that thank you so much for taking your time and working through this course. It was a great pleasure putting this together, and I hope this gives you a good foundation for your next project when you want to build a full stack web application with a frontend, API, and the backend database. You can find me on Twitter @MikeNikles, I'm also available on my website at mikenikles.com where I have blog posts, I have links to open source projects that I work on. So do check these out and also have a look at www.gitpod.io, the underlying developer environment that we use throughout the course where we spin up a fully automated developer environment for each given task. And we then shut it down when we're done and move on to a new one the next time we work on an issue. Do check out these links. Let me know if there's anything I can help you with, I would love to hear from you, if you have feedback, please let me know. I'd love to make a full up course or maybe something else to help spread the knowledge and let people learn from the experience that I have.