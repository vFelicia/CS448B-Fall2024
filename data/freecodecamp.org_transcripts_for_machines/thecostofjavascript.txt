hey folks so building interactive experiences on the web today usually involves sending some javascript down to your users often quite a lot of it today we're going to talk about some strategies you can use to deliver that javascript efficiently while still giving users a really great experience so i work on a web browser called chrome and when users access your site you're probably sending down a lot of files from a web browser's perspective this looks a little bit like this it gets even worse with h2 multiplexing so my perspective is that as much as i love javascript it may be the most expensive part of your site buy for byte javascript is probably the most expensive resource you're shipping down to your users today and i'd like to explain why i feel like that so the median web page today is currently shipping down about 350 kilobytes of minified and compressed javascript uncompressed that bloats up to about a megabyte of script now the experiences that are shipping down this much javascript are taking anywhere between 15 to 36 seconds to get interactive on mobile devices now although i've said 350 kilobytes here the reality is that if we take a look at popular sites they're actually shipping down a lot more script than this we're hitting this ceiling across both desktop and mobile web where sites are often shipping multiple megabytes worth of code that a browser then needs to process now the impact of this can have on loading a web page is some weird and wonderful quirks so the way that we take a look at loading a web page today is that it's a little bit of a journey it's kind of like a film strip that has three key moments in it there's is it happening is it useful and is it usable is it happening is the moment where you're able to deliver some painted content to the screen so the user can actually tell well hey this web page is loading up is it useful is the point where you've painted contentful text or something that allows the user to drive value from the experience and then is it usable is the moment when a user can actually start tapping around the experience and having something happening so i mentioned this term interactive earlier but what does that actually mean well for a page to be interactive it has to be capable of responding quickly to user input whether a user is clicking on a link or scrolling through a page they need to be able to see that something's actually happening in response to those taps and those actions that they're making an experience that isn't able to deliver on this is going to frustrate your users now one place where this can commonly happen is when folks are serverside rendering their experiences and then shipping a whole bundle of javascript down right after to populate and hydrate that experience out now when a browser needs to run many of the events that you're probably going to need it's probably going to do it on the same thread that handles user input now that thread is called the main thread or the ui thread if you happen to be shipping down lots of expensive javascript that can end up blocking the main thread so let's take a look at what you expect will probably happen so here's an example where you know maybe you're going to go and tap around the ui you might check a check box or click a link and everything's going to work perfectly fine but if we simulate blocking the main thread nothing's able to happen at the moment we're not able to check that checkbox any links that we click are not necessarily going to do what we expect because we're blocking that thread so we want to start moving away from doing those types of things now this idea of javascript impacting interactivity is something we're seeing across lots of different types of sites too much javascript in general can actually delay interactivity for visible elements and this is a problem for many sites including google so we run into this in sites like google search so here are a few examples where you know you could start tapping around the ui but if we're shipping too much javascript down there could be some delay in there before something actually happens and the user may end up feeling a little bit frustrated so that's an experience that we want to move away from when it comes to time to interactive we feel that you should probably be getting interactive in about under five seconds there's nothing actually on this person's screen here so they may be going through withdrawal symptoms of some sort ideally we'd love to shift the web to a position where we're designing a little bit more for resilience interactivity can heavily impact a lot of things it can be impacted by a person loading your website on a mobile data plan or coffee shop wifi or just them being on the go and not necessarily having a consistent network connection now when this happens and you have a large payload of javascript that needs to be processed they can end up waiting for the site to actually render anything or if something does render they can be waiting a long time before they can actually tap around and have something happen ideally shipping less javascript would lead to a point where they're not necessarily running into those cases now to explain why javascript is such a big deal and why it can have such a large cost i'd like to walk you through what happens when you send content down to a browser so a user goes and they types in an address bar and types an address into their omnibox their address bar a request is made out to a server which will then have to return some markup the browser needs to parse that markup and get out the css the javascript the images that are necessary and then the browser actually has to process all of those resources this is actually a an accurate depiction of what happens in chrome when we're trying to process everything that you send down now although this looks great one of the challenges here is that javascript can actually end up being a bottleneck so ideally we want to be able to paint pixels quickly and then have the page interactive but if javascript's a bottleneck you can end up just looking at something that you can't actually tap around with and experience so we want to move away from javascript itself being a bottleneck to modern experiences one thing to keep in mind as an industry is that if we want to be fast at javascript we actually have to be fast at downloading that script parsing it and compiling it that means that we have to be fast at the network transmission side of things but also the processing side of things for our scripts because if you're spending a long time parsing and compiling script in a javascript engine that can delay how soon a user can interact with your experience now to provide some data about this here is a breakdown of where v8 the javascript engine in chrome actually spends its time while it's trying to load up the page containing script so in the orange we have all the time being spent parsing the javascript the popular sites are sending down and yellow is the time we spent compiling and together these take up anywhere up to 30 percent of the time it takes us to load up the javascript for your page this is a real cost now another thing to keep in mind with javascript is that all bytes are not equal when it comes to the web 200 kilobytes of script and 200 kilobytes worth of image have very different weights they might take the same amount of time to download but when it comes to processing we're dealing with very different amounts of costs a jpeg image needs to be decoded rasterized eventually get painted on the screen a javascript bundle needs to be downloaded and then parsed compiled executed there are a number of other steps that an engine needs to complete just be aware that these costs are not quite equivalent now one of the reasons why these costs start to add up and matter is mobile so mobile itself is a spectrum many of us here today probably have a highend or median end phone and the reality is that our users may not necessarily have those device classes they may be on a low end phone they may be on a median phone and the disparity between these multiple classes of devices can be quite stark due to thermal throttling difference in cache sizes cpu gpu you can end up experiencing quite different processing times for resources like javascript depending on the device you're using so here's a breakdown of how long it takes to parse javascript from a range of different types of devices at the very top we have highend devices which generally process it pretty quickly the very bottom we've got our low end devices and in the middle we've got our average phones so things like the moto g4 or the moto g5 now take a look at how much longer that script takes to process we can we can actually try to look at a more practical version of this so here is the javascript startup time and processing time for cnn.com javascript on an iphone 8 using the a11 processing chip that they have it takes nine seconds less to process javascript than it does an average phone nine seconds that's nine seconds quicker that that experience would be loading and interactive on an iphone than something more average this hints at another thing that maybe we need to stop necessarily taking fast networks and cpu and high ram for granted fast devices can actually sometimes be slow you can be running multiple things on there fast networks can be slow variability can end up making absolutely everything slow you may have users that you know are not going to have the the latest and greatest phone they might have something more average and so it becomes really important for us to start testing on real phones and real networks so if your team were able to take a look at their analytics and understand exactly what devices your users are actually accessing your site with that'll give you a hint at what devices you should probably have in the office to test out your experiences using if you're not able to afford those you just can't get approval for it check out webpagetest easy we have a number of profiles set up there that you can go and use today that already have popular devices can preconfigured we've got some median mobile devices like the moto g4 already in there and it's also really important to test on representative networks now although i've been talking about you know the notion of low end and median phones being important brian holt made this really great point yesterday which is it's really important to know your audience not every single site it needs to work great on 2g on a low end phone you may well have a wide range of users on sort of the higher end of the spectrum or in a different part of the spectrum so just be aware of the data behind your site so that you can make a reasonable call on how much all of this matters so if you want to be fast at javascript download times are going to be pretty critical for lowend networks the things you can do there are just ship less code minify your source take advantage of compression so gzip broadly zotfly take advantage of caching for repeat visits parse times are pretty critical for phones that have a slower cpu now on the server if you're sort of a back end developer or full stack developer you know that you kind of get what you pay for with respect to cpu disk network as we build sites that are increasingly more reliant on javascript we sometimes pay for what we send down in ways that we don't always easily see so the shape of success there is what can we do to send the least amount of script to our users while still giving them a useful experience now one of the useful things that you can do to accomplish that today one of the greatest tools in your tool belt is code splitting so code splitting is this idea that instead of shipping down your users a massive javascript monolithic bundle sort of like a massive full pizza what if we were to just send them one slices at a time so the smallest amount of script that they need just to get the current page useful enough for them to use now code splitting can be done at a page level at a route level at a component level and this is something that's well supported by many modern libraries and frameworks it's well supported in webpack so consider code splitting it's not this sort of you know theoretical thing either many large teams have been seeing really great wins off the back of investing in code splitting recently so both twitter and tinder as part of rewriting their mobile web experiences and trying to make sure that users are able to interact with their sites as soon as possible so anywhere up to a 50 improvement in their time to interactive just by adopting aggressive code splitting inside their experiences another thing that many of these sites have done is adopted auditing as part of their workflow thankfully the javascript eco his system has got a number of great tools here so things like webpack bundle analyzer which allows you to scan using the source maps of your scripts all of your dependencies that you're including in your bundle and it helps you identify sort of those places where you have libraries that are perhaps larger than you thought they might be you might have npm installed yourself into some performance problems just because you know you needed to ship something and include a date library or a ui library that was a little larger than you thought it might be also great for spotting places where you're including duplicate code so just take advantage of you know some of these tools for auditing if you're really unsure whether you have any issues with javascript performance in general check out lighthouse so lighthouse is one of those tools by the chrome team that we've baked in chrome developer tools it's also available as a chrome extension and the idea here is that it gives you this really indepth performance analysis engine that will highlight places where you can be doing better one of the things we recently shipped in lighthouse is a feature called javascript's boot up time this allows you to highlight places where scripts might be spending quite a long time in parsing and compiling and executing so you can try to look at opportunities to either you know split up those scripts or just be doing a little bit less work there another thing you can do is try to make sure that you're not shipping unused code down to your users something that's also baked into chrome developer tools is code coverage code coverage is really useful because it allows you to just load up your site inside of chrome and then you can start interacting with your pages and it'll highlight all of the code that's actually been used or unused on a per script level and as you start interacting it'll actually update in real time those different bars to show you know in red versus green how much is unused versus used this can be really great for identifying opportunities to split up your scripts or in some cases maybe you know not even load them up on initial load maybe they could be deferred to a later point in time so taking a look at production examples where some of these ideas have been useful um i was talking to the netflix team last week and they mentioned that there was this point where when you landed on netflix.com they had a nonmember landing page flow that they wanted to optimize uh they were initially using react on both the server side and the client side but they wanted to make sure that their time to interactive was as good as possible and so what they ended up doing was actually dropping react just for the client side portion they're still using it on the server side but they prefetched it for subsequent navigations deeper into the user experience this improved their time to interactive by 50 which is huge it meant that users could sign up a little bit quicker and it was worth the time investment here another thing that netflix mentioned was that there was a point where they were trying to move their video playback component so the component that you see whenever you're trying to play anything on netflix from vanilla javascript over to react so this was the identical ui you know for both versions of this thing and they experienced some negative results initially they found that the extra javascript costs for downloading parsing evaluating and the runtime costs for using virtual dom diffing were quite high and they ended up causing a few negative results so reductions in play hours reductions in usage and so they ended up needing to spend a little while actually reducing these costs to enable them to finally roll out react for the video player too i wanted to highlight what this actually looked like so here we have an example using vanilla javascript where there was no interference on the main thread so you're interactive pretty quickly and then we have a busy main thread example where all of that javascript processing meant that it took a few seconds before the user could actually start interacting with the video player as i mentioned they're thankfully in a much better place now and they've been able to ship out this experience to users but keeping an eye on their time to interactive and their javascript costs was critical to them enabling future experimentation that used react now if you're looking for a pattern for serving javascript efficiently to your users i heavily recommend checking out purple or prpl so purple is a pattern that stands for push render precache and lazy load and it's a pattern for aggressively code splitting where you just ship down the code a user needs for every single route and then you take advantage of service worker for precaching the javascript and logic needed for future routes and lazy load it as needed what this means is that when a user ends up navigating to other views and the experience there's a good chance it's already in the cache and so they experience much much reduced costs in terms of booting this up and getting interactive so we've talked about a few ideas uh you know if if you care about performance if you've ever you know worked on a web perf patch for your site you know that sometimes you could end up working on a fix coming back a few weeks later and someone on your team may have been working on a feature or unintentionally you know broken the experience you know you could be in a position where you just fixed the site and someone comes along you're like why why why did you ruin it why um thankfully there are ways that we can we can try to work around this uh and one way is having a performance budget in place so performance budgets are great because they keep everybody on the same page it creates a culture of shared enthusiasm for constantly improving the user experience and it holds the team accountable performance budgets can be employed at sort of a file size level so you could have you know budgets based on javascript chunks you could have budgets around speed metrics so timed interactive or other metrics like first contentful paint this is a feature this is an idea that is well supported in tools like speed curve or caliber and so if you're interested in trying to get performance budgets set up there are a number of tools you can try out just to roll this out for your team i heavily recommend it uh if you're interested in trying to track the cost of javascript in production for your real users there are two things i'd recommend checking out the first is the long tasks api so this is an api that we recently shipped in chrome allows you to gather real world telemetry on parse and compile as well as culprits basically long tasks are any task that lasts longer than 50 milliseconds that could be problematic on the main thread and you can record that and log it back to your google analytics another thing to check out is first input delay now this is a metric that measures the time from a user first trying to interact with the experience and the browser actually responding with something so this is still an early metric we actually have a polyfill available for it today that you can go and check out but between these two you should hopefully be able to get enough telemetry from real users to understand what javascript performance problems they're running into so improving performance is a journey it's generally not something you're just going to do you know all in one go and be done with it's usually a journey where a lot of small changes can actually lead to pretty big gains i don't you know i don't expect most people especially if they have javascript performance problems to go out and fix everything tonight um you know the i i try to compare this to the experience that you might have if someone asked you to learn how to sketch out something like a baby for example if someone told you to go and learn how to draw a baby you'd probably look up the tutorial and maybe the first step would be drawing you know the outline the second step is probably drawing the rest of the baby but that's not the expectation i have of everybody here what you probably will do is you know make a few incremental improvements to your experience maybe you'll chip away a little bit at the javascript and you may end up here which is actually you know not a bad place to be it's a little bit better on the first one but over time if you're able to continue investing in improving the javascript performance of your sites making sure that you're able to get interactive really quickly your users will thank you because they're actually going to be able to do things much much more quickly so i hope some of that was useful that's it for me thank you you