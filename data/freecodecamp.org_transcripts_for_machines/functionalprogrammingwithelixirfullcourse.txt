welcome to this complete Elixir course this course created by octolium covers the fundamentals of Elixir and functional programming including recursion pattern matching and the actor model the course also covers data types flow control and advanced topics such as mixed projects and list operations by the end of this course you'll be able to build your own Elixir applications and confidently apply functional programming Concepts in your projects hi and welcome to this course functional programming with Elixir now this course is all about learning the fundamentals of functional programming and we are going to learn these Fundamentals by using the Elixir programming language now this course is for someone who has some basic knowledge of programming but you don't need to be an expert maybe you know a little bit of JavaScript python Java or C plus plus it doesn't matter but you do need to have some kind of programming experience now let us go through all of the topics that we would be covering inside this tutorial Series so the first thing as you can see that we are going to learn all of the basic fundamentals of functional programming and after that we are also going to learn all of the basics of Elixir you can see that we are going to cover all of the type system of Elixir as well then we will see how to create projects by using mix so this is the basic tutorial project that we are going to create and as a last Capstone project we are going to create an actual statistics Library well that's it for this video I hope you are excited to learn more about functional programming and elixir in general and I'll catch you in the next video so what exactly is elixir now Alexa is a functional programming language now why am I talking about elixir well let me answer this by asking you a question when was the last time you used WhatsApp or Discord well both of these applications there are on the same virtual machine now to be precise Discord is powered by Elixir and WhatsApp is powered by erlang you must be thinking what erlang has to do with Elixir well erlang is also a functional programming language and Alexa is built on the top of erlang and both of these languages they are compiled and they run on the airline virtual machine which is also called as the beam you can imagine this to be similar to your Java virtual machine you have so many languages such as Java kotlin closure and Scala all of these languages they compile and they run on the on the Java virtual machine the same thing happens with Elixir Elixir gets compiled and Resident on the beam virtual machine now you must be thinking why is all of these things important what's so great about about elixir well first it is functional second it supports immutability by default now why is immutability so very important well because of that we can have immense scalability You Must Be Wondering Why because since all of the data types is immutable that means there is no chances for the threads or some other objects or maybe some other functions to accurately change the values so the state is preserved and that's why the systems becomes much more scalable and the most powerful thing about Elixir is that it supports fault tolerance suppose NFL node goes down or any of our actors or processors goes down then automatically they can be revived and they can be revived with its own state so that's why you can create immensely distributed and fault all done systems by using elixir so if you're interested in learning Elixir then stay tuned and I will meet you in the next video bye so now we know a little bit more about Elixir but let us try and understand what do we mean by functional programming in simple terms it simply means that our entire program is composed of different functions so just imagine that this f of x is a kind of a function so let me highlight the background so this the green thing so this is a very simple function now this function it gets an input suppose that input is an X now this function is going to transform that data from X and that data would be transformed to something called as y so this is what your function is going to do your function will always accept some kind of an argument it will transform the data and it will always give you back some kind of data now this may look very simple but it's not so simple there are a lot of things that go behind creating your pure functions so let us try and understand what makes functional programming so unique the first thing is obviously we don't have any classes or objects inside functional programming the next one is all of the data type is immutable so it's just like working with constants throughout your program now you must be wondering why do we need immutable data types or constants the answer is since the data is not mutable that means the state Remains the Same and if the state Remains the Same that means that data can be copied and it can be distributed much more easily and since this data can be distributed that means we can create immensely scalable systems by using function programming now this brings me to the next point and I think that this point is going to shock a couple of us and that means we don't have any for loops now since the data is immutable that's why we don't have for loops just try and imagine your typical for Loop suppose you have your variable of I equal to 0 I Which is less than length and I plus plus now what's happening is for each iteration your variable of I is increasing that means the data is constantly mutating but we can't have that because we have immutable data types you must be thinking then what's the point how can we have iterations in Elixir but functional programming and elixir has a much better way of doing loops and that is by using recursion and I am going to talk more about recursion right in the next video so what do you mean by recursion and why is recursion so important let us try to answer these questions one by one first let us see what do you mean by recursion in simple terms whenever you perform the same task again and again you can say that you are performing a recursion that means you can see that we have one task and this task is calling itself again and again so you can say that we are in a state of recursion now if recursion is so simple then what's the big deal with recursion let me try and explain this by taking you through a journey in time you must have heard about the seven wonders of the world you have the Taj Mahal you have the Great Wall of China you have the Machu Picchu and so on but if we ask each one of us what do you consider as the wonder of the world the answer is going to vary let us see what's going to happen next so these are some of the most smartest guys on the planet so they are Warren Buffett and the great Charlie manga if you ask these guys what do you think is one of the wonders of the world then most possibly the answer would be compounding now let us see what's going to happen next so there is one more really smart guy and as you can imagine this is the great Isaac Newton if you ask Newton what would be one of the greatest wonders of the world most probably he is going to say that it's gravity so the point that I am trying to make is our perception changes from person to person now what happens if you ask this guy that's me photo I think about one of the greatest wonders of the world and as you can guess my answer would be recursion well that's not exactly true if you want a very honest answer from me then I think that recursion plus mutation that means recursive mutation is one of the greatest wonders of this world sounds confusing is it don't worry now it's time for some explanation just consider us human beings all of us have habits right and we tend to have the same habits over a long period of time so can we say that our mind is in a state of recursion because we keep on repeating the same habit each and every day you may argue that our habits can also change well yes they can change and that's what I mean by mutation but just try and consider your habits don't change drastically overnight your habits may change over a long period of time so you can also say that your change in habit is because of small mutations that take place each and every day so maybe you can say that all of us are in a state of recursive mutation let's try and go a little larger let us try and think about the Earth itself now the Earth takes around 24 hours to come to the exact same point so can you say that Earth is also in a state of recursion let us try and expand a little bit further now the Earth revolves around the Sun in an orbit now this as you know it takes around 12 months time but what happens in every four years we have a leap year that means we have a day extra so can you say that even the Earth is in the state of recursive mutation now let us try and go even behind our solar system you must have also heard that the entire universe is in the state of expansion this go back 13.6 billion years ago when there was nothing the Big Bang happened and the Earth Stars sun and entire galaxies came into existence and we are still expanding how can this happen well I can explain this by using a function which is written recursively so this is our function for now you don't have to understand all of these things you will understand these things in the future when you learn a little bit more about Elixir right now let us try and see how the universe can expand from nothing so if I say universe and now this is the time for the Big Bang and big bank is a function which takes no argument now let us see what's going to happen Okay so the Big Bang happened after that you can see that the size of universe is 0 1 2 3 4 and the size is constantly expanding now let me stop this otherwise this will go for Infinity so what exactly happened you can see that I have a function called as expand and at the last the function is calling itself again but this time we are just mutating the state I have written State plus 1 but imagine that this is not plus one we are causing some kind of mutation and that is what this is supposed to symbolize now this brings me to the last point so as you can imagine the very nature of the universe is recursive that means all of the mathematics that we study for programming that 2 is recursive in nature and this concept of recursion comes naturally to functional programming so now we get it we had to take a really long journey in order to understand what is the recursion and what's the big deal with it now let's see how to install elixir so what you can do is you can just go to this website which is elixirlang.org and you can simply click on install and if you're using Windows you can click on windows so from here you can download the installer and as the instruction already says you have to Simply click on next next and finally finish and if you are on a Mac you can simply use Brew to install elixir so if you are on a Mac you can open up a terminal and you can type Brew install an elixir and once you have installed Elixir what I want you to do is uh just open up a terminal or if you are using Windows just open up the Powershell and here you can simply type Elixir and hyphen V so as you can see I'm currently running Elixir 1.14.1 and if you are watching this video in the future you may have some other version but don't worry all of the things which I teach you right now they are going to work in future versions as well the next thing for this video is let us open up our Visual Studio code and let us set up the Elixir plugin for this one so just open up your extensions and I want you to just search for elixir so this extension which is for Elixir LS so here you can see and currently it has like 339 000 downloads so just install this plugin and this is what you really need to start working with Elixir inside vs code the first time you open up any Elixir file inside vs code you will get a small popup right over here somewhere in the bottom right corner and that popup will be saying that Alexa is building the PLT so just let it happen it's going to take some time but let it run and after the Alexa PLT is built you can start working with your Elixir files inside vs code now that we have Alexa installed it's time to start learning more about elixir but first before learning we need to start unlearning because a lot of Concepts from the object oriented world does not exist in the functional world so that brings me to the very first statement if I say a is equal to 1 and if I ask you what do you think of it most probably you will say that a is a variable and the value of 1 is being assigned to the variable of a well you are right but that's not what is happening inside the functional world if I take you back to your high school days and just imagine that you are taking your very basic algebra classes in that class what we learned was a is equal to 1 that means a is your left hand side and one is your right hand side so what maths is trying to say is your left hand side is equal to your right hand side your basic algebra does not say that one is being assigned to a that concept does not exist now if we say that if the left hand side is equal to the right hand side that means the right hand side should also be equal to the left hand side so if I say that a is equal to 1 that means even this statement should hold true and that is what happens in the world of Elixir as well we will also have a demo of this shortly right now just keep in mind that equal to is not the assignment operator this is the match operator and what this operator does is that it simply matches your right hand side to your left hand side and you are going to see this pattern a lot inside Elixir this is also called as pattern matching and this is a very powerful thing inside elixir every time you see a statement like this always remember that we are simply trying to match the right hand side with the left hand side now for the demo let us open up our terminal Elixir actually ships with an interactive shell or an repel so let us see how we can open it up and start using elixir we can enter inside the intra to Shell by typing IEX you can clear the terminal by typing clear so here we can say that my a is equal to 1. now if we say that is my 1 is equal to my a and we get the output as true you can also type as 1 is equal to a and this simply gives back the value because 1 and a both hold the same value of 1. let me clear this up let us try with one more experiment suppose I say that my name is octallium so in this case if I say that is octallium equal to my name then we should get the answer of true and yes that's what it is so just keep in mind that this is equal to is not assignment we are simply trying to pattern match the right hand side to the left hand side let's try to learn a little bit more about pattern matching and let us have a look at this example now the square brackets means that this is a list and I will be covering more about list a little later in the series but for now let us just go with the flow for now I don't want you to concentrate on the syntax I want you to concentrate just on the right hand side and the left hand side can you see that the pattern on the right is the same as the pattern on the left we have two variables on the left hand side we have two values on the right hand side here you can say that the value of 1 is now bound to the variable of a now the next variable is also a and the value inside a is also 1 and that's what it is so this is going to be true inside elixir for a quick demo let me open up my terminal and I'm already inside IEX in case if you are for Photon how to go inside IEX let me show you once again for quitting IEX just press Ctrl C twice and you can put the IEX and again if you want to go inside just type as i e and X again let me clear it up so here I can say that my list has two variables a and a and the values are 1 and 1. so here it is it's a perfect match the right hand side is equal to the left hand side so we get the values back if I just say I want to see the value of a and here it is we get the value of a as 1. now let us go back now can you guess what is going to happen this time now this time you can see that we have the values of a and a and on the right we have the value of 1 and 2. well let us go to our IEX and see what's going to happen this time so we have this A and A and on the right we have 1 and 2. let us see what's going to happen o we get an error and if you watch closely we get an error saying that no match of the right hand side and yes it is not a match the reason is the value of 1 is bound to the variable of a and again the second value is a but this time the value inside a is 1 and on the right the value is 2 so 2 is not equal to 1 and that's why the right hand side and the left hand side are not a match and that's why we get an error let us go back now what happens if we write something like this if we switch the second value from a to a new variable of B can you guess what is going to happen well let us go back and let us see what's going to happen this time so here let me change the value from A to B and let us see well yes it's a perfect match so what's happening this time the value of 1 is bound to the variable of a and the value of 2 is bound to the variable of B we can check it out so if I say a then we get the value of 1 and if I say B we get the value of 2 and that is what it is right over here always try and think in terms of pattern matching that means we always want to have the right hand side equal to our left hand side so this is also called as pattern matching and as I have said earlier this is a very powerful pattern inside Elixir and we would be using this pattern matching throughout this entire tutorial series till now we have seen a little bit about pattern matching inside elixir and we have been using our terminal but we can do a much better job and allow me to introduce to you livebook so livebook is actually like the Jupiter notebooks for Elixir but before I can show you live book you must have noticed that I have a different prompt and I have a couple of more colors inside my terminal and this is because I'm using a little bit more fancier setup but that's about it now let me go to livebook so here it is you can simply navigate to this website livebook.dev and from here we can simply install livebook on our machine so just click on install and from here you can choose your Mac or Windows and download the setup and after you have downloaded the setup just install it as you would install any other program in your machine now I have already installed live book so let me just open it up here it is so this is how it is we can start a new notebook we can simply click over here new notebook and that's it we are good to go let us try the same code that we wrote inside our terminal so here I can see is my a comma a equal to my 1 comma 1 and simply you can click over here evaluate and now we have the output right over here let us try with some other examples so here I can say if my a is equal to 1 then is my 1 equal to a and let us try to evaluate in this cell and yes we get the output now what I have done just for a reference I have also included a couple of notebooks and you can find all of those right over here so this is the GitHub repo for this entire tutorial series which is octallium slash oops uh it's right over here you can go to octallium and slash functional programming with Elixir and inside notebooks you can see that I have a couple of notebooks now in the future I may add a couple of more notebooks to this one but at the time of recording we have three of those so let us see how we can open this notebooks inside our live book so let me go back to my live book and let me just click on this icon on the left and here I simply have to choose my path so I have to go inside my GitHub octalium functional programming with Elixir notebooks and let me choose the first one and let me simply click on open so this is the first live book that you can find inside the repository and as you can see I have included a couple of text and also a couple of code blocks for your reference so this is what we were trying to do last time and if you see right over here I have created some more examples so if my name is is equal to octallium then my octalium should also be equal to name and so on so what you can do maybe you can try to create a couple of more notebooks and you can try to open up the notebooks which I have included inside the repo and I'll catch you in the next video till now we have been trying to learn more about pattern matching and let us continue with the same thing in this video as well now let us go back to our terminal and let me coincide IEX so I can do that by simply typing IEX now again please let me remind you that my prompt is looking different and that is because I have customized the settings I just wanted to have the prompt to be same as my logo that's why I simply changed it but that's about it now let me clear up the terminal and here let us try to learn a little bit more about pattern matching so again let us create the same list a and a and for the right hand side let us say that we want to match with 1 and 2 and as you know we are going to get a match error and this is what we are getting so again let me try and refresh a memory what's happening so what's happening is the value or the variable of a is bound to the value of 1. and on the next time what's happening is here we have a but we are trying to match the value of 2 with a and as you know a is bound to 1 that's why we are getting match error now let's take a couple of minutes and let us try to understand why this is happening this is happening because all of the data types inside Elixir are immutable that means we can't randomly assign new values to an existing variable inside Elixir now you must be thinking that why does all of the types inside Elixir has to be immutable the short answer is because for scalability and we will come to this point in the next video but for now let us try to understand what's happening behind the scenes now let me try to clear up the screen one more time and this time let us say that we want our a and we want on the right to be 1. so this time what's happening is we have a match operator right over here and the value of 1 is bound to the variable of a but here comes a small caveat so if I say a is equal to 2 so this time we do not have an error but I just said that our data types are immutable inside Elixir so what's happening so whenever we have a variable on the left hand side of our match operator at that time Alexa thinks that we want to bound the new value to the variable on the left that's why we have the new value instead of a which is true but if you don't want this Behavior then we can use a pin operator so we can say the pin operator and a is equal to 3 so this time as you can see we get a match error and the match error is saying that no match of right hand side value of 3 and this is because instead of a we have the value of 2 and on the left hand side we are trying to match a value of 3 that's why we get the match error now if we try to do this thing the other way around and if we say that 3 is equal to a so again this time we get an error saying that no match and the right hand side value is 2 so yes as you can see right over here the value which is bound to a is 2 and that's why 3 is not equal to 2 and we get a match error and on line number 4 we could rebound the new value of 2 to our variable of a just because this variable is on the left hand side of the match operator for now you don't have to worry too much about these things as we progress and as we saw a couple of more examples all of these things will get cleared very easily now coming to the next Point why do we need immutability inside Elixir and my short answer was scalability so let me try to explain why immutability helps in scalability since our data is not immutable that means the data can be easily copied across various processes and we don't have to worry if another resource another thread or another process is changing or trying to mutate our data this thing will get clear when we understand how code is executed inside Elixir and when we understand the actor model and that's what we are going to do right in the next video let us try to understand how all of the code inside Elixir gets executed now all of the code gets executed in something which is called as an actor so you can imagine your actor to be something like this box now this is an isolated box and what happens is this box or this actor receives some kind of messages now this messages could be data it could be instructions of what to do with the data and so on after receiving these messages your actor is going to process your messages and it is simply going to give you back some kind of a response so in simple terms you can imagine actor to be like an isolated competition unit it gets something it processes something and it gives back something now what happens is this act as they run inside something which is called as processes and at a given time we can have millions and millions of processes this is where the data immutability comes into picture we can have millions of copies of our data and they can be distributed across various actors not only on our local machine but we can have a global cluster of different servers and we can distribute our load horizontally across the globe so these processes are not your operating system processes you can imagine them to be like your virtual threads so let's try to understand these processes one step at a time we just saw the actor model and this actors they run inside your processes for each process we have a separate ID which is called as bid and I will show you the bid shortly in this video the next part is we can communicate between these processes by message passing and as we just said that since our data is immutable we can create multiple copies and this copies can be assigned to different processors and since each actor gets its own copy of data we don't have to worry if another is changing the state everything runs in isolation the next part is each process has its own stack and Heap allocation so if we come from a compiled programming language such as C or C plus plus we have different memory allocation models you can allocate your memory inside the stack or on the Heap and in case of Elixir each process gets its own stack and hip allocation so this way the garbage collection is very fast we have to just garbage collect for a single process and our application remains responsive at the same time next let us have a little bit more details about our actors every actor has its own mailbox so every message that you pass to an independent process they are collected inside this mailbox and after that they are executed in a sequential order and the Order of execution is first in and first out next this processes are very cheap to create they require less than 3 KB of memory so you can see it's very cheap and we can spawn millions of processors at a given time and the last part to remember is we always communicate with message passing now let us go back to our terminal and let us check our bid over there so pit stands for your process ID so the first thing is let us go inside our IEX let me clear up everything now this IEX is also running inside a separate process and we can check the process ID by using the builtin function called as self now the next thing about Elixir is the parentheses are not mandatory self is a function you can write the parentheses or you can leave them out but these days the general convention is whenever you are writing code inside the code editor at that time we prefer parentheses but on the terminal it's all up to you I am going to leave them out and here we get the output so the current process ID in which our IEX is running is right over here and this is the address 0.107.0 so that's it for this one and I will catch you in the next video I think now we know enough of Elixir and now it's time to write the all important hello world program so let us get started let me open up my terminal and here let me create a folder by the name of functional programming with Elixir now let me go inside of this folder and here let me create one more directory for Scripts let me go inside my scripts directory and here let me create one more file by the name of Hello dot EXs now Elixir has two file extensions this dot s that you can see right over here this means that we want to create a script file and whenever we want to create a compile file that time we simply write as dot EX we will see more about the dot ex extension when we create our first project by using the mix tool but right now just keep in mind that whenever we want to create a script at that time we simply add a s now there are a lot of times when you need extra files for example you need a file to just seed your database or if you want a file just for testing these files are not meant to go into production they are just meant for your development now let me go ahead and create this file and let us open up this file inside our code editor now my code editor is complaining that no mix file found so right now just ignore this and when we create a project by using mix it will go away let me collapse my sidebar so the first thing that you should keep in mind that all of the code inside Elixir stays inside its modules so let's create a module and for creating module we simply have to say that we want to define a module and let us name the model as hello and next for Elixir we don't have curly brackets instead we have the do and end blocks so what we have done till now is we have simply defined a module and all of the code will go inside this module as a general convention the module name and the file name should be same it's not required but just as in community convention they should be equal for example let me open up my sidebar here you can see that we have named the file as hello and we have also named the module as hello let me collapse my sidebar and inside of this module let us create our first function and you can create functions by using the keyword cordless Dev and let us call our function as world now this function will not accept anything so you can't keep your blank parentheses or you can leave them out completely that means this is a function which does not accept any parameter then again we need to create our do and end blocks and here we can say that from our input output we simply want to put something to our output and here we simply want to display the message of hello Elixir now always use the double quotes for defining your strings single codes are meant for characters but right now since we want a string that's why we have put double quotes now let us save this program and let us see how we can run this program let me adjust the screen we can run this file in a couple of different ways so let us see the first method here we can simply say that hey Elixir I simply want you to run the file which is called as hello.exs and you can see that Elixir actually ran our file but we don't have any output and we don't have an output because we have not called the function of word so let us do that right over here let me take my terminal slightly down and here what we can do is here we can say that from our model of hello I want to call the function of world let us save the file and now let us go to our terminal and let us try to run the same command one more time and this time we get the output of hello elixir so you can use this method whenever we want to run a script file but Elixir is actually a compiled language so let us see how we can actually compile this file now again please keep this in mind that whenever we want to have a compiled file that time the file extension should be dot ex but right now let me show you how we can compile and run this script so let me clear up my terminal and here instead of writing Elixir we can say that Elixir compiler by adding a c right over here so this stands for Elixir compiler so now Elixir is actually going to compile this file and then it will run for us so let me open up the sidebar here you can see that we have a single file hello.exs and this one is created by our virtual Studio code now let us compile the file and let us see what happens so as you can see in the sidebar Elixir actually compiled and we have a new file called as elixir.hello.beam now remember that Elixir runs on the beam virtual machine and this is the compiled file for our Elixir code but normally we don't compile and run the Elixir files like this we would use the mix tool and we will learn more about the mix tool as we progress in the tutorials but right now let us go with the flow now let me collapse my sidebar we can also run this file inside our interactive shell so let me show you how we can do that let us go inside our interact with shell and let me clear up everything now here we can say that we want to compile the file of hello.exs and that's it now we are getting a warning saying that redefining module hello and that's because just a couple of seconds back we actually compiled this file and that file is currently inside our memory but right now we can simply ignore all of these things next your IEX actually ran the file and here we can see we have the output of hello Elixir now let me clear up the screen one more time and let us see how we can also manually call the function so here we can say that I want you to go to the model of hello and from there I want you to go to the function of word now remember that parentheses are optional inside Elixir and since our function of world does not accept any parameters I can have my blank parentheses or I can simply leave them out and here you can see that we have an output of hello Elixir and after this we also have a message saying as okay now okay symbolizes a data type which is called as atom we will learn more about the data types in the next video but right now let us go with the flow now again let me close my terminal and this time let us make the function accept some kind of a parameter so here we can say that we want the function of world to accept a parameter and we want to name the parameter as name next we can use our string interpolation so here let me take out Elixir and here we need to put the hash sign and then we need to put the curly brackets and inside the curly brackets I can simply use our parameter of name and also let me take out this line This is not required so let us open up our terminal and we have our IEX running now since we changed the file let us recompile the module and we can do that by typing R now R stands for recompile and we simply want to recompile our model of hello and that's it we have redefined the module let me clear it up and here we can say that hello Dot world and now let us pass a parameter called as octallium and we have the output of hello octalium now remember that the parentheses are optional so we can also write something like this let me take out the parentheses and let me give a space right between over here so as we can see this code is also valid and we get the exact same output well that's it for this video and we will see the different data types in Elixir right from the next one let us try to learn more about the different data types in elixir the first thing which I wanted to remind you is all of the data types in Elixir are immutable in common terms what I mean to say is all of the data types inside Elixir are constants now with this concept in mind let us go ahead and let us try to study the first data type and the data type is called as an atom an atom in Elixir looks something like this so we have a colon symbol right over here and after the colon we have the name of the atom and in case there is some space inside the name of the atom then we can write an atom like this so again the syntax goes like this your item will always start with a colon and then we have the name of the item and in this case since we have a space inside the name of our item we are using double quotes and inside the double quotes we have the name of the atom now this was just the syntax of an atom but now let us go ahead and let us try to understand what's an item all about so let's consider this scenario so we have a symbol or a logo like this can you tell me what this logo symbolizes now this logo is of a very popular brand Android brand is Nike so what's happening in this case this symbol is synonymous with the name of Nike if I show you the symbol or if I show you the name both of this values point to the exact same thing so this is just a pseudo code and this is not a valid Elixir syntax but let us understand the concept of an atom so what's happening right over here is we have a variable and the name of the variable is Nike and the value assigned to this variable is also Nike so in short the value and the name are the same and this is what an item represents in an atom the name and the value is always same and we can represent this in terms of atom like this so we have an atom for Nike let us open up our IEX and we can start playing right over there so this is my terminal let me go inside my IEX and let me clear up the screen so let us create the same item for Nike so you can say Nike this is what an atom is all about suppose we had a very long name that had spaces in between so we can say something like this the and Nike so this is also a valid atom and you will notice that our atom always starts with a colon now what we can do is let us go to our live book and then we can create a couple of more examples of atom so this is our live book and let us create a new notebook let me give the title as data types and this section is all about our atom in Elixir you will see atoms everywhere atoms are very heavily used for pattern matching now suppose you are working on some kind of an application and you want to return an error message so that time what we can do is we can simply create an atom called as error so we can say something like this error and let us click on evaluate so here it is we have created an item which is called as error next let me show you a very practical use of this kind of an atom so let's take the exact same example suppose we are working on an application and we have an error where we are not able to find a file so at that time it's very common to return back a tuple and the Tuple is represented by this early strings now I will cover tuples a little later in the series but right now let's go with the flow and inside the Tuple we can say that the first element is an error so there is some error in that operation and then we can describe the reason for the error so we can say for example file not found and this kind of pattern is very common inside Elixir normally we will have a two element Tuple or a three element apple and regularly you will see that we simply pattern match on this Tuple so what we can do is on the left hand side we can again pattern match with this Tuple so let me create a new Tuple right over here and the first element is an error the second element we can call it as a reason now again what's happening over here is we are simply using our pattern matching I want you to go back to the concept of your left hand side is equal to your right hand side so on the right hand side we have a tuple and on the left hand side we have a tuple next what is happening is on the right we have a string called as file not found and on the left we have a variable oh let let me get the spelling right this has to be reason so what's happening is since we have a variable on the left hand side this value of file not found is being bound to our variable of reason so let us click on reevaluate and let us see what's happening and we get our Tuple back error file not found let us split this into different code blocks so let me create a code block right over here and let me take this code or from here and let me paste it right over here again let me click on the evaluate and here also we can evaluate now what we can do is since we are using pattern matching we can extract the value of file not found and I just said that this value of file not found is bound to our variable of reason and we can check out the value by simply typing our reason and let us click on reevaluate and here we get the value back file not found now this pattern is very very common in elixir so let us have a look at one more example and suppose this time we have a successful operation uh for example if we are working on some kind of an web application and we get back a status 200 message so at that time what we can do is we can pattern match on OK and then we can have a message and here we can pass our OK and we can say status 200 okay and then we can see the contents of our message now let us click on evaluate and as you can see we get the value of message back so again the same thing is happening over here we simply have to Pat and match the right hand side along with the left hand side OK is matching with the OK right over here and this string is being bound to our variable of message and that's what we are calling on the next line right over here well this was all about atoms and in the next video we'll start with strings inside elixir the next data type in our series is going to be the string and strings in Elixir are represented by double quotes So this is going to be a valid string for Elixir we have the double quotes and inside the double quotes we have the string now instead of the double quotes if you use a single code then that would mean a character list and a character list is different from a string inside Elixir now let us go and play a little bit with strings inside our IEX now let us go inside our IEX and let me clear up the screen and as I just said we can create a string by using our double quotes so let me write octalium so this is going to be a valid string inside Elixir now what happens the IEX also provides us with a lot of convenience functions for checking different data types and one such function for displaying the information is called as I so let us call I and let us pass the variable of octallium and let us see what kind of output we are getting so we can see that the term is octallium and the data type is a binary string so what happens inside Elixir is your strings are actually saved as a collection of bytes that's why it is saying that the data type is a binary string next the size of our string is 9 bytes and the next thing that you can see is in Elixir a string is actually a UTF 8 encoded binary now I just said that your strings are saved as a collection of bytes and this is how it actually looks inside your memory and as you must have noticed it starts with double angle brackets and it also ends with the double angle brackets now inside of this collection you can see that we have the individual integer representation of each of the characters inside our string for example the integer of 79 denotes uh o 99 denotes a c and so on next we can also see a couple of protocols that are implemented for the type of a string now Protocols are a slightly Advanced topic and will not be covering protocols in this tutorial but for now let us go ahead and let us see what else we can do with the strings now let us have a look at a little bit of magic of pattern matching with our strings now strings is just a collection of our bytes and what we can do is we can use our pattern matching to extract individual code points from our string so let me clear up the screen and here what we can do is we can simply match for an O for octallium so we can say that our first character should be o and the next one we can collect in a different variable called as rest is equal to octallium and let us see what happens next now let us see the contents of the variable of rest and here we can see that the rest variable contains all of the alphabets after o so what's happening on this line right over here so again the same thing goes your left hand side should be equal to your right hand side on the right hand side we have a capital O and that is being pattern match right over here and next we have a string concatenation operator and we are saying that we want to collect all of the different code points after o inside a variable called as rest so what happens all of the other characters starting from C all the way to M these characters get bound to our variable of rest and that's what we are checking on line number six let us have a look at one more example suppose we again want to see the information for a new string called as ABC now again the parentheses are optional so even if I take out this parenthesis still the code should work and here we get the output and here we can see that the raw representation of a band C is right over here now what's happening is 97 simply denotes the code point for our character of a and we can check that out by using a different syntax so we can put a question mark followed by a so this gives us the code Point representation for a and here we can see that it's 97 and that's what we have right over here now suppose we want to see the code 0.4 B so B is going to be 98 and for C is going to be 99 and so on now with all of these points in our mind let us go back to our live book and let's start playing a little bit more with our strings so here let us create a new section so I want to go on block and create a new section and this section is all about your strings so let us create the same string right over here so we can say we want to create a variable called as name and let us assign the value of octalum to this one next let us just print out the value of name and let us see what output we are getting and as expected we are getting our string back next we can also check if the given data is of the type of string or not so for that we can use an inbuilt function called as is binary so remember your strings are represented as a collection of your raw code points or a collection of your bytes so we can use this function of s binary and let us pass the variable of name and let us try to evaluate and we get the answer as true so yes this is a binary that means this is a string next let us see how we can add two strings together so let me create a new code block and let us create a new variable called as message and here we can create a message saying that hello and for adding or for concatenating we have to use this double angle brackets and then let us pass our variable of name so again just to help you remember your we have the angle brackets and if you go back to our terminal and here we can see the raw representation here also we have the angle brackets the only difference is for the representation we use the double angle brackets and for string concatenation we use the single angle bracket so let us see the output of this one so let us try to evaluate and here we have the message of hello octarian next we can use our pattern matching and let us try to extract values from the string so let's create a new code block and here again we can pattern match so we can say that the first couple of characters should be hello and after hello I want to collect the remaining in a new variable called as name and on the right hand side we have to Simply pass the message so remember message is hello octallium so hello and this space right over here this is going to be pattern matching right over here and the name of octalum would be bound to our variable of name next we can also check out the contents of the variable of name so let us write it over here and let us try to evaluate and here we get the name back as octalium now there is one more way of pattern matching with our strings and this method is by pattern matching on the raw representations so let's see how we can do that so let us create a new code block now remember that the raw string representation is done by our double angle brackets and here let us try to pattern match so here we can say that we want to pattern match the first character or the first code point in a new variable and let us call that variable as head next what we want to do is we simply want to collect all of the remaining code points in the new variable and we can call that variable as rest now since we are using the raw string representation we also need to tell to elixir in which format do we want to collect all of the rest code points so here we can say that the type of rest would be binary and on the right hand side we simply have to pattern match with name and next let us see what is inside our variable of head and let us try to evaluate this cell so what's happening right now is instead of getting a string back we actually get the code point back and if we refer back to our terminal as we can see right over here so this 97 actually denotes our code point of a so that's what is happening right over here so in this case 79 actually denotes the code point for our o and we can check it out in a new blog so let us create a new block right over here and here we can say that is my head is equal to the code point of O and let us try to evaluate and see what answer we are getting so yes the answer is true so if you are feeling a little bit confused so let us go back to our terminal let me clear all of these things and let us check the code point for our character of O and we get the integer representation as 79 and that's what we are checking right over here so the value inside head is 79 and that's what we are checking in this line and since the character value of O is also 79 that's why this expression is evaluating to a true so you can see that pattern matching is very powerful inside Elixir and we use pattern matching practically everywhere inside elixir let us take the same example so let me copy from here and let's create a new code block and let me paste it right over here and here instead of using this variable of head let us pattern match on o and let us see if we can get the rest back and let us try to evaluate this expression and we get the right answer back so we get all of the characters from C to M now it's not mandatory to just pattern match on a single character we can button match on multiple characters so let me copy this one let us create a new code block and let me paste it over here and this time we can use two characters so let us pattern match on O and C and next let us check the contents of rest and let us try to evaluate this cell and as you can see we get the right output so you can see that pattern matching is really very powerful inside Elixir next you can be also very specific while pattern matching with strings you can actually specify the number of strings that you want to collect so let me show you an example right here let us create a new code block and let me copy this thing right over here now instead of saying O and C what we can do is we can say that we want to create a variable called as head and inside this variable we want to collect the first two binaries so here we can say that we want to collect the binary and the binary size should be for two characters next let us check the output of our head and let us try to evaluate this one and as you can see we get the characters of onc back well this was all about strings inside Elixir now don't worry if you don't get this pattern matching with binaries and all of these things I just wanted to show you all of the different possibilities by using pattern matching inside elixir the next data type is our Char list or our character list and as I have already explained the character list is created by using single quotes so let us create a variable called as characters and let us assign the value of octalium now as you can see I'm using single quotes right over here and we get back the value of octallium now let us do one thing let me copy this and let us go to our terminal and inside my IEX I can check for the information so I can use the inbuilt function of I and let me paste the character string right over here and let us see what kind of output we are getting so this time if you see the data type is actually a list last time when we were studying about strings the data type was a binary string but this is a collection of characters inside a list and if you want to see the raw representation so here it is now please note that as this is a list we have square brackets at the start and also at the end and as you can see each of the characters are also represented by the integer values so again the same thing goes 79 represents o then the value for C is 99 then for T it is 116 and so on so let us go back to our live book next let us see how we can add two character lists together so let me add a new blog and here let me create a new character string and let me say hello and for adding or concatenating two lists together we have to use the double plus symbol and let me pass the character's value right over here and let us try to evaluate this cell and here we get the new value back as hello octallium just as a reminder for Strings we were using the angle brackets but since this is a list that's why we are using the double plus symbol next we can also use an inbuilt function to check if the given characters are indeed a character list or not so again let me add a code block and here we can use the inbuilt function of this list and let us pass our characters inside of this one and let us try to evaluate so yes we get the answer as true and the last point is we can always check the code point so we can and use a question mark and then we can use a character so the code point value of a would be 97 and if you check for o it would be 79 and so on so this was all about characters the next type that we are going to see is called as the process so let me take everything up and here let us add a block and we want to add a section for process and let us add a code block right over here now if you refer to my earlier videos so this was a video about processes in which I explained that all of the code is executed inside processes so these processes are also a valid type inside Elixir and we can check the current process in which our live book is running so let's create a variable called as my build so the pit stands for the process ID and we can use the inbuilt function of self and let us check the output of my paid after this one and let us see what kind of output we are getting so we get the output as bid is 144. now if you go back to our terminal and here let us check the process in which our IEX is running so let me call the function of self and this time we can see that we have a different bit number the process ID for our IEX is 107 but if we go back to our live book we can see that our live book is running inside the process number 144. now processes and concurrency in Elixir is a very huge topic and it requires its own dedicated tutorials but for this course let us go ahead and let us see the next type let us add a new section right over here so I want to add a new section and this section is all about our list let me take this thing a little up so the number one thing that you need to understand about list is that the list inside Elixir are actually linked list and they are not your regular list so if you try to do operations like in texting it is not going to work and just to be precise the list inside Elixir are actually singly linked list so let us see how we can work with list inside Elixir let us create a new code block right over here and let us create a list so this is our list and for a list we can see that we have the square brackets at the beginning and at the end and let us try to evaluate this cell and we get the list back now again let me try and repeat that this list is not your regular array or not your regular list this is a singly linked list let's do one small experiment and let us try indexing on this list so let us create a new code block and suppose if I try to see the element at the zeroth index now let us see what happens and as you can see we get an error and we get this error because this list is actually a linked list and not your regular list now the reason that we have linked list inside Elixir is because linked lists are recursive in nature your regular arrays or your regular list they are not recursive and they have to be saved continuous in your memory but then how do we work with listens at Elixir now there are a lot of mechanisms first and the obvious one is by using recursive functions or we can also use a lot of inbuilt modules so let me show you one module let me add a code block right over here and let us take everything up now we can use the model of enum and we can say that enum and we can use the inbuilt function add and let's pass our list and let us call the index as 0 and let us see what kind of output we are getting and here we can see that we get the output as a so what we are doing is enum is actually an inbuilt model inside Elixir and at is a function which is defined inside the enum module and here we are simply passing the arguments for the function let us go back to our IEX and let me clear up everything let me make some space from the top and here if I write enum Dot and if I press tab here we can see that we have a lot of inbuilt functions for the enum module and the function that we use is right over here add now this Slash 2 actually means the rity now arity is nothing it's just the number of arguments that your function can accept in Elixir we can actually overload our functions by using different parameters so for example you can see right over here we have a function called as any and for this function we have two types the first type is right over here so this function takes only one argument that's why the arity is one and here we have the same function any but this time it takes two arguments so that's why the arity is shown as two now let me clear up all of these things now let me show you one more helper function inside Elixir and the name of the function is H so H stands for your helper again if you want you can use the parentheses or you can leave them out and here we need to specify which model or which function do we want help for so what does helper function does is it simply prints out the documentation for that module or for that function so here we need to specify that we want to see the documentation for the model of enum and from enum we want to see the documentation of the function of ADD and here we get the documentation back the first line that you can see right over here this is all about your function definition and you can see that the first parameter is actually a innumerable the second one is the index and this function also accepts an optional argument by the name of default and the default value for this parameter is nil these two backslashes symbolize that this argument of default is an optional argument and in case if this argument is not specified then the default value would be simply nil next we can see that we have a couple of examples right over here so you can see that the helper function is very useful and I often use this function for reading the documentation inside my terminal now let us go back to our live book and here let us play a little bit more with pattern matching and with our list so let me create a new code block now if you refer our list so our list has three different elements and we can use pattern matching to extract all of these elements so let me show you how we can do that so here let me create a couple of different variables the first one should be called as first second third you can call this parameters anything that you want and on the right I simply want to pattern match on the list so what's going to happen is the same old thing the left hand side should be equal to the right hand side so the first thing is since this is a list on the left hand side we do have a list and we are simply trying to pattern match on the different elements so this a would be bound to our variable of first for the second your B would be bound and C would be bound to third let us check out the data inside second so let me call second right over here and let me take it up and also let us try to evaluate this cell and we get the value back as B now what happens if you don't want all of the variables and you simply want to ignore a couple of them at that time we can simply use an underscore to ignore the values so suppose I don't want the values of first and second then we can do like this so we can create a list since I want to ignore the first value I can use and underscore I also want to ignore the second value so let me put one more underscore the next I want to collect the third value so let me create a variable called as third and let us assign a list right over here so our list is a b and c now let us check the value inside third and let us try to evaluate and we get the value as C back so what happened is since we have an underscore that's why the value of a is simply ignored the same thing happens with BS as well and finally the value of C gets bound to our variable of third next let me show you a couple of convenience function for working with our list so the first function is also called as head so let me show you what I mean so the head function simply takes the first value and returns it back so if we call the inbuilt function of head and let us pass our list to it and let us try to evaluate and as you can see we get the value of a back now similar to head we also have another function which is called as tail so let me create a new code block and the function is called as tnl now what a tail function is going to do is it is simply going to ignore the head value and it will return back all of the remaining values so let me pass the variable of list to this one and let us try to evaluate the cell and we get back the values of B and C there is also a shortcut method for doing this so let me show you how we can do that and this time we can simply pattern match on our list so here let us create a list and I want to pattern match the first value inside a new variable called as head H for head and then let me use a cons operator and then I can say that I want to collect all of the remaining values in a new variable called as tail and let me assign the value of list to this one next let us check the value inside our head and let us try to evaluate this cell and as expected we get a back now this pipe operator is also known as cons operator for working with our linked list next let us also check the value inside e so let me create a new code block and let me call the variable of key and as you can see we simply get back the remaining values inside our list the next data type is the Tuple and we have already seen a couple of examples of Tuple but let me show you once again so the Tuple is created by using the curly brackets so you can say we want to create a two element Tuple and we can say that the values should be 1 and 2. so this curly brackets are used for creating an apple not tuples are very similar to your arrays and all of the data inside the Tuple is saved continuously inside the memory and it's very common to have two or three element kind of a double but if you want to save a large number of elements then it is recommended to go with the list now here also we can do a simple pattern match so on the left let's create one more Tuple we can say A and B and let us check the value of a and let us try to evaluate and we get the value back as 1 in this time let us create a three element Apple so in the future whenever you are learning about web development using Phoenix that time you will see that it's very common to have three elements or maximum four elementable and a very common pattern would be something like this so the first element would be a couple called as message the second element would be the actual message that you want to send back and the third element would normally be the state of your server and let us create a tuple on the right so the first element should be reply message could be a string or Italian phone and for the state we can pass a simple list of all of the friends of octallium so we can say octallium Lewis and Chico next let us try and print out the message and let us try to evaluate let's also check the state of our server so we can say State and let us try to reevaluate and we get the right list back so as you can see tuples are very convenient data structure inside Elixir but normally don't use more than three or four element inside a tuple the next data type that we are going to see is also called as the keyword list so let me show you how a keyword list looks inside elixir so we can create a variable called as data now keyword list is actually a list but inside the list we have the key and the value pairs so we can say that a is 1 so a is a key one is a value and you can say B and 2 and let us try to evaluate and we get back our keyword list now what happens inside the keyword list is your key would normally be an atom but if you remember we write the item as colon first and then the name of the item and in fact this key value pair is actually saved as a tuple so let me show you how it is saved as a couple so here let me create a list and inside the first element that is the key is always saved as an atom so I can say a and the second element is the value so it would be 1 and let us try and pattern match on a very simple keyword list so we can say a and one so as you can see over here a and colon this is just a convenience feature but while saving inside the keyword list it is actually saved as an atom and this key value pair is converted into a tuple which we can see right over here now let us try to evaluate and we get the same answer back that means we have a match between the right hand side and the left hand side for accessing the different values inside the keyword list we can use the inbuilt module so let us go back to our terminal and let me write keyword Dot and let me press a tab and as you can see we have a lot of convenience features for working with our keywords let's go back to the live book and let me show you how to fetch the values from a given key so for example I can say that I want to access my keyword list of data and then I want to access the key of a and let us try to evaluate and we get back the data as one well that's it for this one and we'll learn more about maps and struck right in the next one the next data structure that we are going to study is called as a map so let me create a variable called as my map now in the last video we saw how to create a tuple and for creating a tuple we normally use the curly brackets and for creating a map we simply add a person symbol so maps are more like your dictionaries in your python these maps are also your key and value kind of a data structure but Maps offer a lot of features as compared to your Tuple or your keyword list inside Maps we can use different data types for our keys but right now let us see how we can use an atom for our key so we can simply say a colon and one then let us add one more element B and let us add one more C and three so this is how you can create a map and what happens is when you use a tuple for your key at that time you can use the dot notation I will show you shortly what I mean by the dot notation but right now let us see how the map looks like and we get the map back next we can use our pattern matching to extract values so here let me create a map and inside the map we can pattern match on the key of A and let us collect the value inside a variable cordless first next we can pattern match with b and let us collect the value inside second and for the last one we can use the variable of third and let us pattern match with the variable of my map and let us see the value inside the variable of first and let us try to evaluate and we get the right answer back will maps are very convenient data structure suppose if you want to extract only the second value you don't have to use the entire map instead we can do something like this so let me just show you let us create a map and let us say that we simply want to pattern match on the key of B and let us collect the value inside second and latest pattern match with our map of my map and let us see the value inside second and as you can see we get the right answer back so it's not mandatory to create the entire map to pattern match instead we can create a shorter map with just the required elements so here we are simply pattern matching on the key of B and we are collecting the value inside the variable of second the next thing is since we are using atoms for our keys we can use our DOT notation to access the values so let us create a code block and we can save my map dot a and it will try to evaluate and we get the answer back but if we have a different data type for example if we have a string for the key values then you can't use the dot notation let us create one more map and let me call it as map 2 and let us create a map right over here now if you plan to use a string as your key then we need to write them inside quotes because they are strings and since we are using a data type which is not an item for the key we need to use the arrow notation and here we can assign the value as 1 next let us create one more key for B again remember since the key is not an atom we are using the arrow brackets here we can assign the value of 2 and we can create the last one C and let us assign the value of 3 and let us evaluate the cell and we get our map back next we can use the same pattern matching techniques so for example if you want to extract the value of C then let us create a map and since this time the keys are strings let us pattern match right over here and let's say that we want to collect the value inside a variable called as C and let us pattern match with our map number two and let us see the value inside the variable of c and we get the right value back Elixir provides a lot of inbuilt features for working with our Maps so if we go back to our terminal and if I enter map and Dot the tab we can see that we have a lot of different features for example if you want to fetch something or if you want to create a new map or if you want to replace some values or if you want to update some values so we can do a lot of things with the map but for now let me show you a very easy method of updating up a map so let us create a new code block and suppose we want to update the value of C from 3 to 4 then we can say that we want to update the value of our map and the variable name is map 2 and then we can use the pipe operator and then we can say that we want to update the value of C from 3 to 4 and let us bind the value of this back to our variable of map of 2 and let us try to evaluate and see what kind of output we are getting and as you can see we have updated the value of C now we are using this arrow notation because we have strings for our key values but in case if we have atoms then we can simply use the colons so let me show you so we have another map by the name of my map and then we can say that we want to update my map and this time we want to update the value of c and since C is just an atom we can use the regular notation and we can say that we want to update the value to 4 let us try to evaluate and we get the updated value back well that's it for this video this was a very short introduction to Max and we will learn much more how to work with maps as we progress in the tutorials the next video is all about struts in Elixir the next data type is the struct and if you come from a compiled programming language such as C or go you must have worked with structs and now let us see how we can create a structure inside Elixir now for creating a structure we need to create modules because by default the structure will take the name of the module suppose we want to define a structure for the user then we can create a module so we can say create module user and then inside the module we can use another macro and the name of the macro is called as depth struct now all of these things that you can see over your def module Dev structure these are all macros that means they create a code from a given code but right now we don't have to learn more about macros let us see how we can define a struct so what we have defined is we have created a model called as user and then we are using another macro called as Dev struct now here we need to specify the different fields for our struct and these fields have to be specified in the format of your key and value pairs now here again we can use the bracket notation if you want or if you don't want you can leave it out and here let us see how we can specify the fields so we can say that the first field should be username the second one should be an email now this is one way of specifying your Fields but if you want to initialize with some values at that time we can also pass the key and value pairs so for example if you want to say that while initializing we want the age to be nil and for the email we can say that we want to have a blank string and for the username also we can say that while initializing we simply want to have a blank string so what we have done is we have simply converted from a list of atoms to a list of key value Pairs and all of these parameters are going to become the fields for the user struct next let us see how we can create and initialize a struct so let me add a code block now working with struct is very similar to working with a map for creating a map we used to use our person symbol and the brackets and for the struct is very similar just that we have to use the name of the strap so this is how we Define a struct inside let us specify the different fields so we can say the value for the username would be octallium suppose my age is 14 years and my email can be Autobot at the redsample.com and let us try and evaluate so what we have done is we have essentially created a struct and this is how we can initialize a struct structs behave very similar to our maps and we can use the same pattern matching techniques on our struct as well so for example let us assign this one to a variable called as user1 and let us evaluate next let us create one more code block and suppose we want to extract the username then we can simply create your regular map and here we can say that the field name would be username and let us create a variable name and let us pattern match on the variable of user one next let us see the value inside username and let us try to evaluate the block and as you can see we are getting the right answer back so what we did was this user one this is a struct but structs behave very similar to maps and that's why we can use our map notation for pattern matching we can use the same technique for updating values inside a struct as well so for example if you want to update the age so you can say that the map of my user one and inside this I want to update the age to suppose 21 and let us rebind the value this back to user 1 and and let us try and evaluate and as we can see we get the updated age back well that's it for this one so what we have done is till now we just had a very short introduction to the different data types in Elixir but if you're not feeling confident don't worry as we progress and as you have more practice you will start feeling much more confident till now we have seen a couple of different data types inside Elixir now if you're not feeling confident don't worry we will have more practice as we progress with the tutorials but right now let us go with the flow I simply wanted to introduce you a couple of topics before we can dive much deeper into them the next topic is all about your flow control inside Elixir for creating Loops we would normally use recursion but other than the recursion we have a couple of different mechanisms for our flow control so let's have a look at the first flow control mechanism called as a case let us create a simple list so you can say that the list is going to be one two and three now what we can do is we can create a case statement so this case statement acts more like your switch statement so let me create a statement and then I can show you how it works so here we can say that we want to create a case and let me put the end block now here we can say that we simply want to fetch the second element from our list so remember the second element from our list would be 3 so this is at index number 0 1 and 2 so we can say that we want to fetch from the list the second element and after that depending on the result of this statement we can pattern match on a couple of different cases so let us create the first case inside of this one so here we can say that in case this statement evaluates to a one at that time we simply want to return back a string and string would be this one print next we can also create multiple cases so in case we get the answer is 3 back at that time we simply want to return 3 is a match and the next one is a casual case and for that we can say that we want to use an underscore that means we are not interested in the value but in case we don't have a match for the return of this statement at that time we simply want to return a string called as catch all now let us try and evaluate this one and as you can see we get the answer as 3 is a match so let us try and reiterate what happened so we have created a key statement and we simply want to pattern match on the result of this expression right over here so this statement evaluates to a 3 and since we get a match that's why we get the written as 3 is a match we can use this case statement to pattern match on almost anything so for example suppose we have a structure so let us create a module so we can say we want to create a model for post and inside this let us create a structure and let us create the different fields suppose we want to have a field for the ID and we want to initialize to nil and then we want one more field for the title let us initialize to a blank string the next one could be for the description and we can again assign it to a blank string the last one could be for an author again let us assign a blank string so we have created a struct next let us create a post so we can say that we want to create a post one and we want to have a post suppose the ID is one the title could be title number one the next we want the author suppose the author is Julius Caesar and let us try and evaluate the cell and as you must have noticed we are not giving the description inside this struct but while defining we have defined that in case we don't have the value of description at that time we simply want to initialize it to be a blank string and that's why we are getting a blank string right over here next we can use the case statement for our post and suppose we want to pattern match on the author so we can say that we want to have a case statement and we want to Pat and match for our post number one and here let us Define a couple of different scenarios now remember that since this is a struct we can also use the map notation for our pattern matching so here we can say that suppose we have an author and in case the author name is octallium then we simply want to return a string got a post from octallium let me copy and paste suppose the author name is anilo so we can say got post from Anil Kulkarni next we can also create a catchall blog so we can use the underscore and this time we can create a string and we can see what a post from and we can use the string interpolation so we can say post one dot author and let us try and evaluate so this time we get the answer as got a post from Julius Caesar not just as a small reminder we can easily update the struct as you would update a map so in case we want to update the author field from Julius Caesar to my name so we can say that we want to update the author to become Anil Kulkarni and let us try to evaluate and this time we have the new author Anil Kulkarni now let me create a new code block and let me just copy and paste the key statement right over here and let us try to evaluate oh so this time we are still getting the answer as Julius Caesar and that's because we are not rebinding over here so we can say we want to rebind the variable of post number one to the updated value so let me reevaluate and this also let us try to reevaluate and this time we get the right answer back similar to the case statement we have another flow control mechanism by the name of condition so let me create a new code block over here and this is going to be for the condition and here we can define a couple of different conditions to pattern match on now the condition statement does not take an expression right over here instead we can pattern match for the different conditions right over here so suppose the first condition that we want to match would be for the Post author and suppose if you want to say that in case the author is octallium at that time we simply want to return a string back saying that editing a post from octallium let me copy and paste this one and this time let us check for the condition of Anil hulkarni and this also becomes only full currently next let us also Define the catch all block for the condition now for defining the catch or block we simply pattern match on the true condition and we can say that in case we have a true condition then we simply want to return a string saying that this is a catch all now let us try to evaluate this cell and we get back the answer as editing a post from Anil equal kerning let us have a look at one more condition block so let me create a new block right over here we can also use this condition statement for more advanced pattern matching so example we have a list right over here and and suppose we want to pattern match on the first element so at that time what we can do is we can simply use the head function so we can say that we want to extract the head from our list and in case the head is 1 at that time we want to return a message saying that got a 1 and let us Define the catchall block so this time we can use a string interpolation and we can say add is and then we can put the head right over here so let us invoke the function of head on the list and let us try to evaluate this block and we get the answer as got a 1. so as you can see we can use all of the different pattern matching techniques for condition as well as case the last flow control mechanism is the if and else block but normally you will not have to work with the if and else block we would use recursion or pattern matching instead of using IF channels but let me show you how we can use the if and else blog if required so let me create a new section this section is for the if and else and let us create a new code block so the if and else condition is pretty much the same so we can say if true then we want to print out this will work else we want to print out else this will work and let us try to evaluate the cell and we get the answer as this will work well that's it for all of the different types of flow control mechanisms inside Elixir well till now we had a very short introduction to the different data types and flow control mechanisms inside Elixir from the next video we will start working with a mix project and at that time we will learn all of these Concepts in much more details I think by now we have learned enough to start with the basic concepts of functional programming so let us go ahead and let us start a new project now Alexa ships with a tool called as mix which stands for mixing Elixir so this mix is like your project management tool so let us see how we can use this to create our first project so let me go back to my terminal and I want to go inside my folder functional programming with Elixir so right now I have created only one folder which was for our Scripts now let me create a new folder and let me name it as code let me go inside code here we can create a new project by saying mix new and let me name the project as tutorials and that's it we have a new Elixir project let me go inside the folder of tutorials and let me open it up in my code editor so as you can see Elixir by default creates a bunch of different folders and files for us so inside the lib directory we can see that we have a model for the tutorials let me zoom in for you the first main topic that we are going to learn in our journey of functional programming is all about recursion and that's what we are going to start right in the next video now let's start with the most fundamental blocks of functional programming and that is recursion now don't worry if you have never worked with recursion or if you find recursion very confusing I will show you recursion step by step and line by line I will also include a lot of diagrams and small animations to help you understand how recursion works but for now let us get started so this is the mix project that we created in the last video now I don't need all of this code let me just take it out let me just save it now let's write a very simple recursive program to print the number of digits so suppose you have a function called as up to and if you pass 3 to it then we should print 0 to 3. so it's a very simple program but we will Implement a program recursively so inside the lib directory I want you to create a new folder by the name of recursion and inside this folder let us create a file and let us call it as print digits dot ex now this time please remember that the extension is dot ex because we want to compile this file and if you go to test here we can see that we have dot EXs so this are script files and they are not meant for your production code now let me get back to the print digits and let me collapse my sidebar now remember that all of the code inside Elixir stays inside its modules so the first thing is we need to define a model for this file so let's create a model by typing depth module and this is the name recursion dot print digits but the naming convention goes like this first we normally include the name of our project so we have to name our project as tutorials and let me open up my sidebar so inside our project of tutorials we have created a folder called as recursion and inside that recursion we have created a file called as print digits now remember that this is just a community convention and it is not required you can name this model anything that you want now with that in mind let me collapse my sidebar now inside of this module let us create a function called as up to so we can define a function by using the keyword of Def and then we can say up to now this function is going to accept one parameter and that would be for our numbers and then we can start with the do and end blocks now suppose the number is 3 then we simply want to print out something thing like this so we take the input as 3 and then we want to print digits from 0 to 3 so this is what we want to print but we need to do this thing recursively you must be thinking maybe we can just create a for Loop so we can create a for Loop for I is equal to 0 then we can say I less than a and equal to your number and then I plus plus and then we can simply print out I so if you're thinking we can do something like this then the answer is no because all of the data types inside Elixir are constants they are immutable and what's happening inside the for Loop is for each iteration we are changing the value of I which is right over here so we can't use this kind of for Loops inside Elixir then what can we use so the answer is by using recursion so let me take out the comments first let me write the code and then I will explain what's happening now let's think of a base case suppose the number itself is 0 then at that time we don't have to do anything so at that time we simply have to return back zero so we just write 0 over here now remember that the last line inside of function automatically returns so this is your automatic return statement and we don't have to use the keyword of return for the last line now remember that Elixir is a functional programming language so essentially we have to return some kind of a value for each function and in case the function is creating some kind of a side effect at that time by default an item of ok is returned but for now let us continue with this program and let me write the next base case so what we can do in Elixir is we can actually create multiple copies of the same function this is also called as function overloading and we can do this because Elixir supports pattern matching so what we did right over here is we created a function called as up to and we are pattern matching on zero so in case if the number is 0 then we simply want to return 0 and that's it now we can create one more copy of the same function so we can say Define up to this again accepts a parameter called as numbers and let's see what we can do this time so this time what we want to do is we simply want to print out so we can print out by using i o dot puts so let us print out the number but what we want to do is for each iteration we want to reduce the number by one so for example if the number was 3 then after we print out 3 for the next iteration your number should become 2 then your number should become 1 and then your number should become zero and when your number becomes 0 at that time we go to this line number three where we simply return 0 back so the the next question is how can we reduce the value of number by 1 each time the answer is by using a recursive call to the same function so for each iteration we can call ourselves back but each time what we can do is we can say numbers minus of one so what we are doing is suppose this number is 3 so the next time when we call the same function we are passing 3 minus 1 that means we are passing 2 now don't worry if you find this logic a little bit confusing we will see how to trace this function and how we can create recursive trees so I will use a small diagram and small animation for it but first let us run this file and let us see if it is working or not so let me save the file and let me open up my terminal now till now we have been working with IEX but this time we have created a project by using our mix tool but fortunately we can use IEX along with our mix project as well so here we can you can see that hey IX I want you to start mix so we just use the flag of hyphen and S followed by the mix command so what happens in the background is IEX simply compiles your project and all of the modules are available to you inside our IEX so let me clear up everything and let us call this function of up to but remember that this function stays in this module so what we can do is we can say from the model of tutorials I want you to go to the model of recursion from Recreation I want you to go to the model of print digits and from here I want to use the function of up to and let us pass 3 right over here and let us see the output we are getting so here it is we are getting the output of 3 2 and 1 so this 0 is not printing if you want we can print 0 right here at line number four so if you want we can replace this line by again io.puts and 0 but I think there is no point in printing 0 so we can take this one out or else we can also say that whenever we get a 0 we simply want to stop and we can return back an atom called as okay which symbolizes that our operation was successful now let me save the file now since we have saved the file we also need to recompile our project now here we have two choices either we can recompile the entire project or we can decompile just the model that we have changed but each time typing such a huge model name is a big pain in the ass so what we can do is we can create a small Alias so we can say that I want to create an alias for tutorials dot recursion dot print digits let me clear up the screen and now we can say that I simply want to recompile my model of print digits and here it is we have recompiled that module now let me clear it up one more time and this time again we can use the model of print digits and we can invoke the function of up to now again if you want you can use the parentheses or or you can leave them out so let me just pass three right over here and this time we get the output of 3 2 1 and okay so let us go back to our code editor and let us see what's happening so what's happening right over here is this is also called as your base case so let me put a comment right over here so this you can call this is your base case so that means that in case if we get an input which is 0 at that moment we simply want to return some kind of a value and we want to exit from our recursive function now since this function returns a single value we can use a much shorter syntax so let me take out and let me take out the written statement and after the function definition I have to put a comma after do I have to put a colon and let me take out the OK from here and let me paste it right over here and that's it so this is also a valid function definition so normally whenever we written a single value that time we use a single line definition now instead of returning okay let me go back to returning zero so what's happening is we have a base case whenever we are getting the input of 0 at that time we are simply returning 0 but we are not printing anything and in all other cases we are first printing that number and then we have a recursive call now let's see how we can trace this function so let me open up my browser and uh so this is our function for print digits so this print up to 0 and do 0 this is our base case and this is our recursive function so this line number four is a place where actual printing is taking place and on line number five we have a recursive call to the same function now let's see how we can trace this function just imagine that the first argument we are passing to this function is 3 so for each iteration what's going to happen so Elixir is going to compare from top to the bottom is 3 and 0 equal no they are not so Elixir will jump to this function definition so let's see what's going to happen for this function definition the first thing is we are simply telling Elixir to print out the value of number so that's what is going to happen so the first call is to print and we get three back now what happens next so next is a recursive call to the same function but with the value of number minus 1 so let's see what's going to happen so next is we are calling the same function back but the value becomes 2 now is 2 equal to 0 no it's not equal to zero so again Elixir will jump to this function definition and again what happens the first line is we simply want to print out the number so we get the output of 2 and what happens on the next line we are calling ourself back but this time again number minus 1 so the next call becomes up to and your argument becomes 1. again the same thing happens is 1 equal to 0 no it's not so again Elixir will jump to this function definition the first line is to print the value so we get the value of 1 back now what happens over here again we have to call ourselves back so again we call the same function but this time the argument becomes 0 remember 1 minus 0 that's why we get the argument here as 0. now again Elixir jumps to first Clause now remember Elixir scans your code from top to the bottom and the first definition is up to with a pattern match of zero and this time what's happening is we have a match since up 2 gets a parameter of 0 we simply want to return 0 back so what's going to happen over here so for this function we are simply going to return 0 back and that's it do we have any other calls left no so we simply exit and that's it we have the display of 3 to 1 in our console so let me open up my terminal one more time and here it is we have the exact same output of 3 2 and 1. so what we did right over here is we saw how we can trace our recursive program so always remember to plot this kind of trees and this will help you to understand recursive programming in a much better way now let us go back to the code and this time let me make a very small change now instead of printing the number first what happens if I print the number afterwards now let's see what happens this time let me open up my terminal one more time and let us recompile our model since we changed the code and let me clear it up and then let me again call the print digits up to and let us pass three so this time what happened so instead of getting the output of 3 2 and 1 we have the output of 1 2 and 3 so what happened we simply change one line right over here and our entire output got reversed so let us go back and try to trace this circus program as well so this was the earlier one and this is going to be the new one so remember we have the print statement afterwards but first we are calling the function recursively so let's see what's going to happen this time so again suppose that we are passing the argument of 3 so what happens is 3 equal to 0 No 3 is not equal to 0 then Elixir will jump to this function definition now what's happening in this definition first we are calling ourselves so what's going to happen we have a recursive call and the parameter becomes 3 minus 1 that means we have a parameter called as 2 but what happens to this call at line number five nothing that statement remains unexecuted because first we have to exhaust this function right over here so what's going to happen next time so let us see right over here so this call right over here this does not execute instead first we have to exhaust all of the parameters for this function now what's happening the parameter is 2 is 2 equal to 0 no it's not so we are going to go in this function definition so what's happening this time we again have a recursive call so let us call ourselves back but this time the argument becomes one and what happens to the print statement nothing that is kept on hold right over here now let us go back to this function right over here is 1 equal to 0 no so we go to this function again what happens we have to call ourselves back so let us call ourselves back but this time the argument becomes 0 and what happens to the print statement again that is kept pending now what's going to happen this time we are calling ourselves but the argument is zero so we have a pattern match right over here and whenever the argument is 0 we simply give back 0 and that's what happened right over here so this call right over here this resulted in a zero now the control will go back to the previous function now what is spending in the previous function this print statement is pending but what is the value of number so the value of number 1 that's why we get the output of 1 first now again we have exhausted this Clause the control will go back to this one again what's pending the print statement is pending but what is the value of Number the value of numbers 2 that's why we get the output as 2. now again this function is exhausted so the control goes back to this function right over here again what's pending the print statement is pending but what is the value of number it's 3 that's why we get the value of 3 back and this is exactly happening right over here so we get the value of 1 2 and 3 so what's happening over here is we can say that our print statement is executing in the return stage but in the earlier example our print statement was executing in the ascending stage so we have a basic difference in the execution of our recursive functions let us try and summarize what we have learned till now so what we have done is we have created a simple program to print out the digits but we have implemented the logic in a recursive function now the only line of difference is right over here in the first time the recursive call is the last line inside this function now remember the last line is automatically returned we don't have to use the keyword of return and this is creating a loop for us now when do we exit we exit when we have a base case and what is the base case it's criteria whenever we get a 0 at that time we simply want to return 0 and this is the time when we exit from our recursive function so we have two different function definitions the first definition is for our base case the second definition is for our recursive case now what we did in the second time is we simply change our recursive call so in the second case first we have a recursive call and then we have the print statement and what happened this time the execution shifted from ascending stage to the written stage so if I have to summarize further here what's happening the printing is done in ascending stage and in the second case the printing is done in the return stage that means the work or the execution happened during the return and not during ascending stage so this kind of function is also called as yield recursion now remember in tailed Recreation we are calling the same function back but each time with a different argument and on the second case this recursion is called as head recursion because first we have the recursive call and then we have some kind of an execution left now you can see that we can create efficient Loops in Elixir by using recursion and that too avoiding all of the side effects by mutating our values well that's it for this one I hope you enjoyed the lecture on recursion and I will catch you in the next one so till now we saw how to print digits by using recursion and we sort two methods that was tail recursion and head recursion now let us get some more practice with recursion and this time instead of just printing the digits let us add all of the digits together so for example let us create a function called as up to and if you pass the argument of 3 at that time we want to get the sum of all of the digits so this function should return 3 plus 2 that is 5 5 plus 1 is 6 so this function should return as 6. so let us go ahead and let us create the file for this one so inside the directory of recursion let me create a new file and let me call it as sum of digits dot e x the first thing we want to define a module and as per the community convention let us write the application name first so the application name is tutorials and then the folder is recursion and then the file name is sum of our digits let me collapse my sidebar now here let me first write a very simple recursive function and then we will try and restart function so let us call a function by the name of up to and let us pass the argument for the numbers and let's see what we can do this time so this time we can use a very simple recursive function we can say that for each iteration I simply want to add the number and the next time I want to call the same function of up to but every time my argument should be number minus of 1 but this function will never end because we don't have a base condition the number will keep on going into negative values so we also need to define a base condition so on the top let us create the base condition so let me create a new function by the name of up to and this time let us pattern match on 0 suppose the number is 0 then at that time I simply want to return back 0. now remember if we have a single line of return then we can write it on the same line and in case if we have a regular function then the last line is automatically returned we don't have to use the keyword of return so let me save the file first let me run the file and then we will try and Trace the recursive function so let me open up my terminal and let us enter inside IEX so I can say IEX dot s that stands for start I want IEX to start my mix and let me clear all of these things let us create an alias so we can say I want to create an alias for tutorials dot recursion dot sum digits let me clear up the screen and now we can see from the model of some digits I want to use the function of up to and let me pass the argument of three so as expected we get the answer as 6 so what happened 3 plus 2 plus 1 is equal to 6 now let us see how we can trace this recursive function so this is our program for some digits and this is the functions that we wrote on line number one we have the base case and on line number three we have the recursive case now let us see what's going to happen let's take the same example and let us pass 3 to this function now is 3 equal to 0 No 3 is not equal to 0 so Elixir will go to the next function and here what's going to happen here we are saying that we want to add the number and after adding the number we simply want to call the function recursively so what's going to happen is we get 3 plus and again we call back the same function but this time the argument is number minus one that's why the next time we are calling the same function up to with an argument of 2. now what's going to happen is 2 equal to 0 no so elixir go to the next function now what happens again the same thing number plus the recursive call so what's going to happen is so this will evaluate 2 we get the number so the number in this case is 2 so 2 and plus and then we again get back the recursive function but this time the argument is 2 minus of 1 that's why the argument becomes 1. now again let us go back to the same function is 1 equal to 0 no then we will go to the next function now here again the same thing repeats so this time again the number plus that means 1 plus and let us call the same function again but this time the argument becomes 0 so what's going to happen this time this time we have a base condition in place which is right over here we are saying that whenever the argument is 0 at that time we simply want to return back zero so this function right over here this will simply return back a 0. so now what has happened we have exhausted this call and now the control has to return back to the earlier functions so what what's going to happen so this entire expression 1 plus of this function this will be evaluated to 1 plus 0 is equal to 1 so this entire expression evaluated to a one now the control will go back to this function right over here but this time what's happening so this entire function call evaluated to a 1 so what's going to happen right over here this entire expression would be evaluated to 2 plus 1 is equal to 3. now again the control will go back to the earlier function call so this time what's happening the function call of up to and 2 has evaluated into a three so this entire expression gets evaluated to 3 plus of 3 that means we get back a 6 and this is what is written from our function which you can see right over here now if you have a look at this function this function is neither head recursive neither it is still recursive it is just a recursive function but can we convert this function into a tail recursive function yes we can so let me show you how we can convert this function from a regular function to our tail recursive function so let us create a new function right over here and we can say that this time the up to function would be tail recursive now first let me write the function definition and then I will explain what's happening so this function is going to accept two different parameters the first parameter is the number as it is and I also want to accept one more parameter which I am going to call as accumulator so which stands for ACC for short next let us think of our base condition so as we just saw over here we have a base condition where the number is zero so let's try and replicate that same logic right over here so in case if I say that my number itself is 0 then at that time I simply want to return back my accumulator so I can say do ACC e so this is our base condition now let us see how we can Define our recursive condition so let me copy and paste right over here and this time we want to get a number and let us take the return statement in a different line so let me take it out now let's see what we can use as our recursive call now again please let me repeat first let me write the code and then when we see how to trace the recursive algorithm at that time the logic will get clear but right now what I want to do is I simply want to call the same function again but for each iteration I want to say that my number has to decrease by 1 and for each iteration I simply want to add my accumulator with the number and that's it we are done so let me save the file and let me open up the terminal and now I can recompile the model of some digits now let me clear up the screen and we can say that we want to use the tail recursive version and let me pass 3 to this one oh we have an error that's because we also need to pass the accumulator so this function the tail recursive requires two arguments and I pass only a single argument that's why we get an error so let me clear this up and we can say that the accumulator has to be 0 and this time we get the answer back as 6. now we can slightly improve our program each time instead of passing an accumulator what I can do is I can simply set the default values so let us go back to the code editor and let me copy and paste this line so what we are going to do is we are going to create a function definition and since we are just creating the function definition or you can say just the function header we don't need to specify the return statement so this has to go and here we can say that the default value of the accumulator is 0 so in case the accumulator is not specified at that time the accumulator would be set to 0 and here instead of 0 we can say that the first argument can be any number so what we have done right over here is we have simply created a public function so as our code editor is helping us it's just a public function with a given name and body so normally these things they help you with the documentation of your code the first thing we again need to recompile our model of some digits let me clear up the screen and let us try to invoke the same function but this time since we have a default argument for the iPhone emulator I can simply leave it out and again we get the same answer back as 6. before we go ahead and trace this recursive function we can do one small thing now what happens this function is slightly expensive because it takes slightly more memory so what we can do over here is we can simply call the tail recursive function and pass the argument of number and that's it so now let us open up our terminal and let us again recompile let me clear up everything and this time if I do some digits dot up to and if I pass the argument of 3 so what's happening behind the scenes we are still invoking the tail recursive function and we are getting the same answer back as six so now let us go ahead and let us see how we can trace the tail recursive function so this was the last function now if we want to trace the tail recursive function on line number two we just have the function definition so this function accepts a number and for accumulator we have set the default value as 0 on line number three we have the base condition and we are saying that whenever we get the number as 0 at that time we simply want to return back the accumulator the next is our recursive call now let us pass the argument of 3 to this function and let us try to trace this recursive function so we have an initial call like this the value of number is 3 and by default the accumulator is set to 0. now let's see what's happening now is 3 equal to 0 no it's not equal to 0 so Elixir will go to this function right over here now what's happening now we are calling the same function back okay so what we need to do we need to call the same function back but what happens to the argument so the first argument is we simply want to decrement the number by one so in this condition what is happening the number is 3 okay so we get 3 over here and for each call we simply want to subtract one from it so the answer here is 2 and the next parameter is right over here so we simply want to add the accumulator with the number so let's go right over here so what's the accumulator so as you can see initially the accumulator is zero so we get a zero right over here what's the number the number is 3 so 0 plus 3 we get a 3 right over here so this entire function would look something like this the new number is 2 and the new accumulator is a 3. now let's see what's going to happen is 2 equal to 0 no it's not so we will go inside this function again we have to recursively call the same function so let us see what's going to happen so again we call the same function but this time what happens the number is 1 so this 2 comes over here minus of 1 so what's the remainder it's one the next is accumulator plus the number so in this case what is the accumulator the accumulator is 3 which comes right over here what is the number number is 2 so 2 comes over here so 3 plus 2 we have a five so this function gets evaluated 2 right over here up to the number becomes 1 and accumulator becomes 5. now again the same thing we have to call ourselves back again now is 1 equal to 0 no so we go to the next condition and again we call ourselves back so what's going to happen this time so this time number is 1 1 minus or 1 so that's why we get a 0 right over here the next is again the same thing accumulator plus the number so what's the accumulator the accumulator is 5 that's why we get a 5 over here what's the number the number is 1 so we get a 1 over here so 5 plus 1 we get a 6 that means we can say that this expression is evaluated something like this up to 0 and 6 oh so this time the number becomes zero so what's going to happen so it's going to go right over here so is the number 0 yes the number is zero so what do we do we simply written back in the accumulator so that's what is going to happen right over here we simply have to return back the accumulator so what's the accumulator the accumulator is 6 and that is what we have written so now is anything left nothing nothing is left and that's it we get the answer back as six so as you can see this tail recursive functions are very special the first reason is they require less memory and why do they require less memory is because they are recursively calling themselves back again now if you come from some other compiled language like Java or maybe like python you must be thinking that for each of these calls V must be allocating different stack memory but no that does not happen in Elixir since Elixir is a functional programming language this function calls are highly optimized so what's happening we are simply reusing the same stack and hence there is no extra memory allocation so always whenever possible try and use skill recursive functions because they are more memory efficient in terms of speed it could be more it could be less you don't know but in terms of memory for sure they require much less memory well that's it for this video and I will catch you in the next one let's have some more practice with our recursion in the last video we wrote a very simple recursive program to calculate the sum of the different digits but for this video I want you to calculate the factorial of a number first let me get this back to the old code so the old code was number plus of up to and then we simply want to call number minus of one so this time what I wanted to do is I wanted to write a program for calculating factorial so for example if we have a number like 3 then the factorial would be like this 3 into 2 into 1 and the output would be 6. so I wanted to pause this video for movement and try it on your own so I hope you were able to do it if not let us do it together so first let me create a new file and let me call that file as factorial.ex and first let us create the module let us get the model name right this has to be tutorials dot recursion dot factorial and here let me create a function called as off so we can simply call factorial dot off so the first condition is in case if I get 1 at that time I simply want to return one back next let us write the recursive case so in case we get some other number so we can say number and this time let me show you how you can calculate by using a regular recursive program and after that I will also show you how to write this program by using TLD recursion but for now let us go with the flow so here we can say that for each iteration we want to multiply a number and we simply want to call ourselves back each time but each time we want to decrement the number by 1 so this is a very simple recursive case let us open up our terminal let me clear up everything and let us use our IX let me adjust my terminal as well here we can create an alias so we can say tutorials dot recursion dot factorial and let's call our function so we can say factoidal off and let us pass 3 so we get the answer as 6 let us try with 4 so we get the answer as 24 back now let us try and trace this recursive program and see what's happening so this is the first recursive program that we wrote so here we have the base condition Define off if we get one we simply want to return one otherwise we want to call this function so now let us try and Trace what's happening so suppose we invoke this function with an argument of 3 so at that time what's going to happen so is 3 equal to one no so Elixir will go to this function and now what's going to happen we have to multiply the number and call the function itself again so here it goes we want to multiply 3 and we want to call the same function one more time but since we are decrementing the number by 1 so this time the argument becomes 2. now again is 2 equal to 1 no so we will jump to this function again the same thing will happen we first have to multiply the number and call the same function one more time so this time again we have 2 and this time 2 multiplied by the same function and the new argument is 1. so in the next iteration we have a match on the base case so since we have a match we simply have to return one so this function would be evaluated to a simple one now the control will go back to this statement right over here 2 multiplied by and this function so this would be evaluated to 2 and this one comes right over here so this entire expression would be evaluated to a 2. now the control will again flow back right over here so this one would be evaluated something like this 3 multiplied by 2 and we have a 6. now there is nothing on the top we have exhausted dysfunction as well that's why we get the written value as 6 which is the factorial of 3. now let's go back to our program so this was a very simple recursive way of creating the factorial next is can you write the same program but by using tail regression so if you can just give it a pause and try it on your own otherwise I will show you how we can write the same program by using tail recursion so let me create a new function right over here and I can say off but this time it's going to be with real recursion this function is going to accept two arguments so the number one would be on number and for the tail recursive function first let us create the base case so here we can pattern match on the number so we can say that in case the number is 1 and the second argument is our accumulator so this time I simply want to return back my accumulator so don't worry if you don't understand we will trace this program as well next comes our recursive case so we can say of our tail recursive version so the first argument is our number the second argument is our accumulator so here I can say that for each iteration I simply want to call the same function again so off tail recursion but for each iteration I simply want to decrement my number by 1 and for each iteration I also want to multiply my accumulator with my number next we can do one slight Improvement for this program as well we can also have a default value for the accumulator so let us go ahead and let us create the function definition on the top so remember that the function definition always goes on the top so here we can say we want to Define of our tail recursive function the first argument is always going to become the number the second argument is our accumulator and for the accumulator we want to have the default value of 1 and since this is just a function definition we don't have to write the body of this function and let me open up my terminal and since we have changed the contents of the module first let us try and recompile this module now let me clear up everything now let's try and use the tail recursive version so we can say factorial of this time we want to use our Delta cluster function and let us pass the argument of three so we get the answer back as 6. let us try one more time with 5 and for 5 we get the answer as 120 so now let us go and try and trace this recursive program as well so this is our tail recursive version so as you can see for the first line we have the function definition the first argument is the number and we have the default value for the accumulator and the default value is 1 next we have the base case and here we simply want to pattern match on the number so we are saying that in case the number is 1 at that time I simply want to return back my accumulator next we have our recursive case so for each iteration we simply want to decrement the number by 1 and we also want to multiply our accumulator with the number so now let us see what's going to happen with this one suppose we invoke the function with an argument of 3 and the default value for the accumulator is 1 so for the next iteration what's going to happen so is 3 equal to 1 no so Elixir is going to jump right over here so what's going to happen this time we want to call ourselves back so this function will call itself back but this time the first argument is number minus 1 so 3 minus 1 that's why we get a 2 right over here and for the next R command we simply want to multiply the accumulator with the number the accumulator is 1 the number is 3 so we get a 3 right over here so this function would look something like this so next again so is 2 equal to 1 no so we have to call ourselves one more time so again this time what's going happen is we want to decrement the number by one so this evaluates to a 1 and we also want to multiply the accumulator with the number so the accumulator is 3 and the number is 2 so we get a 6 right over here and this function would look something like this what's going to happen this time oh so this time we have a match on the number and we are pattern matching and saying that in case the number is 1 at that time we simply want to return the accumulator so this function would evaluate to something like this we simply have to return back the accumulator and the accumulator is 6 and that's your final answer and after this we simply exit because there is nothing else left to do so just as a small tip whenever you are feeling confused with recursion or if you don't know what's happening inside your recursive calls it's always a good idea to draw this kind of recursive trees and for sure they will help you to understand recursion in a much better way well that's it for this video and I will catch you in the next one let's have some more practice with our recursion and this time I wanted to write a program that will reverse the numbers so in case the number is one two three then the output should be 3 2 and 1. and what I've done is behind the scenes I've created a new file called as reverse number inside recursion and I have created a blank model for this one now here you can use your own logic to reverse the number or if you want some reference I have given a simple algorithm right over here but it's not required to follow my logic if you can do it in any other way you are welcome to do it so let's see what steps I have given right over here so for example the number is 123 then the output should be 321 so for this case suppose I want to write a tail recursive version at that time I want to have one more variable called as accumulator and I want to set at the default value of accumulator 0. now again it's not necessary for you to write a tail recursive version you can write any version that you seem fine but I am going to write a tail recursive version for this one that's why I have taken one more variable next what I am doing is I am creating a loop and for each iteration I want to create a new number and a new accumulator so let's see what's going to happen for the new number and for the new accumulator for each iteration of the loop I simply want to divide this number by 10 so that I get a new number each time so for the first time the number is 123 so 123 divided by 10 so I get the answer as 12. now for the new accumulator there are two steps the first step is I simply want to multiply my existing accumulator by 10. now the existing accumulator is 0 so 0 multiplied by 10 that's why I have a 0 right over here so this was the first part and the next part is I also want to take the remainder of this number so I'm using the mod operator so here what's going to happen is the remainder of 123 and 10 is 3 and the final step is 0 plus of 3 and we get a 3 right over here the next thing is I want to continue with this Loop till the time my number becomes 0 but right now my number is 12 so this number changes from 123 to 12 and the new accumulator is 3 that's why this 0 changes to a 3. now is my number equal to 0 no so we continue with the loop so for the next iteration our number is 12 so 12 divided by 10 we get a 1 right over here and for the new accumulator the value inside the accumulator is 3 so 3 multiplied by then we get a 30 right over here for the next part the number is 12 the remainder of 12 and 10 is 2 so here we have 30 plus of 2 that's why this will evaluate to 32. now again is my number equal to 0 no my new number is 1 and my do accumulator is 32 so we continue with the same Loop now this time my number is 1 so 1 divided by 10 I get a 0 right over here then for the new accumulator my value inside the accumulator is 32 so as you can see right over here we have 32 so 32 multiplied by 10 that's why we get 320 right over here the next part is the number is 1 the remainder of 1 and 10 becomes 1 so here we have 1 plus of 320 so we get 3 2 and 1 right over here so what happens now your number number has become 0 and your accumulator has become 321 and since your number becomes 0 we simply want to return back the accumulator and the accumulator is 3 to 1 which is exactly the reverse of 123. now before you attempt this question let me show you one more thing in Elixir if you do something like this 123 divided by 10 here you can see that we get back a float value but if you want to get back an integer division then you can use the inbuilt function of div for for division so we can say we want to divide 123 by 10 and we get back in the integer value of 12. now for calculating the remainder we don't have the modulus operator instead you can use the inbuilt function of remainder so we can say that we want to get the remainder of 123 with 10 and we get back to the value of 3. so with these things in mind I want you to write this program now again let me repeat you can use your own logic and just pause this video for a moment and try it on your own otherwise we will do it together so I hope you were able to do it if not let us do it together I am going to write a tail recursive version for this program and the first thing which I want to do is I simply want to Define my base case and what is my base case my base case is right over here so if my number is 0 then I simply want to return the accumulator let me create a function called as off and this function is going to accept two parameters by number and my accumulator and my base case is something like this in case my number is 0 then I simply want to return back my accumulator so this is our base case now let us Define the recursive case so we can say that the function of off is going to accept one parameter for the number the second one for the accumulator and let us create the do and end blocks here we can say that my new number is going to be the integer division of my number with n n and also for each iteration I want to create a new accumulator so I can say that my new accumulator again let us use the logic that we have defined over here so the logic goes like this for each iteration I simply want to multiply the accumulator with n and for the next part we simply want to add the remainder of the number along with 10. now the only thing left to do is to Simply call the same function one more time but this time the argument is going to be our new number and here we have the new accumulator now here we also need to set the default value of accumulator to 0 so let me create a function definition on the top so we can say that function of off accepts one parameter by the name of number the second parameter is called as accumulator the default value is 0 now since this is just the function definition we don't have to create the body let me save this program let me open up my terminal null now since this time I have added a new file let us recompile the entire project so we can say that I want to decompile then let me create an alias for tutorials dot recursion dot reverse number oh sorry I spelled it wrong so it has to be alias let me clear up the screen and now let us try our newly defined function so we can say that reverse number off and let us pass the argument of 123 and we get the right answer back let us try with one two three four five and we get back the answer of 5 4 3 to 1. till now we have seen how to work with recursion inside our Elixir now it's time to see how we can combine list along with our Elixir and I can't emphasize more that the list inside Elixir are not your regular arrays or lists list inside Elixir are actually linked list so even if a list looks something like this it's not what it looks like so for those of you who don't know what is a linked list here it goes so here we have three different nodes and for the first node the data inside the head is one so as you can see the data inside the list this one this one actually looks something like this inside the memory so this enter bad thing this would be your node number one and the data inside your head would be one the darker portion that you can see over here so this is going to be your tail of your node number one and this tail is actually pointing to yet another node and the data inside this node is stored that you can see over here so this entire structure this is our node number two and the data inside the head is two now again this node also has a tail and this tail is pointing to yet another node the data inside the node is 3 and as you can see this is going to be our node number three The Head and the data inside the head is three now if you have a look at the list we don't have any other parameters left so the tail of your node number three this would actually point to something which is null that means it is not pointing to anything else so this is how a linked list would look inside the memory now just to refresh your memory let us go back to our terminal so we can say that we have a list and the elements are 1 2 and 3. now as we just saw we have three different nodes and if you want to see the head of the first element then either you can use the builtin function for the head or we can also use pattern matching and in case if you want to use the pattern matching then we can say that the first element should be head then we need our cons operator then we need one more variable for the tail and let us pattern match on list and here we can see that the head is 1 and the tail is 2 and 3. now suppose we have one more list let us call it as list number two and this has a single element of a inside of this list now what happens if I try to pattern match on this list so let us pattern match and see let us write the head and we also want the tail and this time we want to pattern match on list number two so as you can see the data inside our head is a but what happens to your tail let us check it out so as you can see the tail is blank that means we have exhausted this linked list and there are no more elements left so keep this pattern in your mind and we will see how to work with recursion and lists right from the next video so let us get started with linked list but before we can get started I wanted to show you a couple of things so let us go back to our terminal and I am inside my IEX now in case if I want to see the info for a list so let's create a list one two and three here we get back a couple of information parameters for our list and here we can see that we have a couple of implemented protocols and one of the most important protocol is this one so this stands for innumerable that means in short as enum and let us go to the official documentation and there I can explain all of these things so this is the official website for Elixir it's elixirland.org let us go to docs and here we want to see the documentation of the current stable version so this takes us to a new website and as you can see this website is called as hex docs.pm so hex is like the package registry for Elixir so in case if you go to this website hex dot pm and here we can search for different packages suppose you want to search for Phoenix then you can search for Phoenix right over here and this is going to list all of the packages so this is the official package for Phoenix and if you click on the online documentation it will take you to the docs page and this is the official documentation for Phoenix now let us go back to the documentation for Elixir and as you can see we have two tabs right over here so this tab is for the pages and this tab is for the modules now this model of Kernel is automatically imported for us we don't have to import this kernel the next model which I wanted to show you is for our list so let us scroll a little bit down and inside this section of Collections and enums we have our list right over here and here we can see that we have nice documentation in place and also we have a couple of functions that are implemented on the type of list so here we can see we have different functions and if you want to see documentation for any of the functions you have to just click on this one and this open UPS the documentation for the requested function now in the terminal we saw that list also implements the protocol for our enum so let us check out the documentation for enum let me collapse my list and let us go to the documentation for erum so enum basically helps you to iterate over your list or any of the collections and most of the functions for your it labels are inside enum and some of them could be in lists or Maps or hash map but enum would be your most frequently used module and as you can see in the documentation the first example itself uses a list the second example also takes a list and and simply gives back the sum of the list so what we can do is let us try and replicate this functionality by using our list and recursion so now let us go back to our code editor now here let us create a new folder so inside my directory of flip let us create a folder by the name of list and inside this folder let us create a new file by the name of list dot ex and let us first Define the module so this has to be dot tutorials and this naming conversion doesn't make any sense so right now let me just take out this list and let us name the module as tutorials dot list so let me Define a function called as sum and this is going to take a list of our numbers now first let us think of a base case suppose we get an empty list so at that time we can simply return back a zero so let me Define a base case on the top so I can say Define my sum and let us pattern match on an empty list so we can just write empties right over here so in case we get an empty list we simply want to return back a zero so now let us see how we can write the recursive case now what we can do is this parameter of numbers this is actually a list so we can pattern match right over here so what I can do is let me take out this parameter and let us pattern match inside the function definition let us collect the head inside a variable called as H and let us collect the tail inside a variable called as T now let us see what we want to do for each iteration we simply want to add the head along with the sum and each time we simply want to pass the tail and that's it we have a recursive function for adding all of the elements inside the list now as you can see that this is not a tail recursive version so what we can do is let us try and rename this file so instead of calling this as sum let us rename this function from sum to some simple and here what we can do is since this is just one single line of return let me take it to a single line let me put the codes and we don't need the end block and let us open up our terminal and see if this is working or not so let me go inside my IEX and let me clear up my terminal and here we can say that from the model of tutorials I want to go to the model of list then I want to invoke the function of some simple and let us pass the list of 1 2 and 3 and as expected we get back the answer as 6. now what we can do is we can also write this function by using tail recursion so let us see how we can create the tail recursive function so we can call that function as sum and tail recursive and let us think of different parameters that we can pass for our tail recursive version this function will accept two parameters the first is obviously our list of numbers and we also need an accumulator and what we can do is let us Define the function definition right over here so we can say that the default value for our accumulator has to be zero and now since we have just created the function definition or the function header we don't need to create a body for this one next let us write the actual implementation so let me just copy and paste so here we don't need the default argument and first let us think of the base case so in case the numbers is just an empty list so at that time we simply want to return back our accumulator the next is our recursive case so let me again copy and paste now this time again we can pattern match on the head and on the tail so we can say that we want to collect the head and we also want to collect the tail and for each iteration we simply want to call the same function back but now for each iteration we simply want to pass the tail we don't need to pass the head for each iteration and our accumulator becomes our accumulator plus of our head and that's it we have a tail recursive function as well now let us do one simple thing let me go at the top and here let me create a function which is called as sum and this accepts our numbers and here let us simply call the tail recursive version so we can say that I want to call my real recursive version and let me pass numbers to it so now we have a much smaller name and this makes our life much more easy so let us go back to our terminal let us recompile tutorials dot list let me clear up the screen and let us invoke the same function but this time the name of the function is just sum and as expected we get back in the answer as 6 and this time for calculating the sum we are using the tail recursive version now going forward I am not going to draw the recursive trees but if you are not feeling confident or if you are feeling confused then I highly motivate you to draw the recursive trees now before ending this video I wanted to show you a couple of things the first thing is let us see how we can document all of our code the first thing is we can use something which is called as module attributes so on the top we can say that we want to create documentation for the entire module so let's document what we are going to do for this model of list we are going to implement a couple of functions that can be used on the list so I can create a heading for our function summary and the first one that we have implemented is for our sum so this is how you write the module level documentation next let me show you how we can write the documentation for our function so for this we can use the model attribute of just Doc and inside the quotation marks let us write the documentation saying that this function Returns the sum of the numbers inside a list so now if you hover over the definition of sum we can see that the code editor is showing us the documentation and the last thing which I wanted to show you in this video is how we can Define the type specifications or the type hints so here we can use another module attribute by the name of spec so this stands for the function specifications so here we want to define the specifications for our function of sums and here we can Define the type of this parameter so in our case sums is actually a list and the list contains different numbers so this is how we can Define the type of numbers the next comes the return type so here we can put double quotes and we can say that the return type is also going to be a number so what we have done is we have also added the documentation and we have also add the specifications so in the future whenever we you are using tools like dialyzer it will help you to catch bugs inside your code next let us write the specifications for our other functions as well so let me copy this one and let me paste it right over here this function is going to be our sum of simple next let us also write the specification for our tail recursive function so here I can say that this function name is actually my sum of tail recursive now this function accepts two parameter the first parameter is a list of numbers the second one is simply an integer so we can say that the second parameter is an integer and the return type is number and if you want to read more about the type specifications then we can go to the official documentation and we can go to the tab of pages and here we can see that we have the documentation for our type specifications right now don't worry too much about type specifications I will show you how we can write the specifications for from here on well that brings us to the end of this video and I will catch you in the next one now let us see how we can reverse a list inside Elixir so for example we have a list and this list has two elements two and three so this list would look something like this inside your memory so we have two nodes so this node is for two and this node is for three now here goes my question suppose we have two more nodes on the left here we can see that we have one node and on the right here we can see that we have one more node so now the question is would adding this node to our list of 2 and 3 would be faster or adding 4 to our list of 2 and 3 would be faster so what do you think this operation would be faster or this operation would be faster so the answer is adding this node would be faster and this happens in constant time and the reason is we don't have to Traverse throughout this entire list we simply take a node and we simply point the tail to an existing list and that's it but what happens if we want to add a node at the last at that time it is not efficient because it is going to take a linear time and adding this node x a linear time because we have to Traverse through the entire linked list so in this case we have to go from this node to this node and after that we can point the tail of this node to our last node so it takes linear time so just keep this thing in mind that adding a node to the head would be always faster and adding a node at the last would take linear time with this logic in place let us see how we can reverse a list so for example we have a list right over here and we have elements of one two and three so at that time we will take one more accumulator list and for each iteration we will take the head of this one and we will insert that head inside our accumulator list so what happens for the first iteration is we simply take out the head and we insert the head inside our accumulator now here since we are inserting at the head this operation takes constant time and for the next iteration what happens since we have taken out 1 your list now becomes 2 and 3. so for the next iteration we simply take out 2 and we added 2 to the head of our existing list now again since we are adding to the Head this operation also happens in linear time now going to our original list since we have taken out 2 we have just one element left and the same thing happens we simply take the three out and we add 3 to the head of our accumulator list and that's it we have reversed a linked list or rather we have simply reversed a list inside Elixir so let us write the code for this one and let us see these things in action so here let me put up a command this is going to be our function of reverse here let us Define a function called as reverse now this function accepts two parameters the first one is for our elements the second one is for the accumulator and let us Define the function signature right over here so in case the accumulator is not given at that time we simply want to set the accumulator to be a blank list the next comes our base case so let me copy and paste and here we can pattern match and we can say that in case we have a blank list right over here at that time we simply want to return back our accumulator so here I can say do and my accumulator the next comes our recursive case so again let me copy and paste now here what we can do is we can simply pattern match for the list so we can take the head and we can also take the tail and for each iteration we have to call the same function back now let us see how we can pass the arguments for our tail recursive function first let us write the r argument for our accumulator so if we go back to our diagram so here what we want to do is we want to take the head and we want to insert the head inside our accumulator so that's what we can do over here so we simply won't take the head and we want to add the head to our accumulator now let us again go back to the diagram now since we have taken out one our list for the next iteration should be 2 and 3 and we can very easily do that so for the next iteration we simply have to pass the tail back and that's it we have a very nice pale recursive program to reverse our list so let us try this program inside our IEX so let me open up my terminal let me go inside my IEX now here let me clear up my screen and I can say that I want to go from my model of tutorials to my list and I want to reverse and let us pass the argument of one two and three and as expected we get back the answer as 3 2 and 1. now the last thing inside this video is let us also write the specifications for this function here we can use the module attribute for our specifications and we can say that our function of reverse now here we can say that elements is actually going to be a list and since we don't know what type of elements would be there inside the list we can say that they can be of any type and the same thing goes for our accumulator as well here let me show you one more alternate syntax so instead of writing list we can simply write a list like this and inside the list we can specify that this list can hold any kind of elements and again for the return type we can say that the return type is also list and this list can hold anything so we can specify any right over here and just for the sake of consistency let me convert this as well so let me put square brackets we don't need this and that's it for this video I'll catch you in the next one next let us see how we can implement the map function but first let me show you what do I mean to say so here let us see the documentation so I want to go to my model of enum and I want to see the documentation of map so as you can see over here so this map function this takes a list of elements and it also takes a function and what does it do for each iteration it simply applies this function to the element so for example we can see that the first element is 1 and this function is taking one and it is giving back 1 multiplied by two that's why we have the answer of 2 over here now we move to the next element the next element is 2 so 2 multiplied by 2 we get a 4 the next one is three three multiplied by 2 so we get a 6 right over here and we have one more example right over here so in this case this is a keyword list and what this function is doing it is pattern matching on the key envelope Paris and it is simply changing the value from a positive to a negative number so for the first iteration your key is the item of a and the value is is 1 and what this function is doing it is returning back a negative value so we have minus 1 right over here for the next iteration the key is the item of B and the value is 2 and here we are simply flipping the sign so that's why we get minus 2 right over here so let us see how we can implement this function by using our list so let us go back to our code editor and here let us create a new function called as map and let us see how we can implement this functionality so this function is going to accept three parameters the first is for our elements the second one is for the function and the third one is obviously our accumulator and also let us set the accumulator to be a blank list now before we can go ahead I wanted to show you one more thing all of these functions that we are defining inside the module so this function of sum of some simple sum of tail recursive reverse all of these functions are called as named functions and they're called name functions because all of these functions belong to a module and in our case the model is called as tutorials.list but in case for this function of map we are passing an anonymous function so this function does not belong to any module so let us see how we can work with our Anonymous functions as well so what we can do is either we can create an anonymous function right where we require or we can Define it separately as well so suppose we Define a function called as double and we can say that this is going to be a Anonymous function and this function accepts some element and it simply returns that element multiplied by 2 now remember the syntax the opening is by FN that stands for your function the end happens with your end block right over here now in order to use this function we have to use a DOT notation so in order to invoke this function we can say that we want to invoke the anonymous function of double but if we want to pass the value of 2 and as you can see we have to use the dot notation since this is an anonymous function so keeping this thing in mind let us go back to our code editor so let me scroll down to our functional definition and here it is so as usual first let us think about the base case so let me just copy and paste so the base case would be in case the elements are blank that means it's just a blank list at that time we simply want to return back the accumulator so we can say do and our accumulator now here what happens is we don't need this argument and we can do one more thing since we are not using the function we can ignore it by using an underscore so what this underscore means is we simply want to ignore the value of function in our base case next let us have a look at our recursive case so let me again copy and paste here as usual let me pattern match on our head and our tail the next is our function and since this is a tail recursive function we have to call ourselves back each time so first let me ignore the first value I will come to this a little later now the next argument is for the function in and for each iteration we simply have to pass the function as it is we don't have to do anything with it now the third is where we collect our accumulator now inside the accumulator what do we want to do is we simply want to take this function and we want to apply this function on our head now remember that since this is an anonymous function we can use the dot syntax so we can say here first we want to take the function and use the dots and tags and we want to apply this function on our head and we simply want to append our accumulator at the back now let us come to the first argument now since we have used the head the only thing left is to pass the pail and that's it let me save the file and let us open up our IEX let us go inside our IX and let me clear up everything and let us try it out so we can see tutorials dot list dot map and we can say that our map is 1 2 and 3 and the function that phone to pass is the same one let us take the element and for each element let us simply multiply by 2 don't forget the end and that's it and we get the answer back but as you can see the order is not right what has happened is we have reverse the list as well so this 3 is right over here so 3 multiplied by 2 it should be 6 but in our case 6 is the first element and 2 into 2 we have 4 over here and for the first element is one into two and we have 2 right over here but as you can see that this is not the right answer we have reversed the order of our elements as well so what we can do is first we can call our tutorials.list DOT reverse and inside this let us pass our map function let me just copy and paste it over here and now we can see that we have the right answer 2 4 and 6 but as you can see that this syntax can be confusing so let me introduce shows you the pipeline operator so let us paste the map function over here and we can see that we simply want to take the output of this map function and we want to pipe that output inside the new function and the new function is our tutorials dot list dot reverse now here we don't need to specify the arguments what happens is the pipeline operator since it takes the output of the previous statement and it simply passes that output inside our function as the first argument so let us press enter and let us see what's happening so as expected we get the right answer back 2 4 and 6. let me clear it up let us do some more so for example if you want to reverse the same list so we can invoke tutorials.list dot reverse and suppose in our case the list is one two three and four now instead of using this syntax what we can do is we can first take our our elements here we can use the pipe operator so we can say that I want you to take all of these elements and I want you to pass them to my tutorials dot list dot reverse so what happens is we can use this pipeline operator in case if we have multiple Transformations so let us use the same example one more time here let us create an anonymous function called as double and what we want to do is we simply want to take the element and we want to return that element multiplied by 2 and now let us see how we can use the pipeline operator so for example we have a list like this one two three and four and what we can do is we can take this elements and we can pipe this elements to our function of tutorials dot list dot map now remember that the function of map accepts two parameters elements and the function now here what happens is since we are using the pipeline operator this elements are passed automatically to the function of map and the pipeline operator always passes these elements as the first argument so since we have the first argument we simply have to pass the second argument so here we can say that we want to pass the anonymous function called as double and for the accumulator we don't have to pass any value because the default value for the accumulator is an empty list so let us see the output of this one so we get the output of 8 6 4 and 2. now what we can do is we can take the exact same expression and we can find the output of the map function to our reverse function so we can use tutorials.list dot reverse and this time we get the expected answer as 2 4 6 and 8. now instead of using the list dot reverse in fact we can use the inbuilt module so if we go to the model of enum so here we can say that we want to pipe the output into enum Dot reverse and we get the exact same answer back so instead of using our defined function we can use the inbuilt function as well so as you can see that this pipeline operator is very handy whenever we want to do multiple Transformations so let us go back to our function of map and what we want to do is this accumulator has to be piped to our function of reverse and that's it now if we open up our terminal let us recompile tutorials.list let us clear up everything and this time if I have a list of one two three and four and if I just type this list to tutorials.list dot map and let us pass an anonymous function so we can say let us take that element and let us multiply that element by 3 this time and that's it we get the right output back now again coming back to our code editor either you can use this pipeline operator or you can use the conversion syntax so you can simply call the function of remote first pass the element of accumulator and let me take out this one let us also see how to write the specifications for this function so let us use the model attribute of specifications for the function of map now the first parameter elements is going to be a list and the type can be of anything so anything goes over here the next is a function now in order to denote that this is a function we can use brackets over here and here we can say that this function accepts an input the input can be of any type then it transforms that value and it also gives back some kind of a value back so this is how we can Define the function type the next one is for the accumulator and again accumulator is going to be a list of any now the return type is also going to be our list of any well that's it for this one and I will catch you in the next video now let us see how we can concat or how we can add two lists together the so first let me show you inside the terminal so suppose we have one list like this one two and three and we want to add one more list now in order to add our concat we have to use the double plus and the next list would be 4 5 and 6. and here we get the combined list back so let us see how we can write a concat function to do exactly this now in order to add or concat we have two lists so for example the first list is one two and three and we have one more list four five and six so essentially what we want to do is we want to take the last element and we want to insert that last element at the head of the next list but taking the last element is not efficient because we have to Traverse through the entire list and then go to the last element so what we can do is we can simply reverse the first list so the first list becomes something like this 3 2 and 1 and for each iteration we simply have to take out the head and insert it at the head position for our list number two as well so for the first iteration we insert three for the next iteration we insert two and for the last one we insert one and and by the time we insert one this list becomes an empty list so this is how we are going to implement our concat function so let's define the function right over here so we can say Define concat now this function accepts two arguments we can call the first list as our source the second list can be our destination now for this function we don't need an accumulator the second list itself acts like an accumulator so here what I'm going to do is I am going to write an auxiliary function so first let us write the function and then we can Define it so we can simply call the auxiliary function as concat underscore function now remember as I just said a couple of minutes back first we have to reverse this list and we can do that right inside our function definition so here we can say that let us take the source list and we simply want to pipe it to our function of reverse the next is our destination list and we want our destination list as it is so now we can go ahead and Define this auxiliary function so here we can say that we want to create a function called as concat func this accepts two parameter the first list called as Source the second list called as destination now here as our base case we can simply pattern match on our source so in case the source is blank at that time we simply want to return back our destination the next let us see how we can Define the recursive case so we can say we want to Define concat one more time and here we can simply pattern match on the first list so for the first list we can pattern match on the head and for the tail the second parameter is for our destination list and let us see how we can Define the logic for this one now for each iteration we want to call ourselves back right here first let us Define the second parameter so for each relation what we want to do is we simply want to take the head and we want to append our destination list to this one now the last thing to do is we simply have to pass the tail for our first argument so let me open up my terminal let me go inside my IEX and let me clear up everything now here we can see that we want to go to tutorials dot list dot concat now the first list would be one two and three the second list would be 4 5 and 6 and that's it we get back in the desired output the last thing to do is we simply want to add our type specification so let me take out the command I don't need the comment and here we can use the model attribute of specifications for our function of concat the first parameter is a list and the elements are any the next parameter is also list and the elements are of any type and this gives back a list and the types are any next coming to our helper function of concat underscore func now this function is intended only for internal use so what we can do is we can Define the auxiliary function to be private so here instead of just writing def we can write Def and P that means that this is going to be a private function and that's it let's have a look at the last function inside our list and this function is called as flat map now to be frank I was slightly confused should I include this function in this series or not then I thought okay why not let me add this one and let us see how it goes so first let me show you what do I mean by a flat map so let us go back to our terminal and here let us see the documentation for our inner module and the flat map function so what this function does is it accepts an enum and it also accepts one function now flat map is all about the combination of your two functions that is it's a combination of your map and concat and here we have one more example as well so we get an input as a list so during the first iteration we get an item of a and we give back list of a and a but if you see right over here we don't have a list of a we don't have a separate list for B and we don't have a separate list of c and that's because we have flat and the entire list so let us see how we can do this by using our recursive functions now you must be thinking why are we implementing so many functions which are already there inside the standard Library so the answer is I want you to really get comfortable with the recursion and from the next video we will see how we can use all of the inbuilt modules but for this last one let us see how we can implement this functionality by using our tail recursive function so let us go back to our code editor and here let us create a function called as flat map so we can say Define my flat map so this function accepts two parameters so if you go back to the documentation we can see that this accepts two parameters the first argument is for the elements the second argument is for the function so let us do the same thing here we can say that the first argument is for the elements the second argument is for a function now we also need one more argument for our accumulator because what we want to do is we want to collect the output inside our accumulator so here we can say that we also want to have an accumulator and we want to have the default value of an empty list as well now let me copy and paste now let us think of our base case so the base case is very simple in case the elements is a bank list at that time we don't need this function so either you can put an underscore over here or you can simply replace the entire function with just an underscore both of them are valid syntax and in this case we simply want to return back the accumulator as it is now let us copy and paste one more time and this is going to be our recursive case now in this case we need our function as well and for the first argument let us pattern match on our head and our tail and for each iteration we want to call ourselves back so let us call the flat map back now as you know the first argument should be our tail because for each iteration we want to take out the head so the first argument becomes the tail the second argument is we want to pass the function as it is we don't want to change the function now let us see what we can pass as our third argument now if you go back to our documentation it is clearly saying that this is a combination of our map and concat so let's not use our brain and let's follow exactly what these guys are seeing so here what we want to do is we simply want to concat and the first argument for our contact function is going to be our accumulator and for the second function we want to apply this Anonymous function on the head now remember since function is an anonymous function we can invoke it by using the dot operator so we can say function Dot and let us pass head to this one and that's it we have implemented the flat map function now let me open up my terminal let us recompile the model of tutorials dot list let me clear up the screen and let's do one thing let us go over here and let me copy all of these things now here inside our terminal we can say that from tutorials dot list dot flat map and it has passed arguments and now let us try and compare the output so here we have the output which is exactly the same as right over here so that brings us to the end of this section for the list now what we have done for this section is we have implemented a lot of functions from the standard Library by using field recursion from the next video instead of writing all of these functions by hand we will try and use the functions from the standard library but for now that's it and I will catch you in the next one hi and congratulations for making it so far so till now we have seen a lot of recursion specifically we have seen a lot of tail regression now the whole idea of showing you so much of Education was I wanted you to get used to the idea of recursion and how we can use functional programming but moving forward instead of writing all of the functions ourselves we will use the functions from the standard library now Alexa ships with a lot of inbuilt functions and you can find these functions inside modules such as enum then we have separate model for your list and keyword list and so on so that's what we will see so the next section is all about your data Transformations how we can use all of these functions and how we can browse some data to get our desired outputs so I will catch you right in the next video till then bye now let us see how we can start working with our struts and the inbuilt modules so the first thing which I want to do is let us create a new folder inside our lib and we can call that folder as structs and inside of this folder let me create one more file by the name of Seven Wonders let me collapse my sidebar and let us see what we can do with this struct the first thing as usual we need to Define our module so this would be our tutorials Dot structs.7 vendors so let us create a struct by using the keyword of Dev struct here we need to specify the fields for our struct so we can say that the first field would be the name of the Seven Wonders and the second field would be the country of that seven Wonder now we can do one slight Improvement we can also initialize the values right over here and instead of just passing a normal list we can pass a keyword list so here we can say that the default value of name should be a blank string and the same thing happens for the country as well so in case the argument is not given we want to initialize the country to be a blank string now let us see how we can also Define the type specifications for our struct now for defining the type of our struct we have to use the keyword of type so let's define a typewrite over here and let us call type as T so this is more like your community attention your T stands just for your type and here we can specify that we want to specify that 5 for our tutorials dot structs dot Seven Wonders now remember that this track always takes the name of the module and in this case the name of our module is tutorials.structs.7 vendors so by default that's going to be the name of our struct and since this is a struct let us use the right syntax so we need to put our percent symbol over here and our curly brackets so now we have a struct now what we can do is typing such a long name can be boring so we can simply Alias this so let's create an alias at the top so we can say we simply want to create an alias and here we can simply take out all of these things now inside the curly brackets let us Define the pipes for the various Fields so the first field inside our struct of 7 Wonders is for the name and here we can Define the type to be of string so we can say string dot P so the type of string the next one we have for the country and again the country is going to be of the type of string so this is how you define the type specifications for your struct next let us do one more thing Let Us create a list of all of the seven vendors so for this let us create a simple function called let's all so this function does not take anything and this returns your list now inside this list let us initialize all of the Seven Wonders so we can say that the first seven Wonder would be Taj Mahal so since I am from India the first one has to be Taj Mahal and we can say the country is going to be India and let me just copy and paste all of the remaining six wonders so now we have a nice list of all of the Seven Wonders of the World next let us see how we can also write the type specifications for this new function so here we can use the model attribute of our specification things and we want to define the specifications for the function of all now since this function does not accept any parameters you can use the brackets or you can skip them and here we can also Define the return type now the return type is a list and the elements are of the type of P so right over here we have defined the type of T and we have specified the different parameters for our struct and that's what we are referencing right over here let me put a separator line over here let's scroll a little bit down and let us see how we can start working with our Seven Wonders so here let us do one thing let us Define a function called as print names so what this function will do is it will accept all of the vendors and it will simply print out the names of the vendors so for example if we see we have different names so we have the Taj Mahal Petra price the Redeemer and so on so what I want you to do for this function is so this function is going to accept this list right over here and for the output which just want to see the names and that's it so let us see how we can implement this function now this time instead of writing functions of a self let us see how we can use the standard Library so let me open up my terminal and here the first model that you would like to check is the model of enum so what I can do is let us call help and let us see what are the different functions inside the module of enum so if I put a dot and if I press Tab and we can see that this inbuilt module has a lot of inbuilt functions now I want to see the documentation of a very specific function and that is this one for each so here let me call the help on enum.h so this function of each accepts two parameters the first parameter is for an enum and the second one is for the function and we also have a sample implementation so here we can see that the first parameter is a list and we have a simple function so what's happening is for each iteration this function receives an element from the list so for the first iteration your X is the string of sum and what this function is doing it is simply printing it out that's why we have the output of sum for the second iteration your X becomes example and that is what is being printed out right over here so let us see how we can use this inbuilt function for printing out all of the names for our Seven Wonders so let us go back to our code editor and here what we can do is we can use the same function we can say enum dot each now our enum is going to be our list of our wonders next let us Define our function and for the function for each iteration we are going to receive one Wonder from our list of vendors so for each iteration what's going to happen is we are going to receive a wonder and we have to do something with the Wonder and this is the end block for our function now since we just want to print the name of our Wonder we can actually pattern match right over here now we know that this vendor is going to be thus extract of Seven Wonders and we can easily patent match on our structs by using our map syntax so let's do the pattern match right over here so here we can say that for each iteration we want to pattern match and we want to pattern match on the parameter of name and we want to collect the name inside a variable called as name and for each iteration we simply want to print it out and let us put the variable of name right here and that's it let us open up our terminal let me go inside my IX now let me create an alias for our tutorials not structs DOT 7 vendors let me clear up everything and here we can say that the list of all our vendors is our Seven Wonders and remember we have defined a function of all so now we have all of the vendors let me clear up one more time and next what we can do is we can again use the same model of seven vendors and let us print out the names so this function takes one argument and that is the list of all our wonders and that's it now we can see that we have the right output and we get back just the names of all of our seven vendors let us go back to the code editor and let us also Define the type specification for this function so here we can say that the specifications for our function of print names so the first argument is the list of all of our vendors so we can say that this is a list and the type is the type of key that we have defined now since this function is not returning anything we can say that this simply returns an item of okay also if you want you can also use the pipeline operator so what I can do let me take this one out let me put it on this line and on the next line let me use the pipeline operator so by default our list of vendors is being passed as the first argument for the function of enum dot each let me save this one let me open up my terminal let me again recompile everything let us try to run the same function one more time and as expected we get the right answer back next let us see how we can filter a single seven vendor from our list so here let us create a new function and let me name the function as filter by country now this function will accept two parameters the first parameter is obviously the list of all our vendors and the second one is the name of our country for which we want to filter for so for example if the country is India then we should get back this single seven Wonder so let us see how we can implement this filter function here let me add my do and end blocks and let me take this a little up so again let us go back to our terminal and let us see if we can find a filter function inside our standard Library so again let me call the helper documentation from our model of enum and let us see if this model has a function of filter or not so here it is we have a function of filter so let us see the documentation of this function so this function of filter this accepts two different parameters the first is obviously our enum and second parameter is going to be a function and here we have a sample implementation so as we can see the first element is a list and the second argument is going to be a function now if we read the documentation it is saying that this function returns only those elements for which your function returns a truth value so let's see what's happening inside this example so here they have a condition and whenever this condition evaluates to True only that value is returned so here we have a list of 1 2 and 3 and this condition is only satisfied for the element of 2 and that's why we get back a list along with a single element of 2. so let's see how we can use this inbuilt function for filtering by the name of our country so here we can take the list of our vendors and then we can pipe this argument to our enum dot filter now again by default the first argument of Wonders would be passed and we simply need to pass the second argument for our function this function receives a wonderful each iteration so this is how it's going to look like and here we need to specify a condition that will evaluate toward true so here what we can do is we can again pattern match on this struct of seven vendors so let's do that thing and this time we simply want to extract the name of the country so let us pattern match on the field of country and let us collect the data inside a variable called as country name now next coming to our truth condition here we can say that we want to filter it out only when the country name is equal to the name of the country so this parameter country is what is being passed to our function right over here and this parameter of country name is what we are extracting by using our pattern match right over here so let me save the file let us open up our terminal and let us recompile the model of Seven Wonders next what we can do is we can say we want to use Seven Wonders dot filter by country let us pass all of the Wonders and next let us pass India and let us see what output we are getting and as expected we can see that we are getting the right answer back let us try one more time and let us try with Mexico and again we are getting the right answer back so again let us go back right over here and let us write the type specifications so the specifications for our filter by country the first argument is the list of the type of seven vendors the second argument is of the type of string and the return type is the list and this contains a single type well that's it for this video in the next video we will continue with the different functions on our structs so let us continue with our structs and behind the scenes what I've done is I have added a couple of functions and let us see how we can Implement all of these functions so the first function that you can see over here so this function is also about filtering and we simply want to filter out the seven wonders for which the countries start with I so let us see how we can do this one let me copy this one and let me paste it right over here let me take all of these things a little up so in this case our truth function will change and we simply want to compare the values and check if the name of the country starts with I or not so let me take this one out and this time we can rename the variable from country name to just country and let us see how we can compare the first alphabet of our string with i for this let us use another module and the name of the module is going to be string and this model has a very convenient function of starts with now if I hover over the function definition we can see that this function accepts two different parameters so they have one example over here Alexa and Eli so in this case Elixir starts with Eli that's why we get the answer as true so the first argument would be our country and the second argument would be I so let me open up the terminal again let me recompile our model of Seven Wonders let me clear up everything now let's invoke the function so we can say Seven Wonders dot countries which start with i and let us pass all of the Wonders to this one and as expected we get two wonders back so the first one is Made in India the second one is made in Italy the next function is sort by country length oh before moving on let us also add in the type specifications for this one so the specifications are pretty simple this one does is the list of our type of T and this also returns a list of type of T all right so now let us go to this sort function so this time what we want to do is we simply want to sort all of the Wonders by the length of the country name so let us see how we can do this one so if I go back to my terminal and let's check out for enum dot sort so we have a convenient function of sort inside the model of enum and as you can see it has a lot of documentation but I wanted to show you a couple of key parameters so this is the function of sort and this function accepts to parameter the first is the enum and the second one is unsorter now this sorter argument can be of multiple types so let us refer to the official specifications for this function and let us try and figure it out so the first is obviously your elements and now for the second argument of sort we can see that we can pass a multiple of arguments so what this specification is saying that either we can pass a function and this function receives two elements and this function has to written back a Boolean value or you can choose to pass this arguments as well now let us see how we can work with this one so this is a pretty simple function that we can pass to our enum dot sort so let us go back to our code editor let us again use the arguments of Wonder and let us pipe this one to our enum dot sort now here let us see how we can Define the sorter function so this is going to be your regular function now for each iteration this function is going to receive two different vendors so we can call them as X and Y and next for the body of the function we can simply say that we want to check for the length of the string for the first one and let's compare if this length is less than the length of the next Wonder so again we can use the same function string dot length and let us pass the variable of Y this time so what we have done is we have defined a function and for each iteration this function receives two different vendors and we are simply trying to compare the length of this wonders and that's it so let me save the file let me open up my terminal and let me again recompile the module let's try to Inver this function Seven Wonders dot sort by country length and let us pass all of our vendors oh we are getting an error and that's because here we are trying to find the length of the entire struct I forgot to specify the parameter that we want to check for the length of the name of the country the same thing goes for this struct as well so we want to check for the length of this country now let me save the file open up my terminal let me recompile one more time clear up the screen and let us try to invoke this function one more time so this time as you can see we have a nice sorted list so as you can see now the list is sorted according to the length of the country name so Peru this is four characters long so this is the first one next is China this is five characters again then we have Italy and India then we have Brazil and so on so as you can see we have a nicely sorted list so now let us go back and let us see what we want to do for the next one so for the next function of name country list so this function accepts our vendors and I want an output like this so the output has to be the list and inside the list we want another list the first element has to be the name of the seven wonder and the second name has to be the country so let us see how we can do this one so let me take out the comment I don't need the comments and before I show this one let me take you back to my terminal and let me clear up all of these things and this time let us check out the documentation for enum dot reduce now this function of reduce this is a very powerful function and in fact you can Implement all of the function inside the model of enum by just using this simple function so first let us see the function signature so this function of reduce accepts three parameters the first argument is for your enum the second argument is for accumulator and the third argument is for your function and we have one sample example right over here so the first argument is a list the second argument is for the accumulator and the third argument that you can see over here this is for a function now this function receives an element for each iteration and this function also receives the accumulator so for the first iteration since the accumulator is 0 this would be 0 and for the first iteration our X would be 1. now what happens with this function is that the result is passed as the accumulator for the next iteration so you can read the documentation over here so this is what is happening so for the second iteration whatever this evaluates to so this value will become your new accumulator so let us see this reduce function in action so let us go back to our code editor now let us see how we can work with our reduce function so we can say enum dot reduce the first argument is for our vendors the second argument is going to be our accumulator so as our initial accumulator let us just pass an empty list and the third one is going to be a function now let me do one thing let me take this one out and let us pipe into our enum dot reduce now for each iteration this function is going to receive two parameters the first parameter is going to be our vendor and the second parameter is going to be our accumulator so initially the accumulator is going to be a blank list and for each iteration what we want to do we simply want to create a list inside this list we need another list and inside this inner list the first argument would be the name of the vendor and second one would be the country of the Wonder so here we can say that from Wonder I simply want you to take the name and the second argument is going to be the country for this one and after this we simply want to append our accumulator back and that's it let me save my file let me open up my terminal let me recompile the module and let me clear up the screen let us invoke this function so we can say Seven Wonders dot name country list and let us pass all of the Wonders and as expected we get the answer back so here we can see the first argument is going to be the name of the Wonder followed by the name of the country now just to give you some more practice let us try and use this reduce function one more time so for this function right we are country name keyword list so this is what I want you to do so this function is going to accept our vendors and this is the output that I'm expecting so we want to have a list and inside the list we want to create our keyword list so as you can see this is going to be an atom and this is going to be the value so let me just copy all of these things let me copy this one and let me paste it right over here I don't need the comment let me take it out and let us see how we can work with this function now here what I want to do is we don't want an inner list instead what we want is a tuple so let me change this from a list to a tuple so let me explain why do I want a tuple so let me open up my terminal so for example if we have a keyword list like this a and one so this keyword list is actually saved as a list of our tuples so in case if I have to pattern match so on the left hand side let us create one more list and here if I create a tuple the first element is going to be the item of a the second element is going to be the value of 1. so let us see if this is a pattern match or not so yes this is a pattern match so what's happening is this keyword list is saved in this format I think I have covered this while explaining keyword list as well so this is a small recap for you so this is the same logic that we are using over here so that's why we want to have a tuple and not an inner list now the first element has to be an atom so what I can do is let me grab this inside and we can convert this string to an atom by using our string dot to atom and that's it now let me open up my terminal again let us recompile our module and let me clear up the screen and let us try to invoke this functions Seven Wonders dot country name keyword list and let us pass the arguments of all vendors so the system as you can see that the first argument is going to be our atom and the value is going to be the name of the country now before going to the last function I wanted to show you a couple of things so again let me open up my terminal let me clear up all of those things so in case if you want to make a list of just the names of the Wonders we can use multiple modules so let me show you one more alternate method so we can say enum dot map and the first argument is going to be our argument of all of our vendors and what we can do is we can simply invoke a function so this function receives a Wonder each time and what we want to do is we simply want to return the name of the Wonder and we get back a list of all of the names now what we can do is Alexa actually offers a shorthand syntax so what we can do is we can change this function to a short and syntax so we can say that we want to send a reference to an anonymous function and this function is going to receive a parameter so we can say for the first parameter we simply want to return the name back and that's it so this is the shorthand syntax and we get the exact same answer attack so if you are comfortable you can use the short and syntax or else you can use the regular syntax now for the last part of this video I wanted to show you the four comprehensions inside Elixir we can get the exact same output by using the four comprehensions so we can say four and here we can say that for each iteration we simply want to pattern match and we want to extract the name inside the variable of name and we want to extract this from our list of all of the vendors and for each iteration I simply want to return back the name of the Wonder and that's it we get back the exact same result now this syntax is slightly weird so what we are trying to do is we are trying to say that for each element out of this enum we want to pattern match and we want to pattern match on name and for each iteration we simply want to return the name back so you can use any of the syntax with which you feel more comfortable now let me just copy this one and let me go back to my code editor so for this one let us use the for comprehension let me paste it right over here we also need to pass an argument to the function so this argument becomes for our vendors and this also has to change to wonders now let me open up my terminal let me recompile the module and let me clear up this one and let us try to run this one so Seven Wonders dot all names oh I forgot to pass the arguments so all names and the argument is all wonders and we get back the exact same answer well that's it for this video and I will catch you in the next one let us have some more practice with our struts so what I've done is behind the scenes I've created a new file called as expense and let us get started with this one so first as usual let us create our module and let me call this module as tutorials.structs dot expense now just imagine that we are creating an application to manage our expenses so let us Define a struct to hold our expenses so we can say that we want to define a struct and since this struct is going to have multiple Fields let me take them on different lines so the first field would be for the title of our expense and we can initialize the title to be a blank string the second one would be the date of our expense initially we can keep it as nil the next one would be the amount of our expense and let us initialize the amount to be 0 the next one can be the store from which we did the purchase and let us initialize the store to be also a blank string now let us also Define the types for our struct so first let me create an alias so I want to create an alias for my tutorials dot structs dot expense and here let us Define the type for this one so we can say that type of t for our struct of our expense the first field for title so this is going to be of the type of string the second one is date for this we can specify that the type is going to be of the type of date or it can also be nil the next one is for our amount so this is going to be a number and next one is for the store this is going to be of the type of string so now we have the type specification in place now let us see how we can work with our expense struct first let me create a couple of sample expenses so let me Define so let me Define a function called as sample so this function will simply return a couple of our expenses let us create an expense right over here so we can say that we want to create an expense now for the title we can say that we got some grocery the next field is for the date now the type of this has to be a date so for this let me go to my terminal and here let me show you how we can create a date so Elixir has a model for date so we can use that module so let me show you so let us check the documentation for that module so we can say we want to see the helper documentation of date dot new so as you can see this function of new this accepts a year month and day so let us try this one so let me clear up everything so here we can create a new date so we can say date dot new the first argument was for the year so we can say 2023 the next argument was for the month so we can say for April and for the day we can say the 1st of April and that's it we get back a date but as you can see we get back a couple back so let us pattern match and let us extract the date so what we can do is just on the left hand side let me pattern match so the first element would be the item of okay and let us create a variable for the date and let us just check out the contents update so that's it we have a new date now the syntax that you can see over here this Sigel and D this also denotes a date and in fact we can use this syntax to create a new date we don't have to always invoke the function of date dot new so what we can do is we can create a Sigil so this is the sign for sigil and let us create a schedule for our date and here we can say that the year has to be 2023 the month can be March and the date can be 31st of March and that's it we have a new date in place so now let us go back to the struct and let us create a date right over here so let me use the sigil over here so I can say I want to create a date and suppose my year is 2023 my month can be September and suppose the date is 12th of September next is the amount suppose the amount is 18.99 and let's say the store is going to be Metro so now we have created an expense now let me just copy and paste a bunch of more expenses so that's it let me open up my terminal and let me clear up all of these things let us go inside the IEX and let me create an alias for of my tutorials dot structs dot expense and let me clear this one more time let us create a variable for our sample expenses so we can say that my sample expenses is equal to my expenses dot the function of sample so now we have a bunch of samples so now let us go back to the code editor and let us see what we can do with our expenses oh before that let us add the type specifications for this one so here we can specify that the specifications for our sample so this does not accept anything and this returns a list of the type of T that we have just defined next let us write a function to get the total amount that we have spent so we can say that the function is going to be our total and this function accepts our expenses and let's define the body of this function so this expenses would be the list of all our expenses for example if we get this expenses then we simply want to add all of the amounts together and we want to give back the total amount so let us see how we can do this one let me take all of these things a little up now you can solve this by using multiple methods but I'm going to use the enum dot reduce so first let me take the expenses and let me pipe the expenses into enum dot reduce now for this function of reduce let us Define an accumulator so let's say that my initial accumulator is 0 the next one comes the function now for each iteration this function receives two parameter the first is going to be the expense the second is going to be the accumulator and for each iteration I simply want to go to my expense take the amount and add add that amount to my accumulator so that's it now let us go back to our terminal let us recompile our expense let me clear up everything and now let us invoke this function so we can say expense dot let us get the total for our sample and that's it we get the answer as 1025.62 let us go back and let us also write the type specifications for this one so this function of total this accepts a list of the type of T and this returns a number so if you hover our number you can see that your number can either be an integer or a float next let us write a function to sort our expenses by the date so we can say that we want to define a function and this function accepts our list of expenses and now let us see how we can sort our list so in the last video we have seen how to sort a list but this time we want to sort by date so let me take you back to my terminal so let us see the documentation for our enum dot sort so last time we had used sort but we have one more function by the name of salt and buy now let us see the documentation for this one let me slightly scroll up and here they have an example in which they are using date so for example they have a list of different maps and each of the map has a field for the date and this is how they are sorting the date so the first argument is obviously your enum for the second argument they are using a shortened syntax you can use your regular function and what they are trying to say is for each iteration they want to sort by the birthday so let us use this shorthand syntax and let us see how we can sort our date so here we can say that first let me take all of my expenses then let me pipe all of these things into my enum dot sort by and let us use the shorthand syntax so we can say I want to give a reference to an anonymous function and for each iteration I want to sort by the date let us open up our terminal let us recompile our expense let me clear out the screen and here we can say dot expense dot sort by date and let us pass the list of our samples and let us see what's happening so here you can see that the dates are sorted the last one is for 30th of October the earlier one is 18th of October so this one is for September and this one is for July so we have a nicely sorted list in ascending order in case if you want to change the order you can refer the documentation so yeah they are saying that in case if you want descending then you can add this parameters as well let us go back let us write this specifications for this one so sort by date so this accepts the list of the type of p and this also Returns the same list of the type of t next let us see how we can add an expense to our list of expenses so let's define a function called as ADD expense so this accepts one single expense and let us write the body of our function now this is going to be a very simple function so we simply have to take the expense and we simply want to append this expense to our existing list of samples now for this one I wanted to show you one small trick so in case if you want to enforce that this expense has to be of the type of the struct of expense then what we can do is we can simply use a pattern match right over here so here we can say that we want to have a pattern match for our struct of expense so essentially what we are doing is we want to enforce that the type of this parameter has to be of the type of our struct let us also add the specifications for this one so we can say that our ad expense this accepts the type of T and this Returns the list and the list has of the type of t as well now let me open up my terminal let us also recompile the model for our expense let me clear up everything now first let me create an expense so let us create a variable for our expense and let us initialize our struct so here we want to say that our expense suppose we want to buy some coffee and let's say the date would be for the first of April so we can use the sigil and we can say we want to schedule for the date and the date is going to be 2023 the month is April the date is the 1st of April let's say the amount for this one is going to be 10 and let's say we buy this from Metro so now we have one expense with us now let us try adding this expense so we can say expense dot add our expense and let us pass the newly created expense and we get back an answer so let us see if we have coffee in this list or not so yes as we can see the first item is the coffee so we have added our expense inside the list so let us go back and let us see what else we can do next let us see how we can update a single entry inside our list of expenses so for example let's see how we can update an amount for a particular expense so let us create a function and let us call the function as update amount now this function will take two parameters the first parameter is the title for our expense and the second can be the amount so the updated amount and let us see how we can write the body for this one so for example what I want to do is suppose we are buying Grocery and we want to update the amount from 18.99 to say 20 dollars so let's see how we can do that so for updating the amount we have to do a couple of things so the first thing is we need to filter out the expense that we want to update the second step is we want to create a new expense with the updated amount because remember all of the data types in Elixir are immutable the third is we simply want to add this expense to our samples and we want to take out the old entry so let us see how we can do these things so the first step is to filter the exact expense with the given title so we can say we want to use enum.filter the first argument would be for our sample expenses so we can just pass the function of sample over here next we have to define a function right over here so let me use the function and end and for each iteration this function receives one single expense so let us pattern match on the expense title so here we can say that we want to extract the title and we want to capture the title in a new variable and let us name the variable as expand title and for each iteration we simply have to check if the expense title is equal to the given title so this title comes from the functional definition which is right over here and we also need to capture this expense so if you just hover on filter so here we can see that the result is a list so let us pattern match and let us extract that expense so on the left let us pattern match over here and let us create a new list and let us create a variable called as item so this item will hold the expense that we have just filtered the next step is to create a new expense so we can say that we want to create a variable for the new item and let us create a new expense by updating this item so we can say for my struct of item I want to update the amount by the new amount so this amount comes from the function definition right over here so now we have the new amount the last thing is we simply have to append the new item to our list of samples but before we can append we also need to remove the old item from our list of samples but we can do all of these things in one place in a single statement so let me show you how we can do this so here we can say that we want to append the new item to our list of our samples but before we can append we also need to remove the old entry so what we can do is we can simply take the output of sample and pipe this into a new function and we can say list dot delete and let me pass the old item to this function and that's it so what's going to happen is first we are going to remove the entry from the list of samples and after that the new item is going to be appended now let me open up the terminal and as usual let us again recompile our expense let me clear up the screen and let us try to invoke this function expense dot update amount now for example we want to update the amount of our grocery from 18.9 99 to say thirty dollars and let us check if we have updated the amount or not so yes so this is the entry for grocery and the new amount is 30. so let us go back so till now we have seen a lot of different ways in which we can work with our structs we have seen how to work with recursion and we have also seen how to work with the inbuilt modules now for the last thing in this video I wanted to show you the with statements so for example what happens we may have to deal with multiple conditions so for example you are writing a web application and you want to have the function ID for login now in order to login a user we have to satisfy a multiple of different conditions for example first we need to authenticate and then we also need to verify the password and so on so basically what we want to do is in order to log in we have to satisfy multiple of conditions and you can satisfy multiple conditions by using the with syntax so let me show you first and it will be easy for you to understand so the first thing is let us create a dummy database for our users and we can do that by writing our own custom model attributes so here we can say that we want to define a model attribute by the name of users and let us assign a list of different users so what we have done is so this is a model attribute and we have assigned a list of different uses for this model attribute so what happens is we can use this users as a constant throughout our module next let us write some dummy functions to authenticate and verify password so here I can say that I want to define a function to authenticate and this function will accept a user and here what we can do is we can use something which is called as a function guard so here we can say that when the user is in my list of our users only at that time I want to return a tuple and the first element would be ok and the message would be authorized so this syntax that you can see over here the is called as guards so in Elixir we can use different kinds of guards so you will understand guards as and when you learn more of Elixir but for now let us just go with the flow next let us create one more functional definition for our authenticate so in case we don't have the user inside our database so at that time we want to return a tuple the first element would be error and we can send back a message called as unauthorized next let us create some dummy functions for verify password as well so you can say we want to Define verify password now this function will accept two parameters the first is going to be the user and the second is going to be the password and here also we can use the function guard so we can say in case the user is inside our database of users only at that time I want to return back at Apple the first element is going to be okay and then we can pass the message as password verified now in case the username and the password does not match so for this one let us create one more Clause so this I don't need a guard for this one and this has to be error and let us pass the message as wrong password and this case since we're not doing anything with the password let me use an underscore and here also we are not doing anything with the user and the password okay so now we have the basic framework in place now let us create a function for login so we can say Define login now this function accepts the user and also a password now let me take all of these things a little up now in order to log in a user we have to satisfy a couple of different conditions the first condition is first we have to authenticate and then we also have to verify the password so let us see how we can use the with syntax so first let me write the width block over here so with do and we can also write the else block over here now let's see how we can Define the body of our width so in order to log in first we need to authenticate and we also need to verify at the same time now here let us call the function of authenticate and let us pass the user now we have to say that we have to satisfy this condition and we can specify that by using an arrow syntax over here and we can specify that in case we get a specific output only then the user can be authenticated and here we can specify that in case the first element is the atom of ok and then we get some kind of a message back only in that case the user would be authenticated now this is the first case of authenticate but we also need to check if we can verify the password or not so here let us call the function of verify password let us pass the user and let us also pass the password now we can say that this function of verify password also has to satisfy a couple of different conditions so let me just copy this one from here and let me paste it right over here so in case this function also succeeds and we get back at Apple with OK and suppose the second one is for the message message let me put an underscore over here since we are not doing anything with the variable so now what we are trying to do is we are trying to check for two different conditions authenticate and verify and in case we satisfy both of these functions then we can say that we want to return back a message so the first would be the item of ok and then let's create a string so we can say the user logged in successfully but in case the function of authenticate or verify password fails so in that case we'll go to the else block now here we can pattern match on multiple conditions in case we get a tuple back and the first element is the item of error the second could be some kind of a message so at that time we simply want to return back the same thing so we want to return back the Tuple of error and the message back but in case we get some other error so we can specify that by using the underscore so in all other cases we simply want to return back and atom saying that this is an unauthorized operation or I forgot to put a comma over here so this is how your width block looks like so let me open up my terminal and let us see this thing in action so let me recompile my model of expense let me clear the screen and here we can say that from expense Dot Login and first let us pass a user which is there inside our database for example we have the user of Lewis inside our database so let us pause the argument of Lewis and for the password it does not matter because we are not doing anything with the password and let us see what kind of output we are getting so yes we get back the message saying that Lewis logged in successfully let's try this one more time with the user who does not exist so let me change the spelling and this time we get back the message as error unauthorized so this was all about using the width syntax with our Elixir well that's it for this video and I will catch you in the next one hi and welcome to the last section of our entire series now this last part or the last section is all all about building a statistics library in elixir now don't worry about the word or statistics there is nothing big about statistics as long as you know your basic mathematics like addition subtraction Division and so on you would be absolutely fine you don't have to worry now I also wanted to discuss about a couple of things regarding functional programming my first question is do you have a hard time understanding functional programming if your answer is yes then don't worry you are on the right track now what I mean to say is our brains are so much used to the the object oriented programming paradigms or the imperative programming paradigms that it takes some time for you to understand about your data immutability and recursion so don't worry the only thing that you need is more practice and the intent behind creating one more project is to give you more practice isn't it so don't worry and this is going to be a very nice project I will show you how we can slightly architect our code in a much better way how we can create a different public API how we can separate our in our internal implementation from the public API and so on so overall this is going to be a very nice project so hang on with me and I will catch you right in the next video till then bye so let's get started with our statistics project but before that I would like you to meet my friend Luis now Lewis stays in Toronto and he owns a Candies store and Lewis is going to help us to learn more about statistics the first topic that we want to learn is called as central tendency so central tendency is like a big chapter but don't worry I will make it very simple for you the first thing that we want to study is how we can calculate a mean now mean is nothing it's just a glorified word for average so let us try and study a little bit more about this Concepts now since Lewis stays in Toronto Lewis wants to count the number of cars in Toronto so this kind of data is called as your population data now this kind of data is called as population because our entire scope of data is just Toronto right we only want to count the number of cars which are there in Toronto so this number of cars is going to be a finite number and our scope or our range of data is limited just to Toronto that's why this kind of data is called as your population data now let us see next what's going to happen so next Lewis wants to count the number of cars in Toronto but this time the data is different Lewis wants to count the number of cars in Toronto out of all of the cars in Canada so this time what is happening is the number of cars in Toronto becomes your sample data now the reason why this data becomes sample data is we are taking a small subset of cars in Toronto from a bigger set of data which is all of the cars in Canada so all of the cars in Canada is your population and since we are taking a small subset of cars just in Toronto that's why this kind of data becomes your sample data so let us have a look at one more example for example Lewis wants to calculate the average height of people in his house so for example if there are four people staying in his house then that data becomes the population data now what's happening in this case is the number of people are just limited to the house of Lewis and that's why the data is your population data and we are trying to calculate the average height that's why we simply have to calculate the population mean for this kind of data the next is Lewis wants to calculate the average height of people in Toronto out of all of the people in Canada now what's happening in this case all of the people in Canada this data is your population data and what we are targeting is we are targeting just the people who stay in Toronto so this data is your sample data that's why this average is going to be your sample mean right let's have a look at one more example now Lewis owns a candy store in Toronto and Lois wants to calculate the average number of candies sold in three hours now what kind of a data would this be would this be a population data or would this be a sample data the answer is this is going to be a population data because our scope is just limited to three hours and since this is a population data we would be calculating the population mean so for example this other different candies which are sold by Lewis in the first hour Lewis could sell 10 candies for the second hour Lewis sold 20 candies and for the third hour Lewis sold 30 candies so let us see how we can calculate the mean for this kind of data so we have to just add all of the candies together so that's what we are doing right over here and then we simply have to divide by three so we get the answer as 20 candies for an hour that means Lewis was able to sell on an average 20 candidates per hour for the first three hours now let us have a look at one more example now this time Lewis wants to calculate the average candidates sold in the first three hours out of the entire day now in this case the full day would be your population data and since we are just limited to the first three hours out of the full day that means this is going to be our sample data which means we have to calculate the sample mean now these are the different candies which are sold by Lewis throughout eight hours in the day so for the first hour he sold 10 candies for the second hour 20 candies for the third hour 30 candies and so on so let us see how we can calculate the mean in this case so again everything Remains the Same for the first three hours we have the same figures so 10 candies for the first hour 20 for the second 30 for the next so that's why we have 10 plus 20 plus 30 and the number of hours for which we are calculating is three that's why we have three over here and again this evaluates to 20 that means for the first three hours in the entire day Lewis was able to sell 20 candies in an hour so you can see that the formula for the mean Remains the Same so what's the difference the difference is in perspective sample data is different and population data is different so keep this perspective in your mind and let us see how we can code this population and Sample mean right in the next video let us get started with our statistics project so let me open up my terminal and let's create a new mix project so let me go inside my folder of functional programming with Elixir and then let me go inside my folder of code and right over here I want to create a new project so I can say mix new stats and let me open up the folder in a new window so this is going to be our new statistics project so let us see how we can Implement our population and Sample mean functionality so the first thing is inside the folder of lib let me create a new folder and let me call that folder as central tendency now inside this folder let us create another file so let me create a file and this is going to be for calculating our population and Sample mean let me collapse my sidebar and first let us Define a module so this is going to be stats dot central tendency dot mean so here first let us see how we can calculate our population mean now the formula for calculating the population mean is very simple we simply have to take the sum and we have to divide that sum with our count now in terms of statistics this sum is also called as Sigma so let us see how we can calculate our population mean first so let's define a function called as population mean this function accepts a list of our numbers so we can call the argument as numbers and let us see how we can Define the body for this function but before we can Define the body here we need to do a lot of validation the first validation that we need to do is we need to check if this numbers is actually a list or not so for this we are going to use a guard so let us go to the official documentation and let us try and see if we can find the Right Guard or not so inside the model of Kernel we have a section for guards so let us check if we can find the guard for list or not so if I scroll a little bit down here we have one God and this guard is right over here is list so let us see how you can use this guard in our function so here what we can say that we want to have a guard saying that is list and let us pass the variable of numbers so basically what we want to do is we want to run this function only when this numbers is a list now we have validated that this numbers is a list but what happens if this numbers is not a list or in case the numbers is an empty list so let's define one more function overload on the top so here we can Define that we want to define the same function population mean and in case if we get a blank list then at that time written back a blank list now we can either written back a blank list or we can also written some kind of an error so for example if you want to return some kind of an error so we can return back at Apple and we can say that this is going to be an error and we can also return back a message saying that invalid data type so it's up to you if you want you can get return back a blank list or you can return back an error table so this is just for your reference so now let us see how we can Define the actual body for our population mean so here we need to do two things first we need to find out the sum or the sigma and then we have to divide by the count but before we do all of these things we need to do one more validation so till now what we have validated is that this numbers is just a list but we also need to validate that this is a list of numbers so let us see how we can validate this one so here let us create a pipeline so here we can say that first I want you to take the numbers and then I want you to pipe these numbers inside a function and we can call that function as validate our number list so we have not defined this function but let's define it right over here so let me just copy this one and let us Define a function right over here so validate our numbers list this X accept our list of numbers and let us see how we can Define the body for this one now for this function Let Us return back a tuple the first condition would be either true or false the second condition would be the numbers so in case if this list is not a list of numbers we will send back false but in case this is a valid list of numbers then we will send back a true right over here so let us see how we can do this thing unfortunately it's very simple so here let us use the inbuilt module of enum and I want to use the function of all now this all takes two arguments the first is going to be our enum so let us pass the enum of our numbers and this also takes a function so let us Define a function right over here now what happens for each iteration we are going to receive an element from our list of numbers and we simply have to check if that element is a number or not so here we can use an inbuilt function called as is number and let us pass the element to this one and that's it we have defined a function to validate all our numbers as well let us also write the type specification for this function so here we can say that the specs for validate number lists so this receives a list of our numbers and this function returns a tuple the first is going to be our Boolean the second element is our list of numbers let us go back to our function of population mean so now we have all of the validation in place now this function returns back a tuple so what we can do is we can simply take that Tuple and we can pipe the output in here another functions so let us call the new function as calculate population mean so we have not yet defined this function but let's define it right over here so here we can say that Define calculate population mean and let us write the do and end blocks now this function of calculate population mean receives a tuple right the first is our condition the second one is our list of numbers now this condition can either be true or it can be false so suppose we have a true condition then we can have a pattern match right over here but in case if it is false then we can create yet another Clause so let me just copy and paste this one so here I can say that in case the argument is false and we don't have to do anything with numbers so let me replace numbers with my underscore in case the first argument is false that means the validation has failed so here we can again send the same Tuple error so let me copy this one and let me paste it right over here now let us see how we can calculate the population mean in case the first argument is true now here the formula is very simple first we have to take the numbers next we have to calculate the sum and we can calculate the sum by using an inbuilt function so we can say enum dot sum the next one is we simply have to divide the sum with the count so for this let us Define one more function and let us call that function as mean so this function is going to receive two arguments the first argument would be for the sigma which comes from this one the second argument would be for the count and we can pass the second argument right over here so we can say enum dot count and let us pass the list of numbers now let us create this function right over here so we can say Define mean the first argument is for the sigma the second argument is for the count and for this one the implementation is very easy we simply have to divide the sigma with the count and that's it we have implemented population mean but we can do a lot of improvements so as you can see we have some repetition we have this couple of error here as well as on the top as well let me also put some separator lines for our convenience so this is going to be a separate thing and calculation for the population mean is going to be a separate section and one for this one as well so now let us go to the top and let us see how we can improve our code so now the first thing is we have this error Tuple twice so let's create a separate model for errors so let me open up my sidebar and inside the directory of lib let me create a new model called as errors and let us Define the module as stats dot errors let us Define a function over here so we can say Define invalid data types and we simply want to return back the Tuple so let me go back to the file of mean and let me just copy this line let us go back to our errors file and let me paste it right over here now let us go back to this file let me collapse my sidebar and now what we can do is we can create an alias on the top so we can say that let us create an aliens for our star ads dot errors and we can replace this line with errors dot invalid data type and we can do the same thing right over here so let me take out this line and we can say that errors dot invalid data type now I want to do one more thing I want to take out this function of validate into yet another module and this is because I simply know that we would require this validation function for our future implementation as well so inside lip let us create one more file for validators again let us Define the module and the model name has to be stats dot validators let us go back to this file I simply want to cut everything out so let me take it out and let us go to our file of validators and let me paste it right over here now for this one we can do one slide validation since we have taken this file inside another module so here we can do one small validation as well so let's define a guard over here so when is list for our numbers and in case if this validation fails then let us create one more Clause right over here so here we can simply ignore the argument and we can simply return back an error so let me again create an alias for the error right over here so let's create an alias for our Stacks dot errors and let us return an error right over here so here we can say that errors dot invalid data type now the specification for this one is going to change so this function of invalid data type this returns a tuple let us Define a specification for this one as well so let us go to errors and here we can say that the specification for our function of invalid data type so this function does not accept anything and this simply written backs an atom and the next argument is of the type of string so let me copy all of these things let us go back to our file of validators so now what's happening is in case if this number but is a list of numbers we send back a tuple but in case the validation fails then we simply send back an error and the format for the error is we have an atom and we also have a message right the next thing is since we have taken this function in a different module let us go back to our model of mean and let us create an alias on the top so here we can say that we want to Alias yet another module so we can say that we want to Alias stats dot validators now what we are doing is we are importing errors and validators from the same model of stats so we can create an alias on the same line let me show you how so we just have to wrap this inside our curly brackets and we can say that we also want to create an alias for validators as well now right over here on line number 10 this function is inside our model of validators so validators dot validate numbers list let me take out this lines let me open up my terminal and we can go inside our IEX let us create an alias for stats dot central tendency dot mean let me clear up everything and let us call our population mean so we can say population mean and let us pass 10 20 and 30 and as expected we get back the answer as 20. now let us pass an empty list and see what's happening so in this case we are getting back an error saying that error invalid data type now watch what happens if we pass some other argument for example if we pass a b and c so in this case we get an error saying that no function Clause matching and this is because we have not defined a catch all clause for this function of population mean so let us Define one Clause right over here so here we can say that define population mean and in this case we simply want to ignore the argument and we simply want to return back our errors dot invalid data type let me open up the terminal and let us recompile our model of mean let me clear up everything and let us try the same statement one more time so this time we get a nice error saying that error invalid data type so this is how we can create population mean but we are not yet done we also need to implement the sample mean but luckily the formula for sample mean and population mean is the same so let us very quickly Implement our sample mean as well let me take out all of the comments I don't need the comments let me paste the separator line on top now here let me again copy this separator line and let us create one more function for sample mean right over here so here we can say that we want to define a function for our sample mean now this function accepts a list of numbers and we simply have to call our population mean and pass our list of numbers so that's it now we have the function for sample mean and population mean as well let us also Define find the specifications for this function so here we can say that the specifications for our population mean now this function receives a list of numbers and this function is going to return back a number or it is going to return back an error now the type of our error is like this the first element is the atom and the second element is of the type of string let me copy this specification for our sample mean as well let me paste it right here and let me change the name from population to sample next we can do a couple of more implements for our code now if you see this function of calculate population mean and this function of mean so this functions are just our private functions so let us declare them as private so this becomes our F of p and this also becomes our private function the same thing happens for our mean as well this also becomes our private function now let me open up the terminal let us try and recompile this one more time let me clear up everything and let us try to invoke the same function one more time let us pass the list of 10 20 and 30 so this is for the population mean and let us try the same thing for our sample mean as well so let me replace this with sample mean and we get the same answer back now what's happening is every time we have to create an alias but instead what we can do is we can separate our public API from our private API so if I open up my sidebar we have a model for stats.ex and as you can see that this file is not doing anything so what we want to do is we want to make this stats file as our public API so what I mean to say is the end users can just reference this single file to use all of the functionality so let me show you how we can do this let me take out all of these things these are not required let me collapse the sidebar and let let us Define a function for our population mean right over here now this function receives the list of our numbers and from here we can simply call our function of population mean so we can say that we want to create an alias for our stats dot central tendency dot mean and for this function we can simply delegate it to mean dot population mean and let us pass the argument of numbers so now we have simplified our API quite a lot now let me open up the terminal let us recompile the model of stacks let me clear up everything now what we can do is we can simply call stats dot population mean and let us pass the argument of 10 20 and 30 and we get back the right answer now let us go back to our code and we can do one slide Improvement for this one now instead of just calling this function we can use something which is called as def delegate so first let me show you and then I can explain it to you so here we can use the new keyword called as def delegate the first argument is the name of our function so the name of our function is population mean so let me paste it right over here now this function also accepts one argument and the argument is for the list of our numbers and now what we want to do is we simply want to delegate this function to our model of mean and that's it line number four and line number five does the exact same thing so let me comment on this line This is not required let me open up my terminal let us recompile the model of stats let me clear up everything and let me call the same function one more time and as expected this is working just fine let us create one word of Delegate for the sample mean so here we simply have to change the name from population mean to sample mean so whenever we call stats dot sample mean this function would be delegated to main dot sample mean let me open up my terminal let us recompile the same module let me clear up everything and here I can say that stats dot this time I want to calculate the sample mean and let me pass the argument of three four five six and seven and this time we get the answer as 5 well that's it for this video and I will catch you in the next one let us get started with our statistics project so let me open up my terminal and let's create a new mix project so let me go inside my folder of functional programming with Elixir and then let me go inside my folder of code and right over here I want to create a new project so I can say mix new stats and let me open up the folder in a new window so this is going to be our new statistics project so let us see how we can Implement our population and Sample mean functionality so the first thing is inside the folder of flip let me create a new folder and let me call that folder as central tendency now inside this folder let us create another file so let me create a file and this is going to be for calculating our population and Sample mean let me collapse my sidebar and first let us Define a module so this is going to be stats dot central tendency dot mean so here first let us see how we can calculate our population mean now the formula for calculating the population mean is very simple we simply have to take the sum and we have to divide that sum with our count now in terms of statistics this sum is also called as Sigma so let us see how we can calculate our population mean first so let's define a function called as population mean this function accepts a list of our numbers so we can call the argument as numbers and let us see how we can Define the body for this function but before we can Define the body here we need to do a lot of validation the first validation that we need to do is we need to check if this numbers is actually a list or not so for this we are going to use a guard so let us go to the official documentation and let us try and see if we can find the Right Guard or not so inside the model of Kernel we have a section for guards so let us check if we can find the guard for list or not so if I scroll a little bit down here we have one God and this guard is right over here is list so let us see how you can use this guard in our function so here what we can say that we want to have a guard saying that is list and let us pass the variable of numbers so basically what we want to do is we want to run this function only when this numbers is a list now we have validated that this numbers is a list but what happens if this numbers is not a list or in case the numbers is an empty list so let's define one more function overload on the top so here we can Define that we want to define the same function population mean and in case if we get a blank list then at that time written back a blank list now we can either written back a blank list or we can also written some kind of an error so for example if you want to return some kind of an error so we can written back at Apple and we can say that this is going to be an error and we can also return back a message saying that invalid data like so it's up to you if you want you can get return back a blank list or you can return back an erratable so this is just for your reference so now let us see how we can Define the actual body for our population mean so here we need to do two things first we need to find out the sum or the sigma and then we have to divide by the count but before we do all of these things we need to do one more validation so till now what we have validated is that this numbers is just a list but we also need to validate that this is a list of numbers so let us see how we can validate this one so here let us create a pipeline so here we can say that first I want you to take the numbers and then I want you to pipe these numbers inside a function and we can call that function as validate our number list so we have not defined this function but let's define it right over here so let me just copy this one and let us Define a function right over here so validate our numbers list this X accept our list of numbers and let us see how we can Define the body for this one now for this function Let Us return back a tuple the first condition would be either true or false the second condition would be the numbers so in case if this list is not a list of numbers we will send back false but in case this is a valid list of numbers then we will send back a true right over here so let us see how we can do this thing unfortunately it's very simple so here let us use the inbuilt module of enum and I want to use the function of all now this all takes two arguments the first is going to be our enum so let us pass the enum of our numbers and this also takes a function so let us Define a function right over here now what happens for each iteration we are going to receive an element from our list of numbers and we simply have to check if that element is a number or not so here we can use an inbuilt function called as is number and let us pass the element to this one and that's it we have defined a function to validate all our numbers as well let us also write the type specification for this function so here we can say that the specs for validate number lists so this receives a list of our numbers and this function returns at Apple the first is going to be our Boolean the second element is our list of numbers let us go back to our function of population mean so now we have all of the validation in place now this function returns back a tuple so what we can do is we can simply take that Tuple and we can pipe the output in here another function so let us call the new function as calculate population mean so we have not yet defined this function but let's define it right over here so here we can say that Define calculate population mean and let us write the do and end blocks now this function of calculate population mean receives a tuple right the first is our condition the second one is our list of numbers now this condition can either be true or it can be false so suppose we have a true condition then we can have a pattern match right over here but in case if it is false then we can create yet another Clause so let me just copy and paste this one so here I can say that in case the argument is false and we don't have to do anything with numbers so let me replace numbers with my underscore in case the first argument is false that means the validation has failed so here we can again send the same Apple error so let me copy this one and let me paste it right over here now let us see how we can calculate the population mean in case the first argument is true now here the formula is very simple first we have to take the numbers next we have to calculate the sum and we can calculate the sum by using an inbuilt function so we can say enum dot sum the next one is we simply have to divide the sum with the count so for this let us Define one more function and let us call that function as mean so this function is going to receive two arguments the first argument would be for the sigma which comes from this one the second argument would be for the count and we can pass the second argument right over here so we can say enum dot count and let us pass the list of numbers now let us create this function right over here so we can say Define mean the first argument is for the sigma the second argument is for the count and for this one the implementation is very easy we simply have to divide the sigma with the count and that's it we have implemented population mean but we can do a lot of improvements so as you can see we have some repetition we have this couple of error here as well as on the top as well let me also put some separator lines for our convenience so this is going to be a separate thing and calculation for the population mean is going to be a separate section and one for this one as well so now let us go to the top and let us see how we can improve our code so now the first thing is we have this error Tuple twice so let's create a separate model for errors so let me open up my sidebar and inside the directory of lib let me create a new model called as errors and let us Define the module as stats dot errors let us Define a function over here so we can say Define invalid data types and we simply want to return back the Tuple so let me go back to the file of mean and let me just copy this line let us go back to our errors file and let me paste it right over here now let us go back to this file let me collapse my sidebar and now what we can do is we can create an alias on the top so we can say that let us create an aliens for our star ads dot errors and we can replace this line with errors dot invalid data type and we can do the same thing right over here so let me take out this line and we can say that errors dot invalid data type now I want to do one more thing I want to take out this function of validate into yet another module and this is because I simply know that we would require this validation function for our future implementation as well so inside lip let us create one more file for validators again let us Define the module and the model name has to be stats dot validators let us go back to this file I simply want to cut everything out so let me take it out and let us go to our file of validators and let me paste it right over here now for this one we can do one slide validation since we have taken this file inside another module so here we can do one small validation as well so let's define a guard over here so when is list for our numbers and in case if this validation fails then let us create one more Clause right over here so here we can simply ignore the argument and we can simply return back an error so let me again create an alias for the error right over here so let's create an alias for our Stacks dot errors and let us return an error right over here so here we can say that errors dot invalid data type now the specification for this one is going to change so this function of invalid data type this returns a tuple let us Define a specification for this one as well so let us go to errors and here we can say that the specification for our function of invalid data type so this function does not accept anything and this simply written backs an atom and the next argument is of the type of string so let me copy all of these things let us go back to our file of validators so now what's happening is in case if this number is a list of numbers we send back a tuple but in case the validation fails then we simply send back an error and the format for the error is we have an atom and we also have a message right the next thing is since we have taken this function in a different module let us go back to our model of mean and let us create an alias on the top so here we can say that we want to Alias yet another module so we can say that we want to Alias stats dot validators now what we are doing is we are importing errors and validators from the same model of stats so we can create an alias on the same line let me show you how so we just have to wrap this inside our curly brackets and we can say that we also want to create an alias for validators as well now right over here on line number 10 this function is inside our model of validators so validators dot validate numbers list let me take out this lines let me open up my terminal and we can go inside our IEX let us create an alias for stats dot central tendency dot mean let me clear up everything and let us call our population mean so we can say population mean and let us pass 10 20 and 30 and as expected we get back the answer as 20. now let us pass an empty list and see what's happening so in this case we are getting back an error saying that error invalid data type now watch what happens if we pass some other argument for example if we pass a b and c so in this case we get an error saying that no function Clause matching and this is because we have not defined a catch all clause for this function of population mean so let us Define one Clause right over here so here we can say that define population mean and in this case we simply want to ignore the argument and we simply want to return back our errors dot invalid data type let me open up the terminal and let us recompile our model of mean let me clear up everything and let us try the same statement one more time so this time we get a nice error saying that error invalid data type so this is how we can create population mean but we are not yet done we also need to implement the sample mean but luckily the formula for sample mean and population mean is the same so let us very quickly Implement our sample mean as well let me take out all of the comments I don't need the comments let me paste the separator line on top now here let me again copy this separator line and let us create one more function for sample mean right over here so here we can say that we want to define a function for our sample mean now this function accepts a list of numbers and we simply have to call our population mean and pass our list of numbers so that's it now we have the function for sample mean and population mean as well let us also Define find the specifications for this function so here we can say that the specifications for our population mean now this function receives a list of numbers and this function is going to return back a number or it is going to return back an error now the type of our error is like this the first element is the atom and the second element is of the type of string let me copy this specification for our sample mean as well let me paste it right here and let me change the name from population to sample next we can do a couple of more implements for our code now if you see this function of calculate population mean and this function of mean so this functions are just our private functions so let us declare them as private so this becomes our F of p and this also becomes our private function the same thing happens for our mean as well this also becomes our private function now let me open up the terminal let us try and recompile this one more time let me clear up everything and let us try to invoke the same function one more time let us pass the list of 10 20 and 30 so this is for the population mean and let us try the same thing for our sample mean as well so let me replace this with sample mean and we get the same answer back now what's happening is every time we have to create an alias but instead what we can do is we can separate our public API from our private API so if I open up my sidebar we have a model for stats.ex and as you can see that this file is not doing anything so what we want to do is we want to make this stats file as our public API so what I mean to say is the end users can just reference this single file to use all of the functionality so let me show you how we can do this let me take out all of these things these are not required let me collapse the sidebar and let let us Define a function for our population mean right over here now this function receives the list of our numbers and from here we can simply call our function of population mean so we can say that we want to create an alias for our stats dot central tendency dot mean and for this function we can simply delegate it to mean dot population mean and let us pass the argument of numbers so now we have simplified our API quite a lot now let me open up the terminal let us recompile the model of stacks let me clear up everything now what we can do is we can simply call stats dot population mean and let us pass the argument of 10 20 and 30 and we get back the right answer now let us go back to our code and we can do one slide Improvement for this one now instead of just calling this function we can use something which is called as def delegate so first let me show you and then I can explain it to you so here we can use the new keyword called as def delegate the first argument is the name of our function so the name of our function is population mean so let me paste it right over here now this function also accepts one argument and the argument is for the list of our numbers and now what we want to do is we simply want to delegate this function to our model of mean and that's it line number four and line number five does the exact same thing so let me comment on this line This is not required let me open up my terminal let us recompile the model of stats let me clear up everything and let me call the same function one more time and as expected this is working just fine let us create one word of Delegate for the sample mean so here we simply have to change the name from population mean to sample mean so whenever we call stats dot sample mean this function would be delegated to main dot sample mean let me open up my terminal let us recompile the same module let me clear up everything and here I can say that Stacks dot this time I want to calculate the sample mean and let me pass the argument of three four five six and seven and this time we get the answer as 5 well that's it for this video and I will catch you in the next one now let us move on to the next part and let us see how we can calculate something which is called as a median now what I've done is behind the scenes I have created a new file called as median and I have also defined the model for this one and to make things simple I have added a lot of documentation so let us see what do we exactly mean by the median so let us have a look at this scenario right over here so suppose Lewis is selling candies for 9 hours and these are the sales of the candies for each respect to hour for the first hour Lewis could sell 10 candies for the second hour Lewis sold 40 candies for the third he sold 20 and so on so these are the number of candies that Lewis sold each hour throughout nine hours of his shift now let us see what do you exactly mean by median so median is nothing it is just a central value or it's just the value that divides the measurement into two equal parts so what we want to achieve is we want to find a value that will divide our measurements in the first 50 percent and the next 50 percent and it's very easy to calculate median as well so this is going to be a very simple algorithm for calculating the median the first step in our algorithm is sorting our list so here we can see we have a sorted list of all of the sales of candies for the first nine hours for the second part of our algorithm is we need to count the number of elements inside our list and now here there can be two things first if our account is odd and the second one is if the count is even now if the count is odd then the things are very simple we simply take the middle value and that value becomes our median so for example in this case 50 is right at the center we have four values to the left and we have four values to the right so 50 becomes our median the next scenario is what happens if the count is even at that time what we do is we take two values from the center so in this case 40 and 50 are two values now just have a look at this list this list contains only eight values I have taken out the last value of 90 from this list now since this is an even list we simply take two values from the center so we have 40 and 50 as the center so as you can see there are three values to the left and we have three values to the right and then we simply average them out so 40 plus 50 divided by 2 and we get the answer as 45 and 45 becomes your median value so this is how we are going to implement our algorithm for calculating the median so let us see how we can translate all of these things into code so let me go to the top and here we can see that I have defined a model by the name of stats dot central tendency dot median and now let's get started with this one let us Define the very first function and let us call the function as median this function is going to accept a list of our numbers so we can call the argument as numbers list and let us also use the guard right over here so we can say when is a list and it has passed the argument of our number list so this is one scenario and the next scenario could be we don't get a proper list over here so for handling that case let us Define one more version so we can say median we simply want to ignore the input and we simply want to throw an error but first we need to create an aliens so it's very easy for us to use those modules so let me create an alias for our stats dot errors and here we can say that we simply want to return our errors dot invalid data type now let us go back to this function and let us see how we can implement this one so the first thing is we need to validate our list of numbers so again let me create one more areas at the top so here I can say that we want to create yet another Alias and this time it's for stats dot our validators and now let us go down right over here so here what we can do is we can simply take the list of our numbers and then we can pipe this list of numbers inside our validators DOT validate numbers list and after we validate our numbers list then we can pipe the output into yet another function by the name of calculated median now we don't have that function as of now but we will create it shortly let me put a separator line over here and here let us Define the function of calculate median now let me scroll slightly up so that everything is visible now let us see what this function is going to receive so the output of this function validate numbers list is going to be pipe into the function of calculate median and as you can see this function either returns a Boolean and our numbers list or it Returns the atom along with the error message so let us pattern match on various scenarios and let us see how we can handle different cases the first and the most easiest one is just to handle the error so in case we get an input like this we get an error and the second argument is a message at that time we can simply return back the Tuple of error and the message as it is or what we can do is we can simply use the errors module so either you can do this or we can simply call errors dot invalid data types now let us see what more we can do with this function now the function of validate numbers list can also give us a tuple where the first argument is a Boolean and the second argument is the list of numbers so let us pattern match on this scenario and let us see how we can work with this one so let me Define yet another function oh one more thing what we can do is we can simply mark this function to be private now since this is going to be our helper function we don't want to expose the functionality outside so I am simply marking this function as a private function now let us have one more pattern match right over here now what happens if the first argument is false so at that time we can simply ignore the second argument we don't want the second argument so in this case also since the validation has failed let us again send back the error so we can say errors dot invalid data type now let us Define the third scenario as well so again let us Define the private function calculate median and this time it receives a tuple where the first argument is true and the second argument is our list of numbers here let us see how we can Define the body for this calculated median function let us go slightly up and let us have a look at our algorithm so for the algorithm we need to do two things we need to sort and we also need to count now let us Implement those steps in this function right over here calculate median so here what we can do is we can take the numbers list and we can sort it out by using the inbuilt model of enum so we can say enum dot sort so now we have a sorted list of our elements now the second thing is we need to count if the number of elements are even or odd and depending on that scenario we have to handle two different scenarios so the first scenario was how to calculate the median when the count is odd and the second scenario was how to calculate the median when the length is even so for this we would need to create yet another helper function so what we can do is we can take the output of NM dot sort and let us pipe that output in one more function by the name of get median now we don't have this function but we will create it shortly now this function of get median is going to receive three different parameters the first parameter is obviously the sorted list the second parameter is going to be a Boolean value so we will check if the number is odd or even and the third argument would be the count itself so let us pass the argument for this function now the second argument is going to be a Boolean value and we can check if the count is odd or even by using yet another inbuilt model by the name of integer so we can call the inbuilt model of integer and here we can use the inbuilt function of is even and let us pass the count now for calculating the count what we can do is we can say numbers list and we can pipe this one into another function called as enum dot count the next argument for the function of get median is going to be the count itself so here again what we can do is we can say numbers list and we can pipe the output into enum dot count now as you can see we have little bit of repetition so what we can do is we can take this one out from here and let me create a variable called as count let me put it right over here and we can simply replace this by the variable of count and this also gets replaced by the variable of count now the last thing to do is we simply have to define the function of get median so let me use the separator right over here and let me create the function of get median now this function receives three parameters the first parameter is our list of numbers the second parameter is actually going to be a Boolean value so let me write in Bool for now and the third parameter is going to be count now let us see what we can do with this function now for this function we again have two scenarios right so if we go back to the algorithm so the first scenario is odd and the second scenario is even so what we can do is we can simply use pattern match right over here so this integer dot even is going to give us a Boolean in the terms of true and false so here what we can do is let us pattern match on false so that means this list is not even that means this list is going to be odd and since this list is going to be odd we simply have to take the element at the center and return it back and fortunately it's very easy again for this we are going to use the inbuilt model of enum and there is an inbuilt function called as at so this function accepts two different parameters the first is obviously going to be our list of numbers and the second parameter is going to be the index so for the index what we can do is we can simply take the count and we can divide that count by 2. now there is one small issue over here so this count divided by 2 this actually returns back a float and the index value cannot be flowed so suppose if this value returns an integer such as 4.5 so in that case we don't have any values or rather we don't have any index called as 4.5 so what we need to do is we need to have an integer Division and not a float division over here so in order to ensure that we get back an integer we can use the inbuilt function of division so the first argument is going to be the count and the second argument is going to be the number now again this function has to be private so let me put it as Def and P so this is the first scenario where the list is odd the second scenario is what happens when the list is even so let me just copy all of this and let me paste it right over here now for the second scenario is the list is even so we get a true right over here and let us see what we are supposed to do in this case so if you go back to the algorithm so in this case we have to take two values from the center and then we simply have to divide them by 2 and return back the value so let us do exactly those things right over here now what we can do is let us create two variables to hold the values from the center so we can say that the first variable is a and let me copy this function right from here now in this case we have to take one previous value right so if I go back over here we want to take the value which is right over here so what we can do is we can say count minus of 1 and let me again copy and paste for the next value we don't need minus 1 and let us call that variable as B so now we have both the values from the center and we simply have to add a plus of B and we just want to divide them by 2. and that's it now as soon as I saved my file we can see that we are getting a small error right over here so what is this saying that you must require integer before invoking the macro so what's happening is elixir is actually using a macro so macro is a kind of a code that generates yet another code but for now we don't have to go into the specifics we just have to do whatever this error message is telling us so if you just refer the message it is saying that we simply have to require integer so let's do exactly the same thing so let me go to the top and here I can say that I want to require the model of integer and that's it now the error should be gone yes now all of the errors are sorted out the last thing is let us go to our public API let us go to lib and under lip let us go to the model of stacks and let us create a depth delegate right over here as well let us use the macro of Def delegate and we can say that we want to define the function of median now this function accepts the list of our numbers and we simply want to delegate this function to the module of median but before let us create an alias right on the top so what we can do is we can import different modules on the same line so we can say that I also want to import median right over here now here on line number nine we simply want to delegate the execution to the model of median so now let me open up my terminal and let me go inside IEX and let me clear up everything so here let us try and invote that function so we can say stats dot median and let us create a list right over here and let me pass the values so as we can see we are getting the value as 50. now what I have done is this is a list of our odd numbers next let me pass one more list which has even numbers so let me take out 90 I don't need 90 from here and in this case we are getting the value as 45. well that's it for this video and I will catch you right in the next one hello and welcome to the last video of the series so the last video is all about learning something which is called as mode now what exactly is a mode so let me try and explain but before that what I've done is behind the scenes I've created this file mode.ex inside central tendency and let us see now how we can find the mode of our elements so what exactly do we mean by mode so mode is basically the element which repeats most often so for example if we have this array of values then the mode of this values would be the values that are repeating the most now in this example the most repeating values are 4 and 8 that's why the mode of this is 4 and 8. now you must be thinking what is the use of mode so let me try and help you why mode is very important now suppose this values actually stand for the product ID of the candies which Lewis is selling so for example one could be the product ID for the red candies two could be the product ID for the yellow one three could be for the green one so by finding out the mode we can understand which candies Lewis was able to sell the most so in this example we can say that the candy with the idea of 4 and the candy with the idea of 8 where the most popular and is inside the store so let us see how we can find out more so I have given the steps over here so it's basically a threestep process the first is we have to find the number of occurrences or the frequencies next we have to find the maximum number of occurrences and finally we have to group The Elements which have the maximum occurrences now instead of directly writing the code this time let me show you inside the IEX how you can find the solution for this one so let me just copy this one and let me open up my terminal so let me go inside my IEX and let me clear up the screen now if we refer to the steps the first step is we have to find the occurrences or the frequencies so let me paste the values right over here and we can find out the frequencies by using the inbuilt function so we can pipe these values to enum dot frequencies and here it is so now we have all of the values and their frequencies as well so what I would like to do is I would like to Simply Save this in a variable called as ranked map so now we have a ranked map the next step is we have to find the maximum number of occurrences so let us see how we can do that let me clear up my screen so now we have the ranked map for finding out the maximum number of occurrences what we can do is we can take the ranked map and from this map let us simply take the values so we can say map dot values and let us see how it looks like so these are just the values the next is we simply have to find the maximum value out of this map so what we can do is we can type this one into yet another function called as enum dot Max and here it is so the maximum number any value is repeating is Thrice and if you refer to our map we can see that 4 is repeating price and 8 is also repeating Thrice now there is a small caveat for finding out the mode in case the elements are not repeating more than once in that case we can't find out the mode but if we have Elements which are repeating more than once only in that case we can find a valid mode so now let me do one thing let me copy this one and let me save this into yet another variable called as Max let me clear up all of these things so now we have the ranked map and we also have the maximum count the next step is we simply have to filter this react map for the maximum number of occurrences so in this case we saw that 4 is repeating Thrice and 8 is also repeating Thrice so we simply want to filter it out so let us see how we can do this so for this what we can do is we can take the ranked map and then we can use the function called as map dot filter now this function accepts two parameters the first is your map and the second is your Anonymous function so let us write a function right over here now for each iteration this function is going to receive the key and also the value pairs from our map and for each iteration we simply want to filter out for the values where the value is equal to our maximum count so now we have a filtered map the next step is we simply have to take out the keys and that's it so let us see how we can do that so we can take this exact same expression and then we can say that we just want to take the keys from our map and that's it we have our final answer so let us go back to the code editor and let us see how we can do all of these things right over here now for this example I am not going to do all of the validation and error reporting because I suppose you know how to do all of those things so let us directly go inside and see how to write the functions for our mode so let me take all of these things up and here let us Define a function and here we can say that we want to define a function called as mode now this function receives a parameter which is the list of numbers so I can simply add a card over here so is list for my numbers now if you want you can do all of the extra validation but for this video I am not going to do the validation so the first step was finding the frequencies so let me create a variable called as ranked map and here what we can do is we can simply take the numbers and let us pipe those numbers to enum dot frequencies next what we can do is let us try and find the maximum number of occurrences so for that what we can do is we can take the ranked map we can pipe this function into map dot value so now we have all of the values with us next let us find out the maximum number of occurrences so we can pipe this into yet another function enum dot Max so now we have the ranked map and we also have the maximum number of occurrences now the last thing to do is we simply have to filter out our ranked map and for that let us create a helper function so here let us pipe this into yet another helper function by the name of mode func now this function is going to accept two parameters the first parameter would be for the maximum number of occurrences and the second parameter would be for the rank map itself so let me Define a private function mode of func now this function accepts two parameters the first parameter is for the maximum number of occurrences the second parameter is for our rank of map now here we need to take care of one more condition and that is we can find more only if the number of occurrences are more than one so for this function definition let us have a pattern match right over here so we can see that in case the maximum number of occurrences are 1 in that case we simply have to ignore the rank map because we can't find out the mode and let us simply written back nil but in case we have the occurrences which are more than one so to handle that situation let us Define one more function overload right over here so we can say mode of func and the first parameter was for the maximum value the second parameter was for our ranked map so let's take the ranked map and next we simply have to filter it out so we can say map dot filter and here let us Define the anonymous function so we can say function now for each iteration this is going to receive the key and also the value and what we need to do is we simply want to filter it out when the value is equal to our Max and the last thing is we simply have to take out the keys from this one so we can say map dot keys now the last thing to do is let us go to our stats.ex and let us create a def delegate right over here so you can say depth delegate let us create a function for the mode this also accepts our numbers list and we simply want to delegate this to the model of more but first let us import it right over here so we can say we also want to import more and this one we simply want to delegate to more now let me collapse my sidebar and let me open up my terminal now let us recompile this one more time and let me clear up everything so now we can call stats dot mode and let me pass the values right over here and as expected we get back the answer as 4 and 8. well this brings us to the end of this course but before I can see my final words I wanted to show you a couple of things now if you refer to the code from my GitHub repository so which is this one now inside my official GitHub repository what I have done is I have implemented two more functionality which are under the folder of variability the first one is about variance the second one is all about your standard deviation now I am not going to cover these parts inside this tutorial series because I think they are more towards your mathematical modeling and statistics while this course was designed to give you a fair idea about functional programming in Elixir but I have kept them for a reference you can refer them and you can see how I am able to model variance and standard deviation for statistics well that's it from me and I will catch you in the next one hi I hope you really had fun learning functional programming along with me now this course was designed to teach you all of the basic constructs of the functional programming language but Elixir has a lot more to it the next things that you would want to learn is all about the concurrency and the OTP framework and after you learn the concurrency framework then you can go ahead and you can learn the awesome Phoenix framework as well now coming back to this course if you are finding functional programming to be little difficult it's not your fault it takes some time patience and practice before you can understand functional programming language but after you get the hang of functional programming language believe me you would never want to go back to your object oriented programming or your imperative programming Paradigm as well so let me conclude this course and let me conclude this video and do let me know in the comments uh how would you find this course and you can also connect with me on my website it's um octylium.com and also on Twitter my handle is at the rate of earlier and if you're feeling generous you can all you can buy me a coffee it's buy me a coffee.com slash octallium and also do let me know if you want to learn some more Concepts from me if you would like to learn OTP framework the Phoenix framework or if you would like to learn mathematics and statistical modeling from me or any other topic that you would like to learn from me as well so that's it from me and I will catch you in the next one bye