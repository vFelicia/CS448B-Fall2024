hey guys welcome this video is about aws appsync which is a managed graphql offering from aws and today we are going to create a simple angular application that talks to a graphql server which is built on aws appsync and we are going to use amplify library to send request and receive response from the graphql endpoint as you guys may know amplify is a frontend library that makes our life easy to talk to aws backend resources so let's get started now before i move on i want to give a quick introduction to graphql api now graphql api is quite fast and flexible comparing to rest api because unlike crest in graphql it's the client who decides you know what data it needs from the server for example let's say there's a web page that needs to populate with some data so the client or the browser decides okay these are the data that i have to populate in this page so server please give this data to me so it request the data in terms of a query from the server and server will fetch the corresponding data and send it back to the client so it can easily populate the page and graphql of course it operates over http and unlike rest guys we can use fewer http request to get our job done because the client has the handle know what data it needs and what query it creates to get the data so the client doesn't need to send bunch of http requests to get whatever the data it needs for the most part it will get it in one go with a one request and in graphql the queries are quite flexible so it's less code to maintain as well so let's take example now this is a graphql query so in this query we are basically asking from the graphql server a graphql server give me this particular user's name and the email address and also all the blog posts that he has created so when you send this query to a graphql server you will get a response like this one so this is json response can you see the return data is exactly smashing the attributes that the client has requested for example is the user and is the user object and here's the name and the email and the posts since the user has multiple posts so it is written as an array so inside this array you have objects so each objects contain title and with the body so how come graphql is faster than rest for example if it is rest we may have to get the user's name and the email and the id first using a one http call to the server and then we may have to send the user's id to a different api endpoint to fetch all the post of that user so it could be like couple of requests in order to like formulate this type of a data object but in graphql for the most part we have only one api endpoint for that api endpoint we send the query that we need so the browser or the client makes this query and the server will make sure get whatever the corresponding data from different data sources different tables for in this case uh it might have you know queries these two fields from the user table and these post from the post table and aggregate it and send the response back to the user in terms of a json object which can be easily populated on the client so that's the power of graphql and it is quite fast and there are three main operations we already talked about query so that is basically fetching the data from the graphql api which corresponds to a get request in rest and then we have mutation mutation is nothing but changing the data like creating updating deleting a record in the database in rest we use post put delete requests but in graphql we send a mutation and then we have a subscription so which is basically you know watching over the changes of particular data for example let's say you do a mutation let's say you create a new post in the post table and the clients can always listen onto the post creation mutation so whenever a new post is added the changes will pass on to the client in real time so this is happening through websocket in graphql so basically client is opening up a websocket connection to the server and whenever mutation is happening and if the client has a subscription on to that mutation then it will receive the realtime data okay so that's a quick introduction to graphql so let's go to our demo i'm opening up a terminal and navigate to desktop and create a new directory called appsync and i will go into appsync directory and i will open it in visual studio code by typing code space period so let's create a angular application first so i'm going to use angular cli so i open up an integrated terminal here and i have installed angular cli so i can type ng new my app and i'm going to enable routing as well so i have the latest angular cli and i will choose the styles as a css then start creating my application okay we are going to create a very simple todo application so that a user can log into the application and then create his or her todo's so in our application i need two components let's cd into my app folder the first component is auth so i will use ng gc or the cli generator to generate the component and its name is auth so this oauth component it will comprised of my login screen and i am going to use amplify auth ui component to integrate login signup and all those screens very simply so the next component is to do so this is the component which contains my todo's okay both the components are created and if i open my my app folder and into the source folder into the app folder you should see those two components so i'm going to set the routing as well so i will go to app routing module and let's set two parts part to do that will render the todo component and another default path that render the oauth component so let's see if everything is working i will type ngserve so when i open the application it should render the default route and you can see the oauth works here and these are the default content which we are going to delete it right now so here's the default content and i will delete it so i will have only the router component and save it and here you go so our default is oauth route and it works and if i go to todo the todo works as well so now we are going to add amplified cli and the amplify library so we can add a logging screen instead of this auth works okay so let's stop the server and type npm install dash d at aws amplify dash cli and hit enter so this will install the amplify cli globally cli is installed so now we can create resources in aws like appsync service now let's install aws amplifier and aws amplify angular so these two libraries will allow us to talk to backend resources via the api so in order to get these two libraries working we have to do a small changes in our angular application the first one is adding a polyfill so go to polyfill.ts and on top add this line of script windows as any global window so this will provide a stream for the global object and in index.html inside the header tag you need to add a script tag and inside the script tag at this line of code if global is undefined set the global to window and now go to tsconfig.app.json file here's this file and under types array add node because amplify will use node behind the same so we have to add the node type here okay now let's use amplifyca cli to spin up resources so let me clear the screen so first we need to create a logging screen we are going to create a cognito user pool to hold our users and then allow them to access upon successful authentication so let's enable authentication with amplify by typing amplify and first type help so you will see all the commands now first of all let's initialize the project even before adding the functionality so i will type amplify hope you guys can see it if not amplify init hit enter so this will initialize the amplify project in aws so choose the default editor in my case visual studio code and i'm going to build a javascript application which is an angular and our source directory is src because our directory name is src hit enter and distribution directory is dist slash my app which is the name of my app and build command hit enter and accept the default start command ng server so now it asks whether or not i want to use an aws profile now here i say yes and i'm going to pick my youtube profile so if you guys have not configured an iem profile in your machine use amplify configure and add your access key and secret access key with the name of a profile okay now the project is initialized so let's add all so here's the category oath so in order to add that let's type amplify at oauth select the default configuration now this is the default configuration of the user pool okay it is added now before you pushing those changes to aws i'm going to add api as well so i will type amplify add api and hit enter so this time we are going to choose graphql api so select graphql not fresh and provide the api name i will say my app and the authorization type choose amazon cognito user pool since we have already created a user pool we can use authorization from that user pool so amazon cognito usable and then it will ask do you have an annotated graphql schema in my case i do not have anything so i will say no and hit enter do you want a guided schema creation hit yes and then it will ask some information about your project so is it a onetomany relationship like blocks and post or single object with fields like a todo application which exactly what we are building so let's select single object with fields and now it will ask do i need to edit my schema right now i will say yes and hit enter it's going to open my schema.graphql this is my graphql schema so i'm going to change this attributes a little bit for my todo so id is fine for to do name is fine and instead of description i will type body and also i will have another attribute called completed and that's the type of boolean i will save it and come back to my editor and hit enter okay it is created locally now when i type amplify publish or push so what happens is amplify will create my graphql api so it will look at my schema definition so this one graphql schema and it will create an appsync service and it will create a dynamodb table with these fields and also it will link that dynamodb table with the appsync service and also at the necessary configuration to create read delete update records in that table as well so that's very convenient for us as a developer so let's type amplify push and it'll ask these other things or the resources that it's going to configure in cloud the oauth the cognito user pool and for the api my ap my app appsync api so i will agree by typing yes and hit enter so then it's going to ask me do you want to generate code for the newly created graphql api i will say yes because i need the code for my angular application and then it will ask me okay your path pattern to store all the queries mutation and subscription i will accept the default because it's going to create this graphql folder inside my source directory and then add all those graphql files so then it further suggests me okay now do you want to like create all those example operations like queries mutations and subscriptions as well of course i want i need that and now it's going to ask for a file to generate that code i will accept the default so that will create api.service.ts file and now it's updating the resource now while it is updating i want to do attention on this particular directive so this is the graphql schema and it has this particular directive called at model so there are multiple directives in amplify so at model is one of them so in this directive what it does is as soon as it shows okay this type with this directive it's going to create a dynamodb table with these attributes and as i previously mentioned it will do all this linking part with the appsync service together with all the operations so that's very cool all right it's created you can see it has given me the graphql endpoint as well so as you can see it has created a lot of files here here the log says generated graphql operation successfully saved that source graphql folder so let's see this is our source folder and this is the graphql folder and inside the graphql you should see all the queries and see we have a get to do query get all the to do's like list2do's query and then we have mutations like creating a todo update and delete to do mutation and also subscriptions as well so we can subscribe to like one create to do as soon as a todo is created we can just listen for that and get the content so apart from that you should see there's this aws export.js file and it has all the configuration that amplify has provision in my aws account so it has cognito user pool information and also the graphql information etc now we need to do one thing so let's just take a copy of this file and paste it in the source directory again and instead of js file i'm going to rename it as aws export.ts file now we can import this file into our angular components now let me show you one other thing if you go to amplify folder here and into the back end into this api folder and inside app folder you should see the build folder go inside that then you should see this folder called resolvers now open it up when you open it up you should see there are multiple resolvers for creating todo's and deleting todo's updating getting and listing to those for each resolver there's a request template this is the request template for create to do and this is the response template for creating todo's and here's the same and here's the request and response template for get to do now what is this guys in graphql when the browser sends a query to the api let's say uh it's asking to you know get a particular to do right then we have to write a resolver in order to do that operation so if we want to get the todo's we have to query the dynamodb table and get that corresponding to do matching with the todo id right so we can do that in different ways in graphql we can have resolvers either by using the data source for example in this case it is the dynamodb so we can use the dynamodb gate item operation so you can see the operation is get item and the key this is the hash key or the primary key so that is corresponding to the id of the to do so this is the one of the options that you can write the resolvers or else you can write a lambda function and hook that as a resolver and inside that lambda function you can talk to the dynamodb and get the result and send it back to the client so there are multiple ways that you can attach resolvers so the request template is basically you are requesting the data from the data source in this case dynamodb and the return data you can like modify that return data back into a graphql response so yeah you can like restructure it as a graphql response but if you want to do like further filtering before sending the response you can add this here so that's about getting to do so how about creating to do so that's a mutation so when you send that mutation you can again use dynamodb operation put item operation and then for this new key and you know add those attributes that is coming along through the mutation and create a new to do item and here also instead of using this velocity template and using the dynamodb put item operation you can use a lambda function to talk to dynamodb using dynamodbsd case and do that operation as well okay so now let's set the amplifier logging to our application so in order to use amplify we have to do a little bit of configuration so let's go to source folder and into our app and into app.module.ts and we have to import some libraries so what library do i have to import i'm going to import amplifyservice and amplify angular module from aws amplify angular library and i will add the module inside the imports here and the amplify service as the provider so now that we have the amplify angular module imported we can use the ui component provided from the aws amplifier angular for authentication so let's go to our auth component and go to and go to a component.html file and here instead of hot works let me delete it and i will paste in the amplify authenticator directive this will add all the ui components for login logout forget password sign up etc but in order to do some styling let's import amplify styles into our styles.scss file so i will go to styles.css file and here i'm going to import aws amplify angular slash theme.css now let's see our application looks by typing ng serve and when we go to localhost 4200 yes i should see this nice ui so now let's add some code to our todo component as well i will remove this to do works template and i will paste in this code so press this do the wrapper due around so inside that i have two buttons first one is to create a to do and the other one is to get all the to do so create to do is linked with the create to do function get to do is link with get to those function and then we have another view this view will iterate over all the todo's and print out the todo name and the body and whether or not it is completed i will upload this code into github and link it so you guys can see it as well okay guys let me change this get to do to uh list todo's because you are listing all the todo's here and now let's create those function go to our ts file and first one is create todo and list todo's now in order to create todo uh i'm not going to use any like input boxes and get the actual todo content from the user but instead i'm going to like generate a couple of todo's when someone hit this button so let me paste in this code so const new to do and i have given the todo name as to do and then a random value between 1 200 and sample description and this is the completed status which is false and now we have to use create to do mutation so for that let's use amplify api now before actually use amplify we haven't uh configured it properly we got to do a small thing so let's go to a main.ts file which is our main angular file that get bootstrapped and there we need to import amplify from aws amplify library like this import amplify from aws dash amplify and then we have to import that aws export file if you can remember guys the amplify generated this aws export.js file and we created this ts file of course we can like use a script to do this conversion but we'll like copy paste for now so we are importing that particular export file as well then we are using amplify.configure and passing that particular export file so that's it so once you do this amplify configure amplify know okay these are the resources that it can talks to and these are the metadata that it can use for example appsync url let's do another thing if you can remember amplify has created this api dot service file so this has all the mutations queries and subscription of web sync so we need to import this api service if you want you can put it to the app module as a provider so you can use it throughout your components but in my case i will only use in the to do component so how can we use it let me go to to do component and on top let me import that one directory up and api service and i think that is called api service yeah so let's import our service as well and here in the constructor let's create a private variable call it api of api service so now we can use this api private variable in order to talk to a web sync endpoint so let's go into our method which is create to do so we have this new to do and in order to call this mutation we have to use our api this dot api dot and it is create to do and it will take the input test that you do input which is nothing but our new todo let me just copy it and paste it in okay now this function is asynchronous function guys so we need to wait for that and let's take the result into a variable called result why not and since we are using a weight we have to like create this function as a async function all right and let me just put a debug point here just to stop it at this point and inspect the result and for list to do's what do we need let's create another variable called all to do's and that is what we have referenced in our loop yes it is all to do and let's call our api again api dot list to do's i don't have to pass any parameters here again we have to make this function async and rather we'll define this old todo's on top and here let's call it this dot all to do and on ng on init so this is the function that called when this component is initialized so let's call the same thing here so when we refresh the page it will always like call this function and here also let's do another change so once you have successfully created it let's push that to do into our all todo list this dot or todo's dot push the result okay let's see if it is compiling it all right yes i think so and i will go to uh localhost 4200 nothing let's inspect it process is not defined i think that's another problem in angular 6 where we need to use another shim for that so let's go to a polyfill.js so in the polyfill.js if you can remember we had a polyfill for the global object and also we need to have a polyfill for the process object this is a workaround that i found on internet so let's set this one window as any process the script and save it and now let's do a refresh there you go now it works now we are at localhost 4200 and now this is our login page since you guys don't have any account created you click create account and sign up for a new account with the username password an email and those stuff and afterwards you will receive an email to your email address with the confirmation code add that in and then you are good to sign in i have already created a user so let me login with him mjson and click sign in here you should see the inspect element the network tab all the calls that it does for the backend so it's calling the cognito api and once you are successfully signed in cognito will send you all the tokens id token access token and refresh token and they will be stored in the local storage so you can see it has grabbed my name hello mjson and let's go to uh to do endpoint now that we are signed in you can see uh our two uh buttons okay we got an error so let's see yeah uh we need to define this as an array all to do and then here let's take this into a variable let result and assign this dot all to do's as results good items because there's this items attribute that these todo's will be populated okay and here also the same thing let me just copy these two lines and when you click list to do's it will show that as well okay i think now it looks good let's see there you go now i have all these to do so i created so i got 9 68 18 and 78 let's create another one 88 and if i refresh it i should get all those things right and if you go to inspect element 10 into the network tab let's inspect what happens when you click create to do's it's calling the graphql api and it's calling the create to do mutation so it is passing the body completed or not all that right okay so this is one of the ways that we can work with appsync endpoint with amplify graphql client but this amplify graphql client does not support offline functionality so if you want offline functionalities and those complex features you have to use appsync sdk but this graphqlapsync client is really great for you know handling mutations queries and subscription quite easily all right guys so this video is about modeling relationship in graphql when you are using appsync and amplify library i will give you an example on how do you model onetoone relationship onetomany relationship and manytomany relationship in your applications so throughout this video i am going to use one of this example to demonstrate this relationship so this is one of the very common example so let's say you have these three entities you have departments and you have employees and also you have projects so let's see what are the relationship between departments employees and projects so one of the relationship that we are going to map is a department has a manager let's see this one so department has a manager so that manager is also included in the employees right so of course a manager is also an employee so a department has a manager so what type of relationship is that it's a onetoone mapping because one department has only a one manager right and also the second relationship we are going to do is a department has many employees of course a department has many employees so one department has many employees so what type of relationship is that it's a onetomany relationship or we denote it as one colon m or one colon n right and finally we are going to look at one uh many too many relationship as well so that is nothing but a project has many employees let's say a project so we have a project entity a project has many employees let's say many employees are assigned to one particular project and on the other hand a single employee can be in multiple projects as well so one project has many employees and one employee can be assigned to many projects so what type of relationship is that that's a manytomany relationship all right guys so let's see how do we map this relationship quite easily with amplify library all right so head over to amplify library website so at this particular link now guys in the previous video we talked about amplify library and graphql introduction so if you guys want to watch it i will put a link up here and once you are in the documentation you should see how to install the amplify library so it's basically a simple npm install and then you can use amplify init to initialize a project in aws cloud so let's take a terminal and create a new directory called relationships cd into relationships and inside this folder let's create an angular application ng new my app well you can use angular react view or any other frontend framework but in my case i use angular yes i want to add routing and i'm going to use scss so once you have this created go into the folder and open it in your code editor i'm using visual studio code here all right now i open up the integrated terminal and let's initialize a new amplifier project by typing amplify in it okay the edit i'm using is visual studio code and it's a javascript application it's angular application so if you guys like spin up react application use react or view in my case angular and the source directory it's src folder and my build file resides in dist slash my app my app is the name of my app and hit enter build command is this one ng serve all right and now it's using cloudformation to initialize the project so do i want to use aws profile yes because i have this particular profile for my youtube alright so now project is now successfully initiated in the cloud so now i can add api so let's add our graphql api by typing amplify add api and hit enter choose graphql and hit enter again an api name i will just choose the default name my app and the authorization type well i'm going to choose cognito user pool and then it asks me okay do i need to add the default configuration to the cognitive user pool i will just select default configuration if you want like you can go through the setup and customize the configuration now it asks do i have a graphql schema in my case i do not so i will type in and hit enter do you want a guided schema creation yes then it will suggest me like three types of schemas no single object with fails one to many relationship and fine grain access so in this case i will choose one to many relationship that will give me a blog post schema and do you want to edit the schema now i will hit yes and now it's going to open up the schema file so minimize the integrated terminal and so this is the created blog post schema so in our case we don't need this one because we have department employees and projects so i will delete it so let's start building our schema so first type is department so what field does the department has it has an id of id so capital id is a common type that we denote id in graphql and department has a name of string yeah that should be it so our department has an id and its name and now i am going to use a directive from amplify library called at model so this at model directive will create a dynamodb table for department and also it is going to create all the graphql mutation queries and subscription for department model or department type so what is the next entity so let's create our employee and let's use the same directive here because we want to create a table for employees as well so our employees also has an id and a name and let's add h as well so now let's set the first relationship so what is our first relationship a department has a manager so in the departments let's add another field called manager and that manager is again a employee right now before that let me just uh take out this s and keep it single sorry about that so this manager is again an employee so manager is type of employee okay so we are referencing this type when it comes to manager so this is id and string a scalar type in graphql but when you are referencing another type these are called nonscholar type so in order to make this a one two one relationship let's add another directive called connection so we are making a connection on manager to this particular employee type now here's what happens when amplify compiles this schema with these directives it's going to create this department table in the dynamodb and it's going to create id attribute name attribute and it's going to create another reference for the manager by adding attribute called manager id so department table then has a reference to the manager's id so let's see this in action so i'm going to open up the integrated terminal again and hit enter and then i will type amplify push so now amplify is going to compile the code and create a cloud formation template and then it create all the resources so answer yes to all these questions all right so it has given me the graphql endpoint and let me go to aws console and see the resources that it created and if i go to appsync i should see my new api my app and go into that if you go to the schema you should see the full schema that it has created you see it has added all these input types and mutations subscriptions etc so let's go to dynamodb as well because it should create a table for department and employees so these are my two tables and also let me go to aws cognito because we are using cognito authorization so if i open it in a new tab i should see my new cognito user pool so here's my user pool so in the appsync console let's try to create a query let's try to create a department now i first have to login with the user pool because that's how the authorization happen so in order to do that i need to provide the client id and username and password of a particular user so let's create a user here in the user pool i will click create user and okay manoj is fine and i don't need to send any mutation add a temporary password guys and just untick this one manoj test.com and create the user okay user is created and now go to app clients because we need to just copy the client id and make sure you're not using the one with the secret key but without the one this one so just copy in the client id in the app sync console client id paste that in and your password and the username and now i'm logged in as manoj okay now if you click docs here you should see your schema and let's see what are the mutation that i have if i click mutation link here i have this create department mutation right so let's try to create that one we'll type mutation create department and the field name is create department input so what are the input types so if you go to create department you should see the input type is of this particular create department input type just click that should see what are the required field and i should give the name and then let's call it engineering department and department manager id since i don't have a user created or the employee created i can't give it yet so let's leave it blank and later on we'll update the department and the create department's outputs are departments so in the department i can just print out the id and the name right so now let's run this mutation click this button there you go it's created so let's make a note of the department id and i will just copy this and i will put it in a notepad okay so this is the department id and guys let's create a employee as well let's create employee you can just name this one any name but when you're choosing the field type make sure to pick the right one okay an input type colon and open braces if i go to mutation always use the documentation it's quite easy and create employee you should see the input type is create employee input and it accepts name and edge right so name let's say john doe and h t1 and the mutation returns an employee see so employee has a name and id i will just print out the name and the id okay let's close this out and click this one and select create employee okay john doe is created let me just note down these two as well john doe id is this one let's create two more employees jando of age 28 and create the employee and just note the id as well here and also another employee manoj fernando create employee make a note so now that is created so let's see if it is like updated in our database right so if i go to dynamodb and if i go to department table and into the items i should see my first department is created see department engineering department can you see i still don't have that manager id so let's add a manager to our department so i will go to appsync and this time i'm going to use the update mutation mutation let's call update manager so the mutation name let's see what is that name update department okay update department and as for the input type okay update department input if i go into that i i can individually update these attributes so in this case i need department manager id so let's set john doe as our engineering department manager department manager's id so let me quickly copy john doe's id here paste it in here department id that will return me uh the name okay i can just return whatever the values here and let me just run the update manager mutation oh we got an error because we have to like give the id of the department as well so department id that we are going to change is this one so this is the engineering department sorry about that so of course you have to add the department id that we are going to update so make sure to add the department id here and the department manager id which is our john dose id right and then run again all right so it is updated so let's see if it is updated i will click refresh and open this up you see the department manager id so this is how we create one to one relationship now let's add the other relationships as well so let's add this one a department has many employees i will go to my schema now department has a manager one to one relationship and department has many employees so let's add another attribute here it's called it employees and that is an array of employee type so its employees are array of employees so arrays is denoted with brackets so we are referencing the employee type in an array because it's a list of employees right and let's add another connection here now guys when you add this connection it works so when you create one too many relationship so in this case department has many employees when you're creating an employee in the employee table it should have an attribute called department id say department id yeah something like that so this will reference the department so every time you create an employee we should have that particular id now there's a small issue when you just add employees it just works but this particular attribute name we get it as department employees id so it's basically get the type names department and the employee and the id right because if you can remember our manager it was called department manager id similarly it will infer a attribute name called department employees id right this doesn't make any sense so in order to have an attribute that makes sense let's create a named connection now these are named connections so name connection is quite easy just add a brackets and type name and then you can just add any name here this is basically a label guys some reference so it can be anything so let me here just call it department employees and once you are adding a named connection you have to have another field in the corresponding table so this is referencing the type employee so in our employee type let's add another reference to the department as well so let's call it department department and it's the type of department and let's add the same name connection here as well so we have to do this by directional mapping on in order to get this thing working right so when you add that guys this name could be anything what changes is the attribute name so earlier if we weren't using named connection the attribute name could be department employees id now it will take the name as employee department id so that makes sense right because employee belongs to department so employee department id makes sense all right so now let's compile our schema again so how can we compile it take your integrated terminal and type this command amplify api gql dash compile so this will recompile our schema and update our cloudformation stack now let me reiterate again of course you can like take this out and only keep the unnamed connection right because department has many employees this just works without any doubt right but the attribute name is a weird attribute name so in order to have a meaningful name something like employee department id we need to have a named connection okay it's successfully compiled now let's push our changes amplify push so once it is completed let's go back to our aws console to appsync console maybe you have to just log out and log in back now if you take the docs and go to the mutations let's see when you create an employee what are the input types you see there's the new input type called employee department id you see now the name matches quite fine because employees has a department id so let's update our three employees with their corresponding department shall we so i will go back to the scheme and let's use this update employee mutation update employee and the input type is off let's see always use the reference the id of the employee is let's start with john doe id and employee department id so let's add the department engineering department id this is this one and you can just get the name if you want and then i will update the employee all right it's successfully updated similarly let's update the other two employees as well jando just change the employee id here don't change this one because you are adding to the same engineering department so that is the department id and run the update employee again okay jendo is updated and finally manoj employee id change it and run the mutation update employee okay now it is updated now let's try to query a department and see so if the department has these employees get department what is the query so this time it's not a mutation it's a query click query and get department query get department and id so we have to provide the idea for department and that gives me a department click on the return type here department and you get all these information right so let's print out the department name and the manager so manager again system type of employee you see manages another type of employee if you go into that you can just print out the manager's name and go back here so what else do we have we have employees as well so employees and employees are a type of employee connection it's a type of connection and it has these items array because employees are a list of employees and items are list of employees click into the employee and everyone has a name and let's print out the age as well why not so now let's execute this query i will hit play button and click get department there you go so we got the data back so our department name is engineering department our manager is john doe and these are the employees employees employee one two three manoj jando and john doe nice now i want to show you one other thing if we go to dynamodb table and do a refresh on this and if you go to employees table first note that you have the employee department id attribute and secondly if you go to indexes you should see it has created a global secondary index on employee department id key so dynamodb has internally created this index on the employee department id so that it can query using the employee department id efficiently awesome so now let's add the manytomany relationship so what is our maintenance relationship it's basically a project has many employees an employee can be assigned to many projects so let's go to our schema now we need to have another type called project and it's also a model we need to have a dynamodb table and all the mutations and queries and it has a id project id and let's say there's a project name as well that should be enough so what should be the relationship the project has many employees yeah so we can simply add employees of type employee array make sense so employees it's an array of employee right and we can just make this as a connection right if you want like we can create this uh named connection as well and how about the other side employee can be assigned to many projects so employees also can have multiple projects right so if you just type projects and it's a list of project we can just make this as a connection as well right so we have both the relationship employee has multiple projects and project has multiple employees but guys when you are mapping main to many relationships and if you are only using two tables when there are a lot of data the relationships get quite messy because you see the employee table has the relationship to the projects and the project has relationship to the employees and one employee could be in multiple projects and one project has multiple employees so you have to like have so many number of records in these two tables it get quite messy quite fast so one of the ways that we can like model it in a different manner is using a third table we can create a third table and create two onetomany relationships and then achieve this manytomany relationship confusing let me just show you so let's create another table called or type called let's say employee projects right so when we are naming this table it could be like employee projects or project employees whichever makes more sense right so in this case both seems fine employee projects or project employees so let's create a model here and this particular table also has an id attribute and i'm going to take out these two early records this one and this one okay so we can start with a clean slate so what are we going to do we are going to create this particular table employees projects table and create two onetomany relationship employee table to employee projects table and another onetomany relationship from project table to employee projects table so let's create that shall we so employee has multiple projects and that is the type of employee project not employee type but employee project and it has a connection and we'll call that connection uh employee projects remember you can name this anything and once you create one record here you have to have a reference record here as well so let's call it employee because this is the type of employee and the employee type and let's have the same connection name here so we created one of the onetomany relationships as we have created onetomany relationship in department and employees you see this one similarly we created another onetomany relationship between employee table and employee projects table right so we'll do the second onetomany relationship from projects to employee projects so project has many employees and that is an array of employee project let's add a connection with the name project employees so let's create the reference attribute here that is project because we are referencing the project type and that is of project type and have the same named connection here also so now let's recompile this amplify api gql dash compile okay we got no errors and one other thing guys uh this particular employee projects model and when we add this particular at model directive it's going to create all the queries mutation subscription and everything right but we are only like adding the records or creating this employee and project reference in this table we are not going to query anything from this one so in order to tell amplify don't create query types we can pass additional information with parentheses let's say queries null so it's not going to create any queries but only the mutations all right and let's do another compilation okay it's compiled successfully let's do amplify push to push all the changes and like update our resources in aws okay guys it's updated so let's go to our aws appsync console and let me log out again and log in and now if you look at the schema and if you go to mutation you should see create project and update project that means it has created project type as well so let's create a project guys so i will type mutation create project and let's use create project field and input so what is the input click here so basically ids auto generator you just have to give it a name let's call it uh project x and then let's get the id and the name okay execute it create project there you go it's created and let me take a reference on the project id project x id is this one and now let's add manoj and jane to this particular project x so those are the two employees assigned to project x right and how do we do that we are going to create an entry in our employee projects third table so let's use create employee projects mutation so i'm going to use mutation add employee to project and we are going to use create employee projects and as for the inputs we have to provide let's see what are the inputs here employee id and the project id so employee projects project id so what's the project id so we are going to associate him uh with our project x so let's get this project id and who are we going to associate the employee id of chain all right so let's get the id out so this will assign jane to our project text so let's add the employee to that project okay so it's added and let's add manoj also so let's get the manoj id and i'm going to add manage to the same project and let's add the employee to that project okay great so let's now query that project and see if these two employees are actually added right so let's go to docs again query get project by id get project get project and id so what is the id project text id here okay and the get project returns a project so inside the project what do you have you have name and employees you see onetomany relationship there name and employees now take a look at the type guys this employees are type of employee project connection yeah so uh if you go into this should see i will get a list of employees so i can just query that items and these items of type employee projects so employee project we have employee and the project so let's get the employee again and i will take the name employee so it will give me the name of this employee hope it's clear so let me just query the project get project here we have it so our project project x it has these two employees so one project can have many employees so let's see the other side that means one employee can have multiple projects so let's set manoj to another project shall we so first let me just create a new project i will use the previous mutation i will call this as project y and let's run this one create project so it's the one so i created it so this is my project y copy the id here project y now let's associate manoj to that project y so project y id i already copied it so let me just quickly paste it here so this is the id of project y and the employee id of manage so that is this one all right and i'm going to execute add the employees to the project great now if we query manoj then we should see all the associated projects let's query that get employee query name let's get employee okay get employee and basically you need to give the id of the employee which is manoj id and now look at the return type so this is the get employee and you will get an employee type out so in this employee type there are a bunch of things right first we can get the name and we can get the edge and the department i will just omit department for now because you are concerned about the projects so i will type projects and the project is type of project connection and go into that you get items that means list of projects and each of these of our third table type which is employee projects and inside it we can simply get the project and project age type of again project and just get the name nice so let's run this query and it should return both project x and y ideally let's see get employee there you go so manoj is part of project x and project y great so now we have completed all these relationships this video is about real time updates with graphql subscriptions with aws appsync so we have been building upon this particular todo application or other automated to do application where we can like click create to do button and generate list of todo's into this particular list so currently we have to do 5033 and if i click create to do again i should see to do 36 all right so when you click create to do button it will call upon a graphql mutation and create that particular to do in a dynamodb table see if i refresh it i should see three item now let's delete like two of these and now if i click get to do's button here this will call upon a graphql query so in that last video we looked at how to implement both mutations and queries so as our server we used aws appsync so appsync is our graphql server which is a managed graphql server and in order to like work with this particular server we used amplify library now here's our app sync server so this is the schema now in order to work with this server we use javascript amplify library the amplifier provides two ways to communicate with graphql first by using uh amplify graphql client can you see this one and also using aws appsync sdk this one we used amplify graphql client to simply create queries and mutations and now today we are going to use that to create subscriptions as well so what really is a subscription guys subscriptions are basically watching over changes in graphql for example you can watch over particular mutation let's say a create to do so when one of the client creates a todo so that change or that new todo will be distributed to all other connected clients now let me show you this one now if i take a new browser window and go to localhost 4200 to do same angle application we can simulate another client okay so in the first client or the first browser window if i click create to do i will get the to do 41 but my other client will not see that change right in order to see that change yes like refresh it or like click our get to do's query there you go but with subscription we can transmit all these changes in real time to all those connected clients so let's see how to do that so i'm going into my code so this is how to do component html that creates this particular page i'm going to do a one particular change instead of clicking this button and generate this automatic to do let's actually allow the user to type something and then click the to do and then add that custom name as the title of our tutorial shall we so this is the html so i'm going to take out this list to do buttons and add the input box here of type text so this will be the place that clients are typing the todo name and let's add a label to do name so we can pass the todo name to our create to do function so let's do that to do name and let's change the todo function as well i will go to to do component.ts and this is our create todo function now you will receive the todo name as well here so instead of this random todo name let me just add the actual todo name that is passing from the client so these two attributes let's keep it as it is now before i pass that name let's check whether it's not empty if you have a particular length on the todo so that means there's something in the todo and i will put that in the if block so now what happens is we will formulate the to do and then we are going to call upon this create to do mutation right since this is a synchronous function we are waiting for that and once the result is received we are pushing that to do into our old todo array then in the template we are looping over that all to do address and printing out this to do name body and to do completed right now let me change these two as well i will take it out body and completed because these are hard coded values i will just keep the video name let's see if that looks nice on the browser nice now we can like type something back up at 5 a.m and click create to do yeah there's a small error instead of just to do name you have to reference the value here as well right so to do name dot value will give the name of the todo so now let's try that there you go now it works let's clear this input box as well to do name dot value equal null wake up at 5am click the to do now it's getting cleared okay so how do you attach subscription here or how do we push these changes to all the connected clients now guys when you create our schema amplify has already created all these mutations queries and including subscriptions as well so if you can remember in the last time we have been referencing our service api service which is generated automatically by amplify so this api service also has our subscription code as well now this is our api service.ts can you see there's this subscriptions called on create subscription and we have on update subscription on delete subscriptions so from our client we can like subscribe to this subscription for example let's say oncreatesubscription and once we do that we will receive any newly created todo's from other clients in real time so let's try that so i'm going to reference this oncreate subscription so this is actually the type and if i just search again you can see on create to do listener returns an observable where we can subscribe to right so let's use that i go to my to do component and here in my create to do method instead of pushing this new todo into our old todo's so i will let the subscription to add that particular new todo into our old todos array so let's comment this one out i will just remove it i will take this variable out as well so we are now just waiting for create to do to happen and i will take out this debugger point as well now in our ngo ninit lifecycle method let's subscribe for that particular subscription so how can we do that this dot api so we are referring our api and here oncreate to do listener we are going to subscribe to this particular listener and there it will send me the new to do as the function parameter to our next method so we are subscribing to this oncreate to do listener and in the next function it will send me the new to do that is being created by another client so this happen in real time guys well a graphql subscription creates a website connection with all the connected clients and send this information right so the server sends this in real time so now let's add this to do to our todo array let's get this new to do into a variable so that is inside to do dot value dot data dot create to do so you have to like go into this particular object we are going to push this to do into our old todo's array new to do so let's see if this works now again we are subscribing to this oncreate to do listener at the ngoninit method so whenever the component is loaded it will subscribe to this event and once it is subscribed it will receive all the new todos that is created by other clients in real time so once a new todo is received we are like adding it to our old to do survey let me test to do test create to do well i get an error it says cannot read the property of push of undefined that means this. is undefined so let's see yeah here guys let's use the arrow function instead of the normal function so it will correctly reference this with the arrow function okay so let's try now hello create to do now let's get added okay let me just clear out all these items in the dynamodb table and let's test this in different clients so i will take two clients here so this is my first client and this the other client so let's test this out i will type what to do wake up at uh 5 a.m and create to do there you go it get added here and in the other client also it was visible now let's take another client i will take a safari go to the same local host 4200 to do so this is safari and this is chrome this is also chrome let me add another one eat breakfast there you go so can you see now all these connected clients they will receive this newly added todo through that subscription in real time and they will render their template today we are going to demonstrate the offline capabilities of appsync there are two ways of working with appsync basically you can use the amplify graphql client which is a very lightweight client where you can easily interact with your appsync backend but it does not support advanced features like offline etc so if you need advanced features we have another way that is using aws appsync sdk so today our main focus is using aws appsync sdk and build a small offline application and i'm going to use angular framework today because there are a lot of resources for react but very few resources for angular and there are some gotchas we have to be aware of so let's get started so i will take a terminal and i am in my desktop and let's create a directory offline cd into offline and i will create new angular application ng new my app now add routing guys use a ccs and let it create okay cd into my app and open it in visual studio code or any editor you use i will take integrated terminal here and now we have to install couple of libraries there are four libraries that you have installed first one is the amplify cli you have to install it globally so write npm installed hd at aws amplify cli and then you have to install aws amplifier locally and amplify angular and also aws appsync this is our websync sdk and graphql tag library so let me just copy the first one install that i've already done that let me show the version that i have so i have 0.1.45 and let's install the other libraries npm install aws amplifier locally amplify angular map sync sdk and graphql tag all right it's done now if i go to the package.json have a look at the versions that i have installed now before building our application we have to do a bit of initial configuration to avoid some compile time errors when compiling angular with amplify and appsync so first thing is you need to go to src and find your index.html at this script tag so basically it's a reference to the window object which is referred as global so we need this one okay and don't worry guys i will add a link to the github repository so you guys can easily copy paste the code okay first thing is done and secondly you need to go to tsconfig.app.json file and under the compile options under types add node so this is required when compiling application with amplify and now you need to go to polyfill.ts sort of this file on top of the file we have to add two things first one is a reference to the global object there is referencing window and another reference for the process so these two are required all right and also we have to do another configuration in tsconfig.json this particular file here you need to set the attribute called skip leap check to true otherwise you will get some errors when you add the appsync sdk so make sure to add these two i think these are the main configuration we need so now let's initialize an amplify project so i will take the integrated terminal and clear the console i will type amplify init hit enter editor vs code javascript angular src is our source directory and build file will be in dash my app which is the name of our folder and build command accept the default hit enter start ng server right now it's asking whether we want to use the aws profile in my case i will had yes i have multiple profiles i will choose youtube you guys can choose default or if you have a profile configured for aws use that one so it's creating this stack i will fast forward okay done now we need to add some appsync features so uh let's clear this out and i will add the auth first because we need a login and let's use cognito user pool authentication for our small todo application and i will use the default configurations let's add api as well amplify add api choose graphql provider api name my app is fine and here use amazon cognito user pool do you have an updated graphql schema no yes i need a guided creation single object with fields to do do you want to edit yes and she'll open it up and here guys i will just take out the description as well just want the name of the todo that's it so i will save it and hit enter okay now we need to do amplify push to update the resources in the aws select yes so it will update both author api and now take this up a little bit so you guys can see do you want to generate code for your newly created graphql api say yes then choose the code generation language now here guys you can use typescript because here it will create those mutations and subscription separately where you can easily import it so use typescript accept the defaults say yes i want to generate all okay there should be the file it should be in source api dot ts hit enter now it's creating the resources let's give it few minutes okay it's created now if you go to amplify folder and into the backend api my app and into the build folder you can see the graphql schema that it's generated so you have all the queries and mutations and subscriptions all that right and also if you go to your source folder you should see a new folder created graphql inside that you should see the mutations queries and subscriptions as well right now we can easily import them into our components so let's create our components so how many components do i need i need let's say two components ng gc first one let's say auth that will include our login screen and i will create another one in ggc to do that will include our todo application and also i will create a service file in ggs appsync so let's create a service uh called appsync as well so that is created so let's see the generated files both component to do component and here our appsync service okay first and foremost guys we need to register amplify angular module and also our service app sync service so let's import it in the app.module.ts file so this is our main module file here let's import amplify angular module and amplify service from aws amplify angular library so the module put it inside the imports and amplify service put it inside the provider now we need to import the appsync service as well so this new service that we just created so let's import that app sync service from app sync service should be simple as here and add this to our providers list as well now when we push our websync services it has created this uh aws export.ts file rather js file you can find it in your source folder here aws export.js so it has all the reference to your backend resources like where you use a pool use a pool id and absyncroftql endpoint etc so we need to reference this in our application and initialize at start so go to main.ts file here and let's import this aws export file i import it as amplify import amplify from dot slash aws export and also import the amplify library itself import amplify from aws amplifier now let's configure amplify amplify dot configure oops configure with our exported configuration okay now it will initialize successfully but we have to do one other thing as you can see uh our aws export is a.js file you have to convert it to ts we can do it using a script provided in the documentation of amplify for that you go to package.json and you have to replace the start and build command with a script so if you go to amplify documentation at this link and you go to angular and ionic menu and if you scroll down a little bit you should see the script here just copy these two lines so that is basically converting your js file to ts on the fly just replace start and build nice okay now let's add our login screen let me go to auth component.html so this will have our login screen clear out the content let's use the builtin directive for amplify authenticator so this will easily render our login screen so import this directive amplify dash authenticator into your alt.component.html now for styling this component you should add the styles as well just search your styles.css file which is here inside the source directory here and import amplify angular theme you can find this also in the documentation so let's see if the things are working fine so i will type ng serve so that will start the application locally let's see if there are any compilation errors it seems to be working fine we forgot to add one thing that is our routes so go to your app folder and in there app dash routing.module.ts so currently we don't have any routes so let's add some route i'm going to add two routes here first one is to do so if if someone navigate to slash to do it should load up the todo component so let's import the todo component up here to component from to do to do component and also the default route is our component that will render our login screen so i'm not going to add any route cards or anything as such right you guys can use it if you want what component from out slash what component okay and let's navigate to http localhost 4200 and i should see my login screen and see let's remove this uh default content i'll go to component.html and let's remove all this default content save that come back here it will reload the page and here's our login screen so make sure you don't have any errors in the network tab in the inspect element now let's add a very basic ui to our todo component as well so inside our todo component to do html i'm going to replace it with this bit of html so this is basically a rendering an input type or an input box and then a button to click so in the input box you will type the todo name and when you click the button it will fire this create to do event and it will pass the todo name along with that and under it you are going to render all the todo's in an array called all todo's so basically when you click the create to do we will add that to do into this all to lose array and that will show it in the screen so in the javascript side guys let's import our service first so i'm importing appsync service from our appsync service file and let's inject this into our constructor let's create a private variable called appsync of type appsync service so now we can use the sap sync service which itself is single returned throughout our components to talk with our backend services through the appsync sdk right but before that let's uh add some configuration or the code to our websync service so i will go to source app and appsync service here currently we don't have anything first i'm going to import appsync sdk from aws fsync and then we need aws export file as well because we are going to use the graphql endpoints from this file when configuring a web sync sdk finally we have to import auth and or type from aws amplify and appsync oauth link because these are necessary for sending out the credentials of the user when requesting the information so let's see how to use this i'm going to paste some code into the constructor okay let's go through that first i create a variable called client so this is basically aws fsync client that we have exported up here so as for the configuration we have to pass few attributes first one is the abstinence graphql endpoint url that we get from aws export file because inside aws export file we have this particular endpoint let me quickly show you here so that's the url and the region so again in the same export file you can get the region as well now we have the auth attributes so out type is basically it's a type of amazon cognito user pool because we have initializer user pool you can here use the api key if you want but use cognito user pool because that is the standard when it comes to enterprise applications so you go to pass the id token along with your request so that's where we are extracting the id token from current user session so we are getting the id token and send it in attribute called aw d token so that's our client basically and we need to export this client we'll have a variable up here let's say let's see and at the bottom of constructor let's assign underscore hc variable to our client and let's have another function called let's see so what does this sc mean anyways guys so uh let's see is basically hydrated client don't need the arrow function here so here we are returning this dot underscore hc hydrated okay a quick word about aws sync client so this is basically using apollo client so apple client is a graph giveaway implementation that has offline features as well so aws appsync has created a wrapper or another implementation from apollo client and that's what we are using today so in apple client we can cache all the queries in the local storage or any other storage medium and here it will wait until the cache is populated so then only it will return the client or the app sync client so let's see how to use this map sync service i will go to to do component we already imported the appsync service here and in our html we have a create to do function that will fire when the button is clicked so let's have that function implemented so i will create async function for that so it will pass the todo name here as the parameter and let's check if todo name has some value and if so let's create appsync client so i created a constraint called client and i'm awaiting this dot appsync dot hc so this two type sync is our service here and it sees the function that returns the hydrated trend right so we are waiting for the client and afterwards we have to create our mutation so what is the mutation is basically creating this to do in the database right so let's look at our mutations so if you can remember inside our graphql folder we have mutations so here's our create to do mutation so we need to export or rather import this mutation into our to do component so let's do that i will import create to do mutation from graphql mutations and also i'm going to import graphql tag library as well import gql from graphql tag and let's import other tools as well like the queries and the subscription because we have mutations so we may need the queries and subscriptions or at least queries so i'm importing the list to do queries from this queries dot ts file here inside the graph keyword and i have create to do mutation as well so how do we make this mutation guys so basically now that we have the appsync client we can simply use a mutate right and add the mutation together with the passing uh todo value so that is fine but are we using the offline features yet no right so in order to use offline functionality we have to make sure that if there's no network cache whatever the mutation in the local storage or whatever the storage medium that we are using for frontend application and thanks to apollo client it will maintain a map or a queue of all the mutation that is being added during the offline so it will maintain this queue so this q will have all the mutations let's say you added three to do's so it will first add the to do one into this queue offline queue and when you add the second to do it will push this to the queue that one as well so similarly it will like populate this queue in your local storage at the front end right so whenever the network is back so when you're online so it will start executing this queue item from the order that they were received so it will start from the first element of the first item and it will go to the last element that was added so now to call this functionality there are two ways first one is either you can use an update function that will be called when offline as well as when it is back online or you can use the build mutation helper from appsync sdk which is the recommended method so let's use build mutation for that i need to import build mutation up here first import build mutation from aws fsync and here let's get the result of the mutation into a variable called result sult okay and i'm going to copy paste some code here okay now let's go through this code so i created this constraint called result and i am awaiting the client again on a method called mutate so this is basically the function that called the mutation from the absync sdk so client.muted and so inside the parentheses we have to pass the build mutation function so the build mutation function so as we have imported up here so we say it's built mutation and inside that build mutation it accepts several parameters here's the first parameter so it is the first parameter is the client available client right web sync client rather and then we have to pass the mutation so which mutation are we going to call it's the create to do mutation right so create to do mutation we have imported up here and i'm going to grab that mutation using graphql tag library so gql so this will add proper graphql tags to our create to do a mutation and then the third one we have to pass the input type so we have not yet imported our create to do input so let's do that at once so we need to import the inputs as well so currently we don't have any inputs associated here so i will create a new file called inputs dot ts and here i'm exporting the create to do inputs let me paste that so from where did i get this so i'll show you uh so it's basically this text that i copied from our graphql schema so if you can remember our graphql schema is available inside of amplify folder in the current backlog api in the build graphql and here you have create to do input just copy this and come back here and paste it in here so simply add to backticks and export it now we can import it from here so in our todo component.ts file so i'm going to import that create to do imports from graphql inputs nice so now our error is gone so we are decorating that again with graphql tags and variables so variables is basically the inputs that we are providing it right so as we have already seen it is expecting and name the todo name and that is a mandatory field right so in our app sync backend we are generating this id automatically so we just have to pass the name here so i saw variable we are passing to do name dot value now we have to pass this as an object so let me just take it out i will add object literals here name has to be to do name dot value nice so then we are passing another query list to do squarey as we have imported it up here so we have imported list to use queries as well so why do we actually need these guys so in build mutation so what basically happens is if it is offline if there's no network what apple client does is it will use one of the queries that has cached earlier in the local storage so here it used the list to do query so it will read all the todo's or the list of todo's that it has cached earlier so it read it from the cache and at this newly created value into the cache or the list to do's array so it will read the cache and write the new item into the cache as well so finally we have to pass the todo type so that is also required so when the network is back it will play all the mutation that is recorded inside the cache and there's another concept called optimistic ui update so that is basically when there's no network obviously result is not going into the database right and it is stayed in the cache but we will update the ui even though it is not persistent in the database so that it will give a better use experience for whoever the user using the application so how to do that optimistic ui update so once we have built the mutation and it returns the results here let's push into the array that we are referencing in the ui so that is all to do and i'm going to push the result that is returned here so that is all to do and i think we have not references up here as well so let's add that variable up here all to do so of any type and down here let's push that item in the cache into this this dot altodos.push and it is inside the result variable dot result.data.create to do and let's empty our todo name value as well so it will look nice on the ui all right now uh when loading up this component i need to like show all the todo's that has been earlier added right so let's populate these all to do's with a query by calling the list2do's query using our appsync client so in ngon it i'm going to paste this code so i pasted this code so it's basically the stotapsync.hydradarclan so we are calling our service and then you get a client and inside that client we are calling the watch query so that will basically do a query on list to do's which we have imported up here and the fetch policy is cache and network it's basically check the check cache and then go into the network and we are subscribing to the data that is returned from the query and we are setting this total to do's to the data that is returned from here it is data dot list to do start items right now as i previously mentioned this code will be available in the github link below okay now it all looks good so let's see if it is actually working so i will go to my ui and do a refresh and make sure you don't get any errors and now let's create account click create account your username password you have to add capital and numbers there sign up okay you should receive an email to your email address get that code and paste it here and confirm it so then you'll redirect the login page again so type your password sign in okay now you're signed in so now let's navigate to to do okay i don't see any errors that looks good and let's try to edit to do shall we go to gym yes it does beautiful let's verify that i will go to aws.amazon.com and into my dynamodb log into your console guys okay and this is my table here click on that and in the items there you have it so it persisted beautiful so let's add another one eat healthy yep that is also added let's check that there you go now let's try offline so i'm going to click here and turn off my wifi so it's turned off and i will add offline to do let's see if i see a network request it is directly added thanks to our optimistic ui response but as you have seen there is no any network call so let's reconnect our wifi and and have a look at here you should see the request will automatically be made there you go this is the request that got automatically made and now if you go to dynamodb and refresh it there i have the offline to do beautiful if i refresh it again you see those are indeed persistent so this is what i want to show you guys i hope you guys enjoyed this and if you guys like my videos so if you want to see this nature of content please like and subscribe to my channel guys thank you very much