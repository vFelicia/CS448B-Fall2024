hey freecodecamp welcome to another the daily programmer web series video the problem today we're going to talk about is called color maze which is number 325 on the daily programmer subreddit page all right so here is a problem statement posted on the subreddit i'm not going to read through the whole description but i'll go ahead and give you an overview basically he attaches an image or two images the first image is your 2d array which has your color matrix and then your goal is to find a path from the bottom row to the top row which matches the sequence so in this case he gives us a sequence of orange green so our sequence is orange green so at the bottom row if you can find an orange node and then traverse to a green node and then again traverse turn orange to green orange green orange we've found a path which matches that sequence inside the provided 2d array so that's the goal again given a grid find the path from bottom to the top which has the exact sequence we're looking for and then inside here there's a couple of um criteria it says you can move horizontally and vertically but you cannot move diagonally and you're also allowed to move to um it is also allowed to move on the same node more than once so if for some reason you have to like go up the grid and then cut through somewhere you've already been that's allowed and then for the input the first line is a color sequence so again o space g would be our color sequence and then followed by that is our grid that we're trying to solve and then he says that you can output the path that solves the matrix or you can just go ahead and print out the matrix with that path um printed out inside of it with empty strings and all the other locations so for our case let's just go ahead and try to solve it to print out this um actual grid so we can visualize it and then we're not going to worry about trying to parse this input we're just going to you know write a function which takes in a sequence array and then also takes in a 2d array of our grid and so that's basically the problem let's go ahead and work it out on the whiteboard with a really simple solution all right so let's start off with a really simple um example here so again we have the sequence of o and g and we have this grid it's just um which is three by two so four rows by three columns and remember the goal is to start at this bottom row and find a path which happens to be this path that i'm motioning out with my hand from the bottom of the corner the top right corner where you can only move vertically and horizontally to match the next color in the sequence so again let's work this out by hand so the algorithm starting off is you pick the first index of your sequence so for this algorithm we're going to do something like a breadthfirst search where we pick the first index of our sequence so in this case we have the color o and we need to find the bottom elements so all the elements on the bottom row which match the current sequence that we're at so in this case we only have this bottom left corner which is equal to o so one more time we initialize and start with the first element of our sequence we go to the bottom row and find all the elements that match that sequence and then we can go ahead and push that location which is three zero to some type of list or q so i'll go ahead and put a three comma 0 here for ourselves our paths and that's iteration 1 so iteration 2 we go ahead and increment the color that we're looking at in the sequence we check the vertical and horizontal locations that we can move to from our current location so our current location would be um we pop off the first element of our current cells list so in this case we have three zero and then at three zero we just check can we move to two zero can we move to three one do they match the color that we're currently at in this case the only match that we find is two zero so we can go ahead and push two comma zero to our array and then go ahead and move to that location on our next iteration so iteration three we again we increment our sequence so we go back to the o here we pop off the first look first um element of this list so two zero which puts us right here we then add on every vertical in horizontal location that we can move to which matches this color of the sequence o and then one caveat is we can kind of ignore the one that we've already been to since that last previous location was this o there's really no reason to go back and check so in this case the only location that's a kind of a new location is two comma one so we can push two one here and then go ahead and move on to iteration number four so again iteration four we pop off the first element so we're put at 2 1 we increment our sequence then using the same logic we can just add on every location which is vertically horizontally adjacent to this location which matches the sequence of color g in that case it'll only be one one so we can just go ahead and add a one one here and then repeat our steps so iteration five we're pointing at o now we pop off one one which puts us at one one and then we check every location where the previous isn't equal to so in this case we can check this that and there and this happens to match o so we can go ahead and push one two iteration six we remove one two which puts us at one two increment the sequence and then we check and it happens to be that 0 2 is the only location we can go to and then for our final iteration seven we remove the slot and throughout all these iterations you basically check if we're ever at row zero we've kind of solved this problem so in this case we're popping off the first element we get zero comma two we check okay zero is equal to row zero so therefore we found a solution so this algorithm kind of shows you that yes there is a solution where you can get from the bottom row to the top row but then you might say okay well how do you keep track of the path that we took to get from there there to there so basically all you can do is just instead of having this array you can make this an object which has the i and j location you're about to move to and it also has the previous location as an attribute which points to another object so if you imagine we could have um each one of these is kind of like a node which points to the previous so in this case this one it's previous pointed to that this one's previous point to that this one's previous points of that previous points to that endpoints to that so ultimately if you instead of using arrays to build up your paths what you can do is use objects that point to other objects to kind of traverse backwards to the path that you found so in this case we'd have zero two points two one two points two one one which points to two one which points to two zero which points to three zero and then we can just print that out here and that is basically the algorithm for how do you use breadth first search to traverse this grid to find a path which matches the sequence and this will make a little bit more sense as we implement in javascript because like the whole keeping track of the path thing might be a little bit confusing but i think it'll make more sense when we see it encode and then also there's little caveats where to um like if let's say there's multiple start locations this algorithm will still work it'll just take longer because we have to pop off extra locations and move each one individually and i'm not going to work through a larger case because obviously this took a lot of time but try it for yourself hopefully it makes sense let's go ahead and implement this in javascript all right so just a heads up this implementation is probably going to be a lot harder than any of the other ones that we saw on the previous daily programmer challenges um but hopefully it can make sense in the after we go through all of it but basically again let's just get started we have a sequence which has an array of the sequence we need to iterate through and then we also have a maze constant which is the actual 2d grid that we need to find a solution throughout and then down here i have line 12 which is just calling a solve method passing a sequence in the maze and then we're printing out the path so let's go ahead and create a solve function here which takes a sequence and a maze and then inside this function what i'm first going to do is just declare a couple of helper variables so i'm going to say const rows is equal to maze dot length so that's just a constant which tells us the number of rows we have in the array and then i'll say const calls is equal to maze of zero dot length and that'll tell us how many columns are in the matrix and those are again just kind of helper functions that we'll use or helper variables we can use okay so another thing i'm going to do is go ahead and declare a generator so if you don't know anything about es6 generators you might want to read up on that but basically we want a generator so every time we call it it'll give us the color and then once we reach the end of the sequence array we just go back to the beginning and it just keeps on returning us the color sequence so let's say const colors is equal to and i'll say this is going to be a self executing function which takes a parameter of i which is equal to zero by default and again if you don't know what a selfexecuting function is is basically you create a function and then call it right then and there so that it returns something so in this case we want to create a selfexecuting function which returns a yield or which does a yield and that's how you pretty much do it using generators and es6 all right so again this is a generator function which is going to keep on looping over each sequence in the list and then once i goes out of bounds we go ahead and modify the length so it goes back to zero so this will give us og og og og if you keep on calling it again all right so we have a rows constant we have a columns constant we have a color generator constant which we can use to kind of implement our algorithm so the first thing i'm going to do is again the algorithm says we start at the bottom row right so we need to grab every cell that's in the bottom row so i'll go ahead and say let paths equal two paths or maze of the last row so maze of row minus rows minus 1 will give us that very last row and i'm going to go ahead and filter out or sorry i'm going to go ahead and map that to an object so in this case every index we want to keep track of so we could say rows of minus 1 j of j and then previous like we mentioned in the white board is just pointing to another object which is how we traverse back so in this case let me just reiterate if we grab the last row for each element in that row we're going to return an array which has an i a j and a previous attribute inside an object so here if i were to just say let's just print out paths so we can see what's going on here we see that paths is an array of five elements where we have i is equal to four which is the last row and then we have j of zero one two three and four right so that's kind of what we're gonna start off with and then we can go ahead and filter it out to only match the colors of our current sequence later on okay so now we have our initial paths we can go ahead and loop through our colors so this is how you can loop through an iterator or a generator in es6 if you want to basically just a normal for of loop so if i were to print out color here it should print out o and if i were to print out in the next iteration it should print out g and if i didn't have this break here it would just infinitely loop forever so i'm going to keep the break in there for now starting off we want to like we said on the whiteboard we want to grab and filter out anything that is out of bounds so first of all we can say paths equal paths and we're going to use like functional programming to just keep on modifying the paths array so we can first filter out every path that is out of bounds right so we could say if path of i is less than rows path of i is greater than equals zero if path of j is less than columns and path of j greater than equals zero so basically this will give us or this will filter to only give us the cells which are valid or inside of the grid because later on we're going to push values that might be potentially outside kind of a little bit different from the whiteboard algorithm but i'm just going to do a little bit different on this implementation the next step is we need to filter out every path that doesn't match the current color that we're at so if i were to just do filter paths of base of i path of j is equal to color again this will give us only the paths which match the current color that we're at and so in this case color o if we were to print output passes here it should make sense that it only gives us the fourth row of the last row and then that column one right because if you look over here that's the only thing that matches oh so again we take every element in the bottom rail we filter anything that's out of bounds and we also filter to only match the color that we're at which will give us this one location of o and then finally what we want to do is for each remember we pop off the first element and we add it to the end and we keep doing that so what we can do is just do a reduce function where we have kind of we're going to build up a new array and just keep on returning a new array with all the elements pushed to the end so if i were to say reduce where we keep track of the accumulator go ahead and pass an empty array to reduce and what we want to do here is just go ahead and say accumulator concatenated with and then i'm going to do the four locations so horizontal and vertical so i can say di of one dj of zero and then d i of negative one so this should be the direction going up direction going down actually i think that swapped direction going down direction going up um direction going to the left direction going to the right so for each of those directions we are going to we are going to simply map those to an object and that object is going to be our current path location added to the direction so if i do i is equal to path of i plus dur of d of i and the same thing with the j we can say uh j is equal to path of j added on to der jay all right so again taking a step back we started off with that one element right and then we're going to reduce over that array which is going to be one element and for each element what we do is we add every potential location you can go to and put that to the end of the list so in this case we're going to check we're going to add the element that's above which is what we're doing with this whole make an array and then map it and then for each mapping callback function we just take the current location of the path and add it to the direction so you can see here we have after this runs once we have a new array so path is equal to array of four where each location is the top bottom left and right location you can see some of these are out of bounds which is why we have this filter up here so that we filter on the ones that are inbounds and some of these locations may point to places in the grid which are not equal to the current color sequence so that's why we have the filter here and then that keeps on happening where we just take a spot add the four to the end take a spot add the four to the end and we keep on looping that until we find our very in case which again if we just say um if we reach the top row we can just go ahead and return her in so i'll say const first row paths is equal to paths i'll filter and we want the paths which match the very top rail so i'll say filter out the ones and give me the ones that are at the top rail and i can say if first row paths not length so that means we found one we just go ahead and return first row paths like so let's go ahead and remove the break statement and down here this is working as intended so it's printing out the path here right so we have the first location is 0 3 which is 0 1 2 3 which is here second location is 1 and 3 which is here the second location for that is two and three which is here and then previous again is going to be an empty object so i'll go ahead and stringify this so we can actually visualize what's going on all right so our algorithm or our function right now is currently returning this huge nested list where every previous is the previous node so again i'll just go ahead and walk you through this we start off with zero three which is here and then we go to one three and then we go to two three and then we go to two two and then we go to three one and then we go to four one and then we are done so again that's pretty cool but we want to actually visualize it inside the matrix here so let's write a new function which takes a maze takes a path and what it does is it returns a new array which has only that path highlighted so i can say print path in maze is our function and that's going to take a maze and that's going to take a path for paths and what we could do is just go ahead and create a new two by two grid so i'll just say blank is equal to arrays of based on length fill it with underscores and then map that to another array of maze.length fill that with underscores this needs to be zero so this will give us an m by m matrix here and we want to do is loop through all of our nodes or go through our paths so i need to write some type of helper recurser function recursion function which is going to just overwrite the locations of all the the paths inside the blank array with the original color string of our matrix that we pass in okay so one more time what this function is doing is we're recursively recursively diving down all the paths and then replacing the values or indices inside of our blank array with the corresponding values of our original maze that we pass in so down here i can say constant m is equal to print path and maze i could pass it matt maze i could pass a path and then i could say m to see what that gives us and we see down here it prints out the maze with the path highlighted cool so i hope this solution wasn't too confusing now that i'm explaining it i think this was pretty confusing but again this was a harder algorithm to implement and i also use kind of like a functional approach to using like as many filters maps reduce as i could um again if you have a different solution or you think you have a better solution that's more straightforward feel free to paste it in the comments and also if you like this video be sure to subscribe to freecodecamp and like the video below and i look forward to more few videos in the future alright thanks for watching you