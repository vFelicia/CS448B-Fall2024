learn all about the stack data structure you'll learn about its implementation operations and practical use cases par teaches this course he'll guide you through when and why to use Stacks enhancing your understanding of this essential data structure then he'll teach you the 10 most popular stack related interview questions to help prepare you for your next technical interview Hello friends hope you're having a fantastic day today so in this course we are going to learn everything that is to know about stack data structure stack is one of the fundamental data structures in computer science it has lot of practical applications and also remains one of the most popular type of interview questions that you can encounter in your technical interviews so my expectation is that by the end of this video you should be able to understand that what stack is when to use it the moment you see any type of interview question you should be able to identify that this is related to stacks and what are the strategies we are going to use to solve this problem so this course is is going to contain lot of important information we are going to start with understanding what stack is how it is implemented what are the benefits what are the limitations what are its characteristics time complexity space complexities and under what type of scenarios you should be using stack afterwards we are going to see 10 most popular stack questions that has been asked in technical interviews we will understand in depth that what those questions are how come stack became the choice of data structure for that particular type of scenario and how do we actually solve it so without any delay let's get started now very quickly let me give you a brief introduction about myself my name is par vas and I'm based in Canada I have been in IT industry for close to 10 years and I have bachelor's and Masters in computer science as part of the education I have worked at companies like Royal Bank of Canada and noia Microsoft and currently I'm working as a Solutions architect for the biggest theater chain in Canada called clex on the side I also run my own YouTube channel called destination Fang and I would really appreciate if you can go ahead and support me on that channel as well in my personal Hobbies I love watching movies playing video games uh going out on Hikes and doing all sorts of fun activities last year I became dad of two beautiful twin daughters and that's why we I have all of these teddy bears hanging around me so now let's get started with our course so stack is one of the fundamental data structures of computer science this is a linear data structure and typically Stacks are implemented using some sort of list function so it can be either array list or link list but the thing is stack is not just typical any single array or link list this is a special kind of list that contains a very specific property and that is called Leo property that is called last in first out so how does a stack typically works is that inside the stack you always have have to work with the values that you are entering is always going to end up at the bottom of the stack and then if you have to enter the next value it will remain at the top of the stack and you can only access the element that was last entered inside the stack so let's try to understand this with an example currently let's say that we have this an empty stack now for this stack if we try to add value number one so one is going to stay at the bottom of the stack and now for this stack then since it only contains one value if we have to see that what is the element inside the stack it will return us the result as one but let's say that we don't do that and we try to add one more element so if we add value number two it is going to come on top of value number one and then we add value number three we can add value number five something something something now the moment uh over here we decide that I want to get one element out from the stack so the moment we try to do that we cannot directly access this element three or two or 1 we will always have to access element number five first and once we kick element number five out or pop element number five out then only we can reach to element number three which means the last value that was entered inside the stack is going to remain at top of the stack and that is the only value we can access in any any given moment inside the stack and this special property of Leo actually comes in very handy for some very specific operations so before learning that let's try to understand that what a typical stack looks like in real world you can think of a stack of books or a stack of plates both of these uh simply un shows us that how does a typical stack works in the real life because if we have bunch of books stack on top of each other then we can only access the book that is currently present at the top of the stack and then we will start going Bottom one by one so same thing applies for the stack of plates as well and this would be the best way to understand that how does the memory is stored inside the stack and this is implemented using some sort of list function so inside the stack there are mainly three operations that we have to worry about first operation is called push operation so push means that you are entering some value inside the stack next operation is called pop operation pop means that some value that is already present inside the stack you you are going to access or fetch that top element outside of the stack and then that element will no longer be present inside the given stack and last operation is called Peak operation in the peak it is very similar to pop but you are not actually fetching the value out you are simply seeing that what is the current value that resides at that location so let's try to understand currently our stack is empty let me push one value so if I try to push value number three then three is going to be populated inside the stack then I can also push value number four then I can also push value number seven and so on and so forth now at this position I decided to do a pop operation so let me just simply do a pop operation the moment I do that the seven is actually going to be kicked out of the given stack and it is going to be return returned as part of the answer so now the seven is no longer present inside the given stack and it is over here that we are able to be fetch uh if I do pop operation one more time then we would have four also be poed as well and then if I try to do a push operation once again and try to add value number five then five is going to be present over here the moment I do Peak operation at this moment then I'm only going to be seeing that there is value number five currently present at the top of the given stack but I would still keep or leave this five untouch inside the stack I only see that what is the value associated with the peak operation and all of these three operation actually operates in big go off one time so there is a special way we actually Implement stack inside the list and that allow us to fetch complete all of these three operations in bigo of one time so now let's just take a quick look at the implementation for any particular given stack so let's start implementing the stack class we are going to use an integer array list to implement our stack class and now let's create a Constructor to to open an instance of the array list now one by one we are going to implement our three push pop and Peak method so let's start with the push method so for the push method we are not returning anything we are taking an item integer item as an input and we are simply adding it to the array list instance that we have created now for the pop method for first we are going to check that if the given items list is not empty then we need to return the very last element that was entered inside the stack or the last element that is currently present inside the item and we need to remove that from the existing array list so here for the pop method we check that if the given list is not empty then we remove the very last element that was entered entered inside our array list if that is not the case and if the given list is actually empty then we simply return the null value and same way let's try to implement the peak method where it is going to be very similar to our pop method the only difference is that instead of removing the element we simply need to get the value of that element and that's it so now we have implemented the three methods for our stack now let us also try to implement the ismt method so for the is empty method we are simply checking that if the given items array list if that is empty or not and that's it this is the complete implementation of the stack class now let us try to implement a main method and also run some operations on the given stack class so now we have implemented our main method where we are initializing a new stack so first of all we are pushing three elements onto the stack the values are 10 20 and 30 next we are going to be pecking that what is the top element inside the given stack so this should return us the answer as 30 because that was the very last element that we entered inside the list then we are going to pop an element once again that should also return the value 30 because that was the last element that was entered and then once again if we do the pop operation it should return value number 20 and in the end we are going to Simply see the peak operation so that should return value number 10 so let's try to run this code we before forgot to change the name let's try to run the code so we can see that for the very first operation the top element is 30 then the PO element is 30 then once again we pop element number 20 and in the end after that when we check for the top operation we can see a value number 10 so this is how stack is actually implemented but lucky for us stack is actually provided as one of the default application and we actually don't have to implement the stack class all the time this was just simply for your information now let's learn that what are some of the popular use cases that we can apply stack at and You by by knowing these use cases we would be able to quickly identify during our interview or any problem we are trying to solve to realize that whether stack would be a good choice or not so number one thing where you can think of using a stack is for any time you have to do an undo type of functionality so what does Undo functionality mean means we know that inside our computer or browser we have the functionality where it keeps track of every single step that we have gone over across any set of websites and then if we click the back side backspace button or if we do the undo button inside the software such as word or any other PowerPoint or something like that it is able to trace our steps back and then put us back to the previous state so how it does it is that it actually uses stack to store that information let's try to understand this with an example suppose we currently have an empty step and I'm trying to open a new browser session inside the Google Chrome so the moment I first uh go inside the Google Chrome I have a new empty stack being created now inside the Google first of all I decide to go to the Facebook website which means stack is going to mark that I visited the Facebook website right now through Facebook I decide to go to the x or Twitter website so next it is going to put the value of x on top of my stack then I decide to go to the Uber website so once again the same information is going to be recorded and so on and so forth now at this position of uber I decide to click on the back button or the undo button where I want to go back to the previous state simply the browser is going to pop the element that I have entered at the very last so this is going to be taken out now I'm no longer at the Uber place and whatever value located over here it is going to do a peak operation and bring me back to the uh Twitter page that I was previously browsing so this is a great use case now you can understand that how this Leo property last in first out property actually help us to solve a real world problem few other important use cases that we can think of for stack is to have it in the backtracking mechanism because how does a typically backtracking works is that let's try to understand this with a small example of trees so inside any given tree if you have to iterate over the tree you will have to understand that what was the previous state that you are iterating over and have you visited all of its children or not so let's assume that I have currently this type of scenario and I'm trying to go in the depth first search fashion now I know that this was supposed to be a course on stack but I'm just explaining you explaining you some simple theorem to understand that how stack can be used with different data structures as well so in the depth for search we actually go in one single Direction and and the moment we try to find some value if the value is found that is great if that is not found then we have to do the backtrack and do the do the same operation for the remaining children or remaining leaves as well so let's try to do that let's say that we are trying to find this particular element and we are doing a simple depth for search so first we are going to we are at we are located at this position so we are going to go to the left child once again to the left child and once again to the left child we did not find the element we were looking for but the thing is there might be some path that we haven't explored so we are going to do the back tracking and through this back tracking now we are going to see that hey are all the childrens of this particular node uh that I have tested no I haven't tested them so I'm going to check one more once again I did not find what I was looking for once again I'm going to do the backt track and through here I okay so now I have tested both of his children which means now I will need to do the backtrack operation once again and through here okay there are still some children that I haven't tested so I will go on the right and once again I will go on the left and I found the value that I was looking for and at every given moment a stack is going to keep track of every single information that we were iterating over so we can quickly backtrack to the previous position that we haven't iterated over let's try to understand this with some example so let's say that these values are a b c d e and this is f and I okay let's say that this is I so initially our stack is going to be empty then uh we are at position number a then we move to the position number B then we move to the position number c then we move to the position number D at D we realize we cannot go any go further anymore so we will pop D out and we will check that have we explored every single possibility at this C no we haven't checked so once again we are going to go to the value number e so we are going to add value number e over here once again we haven't checked all the possibilities uh sorry we check all the possibilities at e once again we come back to the C we check all the possibilities at C so we are going to remove c as well now we are at this position number B so for at B we haven't checked F so we will add F over here from F we haven't checked I and we are going to reach to the I and I was the item that we were looking for so we found our answer so we can simply say say that yeah this element is present inside this tree and we were able to smoothly iterate over the entire tree using backtracking because we had the stack that contained the last in first out property so now you start to understand that how specific or how important stack is let's try to understand one more use case that is that at any given moment you want to identify that whether the given sequence of let's say brackets or parentheses are they valid or are they in the correct order or not and doing this can very easily be done using Stacks how we can simply have a logic that whenever we identify an opening parenthesis we are simply going to add that value to the stack and whenever we identify a closing parenthesis we will remove that value from the stack and see that the value removed does it contains the same type of parenthesis or not so let's try to see the example in action and then you would be able to understand what I'm talking about so first we encountered a square opening bracket so we are going to Mark Square opening brackets then curly opening bracket and then a round round opening bracket okay so now we took care of all of these three elements now we are at this position and we encounter a closing bracket now the thing is in order for this sequence to be valid the closing bracket has to be exactly the same same way that that was for this particular bracket so let's try to do that so let's say that we pop this element out and over here we identify that for this circular closing bracket the value we popped out was also opening bracket which means this is a good sequence so we can move forward so now we no longer have this value next we have a a curly closing bracket so for curly closing bracket we realized that the value we popped out was also curly opening bracket so this is is also a matching pair that is good and in the end we found out that the last element is also a closing bracket that is square closing bracket and the value we popped out was also a square closing bracket so we found this pair which means this pair of parentheses is valid now the question is this is really important whenever you are building idees or compilers so things like intellig eclipse or jet brains or bunch of other compilers they all use this formula or the stacks to keep track of every single opening and closing bracket now imagine in this scenario that this last element say for some some reason this one is a closing circular closing bracket now at this moment we identified a circular closing bracket and we try to pop this element out and we identify that this was actually a square opening bracket which means this was a mismatch so if that is the case we can simply get rid of these uh these things saying that this was an invalid pair and that that is how we can use stack to complete these type of operations and we can do all sorts of like functional logic and all sorts of important fun stuff using stack so that's why they remain so popular in terms of technical interviews and now we are going to go ahead with the 10 questions about Stacks that we talked about completing these 10 questions will give you the full exposure towards stacks these are some of the most popular most like and most cast problems uh in terms of technical interviews all of them are really popular lead code problems and they have been asked in interviews tons of time so without any delay let's get started today we are going to solve daily temperatures lead code problem that is a medium problem and also an extremely wellike lead code problem so the problem statement is quite simple we are given an integer array called temperature that represents the daily temperature over a certain span period now we need to return a new answer from this given temperature array such that any particular item in that particular answers array should Define that how many number of days you have to wait in order to generate a warmer temperature compared to that particular day's temperature so let's try to understand this with an example suppose this is the temperatures array we are given now in the input you can see that bunch of different values for every single day's temperature now if we see on this very first day the temperature is 73 which means means how many number of days we have to wait in order to get a warmer day well a warmer day is right next which means if we just wait one more day we can actually get a warmer day same way for 74 if we just wait one more day we also get a warmer day because next day's temperature is 75 now at the 75 if we have to find a warmer day then we have to find a day that contains higher temperature than 75 which means this temperature 76 is higher which we can see that that is actually 4 days away so over here we will have to actually wait 4 days in order to get a warmer day same way for the 71 we have to wait 2 Days in order to get a warmer day at position 69 we only have to wait one day to get a warmer day at 72 once again we will have to wait just one day because next day is 76 which is warmer at the 76 we do not find any particular warmer day subsequently which means we cannot find a warmer day so we are just going to mark this as zero that no warmer day exist in front of the value 76 and last one is 73 so since this is the very last entry we don't know what the upcoming temperatures looks like so we are also going to return zero and this is the answer array that we need to return uh that defines the temp days you have to wait in order to get a warmer day from any particular day okay so first let's try to understand a Brute Force approach to solve this problem the idea is very simple we simply go to a day and then we keep on iterating the array until we find the next day that has higher temperature the moment we find this one we actually find the difference between the index positions and whatever the difference is we Mark that in the answer so for this first one we can mark first as the answer for the second one once again we are going to repeat the same process we are going to iterate over every single value inside the array till we find a higher value and which we find 2 days later see same way we are going to keep on repeating the same operation and eventually we would have our entire answer array to be populated now this is the most simplest method but we can inherently see some issues with this approach the number one issue is that at any given position we will actually have to Traverse over maybe the entire rest of the array in order to find the optimal solution what if uh let's assume that this instead of being 50 Maybe This Was 80 and we don't have any particular solution in mind we would have still iterated over the entire array and then once again in in order to find the lower temperature for this next element we would still have to iterate over the entire given array maybe this was 82 so in this this case this is an inefficient approach and if we see time complexity for Brute Force approach is going to be biger of n Square in the worst case scenarios so let's try to see if we can improve upon this time and space complexity or not the thing is at this given location at the very first moment we don't know that what is the temperature that is higher than this one because we have only iterated this one element right but what if we are at this element we can at least predict that how many elements actually has lesser temperature than this and based on that we can immediately update their temperature and we can immediately say that for if we are at let's say value number 75 then at 75 we should be able to tell that 74 is only one day away from having its warmer day and same way at 74 we should be able to tell that 73 is actually just one more one day away from having a warmer day same way at 72 we should be able to tell that 69 is only one day away so how can we actually do that for that we will have to find some way to actually iterate the array in One Direction note that what the current temperatures are and based on that we will also have to check that what are the immediate temperatures that are actually smaller than this current temperature or greater than this current temperature so that we can mark their answers in order to do that we will have to use an extra data structure to store the values of all the temperatures for which we have not been able to find the warmer days second thing is for any particular temperature not only we will have to find the warmer day we will also have to find like the immediate warmer day so for this 745 is actually greater than both 74 and 73 but we should not waste our time marking this 73 as having a warmer day as 75 because there is 74 that is more closely associated with 73 which means we have to worry about the immediate before elements so we are traversing in One Direction but the at the very quickly we will have to understand that what was the last item we were at before moving to any particular previous elements so the best data structure in this case is going to be a data structure that contains the property of last and first out and the answer becomes very simple that we are actually going to use a stack to solve this problem now how we are going to use the stack is actually quite interesting let's first understand couple of properties number one thing is we are using the temperature to compare the difference between any two given values which means we are dealing with the value of this given array but in the answer we need to store that how many number of days are apart between any two entities and that we can find using the index values why because at index value 0er we have this value 73 and at index value 1 we have this value 74 which means 7 uh index value zero is only one day away from finding a warmer day because index value 1 minus index value 0 becomes actually value number one so this is how we are going to find the answer which means in the stack it would make more sense to store the index positions rather than storing the actual values but using the index positions we can very quickly look up inside the array find the answer and then subsequently Traverse the answer so after this long explanation let me walk through the solution that I'm proposing So currently we are at zeroth index the value is 73 currently we don't have any value inside the stack so we are going to add index zero inside the stack okay and now we are at index position number one the value is 74 the very first thing we are going to do is we are going to check that whether the value located at zeroth position which means the value located at temp of zero if that is actually less than the current index positions we are at so if that is less than the temp of one which is correct condition because this one was 73 and this is 74 which means 70 this value can be popped out of the given stack and we can actually Mark the answer for this one by doing the subtraction between the current element minus the index position that we just kicked out from the stack so this is going to be just one where we did a simple equation 1 0 okay now we are going to put 74 in the stack but we are going to put the index value so now in the stack we have index position number one now once again we are at index position number two so this value is 75 75 is greater than 74 which means we can do 2 1 and the answer is one so we can store that that 74 is one day away from finding a warmer day now we popped out one from the stack now let's add ENT entry number two inside the stack okay now we are at this position 71 So currently 71 is actually smaller than 75 which means we don't for 75 we have not yet found a small a warmer day so we are going to add entry number three inside our stack as well next we are going to be at position number four which is 69 once again 69 is actually uh less than the current Top Value we have inside the index which means we haven't found a warmer day for this top element and we are going to add one more element uh that we haven't found a warmer day for okay now we are at position number 72 so 72 is actually greater than this value the value at index number four so we can actually uh find the answer for index number four so let me just go okay so this is for index number one zero we have one we have for two we don't have for three we don't have but for four we found the value that is 5 4 so we can add 1 as the answer for index number four Once Again One the moment we pop out index number four we we should not be pushing index number five yet because we still have to check that whether five is greater than index number three and yes it is once again greater so for index number three we are going to Mark the answer as two and same way for index number two we are also going to Mark the answer as uh so sorry for index number two we are still not able to be able to find the answer because this is 75 and this is 72 so we are going to have index number two still living inside the stack and then we will have index number five now residing in the stack now we are at index number six so this value is 76 76 is actually greater than 72 and so in this case we can actually mark down the answer over here as 1 for this index number five and we can get rid of this index number five now once again this index number two is also smaller than index number six so we need to do the difference 6 2 so we find answer four and we are going to populate answer four over here and then we have an empty stack which means there are no more values we need to check so we are going to add value number six inside the stack and then in the end U next value is value number seven so 7 is 73 73 is actually smaller than the current stack value we have so we are also going to add value number seven inside the stack and the moment we reach to the end we are going to fill out all the rest of the elements by zero that there are zero days that we have been able to find the answers for and this is what we can return in the answer so you see how using a stack we actually need to Traverse over just once on the given temperature array and then we have been able to find the answer which means this is a much better approach and this is the optimal solution compared to our Brute Force solution so let's try to see the time and space complexity in this case the time complexity is actually going to be big of n because we are simply iterating over the temperature array once now it could be possible that for some values we might have to go back and find the values that are smaller than that that where we are doing multiple operations inside the stack but that that number is going to be limited because we are being told that we can find out that how many values are there and uh we are only iterating over the values for which we haven't find the answer and uh in terms of space complexity once again in the worst case scenario this is going to be big of n because we are using an additional space additional stack to find the answer answer so the coding solution is actually quite straightforward first we initialize a number n in order to mark down the length of the given array then we initialize a new answer array of the size n we also initialize our stack that we are going to use now we simply iterate over the given temperatures array using the for Loop we first have a while loop condition that while the given St stack is not empty and the temperature that we are iterating over current if that is greater than the temperature that is currently present inside the stack then we simply Mark the index value that is currently present at the very first element of the stack that we popped out and then we Mark the answer index by doing the subtraction of I minus the current index position that we have just been able to find by popping the element out of the stack and then uh we simply push down the element inside the stack and in the end our answer array should have all the answers so we can simply return done that now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast compared to most of the other Solutions it is also decent in terms of space complexity and once again the solution is available on our GitHub repository the link is in the description so you can check it out from there so the lead code problem we are going to solve is called evaluate reverse polish notation and we can see that this is a lead code medium problem and also an extremely welllike problem on lead code the problem statement is quite straightforward but it actually has bunch of different conditions that we need to understand so we are given an array of strings called tokens now these strings represents an arithmetic expression in the reverse polish notation now we need to evaluate the expression and we need to return the integer that represents the value of the expression now let's try to see some of the conditions that we are given number one the valid operations are plus minus multiply and division so these are the four operations that we can we can imagine to expect in our uh string that is coming in now we are being told that each operand may be an integer or another expression so we will see this in in another example then we are being told that the division between two integers always truncates towards zero which means we are always considering the ceiling value of ceiling value or sorry the floor value of any equation and then we are being told that all the inputs are going to be valid and there are not going to be any issues so let's try to see one example one very simple example so in this case the answer is going to be that the moment we identify an operator we will have to go back and take the previous two elements and if these two are whatever the numbers are we are going to be using that with this operator so we are going to be treating this as a we are going to be treating this as B and since this is a plus operator we are actually going to be doing a plus b so we need to return three as the answer in this case let's try to take some more slightly more complex examples first we are going okay so this is the number we move away move ahead once again a number we move ahead we identify an operator so now we are going to be treating these two values as a and b so we are going to be doing a plus b so 1 + 2 so the P the answer of this portion is actually going to be three our equation looks like three and then three and then plus so once again we are going to be doing 3 + 3 so the answer is 6 so out of this operation we need to return six as the answer so this is the whole logic of what the problem is actually asking us to solve that whenever we are given the values we keep moving forward until we find either one of these three operators like plus minus multiplication or division the moment we identify these four operators we are going to be treating the previous two values as a and b and then apply this operator and then keep on repeating the same process until we run out of all the every single digits inside the given inputs and we are being told that the all the inputs are valid now after this extensive explanation let's try to understand the most simplest Brute Force approach so Brute Force approach is actually quite straightforward uh suppose we are given the values 4 5 plus and then minus and then 7 suppose these are the values we are given so idea is that we are going to keep on iterating one by one the moment we identify an operator then once again we go back to the previous two elements and we use it with that operator and then once again uh we identify okay so now this becomes 9 and then minus and then 7 so once again we keep on repeating the same operation using the operator but thing is many times for let's assume that this if this is a very long string and we identify operator at very late the moment we identify operator once again we are going to be repeating the same process in order to keep find the values A and B so this becomes very tiresome operation so the idea is that we need to make it better and uh find some smarter ways to keep track of all the elements from the point we find the operators in the reverse order and also have an idea on how we can keep on moving forward with the given input array and start parsing the values so these are the two main considerations that we will have to understand so the idea I'm suggesting is that we can actually use stack to solve this problem so suppose this is the long operation that we are given now the idea I'm suggesting in using the stack is that at the very beginning we are actually going to be iterating the same way we are iterating all the values we find we are going to be pushing these values inside the stack the moment we identify the operator we are going to be popping the previous two elements and treating them as uh A and B and then applying that operator with that value and once again whatever the answer we find we are also going to be pushing those answer inside the stack and then we are going to keep on repeating the same process until we identifi the operator and then when we reach to the end we should have our answer ready because we are being told that the given input is actually valid so let's see the solution in action So currently our stack is empty now we are at very first element number two so we are going to be pushing element number two inside the stack now we are element number three and once again element number seven okay now we identified an operator plus so the moment we identified the plus operator we are actually going to be popping these two values out so if we do that we will have value 7 and three that we need to do the sum of so 7 + 3 is going to give us the answer 10 So currently the answer of this portion is going to be 10 so we are going to be pushing this 10 inside the stack and now look at the stack it actually contains the equation for this portion because sum of these three values is 10 that is present over here and then two was already here now we have 10 and two once again we identify multiplication sign so we need to do 2 * 10 so we get the value as 20 so now once again we are going to be pushing the value 20 because we already popped out 2 and 10 okay so now we have value 20 inside our array and now we once again identified value number eight and then once again value number 19 so let's push that okay after doing that now we identified car symbol plus so once again for plus we are going to be doing 8 + 19 so the answer is going to be 27 okay so now we are because we popped out 19 and 8 we push 27 7 down and then we have this minus operator so last operation we are going to be doing is 27 minus 20 so the answer is going to be 7 so 7even is what we need to return in this case to solve the problem and this is the whole solution that I'm proposing using the stack look how beautiful it is look how at any given moment but by the moment we identified the operator we can actually find the previous two elements back and we can actually do the sum uh that needs to be done or some division uh subtraction whatever and this is how we can solve the reverse polish operation very beautifully using stack this is one of the most awesome way to use stack in the real life problem and that's why this is such a popular problem that we have seen in tons of interviews being asked so if we see time complexity in this case the time complexity is actually going to be biger of n because we are going to be iterating over every single character just once nothing more than that in terms of space complexity we are using an additional uh stack so depending on how apart the characters are from any operation the size of Stack can increase or decrease but overall it is going to be big of n so which is good uh and uh acceptable time and space complexity in this regard so now let's see the coding solution for this one so the idea is quite straightforward first of all we are going to be initializing our stack then for every single token we are first of all going to check that if the given token is operator or not the moment we identify that if the given token is operator we are going to be popping two values out so first value we pop out is going to be our B and second value is going to be our a and then we are going to be applying our operator that we have found uh using this method so let's see couple of the helper methods first helper method is the is operator helper method where we are simply checking that if the given token is equal to any of these four values and second one we are applying the operator Where We Are simply going to go over the given input values that is the string and then a value and B value and we are simply returning depending on the operator to whether do the addition subtraction multiplication or Division and if none of this case is there we are simply adding one extra argument but I don't think this is going to uh be called because we are being told that the given input is valid if that is not the case and we did not find that these are the operator by the way uh the moment we identified the operator we also do the calculation and whatever the result we found we once again push it down the stack if that is not the case which means the given token is not an operator so we simply push it down the stack but we first of all convert the value inside the integer because we know that this is going to be the integer value and once this Loop runs we should have been done with our reverse polish notation and whatever the value left inside the given stack would be the answer that we need to return so we can simply pop the very last element so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast in terms of time complexity which is pretty awesome once again the coding solution for this problem is present inside our GitHub repository so you can find it from there so the lead code problem we are going to solve is called Min stack and you can see that this is a lead code medium problem and also a very well like problem on lead code the problem statement is very simple that we need to design a stack that can support push pop top and retriving the minimum element inside the given stop these four operations and it needs to run in constant time or B go off one time so we need to implement the Min stack class and these are all the methods that we need to implement now we know that how does a typical stack work stack operates in Leo principle last in first out if we decide to push element number three then we will have an entry three presented inside the stack next we can push another entry called one then once again we will have entry called one then once again we can have Push another entry called five So currently we have three elements now inside the stack if we have to pop this element then the element five would pop out so let's quickly pop one element so then we will get answer number five then if we do pop once again we will have value number one after doing that if we were to add two two more elements or push two more elements let's assume 2 and six so once again we will have elements 2 and six something like this then if we do top operation at this moment it it should return return answer six because that is the top element inside the array and then if we do get min then it should return us the value S2 because this is the current present minimum element inside the given stack so these are all the operations that we need to do we need to solve all of these in big of one time which means we will have to do something different when we are design designing our stack so what are some of the considerations that we can do the thing is this push method pop method and top method all of these three methods can operate in big go of one time no issues with that in either case this get min is little bit tricky because we will we will need to know that what is the minimum element at any given moment now the very first thing that comes to our mind is that when we are designing the stack uh why don't we just have an extra variable called Min to keep track of the minimum value we have encountered So Far So currently this is an empty stack let's assume that we enter value number five so this has been the minimum value so far five next we add value number six so five is still the minimum value next we add value number two so once again we update this and add two over here once again we add value number seven so now currently the minimum value is two but now there is one problem that you did not see and that problem is that let's assume that we decide to pop one element out so now currently seven is no longer here but once again the minimum V variable is still two because that is the minimum variable let's see let's say that if we do pop once again so once again two is now no longer inside the given stack as well so now if we do Min operation we don't know that what is the minimum value inside the array because we just overrode the value so if we have to check for the minimum value we will have to pop all the elements out of the stack and then find the minimum value that is option number one which takes big off end time and if we don't do that we we basically don't have any other way so now to overcome this issue and to keep track of the minimum value at every single variable we can actually do things slightly differently so the moment we are storing the values inside the given array uh we are actually storing different nodes right for every single location now in this design of node we can actually have node have multiple items not only just its value so let's assume that this is our given node and so in the node I'm suggesting to add three values first value is the value of the node itself that whatever the value we wants to enter that is your integer value like 1 2 34 whatever he wants to put next is that what has been the minimum value up to this point inside the existing stack and if we keep on updating this value with every single entry inside the stack this would be pretty easy to maintain and last thing is the reference to the next node because uh in case we will have to remove or get rid of the element we might need to update the minimum value we have entered so far so let's see that how would this approach is going to look like let's say that we wants to add these values inside the stack okay so first we wants to add value number three currently the node is empty so because node is empty we are adding value number three h what has been the minimum value we have added so far that is also going to be value number three and the reference to the next node is going to be null so we are not going to be concerned with that that this is the very last element inside the stack okay now we need to add value number five so we add value number five but what has been the minimum value is is so far so for that we can either check the minimum value of the next pointer using this next pointer so we check that what has been the minimum value of the next pointer at location number five that is value number three and what is the value of this current value we are trying to enter that is value number five so whichever is the smaller number which is three in this case so we will still Mark three as the minimum value we have been able to find and then we simply have a reference to the next node so reference to the next node once again I'm just marking as three but that that is simply going to be this node okay once again we wants to enter value number one so now at one what has been the minimum value up until this point that is this value number three so instead of using three because one is smaller so the smallest value so far is going to be one and the reference to the next node is also going to be this one same way now we wants to add value number seven but what has been the minimum value we have been able to find so far that is value number one and then just the reference to the next node and then in the end the value is zero so now the value is zero we are trying to see that what has been the minimum value up until this point that is one so compared to one Z is smaller so then this is also going to be zero and then we simply have a reference to the next note okay so now this is what our uh stack looks like we are simply updating the node that we are storing uh the values in and now let's let see each of the operation so I just mentioned that push operation can happen in big off one time because we are just simply pushing one node inside the stack uh let's try to do a pop operation so pop operation can also happen in big off one time because we are simply popping one element out so we will get rid of this element okay now once again let's try to do the top operation so top operation we need we can return seven immediately because that has been the latest value we we find and then if we do the get min operation this can also happen in big off one time because we can simply find the minimum value we have been able to identify so far so this is the logic on how we are going to solve this problem basically by simply redefining the way we are storing the values and then keeping track of the minimum value at every single position that is the whole trick and if we see time complexity in this case well time complexity we already know that that is going to be big of one and in terms of space complexity uh well this is debatable but I think it it has to be big off one because anyways we are being asked to create a stack so we cannot create extra space for that so first let's define the node for our given class where we are going to store three values first one is the value of any particular position next is the Min value and third is the reference to the next node and this is just a simple Constructor to store the values okay now coming back to our main class we are going to have a private node head and we are going to initialize our data structure here next we are going to have a main push method so whenever we need to push any single ENT so if the value is very first then we are simply going to provide the value as it is then minimum value is also going to be the same value because there are no other entries inside the stack and then the next element would be simply null if that is not the case we are going to add a new node where we are going to keep the value as it is then for the minimum value we are actually going to compare it with the current value and the minimum value we have been able to find so far and that we can simply find uh using the next node and then as a part of the next node we are simply going to point to the Head node and this is going to be keep on updating with every single entry uh for the pop it's very simple we simply uh take the very first element that is currently present for the top we simply return the very first element and then inside the for the get min method we simply return the minimum value for the head and this is the whole solution let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast compared to lot of other Solutions in terms of time complexity and very efficient in terms of space complexity so once again I will be posting this in our GitHub repository so you can check it out from there thank and today we are going to solve a lead code problem called generate parenthesis now if you see some of the popular companies who have already asked this question there are companies like Amazon Facebook Microsoft Apple Bloomberg Uber Lyft Google by dance Spotify and Nvidia so that's why I'm paying my at most attention I hope you also enjoy the video okay so this is a lead code medium problem and also very well like problem on lead code basically we are given an input number n and now we need to generate n pairs of parentheses so basically we need to write a function that generates all the possible combinations of wellformed parentheses now these round parenthesis I think they are called wellform parenthesis now we can try to understand these two examples but I'm going to take take it one step further and I'm going to show you four different examples to understand that what this problem is asking us to do okay now in this first example we are basically given n is equal to one pair which means we need to make one possible pair and all the combinations of this well formed parenthesis so obviously the answer is going to be quite simple we simply need to return return like uh just one possible pair that we can make out of this one now suppose n is equal to 2 so now for n is equal to 2 we have the choice to take like two of these and two of of these right we need to take four values uh so basically the number of possibilities we can make is that we can actually make a parenthesis that looks like this and we can also make a parenthesis that looks like this these are the only two possibilities we can have and uh this is what we need to return return as the answer now things becomes a little bit interesting when we reach to n is equal to 3 uh so when we get to the point where n is equal to three the possibilities we can make is so these are the five possible pairs we can make when n is equal to 3 now notice that over here for every single piece we are using like three opening brackets and we are also using three closing brackets but we are just putting them in different pairs so that they generate like the wellformed parenthesis uh same way if we try to do it with n is equal to 4 the answer is going to be pretty huge so let me just uh draw it over here so these are all the possible pairs we can make when n is equal to 4 and basically we are using four opening brackets and four closing brackets and arranging them in different sizes so this is a very interesting problem now let's see that what are going to be the different approaches to solve this problem so now the first approach that comes to our mind is a Brute Force approach in The Brute Force approach what we can do is suppose we are given n is equal to two right if we are given n is equal to 2 there is one thing guaranteed we need to have four characters inside every single block of our answer why four characters because uh we are generating two pairs of parentheses so two pairs of parth Paris is basically going to be four characters at least right so what we can do is now we have two options to choose from either we can choose an opening parenthesis or we can choose a closing parenthesis so what we are going to do is basically we can take every single possible pair that we can make of size four using these two characters and only the valid pairs we put put them in the answer so suppose we are given n is equal to 2 what are the different pairs we can make let me make just a few pairs so these are just some of the few examples that we can make for four characters using like this opening and closing parenthesis for n is equal to 2 and over here we only need to find the legitimate pair so okay we can find one legitimate pair and we can find another legitimate pair and I think this is going to be the answer that we need to return so we will put these two in the answer and then just return them but if you see this Pro Force approach is extremely inefficient uh if we see like time complexity the time complexity goes sometimes into like 2 to the power of 2 N something multiplied by n just to check that whether the pair is valid or not and that is this dter us so no one is going to accept that so we will have to find a way to do something better so what we are going to do is we are going to do things smartly how we are going to do things smartly first let's define our perspect purpose our purpose is to generate two pairs of opening and two pairs of closing brackets and they has to be well informed or valid now we need like two opening brackets so that is a given fact we need two closing brackets that is also a given fact now there are are some properties that we can use at our advantage taking consideration the definition of being valid now what is the definition of being valid so basically if we are given n is equal to 2 there has to be uh two opening parentheses and two closing parentheses so that is one definition second definition for being valid is that we can only put a closing parenthesis if there exist an opening parenthesis before that again I'm repeating myself we can only put a closing parenthesis if there exists a closing parenthesis before that we cannot start our answer with a closing parenthesis because that wouldn't be valid uh third third thing that we need to consider is that we can only have that many number of open parentheses that is equal to the number of n now you are saying that why am I repeating myself because this is going to be the very important property that we are going to use uh so now once we know all of these things let's try to make some smart decisions on how we can actually generate the answer for valid parenthesis uh basically we are given n is equal to 2 over here right now we have option to choose like two opening parentheses and two closing parenthesis so okay now what we are going to do is uh for our answer generation always we will have to start with us an opening parenthesis right now we we created the opening parenthesis that starts with this one now we are going to keep track of few values first value we are going to keep track of is the number of opening parenthesis right so number of opening parenthesis that we have used so far is one uh and what is the maximum we can use maximum we can use is two because that is the value of n we are also going to keep track of the number of opening parentheses we already know that is one right we are also going to keep track of number of closing parentheses and so far we haven't used any closing parenthesis so that this value is zero and we can only add a closing parenthesis if the number of open parentheses is greater than the number of closing parenthesis because we already proved that over here now using this logic let's see that what is the sequence we can make okay so first we start with this value when we start with this value number of opening parenthesis is one number of closing parenthesis is zero now over here we have two options uh and those two options are we can either add one more opening parenthesis or we can add a closing parenthesis so let's see options in both of both of the cases the number of opening parenthesis is going to be two and we can have this value to be two because we are given n is equal to 2 and in this case the number of closing parentheses is still going to be zero because we have only used two open G parentheses over here now in this case the answer is going to be a little bit different uh because the number of opening parentheses is going to be one and number of closing parentheses is also going to be one and this is also valid why because the number of closing parentheses can be one because we already had one open parenthesis so so far both of the cases are legitimate now again at this position we also have two more choices so over here we have the one choice to open and we have one choice to close now let's see both the options if we try to go one choice to open what we will happen is number of opening bracket is going to be three but that is not valid why because we are given n is equal to two explicitly so in this case we cannot go down this path so if we cannot go down this path we will actually backtrack and come back to this position now from this position we can only go towards the path of closing so if we go towards the path of closing so far the number of Open brackets we had is two and the number of closed bracket we had is one so that is still valid that is still legitimate now again from this position we still have two options we can either open or we can close if we try to open we cannot do that because number of open is going to be three so we are not going to go down this path uh if we go down this path uh basically the number of Open Bracket is going to be two number of Clos bracket is going to be two as well and this is the exact condition we need because we are given n is equal to 2 so which means that there has to be two Open brackets and two closed brackets so we can put two conditions whether we can put like the combination of open Plus close is going to be four that is going to be the double of what is uh n or we can have like uh o is equal to 2 and C is equal to two both of them equal to two so this is also good so now we have reached this condition which means that whatever the path we actually make can make our ourselves into the answer so what is the path we took so first we started with uh taking the opening bracket then again opening bracket then again closing bracket and then again closing bracket so let's put this value in the answer right so we are going to create a new variable answer over here and over here let's put one entry that okay two open two close that is good now let's start following the other path I'm going to clean this up a bit so it does not become any more distraction so now in this case okay currently we have one Open Bracket one closed bracket now again we have two possibilities so first possibility we can open one more bracket or we can close one more bracket now let's uh analyze both the possibilities if we try to open one more bracket basically the number of Open brackets we are going to have is two let me clean this up a bit more and over here uh number of closed bracket we had so far is still one so okay this is valid we can put this one now if we try to put one more closed bracket the number of Open Bracket we have so far is only going to be one but number of closed bracket is going to be two which is no a big no no why because we cannot have more close bracket then the number of brackets we have opened because that would defy the possibility of having a legitimate scenario so we cannot go down this path so we won't and uh now again we have two choices at this position we can open one or we can close one if we open one then the number of open is going to be three that is not valid that is not good so we are not going to do anything with this one and we will not go down this path if we go down this path then over here number of Open brackets we have so far is two and number of closed bracket we have so far is also two which is also the legitimate scenario so which means that this path is also going to be a path that we can add to our answer and uh let's see okay so currently we have okay we have one Open Bracket one Clos bracket we also have one Open Bracket and one closed bracket and that's it now uh initially remember we only started with this one opening bracket and then we had two possibilities and we actually exhausted both the possibilities so we cannot go down further anymore now because we cannot go down further anymore uh we can conclude that whatever the values we find so far this is the complete answer and we can return return this as the answer and basically this is the whole Crux of the finding the optimal solution now you must be asking that hey what we actually did was uh we did something s very important first we identify okay the one value then we had the uh final case so final case was that whenever the number of opening is equal to n and number of closing brackets is also equal to n this is our final case and then at every single position we had two options to either choose an opening bracket and closing bracket and keep on repeating the same process until we reach to the end and we had some parameters in mind so if you see we are actually using dynamic programming at its finest because at any single previously computed value that is being used to calculate that which path we need to take and whether we can take that path or not so we are basically using dynamic DC programming plus backtracking to solve this problem and this is going to be like an amazing way to explain this problem uh logically think that in the Brute Force what a disastrous result we were having and we actually brought it down to such like beautiful answer and then we are just presenting it so this is the whole power of uh using any like computer language so before we start implementing the generate parenthesis method first we are going to create our backtrack method uh that is going to be our helper method that we are going to use recursively now for the backtrack method it is not going to return anything uh but it is going to add all the values towards the answer and inside the method we are actually going to create a list of list that is going to store the answer we are also going to have a string Builder to keep track of the current values we have the number of opening and number of closing brackets and also the maximum number of values we can generate okay so now first let's create the acceptable scenario so if basically the current length is actually going to be maximum * 2 uh which means that we can actually we have reached to our answer and we can add it to our answer so this is the legitimate scenario now let's see say for an example we find out that uh uh the we have not reached the answer then what could be the possibility well first possibility could be the number of Open brackets uh that could be less than the number of maximum brackets that is allowed if that is the case basically for the current uh string Builder we can actually upend an opening bracket so let's do that and uh after adding the opening bracket basically we will have to call the backtrack method again with a reduced value of one Open Bracket so let's do that so in the backtrack method we are going to call the answer and we are also going to call the current uh string Builder list we have but for the open we are actually going to add one value and for the number of closed brackets we are going to keep it as it is the max is also not going to be changed and that is awesome now there is also one more important thing we will have to do every single time we make a backtrack call and that is to delete one character that is located at the current length minus one because it is going to add an extra character so let's do that okay now same way uh say for an example if the number of uh close CL brackets and they are less than the number of Open brackets uh if that is the case basically we can also add one closed bracket to our self as well so let's do that and we are also going to call the backtrack method and uh everything else is going to remain the same and basically this whole logic sums up our backtrack method now all we need to do is from our main method we simply need to create a list of list called answer so let's do that and then we are going to call our backtrack method now inside the backtrack method we are going to provide the value of answer we are also going to provide a new instance of a string Builder Pro going to provide the number of opening brackets that we have used so far is zero number of closing brackets is also zero and the maximum number of opening and closing bracket we can have is going to be the value of N and after getting the answer from the backtrack method we can simply return the answer to be return the answer that we got and uh basically that's it yeah let's try to run the code okay seems like our solution is working as expected let's try to submit the code if we submit the code our solution beats lot of other Solutions it is really good in terms of time complexity and it is also really efficient in terms of space complexity as well hello friends hope you are having a fantastic day today so once again we are going to do an awesome lead code problem and trust me this is an awesome lead code problem so without any delay let's get started so now we are going to solve the lead code problem called car Fleet now personally this is one of my favorite problems and we can see that this one is a lead code medium problem and also decently welllike problem the thing is this is a very long description for this problem because it covers lot of edge cases and lot of conditions that you have to understand if you want be my guest and read the whole description if not let me just point out few important topics and then we will we will try to understand what the problem is asking us to do through an example that would make things much more simpler so first thing is we are being told that there are n cars going in the same destination along one lane road so it's a single Lane Road and we are told that the cars are not going to be overtaking each other this is not fast and furious this is lead code okay then we are also given a Target miles that we need to reach that is the final destination for our cars now we are given two integer arrays first one is position and second one is called speed so position defines that what is the starting position for any particular given car compared to that Target distance okay and the speed is at what speed that particular car is running on so we are given both the values inside the car now we are being told that cars are not going to overtake each other but if they are close enough we can consider them arriving at the destination at the same time and any car arriving at the destination or set of cars arriving at the destination would be considered as car Fleet and now we need to consider that how many number of different car fleets actually arrive to the destination so I know that this was quite complicated and very extensive description let's try to make it simpler using some example so over here we are given a Target value of 12 that we need to reach and we are given the positions and we are also given the speeds of subsequent cars so here I have actually plotted a graph or a number sequence where this 12 is the Target that every single car is trying to reach now this C1 C2 these represents different cars and we can see that based on their positions inside the subsequent array I have already plotted them on this given line so this defines their starting position and subsequently this ption defines that what is the speed that is given to every single car okay and we are being told that the distance we are trying to cover is 12 mil and the speeds are given in per hour basis so which means this car C2 actually Travers 4 miles in 1 hour okay so now we need to understand that how we Define car fleets so let's try to understand it one by one so we will try to go over that how every single car is actually going to reach to the Final Destination and we know for sure that no car is going to overtake one other so if one car comes closer to the other car we would consider both of them reaching to the destination at the same time and there would be part of one single Fleet so first let's see So currently this car C1 is located at position number 10 and its given speed is 2 mph we know that the C1 has to be the first car to reach to the destination because it is the closest car to the destination so the in the first hour this car is actually going to reach to the destination and it's going to take 1 hour but during this 1 hour period because how do we come up with this 1 hour because we calculated the distance from the current position to the Final Destination we are trying to reach which is 2 miles and its speed is also 2 miles so we can easily easily calculate the time uh that it takes to reach to the destination now for this C2 also subsequently the C2 would also reach to the destination in just 1 hour so based on this we can conclude that both of this C1 and C2 are actually going to reach to the destination around the same time around at 1 hour mark which means C1 would be here and C2 would be right very close to it so these two cars are going to reach to the destination in around the same time which means this is going to be one of the Fleet that is going to arrive into the destination so now we already took care of one Fleet so let's just get rid of these okay and also let's try to understand that we have already spent 1 hour so during this 1 hour what would be the position of all of these cars so during 1 hour the C4 would have traveled 1 kilm so C4 would be here same way the C5 would have also Kil con completed 3 kilm because its speed is three so after after this 1 hour this c5's position should have been at position number six but at position number six we can clearly see that C4 is already present which means after 1 hour the position is going to look something like this where C4 and C5 are going to be right close to each other now remember that the speed of the C4 is 1 and speed of the C5 is three but because C4 is ahead compared to C5 even though it has higher speed it is not going to overtake it and it is only going to reach to the destination when the C4 arrives but essentially both of these cars are also going to reach to the destination in around the same time and how much time will it take well currently this one is at position number six so it is going to take six more hours and we already spend 1 hours which means the C4 is going to take 7 hours to reach to the destination and because C5 is behind that and it is able to catch up to the C4 it is also going to complete and reach to the destination in 7 hours so after 7 hours the second Fleet that would have reached to the destination would be the cars uh that we just saw that is the car C4 and also C5 so they both will also reach to the destination in around the same time so this would be our second Fleet that is going to reach to the destination and now we already spend 7 hours which means after 7 hours this C3 would have been uh around here because because its speed is just 1 M hour so it would have covered the distance of 7 mil and then still it would have five more miles to go which means it would still take uh like around 12 hours to reach to their destination and in the end the C3 car would be the very final car that would reach to the destination and still this would also be considered a fleet in its own so over here we can see that actually we are getting 1 two and three fleets reaching to the destination so for this given input we need to three as the answer and this is the whole problem statement now I know understanding this problem statement take took us lot of time because there were a lot of moving paths and moving cars that we had to understand but honestly this is an awesome lead Cod problem because if any interviewer dares to give you this problem this is not very difficult to solve but it's very uh pecular for interviewer to explain also you will have to navigate through lot of different edge cases and then think about coming up with the optimal solution so now I'm not even going to be bothered to show you the Brute Force approach because that would be an ins insult to this beautiful problem so let's talk about the actual complete optimal solution that we can use in order to solve this problem and in order to generate the optimal solution we need to make some assumptions and we we need to do some calculations so what are some of the calculations we need to do number one thing that is most important is that for any particular car we will have to understand that how much time it takes to reach to the end that is number one thing and second thing is cars can only reach to the Target based on the current sequence locations they are present in so even though if we see the car numbers over here this C1 and C2 are based are located at the correct space but the C3 is actually going to even though this is the third car this would this has to be the last car to reach to the end so number one thing we are going to do is we will try to find that how much time does it take for any single car to reach to the end we will try to store this information with the cars so we actually have couple of ways to store this we can either store it using a hashmap uh that would only make things more complicated because we don't need like a constant time access to that data and same thing can be achieved using a twodimensional array as well so we will try to use it store it using two dimensional array okay so in the twodimensional array we are going to store the information for a subsequent car and how much time does it take to reach to the end that is number one thing number two thing we are going to do is that we will actually sort these cars based on their positions so number one car in that is going to reach to the destination is going to be the car that is closest to the destination position so based on the position size we are also going to sort them and once we have that we would be able to identify the answer quite easily so now first let's try to understand that how do we actually calculate how much time does it take for any single car to reach to the destination and that is a very simple calculation all we need to do is we need to calculate the distance between the current position and the destination position and whatever this distance is we need to divide the speed by that distance and that would give us the time on that it that that particular car would take to reach to the Final Destination okay so now the idea is quite simple so let's just do that so for C1 currently we can see that this is located at position number 10 and it needs to reach to the position position number 12 which means the distance is two and the speed for C1 is also 2 m per hour which means it is going to take 1 hour for C to reach to the destination same way for C2 it is also going to take 1 hour to reach to the destination same way for this C4 it is actually going to take 7 hours to reach to the destination because the difference between 5 and 12 is 7 and the speed of C4 is 1 M hour same way for the C5 the dist the distance is also going to be 3 U 9 km uh sorry 9 miles and then the speed is three so it is only going to take 3 hours to reach to the destination and last one is the C3 car so for C3 it's actually going to take 12 hours to reach to the destination now we have over this list ready now let's try to sort this given list based on the position of the cars which means once again C1 is at the correct position and C2 is also at the correct position both times are 1 hour and 1 hour then we have the car C4 and C5 so for the car C4 it is uh it is going to reach into the 7h hour mark and car C5 should reach in 3our marks if there were no cars ahead of it and the last one is the c0 car or uh I think C3 car so C3 car is going to take 12 hours to reach to the destination okay so let's quickly do a re recap what we did we found out how much time does it take to reach to the destination then we sorted all of these cars based on the position where they are compared to the start to the Target location so the higher the position the first it is going to be inside our L list and in order to store this information we are going to be using a 2d array now after having this information it becomes very easy for us to solve this problem because all we need to do is we simply have to check because we know for sure that this has to be the first car to reach to the destination at any given moment moment we realize that the speed of this is actually lesser or equal to the speed of its subsequent car then we can conclude that both of these cars would reach to uh at the same time let me rephrase I use the word speed but the the correct word should have been time so if the time it takes for the C1 car to reach to the destination is 1 hour and we see that for C2 the time it takes is also 1 hour which means C1 and C2 both are going to reach to the destination around the same time just in a scenario where C2 is just behind C1 so we can conclude that these two has to be one single Fleet so this becomes our one of The Fleets now in the second scenario we have the time it takes for C4 to reach to the to the destination as 7 hours and the time it takes for C5 to reach at the destination at 3 hours which means C5 actually is much faster than C4 So eventually C5 would be close enough or just behind C4 before C4 actually reached to the destination let's try to once again understand using this plot because after the very first hour actually C5 and C4 would both be at the same place and how do we find out because we can see that the time it takes for both of them to reach to the destination so these two also has to be part of a simple Fleet now say this last for the C3 instead of this being 12 maybe this also took 3 hours to reach to the destination then C3 would have also been part of this Fleet because C3 would reach to the Destination 3 in 3 hours C5 would reach in 3 hours and C C4 is going to block both of them and cause both of these cars to reach at 7h hour mark because C4 is ahead compared to C5 and C3 so this would have been part of this Fleet as well but in this scenario because the time C3 takes to reach to the destination is actually greater than the previous Fleet the largest value in the previous Fleet then we can conclude that this C3 is not going to be able to catch up to this C4 and C5 Fleet so this is going to be our second Fleet and in the end the C3 is going to be our third Fleet so that that's all you need to do to solve this problem once we do have the comp the sorted version of subsequent cars with the time it takes to reach to the destination we can actually very easily compute because for every single Fleet all we need to check is that what is the longest time it takes uh for those Fleet to reach to the destination so in this case for the C4 and C5 it's going to take 7 hours to reach to the destination so if this number would have been anything less than seven then it would have been part of this uh C4 Fleet but because it's not less than 7 so this has to be a fleet on its own and uh that's it that's what we need to do and this is the whole solution so now you see how beautiful this problem is and how awesome the solution is like that's why this is really one of my favorite questions because it's a combination of math and data structures and then how do you make things more efficiently and how can you think about uh different scenarios and different mathematical equations and stuff like that okay so now let's try to understand the time complexity it is going to be bigo of n because we are going to be simply iterating over the given input array bunch of times but still it is going to be big off n but you forgot one critical thing that is we will also have to do the Sorting operation and that is actually going to cause our time complexity to be big of n log n and if we see space complexity well for the space complexity is actually going to be big of n Square because we are using a 2d array to store the information of the cars uh to its subsequent time it takes to reach to the destination overall this is also a very good time and space complexity now let me know in the comments if you want also want to see a solution using a monotonic stack because this is pretty popular problem for that so if you want I can also show a solution with that but I think this is a good enough solution for your interview your interviewer is going to be more than happy and now let's just quickly see the coding for this one so the coding solution is quite simple first of all we create an integer n uh to store the length of the given input array and then we initialize our 2D array that we talked about where we are going to store the information about cars and its subsequent time it takes to reach to the end then we are simply going to iterate over the given input array and we are going to pop calate our cars 2D array that we just created where we are going to Mark the positions of the car and also we are going to calculate that how much time does any single car it takes to reach to the destination then we are going to do the most important operation where we are going to sort the given cars based on the current positions of the given cars once we have that now it is very convenient to solve this problem we are going to initialize a counter zero that this is going to calculate the fleet on what time it is going to arrive and then we are going to have another variable where it is going to keep track that what was the previous time for the car to reach to the end then we are simply going to iterate over the given input uh 2D array cars and we are going to check that if the value of any particular given car is actually greater than the previous time which means that is a new Fleet being created so we are simply going to create a new Fleet or add the value to the counter and also we are also going to Mark the previous time of the last car that just came in and that's it in the end we can simply return this counter that we have created that was keeping track of all every single Fleet and now let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently in terms of time complexity extremely efficiently in terms of space complexity and once again the code is present inside our GitHub repository so you can go and check it out from there thank you hello friends hope you're having a fantastic day today so now we are going to solve Facebook's most asked question this question has literally been asked 142 times at Facebook so this is a very popular lead code interview question and without any delay let's get started okay so the lead code problem we are solving today is called minimum remove to make valid parenthesis book and we can see that this is a lead code medium problem and also a very welllike problem now the problem statement is quite simple that we are given a string that contains bunch of different opening and closing parentheses and low lowercase English characters now at any given moment if we identify that the parentheses are in correct sequence like the same number of parentheses that are opened are also closed then we call them valid but if we identified some invalid parentheses then we simply have to remove them so let's try to understand this with an example it would make much more sense and we can see that bunch of the parentheses are actually at the wrong position first one we can see over here where we have a closing parenthesis but we don't have any opening parenthesis somewhere here before which means this is an invalid parenthesis sa same way uh this is also an invalid closing parenthesis because though this pair of parentheses are valid this is not valid and same way we have an additional opening parenthesis so in this case we have three parentheses that that are invalid so if we simply get rid of these three parentheses that we just identify then we would have our query that will look like this and now we can see that uh this entire sequence is actually valid where we have uh two pairs of opening and closing parentheses so they are valid and also we have a bunch of different smaller English language characters and they are also valid so we simply have to identify that which are the index positions that we need to remove uh in order to make a valid parenthesis pair or a valid query okay so let's simply see The Brute Force approach very quickly Ro Force approach is very simple uh for any query that we are given we can all we need to do is that we simply go over every single character and the moment we identified either an opening or closing parenthesis so in this case we identify a closing parenthesis so once again we would go back and try to find an opening parenthesis if we cannot find it we identified that this one is invalid and then we move forward so same way the moment we identify an opening parenthesis once again we would move forward to try to find a closing parenthesis that is going to match up with that if we find it that's great if we don't find it then in that case we would deem that parenthesis as invalid and if we keep on moving forward in that direction we would eventually find the answer but thing is there is lot of back and forth we are doing and essentially for every single character in the worst case we might have to do like big of n Square work in order to solve this problem which is lot of work needs to be done just to solve this problem and this is actually a very simple problem to solve so now let's quickly see the optimal solution for this one so now let's try to see that what would be the optimal solution to solve this problem and for that we will have to understand just couple of things that what are the exact checks we are making number one thing we are checking is that at any given moment we identify that any particular opening parenthesis exist this can only be valid if further down the road we identify that there exist some closing parentheses okay and same way if we identify some closing parentheses this can only be valid if there exist a subsequent opening parenthesis presented in counterpart towards this one if there does not exist any which means this is one of the invalid ones so using these two conditions what we need to do is for every single opening parenthesis we need to keep it stored somewhere that there might be a closing parenthesis somewhere down the line and the moment we identified some closing parenthesis we will have to check that whether there exist an opening parenthesis immediately before that that is going to match with it so a very good data structure in this case would be stack to solve this problem why because stack has the property of last in first out that we are going to use at at its maximum to solve this problem and let's quickly understand that what I mean now the thing is through stack we would be we would be able to tell that which uh parenthesis is invalid but the thing is we would still need to recreate this entire string in order to solve this problem so what we can do is the moment through stack we identify that any particular indices is invalid whether opening or closing parenthesis we can just simply create maybe like a hash set or some other data structure where we we are simply going to keep track of all the variables or all the index positions that are invalid this is this will help us to build the rebuild the entire string after we find out all the invalid parenthesis okay and the logic we are going to apply is that for a stack uh if the moment we identify that there exist an opening parenthesis we are going to push the opening parenthesis down the stack the moment we identify a closing parenthesis we are going to check inside the stack that whether there exist an opening parenthesis to counter this closing parenthesis if it does we are simply going to pop that parenthesis out so marking that this entire pair is going to be considered valid now for some PEC case we identify that there exists a closing parenthesis but there is no opening parenthesis then this needs to go to the set because this is an invalid entry and using this logic we would be able to solve this problem quite easily so let's quickly see the solution that I'm proposing okay and also let me quickly Mark the all the index positions and also initialize a hash set where we are going to store all the indices okay so very first element is a lowercase English letter element so we will just move forward now we identified a closing parenthesis so now the moment we identify a closing parenthesis we will need to check inside our stack that does there exist an opening parenthesis currently the stack is empty because the stack is empty this is an invalid position so so we are going to Mark the index position inside our set as one next we will move on towards the next element this one is also a lowercase English character so we move forward this is an opening parenthesis so opening parenthesis has to go into the stack so we are going to Mark its index location inside the stack so we identified value number three over here okay next is also a random character now this one is also a closing parenthesis so closing parenthesis we check that whether in the stack do we have do we have any entry and yes we do so we will actually pop this element out so we pop this element out currently stack is empty now because stack is empty we also identified that there exist an opening parenthesis so or sorry a closing parenthesis and we once again needs to check into the stack but stag is empty which means this is also an invalid character so we are going to mark five over here we get once again we can ignore this one now this one is an opening parenthesis so we enter over here once again opening parenthesis so once again we enter into the stack we can ignore this one now this 10 is also a closing parenthesis so for the closing parenthesis we can pop one value out so we pop eight out uh from our stack but the thing is in our stack we still have value number seven left which means that this value number seven is also an invalid stack because we we just run out of all the characters in inside the string so we have an extra opening opening parenthesis as well that we need to remove so we can mark this value and now if we remove this character one uh five and seven from our existing string we would get our string that looks like this where the values are going to be valid and this is what we need to return return in the answer so basically we can very easily solve this problem using the stack if we see time and space complexity time complexity is going to be bigo of n where n is the number of characters that are present inside the stack and space complexity is simply going to be bigo of n as well because we are using an extra stack and also an extra hash set to store bunch of different values okay so now let's quickly see the coding solution for this one so coding solution for this one is quite straightforward first we initialize our hash set and our stack then we simply iterate over the given string uh and for every single character we first check that if the given character is an opening parenthesis we push it down the stack if it is a closing parenthesis and if the stack is empty which means we identified an unexpected closing parenthesis so we simply remove add that uh character to our remove indices hash set that we have created add its index position uh and if that is not the case we simply pop the element out of the stack because stack already has an opening parenthesis this is what it means now in the end after this uh particular Loop has ended we would have taken care of all the unexpected closing parentheses that were present present but we still have to take care of the opening parenthesis and they would still be present as unmatch opening parenthesis inside the stack so any single element that is present inside the stack we simply uh take them out and work on and add them to our headset as well in the end we simply need to build a string in order to generate the answer so for that we remove all every single character that are present inside our head set uh and then just create and upend the string that is that was already given to us in the input and then we simp return that as the answer so this is the whole solution let's try to run this code and our code works as expected so no issues with that let's submit this code and our solution is pretty fast compared to a lot of other Solutions once again the coding solution is present inside the description of the GitHub link that I have provided below this video so you can go and check it out from there thank you this is a lead code easy problem and also one of the most like problems on lead code uh and that is because this problem actually solves one of the very real life application where a compiler has to check that whether the code has valid parentheses or not and so that's why a lot of companies like to ask this problem as an interview question uh if we understand the problem basically we are given a string s that contains just these three types of parentheses opening parenthesis and closing parenthesis and we need to determine that if the given input is actually a value valid input or not we are also given the definition that what counts as a valid input that if the opening brackets are closed by the same type of closing brackets and also we are told that the opening brackets must be closed in the correct order so let's try to understand this with some examples over here I have drawn a bunch of different uh potential or examples and we will see that if they are valid or not so first of all if we see this example we know that okay we have two closing two opening brackets and we have two closing brackets we can consider this as a valid string so I'm just noting it it as V now again in this case we have two different types of opening brackets and we have two different time types of closing brackets so this is also valid string now in this case uh this is an opening bracket this is an opening bracket we have corresponding closing brackets again we have opening and closing brackets and again we have opening and closing brackets so everything is in order and the same kind of brackets are opened and correct in proper shape and size so we can consider this also as a valid format now if we can come to this example this is an opening bracket this is also an opening bracket but we only have a closing bracket for this original opening bracket so we can consider this as invalid option so we get an idea why it is invalid in this case we have three opening brackets and only one closing bracket so again this is an invalid uh string and in this case actually if we see the number of opening brackets and number of closing brackets they are actually same so we have one opening bracket and one closing bracket again one opening bracket and one type of closing bracket but this is still invalid why it is invalid because this bracket this curly bracket bracket is actually opened before this particular round bracket so that's why it has to be closed before this round bracket closes and in this case this round bracket actually closes first before this curly bracket is being closed so this is very important property that we will have to keep track of and that is why we are told that we need to keep track of the order in which they are opened and closed and then only we can determine that whether they are valid or not so this is also an invalid uh formula so let's see that what would be the potential solution what so let's start from the very simple example and see that what would be the intuition behind building a solution suppose we are given an example that looks like this where we are given all of the brackets that are of the same kind and we are given some opening brackets and some closing brackets well we can clearly see that this is a valid approach and how we can determine is that we can actually create a counter and what this counter does it that any at any given moment we identify an opening bracket we are actually going to increase the value in this counter and at any given moment if we encounter a closing bracket we are actually going to decrease the value in this counter and at the end we have to check that whether the value inside this counter if that is equal to zero which means we can determine that the same number of opening bracket and closing brackets are present and then we can say that the string is actually valid if that is not the case we can say it is invalid so if we see that in action first of all we have three opening brackets so we will increment the value of this counter three times and if we do that we will get the counter value to be at three again now we identify a closing bracket so now this value from three becomes two again we identify two more closing brackets so again it go it gets decreased two more times and then we get the final counter value to be zero and because we get this value as zero we can say that okay this string is actually valid string and the same number of opening and closing brackets are happening so this is one way to identify a solution but in this case the complexity is actually very simple why because we are only using one kind of opening and closing brackets in our original problem we problem we are actually told that there are three different kinds of opening and closing brackets and we will have to keep track of them also we need to keep track that in what order they were opened and closed and that order also has to be maintained so it is not just as simple as keeping track of counter that we create three different counters for all single typ one of them and then we see that at the end whether this value is zero or not we also have to keep track of that what is the order they were opened in and they were closed in now for the optimal solution we know we need to take care of two things first thing is we need to check that whether the opening and closing number of brackets are same for each three different types of parentheses or not second thing we have to take care is that what is the order in which they are opened and closed so first let's tackle the first problem we know that for every single opening bracket there has to be a closing bracket and they are always in pair so now to quickly look them up we are actually going to use a hashmap now inside our hashmap we are actually going to have all of these closing brackets as the keys and their opening brackets as corresponding values so we are going to have three entries now we have to take take care of their order and number of occurrences so the idea is we are actually going to use another data structure called stack and the stack is actually going to be very helpful to us so let's try to understand this with an example that how we are going to use a stack over here suppose we are given an input that looks like this okay so I'm going to show you two examples um on how we are going to solve this problem so first let's take this example and the idea is that at any given moment we identify an Open Bracket we are going to add that value inside our stack and at any moment we are and going to encounter a closing bracket we are going to pop a value on from the stack and then we are going to see that the whatever the value we popped out if that is the same value that is for any given uh hashmap value we have inside the string for this that particular closing bracket so let's see that in the action first of all we identify these three opening brackets so we are going to add all of the entries inside our St so first we will add a curly bracket then we will add uh these two brackets once we are done with this one now we have a closing bracket our hand the moment we identify a closing bracket remember we will have to pop the value out of our stack so we are going to pop the value out of the stack and the value we have popped out is actually this one now for this closing bracket we are going to see that what is the value of that bracket inside our hashmap and the value of that bracket is also like this and we are going to compare these two elements that whatever we took out from the stack and whatever we got from this hashmap and both are same so because both are same we can say that okay we are good so far and now so far we have actually uh taken care of these four elements and now we are on this element again this is also a closing bracket so because this is also closing bracket we will have to pop a value out and we are going if we pop a value out we will get a value that looks like this where that we are arrived from our stack and now we are going to check that for this particular bracket that we were iterating over what is the corresponding value inside the hash map so the key is this one and the corresponding value is this one so the value we found from our hashmap is also this one and they both are same so because they both are same we can say that okay we are good up until this point now we are iterating over this curly bracket so we again pop and also I have forgot to uh delete this value now again we pop out a value from our stack so now we don't have this value over here and we have a bracket that looks like this again for this closing bracket the value inside of our hash map is also an opening curly bracket and both are same so we are good up until this point now we are only up to last two characters so this is also an opening bracket the moment we identify opening bracket we will add an entry to our stack and now this is a closing bracket so again we will pop this entry out after popping this entry out so this is the value we popped out from the stack and then we will compare from our hashmap so the value is this one and both are same so we are now we are at the end of our string and because we are at the end of our string we are going to check that whether inside the stack we have entry any entry or not we don't have any entry so we can return true in this case and we can say that the given string is actually valid and this would be the answer now uh let's take one more example exle where the string is not valid and see that what we are going to encounter in this case suppose we are given a string that looks like this so in this case we have two opening brackets and one closing bracket so first of all we identify that this is the opening bracket uh we are going to add an entry over here again we encounter an opening bracket we are going to add an entry over here now we encounter a closing bracket the moment we encounter a closing bracket we are actually going to pop out the value from our SEC and the value we popped out is actually a curly opening bracket now for this closing bracket we actually have a corresponding value inside our hash map that looks like this one now these two are actually not same so the moment we identify that these two are not same we can immediately return that this string is actually invalid and the parentheses are not in correct order so we we are done with this one time complexity is actually going to be big go of n where the N is the number of entries present inside the string and even in terms of space complexity because we are using a stack and hashmap but we don't care about hashmap because it has finite number of ENT but for the stack the values will be dependent on big of n as well on the number of entries present inside the string now let's move on to coding so first of all we are going to initialize our hashmap and inside the hashmap we are going to store the values for three different brackets that we are given we are done with this one now we are going to initialize our stack and we are going to name it as stack as well and now we are going to run a for Loop across the given string so first of all we are going to initialize a character C and that is to keep track of whatever the character we are looking over inside the given string now we are going to check that if the current bracket is opening bracket or closing bracket which means that if the key value is present inside this mapping bracket then we can Define that it is a closing bracket if not then we can Define it as an opening bracket so if the value is not present inside this ma bracket key which means that we will have to uh push the current value inside the stack if not which means that the value is actually a closing bracket and then first of all we are going to pop the value out of our stack and then we are going to compare it with whatever the value pair inside the map bracket we have and if the stack is empty we can return false immediately so in the lse condition we check that if the stack is empty we can return false immediately if not we are going to pop out of the pop out a value from the stack and we are going to name it as top element and now we are going to check that whether that is the same value that is present for the map bracket value key and if the values are not same we can return return false immediately as well and if that is not the case eventually if we get out of the loop then we will have to check that whether the given stack is empty or not if the stack is empty we can return return true or else we can return false let's try to run this code okay seems like our code is working as expect expected let's submit the code and our solution is actually pretty fast compared to a lot of other Solutions uh so I would be posting this in the comments so you can check it out from there thank you hello friends hope you're having a fantastic day today so once again we are going to do an awesome lead code problem that is extremely popular at all sorts of it companies so without any delay let's get started so the lead code problem we are going to solve today is called largest rectangle in a histogram this is a lead code hard problem and also an extremely welllike problem now the statement is quite simple and straightforward we are given an array of integer called Heights that represent the histograms bar height and we are also told that the width of every single bar is one now we need to return the area of the largest rectangle that we can make inside this given histogram so this is all we need to return and now let's try to understand this with an example so for this we can make a rectangle that looks like this now the area of this rectangle is going to be two because the width of this portion is 1 and the height of this portion is two so 2 * 1 is going to be two so same way there are multiple different options we can have in order to generate the area but we need to find the maximum area and in this case the answer would be retrived using these values where if we make a rectangle like this using these two bars so now in this case the area is actually going to be 10 why because the height of this portion is five and for this one the width is 2 so 2 * 5 is going to be 10 so this is what we need to find and this is what we need to return so Brute Force approach is actually quite straightforward and very simple now one thing we can do is that we can take this one single rectangle uh starting at position zero and then we can see that what are every single possible areas we can make so one area would be like this second area would be like this the third area would be something like this uh fourth area would be something like this and so on and so forth and eventually we do all every single possible combination uh based on every single position of the given rectangle bar height and then eventually we would find a solution like this that contains the most optimal approach and this solution would work fine we would be able to eventually find the answer but the this is going to work in big of n Square time because at every single time we are doing lot of extra and overhead work so what is the most common thing we can imagine well number one observation we can make is because we can see that the height for this zeroth index is two at the moment but the moment we want to consider this first index as in combination with this two then the maximum height we can imagine is only going to to be able to one which means we are only at the higher height until we encounter a height that is lower than our current height and whenever that happens we will have to start considering the lower height and we need to understand couple of things if we want to calculate the area we need two items first item is the height so we already know that which height are we going to consider based on the lower height compared to all the other possible Heights that is uh number one observation second observation is we need to consider the width so so width we can simply calculate based on the current index position where we have or we can also keep track of that where did that height started existing that in terms of finding the right side boundary of any particular rectangle we can only find it until we find a lower height that reaches so there are actually three examples we can see very easily first example is at this position number two or this uh initial first position where the current height is two and the current height is located position number zero but the moment we try to consider the next element we will have to get rid of this height too because now it is no longer in the existence which means the maximum area we are being able to generate using this bar two is only going to be two okay now next thing another example is we just saw with the value number five that with value number five we can only say that we can use rectangle five or bar five until we reach to this index position number four and then so which means maximum area that this bar five can make is going to be of width two and height five so total is going to be 10 same way for the six six comes into the existence at index number three but since the height at index number four is actually lesser than the index number three which means this six only remains in existence just for one single bar so the maximum area we can make over here is all is only going to be of uh size six and this is the whole logic this is the whole meat of the solution now after understanding this we can actually make a suboptimal solution using the same very simple approach and then we will try to improve upon that solution so the sub suboptimal solution that I'm proposing is that at every single position we identify that what its right side boundary is and what its left side left side boundary is so what is the maximum height and width we can make and based on that we can do all sorts of calculations and then find the solutions very quickly so let's try to see this solution in exist in action the idea is at this position the maximum left side height we can make is to the maximum right side height we can make is also going the maximum width we are able to achieve is one which means the maximum area we can generate is only going to be two for this position number one the maximum width we are able to achieve is going to be six because this one remains in existence throughout this whole process and the maximum height we can achieve is only going to be one so over here maximum area we can make is only going to be six now at this five the maximum left side we can go is only up to 2 because it starts at position two the maximum in terms of right we can go is only up until position four or before position four so up to two and three so width is going to be two so over here we can make the area 10 for this height six we can only make the maximum height as six same way at this position number two the maximum we can make is actually going to be this much where currently the width is going to be uh four and the height is going to be two so maximum area we are able to generate is eight and same way at this three the max maximum we are able to generate is simply going to be uh just just this one because one before that is actually in the Lesser height so we can maximum area we can make using only or or the entire height of this area is going to be three and in the end we can simply return return 10 as the answer so what we did is for every single element we try to see that what is the left limit what is the right limit and what is the total area we are able to generate and then we can very easily store the answer now this solution would just be good if you provide this solution in an interview it might even work but the thing is there exist a better solution where if we just use stack to keep track that what is the current index position and until what previous index positions we are maintaining that height then we can very easily solve this problem why we need to use the stack because think about it for every single position we are only going to have that position in existence until we find another bar with a lower height which means the moment we find another bar with a lower height we can actually go back to the elements that are already present inside the stack with the higher height and calculate the area that's it that is the whole logic so now let's try to see the solution I'm proposing in action so now let's just quickly initiate our stack now inside the stack we know that this is going to operate in the in terms of last in first out principle and one the other thing is we can actually keep track of the bar Heights but then we would also have to find that what was the initial position of that this particular value so rather than a better approach is that we actually store the index values and using the index values we can quickly look up that what has been the bar height at that position in big go of one time because we already know the index position and then we would be able to also calculate the width depending on the current index position and the existing index position inside the stack so let's try to see the solution in action so initially stack is empty okay and we are also going to have an a variable where we are going to store the area so let's just mark this one as Max Max area that we have been able to calculate so far okay so initially stack is empty now we are at this index position number zero so we add index position 0 inside our stack okay and currently we know that this height is two now next thing is we iterate over to the next element and we identify that currently we are at index position one so the height at index position is actually less than the height we currently have on the element that is already present inside the stack which means this position of this element two is no longer relevant because we found out a value that is lesser inside the in in its existence which means this only exist until this portion so we will try to we will pop this element out and we will calculate the possible area that is that this element has been able to generate So currently for this first position this has been the area it is able to generate that area is going to be two that is the height and multiplied by width that is one so the maximum area we have so far is two okay now once again uh we are going to add value number one inside inside our stack saying that currently one so the the height of this one is also one and currently we we will only pop one out when we either reach to the end of the array or so or end of the Heights or we find some place where the height is actually zero and then we have some more elements okay so this is always going to be relevant in this example now we are at index position number two so notice what happened at index position number two the height suddenly increased compared to what the height we already have which means this one is still valid so because it is still valid we are going to keep it inside the stack not popping it out and we will add one more element five or the this index position two on top of the stack because now this is also relevant so far so we are going to put two inside the stack so its subsequent value is bar height five then we are next we identify height six which means this five is still relevant so because is relevant we are once again going to add value number six on top of the stack or soorry not value number six but the index position of six which is value number three so we put value number three inside on top of the stack and the height is six now we suddenly encounter the value uh at index position number four that is height two so any single value that has greater than two height has to be popped out of the stack because now that is no longer relevant which means for first of all this six is now no longer going to be relevant because the height is six and currently this index position is three and notice that the index position for this bar height two is four which means depending on the index position difference we can actually calculate the width for which the six was relevant so six was currently relevant for width one so currently let's pop six out if we pop six out currently this three is no longer present we know that this was relevant for one width which means width was one and the height was six so now the maximum rectangle we have been able to find is of size six which is greater than the previous maximum we had so we are going to update that okay now are we done no because this is two and this value is five which means we would still have to pop one value out if we pop one value out in this case now notice that the height at this position is two and the height at this position is four so because this is a greater position compared two over here so what is the width we found the width is actually two and what is the height we have is five so this is the height and also let's get rid of this two from our existing SE okay and now this area is going to become 10 so let's just add an area 10 now once again uh we this we have this element one and currently this element is two so 2 is greater than 1 so because 2 is greater than 1 we are not going to pop one out because this one is still relevant so we are just going to Simply add two on top of one so let's just quickly add this index position number four with the height two okay and now currently next one we found the increase inside the height which means this two is still relevant because this two is relevant we are simply going to add an element five on top so we are going to add element five on top now adding index position number five now we reach to the end of the array which means the moment we reach to the end of the array we will have to start popping every single value out compared to its current position so currently we pop value number five out which means what is the height over here the height is three what would what would be the width width would only be one because it is only relevant for this one portion because currently we are at the end of our Loop so the area we have been able to calculate by popping this uh value number three out is going to be three now currently three is less than uh value 10 which is the maximum area we have so we are not going to update the maximum area okay now we are going to next uh pop out element number four so if we pop element number four out it has been relevant for this much portion of the time which means currently we have 2 multiplied 2 so the area is going to be four 4 is also less than 10 which means this area is also not relevant and last one we will have to pop element number one out that has the size one or the height one so for this height is going to be one and this has been relevant since position one until the very last position so this has been relevant for the width five oh sorry for the width six since the very first position it has been relevant so now because this has been relevant since uh position six so the maximum area we have been able to generate is also going to be six but still it is not greater than the maximum area so after the end of this Loop we can simply return the max area to be 10 and that's it that's the whole answer now if we see time and space complexity in this case the time complexity is going to be big of N and the space complexity is also going to be big of n so the coding solution is actually quite straightforward first we have a variable called Max area where we are going to be storing the maximum area we have been able to identify so far then we have our stack that we initialize and we also have a variable n the for the to store the length of the given array then we have for Loop to iterate over the given array now first we check for a condition that if the if the given I is equal to n which means we have already crossed every single element then we can mark the current height as zero because this is to take care of the last element if that is not the case we simply take the value of the given subsequent height height from the heights array okay now we have our while loop where we check that while the given stack is not empty and and the current height that we have been able to identify for any given I element is less than the current height that is already present inside the very first element of the stack then we will have to calculate the area for that uh where we simply calculate the height based on by popping the element out of the stack and then we calculate the width by uh subtracting the value of the current I minus the current element that is that was present inside the stack minus one and then we calculate the max area where we compare two elements based on the given Max area that we have been able to identify so far and the given current height and width multiplication or the current area that we have been able to identify whichever is greater we are going to keep it that and in the end after we run out of this V Loop we are still going to push the current element inside our stack and by the time we are done with all the elements we should have our maximum area being populated with the correct value and then we can simply return that so now let's try to run this code okay seems like our solution is working as expected let's submit this code and once again our solution runs beautifully extremely fast in terms of time and space complexity so once again the solution is present in the GitHub repository the link is in the description so you can check it out from from there thank you hello friends hope you're having a fantastic day today so once again we are going to do an awesome lead code problem that is really popular among tech companies for the interviews so without any delay let's get started so the lead code problem we are going to solve today is called longest valid parenthesis and you can see that this one is a lead code hard problem and also an extremely welllike problem on lead code the problem statement is actually quite simple where we are told that we are given a string that contains just the characters opening uh circular bracket and closing circular bracket and now we need to return return the length of the longest valid parentheses substring suppose we are given a string uh like this now we can see that all of these are actually valid substrings because they are coming in correct order so in this case since all of them are correct we can say that the longest sub substring that is valid is currently of six characters same way let's try to take one more example suppose the string we are currently given is something like this then we only have a valid valid substring that is only valid for just two characters and these two are not part of the valid substring so okay so we need to calculate that what is the consecutive longest valid substring and we need to return that now Brute Force approach logically we are going to do the most simplest things possible where we are simply going to check that uh for every single substring from starting from any particular string we are going to check that what are the longest substring we are able to generate until we encounter some invalid substring so overall this approach is a very simplistic approach that would work fine and generate the result but the issue is this would operate in big of n Square time so we need to find some way to shorten this calculation and in a single go we need to identify that what are the current substring that we have been able to find is it valid or not and if it is valid what is the current length what is the maximum length we have been able to identify and subsequently when will at what point does it stop becoming valid so these are the questions we will have to answer uh and then only we can find the optimal solution so now let's start looking about that what an optimal solution should look like suppose this is the string given to us as an input and now we are trying to find the solution now let's try to make some understanding clear and that would help us build our solution number one thing is the moment we identify at any given moment that there is a closing circular bracket and we haven't found the opening circular bracket which means we can directly ignore this case because this is definitely invalid because it does not have any previous opening curly bracket that is number one observation number two observation is for any single opening curly bracket we will need to keep this information stored somewhere that we have one open bracket for which we are trying to find a subsequent close bracket so it can come over here or maybe here or maybe it cannot be possible but we will need to have that information so these are the two pieces of information we will have to consider third thing is it could be possible that we may find some existing valid uh sequence like this but this may not be the longest valid sequence because longest valid sequence in this case is probably going to be this one so which means we will have to keep track of the current sequence and we will also have to keep track of the valid sequence and also the longest sequence considering all of these things it would make really good sense to use stack data structure for this problem and why are we using stack because if if we have to consider this to be valid then immediately before this there has to be an Open Bracket then only we can see that this is a valid scenario and then this bracket would not be considered which means this still needs to live inside the stack because stack follows an awesome property of last in first out that is going to be greatly helpful to us so now using stack we would be able to solve many different problems and the idea is that for each of this position rather than just storing whether it's an open or curly bracket we can actually store the index values so let me write down the index values and now the thing is inside the stack we will only push values when we encounter some Open Bracket because it could be possible that some time in the future there might be a closing bracket so and whenever we identify a closing bracket we will try to see in the stack that whether there exist any particular uh bracket that we can pop out if it does then then it would be part of the valid sequence if it is not there then we will see all sorts of scenarios okay so I hope that all of these explanation makes sense and now you are able to understand that how we are actually going to use the stack for our solution so let's quickly generate the stack now we are going to keep track of few variables so first one is that what is the current length we have been able to find next what is the maximum length we have been able to achieve now in order to keep track of the current length we will have we will need to know that where does the current valid substring starts so initially because we are actually using this as zero so initially our starter pointer needs to be somewhere over here before zero because we are starting the index from zero because imagine a scenario where we are only given an input like this which means this is 01 So based on the index location we know that this is actually a valid substring of size two but because we are starting the index from zero so we will actually create cre our initial starting pointer from minus1 so it would be very convenient for us to calculate these values okay and you will understand the logic once we iterate over the the example so initially our starting pointer is going to be located at minus one position and this is where our starting pointer is okay so now let's quickly start iterating over the solution so logically first here we identify that this is a closing bracket for closing bracket we will have to pop one element out from the stack but the thing is currently stack is empty so because stack is empty this has to be an invalid entry so we can ignore this case and move on to the next element but when we move on to the next element we can say for sure that this is never going to be part of the uh valid substring so we will need to update our start pointer so now we will have our start variable uh being located at position number one so let's just mark start variable at position number one current length is zero and maximum length is also zero we haven't been able to find any values okay so let's just Mark these now we encounter an opening bracket so the moment we encounter the opening bracket we are going to be pushing the values inside the stack so let's mark the index value same way once again we identify an opening bracket so once again we are going to Mark a value inside the bracket and when we are opening the brackets we don't need to update the current length or the maximum length because we haven't find any valid substring so far okay now we identified one closing bracket so the moment we identify a closing bracket we will have to pop element out of the stack so let's try to pop one element out of the stack if we pop this element out of the stack by the way this is this has to be number two okay by the way so number two index we are popping out of the stack which means that currently that what has been the current length we have been able to identify it so far that is currently we are at element number three the element we popped out is located at element number two which means now this is no longer present over here which means currently we still have one element that is left inside the given stack so so far we can do the difference between this current element and the element that is already present inside the stack using the peak function so the difference is 3 minus 1 so so far we have been able to identify a length of two size valid string so let's update the value that the current valid string that we have been able to find is of size two and the maximum length we have been able to identify so far is also of size two now notice that we are not using the start variable right here uh because this is still not taken care inside the existing valid substring so that's why as long as there are some values present inside the stack we cannot conclude that stack is empty and we have taken care of every single substring so that's why start pointer is still going to remain here so now let's move on to the next element now we are at position number four once again we identified the opening bracket so let's try to add one more value inside our existing stack so now the value is four okay now once again we identified a closing bracket so the moment we identify a closing bracket we will have to pop one element out so let's quickly pop this element out now the element that is currently left inside the string is of size one so because this is of size one and the current element we are at is of size five which means the current substring that we have been able to find is 5 minus 1 so this is going to be uh four so current length that we have been able to find the current maximum length is of size four and because this is of size four which means we will also have to update our maximum length as well and that is also going to be of size four okay now currently inside our stack we only have uh one element that was that has been here for quite some time and now let us also try to move to the next element so once again we identified one more opening bracket so we will try to put element number six inside the bracket now once again we identified the opening brackets so we will try to put element number seven inside the bracket and now at element number eight we identified and by the way this current length would be res uh reset every single time we update the value okay so this is always going to be reset because we don't know that what the current length is we only Define the current length based on the value we pop out so now this is a closing bracket which means we will have to pop one element out so now we are located at Value number eight we popped element number seven out which means we still have one more Open Bracket located at element number six that we haven't taken care of so now we will do the difference between 8 6 and the value is 2 so current valid length that we have been able to identify is of size 2 but that is not greater than the maximum length we have been able to achieve so we are still going to mark this as value number four so this is the logic on how you can actually use stag to solve the problem now let me just show you one more example very quickly uh and then we will uh move to the coding solution basically this is the optimal solution so now let's just quickly start using the logic So currently we identify an opening so we are going to mark value inside the stack we once again identify a closing bracket so once again we are going to pop this element out of the stack the moment we pop this element out of the stack and currently the stack is empty if the stack is empty then we will have to we found a valid string from the starting value so we are going to do the subtraction between the current value minus the starting value which means 1 1 so the answer is going to be two so the current length that we have been able to identify is two and the maximum length we we also identified is also two okay now once again so far remember this s is the starting value is still going to remain here but now we identified a closing bracket but for this closing bracket we don't have any value inside our stack so because the stack is empty which means this is an invalid portion so now the starting value has to jump so now we are going to jump our starting value to start at this element number three okay now this at this element number three we identify an Open Bracket so we are going to add value number three over here once again for four we identified a closing bracket so we will pop an element out of the slope So currently the stack is empty if the stack is empty so now we are uh located at this position number four and by the way our starting position should be at this position number two okay so now uh currently we need to because stack is empty we will need to do the difference so the difference between Uh current index and starting index is going to be 4 minus 2 so value is 2 so this is the current length we have been able to identifi and this is for this portion so now maximum length does not need to change once again we identify an Open Bracket so we are going to add value number five over here and once again we identified a closing bracket so now we will have to pop this element number five from the loop as well so currently the string is empty because the string is empty we will have to do the current value minus X so it's going to be 6 2 so once again and the current length we have been able to identify it is four so the current length needs to be updated this is going to be four and because this is greater than our maximum length so we are also going to update this one and because we reach to the end of this given string so we can return the maximum length as four so this is the whole logic that we can use to solve this problem and by the way if we see time complexity in this case the time complexity is going to be simply big off n because we are simply iterating the given input array just once if we see space complexity because we are using an extra stack we will it will also going to be big of and so the coding solution is actually quite simple first we have a variable to store the maximum length then we initialize our stack and then we initialize the first value inside the stack as minus one this is going to be our starting pointer okay then we have our for Loop to iterate over the given string s uh character by character we check that whether the given string if that is an opening bracket or a closing bracket if it is an opening bracket we simply push that index position into the stack if that is not the case then there can be couple of scenarios so in either scenario first we will have to pop the element out of the stack now after popping element out of the stack if the given stack is empty then we need to push the current index as the base for the next valid substring and uh if that is not the case then we are going to calculate the maximum length so for maximum length we are simply going to to do the max to compare the current maximum length minus I minus the peak that is currently present inside the stack and this is going to be give you give us the current length that we are dealing with and in the end we simply need to return whatever the max length we have been able to identify so let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs extremely fast and this is a very good time and space complexity so once again I will be posting this solution in the in our GitHub repository so you can check it out from there the link is in the description thank you hello friends hope you're are having a fantastic day today so now we are going to do an awesome stack problem that is a actually a lead code premium problem so this is going to be really interesting very popular question and very interesting subject so without any delay let's get started Okay so the lead code problem we are going to solve is called Max stack this is actually a lead code hard problem and the thing is because this is a lead code premium problem uh I took this description from another website called Le code. CA so thank you so much to whoever maintaining that that website now we need to design a Max stack class that supports these five functionalities now if we see the functionality the first three are pretty common where we are pushing an element down the stack where we are popping an element out of the stack and where we are uh just checking what is the Top Value inside the given stack these three are the common functionality of any particular stack then we need to add two more methods where first one is a peak Max method uh and second one is the pop Max method so if we do the peak Max method we will need to know that what is the maximum element currently and if we do pop Max then we will have to pop the maximum element that is right now inside the stack outside so let's try to see the solution for this problem so logically uh let's assume that currently we have an empty stack okay so we have the option to use five operations and so let's try to First quickly push some elements inside down the stack so if we let's push value number three and then value number five and then value number one okay so now currently we push a few elements now if we want to pop and let's just add one more now if we want to pop we can pop one element out as well so if we do the pop operation then we will we won't have value number seven now we can also do a peak operation so if we do Peak operation then we can simply check that what is the very first element so answer of this is going to be one then if we do if we want to do Peak Max which means we should see that what is the current maximum element present inside the given array which means the current maximum element present inside the given array is actually value number five even though it is not at the top of the the stack this is the current maximum element so this needs to be value number five and if we have to pop Max then we need to pop the value number five out of the stack not value number one even though one is the very first element so this is how we will have to design this algorithm and design data structure in order to keep these values now we know that completing these uh items is very simple and very similar no issues with this one this is a regular stack functionality and every single language like language like Java python C++ they have they all have their own stack versions that we can simply use the problem comes when we need to do this peak Max and pop Max problem uh operations because the thing is this is actually slightly complicated because of variety of reasons now the very first thing that comes to our mind is to have a variable called Max where we are going to store the maximum value that we have been able to identify inside the given array and this should make our lives easier this is the Primitive logic we can think of where let's assume that we add value number one so we need to update the value of Max to Value number one then once again we add value number six so we once again because 6 is greater than one so so far the maximum element we have been able to identify is six then we have value number three so three is not greater than the current maximum element which means we don't update anything or we don't do anything now after this uh let's say we add value number eight so once again the maximum element needs to be eight so so far you must be thinking that hey this seems pretty convenient why don't we just have one value to keep track of the maximum element and at any given moment I want to see that hey what is the maximum element I can just simply look at this variable and find the answer the problem is when we do the pop operation out of this given stack then there would be an issue because now let's say that I decide to pop this eight so if I do if I pop this element 8 I know that now 8 is no longer the maximum element present inside the stack but I don't know what is the other element that is the maximum element but instead of just having one simple variable Max we actually need to have a variable another stack called Max where for every single entry inside the original stack for that entry we will have to keep track that what what has been the maximum element that we have been able to identifyed so far and keep updating that list depending on the how we uh push out or pop out the elements from the given stack so let's let me try to explain what I mean the idea is let's assume that for the max we have to worry about two operations first one is the uh Peak Max where we are simply watching that what is the max element that is currently present and second one is the pop Max where we are popping the maximum element out at the current position inside the given array so we have created our own Max stack array uh sorry Max stack so this is our Max stack and this is our regular stack okay now let's assume that I wanted to enter value number one so what I'm going to do is I'm going to add value number one currently this Max stack is also empty so so far the maximum element at this position I have been able to find is also one so I'm going to store value number one over here once again I identified Val number six so because value number six is greater than 1 I'm just going to put six as normal value over here but over here because value number six is greater than value number one so I'm going to say that up until this point of the stack the maximum value I have I have been able to identify is six that I have presented over here and some reason if I decide to pop this element out of the stack then I know for sure that this element also needs to be popped out and then the maximum element at this position will be corresponding to the maximum element at this position that is value number one so which is pretty convenient for us now let's try to add one more element let's say three now once again even though we added value number three over here so far the maximum value we have been able to identified up until this point is once again six so we are once again going to mark value number six over here and then once again let's say we add value number eight so once again we are going to add value number eight over here here because that is the maximum value we have been able able to identify so so far let's repeat what we have done we did the push operation in big of one time no issues with that now at this at any given moment we can also do the peak operation uh and the moment we do Peak operation whatever element is located at the top of the stack we should be able to see that so this is also going to happen in big off one time so once again no issues with this one so we already took care of two variables we can also do the pop off operation easily from the stack so pop operation can also be done in big off one time and we can do Peak Max as well in big off one time because this is also being happening or maintaining in constant time so this also happens in constant time so we took care of four operations in big off one time just by simply using these two different Stacks but now the important thing is that how we are going to manage the pop Max operation for that we will also have to do the pop so let's try to First do couple of Pop operations if I pop element number eight out of the given stack which means now stack does not contain eight value anymore and I will also have to update the maximum element up until this point as well okay now at this position let's say I decide to do pop Max so if I do pop Max at this moment I should not be kicking out value number three from the stack because this is not the maximum element so far the value I should be be kicking out is actually going to be the value number six so what I'm going to do is that I'm going to kick value number six out of this given list up until every single point that I have been able to iterate so far and the moment I kick value number six out I'm going to do a peak operation to see that if this given current maximum value if that is greater than the current maximum value I'm left with and if that is the case then I will need to update the given Max element to add in incorporate value number three as well because remember that in the previous state in this state we did not had value number uh six as part of the given uh sorry value number three as part of the maximum value so far but because we did the pop Max we kicked a value number six out and at the same time we will also have to pop these two elements out as well and we would be left with value number three okay so this is the whole thing that we need to do and this is how we can solve this problem using two stacks in order to con convey this message so this is the whole solution and using this we can complete everything in big off one time all five operations so now let's quickly see the coding solution and then things will be make much more sense okay so now since this is a lead code premium problem and we don't have that subscription at the moment I'm just going to explain you the solution in the the notepad but this code would work fine and the code is also present in in our GitHub repository so let's understand the code so first we are going to create couple of inte uh couple of stacks for stack and Max stack now for the push and for the pop and for the top we need to the all of these three are standard operation the thing is pop and top are going to remain the same the only problem is that for the push operation we actually have to push the element in both the places which means in the stack we are just going to push it as a regular push push entry but for the max stack we will first have to check that what has been the maximum element inside the given stack by based on the definition of this x value so far using math. Max function and checking that what has been the current maximum in the max stack versus the current value we are trying to enter so we are always maintaining the maximum element for any given X element inside our Max stack stack okay then for the pop operation we will have to pop the element from both the places Max stack and also from the given regular stack for the top operation we simply have to check that what is the maximum element on our regular St uh stack uh and we can just do a peak operation now for the peak Max operation we will need to do the same operation but now this time in our Max stack stack rather than our regular stack and the last one is the slightly more complicated method that is the pop Max method where first of all we are going to initialize a new stack called buffer because remember uh the the value we are trying to kick out is presented somewhere in the middle in the regular stack so meanwhile we don't find that value we will have to buffer that from our regular stack so that's why we are going to push every single element uh from our normal stack to the buffer stack until we until we find the top element to reach to the Max and then we will simply pop that element out from the regular stack at the same time we are also going to pop that element out from our uh Mac stack as well and then in the end in inside the buffer we are also going to push all of those elements into our regular St stack using the elements that we just stored inside our buffer stab temporarily so that's why this pop Max method is slightly complicated method and uh you can see the coding solution present onside our on our GitHub repository so hopefully this explanation made sense to you and uh yeah thank you so much