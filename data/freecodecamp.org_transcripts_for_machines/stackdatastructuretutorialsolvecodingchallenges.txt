Stacks are a common programming data structure and many programming interview questions require knowledge of stacks tanishq has helped thousands of people prepare for coding interviews and now he's going to help you understand the stack data structure by demonstrating how to solve a bunch of common coding interview problems the problems go from easier to harder and Denise will be guiding you the entire time my name is Dani sheltery and I'm very excited to bring you this course on Stacks so let's go ahead and get started hello everyone and welcome let's talk about the implementation of Stack we are going to start off with a couple of examples to understand the reason why Stacks are built in first place then we'll look at the implementation level details of stacks in terms of python and C plus plus all right let's get started now if I ask you the question what do you see on the screen you might reply that there looks to be a couple of books present on a shelf so you can call this a stack of books now what would you do if you had to read the first book the book on the top of the stack well you want to read Harry Potter so you will just pull it out of the stack you'll remove it from the stack you'll read it and then you'll push it back on to the stack once again now this is simple and fine but what if you want to read grocking the coding interview now what do you do of course you can drop pulling it out from the middle but all of these books are dense and heavy and you don't really want to disturb the balance of the elements on the top of the stack so what you can do is you can take out the first book you can take out the second one and then finally read grocking the coding interview you read it and then you can put it back on the stack along with these two books what we have just seen is a very important property of stacks that is called the leaf ordering lifo stands for lost in first out saying that the elements that come into the stack towards the end that is the elements that come in the last or the first ones to get out blast in first out now this is a property that will exploit again and again throughout this entire series it's going to be a central property and it's the heart of the reason why we use a stack in many of these questions now let's go ahead and formalize the operations we can do on the stack because we know that if the leaf ordering is being followed we have to use a stack but how do we exactly we use it well let's look at a couple of operations the first operation we saw was removing items from the top of the stack we call this operation formally the pop operation because we are popping the elements out from the top of the stack right so this is going to be the pop operation the second operation we saw was to add the book back onto the stack in other words we're looking at a push operation pushes the formal term used to define saying that we want to add an element onto the stack in other words we'll push an element on the stack now there's a final operation that we do very commonly and that's the peak operation now the peak operation simply says hey go ahead and take a look at the top of the stack go ahead and take a peek at the top of the stack right so these are three operations that we'll keep in mind all right so now let's go ahead and actually look at how these are implemented in terms of python and C plus plus Java implementations are pretty close to both of them so even if you understand just one implementation way you'll be able to do it in any other language I have ensured and tried my best to make sure all of the codes are language agnostic they can be easily translated from one language to the other without having a lot of issues all right so let's go ahead and actually look at how we are implementing these the first thing is how do we initialize this tag and in Python we're going to use the list implementation of Stack because there is no inbuilt internal class for it we're going to create a list empty list of our own to initialize the stack in C plus plus there is so we're going to use stack and we're going to have a stack of int variables and we'll call it as pretty simple all right how do we push in Python we do stack dot append and so we can do stack dot append an item and this is going to return a nonvalue that is it does not return anything we just append this element onto the top of the stack in C plus plus we simply do s dot push this is going to return a null all right how do we Peak how do we check what is the element at the top of the stack well in Python the way to do that is to use stack of 1 that is it is going to give you the last element on the top of the stack right so in this case it's the element three how do we do it in C plus plus we simply do s dot top now remember this is a slight terminology difference but nothing much you want to look at the top of the stack you want to peek at the top of the stack this is how you do it all right how about pop in Python you do directly stack dot pop and that is going to return your value three this is a crucial Difference by the way in Python you're going to get a return value of 3 however in C plus plus when you do the pop operation you're not going to get any return value all right this is super important especially when it comes to implementation keep the language specific details in your mind all right the last thing which will also very commonly use is to check whether the stack exists or not in other words is the stack empty or not so in Python we can simply use the stack variable and that internally checks its length so in our case we appended one element we checked the top of the stack and then we popped it out so the stack is currently empty in both the cases now if you just use stack if you say if stack colon blah blah blah that is going to return of value of faults because the stack is empty right in C plus plus we can do s dot empty which is a function that is going to work on the stack variable and it's going to return true saying that you know what the stack is indeed empty so again small implementation level details that you have to keep in mind all right so now that we have a better understanding of how do we Implement Stacks let's go ahead and take a look at a real life test case where Stacks will be very helpful to understand hello everyone and welcome back in the previous video we talked about how to implement Stacks in terms of C plus plus and python in this video we're going to take an example problem simplify path to build up our understanding of stacks further in fact this question is present of both lead code and interview bit and has been asked in companies coding interview rounds many times this in fact forms a basis for very important point that how Stacks are being used in the real world as well all right let's go ahead and get started with the formal problem discussion so we're given a path and this path is a Unix path given to us and the goal of this problem is to return the canonical path now if you're not familiar with how paths are unique Unix based paths work I'm going to link to resources down below so you can check them out first anyways we're given a path and we have to follow four conditions to return a canonical path first we have to start from a single slash the slash represents nothing but the root directory second any two directories are separated by a single slash so we can have directory one slash directory 2 slash blah blah blah condition 3 says that we should not end with a trailing slash in other words the slash at the end of it if there is a slash at the end of it you have to return it all right fourth condition which is the most important one it says that it only contains the directories on the path from the root to the Target that is there is no period or double period directories now period and double period have special meanings period basically says that wherever you are stay that is whatever directory you are on currently just stay over there double period means take a step back right so whatever directory you are on take a step back all right let's try to uh formally build up our intuitions and our logic all right let's take a couple of examples to understand this better first things we have a slash home slash SD input the blue is the input and the green is the output which by the way is a common coloring schema followed throughout the rest of the series so you don't have to worry about anything all right so we have slash home slash and what is the output the output is slash home that's because we have a trailing slash at the end of the input which we remove all right let's go ahead and take another example in this case we have slash dot dot slash what it means is we start from the root directory and we have to take a step back because dot dot really means that you have to take a step back from the current directory and then we have a slash at the end so of course you can remove the slash at the end because it's a trailing slash but now this double dot means that from the root directory we have to take a step back but there is no step Backs from the root directory root directory is where you start so in fact this will simply be reduced to staying on the root directory that is from the root if you want to take a step back you will end up at the same route all right let's take another example and this time we have slash home slash slash 1337 slash dot slash first things first remove the trailing slash now what we notice that between home and 1337 there are actually two slashes what does that mean well in our case the implementation level detail is that if there are multiple consecutive slashes all of them will be useless basically and we only have to consider one slash in other words multiple slashes will get compressed to a single slash so we have slash home slash 1337 note that the period at the end now means that we have to stay at the current directory so we were at 1337 and we stayed at 1337 let's take a look at one final example which is going to be the most important one and this has sort of all of the conditions mentioned in the question so let's go ahead and formally try to break this down to get the logic first things first we start off with the single slash which is going to be a root directory this is by default present in all the test cases we have to start from the root directory now what's the next step we want to go toward the next value which we see is home now what does home mean who means that we have to go One Directory forward that is from the root you have to go to home all right so pretty simple but now you get a dot dot what does this mean this means that you have to take a step back which means that from the root you first went to home but now you have to take a step back and go back to the root all right pretty simple again uh work next we get a dot dot once again and since we are already at the root taking another dot dot simply means that go straight at the root all right so now we get a slash uh TMP and what does that mean that means that now we have to take a step forward we have gotten the directory and so we'll go to slash TMP and then we have a bunch of slashes together that we have two slashes that just gets compressed to one single slash and then we have a DOT now dot simply means that wherever you are stay so you viewer are the slash temp directory and we'll stay over there and of course the last slash at the end is just a trailing one so we'll remove it in other words the final answer we get is slash TMP as we saw in the first line of this slide so now let's go ahead and formally talk about how did we do this how are we going to implement this going forward and going backward thing if you have guessed it yes you are right we have to use the data structure of course this is a playlist of our Sac we have to use a stack but why do we use it again whenever we have a directory like home or slash TMP we have to take a step forward and whenever we have dot dots we have to take a step backwards and a good way to simulate that is by using a stack all right let me go ahead and show you how this formally works out so the first thing we get is uh home so home means that we have to move forward which means that we will push the value home on to the stack that is we'll append this value to the top of the stack now we get a dot dot next what does that mean that means that we have to go back One Directory in other words we have to pop the element out of the stack right we get a dot dot once again but the stack is already empty what do we do this is a special condition and we have to say that you know what if the stack is empty you can't really pop anything and we don't really have to pop either we were at the root and we'll stay at the root so the stack remains as is then we have TMP so what do we do next this is a directory so we append it we push this value on the top of the stack now we get a DOT what does that mean that means whatever directory you are at stay there in other words the stack remains unchanged so if we have to formalize what can we say let's focus on the core Parts first things first how do we start the way we start is at the root and that is nothing but the cue to initialize the stack right whenever we start we're going to initialize the stack now directory means taking a step forward what does that mean that means that we're going to append an element onto the top of the stack in other words we are going to push this directory in the stack right and what does dot dot mean dot dot now means that we have to pop we have to go One Directory backward so whatever you append it just pop it back again and then finally we have a DOT which means that we really do nothing do no operations and this is really it this is it for the logic of this problem let's go ahead and look at the optimize solution and we're going to code it up from scratch all right let's go ahead and look at how do we implement this question in terms of python code the first thing we'll do is initialize the stack to be an empty stack and then we'll start to iterate over the directories in the paths now obviously the path given to us is going to be a string which is separated by these flashes so each of them directories that is any two directories are separated by a single slash so we have to say go ahead and do path dot split by the Slash that is get me the individual directories and we'll see what to do next so what's the first condition we saw remember from the code remember from the logic the first condition we can say is that you know what if you get a DOT that is if you get the operation where the directory we have to move to is a DOT that means that wait don't really do anything right we don't really do any operation on the stack if we get a single Dot so it was the other case we'll have the directory is what if it's a double lot what do we do if it's a double dot we have to do an operation called pop that is we have to go back one step we have to pop the element from the top of the stack so we'll do stack dot pop but now is a very important Edge case right this is a very important condition I'm going to write see it's not always the case that you can pop this directory from the stack that is for stack dot pop to work you have to ensure that stack is not empty because if the stack is empty and you pop an element out of the stack that is going to give you an error whether it be a python or C plus plus or Java all of these languages are going to give you an error if you pop an element out of the empty stack so first we'll go ahead and check hey you know what if the stack exists only then go ahead and do the stack dot pop operation what do we do else what do we do otherwise well in case this Jack is already empty and we get a double dot what does that mean on an empty stack which means that we are at the root and we get a double dot which means that from the root we have to move a step back which means that we just have to stay at the root so the stack remains as is and this condition in the else condition we don't really have to do anything all right it was the final case what the final case is say that go ahead and append this value to the stack append this directory to the stack all right so this is it right we're going to return what well one of the conditions the first condition and the question says that the path starts with a single slash so we're going to go ahead and start with the single slash and since we have all the directories in the stack let's go ahead and do the join operation so we'll do uh join Dot start so what this is going to do is iterate over all the elements in the stack and join them with a slash in the middle all right so before we go ahead and run this code by the way there's one more condition that is important to know see because directories can have a case where we have say double slashes that is if we have slash home slash Foo slash these double slashes are going to give us an issue because when we split when we split this path by slash it means that there is going to be a case where there is one slash and then there's a empty string and then another slash in other words what I'm saying is we have to add one more condition saying that if the directory is actually empty that is if there were multiple consecutive slashes then we don't have to do anything like that right if we get multiple slashes we just look at it as one slash and we don't really do anything right so this is it for the logic of the code and let's go ahead and test this out on a bunch of input test cases looks to be correct so let's go ahead and submit this and we get it accepted all right so this is it for the solution to the problem simplify path hello everyone and welcome back let's talk about the problem main stack on interview bit all right so the goal of this problem is to design a stack that supports a bunch of operations first Operation Push we have to push an element X onto the stack very simple second operation you have to design an operation that returns as the top of the element that is it is going to see what is the top of the stack and return it third operation we have to design a function that pops the value out of the stack we have to remove the top element and return it right so all of these three operations up till now are something we've already seen that are like very basics of what a stack is but now there is a fourth operation given to us getman this function is going to return a value X which is going to be the minimum value of the entire stack now the only constraint that is given to us is that all of the queries should run in constant time that is we should take order of one time each now how do we start to think about a solution once since the problem is about using a stack let's go ahead and create a stack and we'll start to see what do we do once we get the queries all right so this is the simulation will run let's say we get the um query to push the value 7 onto the stack so now this is how the stack is going to look with the value 7 on top of it if you get push 3 we'll just Add 3 to the top of the stack we hit push nine we add 9 to the top of this track now let's go ahead and say that we get the query getman what do we do at this point of time gateman query says that go ahead and get the minimum element of the entire stack which means that a naive way to proceed about it is to go over all of the elements inside of the stack one by one and find the minimum value in this case we find the 3 is the minimum value so we'll go ahead and return 3. now let's say that we get another operation called pop so we'll go ahead and pop the element out of the top of the stack then let's say we get uh get min again what are we going to do iterate over the entire stack go over all of the elements one by one and return three we realize that three is the minimum value right so let's go ahead and say we get another value another Operation Push one so we will add one to the top of the stack getman says well get me the minimum value of all the elements in the stack which means that the value will be 1. now if you realize what we have been doing up till now is all of the operations like portion the pop even the top are going to take order of one time to run as it does in normal stack however the gate main operation is kind of a pain that is because we have to iterate over the entire stack one by one taking order of end time where n is the number of elements in the stack this means that there has to be a better way to do it we have to figure out a way to answer the getman query in order of one time all right so let's go ahead and talk about the optimization this is one of those questions where if you don't know what to do you really would have no idea on how to proceed and in these kind of questions what we are going to do is we're going to create another stack that's right we're not doing just going to have one stack we are going to have two stacks the first is the blue one which we already saw which will handle the queries like push and the Bob in the top but we will also have a green stack which is going to keep a track of the minimum value we have seen up till now let me go ahead and show you the simulation once again and that will make a lot more sense because it's a beautiful way to approach this problem right so let's go ahead and say we get the query push second we get the request to do push seven so we'll just add 7 on the top of the stack now this is the stack we're going to append it to we're going to add it to the blue stack directly whatever query we get we directly apply it to the bluestack the green stack will simply reflect the changes of the blue one so since we added 7 to the stack the minimum value of the stack is now 7 so we'll add 7 to the stack now let's say we get a push 3 Operation what do we do because this is a blue case we'll simply add 3 to the top of the stack but we'll have the three reflect changes in the green stack as well that is the green stack is now going to store a value that is the minimum of 7 and 3 because we have two elements on the top of the stack right so we're going to have minimum of 3 and 7 and so we'll store three now let's say we go ahead and get the value as uh let's say we get a push nine operation now the top of the blue stack will have nine but the top of the green stack will have the value 3. and that is because 3 is the minimum value of 3 and 9 which is going to be the minimum value of the entire stack all right so now what do we do now we if we get a query get min what do we do simply look at the top of the green stack and return that as the answer we are not going to pop out anything at this point of time right as soon as we get a get main query we are going to Peak at the top of the green stack and return that value now let's say we get a operations which says go ahead and pop the element out of the stack so this is going to pop the element 9 and now we have to make the green stack we reflect changes of the blue one since we removed an element we will also have to remove the element from the green stack now what if we get a getman query once again if we get a getman query we'll simply look at the top of the stack and since the value 3 will return 3. right so now let's say we get a push one operation what do we do one gets directly pushed onto the green sorry pushed on to the blue stack and the green stack is now going to reflect the changes green stack is going to have the value the minimum of three and one that is it is going to take the minimum of the previous element on the top of the stack the one which we got currently all right so now if I get uh get men again what do we do look at the top of the stack and return one as the answer all right so this is really it for the logic of the code what we have done is we have figured out a way to implement the solution using two stacks so let's go ahead and initialize sorry and uh let's go ahead and create self dot stack and we'll have self dot Min stack right these are the two stacks that we initialize this is the green one and this is the blue one all right now what do we do when we get a push query the stack the stack that we have the blue one is simply going to reflect the changes directly so we'll say when we get a push operation self dot stack dot append X nothing special but what do we do about the Min stack Min stack is going to reflect the changes so I'm going to say self.minstack dot append well I want to append the minimum value of the current X that is I'm going to take the current value and find the minimum with the Min stack top so we'll go ahead and do the main stack find the Top Value and take their minimum right pretty simple this is exactly what we discussed before but now we have to take care about one thing this is a common thing which we have to take here across all the stack questions see what we have tried to do here is that we have to try to access the minus one element on the Min stack that is I'm going to find the top element of the main stack but this will only work when will it work this will only work if the self dot main stack is not empty but if it's empty what do we do look if it's not empty we'll simply take the Min of X and the top of the stack but if it's an empty stack let's just go ahead and directly append this element to the main stack so we'll do self dot mainstack dot append X all right this makes sense so now what do we do when we get the pop operation remember we have to ensure that all of the changes in the stack are reflected in the green one as well so when we do self.stag.pop we have to do the pop operation for the Min stack as well again one more Edge case one more condition you can only do pop when you can only do pop if the stack is not empty so we'll say if self dot stack exist that is there are elements inside of the stack then you can do pop but if the stack is empty pop will really do nothing so we'll just say it's pass right now what do we do when we get top again uh here we have to return what is value at the top of the stack so we'll do stealth dot stack minus 1. but wait a second it is not guaranteed that the self of TAC of minus 1 is going to exist in other words the stack might be empty so if self dot stack exists well then you can go ahead and do this but what do we do otherwise the stack is empty and we are asked to return the top element of the stack well look at the condition in the question mentions something what should top do on an empty stack return 1 so in this case we are going to return 1 right what do we do when we get get min now remember in the top function we return the top of the stack which is the stop of the blue stack but in the getman function we're going to return the top of the green stack so we'll say if self self.minstax exist well then you can go ahead and return the self dot main stack stop but if it does not go ahead and return 1 you can see that there's a lot of paddles between gateman and the top that's because the only thing that changes is the stack in top we use the blue stack and in the green one green one is used in the getman function all right let's go ahead and test this out quickly looks like this is correct so we'll go ahead and submit this all right we get it accepted and this is it for the solution to the problem men stack on interview bit all right that's it hello everyone and welcome back now this is after our first section on where we discuss the stack related questions where we built up our understanding of stacks the implementation level details along with a couple of example problems to help us understand things better in this section we're going to focus on parentheses related questions which is actually going to be a step up from the previous one and is going to lead us to calculator related questions in the next section now why are we talking about parentheses questions in stack playlist you will get the questions answered very soon what we're going to look at is a bunch of example problems like valid parentheses longest valid parentheses written in braces and many more these are commonly asked in interviews and applying Stacks to these problems becomes a crucial part of understanding Stacks themselves all right now we will go ahead and take a look at an example and we'll try to build up our understanding of parentheses related questions and calculated related questions later on because what we're going to understand is the reason why we use Stacks inside of these parentheses questions in the first place all right so given this expression to you let me ask you the question if I give this to you on a paper and I'll give you a pen to solve this how would you go about solving this kind of expression the first thing you would want to do is look at the innermost brackets that is the innermost brackets contain the value D so let's go ahead and evaluate that first right you want to focus on the innermost first and then slowly zoom out to the outermost now what do we do zoom out to we would zoom out to B minus D in The Next Step and this would then finally lead us to the entire expression what we have done is nothing but parsing now parsing is a fancy word for what it means is we have to figure out the structure of the input that is it parsing means to figure out how the input is laid out now why do we want to understand the structure of the input why is this kind of thinking helpful let's take a look at a simple example we'll take this simple example and in this case we have two opening round brackets and two closing round brackets now if I ask you the question can you tell me what is the corresponding opening bracket to this current closing round bracket that is I've highlighted this closing round bracket for you can you tell me which of these is the corresponding current opening bracket pretty simple to answer because we already know the way we do this is by taking the bracket that is the closest we figured that this opening bracket came in the last and was the first one to get a result wait a second the bracket which came in the last was the first one to get resolved that is we're following something of the sort of a leaf ordering that's right this is the reason why we use Stacks in these parentheses questions because when to use stack is answered whenever we see Lee for ordering right so we have seen that we have to use a stack in parentheses questions and in calculator related questions as well but how exactly do we use it how do we use tax in these kind of questions what we are going to do is we are going to do a left to right parsing as I explained earlier parsing is a fancy word what it simply means is we have to understand the structure of the input we have to break it down step by step and understand okay this is what gets resolved first and this is what get resolves later on now left to right simply means that we're going to iterate from the left to the right okay enough talking let me actually show you with an example so this is the example case we took earlier and we have initialized an empty stack on this all right so what do we do next well here's a rule that you have to keep in mind anything that you get which is a opening bracket a character Like A B C D or an operator like plus minus division multiplication anything of that sort you get you simply append it to the stack that is you push everything except close brackets on the top of the stack here's what I mean say we get this opening round bracket we do nothing but push this on the top of the stack then we get a push it on top of the stack then we get Plus open curly bracket B minus open around bracket d the only time V and B do not append items on a stack is when we get a closing bracket this is important this is very important if we get a opening bracket a character or an operator whatever we directly added to the stack without thinking without having second thoughts but as soon as we get a closing bracket of any kind we have to start thinking all right so I already asked you the question of what this closing bracket actually closes what is the corresponding opening bracket and if you see in the stack we actually have that value with us we have this opening round bracket on the top on this stack here however that is not the top element and it might not always be obvious which of these opening brackets am I closing right because we have a currently we have a closing bracket in our hand and we want to figure out hey what is the area that I close what is the area what is the expression that needs to be resolved first because I'm following the leaf forwarding again so what we do is we'll keep on popping these elements of the top of the stack till we see a corresponding opening round bracket here's what I mean as soon as we get this closing around bracket we'll go ahead and start looking for the opening round bracket so we'll pop out D because D is not opening round bracket and so D sort of in an intermediate state we don't really know if D is part of a valid expression or not so we'll just keep it hold right now what we get on the top of the stack you see that there's a opening round bracket what does that mean currently look at the yellow marker we are at a closing round bracket and on the top of the stack we have found a opening round bracket in other words everything inside of both of these brackets is going to get resolved both of these brackets satisfy each other both of them resolve each other and everything in the middle of them will get satisfied so D is actually part of a valid string now right the brackets are balanced in a way all right so now let's go ahead and look at what happens later on we'll keep on iterating and we get a closing curly bracket now what do we do again this is a closing bracket so we have to be careful what do we do we look at the value on the top of the stack this is clearly not opening curly bracket so we'll go ahead and remove it but we'll keep it on hold minus maybe or may not be a part of a valid string all right so we have B now again B is not an opening curly bracket so we can't care about that so B and minus are both at an intermediate State we can't really see anything about what do we get now we have a opening curly bracket in other words we have found the opening for this closing curly bracket which we are on currently in other words what does that mean that means we have resolved everything in the middle of these two brackets so you can see somehow that kind of structure is being followed again we have sort of parsed the input we're trying to understand how this input is laid out all right so now what do we do next let's go ahead and keep on iterating so we get a start again this is not a closing bracket so we'll just add it directly we get a c not a closing bracket added directly and now we get a closing round bracket what do we do next what do we do think about it we're gonna keep on popping these elements out one by one we're gonna keep on popping them out till we get an opening round bracket and as soon as we get an opening round bracket what do we know we know that everything in the middle of both of these brackets is going to be validated and this is the way we have figured out how to parse the input we knew that we had to use a stack because we could see the leaf ordering being followed in the way brackets were opens and closed and then we figured out how to exactly go about looking at the opening and the closing of brackets by using a left to right parsing now a quick small implementation level detail is how do we implement this in the previous example I showed you we were appending these brackets and the pluses and the minuses directly and you can do that you can directly add the elements or you can also add the indices now uh different questions will require different cases but in general if you want one single template just use indices that's because if you append indices to the stack you will obviously have a mapping to the elements as well but if you only append elements to the stack you might forget which indice which index it came from anyways that's a very small level detail but still important to keep in mind just make sure you are consistent with what you are appending to the style whether it be elements or indices right so what is the conclusion let's summarize this once more we figured out in all the parentheses and the calculated questions we have to use a stack why is that because these brackets were following a leaf ordering last ones to get in were the first ones to get out they were the first ones to get a result and how did we figure out how do we use it we know we have to use a stack and we iterate it from the left to the right and we parsed the input we figured out the input and the structure of the string that is given to us and finally you can either add elements or the indexes to the stack that's upon you and that's a small detail you can take care of later on as well all right so keeping these three rules in mind let's go ahead and work out a couple of problems to fully get comfortable with parentheses related questions hello everyone and welcome back let's talk about the problem valid parentheses on lead code this by the way is a slight bit modification of the problem balanced parentheses on entropy bit if we are able to solve this you you will obviously be able to copy paste the code and get it accepted for balanced parentheses as well anyways this entire solution is based upon the understanding from the previous video where we talked about the introduction to all parentheses based questions we figured out how do we use the leaf ordering how do we go from the left to right and pause the input and the way we exactly Implement Stacks so if you haven't checked that video out I'll highly recommend you do because this solution is based entirely on top of that in fact it's going to be a very easy version of what we have seen before all right let me go ahead and show you and take you step by step throughout this problem given a string s containing only brackets we have opening and closing brackets of the type round curly and square and the goal of this problem is to return true if s is valid and false otherwise so looking at the example cases we have the first one Returns the output issue because the closing and the opening brackets match and mix and match appropriately in the second case however there is a spray opening curly bracket which never gets closed in fact it is trying to close the round bracket which is going to be invalid so we have to return false in this case all right let's go and talk about the intuitions and the observations needed to solve this question a bit more formally we'll take the same test case and we'll try to build our understanding from this now if we focus on the opening round bracket we see that it gets close towards the very end we get a closing round bracket towards the very end so both of them resolve each other out all right what about the opening and the closing curly brackets well both of them again mix and match well and this closing bracket is able to close the appropriate opening bracket that is the closing query bracket wants an opening curly bracket to be present before it and it is so we can see that this is also a valid case what about the square brackets again the opening square brackets gets closed by the appropriate closing bracket so this is also valid which means that everything inside of this test case mixes and match as well the opening brackets are closed by the appropriate closing brackets so we return true in this case right let's take another example and this time we have something more interesting going on because we have the same number of opening and the closing brackets that is for one opening around bracket we have one closing round bracket one opening curly bracket we have one closing curly bracket but the ordering in this case is meshed up that's because if you can notice this closing round bracket is trying to close an opening curly bracket obviously this will never work because this closing curly bracket sorry this closing round bracket wants to close an opening round bracket it cannot close the opening curly bracket so brackets in this case do not match and obviously this is contrasted with the case where we have the same number of opening and the closing ground and curly brackets but one of them is invalid and the other is valid so clearly ordering matters and if you notice the input has to follow this Leaf ordering that we discussed in the previous video as well that is the last bracket to get in should be the first one to get out and that was sort of the intuition behind using a stack and we also discussed how do we go from the left to the right and parse the input let's go ahead and do that in the next step one more thing we also discussed that if the brackets open add them directly if the brackets close check what they are closing that is if you get any kind of opening bracket just add it to the stack without thinking Twice But as soon as you get a closing bracket what do you do as soon as you get a closing bracket you have to check whether it closes the right opening bracket or not all right let's go ahead and go ahead with the simulation the first thing we'll do keep on iterating from the left to the right we get the first element as an opening round bracket opening bracket what do we do add directly no thinking then we may trade forward and we get opening curly bracket again since this is opening we'll just add it directly no thinking twice but now what do we get we get a curly closing bracket now we have to be careful we have to be very careful in what we do because as soon as we get a closing curly bracket what do we expect we expect that it closes an opening curly bracket because no other case will work out this closing curly bracket cannot close an opening round bracket or an opening square bracket it can only close and opening curly bracket so now following that leaf ordering again we look at the top of the stack what is the top of the stack it's a opening curly bracket so that's great but this current closing around sorry this current closing curly bracket we found an appropriate opening curly bracket in other words both of them validate each other and satisfy each other pretty nice right all right let's go ahead and continue iterating and we get an opening round bracket since it's opening we added directly but now what to have what happens next we get a closing square bracket what does that mean well this closing square bracket comes in and requests that hey uh can you get me an opening square bracket because that is who I can satisfy right I can mix and match well with the closing or sorry opening square bracket so we go ahead and look at the top of the stack and we see that it's the opening round bracket instead what does this mean this means that this closing bracket is actually invalid and so this was illvalidate the entire expression as soon as we get one invalid case one parentheses messes up as soon as one guy messes up the entire string gets canceled think about it that way right now just to another example is uh what happens if we had a closing round bracket what would happen in this case in this case what would happen is we would be able to mix and match well with the top of the stack so we can say that you know what this closing round bracket will be able to match with the stack top both of them resolve each other and we can move forward with our lives again this is a closing round bracket we'll check the top of the stack is it an appropriate opening bracket yes it is so let's go ahead and close that and we're done now what do we see happening at the end all of these brackets are validated all of the opening brackets have been closed and this is the reason why stack is empty remember this is another important condition which you might miss the stack should be empty at the end and what it says is really is that all of the brackets that opened which we put into the stack remember all the opening were put into the stack and all the closing were removing them from the side so if at the end the stack is empty that is a good sign because we were able to close all the brackets that ever opened now what's another case that could happen let's say that we have another curly bracket towards the end now this is the entire string what would happen in this case we would add it to the stack but this would never get resolved in other words it will be left alone and it would make the entire expression entire parentheses invalid right so it's very important for us to follow a couple of conditions let's go ahead and formalize the logic and that should make a lot more sense all right let's go ahead and talk about the code for the is valid parentheses question all right so first things first we'll go ahead and create a stack which is going to be an empty list next we want to create a mapping from the uh closing bracket to the opening bracket that is for this closing bracket for a closing curly bracket I expect an opening curly bracket to be present on the top of this track right this is something we've discussed already we have to do the same for opening and closing brackets for all the kind now all right cool so now that we have created the mapping we can finally go ahead and start to iterate from the left to the right so we'll go over all the characters in The String given to us now first things we'll check is that if the character is a opening bracket if it's round square or curly opening bracket then don't think twice just append it to the stack right because as soon as we get a opening bracket we directly add it to the stack without thinking twice this is something we've already established else else what do we do in the else condition things get more interesting because now I have to say you know what to check if the mapping of this character if the mapping of this closing bracket maps to the correct value present on the stack top that is for the closing bracket that I have right now can you check if it maps to the correct value that is the opening bracket of curly type on the top of the stack because if it does then it's good then it's good right and we'll see you know what since both of them match both of them resolve each other so I'm just going to do stack dot pop I'm going to remove this bracket that matched all right what do we do in the ash condition what do we say when there's a mismatch as soon as there's a mismatch I'm going to return false I'm going to be merciless as soon as you guys miss much I'm going to return false right away okay there's one more thing that we need to take care of see I've tried to access the stack of 1 here what have we learned up till now you just cannot access this stack of 1 just whenever you want you have to ensure if the stack exists and only when the stack exists you can do all of these operations well what do you do otherwise what if the stack does not exist what if the stack does not exist and you have a closing curly bracket or closing bracket of any kind rather in that case that closing bracket is trying to close something that doesn't exist in other words we can just set it on pause right away all right so at this point are we done can we return true not so fast this is where another mistake can occur we have to ensure that the stack is empty we have to ensure that the length of the stack is equal to equal to zero why because we already saw this example over here in this case we reached the end of the iteration and we had one curly bracket remaining in the stack and this curly bracket was never resolved it was never popped out of the stack which means that it Still Remains unresolved to this date in other words this entire expression became invalid just because the stack was not empty in just to reframe what does empty stack mean empty stack really means that although the brackets that were input into the stack all of the opening brackets that were ever inputted into the stack have been closed all right cool so let's go ahead and run this code and this gets accepted so let's go ahead and submit this once and we get it accepted as well all right cool so this is it for the solution to the problem valid parentheses hello everyone and welcome back let's talk about the problem redundant braces on interview bid now just a quick aside if you haven't watched the video introduction to parentheses question I highly recommend you watch it because we are directly going to use rules and logic that we formed in that video inside of this question because we're going to apply things directly without talking about it much that's going to make the solution a lot simpler all right anyways let's talk about the problem statement first given a string a containing operators round braces and letters so we have a bunch of operators like plus minus multiplication divide then we have our round braces so we have the opening and closing round brackets and a bunch of letters the goal of this problem is to return one if a has redundant braces and zero otherwise all right so let's go and take a look at some examples how do they find redundant in the first case we have a redundant brace because we have two sets of round brackets wrapping the a plus b when we only ever need one in the second case we see that there are no redundant brackets because we're going to make use of every single one of them so let's go ahead and take a look at some observations and logic from test cases given and really there is just one single observation that we need to pull out from these what is that let's try to build up to it the first test case we see is a plus b wrapped in these two sets of braces why is there redundancy in this because instead of 2 we can just use one right let's take a look at the last test Keys here we have a simple letter A which is wrapped inside of these parentheses but it looks like we don't really need this the example and the problem sector says that you know what this is a case of redundant braces because you don't really need to wrap a in anything else and in the middle we see that we have a plus a plus b in this case there are no redundant braces we're using every single thing now what do you notice there's actually one thing in common with all of them which makes the solution work and this is the central observation of the entire problem what is the observation the observation is there should be no operators in between these braces so in the first one you see between the first set of braces and the second set of braces there are either no letters and no operators right there are no letters or operators in the second one there are both letters and operators and a third one there is a letter but there is not an operator right so we have to ensure that there are no operators between any two sets of braces because if we can make this condition work then will have a case of redundant braces all right just a quick aside what are some of the rules that we saw earlier rules when do we decide when we have to use a stack we use a stack whenever we see a leaf ordering being followed and that is true for all parentheses questions so in this question we're also going to use a stack however we're going to use it we're going to go from the left to the right and parse the input see what uh structure this input is following and finally how do we implement this in this question the elements are the bigger uh Focus instead of the indices so let's just focus on elements let me actually go ahead and show this to you right as we discussed there should be no operators between any two sets of braces this is something we'll keep in mind as we go through the example all right so let's go ahead and iterate from the left to the right one by one so let's say we have the first element and that's the opening bracket so let's just push it on to the stack again if we get opening bracket if we get a operator or if we get a letter we push that onto the stack the only time we don't push an element onto the stack is when we get a closing bracket because then we need to be more careful again this is something I've already explained in the parentheses questions uh the introduction to parentheses questions video if you haven't checked it out if you haven't understood it well enough go ahead and dive into advanced mode right cool so we'll go ahead and continue iterating we get another opening round bracket so we'll just add it to the stack now we get a then we get plus and then we get B nothing special these are just opening brackets operators or letters we add them directly onto the stack without any question only when we get a closing bracket then we have to be careful all right so now that we have gotten a closing bracket let's try to be more careful with what we do what's the first thing we do well this closing round bracket is looking for an opening round bracket to close make sense so we look at the stack top well that's an element B um B is not really useful for us so let's just go ahead and pop that and we'll keep it as an intermediate state we don't really know if B is useful or not and then we see a plus now what does that mean look at the condition on the top right the question wants that there should be no operators if you want to have a redundant brace that is if you can find an operator in this case we have found an operator that means that the expression that we're going to interrupt in these two opening and the closing round brackets is actually going to be a nonredundant one we need those braces in this case again that is just how the problem is defined so now since we have found an operator let's go ahead and keep that in mind and we'll keep on popping these elements out one by one again so we go we pop out plus and then we also pop out a but now what do we have on the stack top there is a opening round bracket and what do we have currently the pointer is pointing to it's losing round bracket which means that everything inside of this has to be considered together right now since we found an operator What can we say about this current highlighted section we can say that this is actually non redundant case so this is actually a valid case of how braces are being used so let's not touch this we'll just keep on iterating forward so now we get a plus again it is not a closing bracket so we can just add it directly no thinking again opening bracket good to go C good to go ah but now we have a closing bracket so let's try to be more careful this time now what do we do the first thing we do is look at the stack top we have our element C again it's not an opening bracket so let's just pop it out keep it as a intermediate state and now what do we have we have a opening bracket so we have found an opening bracket for this current closing bracket what does that mean that means that the entire highlighted expression is what we have to look at right now but look at this there was no operator that we found in the middle right there was no operator in this highlighted expression which means that there are redundant array cells that's correct so this is what it means we have found a redundant bracket and we can return true that yes indeed there are redundant brackets in this input all right so let's go ahead and take a look at the optimized solution and we'll go ahead and code this up right so this is going to be the code where we start from an empty stack again very simple and then we'll go ahead and iterate over all the characters in the input string right now as I mentioned what is the first condition the first condition is if you get a letter if you get a operator or an opening bracket that is if you get anything other than a closing bracket this is directly appended to the stack no thinking at all all right when it goes to the edge condition we have to be a bit more careful so in this condition what we'll do is we'll keep a track of the count and this count keeps a track of account of the number of operators we have seen because remember that is what is going to tell us whether a bracket or whether an expression inside of the input is redundant or not so we'll start the count from 0 and we'll say you know what since we have found this uh closing ground bracket let's just go ahead and keep on popping these elements out from the top of the stack one by one till we get a opening round bracket right till we get a opening round bracket so we'll go ahead and say now if the Pod is actually an operator that is if it's any of the plus minus star or Division if the character is any of these operators then I want you to do count plus one in other words since we have found a positive number of counts of The Operators whatever the expression is going to be is going to be a valid nonredundant expression and of course at the end of this while loop we are going to do a stack dot pop because we want to pop out this uh opening bracket we don't really have any use for this at all anyways now what do we do once we're done with this entire iteration of this while loop we're gonna check what the condition is we're gonna say if the count is zero that is if the count did not change at all in other words we did not encounter any operators if we did not encounter any operators return one we have found the case of redundancy and if not we'll just keep on going forward going forward again and again and again and if throughout the entire iteration of this entire string you find no such redundancy then you can safely return 0. that is the entire string is nonredundant right so let's go ahead and test this out it looks like it works and we'll go ahead and submit this as well cool so this gets accepted and this is it for the solution to the problem redundant braces hello everyone and welcome back let's talk about the problem minimum removed to make valid parentheses this by the way is a medium level question on lead code and we're going to use this problem to build up our solution for longest valid parentheses as well in fact this solution is going to convert that hard problem into an easy one I'm not even kidding all right let's go ahead and get started with the problem statement so we're given a string that contains opening and the closing round brackets and lowercase English letters the goal of this problem is to remove the minimum number of parentheses to make S valid so in the first case we see that there are two opening brackets and one closing bracket and we see that we have to remove any one of these opening brackets to balance these opening and the closing ones out okay pretty simple and so what I've decided to do is I've decided to remove the first opening bracket and keep the second one you can also do it the other way both of them are perfectly fine in the second case we have the input as 1337 wrapped inside of brackets in this case I have to remove no such parentheses to convert it to a valid string because it's already a valid string all right so let's go ahead and take a look at some observations the logic to build up to the solution now we already talked about this test case where we removed the first bracket but I want you to notice one more thing the question clearly mentioned that we can only remove brackets that is we have to remove the minimum number of brackets to make it a valid shrink in other words we're only going to remove brackets and never the lowercase English letters now this is important because what we can do is simplify our life a bit what we can do is look at these characters instead as indices and we can filter out all of those characters which are lowercase English letters in this way we have simplified the problem quite a lot and now we only have to worry about the brackets opening and closing all right so let's go ahead and talk about uh a couple of rules that we discussed previously first was the thing where uh why do we use a stack and when do we use a stack as soon as we see a leaf quadrant being followed we are going to use a stack and in this question is a parenthesis question so we will use the stack the second thing was how do we use it well we're going to go from the left to the right and parse the input that is for every opening bracket we see we'll go ahead and add it to the stack and for regularly every Closing one we are going to remove an opening from the stack so both of them are going to resolve each other this will make sense in a second don't worry about it and the third one is how do we implement this in this case it is better to use indices instead of elements okay because we did a filtering out operation which means that indices are going to be the way to go all right so let's go ahead and get that input set up and now we have an empty stack with this so what we'll do is we'll go ahead and start to iterate from the left to the right so first we'll go ahead and look at the element 0. all right so element at the index 0 is an opening bracket so we're going to add it directly onto the stack no questions asked then we move on and we iterate further and we find another opening bracket at the index four so we'll again add the index 4 to the stack oh by the way I am adding these indices and you have to focus on getting these indices into the stack the brackets are there just for the sake of demonstration and understanding we're actually going to only have indices in the stack not the brackets anyways then we go ahead and reiterate further and we find that we get a closing round bracket now what does this mean we have found a closing round bracket which means that it is going to satisfy the opening round bracket so this 9 is going to get satisfied with the 4. both of them mix and match together and we'll pop the element 4 out of the stack this is the reason why you see 4 and 9 in the answer make sense now we reached the end of the iteration but 0 Still Remains on the top of the stack in other words it never gets satisfied it never finds any closing bracket to resolve it so we'll leave 0 out so the minimum remove to make valid parentheses is going to remove the element 0 from the input okay let's go ahead and take a look at another example and this one will really bring forward the core of the problem so let's go ahead and start iterating from the first element we see 0 which is a closing bracket now this closing bracket is going to close an opening bracket but do we have an opening bracket on top of the stack well no we don't even have any brackets on top of the stack we don't have any brackets at all which means that this closing bracket will never get satisfied it will be alone always and forever so we are going to leave it and we're going to iterate further all right so now we get an opening bracket let's go ahead and add it to the stack pretty simple next iteration we see that we get a 4. now this four did what as soon as this 4 got an opening bracket popped it out and satisfied both of them so now both the opening and the closing brackets have satisfied each other which means both of them are essential to be a part of the solution right so let's go ahead and continue iterating now we get 6 and this is an opening bracket so let's just go ahead and add it to the stack then we get a 7 also added to the stack and then we get a 9. what do we do when we get a 9 that's right we'll pop out the 7 and now both 7 and 9 will satisfy each other at this point we have 1 4 7 and 9 which are the parentheses which satisfy each other in other words they form an essential part of the answer however 0 and 6 have to be removed right we have to remove a minimum number of brackets and this way we have found two brackets to remove from the answer okay pretty simple uh but what would happen say if I get a 10 which is a closing bracket just for uh thought process sake as soon as I get this 10 what would happen this 10 is going to satisfy the element on the top of the stack which is the element six so 10 and 6 are going to satisfy each other and so there is where we end the iteration all right let's go ahead and take a look at the optimize solution and uh okay cool let's go ahead and get started now if you notice what we have done up till now is uh have a differentiation between these blue and the green ones right the blue ones were ones that never got satisfied and the green ones were the ones which got satisfied so the first thing I'm going to do is create an array called is okay which is going to be initialized with 0 for all the values of the string in other words I'm going to say none of the elements in the original shrink ever get satisfied that is my initial assumption and I'm going to build upon that later on now I'll also have an initial stack and we'll go ahead and start iterating over all the elements inside of the string so we'll first get its index another character for every single element of the string now if the characters in opening bracket what do we do if the character is an opening bracket we add it to the stack without asking any questions now what happens when we have a closing bracket when we have a closing bracket we'll first ask the question here does the stack exist is there any opening bracket on the top of the stack because if there is what do we do if there is we will pop that element from the top of the stack and assign its index the value 1. saying that this opening bracket which we just popped out is actually a one it is okay it is a green value as we saw in the case for one and seven both of them were opening brackets and they got Satisfied by four and nine respectively so one and seven both get this one and we also assign is okay if I to one as well saying that because 4 was the one that popped out one from the top of the stack one gets satisfied but also four gets satisfied so we're going to satisfy both of them and what is the else condition what if the stack is nonexistent what if we get a closing bracket and then we realize that hey wait a second the stack is empty so we can't really close any opening bracket in other words we'll just have to continue unfortunately skipping over this current I alright so was the final lens condition if you get a opening bracket we append it to the stack if you get a closing one we check the stack for emptiness or not and figure out what to resolve but there's a final condition which says if you have English letters well go ahead and also continue because we don't want to mess with any lowercase English letters what we are only going to message we are only going to mess with the indices of the parentheses all right so at the end of this iteration is okay is the array which contains all the information it is the one which contains the information of which all are blue which already do and which one or green the green represents one and blue represents zero right so let's go ahead and iterate further now the goal of this problem is to return the string we have to return the string by removing the minimum number of parentheses Now using this is okay array we have already found out all the parentheses which are essential and which are nonessential so what we are going to do is we are going to go ahead and build the answer character by character once again remember all of this what this tag did was to store the indices of the elements and this is why the is okay thing worked out now we are going to iterate over the string once again and we are going to ask the question hey is the character a bracket or not because if it is a bracket and only if it is okay only if it has been satisfied then we added to the answer because if it's a bracket and it has not been satisfied we'll have to continue we'll have to pass over this test case now was the else condition over here if the character is a bracket then you will have to check if it's okay or not but if a character is not a bracket that is it's a lowercase English letter then by default you have to add it to the answer all right anyways at the final point of time you go ahead and just return the answer so let's go ahead and run the code for sample test cases and some of this all right cool so this is it for the solution to the problem minimum remove to make valid parentheses hello everyone and welcome back let's talk about the problem longest valid parentheses now if you haven't seen the video on minimum remove to make valid parentheses this question will seem out of the blue however if you have seen that this question is just a breeze question because we're going to use the exact same logic as we saw in the previous one all right let's go ahead and talk about the problem statement of formally and we're given a string of just opening and the closing brackets that is we only have opening and the closing around brackets the goal of this problem is to find the longest substring of valid parentheses in other words let's take an example in the first test case we have the opening and the closing brackets which form a length of two but then we have three opening brackets which never get closed in other words the longest substring of valid parentheses is just 2. now the second test case is one where we have opening and closing bracket and then we have a bunch of opening brackets the bin one opening bracket at the end gets closed now what is the longest substring of valid parentheses we have in this case two sets of the length two substring of valid parentheses since both of them are of land 2 will just return to as the answer now what can we say right away about this kind of question this kind of question is actually twofold we have to find two things first first we have to figure out what all parentheses are valid or not because once we have the valid parentheses in hand once we know which of them are valid which of them are invalid we simply have to find the longest substring of them right so this is going to be uh broken down into two parts and if you realize the answer to the first one is something we've already seen all right since there is not a lot to go on let's go ahead and just build up our logic from the previous question as with the previous one we'll set up an is okay variable that is going to be all zeros of the length n in other words it's going to say that you know what I'll assume none of the brackets opening or closing ever get satisfied all of them are zeros we'll also have an initial initialization of this track and then we'll start to iterate our all the characters in the string as before we'll check if the character is a opening bracket or not because if it is an opening bracket will just directly add it to the stack what if it's a closing bracket though in the else Condition it's a closing bracket we'll have to check if the stack exists or not that is for this current closing bracket because I've gone in dl's case for this closing bracket does the stack exist in other words is there a opening bracket is there any opening bracket that you can find which had been put on the stack now if you can find that is the case well then go ahead and make both of them satisfied that is go ahead and pop the element from the top of the stack which is going to be an opening bracket and set its value to 1 that is that opening bracket has been satisfied by this current closing bracket and obviously that also means this current losing bracket has been satisfied so we'll set is okay file to B1 and the off chance that the stack is empty and you get a closing bracket well that's just sad we can't really do anything about that I'm sorry anyways once we're done figuring out which of them which of the brackets opening or closing are valid or not we simply have to figure out the longest substring of these valid cases so what we'll do is we'll set up a count which is going to be a running count of all the values and we have a answer which is going to store the maximum of all of these counts so what we're going to do is we're going to iterate in the range of n that is we'll iterate over every single index and we'll ask the question hey is the bracket I'm looking at is the current bracket okay or not because if it is okay well that's great news whatever the count was increase its value by one why because I found the case of a valid parenthesis right so as soon as I know this current bracket is a part of a valid substring go ahead and add one to the count else else what do we do if at this point of time there is a bracket which is a stray bracket which never gets opened or never gets closed well then we unfortunately have to reset the counter from zero okay so the next step is then going to be simply taking a Max of the answer in the count because answer wants to store the maximum possible value of all the counts ever all right so this is it for the code let's go ahead and run it and we'll go ahead and submit this as well and cool this gets accepted so yeah this is it for the solution to the problem long history valid parentheses hello everyone and welcome back this is the start of a new section on calculator related questions it builds on top of our previous work on parentheses related questions we'll be discussed the exact reasons why we use a stack how we use it especially the left to right parsing method and the implementation level details that we need to take care of now what I'm going to do in this video is establish the we just need two steps that's right just two steps we need to know to solve any calculator related question in fact both of these steps individually are interview problems on their own which means that once we solve both of them both of these questions we'll be able to solve any calculator related question that is like killing three birds with two stones all right so the first step is to parse the input from the infix to the postfix notation and the second one is to evaluate the post fix notation now the first question that you should ask is wait what is the post fix notation so let's go ahead and talk about the introduction to the postfix notation first all right let's go ahead and take a simple example and let's see that we have this kind of string that we need to evaluate now the infix notation is formally defined as such in the infix notation the operator is fixed in between the operands again the operator is the focus over here and the operator is going to be fixed in between in the operands now what is the post fixed notation formally speaking postfix notation is where the operator is present after the operands now that might sound a bit unnatural given that what we have been looking at all throughout our life is the infix notation this is the simple in fixed notation over here and if I ask you the question hey how would you go about evaluating this kind of thing what would you do the first thing we'll look at is brackets so we'll evaluate everything inside of the brackets so 3 times 3 becomes 9. and so this is the expression that we have now what do we do next we realize that we have to do a division operation first which means that we'll do 9x7 C style division so 9x7 will get rounded off to 1. and now we have 0 minus 1 plus 1. and since plus and minus are of the same priority we'll simply cancel both of them out and say the final answer is nothing but zero now what have we done over here what we have done is simply apply a rule called bod Mass which stands for bracket order division multiplication addition and subtraction this is a rule that is commonly taught in high school math and is the way we evaluate any sort of input given to us however there is a small catch see if you have brackets inside of brackets those brackets inside of brackets need to be resolved first before you evaluate the brackets and if you have brackets inside of brackets inside of brackets then you resolve then you need to resolve the innermost bracket first then zoom out and then zoom out once again you can see that this sort of nesting is what can give rise to such complicated expressions and while the first one on the top is pretty easy to solve using the same in fixed notation the second one becomes much more harder and so the question arose whether we can write the expression unambiguously and we can solve it efficiently that is without having to worry about this Bond Mass rule is there a way we can write this expression and secondly is there an efficient way to solve that expression once you have written it that way this is the idea behind post fixed notation the both fixed notation simply says that the operator is present after the operands in other words if we take an example like this we have 1 2 plus it is equivalent to saying 1 plus 2. again I know this sounds unnatural but bear with me for a second because something interesting is going to happen let's see if we have 1 2 plus 3 star what will that evaluate to 1 2 plus will become 3 and then we have 3 3 star in other words we'll have 3 times 3. what we have done is one plus two inside of brackets that needs to be resolved first and then we'll do times three do you notice something if we go back the other way around we have figured out a way to write these bracketed Expressions into nonbracketed ones that is one plus two which had to be resolved first which were present inside of the brackets we found a way to write that without using the brackets how nice is that we were able to figure out a way to unambiguously write this expression all right so this is the general idea behind using a postfixed notation and so we can finally formally talk about these two steps again the first step was to convert and parse the input from the infects to the postfix notation and that is something we're going to look at in the next video and then in the next to next one we'll look at how do you evaluate the postrix notation all right so let's get started hello everyone and welcome back let's talk about how do we convert the infects to the post fix notation as we discussed the infix notation is one in where we put the operator in between the operands that is we fix the operator such as a minus between the operands such as 0 and 1. so we have something like 0 minus 1. in the post fixed notation we have the operator after the operands where we have something like 0 1 minus let's go ahead and take a look at some examples to understand this vector in the case we have 1 plus 2 in the infix notation it gets converted to 1 2 plus if we have say 5 minus 6 it gets converted to 5 6 minus and then if we have something like 1 plus 2 times 3 we have 1 2 plus 3 times wait a second uh one two sorry one plus two times three will evaluate to 1 plus 6 which is nothing but 7. but if we actually evaluate this will come out to be wrong that's because 1 2 plus will get evaluated to 3 first and then we'll have to do three times three giving us the answer nine this is in fact wrong we are doing one two plus three times which is wrong so what do we have to do instead we have to switch out the ordering of this Plus because now what we have done is we have done one two three Star Plus basically saying go ahead and multiply 2 and 3 first so 2 times 3 becomes 6 and so we'll write 1 6 Plus Now 1 6 Plus is what it's nothing but 1 plus 6 which is seven and so now we have the correct answer but if you notice what happened over here we realized something The Ordering of these plus and the star operators changed right we had one plus two times three and it becomes 1 2 sorry it became one two three Star Plus so the ordering of the plus and the star operators change although the ordering of the operands like one two three did not change there's something interesting which we'll come to very soon again all right so now we want to formally talk about how do we convert the infix notation to the postfix notation right so let's go ahead and try to work out the answer one by one so using the board Master will let me know we can say that you know what let's go ahead and do the division operation first all right so we have to do B by C first and how are we going to write d by C we're going to write it as B C slash all right pretty simple up till now then what do we do next we also realize that there's a b by c times D we have to do times D in The Next Step because that is the second operation we have to follow using the board Mass rule so what will how do we write times d well BC by forms one single operand now and so we have to multiply BC by with d BC by is one operating and D is another and so we can write BC by D star all right how do we handle the plus case and the minus case then well it's going to handle the plus one first so we have a plus this entire expression now can we handle that we can write a in the front and plus the end and then we have minus E towards the end so we can write it as e minus right so we followed the bod Mass property and we have written down the infix to the postfix notation in fact if you break it down we have something of this sort first we looked at BC slash then D star then a plus and then e minus following the board Mass rule exactly in fact what we have done here in other words is that we have somehow implicitly encoded the information of the bond Mass rule into the post fixed notation now to evaluate the post fixed notation we won't need this bodmas rule at all because we have already encoded that information in the structuring of the post fixed notation right let me go ahead and explain that further what we have done is that we looked at the bod muscle and we figured out that we have to First Look at brackets then order then Division and multiplication are the same level then addition and subtraction are the next lower level right so this is something we've implicitly encoded into the answer look at the ordering of The Operators we have slash first then star then plus and then minus I also want you to notice another thing which I brought up earlier as well The Ordering of the operands which are a b c d and e remain the same from the infix to the post fixed notation only and Only The Ordering of The Operators change it went from plus slash star minus that is it went from a completely random ordering to a welldefined ordering where we had division multiplication addition and subtraction so now the question is how do we implement this how do we make this happen using formal logic what we're going to do is we're going to go ahead and use a stack to do this let me actually run a simulation and show you how this works the first thing we'll do is we'll start to iterate from the left to the right and so let's say that we get the first element as a since this is the operand and we don't mess with the order of the operands we are just going to write it as a part of the answer directly no thinking twice you see an operand you write it in the answer that's it as simple as that what's the next step the next step is to iterate further and we see that we get a plus sign since the ordering of these operators do change later on we'll keep them in a stack for now and we'll see what to do later on right so now we add this plus to the stack then we get the element B and what do we do since b as an operand We'll add it and obtain it at the end of the post fixed answer all right cool so now we get a slash now I'm going to ask you a very important question is it okay to put this slash after this Plus or should we instead remove this plus first and add the slash later on what should we do let's think about something that is going to happen if you remember stack follows something called the default ring the last one to come in is the first one to get out and notice how the answer on the top right hand side says the answer on the top right hand says that we have to have division then multiplication then addition and subtraction that is we have to follow this highest to lowest ordering in the post fixed notation that is something that we have to encode it by default now if it means that we have to have the highest operation highest priority operators first and the lowest ones later on using this lifo notation what should be the ordering we follow in the stack again the last ones to get in will be the first ones to get out so if you want the highest ones to come first in the answer we'll have to ensure that the highest ones are the first one to leave out of the stack in other words we have to say that the stack follows the lowest to highest ordering so in fact what we have right now plus followed by a slash is okay because in the edge case because in the edge case that we ever decide to remove both of these elements first will pop out slash and then Plus which now exactly follows the ordering we want right so I think that should make a lot more sense now so let's go ahead and continue iterating we get the element C and since this is an operand We'll add it directly add it to the stack now what do we do when we get a slasher uh sorry when we get a star operation remember the board Mass rule it says the first you resolve brackets then order then Division and multiplication at the same level what does it mean for us to get a division and a multiplication right now this is nothing but going to hint us at the fact that this multiplication operator is actually going to take this division operator and kick it out because both of them are of the same priority and remember what is the ordering of the stack The Ordering of the stack goes from the lowest to the highest all right we can't allow elements of the same priority to stick in together so we'll have to kick out the Slash and only then we can add in the star again if you look at it it is still going to maintain lowest to the highest ordering now right it only happens after we kick out the Slash and if you look on the top side top right hand side we can see that you know what this is indeed the correct way to go so we're thinking about this correctly anyways let's keep on iterating further and see what happens we get a d and since this is a what since this is an operand we'll add it directly to the answer then we get a minus and now what happens the priority of minus is much lower than that of multiplication which means that this minus is going to kick out the multiplication you can think about it this way you can think that an undeserving candidate comes a lower priority element comes and it kicks out all the higher priority or the equal priority elements out of the stack it says that you know what you guys are much higher priority than me minus comes in and says you know what addition and multiplication are both either higher or equal to me so I'll kick you both out let me just go and stay in the stack so we'll go ahead and first kick out the multiplication operator and then we'll again compare it with the addition one so now we'll say okay you know what since plus and minus are both of the same priority let's go ahead and kick out plus as well then we'll add minus into the stack okay so now we can go ahead and continue iterating and we get the value e we'll just add it to the answer and then wait a second we have reached the end of the iteration right after e we have reached the end of the iteration so what do we want to do if we want to empty out the contents of the stack and since there is only one single element let's just go ahead and add this at the end so now you can go ahead and compare both of them and realize that you know what we were actually a right all of this logic worked out for us so now we want to go ahead and formalize the logic and write it in terms of code and we're going to follow the exact same things that I taught you before first things first let's create a post fix array which will return at the end and now we'll also create a stack for The Operators the stack is only ever going to store The Operators and not the operands now we want to start iterating over every single element in the infix and we're going to call this element token because it can either be operator or an operand we don't know yet now we'll ask the question hey if the token is not an operator that is if it's a letter or if it's a number or digit something like that if the token is not in the operators then what do we do hit me is that the token is actually an operand and in that case we realize that we just have to directly append it to the postfix notation we don't ask any more questions and that is it for an operand now what happens if we have an operator though then obviously we want to append this item to the stack we want to push the token onto the stack remember stack follows the lowest to highest ordering which means that we have to write one or two lines of code more and this is very important and this is something we'll come to by the way in the next section as well okay so let me explain what's going on here I'm going to say while the stack exists that is while there are elements in the stack and the priority of the element on the top of the stack is greater than the priority of the current token that is we're looking at something like a minus as the current token and the top of the stack is a star which we had a case like that before if we have a case like that then this current token of lower priority is kick out is going to kick out the element from the top of the stack and it's going to kick that element from the top of the stack we'll do stack.pop and whatever the element was kicked out is going to be appended to the post fix one directly so we are going to say while that is true while the current priority of the token is lesser than equals to the priority of the element on the top of the stack then keep on doing this for prep operation because we are strict we want to have a lowest to highest ordering we can't even allow elements of the same priority to be there because even if the priority same we're still going to make a cake operation we're going to kick that element out from the top of the stack and append it to the post fix notation all right good so this should make sense now because we have to follow the lowest to the highest ordering okay what's the last step then are we done if you remember we had the case where there was one single element minus in the stack remaining at the end so we'll actually have to handle cases like that as well and we have to say you know what while the stack exists while there are a bunch of operators in the stack go ahead and pop that element of the stack and append it to the post six now obviously in this kind of case we will only ever have one single element like that okay anyways uh all of this was to convert this kind of input as we saw on the top from the infix notation to the postfix notation but now I ask you the question is it possible to somehow include in Brackets as well because look at the inputs we have never talked about brackets up till now we've only talked about operands and operators what if there are brackets all right let's go ahead and write some more code and since brackets are of higher priority since you know in bodmas you will be always take care of brackets first let's go ahead and handle the cases of brackets in the first two conditions so the first will first thing we'll see is that if the token is an opening bracket what do we do we will append this token on top of the stack we'll say you know what this is going to start of a new expression that we need to take care of earlier on so let's go ahead and append this token on the top of the stack okay now what well we want to say you know what if the token is a closing bracket then we need to do something more as soon as we get a closing round bracket what do we want to do we want to take care of all the elements present between this opening round bracket and the closing round bracket so what we are going to do is we're going to say you know what while the stack of top while the stack top is not an opening bracket go ahead and kick out all the elements one by one so what we are going to say is everything in between of these two brackets between this opening round bracket and the closing round brackets go ahead and pop those elements from the top of the stack and keep on appending them to the post fix notation one last thing that we have to do what is the one last thing the stack top is currently now having the opening round bracket as the Stacked out why is that because that is when the while loop exists because the stack top is going to have the opening round bracket which means that we have to take care of that once again we have to do a stack.pop operation saying that you know what we don't really care about brackets in the post fix notation because that was the whole point of post fixed notation to get rid of the brackets in the weird board Mass ordering now let me ask you this one question and this is a kind of a special trick case that we need to take care of remember the board Mass rule right and what I promised at the start was that we will be able to somehow implicitly encode the information of the infix notation in the postfix notation right and we were able to do that by handling the cases of brackets separately and division multiplication addition subtraction all right but now if I ask you let's go ahead and also formally Define the priority what is that going to look like because we use this priority over here in the while loop right now how do we Define the priority well the priority will be a little bit different so obviously the order has the highest priority then division multiplication and then addition subtraction but the bracket the opening bracket will have the lowest priority why is that you ask it has a very interesting reason behind it all right let's say that we have a bunch of elements in the stack let's say there's a opening bracket and now let's say that the operator is simply a star so we have an opening bracket and a star after it now let's say that the minus comes right so what is minus going to do minus is a lower priority element so it is going to kick out the star out of the stack but at the same time we want to ensure that this minus does not kick out the opening round bracket because it's not minus his job to handle that it's the job of the closing bracket to handle that in its own while condition so we are going to have opening bracket having the lowest priority so that the minus or any other sign in fact is never able to kick it out of the stack all right so in this video we learned how to convert the infix notation to the postfix notation now I promise you in the next one we're going to look at how do we evaluate the post fix notation and that is going to be a so so much simpler than this code hello everyone and welcome back let's talk about how to evaluate the post fix notation in the previous video we looked at how do we convert the infix notation to the post fixed notation and I promised early on that the post switch notation is going to be a very easily computable way to get the answer for any calculator related question what we're going to do is very simple I'm going to create a stack and now we'll see that we're going to start iterating from the left to the right now for elements like 0 which we'll get as operands we are going to push them onto the stack without asking any questions as soon as we get another operand let's say in the case of one we are also going to the push it to the top of the stack but things get a bit more interesting when we get an operator because now what does this operator mean what is this entire 0 1 minus thing mean this means that we have to do 0 minus 1. in other words we have to pop one out of the stack we have to also pop out Zero from the stack take their negation that is do 0 minus 1 because we have gotten a current value as the negative minus sign so we have to do 0 minus 1 and then put it back into the stack right so what did we do you get an operand you add it to the stack no asking questions Twice But as soon as you get an operator go ahead and remove two values from the top of the stack do the evaluation and then add them back in okay let me continue and show you what this means so we get three this is an operand we'll add it to the stack we get another three operand add to the stack what do we do when we get a star as soon as we get a star we'll pop one value out we'll pop another value out multiply both of them since this is a star operation find the value and push this answer back onto the stack okay again what do we do when we get a 7 add this one to the stack now what do we do when we get a slash what will the be the next step since we have a slash we're going to pop out the last two elements seven and nine we're going to take the division nine by seven and this is the C style division so we'll get the answer as one so we'll get the answer as 1 and we'll push this back onto the stack and then finally we have the plus operation where we'll pull out one we're also pop out minus one add them together get the answer 0 and then push it back onto the stack at the end of this iteration one thing is guaranteed there will be only one single element inside of the stack and that will be the answer okay so what are the rules formally speaking we do two things first if you have an operand you add it to the stack else you pop the last two elements evaluate them and then add them add their result onto the stack again all right so let's go ahead and look at the code implementation of the same problem this is the problem evaluate reverse polish notation which is the same as the post fix notation on lead code all right what are we going to do first things first initialize a stack right the stack is going to be an empty list I'm also going to Define these Ops which is basically going to Define for this character for this current operator represented as a string as a character I want to do this operation I'm going to do operator dot add for minus I'm going to do the subtraction for the multiplication I'm going to do 1 and then for the division I am not going to do floor Dem right these are the two options because we have one as true div which is just a slash and the floative which is actually double slash so it might look tempting for you to do double slash in when it comes to python code although in other languages you can just do slash and get away with it in Python do not do double slash because that is floor div that does not work as intended as you want and it's going to give you issues when it comes to negative values uh I won't go into much more detail in that you can go check out some of the links down below anyways what we're going to do next is we're going to iterate over these token given in the input tokens so what was the goal we have to first figure out if it's operand or not now we'll say if the token is not in the operators that is if the token is not of plus minus multiplication or division symbols that means it's a integer value given to us so what we're going to do is we're going to convert that token to an end value and append it to the stack all right cool so now what we're going to do in the else condition the else conditions when we have these kind of operators with us so what we want to do is pop out two elements from the top of the stack do the computation and then append the result back into the stack now just a quick run through of what's Happening note that the ordering of these matters a lot we are first going to pop out N2 and then N1 again uh look at all of the simulation actually Vijaya I didn't explain it back them but is something very important look at what we have done right so as soon as we get the plus operation what do we do we first pop out this element from the top of the stack which is going to take the second place and then we're going to pop out this element which is going to take the first place so this one we currently popped out this guy is the N1 and the element on the right hand side is the N2 right this makes more sense for division as well as subtraction because they are not exactly commutative all right anyways first will pop out N2 and then will pop out N1 whatever the result is we are going to get it by using this Ops of token that is whatever this token is say it's a plus sign so we'll go ahead into this dictionary and access this operator dot add function and this is going to take into values again N1 and N2 whatever the result is we're going to append it to the stack now one last thing that we realized one last thing that we realized was that the stack is going to have only one single element at the end of this iteration which is going to be the answer so we return it at the end and uh now let's go ahead and test the code out so we'll run the code once okay looks good and we'll go ahead and submit this all right cool so this works out and uh yeah this is sort of a formal implementation of evaluating reverse polish notation by the way if this seems too fancy you can write some manual code here as well you can just say LF token is a plus sign just go ahead and do this this this and result will be nothing but N1 plus into and something like this and so you can do LF for all of these sort of cases right if that seems too fancy you can do it this way as well all right cool so this is it and I'll see you in the next one hello everyone and welcome in this video we're going to implement basic calculator one two and three all using the same exact code believe me I'm going to do a copy paste like nothing you've seen before all right so the first thing we want to do with basic calculator is realize that we have already written most of the code in these two functions post function is going to convert the infix notation to the post fixed notation and the second one is going to evaluate the post fix notation again both of these functions have been covered in separate videos of their own which each of their own intuitions observations and formal code that we wrote down in this question however we have to write one more function which is going to do the parsing or the cleaning up thing so we're going to do and create a read function which is going to take in the string and return us the infix notation all right that is the goal of this problem okay why do we do this by the way look at this the input we are given is a string and so we can have a case like 3 plus a bunch of spaces one space times 337 okay so nothing too special but you can see that this is a hard string to work with mostly because won't it be so nice if you can actually have a list of tokens that we need to focus on that is if you have something like say uh something that gave us three then something that gave us Plus then punch Then star then 337. won't it be nice if we have a infix notation laid out like this right this will make things a lot simpler because we don't have nasty spaces to deal with and all of the numbers have been dealt with that is 337 actually is considered as 337 and not three three and seven right these are some of the cases that we have to handle and so what we are going to do is convert and read the string into the infix notation so the infix notation is going to be a list which will return at the end how do we go about making this happen well we'll go ahead and write a by Loop so we'll say I equals to 0 and while I is lesser than the length of s go ahead and keep on doing some computation the first thing we'll do is clear out all the spaces so if the SFI the current character I'm looking at if it's a space well just go ahead and ignore this I don't really want to mess with this what do we do well in the case of space we simply ignore but in the case of operators we can't really do that because we have to add these individual operators to the infix notation list so what I'm going to say is if if s of I is present inside of the operators by the way these operators is the variable over here which is simply just the brackets and the multiplication division signs blah blah if the current character I'm looking at is an operator well then go ahead and add this to the infix list so I'll do infix dot append the current s of I I'll also do I plus equals to 1. all right what's the else condition vl's condition is some case where we have a digit like 2 or 234 or 345 things like that so we have to handle cases like these separately right what I'm going to do is I'm going to create a number variable which is going to be an empty string and I'm going to say you know what while the SFI dot digit is digit actually so while the SFI I'm looking at is a digit well then go ahead and append this to the number so I'll do number plus equals to the S of I and once I'm done with this oh by the way I'll also do I plus equals to 1 always and once I'm done with this iteration when the saturation stops when I get either a space or an operator I'm going to say you know what go ahead and stop at this point of time and please go ahead and do infix dot document p number one thing that we always check whenever we write these by Loops is whether s of I will actually exist or not there might be a case where this I plus 1 might take it out of the length of the string so we'll also have to say keep it limited to that while I is less than length of s and this happens then do these computations okay so we are almost done but there's one more thing that we have to keep in mind and this is sort of a well kind of a pain implementation that we have to take care of because here's the thing the minus could be used as an unary operation that is in the case of 1 and sort of minus of 2 plus 3 all of these cases like all of these cases are valid but in one of the codes we have seen previously we did not handle these unre operations so what is a hacky way around this okay this is going to be a very happy way but what we can do is we can add a 0 in front of it so as soon as we get an honorary minus we're going to do 0 minus that thing so in the case of minus 1 we'll instead write it as 0 minus 1 and instead of minus of 2 plus 3 we are going to write it as 0 minus 2 plus 3. this is going to make the rest of the implementation consistent with the logic so we'll have to say you know what uh before you do this please go ahead and check if the SFI is actually a minus sign or not because if it's a minus sign then we need to do some extra steps before we can jump into solution all right when is a character when is this minus sign and unre operated this is a ninery operator in a bunch of cases we have to say first of all if I equals 2 equals to 0 then go ahead and do infix dot append 0. that is if this minus sign is the first thing you ever get in the entire string if it is the first position in the string then you have to append a 0 before you append this current operator all right but this is not the only case all right so we can have another case where we say uh say 5 minus of minus 2. all right so this is a case where the preceding element with the element to the previous of this minus is actually an opening bracket so we'll also have to take care of this condition and say that you know what if the current minus the zerothal element is the zeroth place where an append 0 to the infix before you append the minus or we have to say or if the S of I minus 1 If the previous element If the previous character was an opening bracket then what then you have to take care to also append the zero by the way just to make sure that this I minus 1 actually exists we have to write one more condition and say that this I minus 1 this I minus 1 should be greater than equals to 0. right so pretty simple and uh yeah I think we're done now let's go ahead and run the code once oh by the way we still have to write all these functions now so the first thing we'll do is go ahead and read the S string given as the input and this will get me the infinix notation for the infix notation I'm going to convert it to the post fix notation so post fix equals to in fixed to postfix of impacts and finally I'm going to return evaluate postwix all right cool let's go ahead and test this out hopefully it works ah God damn it okay it's a typo line 20. is digit okay cool fixed again hoping that we don't have any issues let's just hope that we don't have any more issues it's going to be a pain otherwise all right I'm gonna go ahead and submit this let's hope and great we got it accepted cool so now as I promised before we're going to do a massive copy pasting thing I'm gonna control C go here and uh paste this baby over here let's go run the code once again get it accepted here all right cool looks good and once finally in the basic calculator 3 is going to do the submit directly YOLO all right cool so we get this code accepted in all the three questions just by using these simple Logics what did we do we first read the input string and we sort of cleaned it up and converted the string to a list of tokens then we went ahead and evaluated and converted the infix to the post fix notation and finally we evaluated the postrix notation all right cool uh this is it for this video and this ends the string related section of Stack questions next up we're going to look at monotonic Stacks which is more of a mathematical side of stacks all right