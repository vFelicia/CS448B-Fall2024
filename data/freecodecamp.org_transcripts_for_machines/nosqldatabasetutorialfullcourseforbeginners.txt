Hello everyone here on freeCodeCamp today and welcome to this course on no SQL. My name is Ania Kubow, and I'm a software developer and course creator on YouTube as well as your instructor for this video. In this video course, I will be demystifying what no SQL is clarifying the difference between SQL and no SQL as well as going into a deep dive of the four main types of no SQL databases. With each deep dive, we will be approaching each learning as an explanation, example and exercise. So the three is in order to fully grasp the topic we are discussing. After that, we will go straight into using what we have learned with two real life use cases. By use cases, I mean, we will be getting data into real life projects using a document API, and the Graph QL API to communicate with our newly made databases. And finally, we'll be wrapping up with where to go next. Don't worry if none of this makes sense to you. Now, this is what the tutorial is for. As always, if you like what we are doing here at freeCodeCamp, please do get that subscribe button and click as it would really help us on our mission to provide a broad spectrum of learning materials right here free to access for you. Now, let's get to it. So the first thing you need to know is that no SQL is an approach to database management. It is considered to be super flexible as it allows for a variety of data models, such as key value, document, y column or tabular and graph formats. These are the four we will be looking at today, as well as a new emerging trend of multi model databases. So we have already mentioned that no SQL databases are casually considered to be flexible. But officially the defining characteristics of no SQL databases are considered to be that they are non relational, distributed and scalable. Distributed refers to running on clusters of machines globally distributed to support apps at two different geographical locations. And scalable means that no SQL databases are able to store and query life scale data, as well as support high transaction throughput scaling horizontally. In addition to this, they're also partition tolerant, meaning that they are able to work in the presence of network partitioning. And they are also highly available, meaning that they are able to serve requests even when some machines go down. They can do this as they have data replication built in. And lastly, what does non relational entail? To understand this fully, we need to look at relational databases bust, the relational data model and SQL were designed for databases that work on single machines and scale vertically. We will go into this in a bit more detail later on. In fact, everything we just mentioned is in contrast to what relational databases are all about, which is Atomicity, Consistency, Isolation, durability, or acid for short. I am bringing up relational databases as you understand where no SQL came from, we have to look at them as well as SQL. SQL stands for Structured Query Language. It is used for relational databases. By relational I mean, it's a collection of tables with rows and columns that stores a specific set of structured data. No SQL is used for non relational and relational databases. Okay, so when you think SQL think are the Structured Query Language for database management on relational databases, and think rigid, and when you think no SQL? Well, let's have a look at the word itself. No SQL, you might think okay, so it's the more flexible way to access data. So not using SQL destructed query language. Simple, right? Well, you would actually be wrong. Because of the usefulness of SQL. Many no SQL databases added support for SQL, leading to an understanding among developers that no SQL actually means not only SQL. So you can use the Structured Query Language or you can not use the Structured Query Language, it is up to you. So once again, to recap, SQL is a structured query language, and no SQL is an approach to database management. Got it? Good. And the book No SQL distilled a brief guide to the emerging world of polyglot persistence. The writer explains two main reasons for using a no SQL database. The first is application development productivity. When developing an app there is a significant amount of time before starting anything really, that is spent on organizing data. By organizing I mean, mapping data between in memory data structures and a relational database. So in other words a type of database that supports SQL, as we just mentioned, as a non relational database manager approach, no SQL can provide a data model that better fits the applications need an entire makes our life easier in the long run. As the data model is more suited to the application, it makes debugging and writing code easier, as well as allows for easy evolution. The second reason is large scale data. As we know, organizations today love to capture as much data as possible to improve their offerings as well as other things. However, capturing large amounts of data and processing it quickly is expensive in terms of an operation. So whilst it is possible to do so with relational databases, it is usually more economic to run large data and processes on lots and lots of little cheaper machines or clusters that no SQL databases are designed to explicitly run on rather than one large one. As is typical for relational databases. We will go into this in more detail in the next section. So in conclusion, no SQL is a database management approach. The characteristics we can expect from a no SQL database are that it is a non relational database, as opposed to a relational one, a distributed database that is designed to manage large scale data while maintaining a high performance, scalability, throughput and availability. Now, when people look at no SQL and SQL, they might be tempted to compare the two. But by now we know that we can't do this. Why again, this is because once again, no SQL is a database management approach. And SQL is a query language. So two completely different things, it might be better going forward to start referring to no SQL databases as non relational databases. So let's go ahead and switch that. So we can start comparing them to relational databases from now on. As we mentioned, relational databases use this structured query language, a language that became prominent in the late 1970s. And no SQL means not only Structured Query Language, which allows you to use the language or not use it to get data. No SQL appearance on the scene is noted as somewhere around the 2000s. With SQL, the data is modeled as tables with fixed columns and rows. And with no SQL databases, the data is not only modeled as tables with fixed rows and columns. Instead, it can be modeled as JSON documents, graphs with nodes and edges, key value pairs or with Y column or tabular databases, where columns can be dynamic from row to row within a table instead of fixed. With a no SQL database, the schema is flexible. This means there doesn't have to be any real fixed structure to the data. It can be stored in a flexible schema where this approach can make development easier due to the high level of flexibility. With a relational database, the schema is fixed, they will have rigid data types. So if you want to put a Boolean into a column that has been defined to only take integers, the attempt will get rejected. Think of it as a super strict approach. And whilst the strictness can be good, it also comes with its downfalls and can be very time consuming when trying to implement changes. And finally, let's look at scalability. No SQL usually scales out. This is also known as horizontal scaling. This involves adding more and more machines to the resource pool. Rather than adding resources by scaling vertically like relational databases do. So well no SQL scales out SQL scales up by adding more resources I mean, it adds things like a more powerful CPU and RAM to handle workload and improve performance rather than adding more machines such as service. As mentioned, there are four main types of no SQL database systems each using a different data model. Once again, they are the key value document why column or tabular and graph database types. As mentioned we will be also taking a quick look at the emerging trend of the multimodal type at the end to we will be going through each type and an explanation example exercise format. Okay, so once again, the three is now the first thing you need to know is that databases have multiple layers. The first layer is an interface or in other words, a visual platform where you can visit and interact with data, which is where you find the format, the language and the transport. In this course the interface we are going to use is called Data sex Astra database management system. This is where we will be creating all of our database types for the example and exercise parts DataStax Astra DB is an auto scaling Database as a Service built on Apache Cassandra designed to simplify cloud native application development. Because it is built on Apache Cassandra, you will see us using the Cassandra query language or CQ l a few times in this course, CQ l offers a model close to SQL and it says that data is put in tables containing rows and columns. I will be pointing this out to you when we use it. These languages are how we interact with the data in our database. The next layer is an execution layer. This is where we pass the incoming queries coming from my interface. It is also used as an analyzer and a dispatcher. And finally, we have the storage layer in which the indexing of data happens. The reason I'm using datasets Astra is that it will allow us to create all four types of database types for this tutorial, so I won't have to sign up to separate database management systems for each section. However, you don't have to. There are literally dozens and dozens to choose from, so please feel free to take your pick. We can group these database management systems into families according to the CIP theorem. According to the CP theorem, a no SQL database cannot achieve consistency, availability and partition tolerance, it must sacrifice one of the three for example MongoDB and Kafka chose to focus on CP and the database management system we are going to be using datasets Astra is not an Apache Cassandra, which chose to focus on AP. So to recap, what we are doing here is using data sacks Astra which is an interface essentially, that will allow us to work with our no SQL database, which is in this case, Apache Cassandra, to be exact. Apache Cassandra is an open source, no SQL distributed database. The language we will use to communicate with our database is Cassandra query language, or SQL for short, which, as I mentioned, is very similar to SQL. Most no SQL databases have their own query language or not. Once you are on the data sex Astra platform, we're going to create a database. So I'm just going to head over and click this button right here. And that will take me to the page in which I'm going to create our first database, and the database name, I'm going to call it FCC underscore tutorial, I would recommend calling your database exactly the same in order to avoid any issues further on for this tutorial. Of course, once you have the knowledge that you gained out of this tutorial, you will be able to name your databases, anything you wish. This is just a suggestion. However, now under keyspace name, because the first example we're going to look at is tables, I'm going to call the key space Tabular. Once again, I would recommend that you call your key space name the same thing so that you don't run into any issues further on. Okay, and next we can provide a region, we can choose Amazon Web Service, or Microsoft Azure or Google Cloud, I'm just going to stick with this one. And I'm just going to select a Europe as I am currently in Europe, and I'm going to create a database. And there we go, we have created our first database, it has a database ID, the status is currently pending. So we're gonna have to wait for that to turn active before we can go ahead and use the database. And there we go, we're active. As you can see, here, the status has turned to active in green. Great. Now that we have set up our database management system, let's start getting to some examples. Okay, great. Now let's look at the first database type, which is a tabular database type, also known as a column database type or a wide column database type. What you need to know is that tables are relational and come with a schema, we are going to be making a table called books in this next section and defining what kind of rows the table can take, and what kind of types the rows are made of. For example, I'm going to have a table called books. And in it, I'm going to say that we can only have a row that has a book ID and author a title a year release the categories the books belongs to and a timestamp for when it was added. I'm also going to say that the book ID needs to be a UU ID or a universal unique identifier. The author field needs to be some text and the title needs to be some text to the end has to be an integer and the categories needs to be a set of texts. And the timestamp needs to be a type of timestamp format and only that, okay, so what I've done here is essentially define a schema. The next thing that is important to know is that we are going to be saving this row based on a key. This is important As this is how we are going to be retrieving our data with queries later on. Okay. So for example, if my UU ID for this row looks like this, and I can save it, the only way I can find it is by searching for this key, and the whole data row will be returned. This key is also what is known as a partition key. Because our no SQL database is a distributed database, it means our data can be sold on loads and loads of different nodes. So if two rows had the same partition key, they will be stored together on one note, and when we query for that key, they will both return. Got it. Good. Now let's use it in practice with an example in which we are going to be storing books in a tabular database. So now that we have created the database and has access to us, let's go ahead and create our first table. To do this, I'm just going to double click on the database itself, it should take you to this page in which you will see the key spaces associated with this database. At the moment, there is one as we only created one key space called Tabular. Great. So now I'm going to do this part using the CPU or console. So as we know, tabular databases organize data in rows and columns. Okay, so that's what we're going to be doing, we're going to be building a table with rows and columns to store some data using C QL, or Cassandra query language. The first thing I'm going to do is use a command in order to get our key space. So to do this, I'm going to enter the following command, it is called describe key spaces. And if I hit that, you will see all the key spaces associated with my database, you will also see that tabular is right here. Just to make sure we are all on the same page, it keyspace is simply a word for a logical grouping of tables. So now that we can see our tabular key space, let's actually get to using it, I can use it using the following command, use Tabular. And just hit enter. Don't forget to put the semicolon at the end. Okay, so now you'll see that I'm actually in the tabular key space, I'm inside the key space, I now want to create a table inside the key space. And I'm going to use the following SQL command to do so I'm going to write CREATE TABLE if not exists, okay. So that is something you're going to need to create a table in your key space. And I'm going to call the table books. Now, I'm going to actually define what goes into my table as well. I'm going to define what it is I want to put into my table and what type it is. Okay. So for example, if I choose to put in a book ID, and then also going to state that this is a unique identifier. Okay, so from now on, I can only use Universally Unique Identifiers, or UU ID as the book ID. For those of you who don't know what a UU ID is, it is a 128 bit label useful information in computer systems, I will show you the structure of it as well as what it looks like when we get to using it later on. Next, I'm also going to say that my table of books is going to have an author and the author. So whatever value I have as the author is going to be text, okay, so a string. In other words, we're also going to have a title, which is going to be texts a year, which is going to be an integer. Okay, so a full number, we're going to have categories, which is a set up texts. Okay. So once again, I will show you what that looks like we're going to have multiple categories. Or in other words, it's going to be a set of texts. And I'm also going to have added, which is going to be a timestamp I have defined added to be a time stamp. So timestamp is also a type in C QL. And finally, we're going to have a primary key. A primary key in basic terms is how we're going to search for a book in our table. Okay, so imagine our table has hundreds and hundreds of books. We can filter through the table, we can search through the table by the book ID, thanks to this primary key right here. The book ID that I've passed through into the primary key is also the partition key that we discussed earlier in the introduction. Okay, so I'm putting in a partition key into the primary key. Great, and we're just gonna close that off and don't forget the semicolon and press enter. And there we go, we have now created our very fast, super simple table using CQ L, just to make sure that has worked, I'm just going to use the command describe key space Tabular. So the time I'm picking out the precise key space, and putting the semicolon and then just hitting Enter, and there we go, we can see that our table has been created, okay with the book ID added author categories set, and yeah, wonderful. So now that we have finished our table, we have created our table, let's actually get to putting things into our table. To do this, I'm going to use the command insert into. So I'm going to use Insert into that is a command that we're going to use to insert data into our books table. So I'm just gonna write the word books. And then once again, I'm just going to put in a book ID and author, a title a year, the categories that are belongs to and added and just click enter. The next thing we're going to do is actually add the values. So we didn't actually finish off this command, there's no semicolon, so we did not finish off this command, we're just making a new line so it's more readable. And I'm just going to put some values into our books. So I'm just going to open up the parenthesis, and I'm actually going to create a unique identifier. So this is a function, I'm going to call this so that it creates a universally unique identifier for me. The next thing I'm going to do is write a string of Bobby Brown as we defined author as text. So this needs to be text and needs to be a string. And then we're also going to give it a title, which is also text, it is a string. So I'm going to put dealing with tables. The next is year, which we defined as an integer. So I'm just going to put 1999, and then categories, which is a set of texts. So to do this, I'm just going to open up some curly braces this time. And I'm going to put the string of programming and the string of computers. This is because I defined categories as a set of text. So I can only put text into this set. Okay. And finally, once again, I'm going to call a function, the function is called to timestamp. And I'm going to open up my parenthesis, and I'm just going to put an another function is called now I'm going to call it, this will essentially create a timestamp with this very second. Okay, so timestamp of this very second that I'm going to put into my table. I'm just gonna close all this off, and finish it off with some semi colons, because I'm done with this command now, and just click enter. Wonderful. So now let's see if that has worked. I'm going to use the command select all. So this little asterix means all from our table called books. So we have chosen to call the table books. So that's what I'm using the word books here, and then let's get our semicolon and just click enter. and wonderful. Here is our table, we have created a table, we've put some data into our table. Let's have a look. Here, you will see the UU ID has been generated. This is the structure of universal, unique identifier that looks wonderful. Next, we've got added. Okay, so this is the function that I wrote to timestamp. Now, if I use the function, today's timestamp down to the second has been used to populate this cell right there. And next we have the author of Bobby Brown, the categories and the title dealing with tables, as well as the year which is an integer. Great. So we've created one row in our table, let's get to adding a nother row into our table. So to do this, once again, I'm going to use the command insert into again, I'm going to pick out the table that I created earlier, which I chose to call books. And I'm going to say that into this row, I'm going to put in a book ID, an author, a title a year categories and add it okay and then the values that I want for these cells are going to be once again I'm going to use the UU ID function to create a universally unique identifier for me. I'm also going to put a string of let's put Andrea Agnes as the author for the title. I'm just going to put the moon as the title of my book, and for the year I'm going to put 2001 is an integer, so not a string, that categories, I'm going to put space and non fiction, non fiction like so. And then added. Once again, I'm going to use the to timestamp and pass through now and call it. Okay, so there we have it. Once again, I'm just going to close that off, and then use a semicolon to finish this command and hit enter. Wonderful. So now if we look at everything in our books table, so I'm just going to use the command to select all books, oops, we didn't use the semicolon, select all books. Select all from books, apologies select all from books is the command we need. Wonderful, we can see now that two rows exists on our table that we created. Great, this is looking really good. As you can see, a new unique identifier has been generated a new timestamp, the author name, some categories, a title, and the year as an integer. Correct. Now what if I just want to select one thing from our table? Well, as we mentioned, we know that we can use a primary key to the book ID to do this. So let's go ahead and try do that. I'm going to use the command select all. So once again, select and then we use the little star or Asterix from books. And I'm just gonna hit enter. So I'm not gonna close up this command yet. And I'm gonna use the command where and then use book ID equals. So I've chosen book ID for myself. I've called it book ID. And I'm just going to select a unique identifier. Let's select this one. So what do we expect to return if we run this command? Correct? That is correct. We are now getting one item from our table. This because we chose to select an item by its unique identifier. Okay, so there we go. We have now successfully picked out one item from our table using the book ID, or in other words, the primary key. So we have now seen how we can pick out one item from a table. However, how can we filter out multiple items from a table? Well, to do this, we're going to work with partitions. So let's make a new table for this. I'm just going to refresh my page, you can actually also use the clear command, instead of refreshing the page. If you want to clear all of this, it's up to you. So once again, this is going to be some great repetition for you some great muscle memory practice. First off, let's actually get to listing out all the key spaces using the describe key Space Command. There we go, we can see the key space that we want the tabular key space, I'm going to use the command use tabular in order to pick out the key space that we want. Next, let's actually get to creating a table in the tabular key space. Okay, so we have one table already called books, I'm going to create a nother table this time. So the command you need for this is create table if not exists, and then we're going to choose to call our table restaurant by country. Okay, so I've chosen to call my table that as you can choose to call your table, whatever you wish. And now, in my table, well, I'm going to decide that I want to have the following columns, I'm going to have the country which I'm going to define as text. Next we're going to have cuisine, which I'm also going to define as text a URL, which again is going to be some text. And now I'm going to have a primary key. So from our previous lesson, we know that we can search for something in a table by its primary key, I'm going to choose to search by the country. The country is actually the partition key we refer to in the explainer okay. So, we have a primary key command and we are passing through where we want the partition key to be if that makes sense. So, what I have done is chosen one of the table columns here I have chosen country to be my partition key and I have passed that into the primary key like so. So now also what is happening is that all my data from now on is going to be distributed in my database based on the value of country. Now, the other values here that I have put so name and URL are What we call clustering keys. So what this means is that when I search for data based on the partition key, so in this case, it's country, I can make it come back in descending order, and URL in ascending order. Okay, so there we go, let's go ahead and run that command, not forgetting the semicolon. And there we go. Next is actually insert some data into this table. So just like before, I'm going to use the Insert to command. And I'm going to insert into the table that I have chosen to call restaurant by country, going to open up some parenthesis, and I'm going to say that I want to put in a country a name, a cuisine, a URL, and I'm just going to close that off, and then start a new line with the values. So open up the parenthesis again, and I'm going to put the string of Poland the name, I'm going to put VAs ska, catch ma as a string. And then the cuisine, I'm also going to put some text for this, I'm going to put traditional as a string, and then the URL once again, this is a string, I'm going to put w w.kajima.pl. And close that off and for the semicolon, and click enter. And wonderful, I'm just going to insert a another row while we are here. So once again, insert into my table name is restaurant by country, I'm going to open a parenthesis to say what exactly I want to put in this row, I'm going to put in a country and name a cuisine and a URL. And in the next slide, I'm going to put the values this time, let's put Singapore and I'm going to put the shark as a string, this is going to be American food as a string. And the URL is going to be W W dot shack dot S, G, no, close that off. And wonderful. Hit enter. Great. We can also do a third one. So I'm just going to actually press up this time, we will just bring back the last line. And for the values, I'm just going to replace that with United Kingdom. And for this one, let's put the red rose. And I'm going to put pub as the cuisine. And as the URL. Let's just put red rose.co.uk. and wonderful. So now click enter. And great. Let's check if that has worked. So I'm going to use the select command this time, Select All. So the Asterix is all from restaurant by country, because that is the table name. I want to get everything from the table. Oops, nice post I semicolon. And great. There is our table. This is looking good. And once again, let's try and get in one thing from the table. So select all from restaurant by countries of the table name where the country equals the string Singapore. Okay. And that just puts in semi colons and hit enter. And that should return back the singular restaurant. So the shark because that has the partition key of Singapore. Wonderful. Now, what do you think happens if we add another row that also has the country Singapore? Well, let's check it out. For this part, I'm going to involve you I'm going to break to an exercise. So what I want you to do is actually add a nother line. So now the road to our table that has the country Singapore, the name of the restaurant, the heart, the URL www.hud.sg and cuisine Lebanese, okay, so go ahead and add one row to our existing table. But before we do that, I'm going to ask you to refresh the page. So go ahead and click that. And wonderful. Go ahead. I'm going to pause here while you have a go at doing this yourself before we carry on together. Okay, so first things first you can of course is the describe key spaces command to list out all the key spaces in your database. Or you can just go straight to it if you know which key space You want to use. So I'm going to choose Use tabular, just like Sir, making sure that I am in the tabular key space. Next, I'm going to essentially insert a row into the table restaurant by country. So I'm going to do so like so. First things first, I'm going to use the Insert into command. And I'm going to insert into rest. Durrant by country, just like so because that is the name of our table, I'm going to insert a country, I'm also going to insert a name, I'm going to insert some cuisine and a viewer L. Okay. So that's what I'm going to do. And I'm just going to make a new line. So don't put the semicolon yet insert into restaurant by country. And then I'm going to put in values. And the values are going to be a string of Singapore. And then the name we said is going to be the heart. The URL is going to be WWE dot heart dot S, G. And the cuisine, which is the one we miss, I'm just going to go back. It's going to be Lebanese, Lebanese. Okay, so let's have a look. Make sure that it's all correct. Okay, great. And hit Enter. So now we have a look at everything. So select everything from restaurant by country that we go, you will see that line has been added, a new row has been added. So now if we do select everything from restaurant, we could actually just press up. And then we go where, and I'm going to get the partition key. So country equals Singapore, what do you expect will happen? Tada, we get back the two restaurants that are in Singapore. Wonderful. So that is essentially how you'd group data together in your table and retrieve that group data back. Now it's time to move on and look at document database types, document or document oriented database types are arguably one of the easiest types to do. This is because they require no schema. So before in the tabular database, we had to define the columns that made up our table. With this, we don't have to do any of that. As long as our data comes as an object, it's fine. The objects are made up of keys and values look like this. So this is an example of perhaps an item you might find in a to do list. So here you have an object which I have given an ID with a zero, a title with fixed bike as a string description with a string and done which I have in this case, given a Boolean that is not strict. The values can be strings, numbers, Boolean arrays, or even objects themselves. This is called JSON, or JavaScript Object Notation, and is the most popular format for document database types. Now, a group of documents is called a collection. So we will not be using the word tables anymore. It has been replaced by collections. So keep that in mind moving forward. So what are we waiting for? Let's get to it. In this next section, I'm going to make a collection of to do items using a document API. Now for those of you who haven't heard of the term API, let's do a quick crash course first. And API stands for Application Programming Interface. They allow for technologies to essentially talk with each other and are essential to serve the services we rely on today. They are behind most apps we use on a day to day basis. And they can shape information paths between one technology to another. And they connect things such as our cars, purchase pens, or anything really, to the internet. API's are everywhere. As a developer, you might use the Twitter API to get like tweets on your site, a Map API that will allow us to get data from a third party to use a new delivery app we are building or even use them in a two way stream to get post or delete data from a customer relationship management system. For example. There's a reason why these words are popping up. And let's go into why. In this next section, you're going to be seeing these words I'm using them to communicate with the database you make. In this context. They are called HTTP request message. That's the most common are the get request, post request, PUT request and delete request. There are others too. But for the sake of the tutorial, these are the ones you need to know. Get essentially gets data. And that's all it does. So imagine you have a client or another word, your computer and a server, you are on your computer. And the URL, which is where you want to get your data from is on a server, the client. So once again, your computer sends an HTTP get request to the server to retrieve the data we want. So here we have a get request or a visualization of a get request, the client is requesting the server gives it the necessary resources we need. Then, after the server has sent the response, so request and response, we say that we've got it. Thank you. After the server sends a response, it closes something called a TCP or transmission control protocol connection. We also have a POST requests and put requests. So here we have a visualization of how the request would work with post requests. So simply sending something to the server. And with the PUT request, which are the same, we are sending something to the server. But essentially to edit something or override it, we will go into this in the next section. And of course, a delete request to a delete request will essentially delete something that is pointed to an idea or endpoint. So to get interacting with my data, you will see these different endpoints, simply put an endpoint is where a resource lips. So with this endpoint here, forward slash burgers, I will get all my burgers, I can also create a burger to the same endpoint. To create a burger. However, I use the post haich TT method. As we discussed, I can also edit a singular burger, also, as we discussed. And of course, we have delete, which you guessed it will delete a singular burger if we provide the end points with the ID. Okay, so hopefully, this theoretical example has made sense, let's get to using our knowledge in our project. Okay, the first thing we're going to do is actually create a new key space, I'm going to call this key space document, I'm just going to go here and save it. There we go. Okay, so now we've got two key spaces, I'm going to keep the workload separate. So one for tabular, and for document, because we're going to be working with document types in this section. So to do this, I'm going to choose to connect to my database using the Document API. However, before we do that, we're gonna have to get a token in order to communicate with our database. So to do this, I'm just going to go to settings. And then under Application tokens, organization settings, click that the role I'm going to select as an admin user, and I'm going to generate a token. So this is the token we are going to use, please, of course, do use your own, I will be deleting this after this tutorial. So just go ahead and copy that and make sure to store it somewhere safe. Okay, great. Now, once you've done that, just go back. And this time, we're not going to use the SQL console, we're going to use this connect tab. And we're going to use the document API to connect to our database. Okay. So all I'm going to do is launch swagger. And this will load some swagger Doc's for us that will be useful in communicating with our database. Okay, so this is all pre made for us. There's not much we're gonna have to do, we're just gonna have to fill out some blanks. The first thing I'm going to do is actually create a new empty collection in a namespace. Okay, so before, as mentioned, we work with tables. Now we're going to be working in collections. Okay. So once again, we were working with tables before. Now we're going to work with collections. So I'm going to create a new empty collection in the namespace and just click Try it out. And all I'm going to do is fill out all of these empty spaces that have been created for us while We are here is actually important to note that you can write your own code for these requests. So at the moment, we are in a post request, I will be showing you how to do this in the project portion of this course, for now, we're just going to make use of this pre configured UI to help us make these requests. So all I'm going to do is actually put in my Cassandra token in here. So that's the one that we just created. And under the namespace ID, well, we know that our namespace that we just created, or in other word, a key space is called document. So that's what we put in here, document, okay, not tabular document. And next, we're going to have to put something in the body of our requests. Okay, so we're going to have to put in some JSON with the name of the collection. So all I'm going to do is choose what I want to call my collection. And I'm going to choose to call it my first collection, just like so. Okay, so you open up some curly braces, this is how Jason looks, we open up some curly braces, we put the string of name as we are prompted to, and the string of my first collection. Wonderful. So now we can scroll down. And just click execute, and then wait for our response. And as you can see, that has returned with a status code 201. Okay, status code 201. So that has worked. If you don't know about service codes, that is a really handy website, I'm going to show you with all the status codes that could return, it illustrates them with little dogs. And it's really easy to understand, this is something that I use quite a lot in my day to day, developer life. Okay, so we have now created a collection called My first collection, let's carry on, just going to delete all of this, and cancel that. And now the next thing I want to do is put something in our collection, right, so I'm going to create a new document to do this. Once again, I'm just going to click Try it out. And I'm going to fill out all of these spaces. So once again, it's putting the token that we just created. Next we need the namespace, or as it's called on our platform, the key space. So once again, I'm going to put document and in the collection ID. Well, the collection that I want to put this in is called My first collection, because we just created and in the body in the body, I'm going to put in my first item into the collection. And this is what I want it to look like. Okay, so once again, we have the curly braces about the string of ID, which I'm going to give it as one, I'm going to give it the title of make dinner. And then the description of make dinner to apologize for breaking my housemates bike. And done is a Boolean of false. Okay, so this is the first document I want to put into my collection is just an object that has some information, okay, I can make this information, whatever I wish. So this is what my information looks like. Let's carry on. I'm just going to click Execute. And there we go, we get a 201 code. And that has responded, we also get a response with this, which is the document ID. So the document, we just created the one with ID one, the one about making dinner has this document ID, this is its identifier in our collection. Okay, great. Now let's get to using this ID. So now I'm going to show you how to do two things. I'm going to show you how to search for everything in a collection. And I'm going to show you how to search for one thing in a collection. So let's start off with the first one faster search for everything in a collection. To do this, I'm going to just select search documents in a collection. And once again, I'm just going to put in the Cassandra token. Let's click Try it out. I'm also going to put in the namespace or key space as it's called on our platform. So I'm going to put in document for the collection. I'm simply going to put my first collection, and then I'm just going to execute it. Okay, so I'm just going to scroll down and hit execute. And there we go. We get a status code 200. And we also get the response body. So that is responding with all the data in our collection. At the moment. There's only one item Okay, so it might be a bit hard to tell you might think it's just bringing about one item but it's in fact bring back all the items in our collection. Great Now I'm going to show you how to pick up an item based on the document ID. So the thing we created in the part just previous to this. So to do this, I'm actually going to use the document ID. So let's just go ahead and grab that. And then let's go to get a document. Once again, let's click Try it out, I'm going to put any document ID, and then I'm just going to fill this out. So once again, the collection I'm looking at, and it's called My first collection. And then the namespace is called document and the Cassandra token, well, we just need to paste that in. And click Execute. And correct. So we're returning that one item from our collection. Okay, based by its document I do. Okay, so now that I've shown you how to create a collection, add a document to collection, get all the documents back, and just search for one document in the collection by document ID, I'm just going to show you how you would do this in the project part. So all we're going to do, or essentially all of that is happening here on this platform is that we are constructing a URL. Okay, so every time you fill out a field, you are constructing this long URL. As you can see here, we've populated it with a namespace, a collection and a document ID. So this is exactly what we will be doing in the project part, we're going to be making a request to this URL, however, with authorization. So at the moment, if I just take this URL, and I paste it in the browser, you will get a message that says role an authorized for this operation, missing token. Okay, there are tools that we can use to help us if we do want to view this before building our project, one tool that comes to mind is a tool called hopscotch that I use quite often. And then all you would do so I'm just going to gravitate to hopscotch. And I'm simply just going to create a new request here. So all I'm going to do is put in the URL that we just created, making sure that the method is a get request, okay, because we are getting the data. And I'm simply going to put the Cassandra token that we have. So the one that we've saved the really long one in the header. So once again, I'm going to get that token, and first actually going to get x Cassandra tokens, we can identify it, and then I'm going to paste my long token. Okay, once again, make sure that this is a get request because we are getting data from the database, and Qlik. Sense. Wonderful. So now we get a status code 200. And we also get some response, we get the response body to be the document we have just created. Great. Before we move on, I'm just going to show you how to do one more thing. And that is search for something by a filtered field. So what I can do, I'm just going to go to search for documents again. And in here, I'm just going to add a where string. So this to jog your memory is how we return all the documents back from a database, I can also filter out which ones I can filter them out by title. So for example, I can choose to filter out to this this syntax for filtering out, I can choose to filter out by say title. And anything with the title of make dinner will be returned back to me. So once again, I'm just going to do that that is the syntax for filtering out all of my documents and search for any one that has the title make dinner, or any multiple ones that have the title made dinner, and then click Execute. And anything with the title made dinner will be returned back to me. Okay, great. Okay, so now that we have done that tiver a little exercise. Based on all the learning that we have done so far, how would you go about creating a new item to put in our collection? So at the moment, we have one item in our collection called My first collection, I would like to add another. So which of these do you think I should go to? That's right, I will need to make a post request to this URL, and replace namespaced ID and collection ID as well as provide my authorization token. So let's go ahead and do it. I'm just going to refresh this so we can start a new and click here. So once again, I'm just gonna click here to try it out. Under the Cassandra token, I'm just going to put in my token, the namespace ID or as we know the key space ID is called document and then the collection ID is called My first collection. And now we need to create our document. So I'm going to create an object for this, I could simply just have an ID like so let's give it the ID of two, and then a description. And then make it clean dishes after dinner. And if I executed that, that would work. However, I have chosen to keep all my objects the same, that is a personal choice. So let's go ahead and add a title. I'm going to make the same title that I did last time, and I will show you why. So there we go, title description, and then done, I'm going to give it the value of false, that does not need to be in quotation marks, that is a Boolean value that I'm assigning to the property done. Okay, so now if I click Execute, we get a 201 code with the response body that has come back with the document ID for this document right here. Okay, so we've added one more item, I'm just going to add a another item, let's make this ID 10. Let's give it a different title. So fixed shoes. And take choose to fixed with done false. And once again, I'm just going to execute that. So what that means is, I now have three items in my collection called My first collection. Two of them have the title make dinner, and one has the title fix shoes. Now, if I wanted to bring back all the documents, or the title make dinner, so all of them associated with making dinner, how would I do this. So once again, three items in my collection, I only want to bring by two, and that includes the ones that have the title make dinner. That's right, I would have to make a GET request to this URL. So replace the namespace ID, the collection ID and provide an authorization token. So once again, I'm just going to click to try this out, I'm going to grab the Cassandra token, the namespace ID I want to look at is called document or in other words, the keyspace name, the collection ID I want to look at is called My first collection. And this is the syntax for filtering out I want to filter out by title and want to make sure that that title is equal, making sure to put this in quotation marks equal to make dinner, which is case sensitive. Okay, so that's the syntax. And what do I expect to come back, I'm actually going to set the page size, let's just make it Max 20. So if I add more than two, for example, and I only want to 20. To come back, this is how I do it. And then I'm just going to click Execute. And there we go. So now we can see that two items have come back to us, this one, this one, and we do not see the item that has the title fix shoes. Great. And once again, all we have done is generated this URL by filling out all of the above. Okay, so what I am doing is, there we go, we see the namespace has been replaced, you will see the collection name has been replaced. And if we look where well, we are looking for a title equal to make dinner. And we only want to bring back Max 20 items. Wonderful. So I hope you've learned a lot in this section. Please do pause here, I can't stress enough how much I recommend pausing here and having a play around with all the different requests you can make. So for example, if you want to delete a document, or update a document to please have a play around with that, and once you are done, I will see you in the next section. In this next section, we are going to look at the key value databases. They are considered to be the easiest database type and usually come looking like this. So you have a key column and then you have a value column. You can actually have as many value columns as you wish. The important thing here is that we can retrieve data back to us. So an entire row by the key as that is the identifier in this case. Let's have a quick look at an example of a key value database and how to make one next Okay, so I'm going to click here and just add key value, and click save. Okay, great. So we can now see another key space has been added. Now, this time, I'm going to use Graph QL, just as a little bit of something different in order to create our key value table. Okay, so this time, I'm going to choose to connect using the Graph QL API, just purely because we've already worked with the document API. So I'm going to click here, and just launch the Graph QL playground, just like so. Now, the first thing we need to do when we are here is to create a new table. So first off, I'm actually going to put in my Kasandra tokens are able to communicate with my database. So I'm just going to grab it, just like so. And now you should be able to see the documents populate with all the queries or mutations that we can do. So as I said, I want to create a table. So let's go ahead and do that. This is a mutation as it's under the mutations tab. And to create a table, just going to write create, table, and EZ Pass through the following things. So a keyspace name, a table named partition keys, and values. So the key space name, I'm just going to put this on a new line. Well, we know that the key space name is key value, as we've just created it. Now the next thing we need to actually do is give our table a name. So I'm going to call this shop inventory just like so. And the partition keys. Now, if you remember from the first section, our partition keys is essentially the key that we want to filter our table by or search for items in our table by and it says here that this needs to be an array. So that's what we're going to do, we're making an array. And then what do we want our partition key to be, I'm going to give it the name of Ki. And I'm also going to define the types that it takes. So I'm just going to put type, like so. And I'm going to pass through basic text. Great. So we have our key space name, we have our table name, we have our partition keys. Next, let's put in the values. As you will see, these all have a bank after them. So they are required values is not required, but we're going to need it for our table. So once again, I'm just going to put a comma and put in values. And this needs to be an array. So I'm going to open up the array, and I only want another one column. So at the moment, we've got one column, which is a key. The next column I want to have is values. So I'm going to name this value. And once again, I'm just going to give this the type of basic text, just like set. And if we click here, wonderful, we have created our table. Great. So we've created our table, the next thing I'm going to do is add keys and values to our table. So I'm just going to go ahead and delete this. And instead of having a Graph QL schema, I'm going to have Graph QL forward slash, and I'm just going to put in the key space. So key value, just like sir. and wonderful. So now we're in the key space key value, I'm going to use another mutation to see who the mutations and queries have changed because I can do a bunch of other stuff. I'm going to use the Insert shop inventory. Okay, so that is what I'm going to do and start mutation as this is a mutation. And I'm just going to say shop, insert shop inventory, just like so. And I'm going to use this to insert items into my table. So I need to open up some parenthesis, and then in here, well, I want to pass through a value. And that's going to have my key. So what key can we give this I'm just going to put an A string as we said it needs to be text. And I'm just going to choose to give it this key. So this identifier just like so. And then the value of let's have beans. So what I'm saying with this code is that I want to put in this row into my table that I have just created and the row will have the key of this The value of beans, meaning that if I want to search for beans in my table, I would use this identifier. Okay, so I'm just going to also have to return something. So we know this works. So I'm just going to return the key and the value. Click here. Wonderful. So now we know that we have inserted this one item into our shop inventory into our table that we have called shop inventory. Let's just add another item. So I'm just going to make this random once again. And then another item we can put in his shell. And just click Yeah. Great. So now I'm going to actually retrieve this data. But first off, I just want to show you what this looks like if we use the sequel console. Okay, so I'm going to go back here. And under the secure console, well, I am just going to write, use key value, because we need to get the key space. And once we are here, I'm going to use the command describe table. Shop inventory. Okay, so we can see here, we have added that table, that table exists and exists in the keyspace key value. And now if I want to grab everything from the table, well, hopefully you remember this from the first lesson, select all this essentially means all from shop inventory, making sure that I spelt it correctly inventory. And there we go. We have a table that has a key and a value. And we can find any item in our table. So any row by the partition key or the key right here. Great. Okay. So hopefully, you can see how we can make tables using the key and value approach. Just while we're here, I'm going to show you how to retrieve all the data from our table using Graph QL as well, just in case you are not familiar with Graph QL. This time, I'm going to have to have a query. So I'm going to write a query just like so. And I'm going to look in the shop inventory. Okay, so I'm looking in the shop inventory. And what do I want to return? Well, if I just want everything, then I would simply put values, key value, and click enter. And there we go. We are getting all the items from our shop inventory table. Okay, so if you want to use this in the project, and you want to get all the items from your shop inventory, this is the query that you would use. Wonderful. Okay, before we move on, I'm just going to do a little exercise to see if you've remembered what we've learned. So I'm just going to get rid of this. If I want to add one more item into the shop inventory. How would I do this? And what two things do I need to check? Well, first off, we need to check the we're in the correct URL. Okay, so we need to make sure that the URL is pointing to the key space. In this case, its key value, because that is what I call my key space. And that I also have my Cassandra token in the header. Okay, so those are the two things you need to check. And once you have checked that we can write a mutation, okay, not a query, a query essentially retrieves back data. And a mutation adds data deletes data, or edits data. So for this, because we are adding a new item into our shop inventory, I need to write a mutation. And that mutation is insert shop inventory, because I'm inserting into the table called shop inventory. Okay. And what do we need to put in here? Well, we need the values of key and value. And what are we going to have the key well, at once again, I'm just gonna put in a random string like that as an identifier. And the value this time I'm going to put, I don't know, Coca Cola. Okay, great. And just to check this as work, I'm going to return the values of key and value. I could technically just return one, it is up to you, and just click here. So now because that has returned, we know that has worked. Brilliant. Now, how do you think and this is something we haven't covered? So this is going to require you to have a little bit of a think based on what I've told you. How do you think we would delete an item from the shop in entry. Well, that's right. Because we are changing the data, we're going to have to find a mutation that will delete from our shop inventory. And because we find stuff by the partition key, so this, we are probably going to have to delete an item by searching for this key right here. So let's check it out. So I know this is going to be a mutation. And I can also look in the docs to find the Delete shop inventory mutation to help me out. So that is a mutation that I need delete shop inventory, and I'm just gonna pass through the values of key, I'm just gonna grab this one right here, I'm just going to return the value of key. Okay, and that should have worked. Let's go have a look here. And once again, I'm just going to chop list out everything in my shop inventory. And amazing. So we added the Coca Cola, and then we deleted the Coca Cola to great. Now, if I was to say try delete something by the value, so let's go ahead and put sham and then just return the value, we will get an error. This is because we cannot delete by the value we have to delete or the primary key, which we set to be the key. Okay, wonderful. So I hope you've learned a lot in this section. And I'll see you in the next one. In this next section, we are going to look at Graph databases. Graph databases are a great way to store data that has relationships between other pieces of data, or in other words, notes. Each node is connected by an edge to represent this relationship. Think for example, your friends on social media, he was you and here are three of your friends. So you and your friends are nerds. And the connection you have is represented by this line, or as we are going to call it from now on an edge. Easy, right? But wait, your friends can also be friends with each other. So how do we represent that? Well, by adding more edges to represent the relationships, and as your friendship circle expands, the more complex it can get. So that is the simple idea behind how graph databases work. Let's see it in action. In this section, we will be doing an overview of an already existing demographic database. The GitHub repository for following along will be given to you in the description below. So once it gets to that, please go ahead and find it below. Okay, so this time, we are not going to be using the datasets Astra interface, we're going to be using the data stacks enterprise graph. Okay, so let's go to it. For this part, you're going to have to have Docker installed. So please go ahead and download Docker if you don't have it already installed onto your machines. Okay, so once you have it installed, it should look something like this. All you need to do when you're here is just click the settings and make sure that the CPU and the memory, the swap and the disk image size are all around about these levels. Okay, so that is what you need to do. Make sure that you have at least two CPUs. So here you see eight, and at least three gigabytes or RAM. So these are the settings you need. Once you have them. Let's carry on. And once you have that done, I'm just going to ask you to get up your terminal. And then in whatever directory you wish, please write the following command. So please go ahead and write the command Docker network, create a graph and click enter. So what you should have is this long ID right here. Okay, so once you have that we are now ready to carry on. This is your identifier for the graph. The next thing I'm going to ask you to do is clone this directory. So this is directory I will be putting at the bottom in the description. So just clone the data stacks tabs workshop introduction to no SQL and click enter. Now I already have that in here. So I'm just going to go into the directory, CD workshop introduction to no SQL and once we are in here We are free to start the container. So what I'm going to do is Docker compose up D, and then wait for that to open up empty localhost 9091. So this will take a while please feel free to pause here have a break. Let's get back to it once all of this is complete. Okay, great. And now let's go ahead and visit localhost 9091. Okay, so this is an example from data size itself, please feel free to use it and adapt it as you wish. And there we go. So this is what you should see here is the example that is given to us from data stocks. Let's go ahead and first check our connections. So I'm just going to click here and on connections, it's going to click on this one right here. And just make sure that this is on DSC. Okay, so this essentially is pointing to our local Cassandra. So once that is done, let's test it out. And great, so we are connected successfully. Let's carry on. Now, let's go back to here and just click on this example one, like so. Now, you will see that you're prompted to create a graph. So let's go ahead and create our first graph. I'm just going to keep it as to do tutorial graph like so. So just leaving all the default settings. Okay, and I'm just going to click Create. Wonderful, our first graph is now created. Now if you move down here, you will see a language called Gremlin. Okay, this is the language that we are going to use for this tutorial, it is essentially another query language. Okay, so we've looked at SQL, we've looked at C QL. And now we have Gremlin it is a graph traversal language, okay, and it has been developed by Apache TinkerPop of the Apache Software Foundation. With this language, we are essentially creating schema, okay, so just like we have been doing, you will see here that we are adding a schema called God. And we are giving a partition key. In this case, it's going to be the name, which is some text, and it also has a property, which is age, which is an integer, and we are creating it, we are also creating a demigod which has the same partition, a human again, which has a partition key of name, a monster, a location and a Titan. Okay, so here we have the code in order for us to essentially create our first graph, all about gods and demigods and monsters. So I'm just going to click here to run this. So run this in real time. And wonderful, that has been a success. So, now, if we look down to here, you will see some more code again in the language Gremlin. So just like we created labels here of God, demigod human monster, we have now also included edges. So these edges are essentially how each one is going to be related. So this edge is called Father. So this is going to show us a relationship of father and son or daughter. And then also we have mother and brother, too. And it will also give us the direction. So a god is essentially the father of a demigod, but also can be the father of a god if someone is a Titan. Okay, so that is how that looks. Let's carry on. If we move down, we can see more edge labels. Okay, so we can also write a relationship of who's battled who, as well as father and brother, we can also do where someone lives, or if someone's a pet, and so on. And finally, we can actually add items to our graph. So this is how you would add some items into a graph. So for example, here we are adding Saturn, we are saying this is a Titan, we are giving it the property name of Saturn and we are giving an age of 10,000 and so on. And we do this for all these other items as well. Okay. So there we go, we are defining the items and we are defining the relationships between the items, or in other words, the edges between the nodes. And finally, we can have a table of what this looks like as well. So here we can see this in table format. But what is more interesting is the graph view. So this is essentially what our information looks like once it has been graphed out with nodes and edges. So the edges symbolize the relationship. So if you have a deeper look at this, we can actually click on these, and it will give us more information. So for example, this is a monster of Hydra, you will see the name it has as Hydra, you also see as the labor monster, and by its node, you will see that it's battled the monster service. Okay, so there we go. This is a great example of how graphs can really illustrate information and an amazing way. Now, this has been a lot shorter than the other tutorials. This is because I just wanted to show you how you can work with graph databases, it will involve learning the Gremlin language, but I think this is a good place to start in order to get your head around it. So I'm going to leave this information to you, I'm going to put the link in the description. And please do have a go at getting this up yourselves and having a play around with it as well. So if we want to add one more thing into our database, we can do it right here. And just don't forget to run it. So now because there isn't much of an exercise here, I'm just going to give you a pop quiz. When working with graphs, what would these be called. So these right here that I'm putting out this little red guy right here, these monsters, and this god. These will be called nodes. And what connects the nodes? That's right edges. So once again, these are the edges. And if we actually gravitate over them in this UI, it will give us the relationship between each note. Okay, so as we can see here, we have a little house, the location is the sky. And then this is where Jupiter lives because he loves the fresh breezes. Wonderful. Okay, so I think we are done with looking at graphs to power this down, I'm just going to run a command, it's going to be Docker compose down, and just hit enter. Great. So that is all four of the database types. I think we're now ready to move on with some projects. Now that we have covered the four main database types, I want to quickly talk to you about the multi bottle type. In this course, let's actually recap what we've done. Well, we created a database right and in it, we stored the key value pairs as for the first tutorial, after that we stored Jason document in Astra DB as per the document type tutorial. We then store data in tables as per the tabular tutorial, section two. And finally, we stored graph data. So that's a variety of different data models, all stored in one place by the graph one. All of this is possible because Astra DB is actually a multi model, no SQL database, you can use the same database to store a variety of data models. What is cool about this is that you also only need to learn and maintain one database which makes your job easier. Learn one database and use it to solve many different problems. Okay, wonderful. Now, hopefully through the explanations, examples, and exercises you are now feeling a lot more confident is not only understanding the different types of no SQL database types, but also how to use them. If not, don't worry, I have two short term real life projects that we're going to build in order to show you how you would interact with your databases when building JavaScript projects. By using a data API gateway like Stargate IO, Cassandra and Astra D view, developers can opt to use a Graph QL rest or schemaless JSON document API as an alternative to C QL. Let's do it. Okay, and let's get to it. In this project, I'm gonna be showing you how to use the document type as well as the document API. In order to create up first project. This project is going to be a app which will show you all your favorite burger restaurants. Okay, so let's get to it. I've actually started with a fresh board. So you will notice there are no key spaces, and we're going to have to go ahead and create our database again. So I'm just going to go here, and let's call our database project work and our keyspace Bogguss. And then once again, I'm just going to have to create the area that I'm in and create a database. Wonderful. So you will see my database is being created and you will see the status is pending and I'm just going to wait for that to be active so that I can go ahead and start using it. And wonderful, the status is now active, let's go ahead and use our database. So to do this, I'm just going to double click in here, and you will see the key space name of bagus. Now, let's get to adding some data. I'm going to do this thanks to the document API as stated. So first off, we need to create a token. So I'm just going to click in here. And the role I'm going to choose is admin user. And I'm just going to create a token. Once again, please make sure to keep this token safe, I would strongly recommend saving it somewhere useful. Okay. So once we have that, let's go back to this documentation right here. Let's go ahead and launch the Swagger UI. So I'm just going to go ahead and click that. And these should populate in front of you. So we have a lot of options here. And a lot of endpoints. If you remember from the tutorial, the one I need first is this one right? Here, we need to create a collection in order to store our data. So I'm just going to go ahead and click that and click Try it out. Once again, I'm just going to paste the Cassandra token in here so that we can essentially communicate with the database. And then let's go ahead and choose the namespace. Or in other words, the key space, we want to create our collection in as we have just created it, this is fresh in my mind. And I know that the keyspace name is bogus. Wonderful. And in here, we just have to pass through an object that has the name. And then whatever we want to call our collection. So I'm going to call this burger info. Just like so. And I'm just gonna click Execute. And great, we get a 201 code, we've made a request to this URL with our new authorization token. And the status code we got back was 201. Or in other words, let's have a look at the status docs again. Or in other words, to have one for created. Great. So now that we have created our collection, what's the next thing we need to do, the next thing we need to do is add some documents into the collection. So I'm going to go ahead and do it by selecting this one right here. It is a post request to this URL. So once again, I'm going to choose to try it out. I'm going to paste in my Cassandra token, the namespace or the key space ID that we want to communicate with is called burgers. The collection ID we just created is called burger info. And then the body is essentially the document that we want to put into our burger info. So I'm going to choose my document to look like this. I'm going to give each restaurant a name. So for example, Bob's Burgers. So that is a string I've chosen to give it the string of Bob's Burgers. I'm also going to give it a description and I'm going to say tasty burgers from a fictional character from TV, so we've got the name, we've got description, we can also have ingredients and we can do this if we wish as an array. So in here I'm going to put a patty to beef patty. I'm also going to put tomato let's also put some cucumber, some lettuce and some cheese. Okay, so those are my ingredients. I don't only have to put strings in here. I can also put an array of strings if I wish. Okay. And one last thing that I want to show you is okay, we can also have Boolean I can have visited, and I can have true. And then I can also visited have objects within objects. So if I put location, like so, as a property, I can have an object as a value. So that is also an option. Let's go ahead and do that, I'm just going to open up my objects. And in here, I can have so location, address. And then have that to be us string if I wish. So 45, lambda lambda. Drive, I can also have a, let's do zip code, which is an integer. So I'm going to make this up. And then I can also have the web address. So this is just going to be WW do W dot Bob's burgers.com. Okay, just like that. So we have a string here, we have a string here we have an array of strings, we have a Boolean, we also have an object, which has an address, a zip code as an integer, and a web address as a string. Now let's have a look and see if this is working. We could also give it a unique ID, we don't want it to count from zero. So perhaps let's go ahead and do that. I'm just going to go ahead and maybe let's start from 340. Why not? Okay, so now let's execute this. And great. Our first document has been created. And we also get a document ID that has been assigned to this object right here. So we have one, let's go ahead and add another. So I can just do so from here. Let's go ID 341. This time, let's go Matilda's. And Matthews, man hot turn Burger Joint. And then let's change this up. They have a tofu patty. Tomatoes, let's have a pickle. So pickles. Let's also have some letters. And then we can have Bri visited I'm going to put as false. And the location let's change this up. So I'm just going to put in a random location. Let's put Denver Avenue SIC code once again, I'm just going to make this up. And then let's put and progress and just click Execute. Great. So we have two documents in our Bulga info collection. Let's just add two more. So I'm just going to change the ID again. And then let's have gertrudes place hipster and gout in the city as the description and I'm going to have a beef patty. Let's have perhaps something else here so called Slow pickles, lettuce and there's cheeseless cheddar. This is it I'm going to have as truth and the location. Let's have one or three darling turn. Drive. Once again, just make up the zip code. Go through its place.com and just click Execute. Let's go ahead and just add one more. So there we go. And then let's have fancy burgers. A new location for Burger snobs. Some beef patty? Let's also have a onion ring in this one. Some pickles some letters. And let's just have some generic cheese visited, I'm going to put out false location, I'm going to put one, Walter Street. Make this up. And have and see progress.com and click Execute. Great. So now we have four bugs in here. But let's just double check this has worked. So to get all of our burgers back, I'm going to search documents in a collection. So I'm just going to go here, this will be a get request, as I'm getting the data, I'm just going to paste in my token right here, I'm going to look in burgers. That is the I quote my keyspace. The collection ID is called burger info. And then I'm going to say that, I'm going to have a max of 20, come back, and I'm just going to click Execute. And there we go, we can see all four of our Bogguss coming back to us. Great. So that is exactly the data that we need. Now let's get to using this in a project. So essentially, what I want to do is build a project in which I'm going to be making a request to this URL right here and passing through my authorization token. So let's do it. I'm just going to go ahead and open up WebStorm. So I'm going to go my WebStorm project. And I'm going to say this is a React project. So let's call this Barger app, just like so I'm going to use the Create react app command in order to build out a React project for me all configured so we can go. So I'm just going to click Create. And as you can see, that command has sprung into action. And I'm essentially just downloading all the dependencies, fetching all the dependencies and packages that I need in order to get the boilerplate for my react projects. Of course, if you're not using WebStorm, please go ahead and get to this point as well. All you need to do is create a project it will directory using the command MPX create react up. Correct. So now that we have that, let's get to it. So as you can see here, the MPX create react app has essentially populated all this for me with the following packages and ran these following scripts. Okay, so these are the dependencies that have been installed. And these are the files have come with create react app. So if I actually run this, I'm just going to go ahead and click npm start, like so this is essentially what should show up on localhost 3000. Okay. So that is something that you should be seeing right now, if I go ahead and actually delete all these files, so I'm actually going to go ahead and just do some deleting. So here is our app. This is essentially the spinner that we saw. So you will see here the spinner is this right here. I'm going to go ahead and delete all of this like so. If I actually just go Hello, I'm going to show you how this looks. Okay, as you can see that is working. So that is updating. So I'm just going to delete this for now, I don't need a logo, so I'm actually going to get rid of that. I don't like to semicolon. So I'm just going to delete that. And I like to use functional expressions. So I'm just changing this as this is my preference, but you are free to keep it as as you wish. So there we go. We don't need the logo. So I'm just going to go ahead and delete that from this project. Don't need the report by tools. So I'm going to delete that. Delete anyway, let's delete the tests as well as we're not going to be writing tests for this project. And let's delete this test file. Okay, great. I don't also need I'm actually going to delete the CSS file as I'm going to be doing all my CSS in this index. CSS file. So I'm going to delete this I'm just going to put all my styling in one file for this Project. So there we go, there's our app js file. And if we look in here, we don't need this as we've just deleted it. We don't need this as that is now non existent. And once again, I'm just going to get rid of the semicolons. Like, so. Okay, wonderful. Let's just check, we didn't break anything. And this is looking good. It's good, my console locked up, too. Okay, so now that we have a blank slate, let's get to actually getting our data. So to do this, I'm going to have to create a little mini backend. So just in the root of my project, so on the same level as Git ignore, I'm going to create a new file, just a new file like this, and I'm going to call it index j, s. Okay. So there we go. This is essentially going to be my mini backhand in which I'm going to build a backend using Express. So first things, first, let's decide what port we want our backend to run on, I'm going to say that I want my port to run on 80,000 8000. Sorry. And we're going to have to install a few dependencies for this, one of them will be Express. So we're going to use Express for this project. And use require Express. So I'm just going to get up my terminal and install Express like so I'm also going to need cause Morgane node fetch so we can do fetching in the backend, and dot EMV for storing secret variables. Okay, so please go ahead and just install these dependencies, and I'll talk you through them as we use them. Okay, so I'm just going to leave that to install. And let's go ahead and just actually use them in the backend of the project. So require package cause. And then const. Morgan equals require Morgan, Morgan is actually a package that we're going to use in order to, I'm going to show you what it looks like. So I'm just going to go, Morgan is essentially going to help us debug the backend better and make everything a little bit more readable. So this is the package, if you want to have more of a look. It's essentially a little logger, that will give us more information when we use it. And once we do use it in our project. So once we do essentially do this, so we're using the package or storing it as Morgan we've done the same, we then need to pass tiny into Morgan. Okay. So this is essentially what is going to let us debug better. So as you can see, I've got the package, and I'm storing it under the constant Morgan. And I'm just going to use Morgan and pass through tiny so we can use the logger better. Great. So we've got Morgan, the next thing I need is a package called node fetch. And this essentially works sort of similar to the Fetch API, and will allow me to make fetch requests on the so just like that, that's how I'm going to use Fetch. Just to be sure that everyone is using the same packages, please be sure to be using these packages that I have right here, there could have been updates. So to prevent any issues, just make sure that these other ones you are using, or if you're in doubt, please feel free to check out my GitHub project that I will share with you in the description of this video below. And finally, we also need the.in v to.in. The package will allow us to read secrets from the back as well. And this is how you would initiate it. Okay. So all I'm doing is actually getting this from the documentation. I'm doing this from memory as I've used these so many times. But if we search here here we go. As you will see, all I'm doing is taking this and using it in my project in order to use the.nv package. Whoops, please spell that correctly dot CSV. Okay, great. So this is looking good. Now let's initialize Express. So the package that I have just imported and stored as Express, I'm now going to initialize like so. So now if I use up like this, I can use Morgan tiny in my back I can also use course, this will essentially stop me from having any cause issues, I will show you what I mean by this when we get to building our app a little bit further. And then I can also use Express, Jason. Okay. And this will essentially allow me to read the Jason in a way that I can use it in the backend. Once again, I will show you what happens when I don't use this. Okay, so just make sure to have all of these, like so and all this boilerplate done, so we can start coding. Okay, so please pause here, make a note of this, I'll make it a little bit bigger, so you can see everything a little bit clearer. Once again, things to remember are, please do make sure index js files in the root of your project. Okay, so on the same level as package, Jason, and then this is the boilerplate setup that you need in order to get going with our backend. So the first thing I'm going to do is get all the restaurant data. Okay, that's the first thing you can do. And I'm going to show you how. So to do this, and once again, you can use app like so. So app is essentially what we saved express as initialized expressed as, and now I'm not going to use use, I'm going to use get. And what I'm going to pass through into here is an endpoint that I'm going to choose. Okay, I'm going to choose this by myself. I want to say that if I visit localhost 8000, which is going to open this up in a new tab, if I visit localhost 8000, forward slash burgers, I essentially want the burger data to show up. Okay, so that's what I'm writing here. By putting forward slash burgers, I'm deciding that this is where I want my data to populate. Okay, great. So that is the first thing I'm going to do. Before we get going actually, let's listen out to see if the server's working. So this I would do it once again, if you use up this, I'm going to use listen. So not to use and not get, I'm going to use listen, I'm going to listen out to port 8000. And it's all working, I'm just going to console log out. Server is running on port, and then whatever the port number is. Okay, so this is looking good. Let's also write a script for this because we don't have at the moment. So I'm just going to go in here and start front end. So I'm going to keep that script, but I'm going to say stop front end needs to be written in order to start our app. So our front end, and I'm going to add a new script. So this time, if I start backend, like so then I just want to run the backend. So that's the command to do so. Okay, great. So let's go ahead, and I'm going to stop this from running. I'm going to change the script to start front end and run it. Okay, so the front end should have started. And now I'm going to open up a new tab. Okay, there we go. So that's just running. Let's go back to our project. And now I'm going to open up a new tab. So new tab in our terminal. And this time, I'm just going to run this command that I have written. So NPM. Run, start back end. Okay, great. And I'm just going to comment this out for now. comment this out for now because we are not using it. And there we go. Okay, server is running on port 8000. So this is looking good. Obviously, at the moment, we don't have anything coming back. So I'm just going to continue with this. So if we visit this endpoint, what do we want to do? Well, we want to fetch the data. So for this, I am actually just going to don't have a request or a response. Let's just have it in here for now. And we might change that later. And then Okay, actually, let's just get rid of it. So we'll just have a function a callback to be precise with passing through a callback. And then we need to essentially fetch data from the URL. So if I just save this as URL for now and make this a little bit smaller, we essentially want to fetch data from this URL right here. So I'm just going to copy that, I'm going to paste it as a string, like so. Okay, so that's all I have done for now. Okay, we will be tightening this up. But this essentially is what this looks like at the moment. So there's a URL, now I need to make a get this is a get request. So let's go ahead and do that. So now it's time to use Fetch. So fetch takes a URL, okay, which is essentially this. And we're also going to have to pass through our Cassandra token Ks, or our authorization token. So I'm going to do this along with options. So let's define our options. So const options like so. And in here, we know that the method is a get method, okay. And we also need to pass through some headers. So the headers that we need to pass through, we need to accept this like so as a string. And we also need to pass through the X Cassandra token. Okay, so we need to pass through essentially this, just like we are passing it through. Okay, you will see this is part of the header. Okay. So essentially what is happening behind the scenes here, we are now coding out. So I'm just going to once again as a string posts, my token. Okay. So now when we make a fetch, let's just uncomment this out. Now, when I fetch I am passing through this year, well, we are fetching data from this URL, it is a get request. And we are using this in order to pass through our Cassandra token. Okay, great. So we are making a fetch, and this is going to return a promise. So I then need to chain it with the then keyword. And the response is going to be the response. Jason. And this is also actually going to return a promise. So we need to chain it again. And this time, I just want to get the Jason Okay, so great. Now we do actually need to pass through a request and response. So let's just do that now. Okay, so whatever's coming back to us, we need to view as JSON and then let's catch any errors. So I'm just going to catch the errors by console logging out any errors that will turn so we can see. Just like so. Okay, so there we have it. There's a lot of tidying up to do. But let's first make sure that this works. Just make sure that is in the string itself. Cool. So let's give it a whirl. Now if I visit localhost 8000, forward slash burgers, this is the endpoint that I have chosen. Tada, you will see all my four buggers show up. You will see each object has its own document ID as well. Great. If you're not seeing it in this format, it could be because you don't have a Jason view extension added. This essentially will make your your JSON much more readable. Okay, so if you don't have that, please go ahead and add the extension. Now. This is what it should look like. Okay, wonderful. So we have our data coming through. Now let's get it into the front end. But first, I'm just going to tidy this up real quick. So we don't need this anymore. Okay, keep that as it is the URL. So essentially what we are doing is Passing through the key space, which is burgers and passing through the collection name, okay, so you could save it as separate things and pass it through. So for example, I could say key space as the name, focus, and then pass it through into here with this syntax, like so. So what's gonna go barbers and then make sure that these are backticks. So there we go. So that is an option to if you want to make things I'm sorry, that should be key. So what do we save this as key space, key space. So that is an option if you want to make this more readable, or you can and this is what I'm going to choose to do. Because we are not going to be changing this is pretty much going to stay as it is, I'm just going to get the whole URL just like so. And I'm going to save this as a secret. So I'm just going to go in here. And once again, on the same level, I'm going to create a new file, I'm going to call it dot n fi. Okay. And now I'm going to save this in here as endpoint. So just like so. And I'm just going to paste it in here, just like that. So there we go. And now to access this right here, I'm going to use process NV and put, okay, so this wouldn't work if we didn't have this package and didn't use it just like so. And now I think we have to rerun this. Let's just check that out. Okay, now that seems to be working as it is. Great. So we've saved our URL as a secret back here. One other thing that I'm going to save is my Astra token. Okay, so there we have it. And once again, I'm just going to save all of this is going to grab that as it is, and use process. EMV. And then whatever we call it in our Astra dot EMV file is what we need to call it here. So let's say that and I'm just going to paste that in here like so. Okay. Great. And that seems to be working just fine. Okay, so we've cleaned this up a little bit, got a URL, we're passing through the URL and the options into fetch. And great, one thing we can do is write some middleware. So if I write function not found, and we post you the request the response and next. And then in here, if we get a four, four status, so let's go back to our status dogs. Okay, so you will see that for four means not found. So if we get a four of four, well, then I'm going to get a new error, the error is going to say, not found, so we're just making debugging a bit easier with this, we're going to get the message that says not found, okay, so that is what we are going to do. And then if it's none of these, we move to the next function, which is just an error handler in general, and it's going to be less specific error. And law. We're gonna pass through the error to this error right here. And then request and response. And this time, if the response if the status code is whatever the status codes, it's, so wherever it comes back as or 500. So any error or sorry, any status code or 500, then I want to send a message. That is, whatever comes with that status code. Okay, so there's two ways of doing it. So I'm just going to show you what this means. Okay, so now let's get to using it. So once again, I need to right up use and I'm going to use the function not found and I'm also gonna pass through the function error handler, just like so. Okay, so what I've written means that if I say misspelled this URL, if I wrote burgers like that, I get the message, not found, I get the error message, not fat. However, if I didn't have this, so I'm just gonna come on out, and I go to here. Oops, actually would have this. See, it just says cannot get burgers, it doesn't really tell me why it doesn't give me enough information. However, if it's not found, so for for iMessage, telling it to show me an error that says not found, okay. So that is how we do that. And then any other error, we get a different error message. So we essentially just get the error message that goes with these status codes. But this way, we can be more specific, I can go pay, you are in the wrong place, buddy. Hey, we're on their own pace, buddy. Okay, so cool. It's gonna pull it back to something more general. Okay, so we are guessing all of our baggage data. Now let's get to using this in the front end of our project. So once again, these are all the packages that I have used, or the dependencies I've used, just make sure that you're using the same versions. Okay, great. Now, let's carry on. So essentially, for my front end, so we can shut down the backend. Now, in my front end, I essentially want to get all the data from this URL, so we can use it. So let's go ahead and do that. To do this, I'm actually going to import a nother package. So I'm just going to get up my terminal. And I'm going to install the package Axios. Okay, this package is essentially going to help you make the requests and fetch the data. So let's go ahead and do it, I'm going to write a function right in here. So a function to get the data and we're just going to call it constipation data, like so. So this is a functional expression. And this is actually going to be an async function. Now, to fetch the data, I'm going to use Axios. So let's import Axios, import Axios from Axios. Once again, this is the package that I am using Axios. So import Axios from Axios. And now I'm going to use Axios. And we're going to make a GET request to get the URL, this URL right here, because Okay, so because our backend is running, that should work. Of course, if our back end stops running, that we will not be able to get to this data. And this, we need to use await as that comes back with a promise. And let's save this as broker data, just like so. So they should get the data. And now I'm actually going to save this. So I'm going to use use effect to const. Burgers, set burgers, if you haven't used US state sorry, use state is the one that we're going to use. And we're going to use this to set the state in our app. So of course we have to import it. So I'm going to import that just above here. Import. Use state. We're also going to use use effect I might as well just import that too. We can short spell it correctly. From react, okay, so there we go. So essentially, if I now use set burgers, so at the moment, our state for burgers is now but if I use set burgers, I can set boggers to whatever I wish and I want to set it to the ogre data, just like so. Okay, so let's check this out. Let's see if this is working. So what I now need to do is going to use use effect for this. And I'm going to pass through a callback function that will essentially fetch my data, just like sir. And I was going to pass her an empty array, so that this doesn't keep on fetching over and over again. So let's go ahead and do that. Let's see if that has worked. I'm going to console log bogus. And see what happens. So let's go back to our front end. So localhost 3000. Just inspect the page, a console, log out. And there we go. So this is what burgers looks like. Now we actually just want the data. So we're going to go into the burger data, data. And there we have our four burger objects. Great. So I'm just going to go ahead and do that. So burger data, data. Data. Let's see what that looks like now. Okay, great. So there we have it, we actually have an object of four objects. Cool. So this is looking good. There you go. As you can see, there they are with their ingredients, and occasions and so on, I'd actually like to make an array out of this, so it's easier to work with. So I'm going to show you how to do that. So just here as well, I'm going to change this into an array. Let's actually just save this as data this time. And I'm going to get the burger data data. And for each one I'm going to, so let's get object keys for it. So I'm going to make some object keys for it. Because at the moment, it doesn't have anything to sort of differentiate each of the objects. And I'm going to map. So each burger object I'm going to turn into I'm going to grab it from the burger data. Data, Data. And I'm going to turn it into put it into Okay, so now whatever comes back, I've said that as data, and that is what I'm going to say, Save As my buggers. And there we go. So we now have an array of four objects, each with an object key. Wonderful. I wonder if I do need these object keys, or if that will just work without it? No, we do need we need the object keys. Okay, as does what we are essentially working off. So there we go. Wonderful. So we have our four burgers. Now let's get to actually displaying them in the browser UI. So let's do it. So for this in here, I'm actually just gonna create a data go into my favorite burgers, the styling for this is going to be extremely minimal. As we have a lot to go through. I don't want this to be all about styling, I want you to actually learn how to retrieve data into an actual project. Okay, so I'm just going to do this, I'm going to create a div and this is going to be the bag of feed, maybe give it a class of burger, fuge. Just like so burger feed. And in here, I'm just going to create a card and this is going to take our burger data. So let's actually map over each card. Let's actually create a chord first. So in here, I'm actually going to create a folder or directory called components. So new directory, and it's called components. And then in here, I'm going to create a new file and score card J S, just like so. And then let's create our card. So const card, and then I'm going to return at the moment, I'm just going to return two types like that. And I'm going to use export default card not first to use this card. Okay and other files. So now in here, I'm going to import the card input card from make sure to get the path correct. So in here, opponents Right, yeah, okay. Then, called J S. Cool. We actually don't need that. Okay, so this is fine. So now we've imported the card. And at the moment, we aren't passing anything through into the card. However, I can actually start this up. So let's go ahead and I'm just going to give this a class name just so you can see what's going on a little bit file. And I'm going to say card. And now in here in my style sheet, anything with a class of card, I'm just going to give a give a height for now of 200 pixels. a width of, let's say, at view width, and a background color. Of what color should we go cornflower blue border, radius 40 pixels. Okay, so at the moment, I've just put in a card. So there we go. That is, that is my card. Now if I map all my data onto this, okay, onto each card, it will actually produce as many cards as I need. In this case, it's going to be four. So let's go ahead and do that, I'm just going to pass through some props into this card. So I'm going to pass through Well, first off, maybe let's just map. So let's get our burgers map. We're going to map each burger, and I'm just going to get that and card and I'm going to pass through the burger data. Okay, so this is looking good. As always, we should probably have a key with this. Let's just see how this is looking. So there we go, we've created four cards, as we have for burgers, let's actually add the key prop as well. So I can use the key just use the burger ID as we do have one. So let's go ahead and do that. Okay, so we are creating the burgers, let's maybe give each packet some padding as well. So margin, even margin pixels, just so it's a bit more space out and on the card itself, or passing through the burger. So I'm going to D structure the burger like so the wise we don't have to get the props. So I'm just destructuring the burger. And then it's me, this may be a little bigger. I'm going to sit in here. Grab that at each of these. So let's give them an h2 tag. Let's pass through the burgers name. See what that looks like. So there you go, you will see the burger name is being shown just right here. What else can we pass through, we can pass through the burger description. Maybe let's make this a p tag. So there we go. And then we can also pass through as much information as we wish. So maybe let's put in a another P tag and call this burger. What did we have? Location? And then burger location? Address. Okay key location, web. I think that was one of them. Or was it just website? Website. You can always check what it was. Go and hear what the description, got the name description we've got visited. We have location is web address web zip code, probably don't really want the zip code. So I'm just going to keep it as Web. Okay, so there we go. And then we could also hide it if we've been there or you know, which would mean we'd only see the ones we haven't but that is completely up to you. Okay, in fact I'm going to do this so if Berger visited is true. Then we want to hand back. I don't know what we can return back to sort of freestyling here, a div that has the class name. visited. Otherwise, we could just go if it's not visited, there's probably neater ways to do this, I am just freestyling here at the moment, as I said, when we can do not visited, and it will show based, or show this div if we visited it, and this one if we haven't visited, so then I can go visited and just sign up. And if it's visited, I can just give it green, or red actually, let's make it red height 30 pixels with 30 pixels. Border. Radius 15 pixels, background color, red as we don't want to see it and if it's not visited, we'll give it a green. Okay, and let's make this Okay, so there we go, we know that this means we visited and the green means we have not visited these ones yet. You can replace this with icons, I just wanted to show you one way of doing that. Wonderful. Okay, so this is how you would get data, usually document a p i, and also using the Document Type. Okay, I'm just going to start this up a tiny little bit before moving on paddings give the study pixels. Let's make all the font white font color. White, of course, please feel free to you know, take this project really improve on it go crazy on the styling because that part, my friends is up to you. This is not a styling course. Whoops, cannot Okay, so we just have to what is happening here? It's gonna come out from now. Okay, so it's not picking stuff up in here. This is because sometimes the burger data might not come back fast enough. So I'm just going to put that right here. Okay, good. Okay, so it might not read it first time. So the first time this renders the burger data might not exist, which is why we put this question mark here. And when it re renders then that will show these cuts. Okay, great. So this is looking a lot better. Great, and then I'm just going to override the font if there's an h1 tag and give it the font. color. Black. Cool. And let's just go back here. That back. Wonderful. And one last thing I would do on that is center everything. So on the body itself, I'm going to do display flex justify content, center text align, center. Great. So wonderful. I hope you've learned a lot. Once again, this code will be available to you in the description. If you're watching this in the future. Some of these packages might have changed, just make sure to use these same packages for this project. Wonderful. Thanks for watching and onto the next project. In this project, we're going to learn how to use the Graph QL API in order to build out a hotel app. Okay, so once again, I'm going to start completely from scratch in order to build out our react up. First things first, I'm going to create a new database. So hopefully you are familiar with these steps already, if you have been following with this tutorial. So what should we call our database this time, let's go ahead and call it whatever we wish. So I'm just going to call it project work again. Just like so. And it's cool are keyspace name hotels. The next thing I'm going to do is just select where I am at the moment. So I'm going to go ahead and let's pick Europe and West Europe and just create a database. Okay, so there we go, there is our database it is currently being created, you will see the status as pending. And we're just going to essentially wait until that is active in order to start working with it. And there we go. So let's go ahead and click into here. And then here we will see our keyspace. Now, the first thing we're going to do is just head over to the connect tab in order to start working with our Graph QL API. We're going to be using this documentation right here to help us. So the first thing that we need to do is just create a new application token. So I'm just going to click here to do that. And once again, I'm going to select the role I want. I'm going to choose admin. However, there are many others with different mutability levels. And I'm just going to create a token. Once again, I'm just going to copy this right here and keep it somewhere safe. Now, once we have done that, I'm just going to close that down. And I'm going to launch the Graph QL playground by clicking right here. So there we have it, there's our playground and a row to communicate with our playground, we need to just put the token we have just created in the HTTP headers, just like so. So now we can communicate with our database. Let's go ahead and create our first table. So I can use the docs to help me with this. So this is the mutation I'm going to be using. Once again, if you watch the tutorials, you will know that we have queries and mutations to our disposal queries will essentially find data for us. And mutations can create, delete and update data for us. So we need to create a table. So I'm just going to get rid of this. And this is a mutation. And the mutation that I want is create a table. Now if we look under here, you will see that to create a table I need to the bank indicates that this is necessary, I need a key space name. So let's go ahead and pass that through a key space name, I'm going to put this on a new line. And the key space name has to be a string. So I know that my key space name is called hotels, okay, because that is the key space that we named it right here. So if I go back to my databases, hotels is the key space name. And then the table name, this is something that I'm going to assign right here, I'm just going to call it hotel data. So I have just chosen to assign this to the table name right. Now, the other necessary thing that we need is a partition keys as an array. So let's go ahead and add that partition keys as an array, and I want my partition key. So if we just click on here, I need to give it a name and a type. So I'm going to go ahead and do that, I need to give it a name, which is a string. So I'm going to choose to sort all my hotels by a ID. And then I also need the type. And the type that I want this to be is actually going to be basic text. As I don't want this to be an integer, I want the ID to take letters and numbers. Okay, so that is one column that we have made. So far the partition keys. If I want to add more columns, however, I could do so thanks to values. So once again, values is an array. So I'm just going to my values. And if this is one column, this is actually the column we are going to filter by and search by. And all these additional ones are going to come back if we search for this column. So let's add another column. Again, we need to have a name for this, which is going to be the hotel name and the type for this. I know that I want this to be text. And if we want to add more columns, so at the moment, we have one column, a second column, and I'm going to have three columns in here. So this is actually going to have the rating. So I'm going to call this rating. And I'm going to give this an integer. Value. Okay, so there we go. So now if we run this mutation, great, we have created our table. Wonderful. So now that we have created our table, let's get to adding data into our table. So all I'm going to do is navigate into my key space. So as you can see here, datasets is actually generated the URL for me, I need to go into the hotels. So I'm just going to go up here. And instead of Graph QL schema, I'm just going to go forward slash hotels to make sure that I'm in the correct key space. Okay, so there we go. And now, instead of creating a table, if I look at the docs, they will be changed, I need to insert hotel data. So now this is the mutation I need. Once again, it's a mutation as we are going to be inserting data. So let's get up mutation. And this time, I need to use Insert hotel data, just like sir. And what do we need to put in here, in order for this to work? Well, I need to put through a value, okay, and that is necessary that has got a bang there. So we have to do it, I'm going to give it a value. And this time, I'm just gonna give it the ID, I'm going to make up an ID. I'm also going to give it a name, so the name of the hotel, let's say Abby's hotel, and a rating, which is an integer, so I'm going to give it a four out of five. So let's just actually put this on different lines of just like so. And let's just return back the value of have a name to check this has worked and click Run. So great, we have just inserted some data into our table. Okay, let's go ahead and just insert some more. So I'm just going to change these around a little bit. This time, I'm going to call this set Tories give it a rating five, there we go. That has worked. Let's give me another it up. This time, it's gonna go motel, Mays rating of three. And then one more, and this one is going to be awesome. Hotel and give it a rating of five. Great. So now we know we have just added four hotels into our database. But how can we actually see this? Well, for this, we need a query. So to query this, I would simply I can go here and have a look, if I need the queries, I need his hotel data. So I'm just going to write a hotel data like so. And because we are not filtering out by anything, I can just get the values and then choose whichever values I want to come back so I can get all of them, I can get the ID, the name and the rating. And just click that. Or I can just get the name and ID. So that will return back. Or I can just get the name, whatever you wish. So however you write that query is what will return back to you. I want everything. So I'm just going to do that. And there we go. So that is essentially the query that we need in order to get all of our data from our database. And we also need this Cassandra token as the HTTP header. And also this URL, as that is where essentially our data lips. So let's go ahead and do it. Let's start up our project now. So all I'm going to do is get my WebStorm up and just create a new project. Once again, this is going to be a React project. So I'm just going to use this and I'm going to call this hotel up just like so. And using MPX create react app. This should create a project for me with all the React configuration ready to go. So I'm just going to click sexer. And there we go. You will see my hotel app project right here and all the dependencies being installed ready for me to use. Of course you don't have to use WebStorm. If you're using another code editor or IDE that is absolutely fine to just make sure Get Up to this point where your project is installing all the dependencies ready to go. And great, we are ready to go. So the first thing that I'm going to do is actually just delete anything we don't need. So here are all the files that have been generated, as well as the package and all of its dependencies and scripts. So in here, I'm actually just going to get rid of the logo as we're not going to need this anymore. So just delete that. Anyway, I'm going to delete the report of vitals and setup tests. So once again, just delete that as we don't need it anyway. And then I'm going to delete the app CSS file, as I want all my styling to be in the index CSS file, and just delete the app, test J S and just delete that. Okay, so this is looking good. Just going to minimize that. And delete this as we don't have any more I'm going to delete the semi colons as I'm not a fan of semi colons. There we go, save that. And then in the app js file, I'm going to delete all of this as we don't need it anymore. And once again, get rid of the semi colons, and we don't need the logo as we don't have it. We don't have this file, either. Okay, so this is looking good. Now, if we run this, I'm just going to click this to run the start script. You should see the project show up here, we've got rid of all the styling, so you should just see a blank slate, like so. And let's get up our console log. Wonderful. So now that we have that, let's get to making some requests. So I'm just going to minimize that for now. In the previous project, we built a little mini backend using Express. However, this time, I'm just going to show you a different approach. And that is using Netlify serverless functions. So to do this, let's get off our terminal and let's install the Netlify command line interface. So we can use it to npm install. Net LIFFE phi CLI, and I'm going to install it globally. Okay, so that is what the juice for that is to install that locally and just let that run. Okay, so I'm going to leave that to do its thing, the next thing we're going to do is actually create our first serverless function. Okay, so when that is done, I'm just going to ask you to create a file in the root of your project. So make sure it's at the root of your project on the same level as the package, Jason is going to minimize that new. And the file is called net live by tunnel. Okay, and in here, I'm just going to give you some code to put in in order to build out the sub list functions. So this you can just copy, these are some commands that we're gonna have to put in here in order to build them out. functions here is essentially the whatever you call the directory you want to store your functions in. So let's go ahead and create that, I'm going to create that on the same level. So just make sure that's in the root of your project and call the directory functions just like you did here. Okay, so that is where we're going to store our functions or serverless functions. And then we just need one more. Command. Okay, so there we go. Make sure to write this exactly as I have written it in a Netlify TOML file in the root of your project. Great. So now that we have done that, I'm going to create my first function. So making sure you are in the functions directory, create a new JavaScript file, and call it whatever you want your function name to be. So I'm going to call this get hotels. And this is a JavaScript file, so that will add the J S extension. Now with any surplus function Netlify serverless function, this is the syntax that you need. So let's go ahead and write it. I'm going to have to write export handler This is an async function. Let's make this a little bit bigger. Nicholas who no And then we are going to have to essentially fetch some data. So just like we did before, so we're going to import another directory. So we're going to get node fetch, I'm just going to install it right now. API node, fetch, and let that install. Okay. So while that is installing, let's go ahead and use it in this file const, fetch equals require node fetch. Just like that. Now, as we know, with fetch, we pass through two things. And that is a URL and options that will have our HTTP header along with the authorization token. So let's go ahead and do that. So once again, let's write the URL. And we know that the URL, so let's go back to here is this right here, and this is where we're gonna make the requests to. See, I'm just going to paste that in here, like so. And then Let's also get our options. So const options, say this is const URL. And the options are going to have a method, which is a get request, and the headers, okay, the headers, which will consist of the content type. Content Type, and the X, Cassandra token, okay, so there we go, I'm just gonna make this the same, as we see here exe Cassandra token, and I'm just gonna grab that. So the whole thing and just put it in here, just like, so. It's gonna make it single quotes. Great. So we have our options. And then we also have our new R L, format this a little bit better. So URL options, I'm going to use Fetch. However, this time, we're actually going to save whatever comes back from fetch. So we know this promise, const response. So whatever that returns back, we're going to save as response this time. And this is not all we actually need to do. And because this time, we actually have a query to pass through, okay, so we do have a query to pass through. And that query is I'm just going to save up here. So I'm going to save as constant query. And I'm just going to use backticks for this. And I'm going to paste in my query. So let's go in here, this is essentially the query I want to make. So I'm just going to paste that in here like so, maybe formatted a little bit better. We need to pass that query through in with the options. Okay, so this is no longer a get request, as we are posting, we are sending this query. So make sure to change this to a POST method. And let's get to passing through the query into the body. So I'm going to pass through the query, but I need to pass it through JSON stringify and then pass through the query like so. Okay, great. So that is looking good. We are now passing through the query in with our options, so along with the Cassandra token, the method and then we are putting that into the fetch that we imported from node fetch. Great. Now we're going to use try and catch in order to do this. So this is the syntax, we'll try and catch we've got try and I'm going to catch any errors. So e4 errors. Okay, and to try to do this, we actually have to make sure this is all in the export handler. So let's just grab that and make sure that it is here. We are going to what essentially we're getting the response I'm going to call this was response body. So we could use this, but we also need the JSON from it. And this returns a promise. So I'm going to have to use await in front of it just like sir. Okay. And then if that comes back, then we're just going to return a status code of 200. Because that has worked. And then we are going to show in the browser, the response. So I'm going to use JSON, string five for this to work, I'm going to show the response body in the browser, and if it doesn't work, where we catch the errors, and we're just going to console log the errors, okay? We can also of course, return a status code to someone do return status code 500. And I'm just going to show the error in the actual browser too. So let's use Jason string phi and pass through if error. Okay, so this is looking good before we clean this up, let's just check that works. So to do this, I'm gonna go in here and I need to run the command Netlify. Net LIFFE pi, Dev. And that is do it's much okay. So there we go localhost 888. Let's inspect the page. And now if if we want to get that data, if we want to run this function, essentially, I need to go into functions and get hotels. Okay? Oops, make sure this is an s. So, I'm going to go forward slash.net. LIFFE fi, forward slash functions as the directory that we created and then get the Taos and wonderful. So now we are getting all of our data. And Wonderful. So is saying something's already running on port 3000. I thought I did shut this down. But I didn't cancel. Okay, so we need to stop that running. Make sure that stopped. Okay. Essentially, what is happening here is that localhost 888 is now our front end. Okay, so we don't want anything running on localhost 3000, because we want everything to be running on here. Okay. So that's what we want and to, and essentially, our front end, and our backend are now on this URL. So here we go to get our data. And here is our front end. Great. So I hope that makes sense. Once again, just make sure that Netlify Deb is running in order to get that to work. Wonderful. So once again, I'm just going to show you the package Jason, these other packages that I am using, if yours have changed, or if you're watching it's in the future, then please use these for the tutorial in order to get this code here to work. Okay, so there we go those other packages that you need, along with their versions. Wonderful. Now that we have our data, let's get to clean this up a bit. So just like we did before, I'm going to create a new file, a dot n v file in which we're going to store all our secrets. So once again, I'm just going to put the endpoint in here. And I'm also going to put in my Astra. So just like that, and then from here, I'm just going to get this URL to get the whole thing. Put it in here. And I'm also going to get my token, okay, so that we go, just like so doesn't need to be a string. You can just save it like that. Okay, and now this means I can use process EMV in order to get my Astra token. And I can also use it to get the URL, but now it's hidden. Okay. So now it's a bunch safer, and points. Great. And we have to actually inject these variables. otherwise this won't work. So I just inject the variables by running Netlify dev again. So just like Sir, okay, and you will see injected endpoint and injected Astra token. Okay. So there we go. Let's try that again. Only absolute URLs and point and point and point A misspelt endpoint. Okay, so once again, I need to re inject the tokens and nullify Dev. Wait for that to be run. And Wonderful. So now we have a URL or get back our data. As long as the backend is running, let's get to using it in the front end. So I'm done with this. For now let's have a look if this needs any cleaning up, so here we have all the code that is necessary, this will be available to you below. So please make sure to use it, you don't actually need to pass through an event for this. This is looking good. Okay, so there is all my code. Great. Now let's move on to the front end. So here is my front end. As you can see here, once again, I'm going to have to essentially fetch the data. So I'm just gonna do fetch data just like we did before, we're gonna make this an async function. Okay, let's change this to a function expression just because I prefer working in this way. And now let's actually fetch the data. So now this time, I am going to actually use Fetch. So the Fetch API going to await it as it's going to come back with a promise. And I'm just going to fetch this URL right here. So we're gonna copy that and paste it. And well, we don't need all of this, I can simply put forward slash Netlify functions get Hotel. So that is essentially the same thing. Okay, so we're getting the data from that. And then let's go ahead and save it as something. So I'm going to save it as just the response for now cost response. Great. So that's the line we need to write. Now, once we have whatever comes back from us. So the response need to get is Jason. However, this also returns a promise. So we need to use a weight. And let's say this as the response body this time. And we're going to have to actually save this into state. So I'm just going to import use state and also use effect as we're going to need it later. From react. Okay, awesome. So we've got the response body, let's actually save it to the state of the app. So let's use what should we have hotels, set hotels, and then use state? I'm going to start off with the state. No. Okay. So all this means is that at the moment, hotels is now and I can use set hotels to make hotels, whatever I wish. But at the moment, we're starting out with hotels being not so this gets passed on to that. And I can use this to also change that. So I'm going to use the set that tells to change hotels to the response body. Wonderful, I think let's check out if this has worked. So I'm going to now use use of fact. And then a callback function, you don't know about use effect, I would suggest doing some research on these hooks at the moment. So use effect, just like so I'm going to fetch the data, okay. And then I'm just going to put up an empty array, so it doesn't keep fetching that data over and over again. So I'm going to call that and now let's console log with health to see if this has worked and to see what's being returned back to us. So now, let's go back here, and just go to the front end. And there we go. We are getting the response body data, data, hotel data. So data, who told data values is what we need, and that is an array. So I'm just going to go back here and go response body data, hotel data values. Okay, in order for that to bring back just the array, and there we go. We have an array of four tells. Wonderful, let's carry on. So now that we have that and we have checked that that has worked, there's the whole code in its entirety. Please feel free to stop here and make a note of it or just catch up, press pause and if you What up, let's carry on. So just like we did before, I'm actually just going to map out all the hotels, I'm not going to create card component this time as you know how to do that. So I'm just going to grab the hotels if they exist. And I'm going to map so dot map. And for each hotel, well, I wanted to return a div. Let's give it a class name of a towel. And then in here, let's put an h1 tag that has the hotel name, a p tag that has the hotel, what are the other ones hotel name, then we have a hotel rating. So let's see how that looks. And there we go, we get all four of our hotels with a little rating, too. Now, let's get to setting this up a little bit. So here is my app, I'm just going to get my CSS file. Let's put everything in the body as justify content. Center, of course, we need to use display flex to initialize this. And align text, text align, apologies, text, align, center. Okay, so that is looking good. And anything with a class of hotel, I'm going to make sure that the background color is salmon. And border radius is 50%. Okay, so maybe that's a bit too much border radius, we can of course, change it as maybe make it just 10%. Or whatever, really, that you wish it is up to. Yeah. Great. So of course, please, again, feel free to go wild on the styling, I don't want to go too crazy on the styling. This is not what this is about. This is a tutorial to show you how to get data into a project. Okay, so I'm just going to put my hotels here, and we will let's make this an age. Tag, like so. Great. And maybe let's give it some padding from the top, let's give it 10 pixels. And from each side, I'm going to go 50 pixels to make it look really long. Okay, and then also margin. five pixels. Correct. Okay, so hopefully, you've learned a lot in how to get data, this time using Graph QL. And the Graph QL API, if you want to learn more about how to make more advanced requests. So in making the functions including stuff like pagination, I do suggest watch my Netflix clone in which we use Graph QL to do this, okay, so that is an option for you. Please try go ahead and watch that, if you wish, it is reviewed by an actual Netflix engineer. Once again, the code for this project will be available in the description below. And that's it. So to recap, during this video, cause we have learned what is no SQL, SQL versus no SQL and why you can't compare them types of no SQL databases. So document databases, key value databases, wide column stores or tabular databases, graph databases and talks about the multi model databases. We also talked about how to get data into projects with to real life examples, and also how to look at the document API and Graph QL API as we did this. So action packed course really. And if you're looking for ideas on where to go next, to really solidify your knowledge, I would recommend using the Document API and SDK to build your own Tinder app with me here, or using the Graph QL API to build a Netflix clone here, or even learn how to federate data from two database types with my Graph QL Federation crypto app right here. Thanks so much for watching and I will see you again soon.