hello there and welcome to your introduction to cobol no matter what brought you here we're glad to see you and hope that you enjoy all that went into creating these videos first things first what is cobalt well whenever there's an acronym i like to start there and cobalt is an acronym for common business oriented language that's a big tell right there right in the name this is a business language compared with other more general purpose languages cobol was designed around data processing specifically data processing with incredibly high accuracy extreme efficiency and ease of reading and writing cobol has indeed been around for over 60 years as of this recording and surprise surprise the fundamentals of business being able to process very large amounts of data accurately and efficiently continue to be important so all of the transactions that happen when you're using a credit card visiting a store or doing pretty much anything with a bank there's a good chance some cobalt code got executed somewhere in there in fact every day about three trillion dollars in finance gets handled by cobalt so let's just make sure we're clear here cobalt pretty much runs the world it has been kept up to date to support new requirements throughout the years and 1.5 billion lines of new code are written every year suffice to say learning this language will give you a very valuable set of skills in this course you're going to be working with enterprise cobol which is an implementation written specifically to run on ibm z mainframes the banks insurance agencies energy companies retail chains that depend on cobalt to run their extremely important transactions guess what a whole lot of them also depend on ibm z mainframes to ensure their applications can keep up with the demand 24x7 learning enterprise cobol says i want to work on the most important code running on the most important systems running the types of things that no exaggeration at all the world depends on that's a pretty bold statement and i have no problem at all saying it because it's the truth you might be thinking cobalt on the mainframe am i going to need punch cards and a tie to get through this well first of all no you'll be happy to know that we're going to be teaching all this with visual studio code which as of right now is the most popular editor used worldwide visual studio code or vs code for short supports something called language server protocol which simply put makes it able to support a very large number of languages and environments so the things you'd expect to be there like code completion workspace symbols hover text references and diagnostics can all be supported without it having to be specifically written into vs code itself it gains functionality through extensions which use the language server protocol or lsp we're going to use extensions for vs code that give us all the goodness for cobalt as well as allowing us to connect to a real live mainframe system so after you download and install vs code hop into the extensions marketplace and search for ibm z open editor and hit the install button while that's installing do the same for zoe explorer zowe that's the simple version of things for more detailed instructions on installing the extensions visit the book version for the full details and screenshots couple of basics once you're in you'll also notice these vertical lines very important for cobalt these are the margins those margins segment each line of cobalt code into its various parts which we'll get into later on just know that it's easier to see whether your text is starting right next to a line than it is to count empty spaces so lines good also if you hover your mouse over some fields a little popup box will appear showing you additional information just know that this will come in really handy when you really start hacking away at cobalt code later on and you may also notice that some words get displayed differently than others that's all part of syntax highlighting it just makes things a little bit easier to understand at a glance and this bar across the top that's the breadcrumb view it shows information about what line you're currently at click on any element in that breadcrumb trail and it will highlight the block of text for that element it'll also show you a little outline view of the code over here lastly down at the bottom of your screen there should be a panel with a problem section and if it's not there go up to view and select problems from the editor menu you can click on the problems it is found and it will jump right to those in the code it will find basic logical errors without you having to run or test your code it just knows about those problems ahead of time so you'll definitely want to fix those as they come up got all that i'd say you're ready to dive into some actual cobalt so let's go cobalt is an englishlike computer language it's that way by design meaning it's fairly easy to read understand and maintain compared with other programming languages you'll find that each line of code is pretty transparent about what it's trying to do that's often the first thing people notice about cobol that what it's trying to do is very easy to figure out and you don't have to spend a whole lot of time tracing through code to make sense of it all that's thanks in part to cobalt being standardized so the way that a cobalt implementation should be approached is all described in great detail in that standardization now cobol has gone through several revisions over the years so you do need to keep in mind which particular standard you're working with particularly when you're working with code outside of this course but it mostly comes down to the addition of a few new features better support and small tweaks to fix problems cobalt written specifically for the ibm z mainframe operating system zos is said to be enterprise cobol the code you'll see here in this course is all enterprise cobol and it all gets compiled and executed differently than cobalt you might be writing for other platforms but it is also able to take advantage of hardware and operating system features unavailable anywhere else so it still follows the current cobalt standardization but it's written with enterprise systems in mind let's take a look at some of the basic cobol syntax at a high level so you can get a better feel for the cobol standard right up front one of the key aspects of cobalt some languages use spaces some use tabs cobalt is column dependent meaning it looks at a line of code and expects certain things to be at certain positions in that line specifically it's looking in five key areas of a 72 character line and those look like this the first section columns one through six are the sequence number area sometimes these are blank other times we use them to provide context to a series of statements the next section is the indicator area and it's a multipurpose area if we're going to leave a comment an asterisk a star goes in here or if we're continuing a previous line it'll be a dash or a hyphen it can also be a d for a debugging line or a slash for source code listing formatting don't worry about all that just yet we'll show you how and why you'll use those later on just remember it's column seven and it's one character next we've got the a area which goes from columns eight to eleven in here you'll find divisions sections paragraphs level indicators and other elements that give cobalt programs their structure right next to it in columns 12 through 72 is the b area this is where you put the actual statements sentences and clauses the things that make a cobol program perform calculations and do stuff then last but not least the identification area running from column 73 to 80. well the compiler might consider at least because it actually ignores it so it doesn't consider it at all it's actually an area the programmer can use for any purpose so it's often just left blank now when you're writing in a programming language there are certain words we have to be careful of words like data end file if ready set until those are cobalt reserve words and when the cobalt compiler sees those words it thinks we're telling it to do something very specific so we shouldn't say ready unless we mean what the compiler thinks it means a full list of reserve words is available at the link in your guide in the next video we're going to talk about how all this fits together in the program structure let's talk structure koval has a hierarchy structure meaning that it's got things within other things that's part of what gives it its structure the biggest things in a cobalt program are divisions and within those divisions there are sections and within those sections you'll find paragraphs those paragraphs contain sentences and sentences have statements let's start at the statement and work our way back out a statement is a single directive usually starting with one of those reserved words we just talked about so something like add divide move compute those statements go into sentences just like a spoken sentence can reveal many pieces of information a cobalt sentence can contain one or more statements it's just a nice way of placing a bunch of statements together into a logical container so here is a sentence made up of statements and you can see that the end there is a period that period is an implicit scope terminator it says all the previous statements that have not yet ended are declared as finished you can also terminate a scope of a statement using what's known as an explicit scope terminator like if you started with an if statement and you end with an end if then you don't need to specify that you're done with a period either way works and you'll see both used throughout this course so that's sentences and what do sentences go into well generally paragraphs paragraphs are user defined written by you to give your program structure generally a paragraph represents a specific action made up of smaller steps so if it's something that might get called several times throughout your program like applying interest or prompting the user for a series of input that would go into a paragraph that way you can call that paragraph by its name from elsewhere in the program paragraphs go into sections and there are all sorts of sections they can have user defined or predefined names so they can be used to give your program structure or to make sure certain information is where it needs to be for things to run correctly and then there's divisions and there are four cobalt divisions and we can cover all those right now first is the identification division which is where you'd put the name of your program who wrote it when it was written how it should be used all that helpful information then there's the environment division there are two major sections here one lets you set the type of computer environment required to run your program and the other sets of the mapping between the files in your program and the files on the actual data sets so it's the link between your program and the system it's running on the data division sets up all the data that will be used within your program that includes files data from other programs what type of storage or memory you'll use while the program is running and what it will give up when the program ends then there's the procedure division this is where all those sections and paragraphs go so the instructions for how to take data in how to set up the variables performing math on them interacting with the user and all that kind of fun stuff that happens in the procedure division are you ready to see all those statements divisions sentences and paragraphs and actions i sure hope so because it's time for a lab basic cobol syntax in this lab you'll connect to an ibm z system check out a simple cobol hello world program and then submit the jcl to compile the program and view the output good luck and have fun in this section we're going to talk all about cobol variables i'm pretty sure every programming language in existence has variables of some sort and even basic algebra has the concept of having a letter represent a value like x equals 5. cobalt is really no different though it does put its own spin on some of the details which we'll cover here simply put a variable is a name chosen by the programmer to represent a value that name is referred to as a data name that data name can be anything as long as it's 30 characters or less doesn't contain any spaces is made up of only letters digits and or hashes and isn't a reserved word so some examples of good data names might be balance inventory one two three four five and north american sales in 2020final that's exactly 30 characters there will be no problem with any of those however if we wanted a data name of top five percent with a percent sign or phone numbers with a space in the middle those would not be good we also have to think about what type of variable we want because when we declare or create a variable we have to tell cobalt what it's going to be numeric just numbers alphabetic just letters or both alphanumeric we also have to tell just how many of those letters and or numbers we think we're going to be using and we do all this because cobalt is an extremely efficient programming language and part of what lets it be so efficient is knowing exactly what's going on with all of its data right from the beginning we set this up in the picture clause picture or pick for short sets the length and the data type of a programmer selected variable name so pic9 is a single numeric value where the length is 1. the 9 means numeric it doesn't mean it's a value of 9 or a length of 9 it just means here's a variable of numeric type and since we didn't specify a length we only get one it defaults to one so i don't know maybe we're programming an elevator in a building with nine floors we could use that to store what floor we're currently on could be handy for that and if we need more than one digit we can specify that within the parentheses like here pick nine parentheses four that says it's a numeric variable and there's four of them that might be a good place to store perhaps the year because obviously you would need four digits to represent a year like 2020 or 2021 or 55 45 or 1999 four digits for the year always pick a means we have a single alphabetic character and because we didn't specify length we only get one so i could use that to store my favorite letter z pick x eight gives us eight alphanumeric characters x means alphanumeric and with that many i could store a us license plate made up of up to eight letters and numbers now not all pick clauses are created equal so you need to know that the maximum length of a numeric picture clause is 18 while an alphabetic pick clause can be up to 255 and know that there are lots of other types of pick clauses we will dive into those as we need them for now just focus on those three numeric alphabetic and alphanumeric you can use picture clauses to represent symbols that appear in the value so for example pick nine parentheses four v nine what the heck does that mean well nine parentheses four means there's four digits then we've got a v which represents the decimal position the dot then two more nines so two more digits we can use this pick clause to represent 1425.82 that could be a radio frequency or a measurement of some sort we can also do something like this pick dollar sign 9 comma nine nine nine v nine nine that can be used to represent one thousand two hundred and thirty four dollars and fifty six cents the dollar sign and comma carry through and the v indicates the decimal area when we think of a variable we often think about something variable meaning it can change cobalt also has things called literals which contain data that will not change during the course of the program so i might use a literal to store something that i'm going to use several times in a program but only want to have to set it once for all those other places so maybe the name of a company a string of characters that i use to separate lines and output or copyright information anything that's going to get used more than once and isn't going to change while a program is running cobol has a few figurative literals built in to make things easier you can use them without setting them up yourself and a few you'll find most handy are zero and zeros space and spaces low value high value null nulls and you'll notice that for some of these there's a singular as well as a plural version very handy so if you're starting a new variable and you want it to be all spaces the efficient way to set that up is using the spaces literal rather than sitting there and going space basically using literals is what efficient programmers do and i want you to be an efficient programmer up next our good friend the data division all of the data you're going to use in your program gets set up in the data division to add structure to this we use what's called a data relationship we can see that by looking at this segment of code right here in this data division we've got level indicators each with their own descriptive entry print rec has a level indicator of 01 meaning it's the highest and then the data definitions are below it at 0 5 and the file account rec has its own set of variables with their own level indicators down here don't you just love that structure it's basically saying the data this file needs are the account fields and then below it it spells out exactly what those account fields are so we've declared the data let's do something with it move and compute are reserved words that we use to alter the value of variables move does well you probably figured it out it moves the data from one place into a variable and compute is used to perform math so in this example we've got a bunch of 77 level variables up top which are who where why rate hours and gross pay you'll notice the first three are alphanumeric and the last three are numeric then down in the procedure division we're using move to set up some of those variables the who where and why are captain cobalt san jose california and learn to be a cobol expert and that's spelled out pretty clearly on those lines we're also setting the hours and rate to 19 and 23. we are not going to set the gross pay with a move instead we're going to use compute and set that to the answer of our times rate and then lastly we'll output the values of our variables with some text before them so the person using the program knows what value they're looking at pretty simple right good because it's um oh yeah it's time for a lab take a look at the payroll zero zero cobalt source code in the id.cbl dataset and when you're ready to give it a try make sure you're submitting the jcl for it and not the cobol itself you submit the jcl to run the cobol got that i know you do have fun up until now we've mostly been moving data between variables taking them from user input or outputting them to a display now we're going to take things to the next level and start working with files to do this we're going to use select and assign clauses in the environment division fd statements in the data division and from the procedure division open close read into and write from statements the environment and data division is where we describe our inputs and outputs which will get used in the procedure division because as we all know that's where the action happens let's take a look at that action in action here you can see the file control paragraph in the input output section of the environment division what we're doing here is associating each cobalt internal file name with an external data set name in this case print line is the name of the internal file name and prtline is the external data set or file so that's the select and assign clauses in the environment division further down in the data division this is where we define the level numbers variable names data types and lengths the fd reserve word is used to give the cobalt compiler more information about those internal file names so print line which is linked with the data set file prt lina has these fields types and lengths and account rec which is linked to a cct rec has these fields types and lengths when your cobalt code is running on an ibm z mainframe it'll have access to both traditional z os data sets as well as unix files for right now we're going to focus on the z os sequential data storage method because it's extremely common and a good place to start when working with files in cobol a data set in z os is made up of records and you can think of each record as a line within a data set with a defined length so like anything written out row by row you'll find the exact value you're looking for by scanning down to the right record and then across for the field you want if you take all these fields and add up their length that makes up the entirety of the length of that record you got it it's kind of simple the way data input output or io is handled is a program says hey i'd like to read this piece of data out here and then the operating system or data io subsystem goes and gets it and places it into memory where the program can go and read it if a program is requesting lots and lots of reads one right after the other that's a lot of i o operations which is somewhat inefficient and can lead to slow performance it would be like going into a restaurant and ordering a soda and then waiting until that's brought out and saying you know what i'd also like a hamburger then they bring that out you say fries too and they bring that out and you say ketchup and then they throw you out of the restaurant because that's extremely inefficient and annoying and we don't want to be inefficient or annoying in cobalt programming we have this concept of something called blocks because we know so much about the records we can load data as a block where a block is a group of records as long as the program is going to read one record followed by the next followed by the next and so on we can get the records we want in order into what's called a buffer take a look at this we can see a block of records loaded into a buffer where the overall record length is the size of each field combined we set that overall block size in the buffer with the block contains clause earlier we used the assign clause to describe a data set source file we said select account rack with a dash in it assigned to account rec if we're running this in z os using jcl we need to have a jcl dd statement to link account rec to that actual data set the jcl required for the cobalt compiler to make the connection back to the actual data set looks something like this slash slash account rec d d d s n equals my.data comma disp equals shr if you're unfamiliar with jcl this is a data declaration statement that's what the dd stands for it says that for account rec look here at my.data the disk equals shr just means it expects that the data set exists before we try to use it and that other people can use it at the same time we don't require exclusive access now i don't know about you but i kind of want to see this all spelled out from end to end so we'll start out with account rec that's what we reference within our procedure division in the actual code account rec is what's defined in the environment division's input output section slash slash account rec a cct rec seven characters then gets connected via a dd statement to my.data the actual data set on the disk now don't sweat the jcl stuff too much right now i know you came here to learn cobol not jcl and chances are if you're given some code to write or modify somebody will prepare that jcl for you or at least tell you what data sets and names to use so you won't have to guess there's a link to an online resource for basic jcl concepts in the course notes if you're curious though one other important note the cobalt compiler assumes that what you tell it for the file names is true and correct and it will work when it goes to run because it doesn't have any way of checking what's actually in your jcl or actually on the file system and if any part of that chain is broken or not correctly linked you're going to get an error at run time that's why it's important to have a good naming scheme because chasing those types of errors is no fun at all up next we'll talk about putting all that to use in the procedure division now we're in the procedure division where we actually open those files that happens in the open file section and we can open files for input and output like this here we've got account rec open for input and print line open for output and just as we open the file we should really make sure to close them when we're done this can be done at the program completion or if it's going to be a long running program when we're done using that file resource we do that with the close dash stop so we just say close account dash rec and then close print dash line and then stop run stops the processing because cobalt is often used to handle lots and lots of data it's a safe assumption that we'll need a way to process records one after the other until we're done you may have seen in other programming languages the concept of a for or a do statement cobalt uses perform and in practice it looks like this i encourage you to hit the pause button on this screen and study it for a little bit because while it's extremely straightforward there are a few bits in here that might raise an eyebrow and we'll go through all of that so i'm stalling here to give you time to find the pause button and we're back so starting at the top we've got the read next record paragraph the first thing we're going to do here is perform a read record that's the first line there are no conditions about it we're going to do a read record at least once that read dash record is defined down here that is going to read the next record from the file and if we're at the end put a y presumably for yes into lastrack then when we're done reading we have this end read and even though that terminates logically and explicitly with the end read it also terminates implicitly with that period there so we're just being complete covering all of our bases now going back up into the read next record we're indenting and our first line here is a perform until it says perform until last rec equals y and why would last rec equals y it would be y if read record detected it hit the bottom and it processed its last record and if that file was empty it would hit this first perform put a y into last rec and then the logic of this until statement would say we're done performing we're bumped out of the logic because there's nothing left to do here and we've also hit this implicit terminator so we're done with this paragraph if the file is empty if the file has a couple of records in it like we would expect then we continue and we're going to do a write record with the data we just got that's defined down at the bottom of the example code then we'll do another read record before going back up to the top of this perform loop where we'll check to see if we got a y if it does we'll end if it's values then we're going to use write record to write them out continuing that process until we've hit the bottom of the file setting last rec to y and finishing reading a file from top to bottom is like the c major scale of cobalt programming you're going to have to do a lot of it so you should know how to do it forwards and backwards and this code right here is a great example of this type of logic done right keep all that good stuff in mind as we go into lab number three you'll use everything we touched on in this lesson to fix some code remember that the all important chain of links between the procedure variables environment variables and the jcl data sets needs to be correct and if it helps write them out so you can double check things as you write it go get to it lab number three you'll often hear cobalt referred to as a structured programming language in this definition structured means that it relies on the concept of passing control and adhering to a flow structure as a program executes in other words the way that you write your code is used to spell out how it should be executed people writing code in c pli python and of course cobalt use the structure of their languages to ensure code flows exactly the way it ought to another style of programming known as object oriented programming divides code up into smaller segments called classes each having its own specific purpose and each class has its own set of variables and methods then once the classes are defined you write the code that describes the interaction between them all and if you're writing a program where you're going to benefit from this type of class object relationship it allows for you to write very capable code without needing to define each and every instance of each and every class from scratch every single time however i can tell you from a little bit of experience that it's also very easy to write something that looks very simple but behaves completely different from what you intended you're essentially building the structure of code on the fly and that has its advantages but a lot of the code people write on cobalt needs to be transparent and readable and easily diagnosed which is a lot easier to do in a structured language you get the ability to jump around a little bit in cobalt but you should be sure to use those sparingly and not rely on them to provide the backbone of your program as we saw before cobalt passes control primarily using the perform keyword and using paragraphs so how can we best make use of this structure i'm so glad you asked let's take a look at basic program control and flow through a snippet of code we're setting up the output of print line we're setting the message headers of print rec to the number is and then we're adding one to the counter variable moving that value to message to right and then writing print rec which will print something like the number is one then we do the same thing again with the exact same code adding one moving it to message to right and printing it for as many times as we feel like repeating in this section here the only indication i have that i might be done is that the name of the program is 2 10 1 so i can assume we'll do this 10 times a simple looking program but dreadfully repetitive and not a very good use of anybody's time remember we want to be efficient and that doesn't look efficient those three lines of code keep getting written again and again and again so rather than typing them out let's address that issue right here we'll move those three lines of code into a new paragraph called write new record and then we'll just call that paragraph 10 times using the perform keyword so the program will get here then run this then go here then run this and i'll do that 10 times this is called an out of line perform statement because it requires jumping down here and then back up and it's definitely less code but it still seems kind of repetitive right that's where we need to look into using a loop using an inline perform statement and once i pop that up on the screen you'll see exactly what i mean in the previous versions the part of the code we were repeating was add one to the counter move that counter value to message to right and then writing it out here we see the move counter statement that looks the same and here's that print wreck we wrap those two lines in this perform and end perform which forms our loop so what about incrementing the content of counter that happens as a condition of the loop itself perform that sets up the loop varying counter from 0 1 by 1 until counter equals 11. that i mean we really don't have to spell out what it does right it basically looks like english perform a loop where each iteration of the loop increases the counter by one starting from one until we get to 11. why did we say 11 we had to say 11 because if we said 10 we would hit 10 after incrementing it match this until clause and bump out before executing the move and print part you'll see a logic like this in other languages like this java example obviously the cobalt version involves a lot more typing but it's easier to read and you'll also get autocomplete so your editor will write a lot of that for you another way you can get around this is by using a go to now here's the thing about go to don't use go to unless you absolutely have to do it and you absolutely know exactly what it's going to do go to does exactly what it sounds like it jumps the program to where you're directing it and it just kind of picks up and runs from there the difference between go to and perform is that instead of it being a special assignment that will do and then return from it's just gonna go there and start executing from there it's like when you're reading something online you see a word or a phrase you don't understand so you search for it and you find a video about it and you watch that video ideally you go okay cool now i understand that and you jump back to where you were or if you're like me you go hey that was kind of cool what was i looking at again and there goes the whole afternoon if you were to go back to that program we showed earlier and replaced the second perform right new record call with a go to right new record like this the program would jump ahead to the right new record paragraph execute it and then just keep on going because it didn't know that was on a special assignment it just thought okay well this is where i am now just understand the difference and be careful when using goto statements because you might be losing some of that structure that your program needs to be successful if that didn't make sense you might want to rewatch this video and check your notes because right now we're going to go to the next video when you start planning a program start thinking in paragraphs if you were to start whiteboarding the overall flow of a program drawing words and boxes and connecting those boxes with arrows a lot of those boxes will get implemented as paragraphs and that's good that's kind of the point a paragraph gets defined in the procedure division starts at column eight and can have any name you like apart from a reserved cobalt keyword the declaration of a paragraph is terminated with a period the paragraph itself can contain one to many cobalt sentences and is terminated by either the start of another paragraph or the end of the entire program from an application architecture perspective you really want to spend some time up front charting out the flow of your program and deciding what part will get handled in what paragraph if you start this way instead of kind of figuring it out as you go along not only will your code be less error prone you'll have a nice reference to use later on now there are two big situations where a light should go on over your head and you'll say to yourself ah that's a good use for a paragraph the first is if you find yourself typing the same couple of lines over and over and over again like adding a bunch of numbers together and finding the average if you find yourself doing that think about packaging those up into a paragraph and giving it a name and by the way put at least a few seconds of thought into your paragraph names nobody wants to open up a bunch of source code to find paragraphs called do file stuff or test123 aim for something like open input files or check for duplicates that way you know exactly what's going on in there also if you've got a couple of lines that need to happen a bunch of times extracting those lines into a paragraph and using a perform keyword to execute them a certain number of times or until a certain condition is met is good practice for writing comprehensive code a paragraph can come before or after the code calling it but you should try to order your paragraphs close to the order that they'll be executed in at run time just to make it easier to find them what i'm saying is don't just throw new paragraphs at the bottom of the program you may see people start their paragraphs with numbers and each paragraph will look like one thousand dash open files two thousand dash read next record and so on then as you extend your program you can add them into the appropriate significant digit that way you can say you know what that paragraph should be in the three thousands and so on we kind of don't have to rely on this anymore with modern editors that can quickly jump between the paragraphs of a program but this explains why you might see this done in code that you're looking at and you may or may not choose to do the same when you write yours you may also see empty paragraphs at the end of other paragraphs like this the open files end paragraph has no code and does nothing but for someone reading through code it makes a nice visual indicator that the code for this paragraph ends here it also comes into play if you're using the perform through keyword which we'll learn about in just a little bit one of the simplest ways of setting up a loop is with times for example here we say perform 10 times and then some code finishing with end perform and we can set that up with a number just like that or with a numeric variable like this perform my new paragraph counter times whatever counter is it'll perform that paragraph that many times we can also perform through and this can be spelled out through or just th r u check out this example we have our first paragraph 1000 paragraph a that says perform 2000 paragraph b through 3000 paragraph c this is another reason to consider the order that you state your paragraphs now we'll hit this perform through jump down and execute paragraph b and c and then finish this paragraph we'll never hit d because we were only performing through paragraph c we can also perform until which will evaluate the check and if that condition is not met it'll take some action this is usually done until a number hits a certain level or two variables are the same like increment this value until it's equal to that value in this example the order is that we do the check and then do the code and if the condition is met we're done we've done it until if that doesn't match your logic we can also do perform until with test after like here this will run the loop and then do the test there's also perform varying where we say something like perform varying counter from 0 1 by 1 until counter equals 11. we just looked at that earlier and if you really want to get fancy you can nest those performs like this where we've got two counters going on counter and counter two and every time we increment counter by one we're going to step counter two from one to five in increments of one so we would get one one two three four five two one two three four five three one two three four five and so on now i don't know about you but i'm starting to get a little loopy myself in the next video we'll cover linking in other cobol programs a cobalt program can call other cobalt programs and you do that with the call keyword followed by the name of the program that can be call prog a1 with the literal program name being in single quotes or like this where we move the program name to a variable and then call that variable the way a calling program calls a called program is through something called linkage and i'm going to show you a very basic example of it the program being called has this section called the linkage section and in here it defines three variables month day and year they're all numeric two digits for month and day and four for year of course there's four for year and they've all got an ls at the end so you know they're in the linkage section as opposed to the variables up here in the working storage section which have a ws at the end so this program over here that we're calling it knows that it's going to be called and it prepares itself by setting up the linkage section it also sets up the procedure division using the using keyword so it's going to use those three variables from the linkage section in addition to the three variables from the data division working storage section now the calling program sets up those three variables in preparation for this which in this case matched the variables in the linkage section we want to set those up just like any other variable then we do this call date sub using month out day out year out there's those three variables we're calling that other program and giving it those three variables to store the output that it generates linking programs can get quite complicated but for now we're just going to leave it at that just know that there are ways of passing actual data as opposed to references to data mechanisms for getting a return value from a called program and all other sorts of goodies once a program reaches a certain size you're almost guaranteed to see everything we've talked about in these last few videos put to use so if this all makes sense you're in good shape let's keep this party going a big part of cobalt is generating reports you've got tons and tons and tons of data and you need a way to produce a report of that data so someone else can look at it and go hmm yes yes that's very good yes for that reason we've spelled out an example of generating report data here which can be very easily scaled out to handle multiple records and called any number of different ways at the end you'll be asked to complete a lab that puts all of this to use previously we looked at the select and respective assign programmer chosen names we had something like this in the environment division we used print line as the internal cobalt file name for the output now in the file descriptor marked by fd within the file control paragraph we start to connect it all together the fd entry defines the layout of the record within that print line internal file and you can see you were saying fd is a file the highest level descriptor is print wreck and then within that print wreck we have the individual fields defined first account number o presumably for output that's a value of eight alphanumeric characters then look at this filler that's an odd name for a field and it's actually not a field but a cobalt reserved word remember those we use filler to allocate memory space typically between words or variables and filler can be empty it can be dashes or any literal in this example it's eight characters of account number then two spaces and you can see that we spelled out spaces there with spaces that's a handy shortcut so you don't actually have to type out the spaces each one of those filler lines in here is just inserting two empty spaces and in this case it might seem somewhat basic but without filler your reports would just be a bunch of values slammed up against one another consider this partial program this is the working storage section we've got four headers defined there's no logic in here this is just something that defines what our data looks like notice we've got some areas up here that are just filler and we're filling them up with this text financial report for then in header two it's a mixture of literal labels and printed out variables so we'll have the word year notice it's year with a space at the end of it and that's why it's five characters then the value of hdr year header year same with month and day header three is all filler it's just account two spaces last name two spaces limit two spaces and balance and then forty spaces if you need forty spaces for your account balance i wanna be your friend send me an email once you're done learning cobalt then in header four this is more filler it's eight dashes two spaces ten dashes two spaces and so on so what i see up here so far is a header that goes up top and that says what the report is and then there's some sort of header info that spells out the time period the report is for which is kind of important and then we've got two headers for the values which i'm assuming will be listed out below makes sense so far so that header too that's date info the data name layout for the date info is defined here and it's kind of neat how this works the high level variable name is ws current date data that's ws for working storage and then within that we've got two sections ws current date and ws current time the date is divided up into the year month and day and the time is divided up into hours minutes seconds and milliseconds now we know exactly what that current date data looks like which is good because that's one of the first things we're going to do in the procedure division aka the division where all the action happens check out this procedure division we start out with a paragraph called write headers and then we've got these four move sentences the first one takes the current date from what's known as an intrinsic function more on that later but what it does is it takes the current date of when that code is actually executed and it copies it into ws current date data then because we defined how the fields of year month and day line up within that data name layout we can just tell it to move the year month and day portions of that data into those three variables then in lines five and six we write out our report header that's the financial report four part and the date info that follows it from header two we're writing those out to print rec and we're writing them out there from header one and header two then we move spaces to print rec and line seven if we didn't do this we might leave straight characters behind we want to start out with the next series of moves and writes assuming that we have a blank record and then we write it out so if you're following along at home which i hope you are we've got the financial report for then the date header and info then a blank space because in line eight we wrote out that line of spaces and put it into the print rec in line seven lines nine and ten write out the column headers of account last name limit balance and those nifty dashes that went under them now all we have to do is print out the data that goes underneath those headers and you know what that's where the lab comes in that will show you how you can take data from a file and use it to generate a report with all the nice formatting and spacing that makes it nice and easy to read after that why don't you report back here for the next lesson the path that a program takes is sometimes referred to as its logic does the user want to enter more data if yes then we'll jump to the part of our code where we'll let them put in more data if they're done then we'll jump to the part of our code where we're going to process that data it's kind of like hitting a fork in the road and we use what we know to inform that decision maybe you want to look at a bunch of accounts and find the ones that haven't been updated in the last 60 days in that case we're taking the difference between the most recent update and today's date and comparing that difference to 60. presumably if the difference is greater than 60 then we're gonna do something special with that account that's all logic and unless we insert our own logic a program is going to run from the top to the bottom until it's done so we need to learn how to express what we want to happen in a program's logic three of the most common types of cobol conditional expressions are general relation conditions class conditions and sign conditions and a lot of these are fairly simple it's taking two operands comparing them to one another and saying is this greater than that or is this equal to that or saying is this numeric is this lowercase sometimes because of the way our logic is structured we'll want to say is this not numeric because maybe we asked the user for a number and we got that something like xx and we need a way of saying if this is not numeric go and prompt that user again and remind them we're looking for a numeric answer so whenever you're writing a conditional expression they typically start out with is and then there's a test or a comparison afterwards and you can between the test and the comparison throw in a knot to flip that logic around there's another important and powerful tool you have in writing program logic known as conditional names these are used primarily to say the input we're taking needs to pass this test a conditional name is declared in the working storage section with an 88 level number in this case it has to be an 88 level number we use a conditional name to say the variable that i'm under needs to match this and it can be a literal a series of literals or a pattern or anything like that and it's a good way of verifying user input and again it always has to be an 88 take a look at this example we move az into usastate then we enter this if statement if state the only way this will pass as true is if state evaluates as true which in this case will only pass if it's equal to tx so we're going to say the state is not texas then here we're moving tx to usastate that will pass because it matches that 88 conditional statement it equals tx why would we do something like this well imagine instead of just putting in one state we put in all 50. that makes sure somebody didn't put in something like z z or one two as their state or something like that that didn't make any sense so we can use conditional names as a way of validating or limiting data before we try and do something with it there are other ways of implementing this type of logic but being able to have one place to define the scope of the data for a test is quite handy if we're comparing values like if this is greater than that we use conditional operators and those include is greater than which can be written out as is greater than sign remember those alligator mounts or is equal to which can be written out with the equal sign we can also say is greater than or equal to with is greater than equal to we can take that concept and put it to use in conditional expressions that's where we put those if then else statements to use and you're probably already familiar with those concepts either from another programming language or just from everyday talking logic if it's nice out then i'm gonna go for a hike else i'm just gonna stay inside and play video games again we've defined two possible outcomes and what will inform that decision the weather in code we might write something like this if facial expression is happy then say hey i'm glad you're happy otherwise say what can i do to make you happy obviously we would want this program to actually do stuff if you're happy or not happy maybe clap your hands but this shows a basic if then else statement we have another way of doing this that's more useful if there's more than two paths and that's an evaluate statement we set that up like this first we evaluate facial expression when it's happy we do this when it's sad we do this when it's perplexed we do this and we can keep on going until we run out of possibilities and then we hit the end where we just say end evaluate this comes in handy for menu type items like press one to show account balance press two to make withdrawal press three to transfer money etc each one of those could be a when in this big evaluate statement another thing that happens quite often in programming is performing some sort of function or set of steps until something happens maybe it's processing files until we've reached the end or adding stops to this truck driver's route until the truck is full if we're iterating over data specifically tables trying to find a specific entry we can use search statement that syntax looks like this search the facial expression table until you've found the index marked happy then presumably we do something with that record although in this example we issue a stop run so i guess they found happiness and there's nothing left to do let's get back to those conditions you know we can say if this number is equal to that number that's a test of the relationship between two operands which can be numeric or text we can also use conditions to test the content of a data item like is numeric or is not alphabetic lower or even is kanji and for numbers we can say is positive is negative and is zero and just so you know we're really only skimming the surface here to read more about all these conditions visit the ibm knowledge center for enterprise cobol there's links for that in your material we're coming up on that time time to put what you've learned to use in a lab and we're still working on those reports this time we're going to add in a special case if we happen to be in the state of virginia which will result in a special entry in the last line of your report good luck and i'll see you back here when you're done cobalt is often used to process lots and lots and lots and lots of data and a lot of data is made up of lots and lots and lots and lots of numbers so in order to deal with all those numbers we need to take a look at cobalt arithmetic expressions that's that's it that's that's the intro nope more all right let's put this graphics budget to use it's math time nice good job guys so what is arithmetic expression well an arithmetic expression can be built up with numbers variables that represent numbers the figurative constant of zero and any combination of those enclosed within parentheses including any combination of all that that i just mentioned having mathematical operations performed on them i think that about covers it for example number of people minus number of staff times three divided by eight would be how many pizzas you need in order to feed a crowd of this many people assuming we're not feeding the staff each person will want three slices and there are eight slices per pizza that's a pretty good mix of variables and literals and parentheses and we can spell expressions out with plus minus times divided by and you can also use two asterisks or stars to show exponentiation so 2 star star 8 is 2 to the 8th power meaning we keep doubling two eight times that's 2 4 8 16 32 64 128 256 2 to the eighth equals 256. sometimes it makes sense to spell out our arithmetic expressions using the compute command this can help make your code more readable or just focus a series of arithmetic operations in one place so we can say compute z equals a plus b divided by c exponent d minus e we can also say compute x y z equals all of that and it will assign the answer of whatever that might be to all three variables x y and z now you've probably heard of the order of operations before and if a part of your brain lit up that you haven't heard from in a while the word pemdas probably does the same that is the order in which we tackle an expression starting with parentheses then exponents multiplication division addition and subtraction pemdas by default cobalt will evaluate expressions this way if you want to either circumvent that order or you want to make it more clear for yourself or others who are reading your code you can also enclose sections of your expressions in parentheses cobalt will start with the most nested part of the expression the part enclosed in the most parentheses and then keep working its way out after that it'll look at the unary operators positive negative then exponents then multiplication and division from left to right and then addition and subtraction from left to right that means that an arithmetic expression must begin with either a left parenthesis a unary operator or an operand in the form of a literal number or a variable representing a number there are limitations to how far you can push arithmetic expressions in cobol the first is that exponents in fixed point expressions cannot be more than nine digits if the compiler sees this it'll truncate it and you will get a diagnostic message also while the data descriptions of operands in expressions don't need to be the same meaning you can multiply a twodigit number by a fourdigit number the maximum size of each operand is either 18 or 19 decimal digits depending on the compiler option used if you're working with data that requires either very big numbers or a very high degree of precision make sure you know if you're using compatibility or extended mode for arithmetic there are also considerations to consider when dealing with the rounding of data and there's more to get into that we can't cover in its entirety here but that's all spelled out in the procedure division statements cobalt language reference as you've probably guessed we're going to get to use some of these new skills in the upcoming lab check out this change to the working storage section here we've got t limit and t balance there's some big numbers in there and we'll learn more about data types in the upcoming data type section but i can tell you right now those are big numbers or at least able to represent big numbers they're a comp three data type and they start out with a value of zero and look at this we've got what looks like more header type content except we're calling it trailer and i'm not a betting man but i think that's going to come at the end it looks like it's showing us some sort of totals so that makes sense too and then in the read next record paragraph we now have a perform limit balance total line which is calling this which is two compute statements which look like they're keeping a running total of the balance in total from every line it's processing hmm of course we're gonna write it out so we've got this right t limit t balance paragraph which moves the running totals into the dash o variable so that when we write the trailer lines out the actual values are gonna show up in there those are the parts you'll need to finish this sections lab and by my calculations it's time to get to work computers don't have fingers i mean do they i mean i guess no no they no they don't except what about no no no computers computers do not have fingers let's let's just stick with that so so when a computer is thinking of a number like the number eight it's not going like this it's lighting up little bits of memory that represent that number eight it's got its own methods of taking numbers letters and other concepts and representing them electronically one of the ways you can make sure your programs are running as quickly and efficiently as possible is by choosing the best way for cobalt to represent that data in its memory let's start out with numerical representation there are five different computational value representations let's start with comp one comp 1 is also known as a single precision floating point number representation this is useful for numbers that are very small and close to 0 or very large up to 10 to the power of 38 however comp one has somewhat limited precision it only has about seven significant decimal digits anything beyond that gets rounded so a value like 1 234 567.89 that rate there is nine digits and it's going to get rounded which if you're dealing with dollars and cents you might not want to happen but for simple numbers a comp one might work then there's comp 2. this is a double precision floating point numeric representation and this can handle bigger numbers about 10 to the power of 307 it has more significant digits up to about 15 so it goes further than comp 1 in all regards but it is still somewhat limited and then there's can you guess we did comp 1 comp 2 yes you in the back no it's actually comp 3 comp 3 and this is where it gets interesting this is what's known as a bcd or binary coded decimal this is by far the most utilized numeric value representation in cobol it is also somewhat unique and native to the mainframe computer and z architecture and with good reason it has to do with decimal fractions when you do lots and lots of operations with decimal fractions and the data is stored in binary that's when you start to get rounding issues representing that data in binary coded decimal avoids these issues it exactly represents values with decimal places and can go up to 31 decimal digits ask someone in a banking credit card or payment processing industry why they depend on cobalt and they're probably going to mention bcd binary code of decimal and decimal fractions and then there's comp 4. comp 4 is only capable of representing integers so if you're dealing with something like a counter or you're only working in integers using comp 4 has you covered there and then there's comp 5 which is the same as com4 but with it you can specify the position of a decimal point it's got space efficiency of comp 4 with the exactness of com3 the drawback there is that cannot exceed 18 decimal digits so there's your numerical value representations numbers are good but sometimes you want to use letters and you'll be happy to know that cobalt's got you covered there as well there's ebcdec which stands for extended binary coded decimal interchange code and ascii which stands for american standard code for information interchange and it's not like one supports bigger words than the other it really just comes down to how the characters are represented in the computer's memory ebcdec has eight bits per character ascii uses seven and the characters are distributed across the possible combinations of those bits differently today the only place you're likely to see ebsydeck code is if you're on an ibm mainframe most everywhere else uses ascii or unicode however just keep this in mind if you're working on programs written a long time ago because every once in a while you'll go to load some data and it'll show up looking all weird your first instinct should be to say is it possible that this data is ebsedec and i'm trying to load it in ascii or vice versa because that happens quite often and now you'll know and you'll be prepared in this slab you'll deal with an issue just like that where spoiler alert there's a mismatch between external data and the cobalt representation of that data there's a hint and an explanation in there to help you along because this is a tricky one if you're like me one of the things you like about cobalt is how straightforward each line of code within a program is it does what it says it's going to do and there's really no mystery about what do this until this happens means however sometimes you need to do something beyond just add two numbers together or print out a line of text and it would be a shame if every time you needed to for example turn a string of characters from lowercase to uppercase you had to go and build that paragraph of logic all by yourself first off you're just repeating work and more importantly that's important code logic that needs to work right every single time being added onto whatever the primary role of the program that you're writing is there's got to be a better way well fortunately cobalt has a number of what are called intrinsic functions built in that you can use and if you're working with business data chances are there's something in there for you don't worry it's not like there's 500 new functions you have to keep track of the most recent release of enterprise cobalt for z os includes 70 intrinsic functions and they fall into the categories of math statistics date time financial character handling and general let's take a look at some of those intrinsic functions they all follow the format of function then the name of the function and then any arguments passed to that function in parentheses for example look at this we've got two variables item one and item two item one has hello world in it with a capital h and a capital w the rest lower case and then there's item two which is empty and we're going to display item one which should look exactly like it does up here with that capital h and capital w then we're using the uppercase and lowercase intrinsic functions to show item 1 in both uppercase and lowercase form note that this is just being called in the display function so it's not altering the stored data that's just how it's going to show up when the display goes to show it then in this line we're moving the upper cased version of item 1 into item 2 and then displaying it so in this last line if we display item two it'll show hello world in all caps that's going to come in handy and making sure we don't have any duplicate values otherwise first street with lowercase st would be a different entry than first street with an uppercase st which happens quite often if we just uppercase everything we can be sure that all the data coming in is case insensitive there's also math intrinsic functions got a bunch of values that you want summed up you could line them all up and make an equation out of it or you could say compute x equals function sum a b c divided by d that'll sign x the value of a plus b plus c divided by d and just like before anything within a pair of parentheses as seen as one operand and it needs to get figured out before totaling the sum but wait there's more form that one's signed with nine spaces we can use the function of current date with the argument of one colon eight and move that into the first variable what's going on there well we're specifying the output in this case we want the output from character one that's the one through eight that's the eight which just happens to be where the year month and day live within that output then we want another function integer of date to turn that date into a number that number is the number of days that have passed since january 1st 1601 so it's going to be a big number but it's also not likely you'll need to go back much further than 1601 so pretty safe bet anyway what we have now is essentially a count of days with that we can add 90 to it and now we're talking about a date that's 90 days from now you see what we're doing now we're going to use another function to transform that integer form back into year month and day form using the date of integer function see what we're doing there we flipped it and now we wind up with what is a nicely formatted date in the form of year month day and that's 90 days into the future because we added 90 to it and that takes into account going through all the months of different lengths leap years and all that stuff intrinsic functions and there's more lots more like 60 something more keep that in mind as you're writing code and you think to yourself gee i can't believe i have to write this out by hand because there just might be an intrinsic function that you can use right there intrinsic functions sound like something you might want to try oh well guess what act now and you can do just that with this intrinsic functions lab get yours today we are at the last section of this cobalt series first off i am extremely glad you made it here and i hope you feel a lot more confident in your own abilities as a cobalt programmer of course the world goes on from here there are lots more functions methods and ways of dealing with files and input to explore but if you made it this far you can tackle anything else you come across you'll be able to understand the syntax plug it into your code make requested changes port a program from one system to another you've got all that just like with any other programming language the internet is full of code samples mini exercises and forms with people looking to help go to the open mainframe project and go into the cobol section on there for a good head start on those resources whether cobol is your first programming language or your 15th or your 50th i hope you've learned what this specialized language is all about and you'll see why it's used so widely in highly transactional systems all around the world from our team to you thank you for watching thank you for participating and we wish you the best in all that you do stop run you