in this course you'll learn how to use nextjs and cloudinary to build a Google photos clone and you'll learn how to make the app transform and enhance the images Colby fak created this course Colby is a popular course creator and is great at breaking things down for beginners Kobe works for cloudinary Who provided a grant to make this course possible images are a fundamental part of our everyday lives giving us the opportunity to capture a moment in time and share it with the world or maybe just enjoy it ourselves but what do we do when we have all those images which is increasingly challenging now that most of us have a smartphone in our pocket that has a pretty impressive camera so we're going to see how we can take those images put them into some kind of storage to create a media library where we're going to be able to not only upload those images but transform them such as cropping and resizing we're going to use AI to enhance those images and we're even going to see how we can add some filters and some fun effects like remove the background to really transform our images into something new particularly we're going to pretty much build a Google photos clone where if you're not familiar with the concept it's pretty much that media library I was talking about where once you have all of your images uploaded to your library you can start to do things like editing them where maybe I want to improve that image with AI or use AI to remove the background or we can also do things like cropping where I can dynamically crop it to a to a common format and I can even add filters such as maybe I want to have this image a cooler tone but one of my favorite Parts is taking this a step further with those Creations where maybe I want to include a couple images and I want to create a collage out of them I can easily select the images that I want I can trigger the action to create a collage and now I have my beautiful collage that I can save to my library and now I can share with my friends so through this tutorial we're going to cover a wide variety of topics of how we can build this app inside a nextjs including first off how do we actually upload our images to the cloud where we're going to use a dropin upload widget that makes it really easy to upload our images directly to our media library now once the up inside of our cloud account how do we get them out so we're going to see how we can list those images using nextjs server components and then pass that data to the client using tan stack query where we can interact with it such as adding to that list after upload now once we have all of our images actually in our library we want to be able to view those images and transform them like we talked about so we're going to see how we can use Dynamic routes where we can set up a page for every single one of those images where we can start to do all those different editing options like that using AI to transform it the dynamic cropping and resizing the filters and even just simply adding some metadata and giving the ability to delete that image now back to one of my favorite Parts is those Creations how can we have some more advanced options such as creating API endpoints where I want to be able to create all those different features and Creations such as animations collages and even colourpop so we're going to see how we can dive into these different features and create really Advanced syntax in order to create Dynamic experiences with all of our images now rather than trying to rebuild this entire UI from scratch we're going to use a starter template that's just going to give us some more of the basic layout features now in order to get started with this you can find this repo over on my GitHub it's demo photo library starter or you should be able to find the link inside of the description of this video now before we dive in if you want to see the completed project that I took Beyond this tutorial you can check it out at photob box. where I have a completely open source where you can easily spin up your own photo library completely built you just need to plug in your clouding account now once we get started we can scroll down and we can see we're going to run this command in order to get started you can also clone this repo if you want but I recommend running this create next app command where I'm going to copy that to my clipboard and I'm going to pull up my terminal and run this command where we can see that what's going to happen is it's going to download that repository to my local environment it's even going to install the dependencies and reset G history which is important for starting off with a new project so I'm going to now navigate to my photo library I'm going to run npm run Dev where it's going to start up a local server where I can now open that up inside of my browser and as soon as this project loads we can see we have the exact same starter template so now that we have our project started we can head over to our code editor where let's take a quick look about what's inside where if I start navigating to my source my app directory where we're primarily going to work out of is the page file which we can see this grouping under pages and I'm doing that so I can have a custom layout for just that page but then we can see we also have the resources page where this is going to be where we're going to have our individual page for every single image so we can have that dynamically created we'll see how we can get to that later in the tutorial but we're primarily going to be working out of these two pages we're also going to be working out of some components including a media Gallery component as well as a media viewer component where because we're opting into SSR or serers side rendering for the core of the page we want to be able to use some client side features to actually be able to interact with our images inside of the application so we can see we're using components to do that we're appending Ed client at the top of those where we can then take advantage some of the client side apis now it's also worth noting while we're digging in here is we're using Shad CN to build a lot of the UI so inside of this UI directory you're going to be able to find all the components that were installed using Shad CN where you have the ability to customize them or even add your own Shad CN UI components and addition to Shad CN we're using Tailwind in order to actually do the UI styling but before we get started feel free to pause the video take a minute to get familiar with their project before we dig in now once we're ready to actually start building the project the first thing we want to do is list out our images now in order to do this of course you need a cloud Nary account so head over to cloud.com and sign up for free if you want to get three bonus credits for your free account make sure you head over to C.M medfree Cod camp or check out the link in the description where you can claim your credits but once you have your account and you're all logged in we're ready to go we're going to use the node.js integration in order to easily list out all of our our images using a server component inside a nextjs so to start off let's head back to our terminal and the first thing we're going to do is going to run npm install cloudinary where once it's finished installing we're going to head back over to our code editor where inside we're going to first import the cloud Nary SDK so at the top of app pages page where the page that I want to actually list my files in I'm going to import V2 as cloudinary from cloudinary now the important thing to not here is that V2 is that top level import so we want to make sure that we import V2 but we're going to import it as cloudy for convenience but once we have that imported the first thing we need to do is actually configure our Cloud Nary account so I'm going to add my cloudinary doc config we inside we're going to Define three things we're going to Define our Cloud name our API key and our API secret now let's go grab those values now inside of your Cloud account you can find your credentials right at the top of your program programmable media dashboard now that's inside of your clowner account make sure you select programmable media on this left sidebar and under dashboard you should be able to see your product environment credentials now depending on when you created your account it might look slightly different but generally speaking you should be able to find these you can also note that you can always find your API keys inside of settings and under access keys so make sure that you have different ways of being able to find the keys that you need to configure your account but for now I'm going to go ahead and just use these uh environment cred potentials at the top of my dashboard where we can see we have our Cloud name our API key and our API secret so I'm going to start copying these into the application starting off with the cloud name and as we're starting to configure our cloud account the one thing you want to consider is how you're actually managing these credentials now just using the cloud name if all you're doing is maybe some client side or maybe just grabbing images from your Cloud account your Cloud name can probably just be added inside of the code but we're going to be working with both our Cloud name as well as our API key and our API secret so we don't want to store those in the code just to make sure that those don't get compromised if we accidentally commit them to get or something along those lines so let's use environment variables to configure this so inside of the root of my project I'm going to create a new file called env. looc and I'm going to start off by creating next public cloudinary Cloud name and I'm going to set that equal to my cloud name now no I'm appending next public in front of cloud Nary Cloud name which is important because we want this publicly available or we want this available in the client where we'll later use client side interactions so we want to make sure that we have next public Cloud n Cloud name now we're also going to want next public cloudinary API key where the API key is intended to be used in the client or at least allowed to be used in the client so we're going to make that public as well because we'll be using that for uploading later but then we're going to use our cloudinary API secret and note it's important that you do not add next public in front of this API key because this is only supposed to be used on the server this should not be shared with anybody so let's now fill out those other keys so starting off with the API key I'm going to go ahead and copy that I'm going to go ahead and add it to my variable and then my API secret and I'm going to go ahead and add it here now no I shouldn't be showing you this API secret but because I'm using a temporary account I'm going to reset the credentials but I want you to kind of see how it's actually going to look when you're adding it to your project so just be sure you don't ever share these API key in secret with anybody else other than trying to configure your environment but now moving back into where we're configuring those let's start to add them with process.env dopu and let me make sure I hide myself to not cover this Cloud dinary API key I'm going to also add the API secret and I'm going to do the same thing with my cloud name and be sure to remove next public from the API secret and update cloud name but now that it's configured let's actually start using the SDK so I'm going to first hide my sidebar here to give us a little bit more room but at the top of my home component I'm going to add constant results is equal to await cloudinary api. resources and we're using the resources method to start which is just going to give us all the resources in our inside of our account now there's different ways that you can query your resources whether it's by tag which we'll see later in other ways you can even search your media library but for now let's start with resources and and we're going to go ahead and just console log out the results to see what's inside now inside of your cloud account you should have some images already inside whether it's a brand new account or an existing account with some of your own images but if it is a brand new account Cloud automatically places some sample images in there so that we have something to work with to get started if we head back into our site and we try to refresh the page I'm going to go ahead and open up my developer tools and we're not actually seeing anything in there so let me pull up my terminal actually where if we look inside let me hide myself we actually see all the data there and the reason we see this is because this query is actually running on the server it's not running inside of the client hence why we're seeing it inside of our terminal and we're not actually seeing in the browser in our developer tools and that's completely expected because we're using SSR or server side rendering in in order to get that value and using the node integration in doing so but that's a good thing because now we can make those requests on the server and we can pass it along to the client so that we don't have to include all those resources in JavaScript in order to get that over to the browser so now let's actually try to Loop through these and display them on the page so looking just quickly back at the results we're going to see that we have a top level property of resources and that's going to contain the array of everything that we actually need so heading back to our code editor we know that inside of results we're going to get our resources if I spell that right so let's actually take those resources and we're going to just pass it along to Media Gallery because media Gallery is already expecting a prop of resources and we're going to look inside to see how we can actually configure it to use our cloudinary resources so the first thing I'm going to do is I'm going to pass that along inside so media Gallery is now getting those Dynamic resources now let me navigate over to Media gallery and just to open up the sidebar here we're going into components media gallery and the media Gallery component where we can see we're getting these resources currently it's just expecting an array of those resources and it's just getting the ID now we need to do a little bit of configuration here because it's expecting a cloud resource the funny thing is if we look inside of the browser we already see that we're getting something working we can see that we have a bunch of instances of that cloud andary logo but that's be because it's just looping through that array and it's just adding a static image so now let's make that Dynamic so it's actually showing the image inside of our account now back inside of the code rather than continuing with this manually created object inside of that array I'm going to go ahead and start a new interface and I'm going to call that cloudinary resource because I know I'm going to use that later for other purposes is so I'm going to go ahead and replace that ID and next I'm going to start off by adding some of the details that are going to be inside of this Cloud resource now looking again inside of the terminal hiding myself we're going to be using a few different aspects of this we're going to use the public ID which is just an identifier for that particular asset we're going to use things like the secure URL which is going to actually give us that URL we're going to use the width and the height and we're going to probably be using other things later but for now let's just add those four things so on the cloud resource let's start defining this I'm going to have my height which is going to be a number I'm going to have my width which is going to be a number I have my public ID which is going to be a string as well as my secure URL so I have my height my public ID my secure URL and my width and that for now is going to represent my cloud Nery resource now just to make sure we do have some type errors going on here we can see that the code is currently referencing that ID let me hide myself here we see that we have resource ID resource ID and that was just for some temporary code so that when we spun up the starter we actually saw something so I'm going to replace all these IDs I'm just going to multi select all these by using command D after I highlighted one of them and I'm going to Simply change it to public ID and let me make sure I get everything we have a few more instances here I'm just going to select them all and of course I'm going to upd update those as well to public ID now in addition to the public ID we also want to make sure that we're actually using the dynamic data from that resource so if we look at this image tag here we can see we have the width height and the source so I'm going to go ahead and update all those resource. width we also have our resource. height and we have our resource. secure URL now we don't have any alt value right now and obviously it's not going to be a cloud Nary logo so let's go ahead and just get rid of that string but now we can see we're pulling all of our assets from our Cloud Nary Library whether it's just the samples that came with a new account or anything that you might have added so we can see we can scroll through we can see all these this one looks looks blank but it's actually just a white logo on white background so that's why you can't really see it but we can see that we have all of our images displaying on the page so starting off we're going to get started with one of the more basic but impactful features of cloud Nary and that's optimization now if we head over to our Network Tab and let me hide myself and we filter on our images we can see Let me refresh the page that they're all a decent size they're couple hundred kilobytes each they're getting served as jpegs as pings and what's happening are these images are getting served as is cloud doesn't automatically optimize those imag by default what it does is it Returns the uploaded photo by default where you need to opt into optimization but we can easily do so where we're going to use a new library to accomplish this called Next cloudm which is going to allow us to have an easy to use component inside of an xjs application as well as some other stuff that we'll see later like uploading and we could technically do this using the node integration we could easily construct our URLs to do this but we can a lot more features with with this additional nextjs integration if you want to learn more or see the documentation for next clowner you can head over to next. Cloud dodev where if you click get started you can see all the components available including CL image which we're about to use as well as the clld upload widget and others where we're going to be able to use uploading really easily with the c upload widget so let's get started with the CL image so inside of my terminal I'm going to hide myself and run npm installed next cloudinary and once that's installed I'm going to head back to vs code and we don't actually need to configure anything because if we look back inside of our. looc we already have set up our next public Cloud Nary Cloud name and that's literally all we need to in order to use the components that we're going to use now the upload widget will use the next public Cloud Nary API key and again we already have that configured so we don't need to do anything aside from actually importing the components but what we now can do is we can head back over to our media Gallery component where again that's under components media gallery and this is where we're going to be look working out of for that Gallery I can now import my clld image component from next cloudinary and what I can do now is I can head down to the bottom of my file where I have this image and I'm going to just simply swap that image tag for my CL image and that didn't paste right of course but now we have our it's a dropin replacement for the image tag as long as you have the width the height the source and the alt so it's really easy to configure now the only copy out there is instead of the source being our secure URL which technically Al it can accept URLs with a version in it we want to use the public ID as it's going to just to be a little bit more confident in how we're using it we just a little bit more flexible so I'm going to go ahead and update this to resource. public ID so that I'm passing in my cloudinary public ID to the source of my CLD image but everything else can remain the same and now that I'm heading back to my browser with my Dev server restarted I'm going to go ahead and refresh the page so we can see this network tab but after the page compiles and loads we can see that it's looking a little bit different we can see that we're getting a bunch of webp requests instead of all those jpics now let's just kind of hone in on one we can see this top one C sample 5 we have a now a webp file and we have it being served at 140 kiloby and generally speaking most of these files are definitely smaller than they were when we were serving them before sure some of them are still a few hundred kilobytes because they're big files but generally speaking they're now being served optimized now two things are happening here and let me open up this one as an example where I'm pull myself back in if we look at the URL here first off we see this F Auto what F Auto is going to do is it's going to return the most efficient format automatically so what that means is depending on the browser and the device the browser might support different formats that are more efficient than others where in this case the most efficient format that my account and my browser supports is webp now in some accounts you might be upgraded to Avi depending on your use case uh there's also some other modern formats potentially coming down the line like jpeg XL but for now we have the format that's being delivered for my case which is going to be webp now also looking at Q auto that's going to automatically compress the image to a point where it's not going to visually distort the image so we're going to get the most automatic or the most compression possible while still maintaining the visual uh quality of the image itself so we're having kind of two effects there and how we're optimizing it to deliver as small of an image as we can with the highest quality now we also see that we're also passing passing the C limit where we're passing a width of 3 3,840 and that's actually coming from responsive sizing or in this case we haven't quite configured all the responsive sizing yet so we'll get to that in a second but what this is doing is it's resizing it to 3,840 or because we're using C limit it's only going to resize down from a higher value will and it will never upscale now if this was instead C scale it would potentially upale scale it to that value if the image itself is smaller but because we're using limit it will not upscale and it'll only downscale if it's a smaller value than the image itself now as you'll notice all these are parameters that are getting added to the URL and this is going to be our transformation API which allows us to customize and edit and modify how the image is getting created and delivered now there's a whole lot of different things you can do and you can construct these manually if you want but the library is going to handle this for us and give us a little bit more an easier way to interact with it and achieve the different Transformations that we want if you want to learn about all the different Transformations that are available you can head over to the transformation URL API reference on the cloud documentation but going back to our project I alluded to responsive sizing now let's quickly just inspect one of our images let's keep with that c image 5 where if we look at that URL hide myself again we see that we have our width our height that's the ones that we defined or rather that's what came dynamically from the resource request but then if we we look at source set we can see that it's currently defining these URLs we're seeing those parameters but if we see this width is dynamic depending on the size Now by default the the component which wraps the nextjs image component is only going to give us a one times image and a two times image so that's why you can see the way that the images are configured with those different widths but we can add additional configuration to take advantage of more complex uh responsive sizing now in order to take advantage of that responsive sizing all we really need to do is Define this sizes prop and like I mentioned the CLT image component wraps the nextjs image component so this is a feature that we actually inherit direct inherit directly from nextjs but as we can see for this particular example we're using media query uh sizing where we can say we want to have a Max width of 768 for a 100 viewport width image we have our different configuration for 1,200 and then finally the default of 33 viewport width so we can add something similar to our own project if we head back to the code I'm going to start off by adding a sizes prop and I'm just going to Simply set this to 100 viewport width if we head back to the code we can already see that we have a completely different looking Source set where we have a lot of different sizes available I'm going to stop hovering but if you try to look on the right hand side where our source set is for that image tag we can see all those different size parameters and they're going to have different Dynamic values inside of the cloud n URL so now if we try to refresh the page with a smaller viewport size and I start to increase the size of the browser we can see that it's going to keep loading the bigger sizes and only load the smaller sizes at the smaller viewports now we only have it configured to be a 100 viewport with image right now and we can have better Dynamics sizing based off of the sizes that we have where we're showing these grid of images so back in my code I'm going to go ahead and just paste this value in where we can see that we have a default of 50 viewp part width I have one at 768 we have a two a three column grid so I'm going to do 33 viewport width when we have 1024 I'm going to do a four grid and 1280 we have a five image grid But ultimately what that sizes prop will do is help the browser determine what image to show out of that Source set list based off those given parameters so it's just more information to help dictate and help to optimize how we're actually delivering those images but now we can see when we're loading those smaller images on smaller devices we can have such a big impact on the size of the image that we're actually deling so now that we're optimizing the way that we're actually delivering these images to make them as performant as possible now let's actually start to get images into our library so let's add uploading now as I alluded to earlier we're going to use the upload widget in order to easily add uploading into our application and we can see here we have an option of two different components we have the upload button and we have the upload widget now the difference between the two is the upload button is just a wrapper around the upload widget where it's just going to render a button with very simple controls where the upload widget will give you a lot more flexibility for how you render and control the experience now for our purposes we just need the upload button so we're going to roll with that where we can see the code to actually add it is pretty simple and we can see that once we have that button we get this really nice widget that gives us a lot of different options for how we upload our image and how we can control that experience so we're going to get started by adding the upload button now looking at our app the place I'm going to add this to is our navigation where we can see here I have this link which is just a placeholder but we're going to add our upload button there so it says upload it has a nice little icon and anytime somebody sees that they can easily click it to upload their new files so back inside of my code I'm going to head over to components and I'm going to open up my navbar where we can see I have that link already available now one caveat with using the upload button or the upload widget is it's a client component and at the time of recording this it requires you to use the use client directive because it's not currently bundled inside of the component so we can see here in this warning if we're using using the app router if you're using the pages router it doesn't matter but our example here is the app router so we need to make sure we add our used client now rather than opting in my entire navigation into a client component I'm going to go ahead and create a new component that's going to wrap that button so I'm going to call it upload button. TSX and if we notice here I'm using a different pattern for how I'm managing this component just out of Simplicity for this demo so I have this top level file under components but I'm going to call it constant upload button is equal to my component function I'm going to ultimately return something but at the bottom I'm going to export my default upload button now importantly let's import our clld upload button from next Cloud Nary I need to also make sure I opt this into a client components but then let's actually render out our component just to get started now back inside the navigation I can now import my upload button component I'm going to go ahead and replace my link with that upload button and just to kind of explain something here our navigation is a server component but because it's a server component I can't do client component like things such as use use effect use state or anything that's uh required inside of the client inside of this particular component but what I can do is I can render client components inside where once that branch of the component opts into the client I can do whatever I want inside the client inside of this particular component now when we head back over to the browser we can already see that this changed from link to upload and let's give it a quick try if I click it we can already see that we have our upload widget and literally that's all we did we didn't really need to do much now if we try to upload something it's not going to quite work yet because we have to do one of two things now when you're uploading to Cloud you have two options you either have unsigned uploads or you have signed unsigned uploads is basically saying you're allowing anybody to upload as long as they pass in a particular upload preset or basically a a default configuration for those uploads now we want to go the more secure route so we're going to use signed uploads which means every time we make an upload request we're going to use our API credentials our key in secret to sign that request when it's getting uploaded just to make sure that we have control over what's actually getting uploaded to our account now heading back to the documentation for a second what we're going to do is we're going to create a new API endpoint where anytime that the upload process occurs it's going to First grab that signature from the endpoint and then pass it along through the upload process now to find an easy to reference example of this we can head over to the upload widget section where we can see signed uploads we're here we're going to be able to find an endpoint that we can simply copy and paste into our project now we can see that we need to install cloudinary which we did we need to set up our credentials which we did where all we need to do is we need to Define that signature endpoint on as a prop on our upload button and then we just simply need to create this new API rout so now let's start off by creating this sign Cloud Nary parameters route so I'm going to go ahead and just copy that because we're just going to create it as it says in this documentation I'm going to head back to my code and under app I'm going to create a new folder called API inside API a new folder called Cloud sign cloud pams and I'm going to create my route. ts file inside of that now back to the documentation I'm going to again just simply copy and paste this code because it has everything I need including using the node SDK in order to sign that request so I'm going to go ahead and paste that into my project I'm going to go ahead and trim that white space I need to fix that but we can see all we need to do now is Define that signature endpoint so inside of my upload button code I'm going to Define signature endpoint and I'm going to specify it as my SL API hide myself SL API sign Cloud Nary prams but now heading back into the project let's go ahead and click upload again I'm going to now browse for a file let's go ahead and add this picture over brail we can see that it's successfully uploaded and I now have that photo I'm going to go ahead and click done but we can't see it actually in our page and that's because we're not currently refreshing the page once we have a successful upload now let's double check that it did upload though so I'm going to head over to my console and if I refresh the page here we can see that the image does now show up so I did successfully upload it now before we move on on figuring out how we actually refresh the page I want to do one thing and I like to have a little icon along with my upload button just to give a quick visual representation of what it is it makes a little bit easier to find as well in order to support icons in the project I'm currently using Lucid react we can see I'm currently using the image icon in order to show the photos option inside of the sidebar which if we looked at the left hand side of the template we can see it readly available there Lucid react is really easy to install if you don't have it yet inside of your project so you go can go ahead and configure it there if you're following along with the template it should already be ready to go but once we're there we can head over to the icons page where we can search for and find the different icons we want so I'm going to go ahead and just search for upload for instance and we can see we have a bunch of examples now the one that I want to use I'm going to Simply import upload from Lucid reacts and now we can actually break down our upload button components just to make it a little bit easier to navigate around I'm going to close tag that but then inside what we can do is anything you pass as a child into the upload button it's going to render inside of the actual button itself so I'm going to add my upload icon and then the upload text back inside now if we look back at the project we can see that well it worked but not quite as we expect so let's add some Styles now first of all I want to resize that icon a little bit so I'm going to add class name and specify width of four height of four and we can see I'm using Tailwind for my sizes it's already configured in that template you can use your own styling solution depending on what you want to use but I also want to be able to put those icons and the label on the same line and then Center Center them vertically so what I'm going to do is I'm going to wrap it in a span I'm going to close that tag and then on the span I'm going to first Define Flex to use flex box I'm going to add a gap of two and then I'm going to say items Center and I'm going to hide myself just to make sure that you can see this and I'm not covering myself up so we have Flex a gap of two to add space between the icon and the label and we're going to align them Center and as we can see that's looking a lot better we have our icon and it still works just as expected now another thing that I want to do is when we upload if I select a file again and select upload we can see that the UI just kind of sits there I have to manually select done which again let me hide myself we can see this orange button I have to manually hit done in order to close that so what kind of options do we have to get that out of the way so it's not intrusive on the UI once it finishes uploading now in addition to the signature endpoint we can Define some other options on our upload button so I'm going to specify an options prop and on this I'm going to say Auto minimize and set that to true so now when I try to use the upload widget again and select a new file we can see that it automatically goes down I'm going to hide myself again it automatically goes to the bottom right of the page and you can also configure the location of that but I'm pretty happy with the default of it being there we can even open it back up if we want and we can even upload more but we can see that it collapses down to the bottom right of the Page by default now moving on to how we're going to actually refresh this data on the page in the world of server components and client components we need to consider how they're going to communicate with each other and there's not a lot of great options or at least not complicated options for how we can refresh that particular server component from the client but what we can do is we can render that initial data as we're doing now we're going to pass that to the client and then we can use a different solution to take over and in particular we can use tan stack query where what we'll do is we'll take that initial data we'll pass it to tanat query and then any subsequent subsequent request or when we're finished uploading something we're going to add that data to the tanat query data store now if you want to learn more about tanat query or previously react query you can head over to the documentation but we're going to go ahead and just dive in and get started and work through the example so we can see we can get started by installing tanack SL react query so inside of my terminal I'm going to npm install tan stack react query now once that's finished installing I'm going to head back to my code and now we need to think about how we're going to approach this where we have two aspects of how we're going to use Query where the first one is actually the use Query hook itself which is going to allow us to make that Fetch and manage the state of that but what we need to do is also install what's called a provider around our application so that we can have access to that State anywhere inside of the tree underneath that provider now to do that we're going to head over to our layout component where here if we install the provider at the layout that's going to give the opportunity for any component in the tree of our application to have access to that query provider now the tricky thing is because we're dealing with server components and client components this is currently a server component and query needs to run on the client but what we can do is we can use what's called The Donut pattern where essentially we're going to add a client component on our page but as child we're going to still pass through those server components so it can act like nothing happened as we're passing the server components basically through that donut of a client component which is going to be our provider now I'm pretty much going to follow along with the tanack query documentation here we're under Advanced server rendering we can find server components and nextjs apppp router where if we scroll down a little bit we can see that it recommends to create a new file called app providers. jsx where we'll ultimately copy and paste this code in where we're going to create that provider which will later import into our layout so the first thing I'm going to do is I'm going to copy this and we'll go over it in a second but back inside the code under my after Dory I'm going to create that providers. TSX file and I'm going to paste that in as is now I'm going to hide myself immediately we see a typescript issue so I'm going to go ahead and type that out as children react node and we want to make sure we update that import a little Quick Trick is hitting command period when you have that selected so that I can hit update import from react and all that really did was at the top we can see we're now importing it from our react package but going through the rest I'm not going to go through this too granularly but we can see that we're importing our query client and the query client provider and really we're just using some optimized settings for making it work between the server and the client uh rendering life cycle so we're going to just kind of skip through that part if you want to look more at the documentation I would encourage you to read through that uh serers side rendering page inside the documentation But ultimately we're exporting these providers and now we want to bring it in and actually wrap it inside of our our layout so if we head back to that documentation page we can scroll down where we see that we're going to want to now import that providers file and we're going to simply just wrap our children with it inside of our layout so inside a layout I'm going to go ahead and paste in that providers and like I said we're going to go ahead and wrap our children with it and now that we have that all set up we can actually start making our queries inside of our project so we're going to head back over to our media Gallery which is where we're going to actually request that data so the first thing I'm going to do is I'm going to import use Query from at tanack I'm going to hide myself here react query and with that I'm going to go ahead and scroll down into my component where I'm going to Now set up a use Query instance where I'm going to pass in an object for my configuration where the first thing I want to do is I want to set up a query key and for that let's call it resources it's going to be an array where we pass in these query keys and then we're going to want to set up a query function which is going to be the actual fetcher for what we're going to request so let's set up that function it's actually going to be async and here's where we hit a little bit of a hitch where we actually need to be able to request these resources somehow and again we're inside the client of this of this application so it's not like we have direct access to use the node SDK here so what we're going to do is we're going to create an API endpoint where we can request those resources using this fetch request so I'm going to head back over to my sidebar where I'm going to under my API directory I'm going to create a new folder called resources and inside I'm going to create a new file called route. TS where here I'm going to export and an asyn function called get because ultimately we're going to make a get request where now I can start to import the cloud SDK to make it easier to get those actual resources so we already created that sign clowner prams file so I'm going to go ahead and just copy the snippet from the top of that and I'm going to go ahead and paste it right at the top where now that we have Cloud imported I can now destructure resources since we know what it looks like from an earlier from the page earlier going to hide myself where we're going to await cloud. api. resources and once we have those res sources I can now return the response object. Json method where I'm going to pass in my data as my resources but now back inside of our query function I can start to query for that actual data so I'm going to say uh await fetch where I'm going to hit the API resources endpoint let me hide myself again I'm going to turn that into then r r Json where I'm going to destructure my data from that and then ultimately I want to return that data but now that we have that used query set up we know that used query is going to actually return some data for us along with a lot of other things like the status of that request so I'm going to destructure my data from use Query and let's console log that out just to see what that looks like if we head back to the browser and let me hide myself here we can see that our data is being logged out and we can see that we currently have 10 resources which matches what we have inside of the actual Gallery page but we can see for each of these we have all the information that correlates to a cloudinary resource so we were able to just make that request on the client but one thing that we have here is notice that the data is first undefined but we're already quering that from the server so how can we actually pass that initial data through from the server to the client so that we have what we already have available now back inside of the code our Ed query Hook is also going to take a property called initial data where we already are grabbing those resources from the server so why can't we just pass those right along through and that's exactly what we're going to do where I'm going to take these resources and I can actually just rename this as initial resources and I'm going to set this initial data property as my initial resources but then just to make it a little bit easier on myself I can rename data to resources and now let's console log out that resource to see what it looks like and once we reload the page we can immediately see that we now only have that one resources log that includes all that data because it's using that initial data and passing it through to the client now this is working really well for being able to manage that life cycle between the server and the client but we have one problem here we want to be able to add new resources to that state so that whenever we upload an image from that upload button we're able to push it into that state but before we even get to that point one additional issue is we don't have access to that Navar button directly inside the media Gallery so what we're going to first do is we're going to take this used query instance we're going to put it into our own own hook instance and we're going to be able to share that hook between the media gallery and then the navigation so the first thing I'm going to do is I'm going to create a new directory inside of my source called Hooks and inside of hooks I'm going to create use resources. TS now inside of here I'm going to export a function called use resources where the first thing I'm going to do is I'm going to basically just copy everything and paste it into here so let's go back to the media Gallery where I'm going to grab first of all the import for used query and let's paste that in the top I'm going to grab the actual query information itself let's keep that console log in there just so that we can test it out as we're working through this we need to make sure we have that uh in instance of the initial resources so what we're going to do is we're going to allow instances of used resources to actually pass in options and inside those options we're going to take those initial resources so I'm going to first Define that argument of options and let's name this a new interface of use resources and I'm going to set up my options to reference that now here we're going to want to grab those initial resources which is going to be an array and we need to Define that type if you remember before we already created a cloud n resource so first let's grab that and let's abstract that so we can import that in both places if you remember we actually created that clowner resource at the top of media Gallery the same place that we were using it before so the first thing I'm going to do is I'm going to cut this out of this particular file and again inside of my source directory I'm going to create a new folder called types inside of types I'm going to create a cloud. TS file where I'm going to Simply paste in that cloudinary resource I'm going to export that interface of cloud Nary resource so if you're following along we grabbed the media Gallery Cloud Nary resource which we had previously created and we're creating a new file that contains that so that we can share it between the different files so now let's head back to Media Gallery where we can resolve that type issue now and I could import my cloudinary resource that I just created from at types cloudinary we can see that that cloudinary resource should be now resolved so now let's also bring that into our Ed resources hook so I'm going to go over to use resources I'm going to paste that in as well and now because I can share it between the two files I can say that my initial resources is going to be an array of those Cloud Nary resources so now let's continue wiring this up so that it works as we expected to now first of all our initial resources of course that's now going to come from our options so let's add options and let's optional chain that just in case it's not being passed in and we can make sure that we're now going to return our resources so I'm going to go ahead and return a new object I'm going to return those resources as is but now we have our basic cook configured where we can start to actually use it inside of our project so I'm going to head back over to Media Gallery where now let's import our use resources hook make sure I have a capital R from App hooks use resources and then at the top of my file I can say constant resources which I'm going to destructure from use resources and of course we want to make sure that we pass in our initial resources right through to that hook but now just to make sure that everything is still working as we expected to I'm going to go ahead and console log out our resources and if we refresh the page we can see that it's still working exactly as expected so now let's start to add that mutation angle so tanat query comes with the concept of mutation where we can wrap a request similar to what we did with the used query hook only it's meant for changing data now the problem with that though is we don't really need it because all the uploading happens automatically for us from within this widget so how can we still tap into that life cycle where we can push the resources into State and also maybe invalidate it so that it'll then refresh and get the most fresh content directly from the server so we're going to take advantage of something called the queery client which is going to give us the ability to both set and invalidate our data where specifically once we import this we not have access to do something things such as set query data where it's going to allow us to set the updated data by using the cache keys and then we're going to also use invalidate queries where we can pass in the queries that we want to invalidate and specifically the ones related to the upload we just made so starting off back inside our use resources hook I'm going to import the use Query client hook where we're going to set that up at the top of our use resources hook where I'm going to say constant query client is equal to use use Query client so now I'm going to scroll down and I'm going to create a new function and I'm going to call that add resources and this function is going to be what I use to pass the resources to eventually set that into the query data so I'm going to take that add resources I'm going to return it from my hook where then inside of the upload button I want to now get that function from the hook so I'm going to import my use resources from a hooks use resources let me hide myself to make sure I'm not covering anything up and then I'm going to destructure that add resources from my used resources hook now one thing that we immediately see is we're going to get a typescript error on that and if we head back to our Ed resources hook and scroll up to the top one thing that we never did is we never made options actually optional so the first thing I going to do is make that optional and then similarly on initial resources I'll also make that uh optional as well because we don't need to necessarily pass in the initial resources if we don't have them now going back to the upload button now that we have this add resources function I ultimately want to trigger that anytime we have a successful upload now fortunately on the clld upload Button as well as some other events we have on success so I'm going to add an on success call back if I spell that right and I'm going to set that as handle on success where now I can start to Define that handle on success function where this is ultimately going to receive results where in order to type this out we currently have to import that from the next Cloud n package so I'm going to go up to my next cloudinary import I'm going to hide myself just to make sure this is all clear and I'm going to import cloudinary upload widget results and then I'm going to go ahead and set the type for my actual results and let's just log this out for a second just to kind of see what's going on if we head back to the page and refresh and we try to actually upload something let me select my file and upload it we can see that we get that results event or we can see it's a success and then we get our info where that info is essentially going to be the resource that we have it's going to include all the information we need it includes a little extra information related to the uh upload widget success where we can see like the batch ID for instance but ultimately this is going to be the info that we're going to use in order to push it into our state so let's do just that where the results doino is going to be what we need so what we can do is on add resources we can push that directly through and we're going to accept that as an array so that in the future we can always push in multiple resources if we want to and especially just makes it a little bit easier because we know that our state is an array of resources anyway so I'm going to pass this in as results. info and we can see that we still get a typescript err because we need to cast this as a cloudinary resource so I'm going to go ahead and import cloudinary resource from I'm going to hide myself at types cloudinary where I'm going to go ahead and cast that as cloudinary resource and we're still getting a type air but let's head over to our actual add resources uh function where we never actually set that up to receive the results so first let's add that argument of results and we know that we need to set the type of this as well where we're going to receive again that array of cloud nning resources so now let's again take a quick checkpoint just to make sure that this is working so let's console log out our results from add resources I'm going to add add resources in the front of that just to make sure we know which one we're looking at and I'm going to go ahead and clean that up from the handle on success function itself but again I refresh and I'm going to upload yet another image and we can see once it's uploaded we do get that add resources results and I can expand it and we can see all the information related to it so now that we're successfully passing it into the hook let's now use that data to actually add it into the state so that eventually we want to refresh it on the page now looking back at the set query data method we want to be able to pass in two arguments first we have the query key which is similar to what we were doing with the use Query hook as well but then we have an updator which is going to be a fun where we're going to take our old data and merge it with our new data so now back inside the code I'm going to take advantage of that query client where I'm going to say query client. set query data where the first thing we need to do again is add those tags and we can see similar to query data up here I'm going to just simply copy that same query key and I'm going to hide myself as we're adding this but then we have the second thing which is going to be that updater so that's going to be a function where the argument is going to be old where we have that old data that we want to add and then we want to merge it with new so what I'm going to do is I'm going to return a new array where I'm going to spread out my old data but I'm also going to take the results and I'm going to spread that out before now yet again the query system doesn't know what kind of data I'm passing through so I'm going to go ahead and type out this old data so that I can add it as a cloudinary resource and we can see it makes it happy and if we go back to upload button we can see that we're passing through that data and we come back to the ad function the ad resources function where it's going to set that query data based B on that same query key where then it's going to again merge the old data with the new one and since we want to have it appear at the top of the list in chronolog chronological order it's going to put it in the front of that array so now let's try that out I'm going to go ahead and upload a new image I'm going to select it let's go with this bottom one where we can see after it's uploaded we can now see it immediately appear inside of the actual UI now this all works fine and well but it's technically not a representation of the server because we didn't actually request this resources list from the server we pushed it in based off an assumption that it was successfully added now theoretically it should be completely fine but just to make sure that we are getting the completely fresh data that there wasn't an error somewhere we can now invalidate that query so it then goes and tries to make a fetch request to get the real content from the server and if there's any changes we'll have that reflected again in the UI so back inside of the code I'm going to again use the query client but this time I'm going to use invalidate queries where this invalidate queries is going to take an object where we can pass in a query key and similarly that's going to be our resources now this time instead of just watching the console log I'm going to open up the network tab where I'm going to go ahead and trigger a new upload just as we usually do and we can see after it was successfully uploaded it did add it but we have another request now in the network tab where we now have that resources request that's immediately going to happen after we push it in the UI because we invalidated that query we can see we have a preview and a response of all the data that came back so we know for a fact that the image is now available in our resources list now just as a quick note this pattern is called optimistic UI or optimistic updates where as soon as we have that information we're going to push it into the UI and then later validate it now it's technically a little bit different the way that we're doing it because we're doing it on successful upload but maybe you have a listed to do is where you have that text and you can immediately push it in or maybe what we're not going to actually cover is here maybe you can grab that local file push that into the UI immediately and then later validate it on the server but either way it's a good pattern to make the UI feel responsive as you're doing that upload but we can see that if you are using the mutation function inside of a a future request you can actually just control this using their recommendation by finding the optimistic updates page inside of the tanat query documentation now moving on I went ahead and deleted some of the images that I uploaded because I want to show the next issue where we can see that we're currently showing all the images in the account including including all those sample images that come with the account now those are great for being able to test things out but we only want to show the images that we're actually intentionally uploaded into our photo library so we're currently using the resources method where if we head back inside of our code where we can either look the API resources route or we can look at the page where we're quering that we can see that we're using that resources method from the cloud API now this is again working really well for our current use case just to get the data on the page but now we can start to narrow down how we're going to query that and we can do that by using tags where what we're going to do is we're going to First tag every single upload that we make from this page and then we're going to only query for resources that match that tag so starting off inside of the upload button let's first tag every single upload that we make from this account so I'm going to go ahead and inside of my options on the clld upload button I'm going to add a new property of tags I'm going to add an array where I'm going to Simply add media that's just a pretty generic word and that's tags that's just a pretty generic word to represent any kind of image or video that I upload and right now we're currently focusing on images but it still is a good representation you can really name that every anything you want you can name it photo box like you can see in that demo that I mentioned earlier or really anything that's just going to basically represent your images inside of your library but now let's actually upload something so I'm going to go ahead and click upload I'm going to select my file and how about this nice picture of Grease where we can see once it's uploaded I'm going to go over to the network tab and let's go look at this upload request where we can see under tags we have media so now if we head over to our media library I'm going to refresh the page we can see our new picture and if I go over to my metadata we can see that it has that new tag of media so now let's try to only pull in the images from our account that matches that tag so back inside of my code I'm going to start off with the page for the server request and then we're going to move on to that API route we're under the pages app pages page where I'm making that initial request instead of the API resources I'm going to do Resources by tag where I'm going to go ahead and paste or add in that media tag and just to make sure that we can clearly see that we see that Resources by tag and I'm passing in that string of media now because we know that that's going to refresh inside the client let's head back over to that API route we're under app API resources route we're going to update that as well to resources by tag and I'm going to additionally pass in media but now if we go back to the application and refresh we should see that we only have that one image display because it's the only image in our account that's actually matching that tag so at this point I'm going to go ahead and clean up my media library a little bit I'm just going to go ahead and delete the images that I uploaded that don't match that tag and I'm just going to leave those samples in there as well it's really up to you for how you want to manage your own media library and it looks like I got a little aggressive there and I deleted the uh grease one too but we can know that we can simply up upload a new file such as this picture of Brazil and we can see once it's uploaded it's going to be immediately added to the UI now it's time for a little bit of an optimization where as we were adding this hook to our navigation for that upload button we started to create a little bit of an issue where because we're first defining our initial resources as undefined it's getting rendered that way and if we look and refresh the page we see that we don't get the image as fast as we were before and we also see immediately from the media gallery that we're conso logging out that undefined resources first so how can we address that now going back to the code I'm going to approach this by two angles the first one being if we're adding this hook inside of our navigation I don't want to even make any kind of fetch to begin with so the first thing we can do is the used query hook has a property called enabled which we can set dynamically based off of where where we're actually adding this so what I'm going to do is I'm going to add a new property of disable fetch which is optional which is going be a Boolean and then I'm going to start to destructure that disable fetch from my options which because options is optional I'm going to go ahead and default that to an object but we're going to then take disable fetch I'm going to by default make that false because we're going to default into it fetching going to hide myself so that you can see this but now we're going to take disable Fetch and we're going to say we're only going to want this enabled if we don't have disabled fetch set to true now heading over to our upload button we can simply add this onto our used resources so by adding a new object and I'm going to add disable fetch I'm going to set that to true now back inside the app if I try to refresh the page we're still seeing that resources is undefined first now the other approach we can take is because we know that we can set a query key dynamically I can pass in the tag of the query that I want to make we're inside a media Gallery we want to query that tag of media and inside of upload button we don't actually want to query anything now because of the way that that works we're only going to be working with the resources of a tag of media inside of the media Gallery as we're requesting that specific tag so what we're going to do is we're going to create a new property called tag that's going to be a string and it's going to be optional of course where inside of my query key I'm going to say that I want this query key to be resources and I also want to include my tag which is going to be options tag now additionally I need to actually pass in this tag from media Gallery so inside a media Gallery where I have my used resources hook I'm going to pass in a tag of media now if I head back to the page and refresh we can see that that image is showing much faster because we're getting that initial data from the server and we also don't get that undefined resources now the nice thing is we'll see that we will later be using this tag in a dynamic way where we're going to have different pages that have different tags but we'll come back to that later but one optimization that we can immediately make to how we're setting this up is when we're using Med media Gallery we're already using a tag if we head back over to our page under Pages page. TSX where we're actually including that media Gallery if you remember we're quering hide myself we're quering the resources by tag and we're looking for media so why not set that media tag once and then pass it through the media Gallery so we know depending on the media Gallery instance that's being used it's going to request the appropriate tag so inside of my media Gallery the first thing I'm going to do is set up that new proper of tag where it's going to be a string as well I'm going to destructure it from my media Gallery props and then I'm going to pass that tag directly into the used resources hook now on that page again I can pass in my media tag as a prop to my media gallery and heading to the browser just just a double check it is working as expected now personally when I'm creating strings like this that have an actual meaning and representation throughout my application I don't want to have to manage that tag every single Le place inside the application separately so we can Define that in a central location so that we can easily adjust that if we need to if we ever want to change that tag for instance or maybe depending on the environment or if you want to share this code maybe other people want to use other tags like I did with photo box so we have one of two options where we can either Define a constant inside of our project or we can set up an environment variable which is kind of a way I like to handle that so inside of my env. looc file I'm going to create a new environment variable and we're just going to paste that in of next public cloudinary library tag and that's just supposed to be a generically meaning uh phrase in order to describe the actual tag that I'm using so I'm going to set that as media where now I can take that head back to my application and wherever I'm using media such as this location I can add my process.env my next public cloudinary library tag or you can just shorten that to library tag whatever you want to do but because it's Cloud specific that's why I'm using Cloud there and then we can start to use that in the other locations such as the API route I'll go ahead and replace that tag which is generically getting those resources for us we can also do it inside of our page where I'm getting the resources by tag for that homepage as well as the media Gallery prop now that should cover all those instances but as last one last time let's double check and it looks like we're working as expected now one thing that we didn't cover however is we never thought about how this impacts our optimistic UI that we set up so I'm going to click upload I'm going to try to upload a new file and we can see that we get an error it says old is not iterable now the issue is inside of our used resources hook we scroll down to where we set up our add resources we set our query key for both the setting query data and invalidating to just the resources we never updated that to our media to include our media tag so it has no idea and it's trying to just invalidate data or set data for something that doesn't currently exist so we want to also make sure that we update every instance where we include that new tag so I'm going to go ahead and just break this down to to make it a little bit easier for us to read a little bit but then we can go ahead and add that same tag that we added in the other locations of my library tag I'm going to grab that and I'm going to add it to my set query data method as well as my invalidate queries method but now let's test that out and we can see that because I refreshed the page the image is actually showing but now let's try to use that optimistic UI where as soon as I upload the file we can see that it adds just as expected now I think we're in a pretty good position with our media gallery and we'll come back and we'll do some things later but next I want to make sure that I have an individual page for every single one of my images so when I click through to this I can actually view that specific image and then eventually I can make those edits now I preconfigured a page at resources SL page where we can see that it's currently similarly to what we started off with the gallery it just loads a logo here currently just as a placeholder but we have some existing UI including our editing our info and our delete that we can into as we start to add this capability so what we're going to do is we're going to take this from a static page and we're going to make it a dynamic route where then once this page loads we're going to fetch that image and then use that information to populate the page now going back inside of our code to actually find this file if we go under Source app we're not going to look under Pages we're going to look under the Resources directory where we have a layout for our resources but then we have that page directory that includes our page and we can see that it looks pretty similar to the same thing that we had for our media Gallery our homepage where we're using the media viewer component now to give our interactive UI using a client component inside of the project where this resource this page is going to be a server component where similarly again we're going to request that data using the node SDK for that individual asset and then pass it along through but the first thing we need to do is actually make this route Dynamic so we can get that Dynamic value so what we're going to do is inside of the sidebar we can see under the Resources directory we're going to rename this page directory and we're going to set this to use brackets and inside we're going to add a variable name and I'm going to use asset ID now why asset ID as opposed to something like public ID where asset ID is going to be very unique it's an easily queriable uh data value that we can use in order to do that and it's just a little bit uh of an easier way for us to confidently query our data and pass that along through the application but it's going to be a unique value that we can ultimately use to make the request using the API but just back to the sidebar for a second this resources asset ID because we're adding this in Brackets we're basically telling nextjs that we want this to be a dynamic parameter value we want this to be dynamically loaded based off of whatever somebody's going to in the browser so that means inside of our resource function which is our page component we're going to receive an an argument that's going to incl include pams which is where we're going to grab this value from now let's type this out as we're going to receive our pams and we're going to ultimately get our asset ID value and that's going to also be a string but now we can say let's console log out pams just to kind of see what that's is going to look like now if I go back and refresh the page as is just simply with that page inside if I now look inside of my terminal I can see that pams console logged out with that asset where it's now equal to page now if we go back quick to our Gallery page where we're listing out our resources I can just actually grab one of these asset IDs from any one of them that are getting currently listed out I can go back to my resources page and I can replace page with that asset ID now nothing too different should happen but we should see that our prams change from page to that asset ID so that's showing that it is a dynamic value based off of whatever is inside of this URL so now let's actually take that asset ID to actually change it but before we do let's make it a little easier so we don't have to manually grab the asset ID each time let's actually set up the links on our homepage so that whenever somebody clicks one of these they're going to go to that link automatically so back on the media Gallery component I already have my link component imported from nextjs where if I scroll down to the bottom of the page where I'm adding that clld image I already have that link component set up and wrapping around the image so all we really need to do at this point is is update the hrf in order to have that Dynamic value so instead of this hashtag that I have in there I'm going to add the template tags where we're going to say slash resources and that's going to be a dynamic value where we're going to add resource. asset ID and just to make sure that you can see that our link href that's wrapping our image on the gallery page is going to be /resources and then we're going to use a dynamic value of our resource asset ID so now inside the application if I click through to souo we can see that it does go back to that Resource page but now I have that Dynamic ID inside the URL and I didn't have to manually add that but now let's actually query for our resource on our Dynamic resources page so if we remember from earlier we configured our SDK on the homepage I'm just going to Simply copy and paste that code over rather than having to type it all out again but now we can add our media viewer inside of the media Gallery I'm going to get rid of the sidebar for a second but inside of our actual Resource page function I'm going to say constant results is equal to await cloudinary API where we're going to use the resources by assets asset IDs method and just pay attention to that Resources with an S by asset IDs with an S where we're going to go ahead and pass in our prams do asset ID now we can see that typescript is yelling at us we don't actually need to make this optional we should make sure that that's always getting passed through but we can also want to pay attention to this says Resources by ID so why are we passing in a string well this method takes both a string and an array of strings out of convenience just so that we have an option to use it however we need in order to get our assets so in this instance we're just going to be able to get our single asset but now let's console log out our results and another thing that I do want to note is where is that params asset ID coming from just to kind of confirm here that's where we set up the dynamic page route in inside of our tree here where that asset ID is going to correlate to that param but now if we head back into the application and we reload that page we should be able to hop back to our terminal where we now see all that resource data we have our results that we're conso logging out where we're going to have that property of resources that includes our single resource so like we did with our Gallery I'm going to destructure resources from this request and because we know that we're only going to pass in a single resource I'm going to pass through resources zero which is going to grab the first item of the right if it exists now again similar to what happened when we were setting up our Gallery we have a typescript issue here because if we go to Media viewer and let me get rid of the sidebar we can see that this resource that we're defining we're defining that ID just like we did before and this needs to actually be a public ID so instead of just trying to fix this again we do have that cloudinary resource type that we can now import and just use that so the first thing I'm going to do is I'm going to import my cloudinary resource from at types CL cloudinary and then make sure I have that spelled correctly I can use my cloudinary resource without an S as that resource type but as we can see we're still getting a type error and that's because we're just simply using that ID somewhere so at the bottom here we can see we have resource.id that I was able to just command F and I'm going to add public ID now if we head back to the application and refresh the page we really shouldn't notice too much different we might notice the logo is a lot bigger and that's because the resource that we're trying to query just has a bigger size to it so it's trying to fill up the space that it has but one thing we should notice is if we go over to this info panel or button here and we click it it's going to update that panel and that's where we can actually see that ID that we just updated to public ID and this value is dynamically being pulled from that Dynamic resource that we had so now not only should we show the ID let's actually show the image instead of this Cloud Nar logo so just like our image that we updated in the gallery let's update this to CL image so the first thing I'm going to do is change that image tag to clld image I'm going to dynamically update that from next Cloud Nary and just to confirm that we can see that we imported C image I like to organize the external Imports at the top we imported C image from next Cloud now going back to that we can see that it has everything we need the width height instead of the source we need to pass in that cloud Nary public ID so I'm going to change that to resource dopu ID and similar to before this Cloud Nary logo alt doesn't really make sense for our current purpose so I'm going to go ahead and delete that and technically if we wanted to we could probably pass in that public ID so I'm just going to say image public ID and that should suffice for at least having a dynamic value in there that represents what it is but now if we head back and we refresh the page we should see that we have our nice big image and in this case sollo now if I head back and go to another image such as Athens we can see that that image dynamically loads based off the route that we're getting because we're requesting the resource for that specific asset so now that we have the ability to actually display our images and navigate around to them dynamically let's start actually having some fun with this and start to edit our images where we can use transformations in order to apply different effects to our images like I mentioned a little bit earlier the transformation API is a good reference for all the different things that we can actually apply to our images but specifically because we're using CL image we can take a look at the next Cloud n documentation to get a good look at how we can more easily kind of work with these different Transformations and just a quick note that there are options to be able to add any transformation if it's not directly supported by the CL image component and if not just make sure you file an issue on the GitHub repo but if we take a look at this I'm going to hide myself we can look through all the different options available we have the sidebar that shows everything there's some really interesting AI oriented things like background removal which we'll actually use you can even change the color once you remove the background there's generative fill which we're not going to get into today but it's pretty darn cool you can also recolor remove replace but some of the simpler effects are things like being able to blur an image being able to turn it to gray scale and all those different kinds of things changing the different colors having fun with some overlays and there's just a ton of different things that you can do in order to really take advantage of the different effects and Transformations from cloud Nary so looking at the photo page we're going to work on this edit tab where if we open it up we can see that we get this panel that includes all these different tabs including these enhancements the cropping and resizing and these filters that we can add and we're going to work through all of these but we're going to start start off with the enhancements tab now inside of the code we're going to be working out of the media viewer file of course where if we start to scroll down we're going to scroll down until we get to this edit panel section and I even have it clearly labeled to make it easier to find but we have a sheet here which is going to represent that panel UI that we have that we grabbed from Shad CN but if we start to scroll down we're going to look for the enhancement section specifically where we have this unordered list that currently just has this none option so we're going to start to expand the options that we have available here so to start I'm just going to duplicate this list item I'm going to start off with how about improve I'm going to add another one of restore and then I'm going to add yet another one of remove background now if we refresh the page and reopen the panel we can see that it was updated with all of our different options but now let's try to get this set up so that we can actually store whatever enhancement we want to use in state so that we can then use it inside of the UI to do that we're going to use the Ed State hook and we're going to create a simple instance that we're just going to call enhancement and we're going to create a new one for each of the different types of editing that we're going to do but it's just going to allow us to store what kind of enhancement we actually want to apply to the image so I'm going to start setting up the state underneath my deletion state which includes a few different things that we'll get into a little bit later but I'm going to set that up with constant enhancements set enhancements and we're going to set that equal to use date and we're going to make that just a simple string now if we start to scroll down back to our page where we set up those enhancement values where we have our none we have our improve and we have our restore and remove background what we're going to do is whenever somebody clicks one of these buttons we want to store that enhancement in our state so to get started I'm going to just break down these buttons a little bit where I went ahead and just did that off camera just to save a little time but here I'm going to add onclick where I'm going to say whenever that is is clicked I'm going to set enhancement where for this one I'm going to Simply call it improve where now we can replicate that through all our other ones we have our none which I'm just going to set that to undefined then we're going to scroll down to our restore let's call that one restore our remove background which I'm going to call that simply remove background and now just to make sure that we're on the right track and just do a little quick confirmation here I'm going to console log out my enhancement and if I refresh the Page open up the edit panel and I start to click these items we can see that it is logging out that state now heading back over to the documentation for a second let's see how this is actually going to get applied to our image where if we start to look at these Transformations let's start with restore where we can see that in order to add restore we just simply need to add the prop of restore we don't even need to add a true to that that's going to automatically resolve as true and opt Us in where this restore one in particular it's going to take a blurry image and it's going to or blurry or poor quality image and it's going to restore its quality so if we look inside of our media viewer what we're going to want to do is we're going to store those Transformations that we want to apply to the image in a temporary state so that we can simply spread them out on our clld image appropriately for the different props and options that we want to use so for instance we can use Transformations which we can add as a constant at the top of the page where I'm going to scroll back up there I'm going to create those con Transformations and set that equal to an empty object to start where because we know that these are all going to be props that we're going to be passing into the CL image component we kind of already know what this type is going to be so what we can do is we can actually just type out our Transformations as our clld image props so scrolling back up to our import of clld image I'm going to import clld image props and I'm going to scroll down back to our transformations I'm going to just create a new type for this called Transformations just to make it a little bit easier to read where we're going to set that equal to CL image props but what we're actually going to do is CL image props also expects a source value and an ALT value because we're creating an image tag so we're just going to emit those two props and then allow the rest to be passed in so I'm going to use omit CL image propped where then I'm going to pass in source and my ALT but now I can Define my type on the cont inst Transformations and starting with my enhancement I'm going to say if enhancement equals restore all I'm going to do is I'm going to add transformations. restore and set that equal to true now because we're not applying it directly to the react component we do actually have to Define that as a Boolean otherwise that'll just be undefined but we are setting that restore property to our Transformations which will be spread out onto that component now heading into the browser we're going to go ahead and now click on restore and when you first click this it's going to take a little while the first time to actually run this because we have to process that with AI in the background but in my case I already clicked it and I already loaded it and we can see that by if I actually open this up in a new tab I can see e gen ReStore in the URL now this looks pretty similar to the other one let me duplicate this tab just to make it a little bit closer to see if I remove this and it didn't really do too much to this image and I mean honestly this image is pretty great to to begin with so it didn't really have much to improve on so let's actually take this image let's create a blurry image out of this and test it on that and again if we go back to where we were talking about how we were using transformation uh URL parameters we can really easily do that so the first thing I'm going to do is instead of width 3840 I'm going to Simply change this to 500 so now we have a 500 pixel image and then I'm going to add C scale and I'm going to add w1000 to scale that up to 1,000 and we can see that that's a pretty blurry version of this image but now let's actually save this image and reupload it to our media library so that we can try it out with this image and I'm going to go ahead and save that to my desktop now if we notice here quickly we are getting a webp format and if we remember from earlier we have this F Auto in the URL and that stands for format of Auto so it's going to automatically deliver the most efficient format for that browser and for that image and in this case we're getting webp now because we're uploading to cloudinary it knows what webp files are so I'm just going to go ahead and save this one as is and then if we head back over to our application again I'm going to go ahead and go to the upload page I'm going to add my new file if I can find it inside of here I think I just need to refresh that UI since it was pretty new so I'm going to go ahead and select that file we can see that it was uploaded and we have our blurry image so now let's actually try out this restore so I'm going to open back up that edit panel and I'm going to click restore and again you might have to wait a second well that was actually pretty fast and I don't know if you noticed but that was a pretty big difference let's open that up in a new tab for this one as well so this is going to be the restored image we can see e restore here let me duplicate this tab and get rid of the original one and let's go back and forth we can see that that's a pretty uh pretty substantial difference that's a lot better than that blurry image that we had and going back to the UI we can go back and forth between none and restore none and restore and we can see that we can immediately get that now that it's completely loaded so now let's wire up these other ones where we have improve and we have remove background now we already set up restore but how about let's set up improve now for this one we don't actually have an example like we did on the examples page but what we're going to do is we're going to go down to filters and effects and we're going to scroll down until we see I think no there it is improve where for this one we can pass it in as a bullan just like we did before now if you you can also take that further you can pass in a string with some different settings uh or probably a number here uh but what we can do is we can just use the Improv similar to what we did with restore so I'm going to just copy this because it's basically going to be the same thing I'm going to say Els if enhancement equals improve I'm going to add that improve and now if we click improve we can see that the colors look a lot more interesting than they than they did without it but now let's let's actually get off this blurry image and head back to a normal one where we can see that we have this nice original and and let's add it to that where we can add impr proven again it's going to take a few seconds just to process that transformation but once it does we can still see that same effect that it looks a lot more vibrant and a lot more interesting than it did on the original and again you can pass in custom settings to kind of tune that up how you want but generally speaking it gives a broad automatic Improvement to the image but now for the last one for our enhancements is remove background and similarly we're going to do the same thing if enhancement equals remove background we're going to set the proper but this time it's going to be remove background cam case so now let's try to swap to that and we can see that we immediately lose the image but let me open up my web console looks like we get a nice 420 here but let's actually inspect this I'm going to refresh my tab and reproduce this so we can see what it looks like and if I look at that image request I'm going to scroll down if I can expand this I'm going to scroll down to xld error now the nice thing is if you get a 400 level error it's going to try to provide a description reason inside of this xld error header now for this particular case we don't have an active subscription for the cloud AI background removal now background removal requires an addon in order to make this work but the good thing is there's a nice free tier so that we can just start testing it out now just as a quick note it is in the documentation specifying that you need the addon if you want to find a link to this it's easily available under the remove background property where we can go ahead and click through and we can learn more about the actual addon but heading over to our cloud console let's go over to the settings with this little Cog here in the bottom left we're here if we scroll down on the left we're going to find under explore the addons page we're here we can immediately see at the top left that we have this Cloud Nary AI background removal now once we get to this page we can see a little bit more information about the addon including the pricing TI for this specific addon where here we get 15 free every month so here we're going to want to go ahead and enable the free account but now that we have this enabled let's head back over to our app where I'm going to get rid of the web console and now let's refresh the page and try this again where I'm going to click remove background and we can see that we still lose that image but let's open on that web console again where this time we're getting a 423 air and that's a little bit different where the way that the background removal works is it's first going to return a 423 and that 423 means it's processing in the background so the subsequent request though whenever that finishes are going to deliver a standard request so we can even see that the C the image component pulls until that's available where now we can see that it tried to remove the background now I would imagine that's a little bit of a tricky one there's a lot of detail in that and it's not the most clean and crisp image to begin with even though it's pretty nice so let's try to use something that's a little bit easier to work with where if I'm going to head back I'm going to upload a new image I'm going to go ahead and select one and let's go through here I have an elephant picture somewhere that I like here we go we have our nice elephant friend I'm going to try to upload that one we're going to navigate over there we can see that we have our image I'm going to go ahead and try to remove background from this one and we can see once it's done processing this did a pretty good job and we can toggle back and forth between the one with the background removed and with it not and we can see just how well that it did so imagine now if we wanted to we can go ahead and change that background we're not going to add that kind of feature inside of this application but just as an example playing around with the UR with the URL parameters again let's just add a another transformation of B blue which is just adding a blue background and we can see how easy it was to add that background we can even add images underneath that or really whatever we want to transform it into something completely different but I need to try to keep myself in the scope of what we're actually Building inside this application and now let's update the UI a little bit so that when we actually select something it makes a clear indicator that we selected that one and we can also update some icons to make it a little bit more representative of what we're trying to do now looking back at the UI for a second the way that we're currently showing these elements is I'm adding this border of white now we can dynamically add that border so that any item that is selected only receives that white border so let's start off with the undefined one where let me first cut out this border white I'm going to add a dynamic value where I'm going to say if enhancement doesn't exist if enhancement doesn't exist I'm going to add a Turner where I'm going to add the border of white because that is going to be our TR the value and then otherwise I'm going to add border of transparent now looking at the app we can see that the Border actually disappeared from none but that's because we have remove background selected of course so I'm going to go ahead and select none and we can see that we get that border and if we go off we don't have it so let's add that to the other ones so I'm going to copy that Turner and I'm going to scroll down first to improve let's replace our border white where for this one it's not going to just simply be if it doesn't exist we're going to say if enhancement equals improve let's go ahead and copy this to the other ones so I'm going to say for my restore one if this is restore and then scrolling down one more for remove background we're going to say if this is remove background we can already see that the UI updated we're showing improve right now if we go ahead and select off of it it doesn't we actually see a really nice difference there with the improved one but that's kind of be uh aside from the point but we can see that depending on the one that we select we have a nice UI indicator for it so how about these icons though for improve I like the idea of just using this wand that we have at the top one so I'm going to start there where we can see inside of those tabs I'm using wand two from Lucid react just to kind of show where I'm grabbing this from if you remember from earlier we install Lucid react under icons we have wand and we have two different ones and I'm going to use wand two so now for my improved option I'm going to update that from ban to my wand 2 and let's just be honest here I already know what icons that I want to look up so I'm just going to look them up directly but you can feel free to look through all these different ones but for ReStore I found this icon that I like which is this pencil ruler and I think that represents a good uh restore option so for ReStore I'm going to update that to pencil ruler and I already know that name so I'm going to add a quick import update to my Lucid react with that little shortcut as usual I'm going to then go down to my background removal one where for background removal I liked the idea of using scissors for this and we can see we have a few good options for scissors here now there was one that I actually liked a little bit more than this if I type in hyphen here we can see that I get this one with the dash lines on the bottom and I liked that a little bit better but for some reason there's some searchability issues with this and even the name of the Imports didn't quite correlate with the names that we see on here so I'm just going to skip that one so I'm just going to use this Square scissors one we're inside of the app that's going to be scissors Square I'm going to then be able to update that import by using the command period like we saw before so that we can easily import that into the top of our project but now heading back into our application we can see all those lovely icons that have a lot better of a representation of what that specific option is trying to do now one other thing that I want to do is if we remember when we were selecting through the different options sometimes it would just show the original for a second before we got the new one now if we go back to one of the other images that we haven't touched yet such as this train and I open the panel if I go ahead and hit something like restore we can see that is just showing the original image for a little bit now I don't I know that it's loading in the background but what I wanted to happen is I want to show some kind of loading State now the first thing I can do is because this is a react component I can set an updated key based off of the information that's inside of the project so that I can refresh that once I have a new transformation so what I'm going to actually do is I'm going to add key and I'm going to set that equal to json. stringify and I'm going to pass those Transformations into to that method now just as a quick note stringifying like that could potentially be expensive if you're trying to have a really performant UI so we're really just using this as a kind of hack in order to force that component to refresh when we're changing the URL but heading back inside of the UI let me hide myself we already tried restore and I don't know if you can kind of see the difference there that there's a very subtle difference but it does look restored but that's beyond the point but if I try another one we can see that we have it immediately go to Black and that's because is updating to that new URL that just hasn't updated yet so we can see that we're going to get the similar effect with remove background again remove background Works a little bit differently because of how it's processing but it's still going to give that same similar experience so let's actually try this on another image so I'm going to hit back and I'm going to go to the Sao example since I don't think we have added the effects on here and let's go ahead and try that on restore again we can see that we immediately lose that image because it's now loading that new URL and then as soon as that is loaded it's going to pop back in where now we can see that we have that restored version now I think that's a better experience than what we had before because it doesn't show a delay in the UI so once you click on that button it's immediately going to update even though it's in a loading State and to be honest it looks a little broken because it's just pure black right that's the canvas in the background that's not really indicating a loading State now one of the nice things about the next image component again which CL image wraps is we can add some placeholders using SVG so if we look at this guide that I have on the nextcloud N.D site we can scroll down and we have a few options including a blurred image as well as being able to show a shimmer effect now it's kind of hard to see if we're just looking at this here let me open up my network tab I'm going to go ahead and throttle my connection so that we can actually see the loading indicator I'm going to go ahead and hard refresh and if we try to look down here maybe I actually need to also keep my cache disabled so let's try this out if I hit hard refresh we can see we get that blurred placeholder if scroll down we can see that we get that Shimmer effect let me try that again we see we get that Shimmer so it just gives a little bit better of an effect for when it's loading inside of the application so I'm going to go ahead and try out this Shimmer effect so I'm going to scroll down and I actually have all this code really easy to copy and paste right inside of the documentation so let's get started for this one we want to make sure we're in the correct router I'm working in the app router so I'm going to go ahead and copy this snippet and when we're using this Shimmer effect we probably don't want to have to Define this on every single instance of CLD image so we're going to create a little simple wrapper around our CL image component so that we can apply this Shimmer to all of our different images so opening up my sidebar under components I'm going to create clld image. TSX and again I'm using the similar pattern as upload button just because out of Simplicity but now let's go to hide that sidebar constant CL image is equal to my new component function and I'm going to export my default clld image now just so I don't this from my clipboard I'm going to go ahead and paste all this Shimmer code at the top of Cl image but now we need to actually import CL image so that we can render it inside of this component so at the top I'm going to import clld image but I'm going to import it as cldd image default from next cloudinary because I don't want to have a name collision with the actual CD image uh component that I'm defining there but what I'm going to do is I'm going to take this I'm going to add it as what's getting returned and then I'm going to just simply spread the props out on that component so I'm going to add my props and because we need to type that I'm going to get my CL image props I'm going to Define that as my type for my props and then simply spread this out on my CL image default now finally we need to actually use this data URL and if we head back to the documentation where we had this demo we can see that the way that we're going to do this is we're going to Simply set that data URL as our placeholder so back in my code I'm going to Simply set my placeholder value to data URL now hold up we have another type era here that we have to address and I think it's because how we're creating this data URL that it just doesn't like it but what I'm going to do is at the top of this file I'm going to first import image props from next image and then I'm going to scroll down and let me hide myself what I'm going to do is I'm going to say data URL as image props and then I'm going to reference specifically the place holder but now of course we need to actually use this component so I'm going to head back over to my media viewer I'm going to go to the top of the page I'm going to get rid of Cl image from nextcloud Nur and then I'm going to import as a new component my clld image now heading back to the application to test this out I'm going to upload a new file just so that we can actually see the loading experience for this so how about we update upload this one with some nice Northern Lights I'm going to go ahead and go to that image we can already see that we're getting that nice Shimmer effect in the back there but once it loads even further we can go ahead and open that edit panel and if I go ahead and click something like restore we can see that we get the similar experience where we now have a nice loading indicator to show that that image is actually loading something in the background but next let's take this a step further and let's start to add some cropping and resizing now this is going to work really similar to the enhancements that we added where we have this cropping and resizing section we can see that we already have the original setup here and now we're going to just add a few standard formats now the ones that I think make sense to add I'm going to add Square I'm going to add landcape and I'm going to add finally my portrait now like before I went ahead and just broke down these buttons just to make a little easier to read as we're working through this but I'm going to go ahead and add my click Handler on click and I'm going to say for this one I'm going to create a new instance of State called crop similar to what we did with enhancements so I'm going to say set crop and I'm going to set to undefined but now let's actually set up that instance of state I'm going to go back to the top of the file where we have our enhancement and I'm going to just simply clone that to start I'm going to make that set crop going to make sure I update that c it's also going to be a string but now I can update for the other ones I'm going to have my Square set that to square I'm going to have my landscape one simply landscape and then finally my portrait where because we already ran through one example of this we kind of already know a little bit of what we're doing already and in particular we know we need to set those status indicators so I'm going to go ahead and just set those now where I'm going to copy this code from the enhancement where remember if we're setting the active value we're going to set it of a border of white otherwise we're going to have a transparent border just to give a nice little indicator that it is active so for each and every one of these let me first just clone this for each one I'm going to paste it in instead of border white at the end here and then I can update my enhancement all to crop and I'm going to say first of all for the top one that needs to be if crop doesn't exist for my next one that's going to be if crop equals square and then for my landscape one and finally for my portrait now back in my app if I go ahead and try this out we can see that that part is working so now let's actually add the transformations now this is going to look pretty similar to what we did with enhancements but it's going to include a little bit more math because when we're cropping and resizing it's going to depend on the width and height for how we're going to actually handle this so let's see what I mean here we're let's start off by saying if crop equals square and if you think about when we get our width and height if we have a width that is longer than a height we probably want to use the height as the basis of the square right where alternatively if we have a height that is larger than our width we would probably want to use the width to crop that down with without having to try to upscale it or something along those lines so let's first check that value I'm going to say if resource. width is greater than resource. height I'm going to say transformations. height is equal to resource. width otherwise I'm going to do the opposite and I'm going to say the width is equal to the height now finally because of the way that the image component actually crops on the URL we kind of have two different ways of of doing this where one along with the responsive sizing we can crop everything after any Transformations are applied and more often than not that's probably okay but we want to actually crop the source of the image before any Transformations are applied that way we don't run into any wonkiness including things like relative sizing that might change how the image is actually getting cropped so what we're going to do is we're going to specify transformations. crop where we're going to set that equal to to where we're going to first specify we want to crop it on the source by setting Source equals true and then I'm going to use a type of fill for that crop but we can see that type error went away it might have just been a little bit laggy with my IDE but now let's actually check out this Square transformation back inside of my app if I go ahead and select Square we can see we get that nice loading State and then eventually when it loads we now have a square image where previously we had that nice tall image now just a kind of pop in and see how this works on the URL parameters just so we can kind of get that idea we see that we have that crop of fill and we have that same value for the width and height which of course gives us gives us that square The Fill crop means that it's going to take up as much space as it can within those bounds but then we can see that we do have that twostage cropping and resizing that I was alluding to where we could technically include it by default along with this but again we might have some transformations in between those two things and it makes more sense to crop the source of the image before we apply any of those other Transformations and this is probably more relevant if you're using things like overlays or other kind of relative size Transformations but it's just kind of best practice to kind of get in the habit of doing that but now we have two others that we need to actually apply so we have our landscape and portrait back inside the code we're going to do a similar thing for each and every one of these but not exactly the same so I'm going to start off by saying else if crop equals landscape the first thing we're going to do is we're going to apply that same crop to both of these so let me just copy and paste this one between both of our different Transformations we have portrait as well as landscape but now is where we need to actually do a little math so let's think about this for a second if we have an image that is landscape let's make that 16 by9 that's a pretty common landscape format and if I have a different width in a height what I ultimately want is I want to have a normal width that I kind of fix in on and I want to set my height relative to that width now you can probably go the other way around depending on what you want to do but ultimately let's use that as the basis for how we want to actually Define the height to transform this into a landscape image so I'm going to start off by adding transformations. height and I'm going to set that equal to resource. width but then I'm going to actually divide resources width by the ratio that I want to apply so that's going to be 16 by 9 now that's probably going to give a fraction or a decimal in this case and we want that to be a nice integer so I'm going to go ahead and wrap that with math. FL that way it's a little bit easier to work with especially when we're trying to not have some kind of like sub pixel rendering now back inside the app let's try this out real quick I'm going to go ahead and refresh the page just to make sure that that uh settings is all completely up to date but now let's try to set that to landscape where we can see that it's already working and we can kind of already see the the width and height of what's actually happening now let's close this but we can see that it automatically cropped that image to that landscape format now that image looks a little grainy to me I think that image just itself isn't the highest quality we can see that if I zoom in on this it isn't the highest quality image to begin with but we can see that all we needed to really do was pass in those Dynamic values along with our crop of fill in order to really easily get that nice crop now let's go ahead and try to test this out another one just to kind of see another example where let's go ahead and upload an image I have this nice image here going to upload it going to select it and as it's loading I'm going to go ahead and open up the panel where we can find that crop and let's try to set that to landscape and one thing that I wanted that's interesting that I wanted to point out is not only is this going to crop our image but it's going to do so intelligently we can see that it's trying to find the most interesting part of the image and crop to that now let's open this up in a new tab to try to see what's going on where we can see that in the URL we also have this G _ Auto that stands for gravity of Auto where gravity is basically going to be the focal point or the anchor of wherever we want to set it for the image Now by default with Cloud Nary if you don't set it it's going to default to Center but with cl image and the next Cloud Nary Library we're automatically adding guto so it can be a little bit more intelligent for how this works but let's kind of see what this looks like if I remove guto we can see that we get a different crop entirely and it's just using the center and we can see that we have that reflection but that's not really giving the most interesting part of the shot which is the image itself so we can see that when we have guto it's determining that this is the most interesting part of the of the image and it's prioritizing that in how it's cropping the image but now that we have the landscape all covered let's now add portrait so this is going to look really similar I'm going to go ahead and copy and paste this in only we're going to swap the different values so it's going to be Transformations width and Transformations height and now I'm going to go back and let's select an New Image or upload a new image for fun so I'm going to go ahead and select a new one let's go ahead and add this one once it's uploaded I'm going to go ahead and open the edit panel let's go ahead and select portrait this time and we can see that it's of course loading and once it loads we can see that it's actually zoomed in way too far and we just got to make a quick tweak to the application here now this was intended to be somewhat out of scope for this project but we can kind of review what's actually happening here for how we're displaying the image because one of the problems that we wanted to solve is how can we display that image within the canvas so that it's responsive no matter what the viewport is going to look like whether it's tall or whether it's wide which can be challenging when you're just trying to use CSS alone now with JavaScript we could probably do that but then we don't have to add all that JavaScript so what we're doing is inside of this application we're first determining the canvas height and the canvas width we're determining if it's a square landscape or portrait image and then we're adding different styles to the image based off of that so if it's a landscape image we're setting a Max width along with the width of 100% and a height of Auto where if it's a portrait or Square we're setting a Max height of that actual height we're defining a height of 100 viewport height and the width of Auto and again this gives us the ability to have an image that's going to scale nicely inside of that canvas in the image viewer now where that's getting applied is if we go down to the bottom of Cl image we're just setting that in the Styles tag but ultimately the issue here is we're still using the resource height we're not using the trans trans formations height so what we're going to do is we're going to add to the beginning of this we're going to say if transformations. height actually exists we're going to use that first and similarly we're going to do the same for our width so we need to make sure we update that width as well but as soon as we update that value we can now see that we do have that nice portrait image and it's able to scale nicely so I can show you that I'm going to close the panel we see that it does fit really nice and Center in there it's going to scale nicely if we go back to the land Cape version whether that's that or the original version let's just go to the original and I close we can see that it's dynamically based off of that value going to scale really nicely inside that canvas so just a little quick CSS tip there but to my point if we go back to that portrait image that was the whole goal here where we do now have that nice portrait image that we were able to dynamically crop and resize so now after we have that we have all the different ones we wanted to add we have our original which is just the original we have the square we have the landscape and we have our portrait so now I think the last thing that we need to do here is actually just update these icons now luckily for us we have some pretty simple icons we can use we're going to just simply use Square we're going to use rectangle where we have both a horizontal and we have a vertical rectangle so let's go ahead and add those we have our Square which is going to be square we can go ahead and import that we have our landscape which is going to be rectangle horizontal we can go ahead and import that and then finally our rectangle vertical and finally import that did I spell it wrong it looks like I didn't spell it wrong it looks like I just simply tried to do it before it was actually ready for it but now we have all those Imports imported and our updated UI to go along with it so I think that's looking pretty good let's take a look at what we got so far we have both of our enhancements with all the different options we have our cropping and resizing with all of our different options and now finally we get to add our filters now our filters are again going to work the same exact way as we did our enhancements and our cropping but a little bit more fun where we can see here we're using an image to display this because the nice thing about this is because of the way that it kind of works it's a lot easier to show A visual representation of it inside the UI since we can just show a bunch of square images that include that filter rather than trying to wedge in all those different sizes all the different enhancements and having all that processing in the UI this is going to be quick and easy for being able to show a visual way to show those different filters and effects so the first thing I'm going to do is actually just update this image to a clld image so let's add CL image we can add this as our resource dopu ID we can set this in a second here but with our resource and height we don't need that image to be that big looking inside of the panel after it updates we can see that well it looks okay we have our image it's using that re resource width and height but let's actually open this up in a new tab that image is way larger than we would ever need in that little space let's actually see what the rendered size of that is if we look at that that's only currently 156 pixels wide so because we're using Dynamic cropping and resizing I can just simply set that value on the image itself so I'm going to set my width as 156 and I'm going to also set my height as 156 because instead of showing that original size I'm just going to show squares so that it always looks appropriate and doesn't create really long list and it doesn't create really short list it's pretty consistent in the UI now the only thing I'm going to add in addition to that is crop of fill so that it takes that space and actually gives me that crop otherwise it's just going to use that value in the Dom which is just going to kind of skew it but we can see that it was already updated and we now have this nice little representation of our image and best yet if we look over this image we can see that the intrinsic size is that 384 and it's able to do so because it's generating that dynamic sour set of the one times and two times image and because I'm on a retina display it's showing that two times image so now at this point let's actually have some fun with this and start to add some filters probably some of the easiest filters to add to images are called artistic effects in Cloud M and if we look at some of these examples here we have a ton of different filters that we can apply we're not going to add all these I'm just going to pick a select few but ultimately the way that this syntax works and let me look at the URL Syntax for a second here and hide myself we can see that the way that this works is it's eore art and then that filter name inside the next Cloud documentation it's going to work a little bit differently where a lot of these are going to just be top level options that we can add where for instance let's add cpia which is a pretty common filter we I'm going to go ahead and clone this list item where let's now add cpia and we can already see in our panel that it already added that second option with that cpia effect so now let's add two more where let's clone this another two more times and as far as what filters to use how about I want to use Sizzle for this one now Sizzle is not available as a top level prop but what is is this art prop where we can pass in any of those strings that correlate to one of those artistic filters so back on CL image for my next filter I'm going to change sepia to Art equals Sizzle and looking inside of my options we can see that it gives a nice effect to that image now as my last one how about we use grayscale cuz that's a good common one to want to use so this time I'm going to replace cpia with grayscale and we can see we have nice four options including the original for the different filters that people can add and you can feel free to add as many as you'd like now be sure when we're adding all these to add an ALT description for all these such as grayscale we can add our Sizzle we can add cpia and then we can keep no filter when we want that undefined but now back at the top of the code let's do the same thing that we did before and now create our state for filter so I'm going to go ahead and clone my crop I'm going to set that to set filter update the F there and now for this one I'm going to scroll below my crop where I'm going to say if filter where I'm going to do things a little bit differently than I did for the past two because we know that two of these grayscale and sepia are top level props so instead let's do I'm going to create an array that includes grayscale and my sepia and I'm going to say if this array includes filter then I'm going to actually do something in a second here but we can see we do get a type error so we also need to add if type of filter equals string just to make sure typescript is actually happy here but now let's actually add the transformation to our Transformations object so I'm going to say Transformations filter equals true because we're basically setting that Boolean on that prop to True since that's what it accepts and we can do a similar thing to that with the enhancement because specifically restore improve and maybe not remove background unless you rename the key for this but these all can do that same thing so you can apply the similar approach to that but for this one we can see we also need to make typescript happy for this so I'm going to say as key of Transformations and we can make sure that that's going to specify that that key needs to be included as part of that Transformations type so we can see now that if we have a filter that includes a top level prop let's just simply apply it as a Boolean and for the last one we know that if it's Sizzle we just need to set that value as the art prop now technically we could probably do a similar thing to what we did with the top level props where we know that these art filters there's going to be multiple values of those so if we look for all the keys that are going to be art filters we can apply it to that singular prop so what I'm going to do is I'm going to copy this if statement and I'm going to say else if filter equals string and we can pull that up to make it a little bit cleaner if we wanted to but I'm going to replace this array and I'm going to say Sizzle and honestly we could add all those other filters we want such as Frost if we want but for now I'm just adding only Sizzle but then we can say if transformations. art equals filter that way it's going to apply whatever art effect that we include in here as an art filter now we only coded up the core Logic for this so let's actually make this interactive and work the nice thing is we already did this two other times so we know exactly what we need to do we need to set these onclick handlers for each and every one of our different options and make sure that it has a dynamic value so that it shows that border only if it's being used so I'm going to go ahead and first of all collapse down these buttons like I usually do just to make it a little bit easier to read as we're working through this but now I'm going to go ahead and first of all copy that on click I'm going to add this to each of those buttons and then I'm going to start to actually set what that's going to be so we have set crop that'll be set filter and then I can start to add my undefined I'm going to add my sepia Sizzle and finally grayscale now of course we need to also set our Dynamic borders so let's go ahead and copy that as well so we have crop equals portrait I'm going to replace this border of white for each of those and now set this to be filter so if filter equals or rather if filter equals undefined of course if filter equals CIA if filter equals Sizzle and finally filter equals grayscale so when we pull it up we can now see that it's currently selected on no filter because we don't have anything selected but let's try adding sepia where we can see after it loads we now have that CP effect if we want to add sizzle we get Sizzle as well and finally grayscale and we get that nice effect now to be clear it's only going to take that long to load the very first time that you run this uh filter or whatever effect because what's actually happening behind the scenes is cloud Nary is going to process that image the first time and then it's going to store it in Cache so we can see as we're flipping through these images now it's already cach on cloud CDN so it loads super fast but what we can see is we now have these filters and you can really add as many as you'd like to really give a cool effect for the different images that we have but now we have one problem I was able to add all these really cool filters and effects to all my different images but how do we actually save this now as you might have noticed as we've been working through this we do have this save button and we also have this little drop down for save as copy so we can just hook into these and we can trigger a save on the image itself to get this moving so inside of our edit panel at the bottom you'll find the sheet footer where we can see that we have that save option which is just a button that we have available and we're using this drop down menu from Shad CN in order to show more options and specifically we're showing the save as copy now previously the only uploading that we've done so far is using the upload button and that's all been handled automatically for us so now we need to create our own endpoint so that we can send those uploads straight to Cloud now starting off let's add the click Handler to our save button so I'm going to add on click and let's call that handle on Save and I'm going to go to the top of the file so I can Define this function and the way that I like to structure my components is I like to have all the state and then I have the use effects kind of after that and then I like to define the functions after that kind of close to the bottom just to make it a little bit easier for me to kind of find where everything is so how about with these already defined functions I'm going to add my new function of handle on Save let's just add a little note here CU it just helps it easier to scan and find these things now to actually save this image the first thing we need to do is we need to grab the data for the changes that we're actually going to save to this particular file now the way that it's structured is if you remember all these are just URL parameters inside of a big URL so what we're going to do is we're going to just grab that URL and then we're going to send that to the actual upload process now in order to construct that URL we don't need to do any fancy hacking around to maybe grab it from clld image we can import a new function called get clld image URL now you can learn more about this inside of the next Cloud n docs but this is going to have the same exact API as CL image only you're passing it as a function which returns a URL so I'm going to copy that I'm going to go to handle on Save where I'm going to now create constant URL is equal to my get C image URL and I'm going to actually go to CL image which is the bottom one I'm going to grab all these props including the transformations and I'm going to actually paste them inside as my options and I can get rid of the alt because that doesn't matter I can get rid of the Styles because that doesn't matter but I can now change these into properties so that I'm passing that through and basically constructing it the same way that I would for the CL image to just grab the URL now kind of proving that this works the way that I'm talking about let's conso log out our URL and now hitting the save button we can see that it spit out a URL but now let's open that up in a new tab where once it loads we can see it's the exact same image that we were actually seeing inside of our media library now before we actually pass this URL through as is and save it one thing that I do want to call out is if we look back in the URL remember we're including F Auto by default which inside of a browser it's automatically going to deliver that most efficient format but when we send this to a serverless endpoint it's essentially a node environment and we're not going to have that signal from from the browser to determine what format to actually send through so we probably don't want to include F Auto it'll probably work but it just will potentially give unexpected results so what we want to do instead is we just want to remove F Auto from this picture entirely so that we don't need to consider and be a little bit more consistent and uh reliable for the results that we get so because get CL image URL and clld image use F Auto by default we need to opt out of it so what we're going to do is we're going to also pass in a format of of default which is just saying that we want to use the default format that is inherent to the image itself now to similarly point out another one we also have q auto which stands for quality of Auto which I don't think we covered yet which is going to automatically compress the image to a point that's not going to be visually different so we're trying to get as high quality of a result as we can by compressing it as much as we can it uses AI under the hood to do that which is pretty amazing but nonetheless it depends on if we want to upload the original asset or if we want to upload a compressed asset and I think because we're going to now save that image and then in the future we're we might apply more Transformations we probably want to use the default quality right that way we're not overc compressing things again and again and again so let's do the same thing that we did with format but with quality so I'm going to go ahead and duplicate this and add quality of default and again when you're using these URLs inside of the browser and you're showing these to visitors you always want F Auto and Q auto because that's going to give your visitors the best experience possible but we're going to be taking this URL and we're going to be overwriting the original image with the new Transformations so we probably want to retain as much quality as we can inside of our original asset now just to kind of drive that concept home a little bit more is I want to point out that inside of your media library we have all of our originally uploaded Assets Now when we create those Transformations we can create new versions of that as much as we want with those little URL parameters but that never impacts that original image so what's happening is we're creating derivatives of those where you have that or original image and then you can apply Dynamic Transformations as much as you want but again those never impact the original image but what we're going to do is because we want to apply those Transformations and then save those Transformations we will overwrite the other the original image now just to be clear we're also going to be adding an option to save as copy so that you have the option to either overwrite the image or you have the option to save it as a copy depending what you want to do but just making clear what we're actually going to be doing here but now that we have this generated URL that we can use to save our image let's actually save it so what we're going to do is we're going to create that API endpoint so that we can send this URL and then overwrite the file so I'm going to open back up my sidebar where under Source app API I'm going to go ahead and just duplicate our existing resources API and I'm going to call that upload that way it just gives me a little bit of a starting point where we already import the SDK we're configuring it so it just makes it a little bit easier for me but what we're going to do inside of here is first of all it's currently a get let's make this a post because we're going to be sending data to this endpoint and then we want to change this from actually requesting a resource to now uploading a resource so I'm going to get rid of the sidebar just to give us a little bit more room but I'm going to say constant results is equal to A8 cloudinary do uploader do upload and then I'm going to pass in my URL as that first argument and this upload option takes a few different formats including actual image data so you can check out the documentation but because we're only ever going to use a URL I'm going to just simply pass through that URL as Z now as far as getting the data to our endpoint we kind of have two good options where we have form data and we have Json now we form data would probably be the best option if we're actually passing in raw image data but because we're only ever going to be using a URL in our instance Jason probably works just fine so what I'm going to do is first off this post request is going to take a first argument of request which I can type out as a standard web request and then I'm going to say my pams is equal to await request. Json and then I'm going to actually destructure the URL from that Json now once we actually have the results we can simply pass this back as the data but let's head back over and let's test this out before we do anything else back inside my handle on Save now I can do await Fetch and I can do my SL API SL upload I'm going to set the method of post I'm going to add my body which will json. stringify and we'll add our URL now we can see I'm getting a syntax are on a wait and that's because the handle on Save I never made an async function of course but then let's add constant results for our fetch request and let's try to actually log that out I'm going to log that out separately from the URL just so that we can debug if we need to so pulling that back up I'm going to hit save and once that upload returns first of all we can see that URL and we see that we do get a basic response and we get a status of 200 so it seems like it's okay now I never actually uh transformed this into Jason let's see if I can just store this as a global variable instead of having redo it let's do await temp one Json and we can see our data which is going to include that uploaded asset so that means that it worked perfect now we have one problem here this flow would actually work perfectly for save as copy but we want to actually save and overwrite our existing image now heading over to the cloud Nary upload documentation for a second let's scroll down until we get to this public ID parameter now what we want to do is we're currently uploading that file but we're just uploading as a new file what we want to do is we want to overwrite the existing file so what we can do is we can pass in that public ID of our existing file so when we we do so we're saying we don't want to just upload this we want to overwrite that public ID now another parameter that I also want to point out is overright where we can see here this is going to allow us to control whether or not if we pass in a public ID that we do overwrite that existing asset now this defaults to true so we don't actually have to set it but if you want to try uploading with your own public ID and you don't want to overwrite if it actually exists then in that case you would want to set it to false but we're not going to set it to anything because by default again it is true so when we use a public ID it will overwrite that file for us so what this practically means for us is inside of this upload request I'm going to also add public ID which is going to be our resource dopu ID now over inside of the endpoint I'm going to also destructure that public ID and then I'm going to add that to the upload where we're going to specify upload options here now I want to create this upload options object on the Fly because we want to do this dynamically specifically because we're going to reuse this endpoint for our save on copy we don't always want to try to send in a public ID so first off I'm going to create constant upload options and set that equal to an empty object but then I'm going to say if type of public ID equals string let's Now set upload options public ID to our public ID now to keep typescript happy let's make sure we find this as a record with a string string but then I'm going to take these upload options and I'm going to pass it in as a second argument to our upload method so now let's give this a try again so I'm going to go ahead and click save and we're going to wait a second if we want we can open the network request but we already see that we have our results and again I forgot to log it out as Json so let's store that as a variable and then I'm going to do the same thing and await that to my Json and if we start to look at the data we can see that this should be the same image signature or the same URL as it was before except maybe a version change so let me open up this image in a new URL and we can see that we do have that new image and we can see if I actually try to refresh the page on the main image itself that that's also updated as well I now have the ability to go in and crop and resize this new image to however I want and then of course save that optionally if I wanted to but there's a little bit of an edge case that we need to cover here let's go back to one of our original images and let's let's try this one for instance where when we looked at this image we're looking at it without any URL parameters with it so we never actually looked at the original image in its original state so let's just open this image up in a new tab for a moment I'm going to get rid of all the URL parameters associated with it just so that we can prime that in Cache but now I'm going to add some filters to this let's go ahead and just add some cropping and resizing let's add one of our other filters to it how about for this one let's add CIA I think that looks kind of nice and we can let it load for a second it probably doesn't matter too much but ultimately we have our image and now let's try to save that so I hit my save just like before let's let that load in and something actually happened this time we're getting a 500 response what's going on here if I open up the terminal I get this error of error in loading that URL now as I mentioned before when we're actually loading this URL from cloudm the very first thing that it does is cloud Nary tries to process this image apply all the Transformations and everything to it so that it can then store it in the cach and afterwards we can see that it loads super fast right but in that process if we try to upload the image before it was ever processed it needs to both do that processing on the Fly and then upload and it might not always be able to do that within the timeout time or generally speaking it's just probably General best practi is not to try to upload an image that also needs to process first so what we can do is we can prime that URL and preprocess it so then we can then push it straight forward to the to the uploader function so all I'm simply going to do is before we actually do the upload request I'm going to add a wait Fetch and then I'm going to pass in that URL and that's simply going to Prime that URL for us and preprocess it for when we actually upload it and as while we're here I'm going to now transform this result to Jason just to make it a little bit easier to read so now let's go back and I'm going to go ahead and try that again and this time we can see we got our results and it looks like everything was happy because we did get a successful response now here's another snag that we're going to hit if I go back to this URL and I actually try to refresh the page we can see that we get the original image where what's going on we just saved that image and overwrote it right now if you remember before we hit that first snag the thing that I originally wanted to point out is that we were priming this original URL if you remember we went in here we stripped the URL parameters and we just loaded the original image so what we were doing is we were loading this image into cache before we ever actually hit it in a separate upload request now that's where the problem lies where because it's in cash it doesn't just simply automatically invalidate we need to tell it that we want to invalidate all copies of that URL now just to point out in the documentation we can see that it does make a note that we will want to invalidate the assets specifically if we're using versions and we want those versions to be invalidated because that's another mechanism that we can use but in this case we probably want to invalidate all the different options because we do want to save that original asset if you do want to learn more about how that invalidation works you can check out this page invalidate cash assets which you can find by searching in the documentation but to actually make this happen we're going to just simply pass in this invalidate parameter and we're going to set it to true so inside of our API route because we know we're passing in a public ID and if we're passing in a public ID that means we want to overwrite an image we're going to add that additional invalidate and set it to true inside of that if statement but now we see that we get an error because we're trying setting a bullion so all we got to do is say that this can also be a bullan but just to validate this is working let's try and do this on another image how about I'm just going to recrop this same existing image so let's Prime this one as well way to get rid of those other tabs let's strip all the URL parameters so that we have our original image which is going to be that transformed image that we already have but now let's head back let's open up the edit panel let's make this a square I can add a new filter let's make this one grayscale and then now I'm going to hit save now you probably want to add some kind of loading indicator to this just so that people don't think that the UI is stalled when you're actually saving but nonetheless we already got back our results we can look inside and we have that image now let's go ahead and refresh this page to see if that worked and we now see that we do have our nice cropped image because it did save it overwrote that image and it invalidated the cache for us we can even see if we hit the back button that it's already updated in our original page now now we have the save functionality worked out but what happens after the save so if I head back in here and if I actually hit the save button nothing's going to happen afterwards now what I want to happen is I want to close this panel as long as that save is actually successful and complete now if you're following along with the starter template I already have this option or function rather called close menus which essentially just hides all those panels it closes all the UI and this is something that we don't necessarily need to cover in this course but essentially that's just my function I can call in in order to easily get rid of that UI so I'm going to take that Clos menus and after I know that it was successfully saved I'm going to add close menus and let's get rid of those console logs and let's just give that a quick try we don't have anything on this of course but let's just see if it closes and it did so next what I want to also do is if I have any of these Transformations applied such as landscape or whatever I wanted to actually apply I wanted also to reset all those Transformations because now the original asset is the asset that I want to show so I want to make sure that those are clear so that it's going to give me the option to go back and now add new new Transformations now for this one I don't have a function already available to easily do this but what I'm going to need to do is if we scroll back up to our state we're going to need to set enhancement set crop and set filter and for each of those we're essentially just going to want to set it to undefined to reset that state so I'm going to go back to where I have that close menu where is it closes menu eventually find it I'm going to create another function underneath and let's call this discard changes because this is something that we could use in the feature as well again I'm going to just add that little note because I like to have it a little bit easier to find for now I'm going to get rid of that description but here let's add set enhancements to undefined we'll do the same thing to set filter and the same thing to set crop and now let's take this discard changes and we're going to do the same thing with that so I already have my landscape I'm going to add another filter and oh that's a cool little effect here but now I'm going to hit save again we can see that it closed it if I go back up into my Transformations we can see that everything was actually reset now another thing that you might have noticed is that original image or rather that new image is currently being displayed because we invalidated that now sometimes the way that it'll work is if you remember in previous examples we needed to force a state rendering for it to actually refresh that image now it seems like that's automatically happening but to be sure to make sure that we get that loading UI so that it is showing some kind of indicator as we're waiting for it to load what we can do is we can set a version on the URL so that it'll Force whatever that new version is and we can just use the date for that so up where I'm defining my state I'm going to add a version and I'm going to add set version or singular now for a default value I'm just going to set that as one and I want to make this a number as well because we're going to use a date Tim stamp now where I'm closing my menu and discarding my changes what I can do is I can say set version and I can just use date. now and what date. now is going to give me is basically a number that's going to represent the current Uh current time date time now heading down to my clld image which I'm displaying on the page I'm going to do two things first of all I'm going to add it as the key to force that render but I'm I'm also going to add it to the image itself just to make sure that the image itself is going to be be providing the most recent version and again with the invalidation that shouldn't be a problem but this is really just a kind of safety net for us so I'm going to wrap the Json stringify with that string then I'm going to add my version and then I'm going to Simply pass along my version as a version for the URL and again because we weren't really experiencing any issues we shouldn't really notice too much of a difference but let's go ahead and just apply something we going to add portrait and we can see with all the different edits because layering over and over and over the image is getting smaller so it's getting a little bit blurry but nonetheless let's go ahead and click save and as I do that I'm going to hide the panel we can see that it the panel was hidden and then we had that image refresh and we even had that little loading indicator while that happened now if I refresh the page we can see that the image does look good so maybe there's just a responsive image issue for when we're applying those Transformations let me show that again we have that square image or maybe we can add the landscape or anyways because we went from the image to the small images maybe there's just a logic hiccup in the in that canvas logic that we showed before which made it show a lot bigger than it actually was but we can see that with our changes that it looks pretty good and we have that portrait and it's not way overblown now before we move on to adding save as copy which should be pretty simple I do want to do one thing so inside of our panel we currently show that save no matter what and that probably doesn't make a lot of sense because we only want to save something if it actually has changes so so inside of my code the way that we can determine if we have any changes is we can inspect this Transformations object so what I'm going to do is at the bottom of all the different effects that I'm adding I'm going to say object. entries Transformations and I'm going to check the length of that to see if it's greater than zero I'm going to set that to a constant of has Transformations I'm got to make sure that I actually spell that right but now what I can do is I can take that has Transformations let's go to handle on Save we found the but but in and now I can just wrap this entire area with that and specifically this div here so I'm going to say has Transformations and I'm going to indent this div and now we have that wrapped with that logic so let's see if that works we can immediately see that that save button is no longer there but let's try to add a transformation let's add Square we can see that it popped right back in now we could probably also update how we're wording this close button where if we have Chang ches maybe we want to cancel the changes instead of just simply close so around the same area we can do something similar where if we head down and find that close I'm going to say has Transformations let's add cancel otherwise we'll have the close and maybe we want to also update the color of this button so that maybe it's Red if we have Transformations and want to cancel them just to make it a little bit more prominent that we're going to lose those changes so I'm going to change class name to make it a dynamic value hide myself here just to make sure it's clear and we're going to say if has transfer formations let's make this BG red 500 otherwise we're going to add that BG of transparent and we can now similarly see that because we do have a change we see both the save as well as the cancel if we get rid of it we can see that we do show that close button but if I hit cancel it doesn't actually cancel those changes it just collapses the menu so let's fix that quick so when I hit this button I don't want to just close the menu I also want to use that discard changes function so I'm going to just break this open and I could probably abstract this to a new uh function for that handle if I want it but for now let's just add discard changes and this time when I actually hit cancel we can see that it reverted to its original state and canceled all the Transformations that we had applied so the save functionality worked really well but now let's implement the save as copy now like I mentioned earlier this is going to work really similar to how we did this handle on save so I'm going to scroll down I'm going to find the menu item that's wrapping my save on save as copy text I'm going to add on click and let's call this function handle on Save copy and now I'm going to go back up to where we're defining handle on Save and the first thing I'm going to do is just simply clone this function just to give us a good starting point for how we're creating this so let's rename that to handle on Save copy we're going to do the same thing where we're going to create the URL but one of the bigger things is we're going to not pass in the public ID this time and if you remember inside of our API route we're dynamically overriding that file only if we pass in that public ID so it should just work and upload it as a new copy when it comes back with the results so let's go ahead and console log that out we're now if I open that up and hit save on copy we can see that we did get those results now we also saw in the background that it did reset the image now let's look through this and let's open up this secure URL let me hide myself looking through I have my secure URL we can see that we do have that original image now also let me check the asset ID e624 6 yeah that's different from the resource asset ID that we're on so we did successfully create that new asset but we're still on the original asset so in as far as the UI goes how about we redirect them to this new asset so back inside of the code because I'm going to push them to a new page first of all I can probably get rid of the the menu item and change discards from the below but what we're going to do is we're going to use the nextjs router and push them to the new page so I'm going to go first of all to the top of my page I'm going to import use router from next navigation then if I scroll down to my component the first thing I want to do is I want it to say constant router is equal to use router so I can create a new instance to interface with it and then if we scroll down to our handle on Save copy we can now use that router where we're going to use router. push where I'm going to create a dynamic path of /resources where I'm going to pass in that Dynamic value now if we remember this is going to have a property of data first off so I'm going to say data. asset ID so now let's give this a try I'm going to go ahead and add a transformation I'm going to go ahead and click save as copy where we can see once it's saved it pushed us to that new page which is going to reference that new asset now we do have one problem here let me hit back for a second we don't have that asset available in our media library if you remember in our code we're currently quering our Resources by a specific tag and we never added that tag so it probably makes sense that it's not showing so what I can do inside of the API in point I can say else upload options tags where I can now set it equal to include that tag where if I head back over I can quickly copy the tag string and paste it inside of my tags and the reason that I'm currently doing an else statement here is if we're uploading our public ID and overriding the image I don't want to wipe all the existing tags if there's already tags on it where here we're uploading a new image so there aren't any tags on it unless we specify those tags now we can see that typescript is yelling at us because we are passing in an array with a string so we need to do one last thing and add array of string and we could probably make this look a little bit cleaner pull up an upload option for instance and have that in there but for now that should work as expected but now let's try it again so let's go back to that image I'm going to crop it to a square we going to hit save as copy and after it uploads we can see we went to the new page that works as expected but if we hit back we do need to refresh because we didn't invalidate the queries for this page we do see that new image but okay we have the ability to save our images in multiple ways but what about deleting those images now getting rid of my Dev tools for a second if I click this delete button we can see that we currently get this modal it's basically a confirmation dialogue that just makes us actually delete it if we only want to delete it so we actually know what we're doing and didn't accidentally click but nonetheless when we click this button we want to actually delete that asset Now using the cloud Nary admin API we do have a nice end point for being able to delete our resources it's simply delete resources so first off jumping back inside the code I'm going to go ahead and duplicate my upload end point so I'm going to say delete and call this my API for deletion we're inside we already have a similar boiler plate we have our importing we have our configuration and we're going to be able to get rid of some of this stuff but we can also keep some of it to make it a little bit easier now let me get rid of my sidebar let's first clean up we don't need any of these upload options now we do need the public ID because we're going to delete it by the public ID and then let's get rid of the URL but now instead of the upload loader we're going to use cloud. api. delete resources now resources takes an array where we can pass this public ID directly to it and we can still just pass through these results as is but keep in mind also that this is going to be a post endpoint and because I duplicated the upload endpoint it already isn't is a post request but now let's head back over to our media viewer UI and start to look for that delete where if we remember when we click that original button at the top navigation it's it's going to open that modal so we really only need to interact with the modal button where we can see here that we have our dialogue and that includes that button for deletion so the first thing I'm going to do of course is I'm going to add my onclick Handler and let's call this handle on delete and now let's take this and actually defined it handle on Save I'm going to add it to a similar location that we did to the save and points so I'm going to add my function and acing function rather handle on delete where inside I can run a wait fetch I'm going to hit my/ API delete endpoint make it a method of post pass in my body json. stringify where I can pass in my public ID as resource dopu D and really to delete it that's all we need to do so let's test this out quick so we can stick with this current one because H it's not the greatest image so let's get rid of it let's hit delete and if we wait a second of course we never did anything with the U y so nothing's going to happen but let's try to refresh the page we can see that we no longer get a good page we're getting an error and we could probably clean up these errors just to make sure that it's a little bit more understandable what's actually happening but it's because we deleted it and we no longer have that information to feed into the UI so if we head back to our homepage we can see that we no longer have that image of course so the first thing that we can do is if we do have a successful deletion let's push them to that homepage so I'm going to add router. push and I'm just going to Simply uh reference the homepage we can go ahead and try this on another asset how about this one because the cash isn't quite validate uh invalidated for all the different variations so let's click delete I'm going to hit delete and we can see that we were moved to the homepage now it didn't update of course again because of the query inv validation but let's refresh the page and we can see that it's gone now for all intents and purposes this is probably just fine but as we alluded to earlier we can add some little interactions to make it clear what's happening and while I'll save the save functionality for you how about when we're on delete let's update that little button so that it has a little loading spinner to indicate that it is currently deleting so if I go to the UI what we want to do is we currently already have this deletion state that I'm using in order to control the modal opening or closing which we'll get to in a second but what we're going to do is depending on that state we're going to show a different button so first off let's go to deletion so that we can see what this state looks like but currently it's just a string in that string we have our delete comption and the only thing that we're currently setting it to is undefined or I think I missed it there or we're going to set it to confirm which confirm is just controlling the dialogue to be open so the first thing we want to do is we want to make sure that this dialogue is indeed open on the states that we want it to be open on and maybe not just any state only on the states that we specify currently if the state is defined it's going to be open so the first thing I'm going to do is I'm going to say if deletion and the deletion State and we're going to use that array includes again like we did before and I can get rid of that opal optional chaining because we're checking for it first but let's add first of all I think it's confirm and then let's add another one of deleting where I added an extra e there but then when we're actually trigging that handle on delete let's set deletion and we'll set that to our state of deleting now first things first if we are in that deleting State let's show a different icon let's show a spinner icon so I'm going to say for my deletion state if deletion State equals deleting we're going to do one thing otherwise we're going to do the other thing which will be our trash icon so we're going to say if it does not equal the deleting and because we're going to use the same word delete for both of them I'm just going to keep that outside but now let's just duplicate this because we're going to replace this with a loader where if we head to Lucid we can see that we have a few different loaders that we can choose from where I specifically liked this loader to I'll make sure that I update this to import it but we also need to make sure that we're adding our optional chaining for this state to begin with where the only other thing that I'm going to do is on this loader icon I also want to add my Tailwind class to actually animate it so I'm going to add animate spin now as one more thing I don't want somebody to be able to click on this button twice if it's in that loading State now depending on who you ask there's a lot of strong opinions about disa disabling button UI but I don't want somebody to be able to click this if it's already deleting and Trigger that second deletion request if it's going to just error so what I want to happen is if it is deleting I don't want anything to happen if they click it so we kind of have one of two options where we can either just disable it on the button itself or we can use the event handler and use JavaScript to disable it so let's do that one I'm going to copy that hand head up to handle UND delete and if our state is in that deleting State let's just simply return now going back to the UI let's pick another one delete how about let's delete that really fuzzy one that we had from before when we were testing the AI I'm going to click delete let's click the delete button we can see that it's spinning and loading and we were pushed back to the homepage and let's refresh and we can now see it's gone so now let's take a quick moment to handle that invalidation issue that we were seeing where when we go back to the homepage we want to make sure that that refreshes the query inside of the client as a quick refresher when we were originally creating our used resources hook for that media library homepage we use the used query client in order to invalidate after we added a resource so we can see we imported use Query client we grabbed the query client itself and then we both set data and invalidated we're here we're only going to need to invalidate the queries but we're going to do that in the media viewer so let's give that a try where first I'm going to import the use Query client at the top of my media viewer file where I only need the use Query client so I'm going to only import that I'm going to go ahead and then grab that query client statement and go to the top of my media viewer paste that in where then I can grab that invalidation which let's just take a moment to refresh on that where it's running invalidate queries I'm passing in a query key which equates to my resources as well as my library tag so that it's going to revalidate that request and force a new one so let's go ahead and copy that one as well I'm going to head over to Media viewer and then handle on delete at the very end of that right before we push to the homepage I'm going to go ahead and invalidate those queries now let's take a quick second to test that out we're here let's delete the Northern Lights to begin with where at the top right I'm going to click delete and then I'm going to confirm the deletion where we can see I was pushed back to the homepage after deletion which is successful but we also invalidated that query and while we saw it for a split second in the process of it revalidating we did see that it was then removed after it invalidated and refreshed those results now realistically speaking for our handle on Save copy and handle on Save we might or might not have to do it for those if you think about it if we're saving a copy and then going back to the homepage if we didn't invalidate those queries we might not see that new copy which we did actually see before so what we can do is we can invalidate those queries both on Save and save copy so the first thing I'm going to do is I'm going to actually create a new function just for the invalidation of the queries so let's say function invalidate queries I'm going to pop this inside we then I'm going to run it right before that router push again but then I'm also going to run it right before I push to resources or that placement probably doesn't matter for the handle save on copy and then for the handle on Save I'm going to do something similar so we can go ahead and just test that out so I'll go with my elephant friends I'm going to go ahead and edit it create a square out of it let's create a cop we can see after it was finished it pushed me to that new page and now let's head back to the homepage and we can see those queries were invalidated and I now see my elephant friend again but in a square format now before we wrap up with our individual viewer page let's do one more thing where I'm going to head back over to my elephant where on this info panel we currently only show the public ID and I want to show a little bit more information than that cuz we have things like our width our height maybe we can even show the tags but basically let's fill this out with some information that we have from the asset now the only information that we currently made available on the type is our height our public ID our secure URL as well as the width and there's a lot more information if we remember from inspecting the resources so just to kind of see what's inside before we tackle this let's console log out our resource where once we refresh the page we can see all the data inside and let's do things like our bytes the created ad maybe we want to add the original format we can see this one's a JPEG but back inside of our media viewer let's find where we're setting that public ID I'm going to get rid of the sidebar here so I'm going to look for public ID and I'm going to hit enter a few times until I actually find it and here we see our info panel where I'm actually setting that public ID within the text so let's add a few more how about we want to do we going to break down this so you can see we have our date created how about we also do our width we do a height let's do the format the size and finally let's do the tags and some of this again we already have how about for our width and height let's add our width our Heights I don't think we had the date created at yet but we do have the tags so we can do tags and join that by a comma actually that's tags with an S and actually we don't already have that so anyways we can go back to our type now and start to add the things that we don't have yet so starting with tags we have our tags which is going to be an array of strings we have our format which is going to be a string our size is actually going to be available at bytes not size so we want to find bytes and that's going to be number as well and then we have our created at date which is going to be a string so let's add our created at which will be of course a string but now let's head back to the media viewer and start to fill these things in we have our size which is bytes we have our format and then I think it's just the last one of our date created so created at but now let's wrap that with date new or rather new date which then will add to local and I'll hide myself local string now if we head to the browser if you tried to use tags already we'll notice that we don't actually have them now by default the tag don't come back in the response from the resource so we have to actually explicitly request that so back inside of the project I'm going to look under my pages for the resources and the asset ID we're here I'm going to pass in a second argument into my resources by assets asset IDs which I'm going to say tags true we can see once it refreshes everything is working as expected let's check that out that in info panel now where we can see all of our different information we have the date created which looks nice with that local string we have our width our height we have jpeg format and our size as well as media now as far as these numbers go these are a little bit harder to read we can add commas here we can probably format that size a little bit differently and if you're following along with the project starter I included a few functions inside of the utils file the lib utils file which includes some functions just to format this for us where I use chat gbt to easily generate this you could use whatever code generation tool or just write them yourselves if you're up for the challenge but here I have ADD commas simply which what it sounds like and then we have our format bytes which it'll dynamically format it to bytes kilobytes gigabytes Etc based off of how many bytes there actually are so at the top of my media viewer I'm going to import format bytes and add commas from at lib utils and then I'm going to head down to where I'm actually doing those things format bytes and then for my numbers specifically my and height I'm going to add add commas to wrap that I can do the same thing for my height and now we can see that that's formatted a lot easier to read where we have the comma for the width and the height and then we can see that that's 1.9 megabytes in size now heading back to the gallery page it seems pretty Snappy and fast because well my internet's pretty fast and it's loading pretty quickly from the clown server but what if maybe my internet's not slow or maybe what if the cloud request or another services request was taking a long time to load the way that nextjs works which inherits from react is it's able to stream in some of these server components into the UI where if I wanted to load this entire page I don't need to have it completely blocked to have every request fulfilled before it actually loads on the page where specifically because I'm loading the contents of this Gallery separately in its own server component if that takes a long time to load I can still run into the rest of the UI before that actually finishes is so that once it does finish it can load that itself so we can take advantage of some of the nextjs features specifically the loading template in order to make that work so back inside of the code I pulled up the homepage that's currently loading that media gallery and as we can see inside we're loading those resources which get passed along but we're doing that on This Server now this is the layout that's currently loading any of the page contents where we have these sidebar links that are separate from the actual children that get rendered for the page itself but what we can do is we can create a new file that's simply called loading. TSX and inside I'm going to export a default function called loading and inside just to test this out for a second let's just say loading and if we try reloading the page we should see for a split second that little loading in the top left now like I mentioned before this is particularly impactful if you have a request that's slow to load so while this Cloud API request is loading pretty fast we can kind of artificially see what this would look like so what I'm going to do is I'm going to say await new promise where I'm going to pass in a set timeout where inside I'm going to Simply resolve undefined so it just finishes that function but I'm going to set that timeout for 5 seconds so what's going to happen is anytime this server component or page tries to load it's going to get those resources and then it's basically just going to wait for 5 seconds until it resolves so now when we try to reload the page we see that we have the loading indicator and it's going to sit there for 5 seconds until it resolves but in the meantime we were able to see that the sidebar in the navigation were all able to completely render and be on the page and even be interactive before the actual content's loaded now rather than just that little simple loading indicator I want to just put a little Cloud n logo inside for mine so I'm going to go ahead and inside a figma I'm going to copy this as SVG and because I can't put SVG code directly in react because react is jsx I am using this handy tool SVG to jsx where I'm going to paste that in it's going to allow me to easily copy the SVG that's jsx ready so now inside of my loading function I'm going to return that SVG and if I try to reload the page we can see that we get that logo but let's make that a little nicer looking to start I'm going to wrap that with a div going to make sure I indent that and then on the div I'm going to add class name I'm going to make it a width full height full I'm going to use flex box box I'm going to make the items Center and justify Center so if I reload I think that's making good progress and I just realized I misspelled justify so that's why it wasn't in the center to begin with but then on the SVG itself I'm going to add class name text zinc 200 and how about for dark mode dark uh text zinc 800 and then I'm going to add animate pulse to give it a little animation now the last thing that I need to do is actually change how the fill is getting applied inside of the different paths and as we can see this fill is currently set to Black so I'm going to set that to current color and when I reload the page we can see that we get that lighter logo and it has that nice little pulse indicating that it's loading now I'm going to go ahead and actually remove that promise cuz we don't need an artificial delay in that we can see that if we refresh again we do get it for a split second and it's really only going to show if we actually need it there but the cool thing is we can do that exact same thing for the media viewer as well so what I'm going to do is under resources where we have our Dynamic route at that top level next to the layout I'm going to Simply drag that in and copy it in where now we have that same file but the difference is I I can probably just get rid of this text zinc 200 because it's always going to have that dark background so that's really the biggest difference there and now if I try to navigate to one of the images we were able to see for a split second that logo in the background if I refresh we can see the same thing now as far as loading animations go we never never added that loading animation for the CL image components that we use on the gallery page so as you remember we created a wrapper component around that so that we were able to just add that SVG loading animation uh directly inside that wrapper but still render the CL image component pretty much as is so what I'm going to do is I'm going to Simply get rid of CLD image and then I'm going to import the CL image component wrapper that we created and if I reload the page we can see that we get a split second of that if I open up my network tab let's add the fast 3 G and I refreshed the page we see that we do get that loading animation as it comes in now it's dark and it's probably better if we did like a light animation for this one but I'm going to consider it out of scope for this one so maybe that's something you can do on your own where you can try to create a variable loading animation between whether it's light mode or dark mode based off of either the page that it's on or even if the browser itself is in light versus dark mode but now we get to probably my favorite part of this whole project we're going to add some Creations where we're going to have the ability to multiple items or maybe just a single item and we have this little menu up here where if we click it we're going to have a couple different options for a creation that we are able to create one being a collage for instance where we'll automatically on the Fly create a collage based on these two images now looking at the code for a second let's see how we're going to walk through this where I have a little bit of UI already scaffold for this particularly a little dialogue that's going to allow us to preview the creation before we allow somebody to actually save it so if we scroll down in the starter or if you want to create your own dialogue I currently have this dialogue where if it has a creation it's going to show we don't currently have that capability yet but if we want to be able to show the creation we're going to show it right inside of this content we're going to say do you want to save your creation and then of course we're going to give a button to save that so let's Dive Right In I'm going to search for the word option because one of the menu items had the word option in it and we can see that we have this drop down menu where I have the first item of option now of course we want to make that a collage so the first thing I'm going to do is change that to the word collage but then we're going to use this drop down menu item in order to trigger that so we're going to set up an onclick Handler on this where I'm going to name it handle on create collage now we're going to want to create this function so I'm going to copy that I'm going to head up to the top of the page and let's add it under let's just add it at the top of this list here handle on create collage I'm going to then create my little note just to make it a little bit more easy to see but then inside of here this is where we're going to start to manage the creation state to begin with so that we can put it in that creation flow now if I look at creation itself here it's currently not expecting any kind of shape that we're going to store that information in so the first thing I'm going to do is create a type just so that we have an idea of what that's going to look like so I'm going to create an interface of creation and some of the things that we're going to want to store is first of all the state so what state is that dialogue in so I'm going to say State and that's going to be a string I'm going to want to store the URL so that's going to be the UR URL of the creation so I'm going to say URL equals string and then we're going to have different types of Creations the first one's going to be a collage of course but if we want to do something different based off of the different types we want to have a way to do that so I'm going to say type equals string but now we can take that interface and I'm going to set it on my state instance and then we can actually set our first state where inside of handle on create collage let's add that where we have those three different things we have our state we have our URL and we have our type and let's start to think about what kind of state we want to have now if I'm immediately creating a URL I can just add something like created so let's add created where maybe in the future we have some Creations that require an API endpoint which we will so maybe for that one it's going to be creating until that finishes maybe for a loading state but rather let's get back to the URL where we're going to have something in there now we don't have that URL yet we'll get to that so I'm just going to add a random string and then finally for the type this one's going to be a collage now heading back to the app just for a second I'm going to go ahead and click that plus I'm going to click collage and we can see that we already have that dialogue because now creation is a truly value because we set that state so what we're going to do is we're going to first of all we're going to create a URL for the collage and then we're going to store it so that we can show it using that CLD image component right inside of this area now we already have the CL image component imported but if you remember we used that get clld image URL function in order to easily generate it where it wasn't in the context of actually displaying the image so we're going to use that and I'm going to say import get clld image URL from next cloudinary spell that right and then I'm going to take that I'm going to scroll down to where I'm actually creating that collage and let's say constant URL is equal to get clld image URL I'm going to say source is equal to and now we need to find out what images we're actually trying to use to create a creation right so we're going to try to inspect the ones that are selected from within the U so quickly what do I mean by that so we have these little check boxes here so we're storing those selected values in the state that's already preconfigured in the starter if you're following along but ultimately we need some way to be able to detect that these were the selected images so if we look at the top of media Gallery I have this selected and set selected and it's just an array of strings and if we just take a quick look as to what I'm doing I have a checkbox for each and every one of those images we can see that here where if somebody actually tries to select that checkbox it's going to trigger that function and it's going to Simply add the public ID of that image to that list so I'm going to Cal this out for a second and let's just console log out selected just so that we can have an idea of what we're actually working with so if I go ahead and select collage we can see make sure that this is big enough that we have that selected value which are those public IDs so to get started I'm going to just simply add the first one so we can start to construct that UI so I'm going to say the source is going to be selected zero which is going to be the first item in that array we don't NE necessarily need to even set a URL CU because Cloud doesn't necessarily require a width and a height because it already knows that when it's trying to deliver that image so we really only need to set a width and a height if we're trying to change those values so what I'm going to do now is I'm going to Simply set that URL and now we have that creation state that we can start to actually display it inside of the little dialogue UI now before we actually do that though I have one more thing and we need to set a version on this URL now that's going to accomplish two things one we'll get to in a second when we're showing how to do this in the UI but the other thing is when we're using the creation we probably want to generate a new creation every single time that we do this now if we don't say perhaps somebody selects the same two images we go and make changes to that image and then save it and then come back and try to create it again it's probably going to use that cached version that has so it's not going to use the updated version so we want to make sure that we're always creating a brand new creation when the user actually prompts that so what I'm going to do is I'm going to set version and let's just say date. now so going down to the dialogue UI the first thing I'm going to do is say creation optional chain URL so only if that exists I'm going to show a div that includes my clld image component now as far as the CL image component goes it does require a width and a height but for all of our Creations we are going to contain it to a specific with and height and specifically we're going to do 1,200 and we're going to do by 1200 and the reason we're going to do that is if you think about a collage it's not really going to have a dynamic value it's going to always be a Square where we're going to place our different images from within the square now of course you can make that different if you'd like you can make all your collages wide or tall or maybe even they have the option to change how that works but for our purposes I'm going to add a static 1200 X 1200 for each and every one of the Creations that we're going to use but now I can set the source as creation. URL and just as a quick note typically and to this point we've set a public ID for each and every one of our sources of clld image now technically the CLD image can take in a cloud n URL however the URL must have a version number associated with that and why does it need a version well the cloud n URLs are pretty tough to actually parse and without the version number it's pretty practically impossible to do so because there needs to be a separation between the the Transformations and the end where we can grab that ID and if you don't have that there's potential that maybe somebody's using a name that collides with one of the Transformations but we're getting into the weeds what I'm trying to say is the version number is required for the URL if we want to use that there so then I'm going to say alt equals creation and then finally we can use a property called preserve Transformations and what that's going to do is if we pass in a URL because I'm parsing that URL it's going to allow me to take any Transformations that were inside that URL and then automatically apply them to the image that we're actually displaying so now we have that image and let's see if that works but now going back to the UI for a second let's actually test this out where I'm going to select my elephant and I'm going to click create uh create collage where we can see that we're immediately getting that loading UI and we see that it is showing larger than that set 1200 by 1200 why is that so if you remember from earlier when we were creating our little thumbnails for our filters we had to also set a crop of fill now that's important because otherwise cloud is not going to just assume that we want it to be cropped to that size where that width and height will just be used inside of the actual Dom for the image element but it's not going to just simply crop it so we can set a crop of fill but because we're now going to add Transformations again remember from earlier we want to crop the source of the image we don't want to crop the end of the image so what I'm going to do is I'm going to say crop and we're going to pass it an object where I'm going to say type of fill and then I'm going to say source is true but now going back to the UI if I try that again we can see that we get a nice Square which actually looks pretty similar to one of the ones we already had in there but that's a new creation based off of that other resource that was initially taller but now let's take those selected images and try to create a collage out of them where let's think for a second how this would actually work so we have our base image and we want to basically split it in half and we can provide multiple templates for this but we basically want to split it in half so that we have one image on one side and one image on the other now Cloud Nary has the ability to place layers on images and what that means is we can either place text layers or image L image layers so later you can honestly add a feature to add text to your image but we're not going to get to that here what we want to do is we want to place these layers so that we have two layers that represent those two images that are going to be our Collage if we head over to the next clowning documentation we can see overlaying images under the guide section where we can see how to do just that I'm going to select get SE image URL but we can see we're going to use the overlays property where we're going to pass in an array of overlays that's going to contain our images that we want to Overlay the position of it and any effects that we might want to add to it and particular maybe like cro so let's start with our images where I'm going to now add overlays and I'm going to create an array where let's set up that first object and we can use the first selected item for that first overlay where we're going to set a public ID of selected zero and then we're going to add a position where the position is going to work where we want to just set a simple gravity and what I mean by gravity is the focal point if we remember for from earlier where we want to say we want to set that to West so we were you know depending on which way my camera is we want to set it to either the left side or the right side the west side or the east side which is going to tell us exactly where we want to Anchor it so that when we have just half of an image it can be either on the left or the right so I'm going to add an object for my position and I'm going to set gravity of West but then we want to resize the image so I'm going to add an effects property which is basically just going to allow us to pass an array of different effects that we want to apply where I'm going to pass in an array of objects and that first object is going to have a width of 600 which is half of the creation size we're going to add our height of 12200 which is the full height of the creation and then we're going to add a crop of fill because remember clouding is not going to just assume that we want to crop it so it's not going to use the right scale or cropping mode if we don't pass that and then finally we're going to add a gravity of Auto where that's going to mean that depending on the size of the image in the crop it's aut automatically going to detect the most ideal location to crop it to so if you have a wide image with an elephant on the left side it's going to automatically crop that frame to where that elephant actually is now let's give this a try just to see where we're at so let's hit add new and we have our collage and once we actually let it load for a second we see that it's not quite right so if we look at this image we see that it's much smaller and what's actually happening here well we're cropping the image that we're displaying but we never cropped the source image of the image itself but on top of that the image below is showing and maybe we don't want that to show maybe we want to just make that white so we have two problems here first we need to crop the image and then we need to remove the background image basically so we're going to say we want to set the width of 1200 the height of 1200 which will match the creation size and then we want to say we want to make a crop of fill for that and let's just double check that that's working so far and try again on my collage and remember we set date now so it's all always going to generate a new image but just to try to illustrate a point that I was trying to make earlier is we still see that it's not quite the right shape and size now again because we're not specifying that we want to crop the source of the image we're we're cropping after everything occurs and then when we're using that with clld image it kind of gets mixed up because now CLD image wants to pass in the responsive sizing which is kind of the point of the tail end of the resizing so we're going to set that as an object and we're going to say type of fill and we're going to say source of true but now when we open that one up we can see that now that elephant is taking up half of the actual size so now let's remove the background now this part's a little bit trickier because you always require a source in order to create a URL because you ultimately need an image in order to build all this off of and while you can maybe add like a one pixel by one pixel white image and then overlay everything on top for our purpose I'm just going to keep this current image that's selected as the image that we're going to be using but what we can do is we can add an additional effect and basically turn that image into a white image so I'm going to go ahead and create a new property of effects where on that I'm going to add my new object where I'm going to use the colorize property and I'm going to say I want to colorize it 100 and the syntax here is a little funky but what we're going to need to do is 100 and then we're going to say we want it as a color of white so let's see that syntax and you can find an example like that inside of the documentation but we want to colorize it we want to change the color of it we want it to the full effect and then we're going to set the color of white and then just to be safe I'm going to add a background of white as well so let's test this out and we can see once it loads we have our white background and we have our elephant only on one side of the image so now let's add that second image on the other side so we're going to do the same exact thing that we did for the other overlay I'm going to duplicate that but this time we're going to use the second image selected now we're going to have to add some logic here to make sure we determine how many images are selected but we'll get to that in a second so we'll just assume that we have two selected for just making sure this works but the only other thing that I need to do is remember the gravity is going to set which sides of the image that needs to be that it needs to be anchored to so for this one we're going to make it East so now let's how about we select the elephant and we select this uh picture from Athens I'm going to click create collage and once it loads we can see that we have our beautiful collage where we have both of our images where again the gravity is automatically detected where it is in the image and based on the size of the image it doesn't necessarily mean that it's going to be a perfect inner crop now there's something coming out soon that's going to help you with that kind of thing uh crop of Auto but we can see that it was nicely cropped and it's going to give us that collage effect now as I pointed out we only want to be able to create a collage if we have two images so the way that we're going to handle this is we're going to wrap all of our menu items based off of those constraints that we actually have so for this particular one we only want to show the menu item for Collage if we actually have enough items to show that so I'm going to say selected length is greater than or rather if yeah greater than one because we can set different templates up for different uh collage groups and then I'm going to say and then we'll show our menu item so now in the UI if I only have one selected it's not going to show anything but as soon as I select another one we now see collage now as I mentioned before I want to be able to create collages based off of multiple multiple images not just two images so now we can try to create the concept of templates where we're going to create templates based off of how many images we have so the first thing I'm going to do is I'm going to actually abstract this image into a lib file so inside of my sidebar here let's find where we have our lib already going to collapse down the app where we have our lib I'm going to create a new file not a folder a new file called creations. TS and you can really name this whatever you want but I'm going to create all the Creations logic inside this file but let's export a function called get collage and inside collage it's going to take a list of public IDs which will be an array of strings or string now heading back over to the media gallery for a second I'm going to lift up all this code that we're using to create our actual URL and I'm going to Simply paste it into this new file now of course we need to import our next Cloud Nary Library so I'm going to use my handy command and period and I'm going to add that import for us but we can see that we're also getting a type error on selected and that's because we're not using that as the variable name so I'm going to pass in and replace the selected item or the selected name with public IDs but now we have this URL and we can simply return the URL to start and then let's head back over to the media gallery and just wire this up just to make sure that it's working properly so at the top of the file first I can get rid of get SD image URL I'm going to then import get collage from at lib creations and now let's use that so I'm going to look for my handle on create collage and how about let's just pass this in as get collage where we're going to pass in our selected now you know me I like to make sure that this is working so I'm going to hit the plus sign hit collage and we still get our collage so now let's actually create some of these templates where I'm going to create a constant of collage templates I'm going to set that equal to an empty object where what we'll do is we'll use a key of how many different items that we have inside of that array so we can dynamically pull that template based off of how many public IDs we have so let's start with the first one that we already have of two and I'm going to create a function out of this where I'm going to pass those public IDs as that actual value now again we want to be able to use the array of strings as the type for that but then I can determine what all the different properties that I want to store in this template now kind of looking at this for a second we're always going to use the first item as the source it's always going to be 1200 by 1200 we always want to make sure that we're cropping at the source of the image we always want to set a version but we could probably use these overlays as the basis of our templates now again we're probably going to want to keep the effects for each and everyone because we want to have the underlaying images white so let's now just use only these overlays as the basis of what we want to do so I'm going to cut out these overlays and I'm going to return an object that includes those overlays but now what I want to do is I want to try to dynamically pull out the template that I'm going to use for that image creation so I'm going to copy collage templates and we're going to say constant template is equal to collage templates and let's use Public public .length as the way that we're going to access that now we can see that typescript doesn't like that and why doesn't it like it well how about let's go back up to collage templates and we never set a type for the type of data that this is going to expect so let's say this is going to be a record where it's going to be a number not a string like you might usually expect and then we're going to have a function where I believe that's a capital f but now let's see if that fixed our error it did and we can first of all let's say if we don't have a template do we throw an error do we just return how about let's just for now return so that we're not interrupting anything but now we can actually use this template to create our Dynamic properties so at the very end of this I'm going to to spread out where we have our template and remember that's going to be a function where I'm going to pass in my public IDs now one thing I just thought of is we see that we get a type error over on media Gallery because the URL could potentially be undefined now because we do want to make sure that we always have the right number of images maybe it makes sense to use throw air anyways it shouldn't ever get to that place because that means we're displaying it in the UI where we shouldn't be so let's just try to use throw new error template not defined and we can see that we no longer get that type error inside of the media Gallery itself so as expected it should work and it does so next let's try to add another template so the first thing I'm going to do is I'm going to clone number two and to make sure I add my comma up top I'm going to set my key of three but now what we want to do is we want to create three overlays to have three different positions of where we place these images so we're going to leave the first one as is or you could use you want to think about the layout that you want to create and the layout that I'm going to create is I'm going to have the first one just be the tall image and then the second two I'm going to have the two halves of images so we're going to leave that first one as is I'm going to duplicate the second one but what we want to do is we want to set the height of 600 for both of these because again they're going to be half of the height and then we want to update the gravity based off of where we want them to be so how about we make this first one we're going to make it Northeast so it's going to be in the top right corner and then this second one we're going to have as Southeast or the bottom right corner but of course we need to make sure that we update the public ID that we're trying to get out of that array and before we get started I uploaded a few more images before we test this out and while I like the elephant and grease I just want to have a little bit more variety as we're having fun with this so I'm going to select the Penguins this time I'm still going to select the elephant because I like the elephant but how about for the last one let's do the Northern Lights I think that'll be a Cool vibe so I'm going to hit add again let's select the collage and we can see that it's creating itself in the background let's see what we get here where it might take a little bit extra longer because we had three images this time but we can see that worked really well we have our tall image we can see that it's beautifully cropped then we have our elephant and then we have our Northern Lights so let's do one more let's do a four where we have a grid of four images and after that I'll let you take it from here so I'm going to clone my number three and as we're doing this there's probably a good way to kind of abstract the different locations maybe you have a function that creates a top right corner or a bottom left corner but we'll let you be able to abstract that kind of thing on your own for now I'm just going to duplicate these just to make it easier so let's create our four key and then again because we used that same pattern on the right where we created those two items I'm going to do the same thing on the left where I'm going to add my first and second slot of the array where we're going going to make both of these 600 in height now the first one's going to be Northwest the second one's going to be Southwest and the only thing I need to do on top of this is just adjust the IDS that I'm using for the right side since I'm now using those for the left side so of course we now have two and we have three so let's go ahead and add one more image to the mix how about this picture with the pyramid I'm going to hit add and collage and we can see once it's finished we have our nice collage of 4 different images so once we're happy with our collage now we want to have the ability to save it into our library that's the whole point right we don't want to just look at this collage we want to save it so that we can use it we can share it so now we have this save to library button at the bottom of this UI that we can wire up to do just that so back inside the code where I have that dialogue UI I'm going to scroll down until I see that save to library button and of course on that button I'm going to add onclick let's add handle on Save creation so now let's take that function just to make sure that you kind of see what I'm writing here is an onclick handle on Save creation but now let's scroll up and actually add that function where how about we add it after we actually Define the create collage I'm going to name that with my little comment as I usually do and it it's not coming out there we go and what we're going to do is inside this function we're now going to upload that image similar to what we were doing inside of our media viewer when we were uploading or rather saving our image now to make this a little bit quicker and easier I'm hopping over to my media viewer file where we have that handle on Save copy and I'm just going to grab the code from there where we preload that image with that fetch now it'll probably be unnecessary since we're showing it but because we're showing in the image it works a little bit differently nonetheless let's just include that fetch it'll be quick if it's already created and then we can grab that upload code and we're going to want to invalidate the queries after but we're going to do that a little bit differently we're we're going to add the resource since we're on the gallery page so I'm not going to include that one I'm only going to include that Fetch and the actual upload request so inside of my handle on Save creation I'm going to go ahead and just paste that in and of course we need the URL for that so that's going to be creation URL and of course it needs to exist but it might not exist so we want to make sure that we handle the event that somebody clicks that save and it doesn't exist even though technically if we're only showing the UI it needs to so we'll say if type of creation. URL equals string make sure you see this we're going to Simply return for now and we can see that I still get errors because I need to first of all make this async and I'm realizing this needs to be not string not just a string and and we can see that the other one goes away but we can see that we also want to be able to pass in I can get rid of the optional chaining for this one we want to pass in that URL as the body of the request and then ultimately we're going to get this data and let's console log this out just to see if it's working so let's go ahead and hit save to library and of course we need to wait for that upload to actually finish let's see if we get a response out of this and we can see that our data comes back with our new upload so I'm going to copy that URL rather the secure URL and if I go to this we can see that we have our creation Now if we have a successfully saved creation we want to do two things first of all I want to dismiss this UI but also I want to push that new resource into our actual resource Gallery so that when I hit close here it's actually going to show up so the first thing I'm going to do is if we remember our used resources hook we have this add resources function which allows us to set the resource into State and then eventually EV invalidate it and we're returning it from that hook so I'm going to go ahead and destructure add resources from that and if I now scroll down to my handle on Save creation I can say add resources where I can pass in that data as an item of that array now we're also using this creation and set creation state in order to kind of determine where we're at with that creation so we use the state of created when we want to first pop up that dialogue we set that Ur in the type so we want to also reset that so that this goes back to undefine and then it dismisses that dialogue and generally just resets that creation state so I'm going to go down and I'm also going to add set creation undefined now finally because we're using these selected items in order to create it after we dismiss that UI and have handle the save a creation we should also reset the selection because the intent is to use those create it and then save it it's not necessarily meant to continue doing more and more things so as a convenience let's also dismiss the selected UI so on our selected State we can also use the set selected function where we can revert it back to its default state of just an empty array so if I head back down I can also say set selected and I'm going to make that an empty array so now this time when I go ahead and try to create a collage we can now save it to the library and once it finishes we can see that it was pushed into that state and everything was reset so now we can start to interact with that particular image now if you notice whenever we try to save to library if I go ahead and select two of my images again and open up that dialogue we never gave any user feedback if it was actually saving so it kind of looked like the UI was just stalled when we push that button so similar to what we did with deleting let's update this button to you have a little loading indicator so to do this we're going to manage it with our creation state where we're going to set a new value for State whenever we do this so I'm going to use this same set creation function where at this time I'm going to pass in a function as the argument because what we're going to do is we're going to take the previous value and we're going to create a new object that first off we're going to spread out that previous value but then because we want to keep all the previous attributes including the URL and the type but then we're going to say state is saving now we can see that we get a type error because of previous because it could potentially be undefined so let's just say if previous more of an edge case let's just return now if we head down to the modal UI let's scroll down to that button where we're going to dynamically show a different save button where let's let's first say creation State equals saving if we're if we have that saving State we're going to show a different icon but let's have that first where if we do not have that state of saving we'll then show that save button so let's go borrow that same loading spinner from the other page where again going back to where we deleted the item we can see we have this loader to with the animate spin so let's go ahead and copy that I'm going to go ahead and paste that directly into that existing place and as usual I can use command period to automatically update that import and now let's give that a try so now if I try to hit save to library we can see that we get that nice little loading spinner as it was actually saving that time it was fast but in case it's slow it just gives a little bit better of a feedback of what's going on but we probably Alo want to make sure that this doesn't fire an additional save if somebody were to click it again and again we can go back to whether we want to use a disabled attribute or we can do it via JavaScript so for now let's just do it with JavaScript where I'm also going to say if the creation or creation state state equals saving so now if I try to hit that multiple times it's only going to fire that once and save it to the library and then once it's complete push that one instance in okay so I think that does a pretty good job at managing our collage and our general workflow for being able to add those Creations but what's next so if we want to select some of these other images what if I want to select this penguin and I want to have it maybe automatically zoom into that penguin using some kind of animated effect now what I can do is I can go up to my plus sign and then since we don't currently have one it's showing none for just one but maybe we can show an animation so the first thing I'm going to do is create a new menu item where we're going to have a similar con straight the first thing I'm going to do is duplicate that but what we're going to do is this time we're going to say if selected length equals one we're going to allow someone to create an animation so of course we need to upload this call back handle on create animation where now we can scroll back up and how about we make this underneath where we're creating our collage so I'm going to add function handle on create animation I'm going to add my little note as usual and we can do the same kind of thing that we did with the collage so I'm going to go ahead and copy that set creation code and we can probably technically just add the URL here because we're only going to create one instance of it but I like the idea of keeping that code organized inside of the Creations lib so that it's just an easy way to find all the different creation that we're going to make so I'm going to get this seated with a get animation function where let's head over to lib where I can head down to the how about the bottom of the file and I'm going to say function get animation let's add a little note here for separation and we're going to do a similar thing to what we did with our collage so I'm going to go ahead except we're not going to do a template this time since we're only going to have one later if you want maybe you can take multiple images and creating a frame by frame animation but for now let's just copy this get URL function paste it it inside but this time we're going to use a different method of how we actually create our different creation Now let me first add this as my array of strings to make sure that we have that typed out properly but this time we're going to create a zoom image and we're going to use an effect called Zoom pan so what I can do on this is I can simply say Zoom pan set that to true and when it comes to cropping by default if you remember the library uses G Auto or gravity of Auto and that actually conflicts with the zoom pan feature so we're going to add a gravity of center now heading back for a second to the dialogue inside a media gallery that we're using to actually display the creation image this crop mode that we have on here conflicts with that same gravity of Auto now if you remember we added that in the first place because we were just trying to preview our image and any creation that we create will be returned as 12 by 1200 by 1200 so we actually no longer need that so I'm going to get rid of the crop on that preview image where now we're just displaying a 1200 X 1200 and we're preserving the transformations of our creation URL but if we now head back to the Creations file we need to make sure that we do actually export our get animation function so that we can now import it into our media Gallery so if I head back up to where we're using that we have our get animation I'm going to hit command period so that I can update that import and of course we're no longer creating a collage we're creating an animation and now let's give that a try where I'm going to go ahead and select this penguin I'm going to hit plus hit animation and this one might take a little bit longer than the others because there's a it's a heavier processing in order to create an animation a gif of course so well that was decently quick but we can see that it's zooming in to the focal point of the image which is pretty cool now if you noticed it stopped it doesn't Loop by default but we can really easily enable that now all we need to do is back where we have our Zoom pan defined I'm just going to Simply pass in a string of Loop now just as a quick note if you want to take that further you can actually Define this as an object where you can pass in some custom options such as maybe you want to zoom into a specific region or maybe you want to I don't know just do some more advanced effects with it check out the documentation for Zoom pan there's some pretty cool things you could do with it but for now I'm just interested in focusing in on that and zooming and then doing a loop with the animation so now let's try this again with our same penguin friend it should generate a new image because I'm using that version number of course but once we get it we can see that we get that lovely animation let's see if it loops and it does so that worked perfectly and we able to give a cool animation effect for any of the images that we want to select now as a final creation we're going to create a color pop and what do I mean by color pop well let's think about this elephant for a moment where what we're going to do is we're going to desaturate the background so that the only color in the image is our elephant friend himself and the way that we're going to do that is a little bit creative where the first thing we'll do is we'll remove the background kind of similar to if you remember how we had this option to remove background we're going to do that but we're going to do it in an API endpoint so that we can track its its usage or rather the removal we're going to then upload that separately because then we'll desaturate the original image and then overlay on top the image with the color so let's start off by creating the trigger me mechanism where we have our animation and our collage so let's now add another one and we're going to call this color pop and if you notice this isn't in ABC order with collage but it doesn't matter because this is only showing at more than one and the are showing at only one so you can kind of set that up how you want depending on your use case but now let's update that on click Handler and let's call this handle on create color pop or yeah looks like we have creating all those but then underneath all my other ones let's just clone this one I'm going to now rename this on create color pop I'm going to say created color pop but now our URL is going to work a little bit differently now this is going to be an asynchronous process where we're going to do this in an API endpoint because we need to do that extra processing it's a little bit more complex in composing this image so we're going to first create that image using our API endpoint and then we'll set that creation data but if you remember earlier we were talking about how we were using different states for our creation where we're going to create a creating state so that while that's loading it's going to be able to show us a little animation but let's first set up the actual image itself and then we'll get to that loading state so inside of my app API directory I'm going to create a new folder called creations and inside that I'm going to create a new folder called colorpop and then finally inside that I'm going to clone one of my existing routes let's just clone the upload route so that we can kind of start off with some of the existing boiler plate now we'll be using some of this existing code specifically we'll be taking in the color the public ID that we want to create this out of but we're not going to use a URL so we can get rid of that but we are going to need to upload this image in order to get that removed background variation or rather store the variation with the background removed so we're going to keep some of those upload options but first we need to create that URL that we're going to use to remove the background so at the top I'm going to additionally import get clld image URL from next cloudinary and then I'm going to use that to create my cons background removed URL and let me hide the sidebar just to give us some extra room here where I'm going to run that function I'm going to pass in the source as my public ID and I'm going to add remove remove background set to true now another important factor about this is when we upload that image and or rather when we create the URL and then we pass it along we want to make sure that that's always going to be a PNG because we want to preserve that transparency and as I mentioned earlier when you have format of Auto which is default with get SE image URL you might have a different way of or rather the format might be detected in a different way that it is in the browser because it's in that node environment so let's add a format of ping explicitly there and then I'm also going to pull off the quality attribute because we don't want to mess with the quality since we're still trying to maintain the default image or rather the source image we just want the background removed from it and then as we remember we did in other creations we're just going to set a version where we're going to use date. now and that's not going to really matter what version or what date that we set since it's going to be on the server time it's just the fact that we're trying to get a unique version for that but then since we have this background removed URL before we go forward and try to start to compose that image Let's test this out and just wire up the workflow so that we can actually see it happening in progress so I'm going to go ahead and comment out this upload code and I'm going to Simply pass back this URL as my background removed URL now inside of my handle on create color pop function I can now await fetch my API where it's the Creations color pop endpoint I'm going to pass my method of post my body which is going to be json.stringify including my public ID which will be the selected zero remember our selected array is going to include those public IDs so we're going to grab the first one and then of course I need to make this fun function async but the result of this is going to include that URL so I'm going to Simply destructure that once we get that response and I'm going to need to make sure I pass on a then so that I can actually turn that response into Jason before I pass it through we're ultimately I'll take that URL and pass that right along to set creation so now heading back let's test this out where let's pick out this picture from Athens and I'm going to go ahead and click plus color pop and it looks like we have an issue so let's look at the web console for a second and it looks like we're getting those 423s now if you remember the 423 status means that it's processing and we have a little bit of an issue there where we can see once it was updated we were able to get that actually added into the UI which is great but in the meantime we need to actually pull for that background to be removed before we can actually display it now we could probably try to fix up the UI so that while it's pulling it's going to show properly inside of here but if you remember we're going to take the result of that removed background and we're going to actually overlay it on the original image so we're going to need it before we get back to this part of the UI so that's what we need to do inside of the endpoint so that we can pull for that image make sure that the background is removed and then we'll apply it to the original image so the way that I'm going to do this is I'm going to create an async function that I'm going to call check status now this check status is going to take in a URL and that URL is going to be whatever we pass it and in particular it's going to be this background removed URL where let's set this up and the very first thing I'm going to do is I'm going to try to fetch that image so I'm going to say constant result is equal to or let's call this response is equal to await fetch that URL and then I'm going to see if that response is okay rather or it's not an error or something like that where the 423 would say that it's not okay so I'm going to say if the response is okay and if it is okay I'm just going to Simply return true because the point of this isn't to get that URL it's just to check if it is okay so we're just going to try to return something now after that if it's not okay there's two things I want to do first of all I just want to put in a little bit of a delay just so that we're not spamming this end point but then I'm going to set this up so that it's triggering recursively so if it's not okay it's going to check it again if that's not okay it's going to check it again and so on until it is okay and then it will basically return that true again it will resolve and we can move on so I'm going to say await new promise we going to grab resolve and inside I'm going to set time out we're inside there I'm just going to Simply make this happen for 500 milliseconds again just so we're not spamming this thing and then we can say resolve undefined but after we get through that after that little delay I'm going to return this check status function and I'm going to pass through that same URL now I think I need to have my aait on here but once we now have this all set up I can now try to use this check status so I'm going to run aait check status I might not need that a in that context but this is going to allow us to now pass in our background removed URL so again let's walk through this flow once I check my status of the URL it's going to first try to get that and then if it's not if it is okay if it's a 200 level response or whatever the that's going to trigger the okay it's just going to return true it's good we can continue on but if it's not okay let's wait for 500 milliseconds and then check it again if that's not okay again we'll check it again and so on until it is okay and then we'll continue through where now we know after this that it is okay and we can just return that with a response so let's try this again how about with our Penguins this time I'm going to go ahead and Trigger the color pop we can see that it might take a moment where this is where we're going to create the creating status if we remember but once that UI pops up we can see that it's starting to load and then we have the image with the background removed now one thing you might notice is the image is still tall we just never cropped it where the other ones again remember we need to return an image with the background or with the image already cropped but we're going to handle that afterwards so let's move on now once we have that background removed URL we know that everything is okay we can now upload this so that we can then use it later so I'm going to uncomment this code and we don't need all this stuff you know maybe one thing that I usually like to do is I like to tag it where we can say something like background removed I also like to sometimes tag with the original so that if I ever need to reference it I can so let's say original where we can pass in that public ID of the original image but then I can continue on I can pass in that background removed URL as my upload so then once we have those results we can now pass that back but we're going to use that that as a creation URL but first let's just pass back that results. secure URL just to make sure that that process is working in the first place so I'm going to trigger it again on the same Penguins because we know that we're going to create a a unique process for all that but we can see now we're going to get that URL and it's working so now I'm going to go ahead and copy the same code that I created for the background I'm going to paste that below the results but this time it's going to be the creation URL we can pass in instead of or rather we're going to keep that public ID we don't need to remove the background we don't need to change the format we don't need to change the quality we do want to set the version but one thing we're going to do we're going to say grayscale true and then we're going to add an overlay which is where we're going to add the the new image with the background removed so let's say overlays where we're going to specify our array with our object where the public ID will be our results dopu ID now if you remember we also need to make sure that we crop this image before passing it along so I'm going to set my width of 1200 my height of 1200 and then I'm going to set up my crop property where of course we need to make sure we're cropping the source of this we're going to set a type of fill and then I'm going to also set a gravity of Center just to make sure that those two images are going to be aligned as they're getting added together but then I'm going to take that creation URL and I'm going to pass that back as my response but now heading back to the browser let's give this a try I'm going to hit color pop and remember it'll take a little second we're going to fix that delay so that we can actually show some kind of UI but we can see we get our color pop we have a background with the desaturation and we have our colors now let's maybe try that again with I think the Athens one might be cool or at least it might be pretty obvious of the the actual result but we're going to go through that backround removal process now the first time an image has its background removed it'll take extra long and then other images will be quicker but we can see we now get that same effect but I'm going to try this one more time cuz my elephant friend was the original one that I wanted to test this out on we can see once it goes through that process of removing it we get our popup with the creation and we can see that we have a nice pop effect color pop effect for our elephant but now let's fix that little UI issue now the reason it's having that delayed effect in showing the modal if you remember we're first hitting that endpoint and when we hit that endpoint it can potentially take a little bit of time so what we want to do is we want to put our creation modal in a state that indicates that currently loading but so that it can show immediately and then show that kind of loading indicator so we're going to take take our set creation and the very first thing we're going to do is we're going to set our creation but let's put that in a state of creating now of course we're not going to have a URL yet so let's just make that undefined it can really be any value at this point looks like URL doesn't like that though so let's go ahead and make sure let's make that optional and if we head back to the UI and try this out we can see that it does show that UI right away as it's making that API request so that definitely is an improvement already but now let's show some kind of loading indicator now heading down to our creation dialogue we have a bunch of content that we probably only want to show if we're able to actually save where we're trying to show something before we're ready to save so the first thing I'm going to do is I'm going to wrap everything in here with to check that it's in the right State and if we remember so first of off first off I'm going to use the includes method like we did earlier and I'm going to say we have two states we have created and we have saving that I want to include in this so I'm going to check if these includes my creation State and if it does then I'm going to wrap everything inside I'm going to add a fragment so that I can control all these components inside let's just go ahead and indent this twice going to add that fragment and then I'm going to close that off so now if it's in that state looks like I spelled that wrong if it's in that state we'll show what's inside now it looks like I can't just pass this in as an undefined value so I'll first check and see if that exists first and then I'll check if it's included in that state but now if I try to select it and go to color pop we can see that it pops up as basically an empty dialogue and then it brings it in when it actually has that URL so now let's add that loading spinner so right above it I'm going to basically do the same thing let me close that off but I'm going to say that I want this to be in the state of cre skating before I actually show anything but once we're in that state I'm going to show that same loading icon that we used elsewhere so what is that loader because when we were using that for the save button so that was just a little bit down I'm going to grab that same loader and I'm going to go ahead and paste that inside now of course we're going to want that to be a little bit bigger and I know I want this to be 12x 12 I also want to put a wrapper around this because I don't want it to just be hugged up tight next to the loader itself I want to give it a little bit of breathing room so I'm going to also wrap this with a div where on that div I'm going to set a class name first of all Flex because I want to items Center I want to justify Center but then I'm going to add P of let's call this 12 but now that we have that loading indicator let's give that a try I'm going to hit colourpop again and we see that we have that nice spinning animation before the colour pop actually comes up so we're indicating that it's currently loading and then we get the second loading indicator which maybe we can reduce that a little bit in some way but either way we're able to get that experience where we're showing that it's processing before it actually gets to the image itself but then of course I think I like this one so I'm going to just save this one to the library now these creations wouldn't be fun unless I added some icons so let's quickly add some icons to the different options that we have available now heading back into Lucid I think I like this layout panel left for my collage one I think that probably indicates a good value on that for my animation I found this Square stack one that I think looks pretty good it shows that it's going in frames and then for colourpop I had a little bit of a hard time trying to think think this through of what I wanted to use but ultimately I settled on using drop so that indicates that I have a drop of color so for my animation I'm going to add my Square stack icon I'm going to make sure I import that in I'm going to add my class name with a width of four a height of four and also a margin right of two just to give a little space I'm going to copy that and paste it into color drop where I'm going to use the droplet going to need to make sure I import that as well and then finally for my collage it's going to be layout panel left and I'll go ahead and import that one as well so now back in the browser I can open up that menu and I see my animation in my colourpop now let's select one more so that we have for the two selected option where now we can see the collage and of course that's not incredibly necessary but it gives it a nice touch so that we can kind of have a good visual reference of what we're selecting now I added all these creations to my media library every time I created one but I don't have a good way of only seeing the animations what if I wanted to kind of filter out all the originals and I just wanted to see the fun ones that I created now what we can do is we can add a new navigation item so if we select this we go to our creations page and on that creations page we only query for things that contain that specific tag related to Creations so that also means that we need to only tag our creations with a specific tag so let's start off by creating that new page where we can include those Creations so under the page PES route I'm going to create a new folder called Creations where I'm going to just simply duplicate this original page that I have and if we remember this is our default homepage in its current state where this is just going to query all of our Library resources remember we're tagging those originally so that we can add those to the page we pass them into media gallery from our server response and then we also pass in that tag so that we pass along the information to make that request on the client as well so the first thing that we need to do is we need to query for those images that only match that tag but we haven't yet added that tag so I'm going to first open up my env. loal and let's create a new tag for creations and let's call this Simply Creations now copying that value let's head back over to our page and I want to make sure that when I query for my res Resources by tag I'm going to query for that New Creations tag and that when I pass it into media Gallery I'm querying for that as well now if I tried to go to that creations page it's understandably empty because again I no longer have any of those Creations actually tagged as a creation so I'm going to head back to my photos and what we're going to do is we're going to create new creations and every time we do we're going to make sure we add that tag so let's head over to our media Gallery where we find our handle on Save creation function and inside of that upload request let's add another field where we're going to call that tags and let's pass in that tag that we just created or let me copy that value and it's it's going to be process.env that tag name and I'm just going to wrap this in string just to be sure now that means over in our upload route we need to be able to accept those tags and then pass them into our upload options so what I'm going to do is I'm going to destructure those tags and we can see that we're already adding upload tags specifically for those Library tags and if we remember the logic here first second we're currently checking if type of public ID equals string and that's if we're passing in an image that already exists because we want to overwrite it so where where we have this options. tags this is because we're just tagging every image that's new with that General Library tag so we're going to do the same thing but this time we're going to spread out our tags if they are available and we can even make this an empty array by default that way if we don't pass in tags that we're not going to have any issues but now let's try that one more time I'm going to go ahead and select my elephant friend again let's try to make the color pop again now once this loads I'm going to go ahead and save this to library we can see it was pushed into the media library but now let's check and see if it was actually available as a creation so I'm going to go to creations and we can see that it's there because it's now tagged as creation and we're querying for only those Creations on this page now let's add one more let's select the northern lights and our Penguins let's do a collage just so that we at least have two there I'm going to save this to library we have it in our library and then in inside of Creations we now have two but now we still have one big issue in that we have no way of actually navigating there unless we manually go there and that's not good ux so let's add a sidebar link for this if I head over to my Pages directory here I'm going to go down until I see my layout now inside of my layout I have this component called sidebar links and not to go too deep into this but again we're rendering a server component as the default layout but then I'm using this sidebar links as a client component so I can determine path name and show some kind of indicator that that link is the active link with some styling but inside of sidebar links I can now just add a new path that new path is going to be creations and then I can call that label of Creations now of course we want to also assign a icon image for this like we usually do and then for this icon I like the idea of sparkles for this so I'm going to use Sparkles so I'm going to call this Sparkles and then I'm going to import that and we can see that it's nicely displayed on the sidebar here if I select Creations we can see that it loaded that page with just the Creations now there's so many things that you can do to take this project beyond what we created whether you want to add more Creations maybe you can add favorites where you add a tag if somebody favorites an image but there's so many Transformations and effects that you can really have a lot of fun with building out your own Google photos clone now as a reminder if you want to check out the full demo or if you even want to contribute to this demo definitely check out photobox where you can check it out at photob box. where you can see all the Fe features that I built into it and hopefully you can contribute a future to it too I hope this has been a fun project for you to learn through all the intricacies of nextjs and using these different image editing techniques I know I had a ton of fun building it but what's your favorite Google photos feature or what's your favorite feature that you're going to add to your own application let us know in the comments and remember head over to C.M medfree codecamp so you can make sure you claim your bonus 3 credits I'm Colby fok and thanks free code camp for this collaboration thanks for watching