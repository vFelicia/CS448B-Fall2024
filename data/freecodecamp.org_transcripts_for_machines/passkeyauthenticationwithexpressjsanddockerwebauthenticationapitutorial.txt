Learn more about the Web Authentication API by building an app that implements past key authentication. The Web Authentication API lets you create and use originscoped public key credentials to authenticate users. At the end of this course, you will have an Express.js app connected to a Postgres database inside a Docker container. Hello and welcome to this Dev Rhino video here on the Free Code Camp channel. So glad to see you. In this tutorial, we will learn more about the Web Authentication API by building an Express.js app that implements past key authentication. To follow along, you will need to have Docker installed and running. You can head over to their website to find the version that suits your environment. Even though we're using Node.js in this tutorial, you do not have to have it installed on your machine. This tutorial will focus on the key concepts involved in the implementation of a public key pair credential system. It does not dive into security, any robust error handling, data validation, or any other authentication edge case. By the end of the tutorial, we will have created an app that will allow the user to register and create a pass key with an authenticator of their choice. They will also be able to log out and log back in with their brand new pass key. Now let's get started. We can begin by creating a new folder for our project and immediately changing into it. Then we will create the config files we'll need to work with Docker. We'll create a Docker file, a Docker Compose.yaml file, and a.dockerignore file. Now let's open up the Docker file to add an instruction to pull the official Node.js image for version 19. We will also add an instruction to set the path to the working directory. Over in the dockercompose.yaml file, we will set the version to 3.8. Then we will create our first service for our web server. It will use port 3000 and persist data in a volume. In the.dockerignore file, we will want to ignore node modules and any NPM debugging logs. That's the minimal config we need to get started. We can now run the Docker Compose up command to create our new container. Now we can verify that Node.js was successfully installed by entering our web container and checking for the version. If you see a similar printout, you're good to go. While we're still in the web container shell, let's initialize our project to use NPM. Then we can install the express package as a dependency. Now we can create a new index.js file to act as the entry point to our application. Then we can head to the express.js documentation and copy over the example web server starter code. We'll update the port constant to use an environment variable and also set the host variable to listen to any available network interface. Now we can start up our web server by running the node index.js command. If we open up local host port 3000 in our browser, we should see the hello world text. Let's head back to our web server code and say hello to the universe instead. If we go and refresh our browser now, our changes are not reflected. Our app has no way of rebuilding on the fly yet. To introduce this behavior, we can install the node mon package as a dev dependency. Now with this package, we can start our web server by using the node mon command instead. If we head to our browser now, our changes are reflected upon refresh. But what happens if we delete our node modules folder? Perhaps a teammate has cloned the repository and has not installed the dependencies. If they try to run the web server, they will see a message about missing packages. They could always just reinstall them, but this is kind of sad. Let's improve the developer experience by updating our Docker file with an instruction to copy over the package.json files. Then we can add another instruction to install dependencies. So now whenever a new dev spins up this project, they have all the dependencies they need. We will also head over to the dockercompose.yaml file and add a volume to persist the node modules between builds. We should also add the startup command here too, so that it maps to the dockercompose up command. Now we can exit the web container and rebuild our app. We can restart our app using the dockercompose up command. If we head into our browser, nothing has visually changed. However, our app is still functioning as expected, which is a good sign. To round this section out, we will add some final touches to our docker file. We can add a line for the starting command, then we can add another instruction that copies all the project files from the host into the container. These instructions won't make a difference for our local setup, but they will be useful if we ever deploy our app to a service that doesn't support dockercompose. This section is over and you're doing great. Let's keep going. In this section, we will set SQLize up as our ORM. While our app is still running, we can open a different terminal tab and install the SQLize package. Then we can also install the SQLize CLI package as a dev dependency. Once that is installed, we can initialize SQLize for our project using the CLI tool. This command will create all the files we need. However, they are not in the locations that we'd like to have them in. So let's do some housekeeping. Let's create a couple of new directories called app and db. Then let's move the models directory into the new app directory. We'll move the migrations folder into db and the cdys folder into the db folder as well. Then we will rename the config.json file to database.js. Now we will open up the models index file and make sure our config is pointing to the correct file. We've made quite a few changes, but SQLize expects the files it generates to be found in specific locations. So we need to create a SQLize RC config file to overwrite the default paths that SQLize expects. Finally, we need to update our database config file. We'll convert the JSON to JavaScript and store it in a constant called db settings, which we will export. We need to convert this file from JSON to JavaScript so we can access environment variables. We also change the dialect from MySQL to PostgreSQL. By default, SQLize uses MySQL. Let's set up a Postgres database for our application. We've already started using environment variables in our code, but we haven't actually defined them yet. So let's create a.env file to store them. The PG host will point to the database container that we will create shortly. PG port will be set to the default port for Postgres. PG user will be the name of the user that will connect to the database. PG password will be the password and PG database will be set to the name we will give our database. Once our variables are defined, we can head into the dockercompose.yaml file and tell our web service to pull them in. Now we can set up a new service for our Postgres database. We will not set up our own docker file for this service. And instead we will use an official Postgres image. We will also use the environment variables from the.env file to set up our database. The port will use the default Postgres port and we will set up a named volume to persist our database between builds. Lastly, we will set the web service to depend on this new DB service. Now let's build our database container. We can kill the server and rebuild the app. Then we can start it up again. We will access the shell of the new DB container and use psql to connect to our database using the credentials we have stored in our.env file. If you see a similar output, your database has been set up. We can also use a database client to connect to our database. We can use the same credentials from our.env file here as well. Our database is currently empty. While we have seen how we can connect to the database manually, we should also give our web server a way to connect programmatically. Let's head back into the terminal and install the Postgres package. Then we can create a helpers folder in our DB directory. Here we will create a little file that will allow our code to access the database. This file will define and export a module called DB. This module will use SQLize to create a new database connection using the variables located in our.env file. We will also set the dialect to PostgreSQL. Now that our app can use SQLize to connect to the database, let's generate our first SQLize model. This will correspond to a database table. We will run the model generate command to create a user model. We will give it a name and a single attribute for email. This command will generate a new model file and an accompanying migration file. Let's open up our user model file and add some more attributes. We can see that our email attribute already exists, which is expected. Now let's improve it and tell SQLize that it should be unique. We can now add a new handle attribute and the usual timestamp columns. We want to follow a different convention for the table names. So let's also provide a new table name setting. We can head over to our migration file and update the table names in there as well. Let's also tell the migration that we need the email to be unique. We can add the handle attribute here as well. Now we have enough to migrate the database. We can use the SQLize CLI tool to perform the migration. Once the command executes, we can see that the settings in our migration file have been applied. If we open up our database client, we can see a new user's table that contains all the columns we configured. Let's set up a dedicated routes file and our first controller. In our terminal, let's create a new file to organize our routes. Within this new routes file, we will import the express package so that we can create a new router. Now that we have a dedicated routes file, we no longer need to put our routes in the index.js file. Let's cut our only route from index.js and paste it into the routes file. And then let's import and use our routes file within index.js. Now let's create a new folder for our controllers. Within the controllers folder, we can create a new pages controller. Introducing controllers will allow us to further clean up our route handlers. Inside the pages controller, let's add a new action called welcome. The new welcome action is a callback handler that we will pass to our routes. It takes a request, a response, and the next callback as its arguments. Within its body, it will check for a user. If there is no user, it will render a welcome message. If there is a user, it will call the next function on the stack. If this pattern looks familiar, it's because this is just a regular old middleware function that is commonly seen in Next.js apps. Now we can head back into our routes file and clean it up a little further. We will import the pages controller and set up the route route so that it calls the welcome action from the pages controller. And with that, we now have the concept of routes and controllers within our app. Now let's configure our app for frontend views and static assets. We will be using the EJS and Express EJS layout packages so we can hop into the terminal and install them. Then we can head into the index.js file to configure them. We will tell our app to use layouts and we will set the path to where all our view files will live. Then we will set our default layout file and also set our view engine to use EJS. We are using the path package so we should import it. Now that our app is configured to handle views, let's create a folder for them. We will start working on the global application layout first. So let's create a folder and a file for it. We can open up the application layout file and add some boilerplate HTML markup to it. There isn't much happening here. We've just given it a title and specified that it should be responsive. The only interesting part is this template string. This is the bit that will pull the body content from our individual view files. Now we can create our first real page. Since we've already got a welcome controller action, it only makes sense to create a new welcome view. We will head to the project repository and copy over the markup for our new welcome page. HTML is out of scope for this tutorial, so we will not go over this. But please feel free to dive into it on your own if you're interested. Now that we have a proper welcome page, we can head into the pages controller and update the action to render it. If we head into the browser now, we can see the content we added for the welcome page. Now let's work on giving our views some styles. Back in the terminal, we can create a new CSS file in the public folder. Then we will head into the project repo and copy over the readymade CSS. CSS is also out of scope for this video, so we will not be explaining any of the styles. Once we save the file and head into the browser, we see that nothing happened. That's because our app knows nothing about this new style sheet we added. So first we can head into our application layout file and import our style sheet. Then we can open up the index.js file and configure our app to look for static assets in the public folder. Now when we go back to our browser and refresh, we should see our styles coming through, but our logo is broken. Let's go back to the project repository and download the images folder. Then we can drag it into our local public folder. Inside we have three custom cursor images and a couple of different logos. If we head back into our browser now, our logo image should now be showing up. Now let's create a page that will hold our registration form. If we head into the browser now and click on the register button, we're met with an error saying the register route does not exist. Well, this makes sense because we haven't created a register route yet. Let's open up our routes file and get to work. We're importing the auth controller that doesn't exist yet. Then we add a new get route handler that calls an action called register, which will live in the auth controller that we will create now. We can open up the new auth controller and add the register action, which will render the register view. Then we will head into the project repo and copy over the markup for the register view. If we refresh our browser now, our register page should be rendering correctly. Now let's create a page for our login form. Then we can add a route handler for the login route and inside our auth controller, we can add a login action that will render the login page. Then we can head into the project repo and copy over the markup for this login page. Once that is saved, we can head back into the browser and check it out. It looks very similar to the register page, but this is the login form. Now let's set up the final page, which will be the dashboard. Let's add a new view file for it and we will update the route route to take a second action. Then we can create a new admin controller and add a dashboard action, which will render the dashboard page. This dashboard action is the one we referenced back in the routes file. Now let's get the markup for the dashboard and paste it into the view file. We will not view the dashboard page in the browser for now. It can be a nice little surprise once we start implementing pass keys. We've made it to another milestone. We've covered a lot and you've been phenomenal. Let's create a model and migration for the public key credentials. We already have a users table. Now we need a public key credentials table to store the public keys for each user. We will use the model generate command from the SQLI CLI tool, giving it a model name and a single attribute, which is the public key string. This command will generate a model file and an accompanying migration file. We can open up the public key credentials model and add a couple more attributes for username and external ID. These columns will help us identify public keys and associate them to specific users. And since we're following a different convention for table names, let's also configure the table name setting too. We will add a belongs to association because a public key should belong to a user record through the user ID. Now let's open up the migration file and add the same attributes here as well. Then we must also remember to update the table name to match the new table name we set in the model file. We've already stated that public key records belong to users. So we should head into the user's model and indicate that a user has many public key credentials. Now we can migrate the database so that our new changes can be applied. If we open up our database client, we can see a brand new table called public key credentials. Our database is all set now. Now let's configure Passport.js to handle authentication. We will be creating a service to organize our Passport.js related code. Let's first install the base Passport package. Then we can install the Passport Web Authent strategy package. This will give us the ability to authenticate with pass keys. Now we can create a new file for a service in the services directory. We will set up the module with an init method that contains the three main functions we need to implement. Now we can head into our routes file and import our newly created Passport service. We will also import the session challenge store from the WebAuthn strategy package because we will need this to generate challenges. Then we can create a new instance of the Passport service and a new instance of the session challenge store. Then we can initialize the Passport service instance and pass the challenge store to it. Back in our Passport service file, the first thing we need to do is configure Passport to use the WebAuthn strategy. The Passport use method accepts a callback. We have created one that we have called use WebAuthn strategy. Within the function body, we will return a new WebAuthn strategy instance, which takes three pieces of information. First, we will pass in the challenge store in an object. Then we will pass in a verify callback and a register callback. We should also remember to import the Passport and WebAuthn strategy packages at the top of the file since we are using them. The verify callback will be used when a user logs in and the register callback will be used when a user registers a new account. Neither of these callbacks exist yet, so we will need to create them. We can start with the verify callback. The end goal of this function is to look up a specified user in the database and get their public key. It will be an async function that takes in an ID, user handle, and a done callback. We've made it an async function because it will be interacting with our database. Within the body of the function, we will create a database transaction. If anything were to go wrong, the database transaction will allow us to roll back our actions without persisting the changes to the database. We're using the DB helper, so we should remember to import it at the top of the file. Back in the function body, we will use a trycatch statement. If the actions within the try block are successful, we will commit the transaction. However, if we get an error, we will drop into the catch block and roll back the transaction. Now let's put together our database interactions. Back in the try block, we will use SQLize to find one public key credentials record from the database where the external ID matches the ID value we passed into the verify function. We must also remember to pass in the transaction because we want this action to be wrapped in a database transaction. We're using the models object here, so we should import it at the top of the file. For some basic error handling, we will send back an error message if we cannot find the public key credentials. Now let's try to find the specific user that owns the public key credential. We will also remember to pass the transaction to this action as well because we want it to be wrapped within the same database transaction as our first action. If we are unable to find the user, we will send an error message saying as much. We will also add another check to ensure that the user handle we passed in matches the user handle for the user we retrieved from the database. If all these actions are successful, we will commit the transaction and execute the done callback with the credentials record and public key. And now our verify function is complete. We can collapse it and work on the register callback. The end goal of this function is to create a new user and a new associated public key credentials record and persist them in the database. It will be an async function that takes in a user, ID, public key, and a done callback. Within the body of the function, we will create a database transaction. If anything were to go wrong, the database transaction will allow us to roll back our changes without persisting any data to the database. We will use a try catch statement. If the actions within the try block are successful, we will commit the transaction. However, if we get an error, we will drop into the catch block and roll back the transaction. Now let's put together our database interactions. In the try block, we will attempt to create a new user record in the database using values from the user object we passed into the register function. We will also remember to pass the transaction to this database interaction because we want to be able to roll it back if anything goes wrong. For some basic error handling, if we are unable to create a new user record, we will send back an error message. Next, we will try to create a new public key credentials record to associate with our new user record. Again, we are passing in the transaction because we want this action to be wrapped within the same database transaction as our user creation action. If we are unable to create new credentials, we will send back an error message. If the actions within the try block are successful, we will commit the transaction. But if we get an error, we will drop into the catch block and roll back the action. Now that the register function is also complete, we can collapse it and move on. Looking back at our notes, the next task we need to work on is to serialize the user to a token. Serialization involves taking in a regular JavaScript object containing user details and converting that into an encrypted string, which is also known as a token. To achieve this, we will use the serialize user method from the passport package. The serialize user method takes a callback, so we will create a little callback function to pass to it. We will just name it serialize user function because naming is difficult. When this callback function is executed, it will call nodes processNextTick function, which will invoke the done function with the JavaScript object containing user details. processNextTick is a Node.js thing and is a little out of scope for our current tutorial. The last thing we need for this passport service is the ability to deserialize a user. Deserialization involves reading and extracting user information from a token. We can use passport's deserialize user method here and pass it a little callback function that we will call deserialize user function. This is very similar to the serialize user function, but we send through the whole user object. The WebAuthn API requires session support, so let's set that up. We can kick things off by installing the express session package. We can also install the connect session SQLize package so we can use SQLize to store session data to our database. Now we can head into the index.js file and import the passport package, the express session package, and the connect session SQLize package. We should also import the DB helper since we will be storing session data in the database. Now we can create a new instance of a session store and configure it to use our existing database. We will now configure our app to use the session. We've set the secret to an environment variable that doesn't exist yet, so we will come back to it. We've also made sure to tell our app to use the session store we created above, and we've indicated that we'd like the cookies to expire after one week. In a real production system, this is the place we would also add more security related settings. Finally, we will sync our session store and also configure our app to use passport to authenticate with sessions. Now let's go back and add the session secret variable to our.env file. We're just using some random string. In order to see our changes take effect, we need to restart our server that has been running in a different terminal tab. If we visit our database client now, we should see a new sessions table. This is automatically generated for us. If you are having trouble seeing the same results, you may need to head into the browser and do a quick refresh. Now our app supports sessions. While we're in a configuration mood, let's head back into index.js and add a few more helpful settings. We need our app to be able to work with JSON, so let's configure it to use the builtin express.json function. We will also install and configure a package called Malta, so we can submit multipart form data. Then we will also install and configure the cookie parser package so that our app knows how to parse cookies. Finally, we should also configure our app to handle any URLs that contain query param data. We are now ready to take a highlevel look at how parse keys work. Public key cryptography is not a new concept. If you are familiar with RSA private and public keys, these ideas may feel vaguely familiar to you. However, parse keys are making the concept more mainstream with the goal of replacing password authentication. Pars keys are used in two different phases. The first phase is the attestation phase where the parse key is created during the user registration process. The second phase is the assertion phase where the user's credentials are verified, allowing them to log in. During these two phases, there are three main entities involved. First is the authenticator, which could be a smartphone, a password manager, or a USB device. Next is the client, an example of which could be a user interacting with their browser. And finally, the relying party, which could be your own server or the server of another application that supports parse keys. In the upcoming sections, we will implement the two different phases. Let's implement phase one where a parse key is created upon user registration. Before we dive into the code, let's go over a quick summary of the main things that happened between the client, the authenticator, and the relying party. First, the user submits the registration form, prompting the client to request a challenge from the relying party. Secondly, the client calls the navigator.credentials.create method. This will prompt the authenticator to use the challenge it receives to create a new credential key pair. The authenticator will pop up a dialogue asking the user for verification. In our case, this verification will be done through a fingerprint. Once the user is verified, the private key is stored on the authenticator and used to sign the challenge. Then the public key, the signed challenge, and the credential ID are sent back to the client. Finally, the client sends the public key, the signed challenge, and the credential ID to the relying party. The server verifies the signed challenge using the public key and the session information it receives. If the verification process is successful, the server will store the public key credentials and user details in the database. Now that we have an idea of the flow we want to achieve, let's start working on the code. Inside our code editor, let's find our bearings by taking a look inside the register view. At the very bottom of the file, we have imported two script files. However, neither of them exist yet, so we will need to create them. First, we will create the attestation register script file. Then we will create the base64url script file. We will head into the project repository and copy over the contents for the base64url script. The original GitHub link for this little utility helper can be found at the top of the file, so you can get the code from the original project as well. This base64url script will ensure that binary data and URLs are properly encoded to plain text to avoid ambiguity. Once we've saved the file, we can start working on our attestation register module. We will create a new register class that contains an init function. We have left some notes to guide us. The first three steps correspond to the steps we saw in the section overview. The fourth step is just a UX touch where we redirect the user to the dashboard. At the bottom of the file, we will listen for the window object to load. Once the window has loaded, we will add an event listener to the registration form so whenever it is submitted, we will create a new instance of our register class and call the init function. We will also prevent the default behavior that the browser gives to the form element. Our first function will allow the client to request a challenge from the server. It will be an async function that we will call getChallenge. In the body of this getChallenge function, we will make a request to this endpoint that doesn't exist yet. It will be a post request and we will send through the data a user submits through the registration form. Then at the end of the function, we will return the JSON response. Now let's go and add this register public key challenge and point to the routes file. We're adding a new post route handler that calls the createChallengeFrom function from the auth controller. This action doesn't exist yet so we can head into the auth controller and add it. Within the body of this action, we will return a middleware function. Inside this middleware function body, we will set up a user object. We will set its ID to a UUID value we generate. The name will be derived from the email address the user sends through in the registration form. We will also remember to import the UUID package at the top of the file. We haven't installed it yet, but we will install it shortly. We will then use the challenge method from the challenge store to set up, yep, you guessed it, a challenge. The user object and the challenge will be returned in the JSON response. We have used the base64 URL package to encode our user ID and challenge. We also use this on the front end, but this is the back end so it needs its own copy of the package. While we're here, we will also install the UUID package from earlier. We should also remember to import the base64 URL package before we move on. Now we can head back to our attestation register script and work on the second step. This is the step where the client will prompt the authenticator to use the challenge to generate a new credential key pair. It will be an async function that will receive a challenge. Then it will use the navigator credentials create function to create a new credential key pair. This navigator credentials create function is part of the web authentication API from JavaScript. At the end of the function, we will return the newly created credentials. You may have noticed that we passed in some options that don't exist yet, so we will need to create them. The first key we set up in the options object needs to be public key because this is the type of credential we are looking to create. We will also set the name of the relying party and then we will set up a user object containing the user details. Next, we will set the sign challenge we got from the previous step. And finally, we will set up an array of encrypted credentials the relying party will accept. Each of these correspond to a COSE cryptographic algorithm and are ordered with the most preferred algorithm at the top of the list. Finally, we will add an authenticator selection that prefers user verification. That's all we need for the second step. Let's collapse the function and move on to our third step. This step will send the credentials to the server for verification and return the authenticated user. We will create an async function that takes in user credentials. This request will also require us to send through some options, but we will build those in a separate function shortly. We will use the fetch API to send a request to the login public key endpoint that does not exist yet. This request will be a post request and we will pass along the options object which we have yet to create. Then we will return the response. Now onto the options. We'll set up a new function to build these. The response field will contain some details about the client data JSON and the attestation object. We will also check if the authenticator supports different types of transports. Transports can include things like Bluetooth, USB or smartphone desktop hybrids to name a few. A full list of options are available in the documentation. If the authenticator has transports, we will set those in the options too. Now let's work on the login public key endpoint. We will head into the routes file and add a new post route handler. This handler has three actions configured. When working with Express.js, we are able to move through a stack of middleware. So in this case, we will first use passport to perform a check to see if the user is authenticated correctly. If they are, we will grant them admission into the application. If the check indicates the user is not authenticated, then we will drop into the last middleware function in this list and deny them entry. This is very similar to border control at an airport. None of these actions exist yet. So we can head into the auth controller to create them. At the very top of the controller, we will set up our passport check. This function will be using the authenticate method from passport. So we will remember to import passport at the top of the file. The authenticator method takes in the strategy and an options object. We are using the web authenticity and setting up a couple of options that are related to error messages. Now we will work on admitting an authenticated user. If they are eligible for entry, we will set their destination to the route route. This will bring them to the dashboard. Then we can add the deny user function. We will first check the status code to ensure that it is not a 400 code so we can return early. But if we do get a 400 code and the user is not found, then we will indicate everything is not okay and redirect the unauthenticated user to the login page. This is all we need to authenticate a user. The final step we need to complete the registration process is to redirect the user to the appropriate page. Our redirect function is pretty straightforward. We will just set the window location's href value to the destination we set when checking the user's passport. Our registration flow is now complete. So let's head into the browser to test it out. We will use our cool email address to sign up. The client will then prompt the authenticator to seek verification from us. There are different options available to us. These options relate to the transports we set in our options earlier. If a user is on a Mac, they can opt to use the builtin key chain. They can also choose to authenticate using a QR code which they can scan on their smartphone. But for simplicity, we will use our Chrome profile. However, all other methods will work too. Once we hit continue, we will be asked to scan our fingerprint. And because our passport check was successful, we can now see our empty dashboard. We covered a lot of ground, but our registration is done. Thanks for persevering, you're doing a great job. Now let's add the ability for a user to log out. In our browser, we can see that we already have a logout button, but if we click it now, the world will end. We need to head back into our code and wire things up first. We will start in our routes file and add a new post route handler for the logout route, which we'll call the logout action which doesn't exist yet. So we can hop over to our auth controller to add it. The logout action will be a middleware function which will use the logout method from the request to log the user out and redirect them to the root route. You may be surprised, but this is all we need. Now, if we head back to the browser, we can safely click on the button to log our user out. Let's implement phase two, where a passkey is used to authenticate a user and sign them in. Before we start writing the code, let's see a quick summary of the main things that happen between the client, the authenticator, and the relying party in this phase. First, the user submits the signin form, prompting the client to request a new random challenge from the relying party. This first step is more or less the same as the first step of the attestation phase. Secondly, the client calls the navigator credentials get method. This will prompt the authenticator to request verification from the user. In our case, the verification will be done through a fingerprint. Once the user is verified, the authenticator will use the private key it had previously stored to sign the challenge. Then it will send the sign challenge, the credential ID, and the username back to the client. The client then sends this data onwards to the relying party. The server verifies the sign challenge with the public key it previously stored in the database. If the verification is successful, the server will find the correct user in the database and log them into our application. Now that we have an idea of the flow we want to achieve, let's get to work on the code. Inside our code editor, let's orient ourselves by looking in the login view. At the very bottom of the file, we have imported two script files. We handled the base 64 URL script in phase one, but the assertion login script file does not exist yet, so let's create it now. We can open up our newly created file and add a new login class that contains an init function. We have left some notes to guide us. In the first step, we will check to see if our browser supports conditional mediation for public key credentials. The middle three steps correspond to steps we saw in the phase two overview, and the last step is a redirect function that works exactly the same as the redirect function we implemented in the registration phase. At the bottom of the file, we will listen for the window object to load. We will then create a new login instance, and if the browser supports pass keys, we will initialize our new login instance. As a first step, we will check if the browser supports conditional mediation for pass keys. If the browser does not support this, we will return early. This conditional mediation will allow the browser to find any available pass keys and display them to the user in a dialog box. If the browser does not support this, it will not be able to find the available pass keys. This will prevent the login process from completing. For our second step, the client will request a challenge from the server. We will use the fetch API to make a request to this endpoint that doesn't exist yet. It will be a post request without anybody content. Then we will return whatever response we get back from the request. Now let's go and add this login public key challenge and point to the routes file. We're adding a new post route handler that calls the get challenge from function from the auth controller. This action doesn't exist yet, so we can head into the auth controller and add it. It will take in an instance of the challenge store and it will return a middleware function. In the body of the middleware function, we will use the challenge method to create a new challenge. If there is an error, we will fall through to the next middleware on the stack. If the challenge was created successfully, we will send it back in the response body. Now we can head back to our assertion login script and work on the third step. This is the step where we get the user's existing pass key and use the sign challenge to authenticate on the server. It will be an async function that will receive a challenge. Then it will use the navigator credentials get function to get an existing credential key pair from the user. This navigator credentials get function is also part of the web authentication API from JavaScript. At the end of the function, we will return the credentials we found. You may have noticed that we passed in some options that don't exist yet, so we will need to set them up. Within the options, we have indicated that we will be using conditional mediation and our credentials are of the type public key. Within the public key option, we will send through the sign challenge. Now we can move on to step four, which will be the step where we use the credentials to log the user in. We will create an async function that takes in user credentials. This request will also require us to send through some options, but we will build those in a separate function shortly. We will use the fetch API to send a request to the login public key endpoint, which we created in phase one. This will be a post request and we will pass along the options object which we have yet to create. Then we will return the response. Now onto the options. We'll set up a new function to build these. The body will contain the user's credential ID, then the response field will contain some details about the client data JSON, authenticator data, the signature, and the user's handle. We will also check if the public key credential object can give us any information about the type of authenticator that was used to create our credential key pair. If we are able to get this authenticator information, we will set that in the options too. Now we can collapse these completed functions and work on our final step for phase two. This step will redirect the user to the appropriate page. This redirect function is exactly the same as the one we implemented in phase one. We have decided to duplicate it here to keep each phase separate and make the flow of information easier. If you have strong feelings about dry code, you may refactor it as you see fit. Our login flow is now complete. So let's head into the browser to check it out. When we click on the email input field, a little dialogue appears to display our available pass keys. This is the conditional mediation that we were checking for in our code. Once we select our pass key, we will be prompted for verification. We can scan our fingerprint to verify. And because our passport check was successful, we are now back in our empty dashboard. And our login button still works. This concludes our implementation of phase two, where we use our pass key to log in. And there you have it. In this tutorial, we learned more about the web authentication API by implementing pass keys in an Express.js app. We also use Docker and Docker Compose to manage our Node.js installation. A text version of this tutorial can be found on divrino.com and a repo can be found on my GitHub account. I'll leave both links in the description for this video. If you learned something new while building this project, please let me know in a comment or like the video and subscribe to my channel. Thank you for watching. I appreciate you.