Master technical interviews this course breaks down complex topics like data structures algorithms and interview strategies into easily digestible content par teaches this course he is an experienced engineer and he will teach you both the fundamentals and help you understand Advanced coding patterns and common pitfalls to avoid Hello friends hope you are having a fantastic day today I want to welcome you to a journey that will transform the way you approach technical interviews and my aim is to help you become significantly better at technical interviews I'm here to be your guide as someone who has walked through this path and knows the twist and turns every step of the way together we will unlock the secrets of technical interviews from the basics of bigo notation to the integrities of data structure and algorithms so before we move forward let me introduce myself my name is par and I'm based in Canada I have been in the tech industry for close to 10 years and I have worked at companies like Microsoft NOK Kia and Royal Bank of Canada I'm a big believer in technology and love Building Solutions and softwares last year I became dad of twin daughters and on the side I also run my own YouTube channel called destination Fang where I teach about data structure and algorithm related problems so now let's just get started with this course so first let's try to understand that what is going to be the format at any typical interview for any tech company usually during the interview process you can expect somewhere between 3 to six rounds of interviews and they are usually broken down into three main categories first category is the behavioral interview and the purpose of the behavioral interview is to check what kind of person you are are you a good culture fit do you work well with different people do you work well under pressure can you raise your concerns if you have any conflict between two people how can you handle that and these are the things companies wants to know before they hire you second type of interviews are system design design interviews and they are usually more emphasized for more senior level folks and if you are someone with like 10 years or 20 years of experience that would be one of the most significant chunk of importance for any job that you are applying to but that doesn't mean that uh they are not going to be there for junior level folks there would still be some emphasis but not as great and usually those interviews tend to be openended where they ask you questions like if you have to build your own Twitter or your own Google how would you do that what are the things you would consider and then the conversation Dives deep into the vast sea of software Solutions and the third category is technical interviews which is going to be our main point of focus for now from now on T typically a technical interview lasts for somewhere between 45 to 60 Minutes during this time interviewer usually ask one to two questions and once you have the solution in place they would judge the solution if solution seems to be good enough or fine they will ask you to write a preliminary code for that in any language of your choice but the thing is it's not quite as simple as it sounds there are lot of moving Parts in any technical interview usually a technical interview has a problem statement and that problem statement usually refers to some real life scenario and that problem statement needs to be solved using a computer program that we we are trying to build for that you would need two things for sure number one is data structures and data structure is nothing but a way to store the data inside the memory of the computer there are lot of different methods available uh so you will need to take care of data structure second thing is algorithm and algorithm is nothing but a set of instructions that a computer needs to follow in order to come up with a solution trust me there are lot of data structures and lot of algorithms and lot of different techniques that you have to understand but when you combine these two you get somewhat a solution but how would you know that whether your solution is a good solution or a bad one for that we actually need some way to measure that how effective our solution is and in order to do that in computer system we use something called Big O So Big O is a notion where we compute what is going to be the worst case scenario time and space complexity and depending on those results we make the decision that whether the solution or the option of solutions we have which one is the best and most optimal one and which one are suboptimal options so before we start going deeper into the realm of data structure and algorithm let's first understand that what are the measurement units how do we actually understand that this is a good solution okay so let's talk about big O big O is typically defined by a big O and in the bracket we are going to Mark the complexity of Any Given algorithm now usually when when we talk about Big O we are usually talking about two items and those two items are time complexity and space complexity and remember the purpose of Big O is to identify the efficiency of Any Given algorithm now uh there are couple of ways to measure the efficiency of Any Given algorithm but the most important consideration that we are always going to have is that we are going to consider the worst case scenario that in the worst case how efficiently our algorithm is going to perform on top of that we are also going to check that for any given algorithm let's say that currently we are dealing with five number of inputs uh so in with five number of inputs what is the efficiency now let's say that the number of inputs grow to 5 million in this case what is going to be the efficiency and that becomes the true measure of Any Given algorithm and there is also one more condition consideration while calculating big hope is that we don't care about Hardware or software abilities for any given particular solution so we are assuming that our algorithm is currently running on the best hardware or software available so that's why we eliminate those outside of our control entities and only we focus on the efficiency part of our algorithm so first uh and foremost time or space complexity is Big O of one now currently I'm only going to talk about time complexity because that is sort of like more important of course space complexity is also important but time complexity is usually where you will have to improve whenever you are building your solution now in terms of that uh I'm going to currently show you five different examples of different Big O's uh for all I'm explaining it using the time complexity but throughout this course we are going to be solving bunch of different technical interview problems and where I'm also going to explain you the what space and time complexity we are using and how do we calculate that so don't worry about anything we are we are going to cover all the topics uh for that is for sure now first and foremost the Big O notation is a constant time Big O notation that is usually defined by like like this where in the middle there is a big one present this simply means that the current operation does not depend on the given input size and uh one clear example if you want to put it in the real world is that let's say that you are currently shopping in some uh Plaza some shopping cart or some somewhere like that and you can see in front of you that uh you have the option to pick any item from the five available items so since you have the option to see these items and you are being asked that hey uh in the bracket number three there is a banana that you need to pick you can just directly walk in and pick that banana up and in this case you don't have to think anything you just B there fetch that data and you completed your operation so same way instead of five items let's say if there are 500 items and we are assuming that your eye vision is the best you are able to see everything so in that case uh even if the value is located at 499 place and I tell you that go and grab that you can still be able to go and grab that within the constant time so timing would not be impacted based on the growth of number of input size so in this kind of scenario we can consider that operation to have a constant time now next operation is bigo of end time now what does bigo of end time means is that the number of inputs as the number of input size grows the more time it takes for us to complete that task and the progression is essentially linear so let's say that uh this is the graph where we can see that the number of input size and the time it takes to complete the line is going to be a straight line that they are in proportion to each other and if we have to consider an example for uh this kind of scenario let's assume that currently uh you have 10 items that that are already placed in 10 different pots and now these pots they are covered with different lids and you have no way for know that what is currently present in each of the pot so if I ask you that uh from these 10 pots I want you to find a banana so in this case what would be your approach well you will definitely go to the first place and in the first place you will try to check that uh if the banana is present uh currently banana is not present here so you will check the next spot you will check the the next part again you will check the next Sport and eventually you would find a place where has a banana and you would return that in that scenario let's say that instead of 10 values if I put like 1 million pots then essentially you will have to open 1 million pots in order to find the banana so there is a direct correlation between the given input and the size so that's why this would be a good example for bigo of n time complexity where our solution is direct ly in correlation with the given number of input size next one is actually big of log n and this is a logarithmic time operation this is quite un interesting to understand what it happens in this type of operation is that with every step you make you essentially eliminate 50% of given input and same thing happens when you make the next step and same thing happens when you make the ne Next Step so say initially uh uh this is your entire input size when you make the first change the change is going to enable you to essentially get rid of this entire part so now you are only dealing with these number of input sizes with the next step you took again you eliminated half of them so you get rid of this part and then now you're only dealing with this much portion of the given input and same way if you keep on going and going and going eventually you would be able to find the solution you are looking for if we have to consider a practical example for this type of logarithmic time I told you that hey this is the phone book now in this phone book I want you to find the number of Patrick the plumber now for this in order to find the number of Patrick the plumber what will you do is you will open the book somewhere from the middle and let's say that you open uh at where character or alphabet m in the middle portion so essentially you can eliminate that from a to M this Patrick the plumber is not going to be present so you will essentially get rid of all of these pages so let's say that uh it's a 500 page phone book you essentially eliminated 250 pages in just one go and in the next iteration you only have to check for n to Z and again you try to open some middle page and then you would be end up with this a smaller subset size so with every increment of step you take you get almost 50% closer to your uh given answer and you are eliminating 50% of input sizes in that so that is defined as bigo of log n or logarithmic n time complexity well usually the constant time complexity is the fastest and second fastest is the logarithmic time complexity now the next sequence is going to be the combination of two items and that is going to be bigo of n log n so bigo of n log n is an operation where essentially let's say that this is the current input you are given initially first of all you are you will have to itate over all of these places in the input but once you do that then for the next set of instructions you only need to do it in the logarithmic time so for the next operation you are essentially again eliminating half of the given inputs with every single change you are trying to make and this is quite an interesting approach one of the good examples for this one could be that let's say that you are playing a card game with your friends now initially in your card game in your hand you receive five random cards but you are are a person who wants who likes to do things in more of like a sorted array or sorted way so your approach is that hey uh since the these are random values let me put them in a correct sequence so for that what would be your approach your approach would be that first you are going to put down the value number two and you will treat that two is the minimum number and this is the new sort of sequence that you are trying to make now in this case currently since this is empty you can put two anywhere so you will put two in the first place now you need to put value number 7 now again you know that 7 is greater than two so you put 7 on the right side of two now you need to put value number three you already know that all the values that are currently present in this array they are already going to be sorted because one by one you are sorting them now in order to put this value number three you will have to find the location where it should be the ideal location and ideal location would be between two and 7 the three should fall between two and 7 so what would you do you would first try to find the middle Point Middle Point is currently let's say uh 2 and 7 so you pick seven so which means you know that three needs to be on the left side of seven so again there is only one element so you know that three needs to be in the middle so once again you adjust the values and you are going to put three over here and then seven over here again you have value number one so once again you will have to make adjustments or you will have to identify that one needs to go in the beginning and again you are going to use the binary search approach the same approach we were using in the previous uh application or previous phone book example that we saw so let me just redraw all of this and this would be the sequence and now you have value number five you need to put so once again you will try to find the middle value and you find that the correct location for five is going to be this place and you will again going to put it over here so now after this after completing this example if you see the solution you currently have is actually now sorted so let's calculate the the complex for this well you had to go through each and every input in order to receive or complete the steps so definitely you did n work but even for every single element once you did or process that you also had to do some work in order to put it in the sorted place so for that you are not doing the N work you are actually doing the log n work so in this case the Big O is actually going to be Big O of n log n so these are typically the four four most popular Big O's um in terms of like any architect any technical interviews that you have to consider but apart from that we also have to worry about bigo of N squ and bigo of n cub and bigo of uh 2 to the power n and then there is the worst one and that is bigo of n factorial so let me just quickly explain these four of four of you for this so suppose in this case uh big of n Square you already you can already guess that for every every single element we will have to work with all the other elements so let's say that currently I have this value number X now I want to check that in the remaining portion does X is present or not so one by one I will have to check all of these values and since it is not present so then I can say that okay for in order to process one element I had to process all the other elements so essentially I did B of n Square work so or B of n cross n work and same would apply for all the subsequent examples as well and uh that is how we reach big of n Square time complexity this is also uh referred to as quadratic time complexity then for big of n Cube again you are adding one more n over here so let's say that you this step needs to be done as part of one of your algorithm and then once you get the process of this you again have to do n work or compare with all of these values and once again repeat the same exercise in this case case uh the time complexity is going to be big of n Cub now this one big of 2 to the^ N is a Time complexity where at every single location you have the option to process two values and among these two options depending on which option you took your complete computation path would change so in these kinds of scenario the typical uh calculation is going to be big of 2 to the power n uh and the last one is the factorial time complexity so factorial time complexity is where the input sizes grow exponentially with the increase in the number of input size and this is actually a huge restriction because these two time complexities are so bad that they can't even function and one of the very good example for this big of 2 to the power nend time complexity is actually traveling salesman problem um if you want go ahead and search about that it's a quite an interesting problem to study that gives you quite lot of idea on how computational how there are limitations to computations as well uh for the N factorial one of the very good example is to find permutations and combination for all the given input sizes that we are trying to deal with so this is what you need to understand regarding the time and space complexity and uh now let's try to start understanding that what are the data structures now we are going to talk about data structures the most important topic that you have to understand for any technical interview or computer science in general now when we talk about data structures data structure is nothing but a way for us to store the data inside the computer's memory so let's assume that these are all the memory blocks of Any Given computer so we have the option to store the data in like an entirely common box like this or we have the option to save the data where one node is present over here the connecting node is present somewhere over here its next connecting node is present some somewhere over here and so on and so forth we also have the option where we know the option of that this is one node and then this node can only be accessed through these two nodes or something like that and then there are also quite connected nodes as well plus there are some structures data structures like q and stack so data structures in itself is a huge and complex topic now let's try to break this down into categories so it helps us understand what type of data structures are and how they operate so if we have to create the categorization data structures are typically two types of data structures mainly first one is a primitive data structure and second one is a nonprimitive data structure now these primitive data structures are the smallest unit of data that we can store inside the computer and this is your integer value or your character value or Boolean value typically all the values that we usually use in any compiler language so to store store the raw bits of data in the computer and lucky for us or that this is too preliminary that it is not considered for any technical interview but you must have encountered this if you are a programming person so now the next category is the nonprimitive types of data structure and that two has further subcategorization so in the nonprimitive type of data structure the first of characterization is the linear data structure and second one is the nonlinear data structure now for the linear as the name suggest linear data structure defines as the data that are typically stored in a sequence or in a linear fashion so this includes array then uh link list stack and Q so these are the major categorization of the linear data structure now when we talk about nonlinear data structure this is essentially the data structure that that is in a weird shape uh where the connection or the hierarchy between any two nodes is quite deep and quite significant and this has some of the most interesting properties actually so that is uh trees and graphs now for the apart from trees and graphs uh there are many subtypes in each one of them and when we get to those topics we will discuss it in the in more detail but for now understand that these are the to generic subcategories now the there is also third unofficial category which is really important for us to learn and that is Hash based data structure so hash based data structure typically includes uh hash map and hash set and these will these are very powerful tools at our disposal that we can actually achieve quite an interesting uh output with these data structure so without any further Ado let's just get started with the linear data structure now arrays are a not only they are a linear data structure but arrays tend to be fixed in the size and there are some properties associated with arrays so first let's understand that typically uh let's assume that if this is the whole memory of the computer then if whenever we Define an array we have to give it a sum size uh and the size of an array usually tends to stay within a fixed Contin ous memory space inside any given computer as well so let's say that we create an array with the size five then there would be a memory space like this with five consecutive memory spaces are going to be located next to each other and this is how it would be represented in the memory now since we already know that there are going to be five continuous bits of memory uh one good thing about array is that if you want to access any element even from anywhere in the middle you can access it quite quickly and very fast so uh let me give you an example for that suppose uh this uh this is currently the whole chunk of memory for the given array now how would the fast access work is that we already know that what would be the initial location of this position in the array inside our memory I'm giving you like a detailed explanation to help you understand how does arrays work so let's say that the computer memory address like this portion is referred to as 100 and for the Simplicity we are expecting that all of these nodes they are 100 in the size which means that this if this memory location is 100 then this location is at 200 then this location is at 300 and so on and so forth so let's say that uh I currently wanted to access the fourth element that is this element present inside the given array so do I have to do any additional research or any additional extra effort no why why because I can quickly come over here I can see that okay this starts at Value number 100 I want to access the fourth element which means fourth element has to be present at Lo value memory value number 400 and that we can access quite quickly so just because we learn about the bigo time complexity the retrival bigo time complexity for array is actually going to be bigo of one or constant and how typically we access the elements inside the array uh we use something called indexing so arrays let's say that this is an array of size five because we can store five elements in this usually it is going to be indexed starting with value number 0o so 0 1 2 3 and 4 this is going to this is how array is going to be represented and you can store any item in the array you can store either character or you can store integer you can store Boolean you can store even some some of your separate classes you created all the things you can store inside the array but uh in order order to access that you will have to use these index values so let's say that I put down the values as uh 5 15 3 1 and two now if I want to access that what is located on index number two or position number three why position number three because this is the first element this is second and this is third element and we have an index starting from zero so why am I pointing you out this because this tends to be a tricky thing and many times you would encounter in technical interviews that they would say that hey I have an array that starts with index one so that this is like a common trap that you sometimes can find yourself into so that's why make sure that what type of index you are using 99% of cases you are going to be using an array starting with index number zero now let's just go back uh again so in this case uh let's say that the name of this array is a so if I want to access this third element all I need to do is try to fetch the value that is located and on the second index position and this would give us the answer as value number three so retrival inside the array is quite quickly now let's see that what are the different operations we we have the ability to perform inside an array let's say that currently we have a blank array present and what are the things we can do so let's mark down the index values now first operation we can do is we have the ability to insert element inside inside any given array now inserting an element is actually quite quick uh because if you know know which index location you are inserting element into you can actually do it in within constant time so B go of one time you can insert element you can insert element to the end of the array you can insert element to the beginning of the array all you need to know is the index value and that's it now second thing we can do is we can retrive the G the inserted array as well and retrival is also quite quick we we just saw so that is also a constant time next operation we can do is we can find element inside the given array so let's say that how does finding inside the given array would actually work and uh this is a question for you guys that while I explain try to think that what should be the time complexity for this one uh ready so let's say that currently the values are 5 15 3 and 1 and I ask you that inside this given array I want to find that uh value number three where it is located so how would you do it approach is going to be quite simple the logical explanation is going to be that you go to the first element if it is three that's it if it is not three go to the next element again not three go to the next element okay this is three then retri the index position and that's how you find it now in this case what was the time complexity well the answer is quite obvious because we had to jump through all the values in order to find the value we are looking for it was big of n so logically why it was big of n because this is unsorted array so in the unsorted array always if you have to find any element it's going going to take big off end time but let me show you a quick uh interesting thing over here let's assume that I currently have a sorted array so 1 2 3 4 5 these are the elements I have and now I want to find that whether four is present or not so in this case what what is going to be the approach since I already know that this is a sorted array I'm going to first check for the middle element and again I can check what element is there pretty quickly because retrival is Big go of one so that is an important property so in this case I can see that this value is three the moment I realize that this value is three I can say for certainty that four is not going to be anywhere left of three because all the valents all the elements are going to be less than three and we have we are trying to find for the value number four that is actually greater than three so we can eliminate these two or these three elements with a single check again we will try to check for the middle element and we find Value number four and we can retrive that so if the array is unsorted the finding is going to take big off end time but if the array is sorted then in that case the finding is going to take because of log log and time and why because the method we just use is actually called binary search where we are dividing the all the elements in one half or the other half and then we are essentially making judgment on which direction to choose and find the answer in the most optimal manner so finding uh takes B of end time next question is deletion so deletion is also if you know what place you wants to delete it only takes big off one time because all you need to do is just go to that index and get rid of that value so deletion is also very quick inside the array now we all find quite interesting items about array let's see that what are some of the drawbacks of an array well the number one drawback of an array is that it is actually a continuous memory size and it is also a fixed memory size so what do I mean by fixed memory size because initially when we are defining an array we actually have to Define that what is going to be the size of an array and let's say if we exceed the size of that array then the operation becomes quite expensive uh let me give you an example so in this case suppose the array is 1 2 3 4 5 these are the five values now we realize that in the same array we need to add more elements so what behind the scenes procedure is going to be that there will be a new array created of size 10 and now in this new size 10 array first it is going to shift all of these elements one by one and after that once the shifting is done then the next element that you wanted to add over here value number six would be added over here so previously when we have to insert any element inside the given array that was a bigo of one operation the moment we exceeded the size the operation became bigo of n operation uh because we had to repeat this whole process and that too when we did that what was also another fault with that is that currently all of this space is actually unused so we we are already running on a very important resource that is our computer's memory and we are leaving some values unused because they have not been filled yet so this is one of the biggest issue with the arrays now second issue with the array is that uh actually if you want to find any element then it takes bigo of end time because that you have no way for to understand that where any particular element is present so this is also another issue with an array but apart from that if we have to talk about benefits of an array well uh there are quite a few benefits actually if you believe it or not number one it's the simplest algorithm to understand or simplest data structure number two it is actually quite uh useful and and quite fast uh quite fast means that whenever you have to retrive any element from any particular index you can actually do it quite quite quickly uh allocation memory allocation is not an issue this works really well with other data structures when you are trying to solve some complex problems so when we get to the points of dynamic programming and Matrix manipulation we are going to learn quite a lot about arrays and we are going to use lot of arrays in many different scenarios now let's try to understand that how does a typical array problem work with an example and the example we are doing is actually the number one problem on the lead code and one of the most popular uh interview question that is two some problem so what problem statement suggest is that suppose we are given an unsorted array and uh in this case we have five elements so let's give some arbitrary values of these elements and in this case uh we are trying to identify that uh the we are also given a sum value so let's say that sum property is currently given as value number 17 now we are trying to find that find a pair that actually has the answer as value number 17 and then return its index position so we are know that the answer is actually going to be in this case 2 and three because these are the 10 + 7 but let's see that what is going to be the approach that we need to take so this will give us a very good Insight on how does algorithms also work and how does time and space complexity works so let's see the first approach first approach is going to be our Brute Force approach or the most preliminary basic approach the idea we are going to use is that we will take any element we will minus it with 17 so whatever the remaining element is left we will try to see that in the remaining array does that remaining element is present or not uh so if we are considering five so let's assume that five is currently part of this two some so which means if five is part of this 17 that makes 17 then there has to be a remaining value 12 present inside the remaining array and we all know if we have to find any value inside the array we can do it in B go of end time because this is an unsorted array so we are going to jump through all of these values to find Value number 12 but currently 12 is not present so because 12 is not present we can consider five not to be part of the answer then we will go back to Value number three once again 17 3 value is going to be 14 so we will try to see that whether 14 is present again 14 is also not present so we will get rate of three again for seven So currently we are considering value number seven which means for the sum we need to have value number 10 present somewhere and yes 10 is present over here so in this case we did find the answer as 2 and three because we need to return the index value and we can return it quite quickly but if I have to ask you that what is going to be the time time complexity or the Big O for this given input what would be the answer it's quite obvious for any single element we have to search all the remaining elements and if we do or consider that in the worst case scenario essentially the time complexity is going to be biger of n Square so that let's see that can there be a better approach using the array to solve this problem and the answer is actually yes there is a much better approach and first let me give you a slightly better approach right so a better approach in this case would be that what if for the given input array we decide to sort that and if we sort this given input array we will find the values to be 1 3 5 7 and 10 now once we have these values stored all we need to do is uh we need to check that uh whether for Value number one if the subsequent pair the value number 10 n is present or not and in this case since originally we need to find the index value when we create the Sorting we have to create actually a new array so this is an important piece of information so just Im Just a thing so now if we have value number one which means we are trying to find the sum to be 17 so then uh 17 minus 1 is going to be 16 so 16 needs to be present so since this is a sorted array we can actually find in log n time that whether 16 is present or not and all we need to do is we need to apply the binary search where we first check the middle value So currently this value number five so we make sure that 16 has to be somewhere on the right side but since it is not present over here we are not going to bother checking same thing we are going to check with for the value number three that again for Value number three if that is has to be part of the answer we can actually try to find the answer in log and time so to check whether value number 14 is present or not again that is also not present for five value number 12 is also not present but when we get to Value number seven actually the value number 10 is present and we can find this in log n time so what do what did we did we found out that the correct values we need are 7 and 10 so once we have the solution we again need to go back to our original array because we need to return the index values so now once again we would search all of these values one more time to see where what are the index location and then return the values now let's try to calculate the time and space complexity in this case so for the time complexity what are the operations we did number one operation is that for the given input array we actually sorted this so once we sorted this given input array uh it took us bigo of n log n time to sort because based on the example I showed you earlier plus after sorting it we had to iterate over all of these elements to find that what is is the subsequent or remaining element that is present or not and this so iterating over all of these elements took us B go of end time and uh in order to find that for each one of them the subsequent element is present or not again it took us beo of log n time so again we did B of n log n so in total we did two times B go of 2 * n log n but the interesting thing about Big O is that all the constant values are not considered so we are not going to consider big two in this case and we will only consider this to be big off and login on top of it once we find the correct pair we again had to go back to our original array to find the uh appropriate index values so for that we also did Big O of n work but when we are generalizing the Big O we only care so whenever there is a plus operation or the additional task essentially our main main component is still heavily going to be dependent on big of n login because that is greater than big of n so we can also ignore this one and the time complexity is going to be big go of n log n in order to generate this now in this case space complexity is also an issue why because we had to create an additional new array for the sorted property and because the new arrays size would be dependent on the original size and the original size we are considering the value to be n because of that in this case the space complexity is also going to be bigger of n so I wanted to show you this approach to show you that how to calculate time and space complexity and what are the considerations we need to make so I hope you find that uh very useful and you find the idea now of course this solution is much better than our previous Pro Force solution which gave us the result of big of n square but still this is not the most optimal approach there are still optimal approaches available and the optimal approach uh let's see that how we are going to deal with it well actually I should not be showing it to you but I'll just show it to you for the optimal approach we are actually going to use another data structure called hashmap and when we get to that point we will I'll explain you in much higher detail that what an hashmap is but for now consider that hashmap is a key value pair uh data structure that looks like like this where you have a key and you have a value and if you know the key you can find the value associated in constant time we go off one time so it's very quick now let's just draw back our uh original array so I think the values were 5 1 7 10 and 3 and we are trying to find the sum for Value number 17 now again the approach is going to be that if let's assume that five needs to be the part of the answer so if five has to be part of the answer sir we need to make sure that value number 12 is present somewhere in the remaining array now currently we don't want to check the whole remaining array because if 12 is present eventually we would also encounter 12 somewhere down the road as well by the time we would have already processed value number five so what we are going to do is we are first check that whether 12 is present inside the hashmap or not currently it's not present in the hashmap if it is not present in the hashmap we are going to add an entry of key value pair over here where we we will add value number five as the key so this value and its subsequent index value as its value because we need to return this in the answer now again going back currently value number one if one has to be part of the answer then value number 16 has to be present but currently in the hashmap we don't have value number 16 so again we are going to add one more entry that is value number one and oh sorry for this five the initial entry is going to be zero because its index location is zero so for this one the index location is one 1 once again for this 7 we need to find the value number 10 but 10 is not currently present inside the hashmap and we are able to check all of these in big off one time so that's a great benefit now we are not able to check this one so what we will do is we will actually add entry number seven over here with the index value of two now let's add one more room and now we are at Value number 10 so if 10 has to be part of the answer then 7 needs to be present somewhere in the array and 7 is already present in the Dash map because we have already processed that value the moment we realize that all we need to do is grab the index element of 10 that is value number three and grab the index element of value number seven that we can find it from the hashmap over here and we can return return uh 3 and two as the answer that this is the index pair that makes us the two sum possible inside the given array and now let's break down the time and space complexity for this solution so of course time comp complexity actually is very fast in this case because we only have to iterate over the given input array just once and we would be able to find the array so the time complexity is actually going to be dependent on big of n the given number of input sizes which is much better compared to both our Brute Force approach and our sorting approach now in terms of space complexity uh we actually have to create an additional hash map and the size of the hash map is actually going to be the size of the array maximum in the worst case scenario so again the space complexity is also going to be bigger of N and this is how you actually solve this problem so now let's quickly try to understand the problem statement for two some problem that is I just explained it to you and the coding solution so we have a Java code over here and first of all we have the two some method where we need to return the index values for both the positions and in the input we are given the num nums array and the target value or our two sum now first of all we are initializing our hash map where we are going to store the values of the subsequent values we processed inside the given array and also their indices then we are simply going to run a for Loop to iterate over our given array first of all we will try to see that what is the complement value that we need to check and then we will we can do that by subtracting the current array position minus the target value once that happens we check that if the hashmap already contains that complement value or not if it it contains the compliment value we can return the index positions quickly if it does not contain then we are going to add that value in our hashmap and in the end I'm just adding uh an illegal argument exception that there is no toome solution but this is never going to be the case because we are explicitly told that there is always going to be exactly one solution so let's try to run this code and this code runs pretty quickly let's submit this code and our code runs quite efficiently compared to a lot of other Solutions now let's learn about the next data structure that is link list Now link list is quite an interesting data structure because it's not what array was at all uh in the array we actually had all the memories being stored in a continuous block and the size used to be fixed link list is actually complete opposite of this let's say that this is currently the memory then we would have a link list that would look look somewhere something like this it would be sprad out all across computer and the nodes would be connected with each other where one node would know the address of the other node and that is how we actually Traverse over any given link list so typically link list is a dynamic structure well of course it is a linear data structure but it is also dynamic in nature and uh typically a link list looks like this where we only have the information of the first element that is present inside the link list nothing more than that that but if we have to go and reach to any particular element we can actually do it by going sequentially to from that original first element to the last element and we would be able to find that value somewhere in between so typically a link list would look something like this where you have these memory blocks or these nodes and the first node is referred as the root of the link list and in every single node there is going to be a partition and what this partition defines is that this would have the memory location of the next element inside the link list so let's assume that currently we have this value number five and this is located at memory location 100 now this particular block is going to have the memory location of this block so let's say that this block is currently located somewhere randomly at Value number 600 so that 600 would be stored over here once again let's give some arbitrary value over here so let's say that value number three is the value for this node next element it has is it could be anything it could be 300 and now at 300 memory location we have another node that is present with value number seven um and same way it has the address for this next element so basically the structure of a link list looks something like this where we have the first element that points to the next that points to the next and that points to the next and the last element actually points to the null value and when we see an element pointing to the null value that defines that whether the given link list uh where it ended basically now for the link list it's actually uh there are three different types of Link list now what I just showed you this is called a singly link list and why singly link list because one element knows that what is going to be the element after that but any particular element has no idea that what is the element before me because it does not have that address so that is why this is referred as a singly link list where you have the idea of what the single next node is going to be in the iteration but there is also a dou link list and W link list as the name suggest it has the idea that who is the previous caller and who is going to be the next caller so the structure is usually like this where you have additional memory slots uh where we store the information so something that looks like this and uh once again so let's assume that this is currently the root node so even for the root node now in this case since root node is not being pointed by any other node this address is going to be null value and then we will have some value being associated with this so let's say 10 so 10 11 3 1 these are the values associated with the link list but now this 10 this portion is actually going to to contain the address of this element so it has the address 300 let's assume and we can also assume that this address is 50 so this value number 50 would actually be stored over here that this second node would know that who is the first node that is calling them so when this node needs to go back or Traverse in the reverse order it can also do that so when traversing in the reverse order uh it will look something like this that this would actually point to this address and uh same way this has the address over here this has this address and this has this address and this is this address and in the end we have this last element that actually points to a null value and when we see last element pointing to the null value which means that the link list has ended or W link list has ended and when we see first element pointing to the null value which means that the W link list actually started there is one more link list that is called a circular link list and in the circular link list as the name suggest essentially there is a cycle that keeps on happening and uh how it operates is that usually if we consider it's an additional extended version of The W link list so let's say that currently we have a w link list where uh in the normal case scenario this W link list would be pointing to the null value in the first place but let's assume that that is not the case and currently let's just give some arbitary values 1 2 4 7 these are the values right now we know that that one is pointing towards two and two is pointing towards one same way this is relation is already stable now previously in the normal link list the last element its next node would be a null value but in this case the next node is actually going to point back to the very first value and same way this very first node is actually going to point back to the last element so that is why there is a circle circular nature happening inside the link list now understanding this let's see that what are the different operations we can perform on any given link list and for reference I'm just drawing a simple singly link list but same would be true for all the W link list and circular link list as well and uh let's define some arbitary values and currently this one is pointing towards null and uh currently this is going to be the root of our link list so we have the option to add values to the link list now if we have to add values to the link list the time complexity depends on where you are trying to add so let's say that if you are trying to add the link list to the root element and sometimes this is also referred as the head of the link list as well so let's say that you are trying to add elements to the root or the head element of the link list it's actually quite simple all you need to do is that you will first try to go to the root element you would see that what is the current memory address for this root element and then you would actually create another node and let's mark the value as nine you would point point this nine back to this root Two element and that's it now you have essentially created a new head element or the new first element where this is this becomes the root and this is being pointed by this value number nine or root so in this case uh you only have access to the next element so you give the next element of the previous head to the new head and this can be done in big of one time constant time operation same goes that if if you want to add an element somewhere in the middle well this the whole procedure is actually quite simple let me first show you the procedure and then we will talk about the time complexity well the procedure would be that let's say that I want to add a node number seven over here so what I would do is that currently this four is pointing to the one rather than doing that I'm going to Mark 4 do next or the next element that four is pointing to to 7 and then 7 do next to the previous element that four was pointing to so the value number one so we would have a temporary variable in between but essentially you get the idea what I'm trying to say and now this process only took big off one time but now the tricky part in this case is that in order to reach to the four we actually have to first go to Value number nine and then through nine we would do sequential jumps until we reach to Value number four and then we would be able to make this changes so if we have to make the change somewhere in the middle uh the time complexity is actually big of N and same goes for the end as well because if you have to add it into the end you will also have to update and go to the end and then that would also yield the time complexity of big of n but now there is there are some slight variation difference where if you have a w link list and you wanted to add to the last element maybe you can do it faster if you already have that information stored or you can go in the reverse order or in the circular link list you can do it quickly in the end but that these are rare anomalies that you are rarely going to encounter now let's see that if you have to delete an element how does it would work once again deletion process is quite simple that all you need to do is that let's say I want to delete this value number seven so what I would do is currently the next node that seven is pointing to I would ask four to point to that node and that's it seven has been deleted because now there is no way for us to reach to seven and so this the process in itself is quite easy but again the same question remains that in order to get to the value number four we will have to do all of these Hops and get there so if we have to do some deletion in the start it takes big off one time but in the middle it takes big off end time now let's see that what is the next operation we can do and that is finding an element inside the link list once again you get the idea you can find the element but once again in order to find the element you will have to Traverse through all of those these Hoopes in order ultimately till you reach that element so that two is going to be big go of end time and once again uh the last one is that you can also modify any existing element but in order to do that that also takes big off end time so essentially all the operations in the link list if they are done somewhere in the middle or the end of the link list it takes big off end time so now the question comes that why do we even care about link list why should we use it well one of the most important benefit is that it it's dynamic in nature so it keeps on growing and growing you don't have to worry about memory allocation size allocation because it can find sizes anywhere so anywhere there is an empty block of memory present link list can acquire that put it in the memory and do it on top of it swapping any two elements so if this pointing over here we can actually start pointing or add couple of new link list and then bring them back and then get rid of this uh list this is actually quite simple and quite easy so in many of the branching strategies this is actually quite helpful that uh you can actually create all sorts of like get a branch and repos and stuff like that using link list on top of it uh many times we are going to use just like arrays link list in tandem with other data structures so we will see that when we get to that point now let's talk about uh some of the examples of how typically we solve any problem inside a link list so one of the popular very popular problem is that we need to find the middle of the link list or middle element of the link list so how do we actually do that so let's assume that we are currently given a singly link list and we don't know that what is the size of this link list so how do we encounter that what would be the middle point for this one so one approach is that uh it's the simplest approach we actually start at the root value or at the head of the link list we keep on going to the next element until we reach to a point where the next element points to a null and the moment we reach that we would know the size of the link list so in this case we found out that the size of Link list is five so middle element is going to be the third element then once again we start once again from the root and let me use another color and then you we hop back and we reach to the middle element and then we say that okay this is the middle pointer of the link list so this this can be one of the examples so what is going to be the time complexity well time complexity is going to be big of n because we have to go through essenti all the inputs but there is also another better approach where once again time complexity is going to be biger of n but in practice it is going to be faster and that is that rather than making one hop you actually make two hops and how to do that well you can actually have two pointers so one pointer is a fast pointer and the second one is a slow pointer both start at the same time but slow pointer makes one jump and fast pointer makes two jumps so the moment Fast Point pointer reaches to the end of the link list the middle pointer or the slow pointer has to be in the middle and that you can return as the answer so in this case the time complexity would be big of n divided by 2 so overall since 2 is the constant value we would still write it as big of n but in practice this is going to be much faster compared to the other approaches so now let's try to understand the middle of the linkless problem and as the problem statement states that we are given the head of a singly link list and we need to return the middle node of the link list now this is the Java code for that and typically for the link list we are initializing two pointers for that first one is known as slow and second one is known as fast and currently both are located at the very first be uh beginning position of the link list now we run a v Loop that while fast is not equal to null and fast. next is not equal to null we are going to keep on moving the slow pointer to one jump so slow will go to the slow. next or the next element inside the link list and fast would go to fast do next do next so it would make two jumps at a time and in the end the moment this Loop ends we would be at a position where fast is at the last position or the next element to the fast is actually the null value in either case so slow has to be the middle pointer of the link list and we can actually return that so let's try to run this code and our solution works perfectly fine so let's submit this and our code runs with 100% efficiency so this is pretty good and uh all the code that I'm showing you would be posted in a gith up public repo so the link is going to be in the description so you would be able to check it out from there now let's see another data structure that is a stack now stack is once again very similar to an array or link list it's a linear data structure but uh the stack has a very specific property and that specific property is actually that stack is something like this uh you can consider it as like a test tube um in any lab or any sort of thing or a stack of plates this would be like a good example to understand what stack is where the value where you first store sto gets stored at the very bottom once that value is filled then the next value when you have to put in that would become at like the bottom to the uh second place and it will keep on going now when you have to take things out you will always take things out that are currently at the very top because you cannot reach to the bottom element because they are already Behind These memory lines so in order to reach to the bottom elements you will actually have to go through one by one for all the values so let's see this an example let's say that currently our stack is empty we are trying to fill in some values so let's say that we put down value number one first so one has to go at the very bottom now the we have we are putting value number two then three then four then five and then six So currently we have six elements inside our stack now when we start taking the values out actually the only value we can take out at this moment is value number six because that is the only value we have access to because this is like a test tube or a a stack of plates kind of a structure so that is why when we decide to take things out we are going to take value number six out first after taking value number six out then we we can start taking value number five out after five we will get to the value number four and so on and so forth so essentially the last element that was encountered or entered inside the stack would be the first element that is going to come out so this is this works on the Leo principle last in first out okay so and that's it this is what the whole stack is uh now if you have to see what are the operations you can do inside a stack uh you actually have some limited operations but they have very specific use cases so let's say that currently we have a stack like this 321 there are three elements so number first thing we can do is we can push value inside the stack because we already pushed these three values uh inside the stack so pushing element inside the stack is actually quite simple all you need to do is just push it and whichever is like sequentially available memory block so let's say that this is a stack like this so this would be the element that gets filled so this takes big off one time now you also have the option to pop a element out so when you pop an element out you only have access to just pop out the element that is currently located at the first pace so in this case you can only pop out this element and after that is done you will pop out this element so this also takes big off one time now the next option we have is that many times rather than popping one element out we can just check that what is the current element at the very top and that for that we usually do like a peak operation and this also takes big off one time so you would you must be thinking that hey this is super fast uh data structure so let's use this up to the fullest extent but uh this is very limited in memory size and also like the way data is being stored so if we when we start talking about additional operations if we have to find an element inside a stack that takes big off end time for obvious reasons because at one point we are only accessing one element out and let's say that the element we are trying to get out is actually located at the very bottom we won't be able to reach it until we reach all the elements if we have to once again delete any element once again it will take big of end time because we will have to first find that element so that also adds an additional layer of complexity and same goes for modify as well that that this also takes B go off end time so all of these things they are closed L correlated with each other now let's see that what are the operations we can do or what are the use cases of a stack so number one use case of a stack is that wherever you need to maintain a sequence in one order and the reverse order sequence has to be match in that case uh stack would be a great example and this is one of the very popular scenario for that where we are we want to check that the number of parentheses we have are they in the correct order or not and that can very easily be determined using a stack where all the parentheses that are coming in they also get out in the same manner and U if you want we can also try to do a quick example so let's say that currently we are trying to build a compiler and in our compiler we wants to check that all the parentheses that were opened they are closed in the same sequence so what we can do is okay the moment we open a parenthesis we are going to push an value inside the stack So currently stack is empty and let's say that these are the sequence of operation we are going to do right that first we are going to open a curly bracket then we are going to open a square bracket then a circular bracket and then we are going to close in the correct manner as well so the idea would be that first we open the bracket so we are going to add a value over here then once again open so add open so add now when we are closing the bracket we will remove the value and try to see that whether the bracket is of same kind or not so the first value we removed is a curly is a circular bracket and the value we are trying to close is also a circular bracket which means awesome so this sequencing was correct now uh the very first element currently is the square bracket open square bracket and now the bracket we are trying to close is also an open type of bracket so once again this is also a match so we can consider this and the last element is a curly bracket and a curly bracket so once again this is also a match so the whole solution work and now we are at the end of our parenthesis at that time we also check inside our stack and currently our stack is also empty which means all the brackets that were opened they got closed in the same manner let's assume that uh there is one more additional bracket over here in the beginning that this was the case so then after these three has been done we would still have one entry over here which would dictate that the parentheses were not opened and closed in the same manner and uh that would throw an error so this is actually the use case being used in many of the compilers as well so that's actually quite cool to understand that a simple data structure can give birth to such a wide variety or such a huge functionality now here is the problem statement for the valid parenthesis problem where we are given the string of opening and and closing brackets and we need to determine that whether it is a valid sequence or not so for that we are actually going to use a hashmap in this case where we are going to create the mapping of opening and closing brackets where all the closing brackets are going to be placed as the keys in the hashmap and their subsequent values would be their counterpart now let's move on to our is valid method where as an input we are given a string so first of all we will initialize our stack uh we are going to run a for Loop across the given string and we will see that whether this is a closing bracket or not if that is the closing bracket we would get the top element of the stack and if the stack is empty we can return false if it is not empty we will pop the element and we will compare it with the closing element so if they match that's fine if they don't match we can return false and if that is not the case if it is an opening bracket we will simply push the value inside the stack now in the end after this whole Loop has ended essentially a our stack should be empty if the stack is empty we can return true that the sequence is valid if it is not empty we can return false so let's try to run this code and seems like our solution is working as expected let's submit this code and our code runs pretty efficiently and you can imagine that how Stacks are actually serving a very critical functionality now let's try to think about another example of what a stack can do and that is a redo functionality so we all know that what a redo or undo functionality is basically if you are going through your Google web browser whenever you need to go back to the previous website you were at uh essentially a stack is being used and how it does is that let's say that initially you opened your Google So currently your stack is empty now you first go to the Facebook page so it will Mark the value as Facebook from Facebook you decided to go to the Instagram page from Instagram you go to the YouTube page and and from YouTube you go back to the Twitter page now at the Twitter you decide to hit that uh Arrow back button or the undo button the moment you hit back it is actually going to pop the value out so currently okay uh you are at the Twitter so previous element like the YouTube would be there okay now currently you are the Twitter you hit the element back so it is going to pop the first value out so first value popped out would be YouTube so it will take you to the YouTube page now from the YouTube you once again hit the arrow back so once again the Instagram page is going to come out now currently you are at the Instagram page and you have this value now from the Instagram page you decide to go to the let's say Uber page so now because you went to a new page there will be an entry for Uber being added over here now once again when you hit the undo button actually from The Uber page you would actually go back to the Facebook page so that's how these things would work and uh this is actually quite useful data structure in my opinion the last linear data structure that is a Q and Q is also very popular as the name suggest Q is actually quite simple where unlike stack we actually have both ends open but all the values are coming in from one end and going out from the other end so let's say that currently you have the cube and you have value number five come in so five would be the first candidate to get out then we have value number six coming so six would be the second candidate to get out same way all the subsequent elements that keeps on coming in they all would be stored in the same sequence of the sequence they came in so we have a value where we can NQ or where we can add values to the cube and where we have a position where we can DQ where the values go out of the cube and uh we all know the functionality of cube uh there are lot of real life systems where we need to have cues uh if we want to generate like some Network packet manufacturing or uh Network packet submission type of system definitely we are going to use because we want uh our let's say that we have a system a and we have a system B and we are sending some Network packets so we want Network B to receive the network packets in the same manner they were sent from Network a so for that on the B side we are actually going to create a cube and this cube is going to have the sequence IAL flow of the networks so now let's see that for the Q we already know the use case but first understand that what are the types of cues available so the number one type of que is actually the just a regular quebe then there is also priority Cube now what priority Q means is that this represents some real life scenario so let's assume that you are currently waiting at the DMV Center to make your driving license and currently the officer sitting there is asking for everyone in a sequential manner so currently all the people are standing in the line and of course the person who came the first would be the person reaching out to the DMV officer in the first manner but during this time DMV officer identify a pregnant lady or some person who had some disability so in that case this person would be the first person to go and meet to the officer and complete the task and this is the real example of how a priority looks like where it mostly operates as a normal queue unless you have some event that you can Define that would dictate that it has a higher priority so process that first and this is quite useful in many real life scenarios as well where let's say that in your phone you wants most of the stuff to happening in the sequential manner but what if there is something related to like payment fraud happening so you want to put first first priority for that and for that usually a priority queue gets implemented now let's see that what are the different operations you can do or you can perform on a given Cube so I'm drawing a preliminary basic q and uh we are going to have the values coming in from one end and going out of the other end so essentially the first value would be five that came in so the first value would be five that would be going out so Q operates on fif principle first in first out unlike stack that was working on Leo principle last in first out so that is that is a difference between them and you have to understand now uh in the Q we first have the option for NQ which means we are adding an value to the back and this process takes big off one time because it's a constant time operation we already know where we are heading same way for the DQ uh it also takes big off one time because again once again the operation is quite similar now on top of that in the Q we have the option to Peak that who is going to be the first value coming out so that does not actually comes out but we would know that this is the value then there is also another option to search inside the queue but searching like other data structure takes big off end time and by the way for peing would take big off one time now on top of that we can actually delete an element from the queue but we would rarely do that because we want to process those elements this also takes meig go off end time and that essentially that's it now I I think I already give you sufficient examples of how does a queue operate or how it looks like so you can actually imagine that uh how things work with the cube and one of the most popular data structures out there is actually trees so trees is not your everyday looking array or link list it's actually completely different uh first thing it is a hierarchical data structure second thing for the trees you actually have to consider some terminologies so typically a tree looks like this where it has a node in this node you can store some information so that information can be anything you can store an integer value you can store uh a character value or if you want you can store some class values as well so let's say that you created a class called person and in that class you have that first name last name and date of birth you can fill out all of the those information in this node but apart from that on top of storing all of this information let's say that you store that information in the majority part of the given tree node in the rest of the part you actually create the connections that it is connected to with other nodes and this is really important so one single tree you only have access to the root node but from this root node you can actually connect to multiple places inside the given tree so you can actually be connected with two more nodes that are below that under one of nodes you can be connected with three more or four more or any more number of nodes this node maybe only have one node then and this node has another node and this is how typically a tree progresses so when we are talking about trees we will have to first Define few important things so I already told you the number one thing that what a node is that node is basically the portion of tree that contains data that contains important information now next important information for that a tree needs is an edge and what does an edge represents so if we see or take a look at this picture Edge is essentially the o that connects any two node and there needs to be some relationship between them so typically in a tree you would always see a relationship like this where a tree is always under some other parent tree so in this case this root node is actually a parent node for these two subsequent nodes but also at the same time let's say that you have four more nodes over here then in this case for these nodes this becomes a grandparent and uh this becomes uh these two nodes becomes parents for these subsequent nodes so there is always a parent child relationship and that relationship is typically defined through an edge next we need to discuss that what a root means so root means the node that is that supersedes all the nodes so essentially the great great great great greatest grandparent essentially the very first node that becomes your entry point into the tree and this is defined as the root node now let's talk about that what does a leaf node means so Leaf node means that the node that does not have any children so let's say we have a tree that looks like this in this case we currently have a node this node is by default the root node and this tree is connected with these two edges to these two children but these two children does not have any subsequent children of their own so in this case uh these two nodes actually becomes the leaf node that we are trying to explain now let's talk about the concept of depth now what does a depth means inside a tree essentially for any given tree uh it is always placed in the layers that one root node has some children then these children have subsequent children of themselves as well there can be n number of Childrens and for the Simplicity sake I'm drawing two children for every single parent but there can be n number of children and in this case we can see that currently this root node is actually located at depth one or you can also consider it depth zero depending on what type of situation you're tackling they are just numbers but they would be the initial depth and then with every level you go down the number of depth increases by one so in this case this is located at depth one this is located at depth two so essentially depth can also be considered as level of parents or children uh that each one of them has and very close and very similar similar concept is of height so height basically defines that how deep a tree goes so in this case from the root node we actually go two levels down so we can consider the height of this tree to be two uh same way uh from any single separate node you can also calculate the height from that position as well and in this case the height would be one if we consider this smaller sub tree of a tree so these are the different terminology that you have to understand before we proceed with uh what a tree is now let's try to see that what are the different types of trees that are available and trust me there are lot of types of trees so first let's just start with the simplest trees and that is binary tree now what does binary tree defines well we all know the meaning of binary binary means either zero or one which means it means two so binary tree means that every single root node has exactly two children so in this case this would have two children same way these subsequent nodes would have two children of their each and so on and so forth and until we run out of the level so in this case let's say that this has two children and that's it so this is a binary tree why because by definition every single parent has exactly two children or no children at all so and that property is followed across all the nodes uh so binary tree is what you're are going to encounter mostly in your typical interviews and very closely and a a subset of this binary tree is actually binary search tree so what does binary search tree means that it follows all the properties that a binary tree has that every single node has exactly two children or no children at all but on top of that the binary search tree has an additional property where the values that are being represented in that those binary trees they are actually sorted with the condition that everything on the left is actually less than everything on the right uh and this property is followed throughout the entire tree so let me give you an example let's say that we currently have a tree that looks like this and currently the value of this root node is s then it it can only have children where the scenario is that everything on this left sub tree has to be less than seven if it is everything on this left sub tree is less than seven and everything on the right sub tree is greater than seven in that case we can Define this as a binary tree or sorry binary sear tree so let's say that we add two more nodes over here and these two nodes Define the values as that this one is value number five and this one is value number eight so far this follows the property of a binary search tree that is good for us now let's just take it one step forward as well so we have two more child over here in this case so in this case let's say that the value of this child is three and again value of this child is six is it still a binary tree yes why because let's follow the same property currently if we consider this parent node then this becomes the left sub Tree in left subtree all the values are less than value s so that is good now let's consider this node so this node is five its left is three and Its Right is six and that is also followed because left sub tree is less than five and right sub tree is greater than five so both properties match same way the right sub tree is currently greater than seven so this property also matches so in this case this would be a binary search tree and binary search tree has lot of potential and lot of application you can actually use it for sorting or you can use it for to store data or to go hierarchically down so we we will talk more about this when we go when we start talking about uh various uh scenarios where you can actually use the uh tree data structure now there is one more data structure that is called a AVL trees so what AVL trees is that AVL tree is actually a special kind of tree where not only it is a binary tree but apart from that it is also binary search tree and on top of that it is a balance tree so what does the balance tree means so let me give you first an example of a balance tree balance tree is any tree where all the nodes on the left side of sub tree and all the nodes on the right side of subtree are even so in this case let's say if I have a tree like this this is a balance tree if I have a tree like this where left node has two sub nodes and right node also has two sub nodes this is also balance tree so any symmetric tree is basically balance tree and AVL trees contains all of these three properties yeah so that is about AVL tree then there are all more specialized trees that is red black tree and there is also B trees but these are just too higher of the concepts but I'm just going to give you an example that red red black tree is actually a tree that has separate colors so some nodes are defined in a certain color and the other nodes are defined in the certain colors and depending on their positioning the colors are maintained so whenever you try to add new value uh it automatically maintains the colors and it automatically generates that what should be the next subsequent value based on those coloring groupings so the red black trees are great at sorting various items and various operations depending on the color property and B trees are multilevel balance and sorted uh tree data structure that can have more than two uh more than two children so it is actually much more complex topic and in its own uh it has actually lot of uh things that we can think about but we are not going to go deeper because that would be much that would be a topic for much higher level I just wanted to give you a brief overview for that now let's let's see that what are the operations we can do on a tree so the operations are quite simple we can do like searching we can also do sorting we can also do uh deletion and in insertion all of those things right but in order to do that uh we actually have to Traverse over the tree all the time and the most important operation that you will have to learn about is that how how the traversal Works inside a given tree so actually for trees there are typically three different ways you can Traverse over inside the given tree and that that are that in order traversal preorder traversal and postorder traversal so how each each and every one of them is going to work well I actually have a separate video on that but if you want you can just check what I'm trying to explain right now what in order traversal means is that first we are going to visit the node then we are going to visit the left child and then we are going to visit the right right child child preorder means that first we are going to visit the left child then we are going to visit the node and then we are going to visit the right child and post order means that first we visit left then we visit right and then we visit node so let's see this in action suppose we uh we are given a simple tree so I'm currently drawing a simple most basic tree and we will go through its values right so let's say the values are one then on the left is two and then Its Right is three and also on the right is four and on the left is five and on the right is six let's say that this is the type of tree that we are trying to generate now let's see that what would be the in order traversal would be for this part this type of tree well of course first we are going to visit the node so node in this case is going to be the root node and that is going to be one so the very first value we are going to go through is going to be value number one then we are going to see all the left sub tree So currently for the left subtree it only has node number two but again at node number two we are also going to visit this and then after visiting now currently for this node number two it does not have any left sub tree that we can visit so we are going to go into the right side and on the right sub tree we have value number three that we haven't visited so we are going to visit node number three after that again we are going to repeat the same process now in this case we already took care of this value this value and this value so now even for node number one we are going to go to the right sub Tre but for right sub tree again we are going to apply the same logic of node left and right so once again we we are first of all going to visit node number four and after that we are going to visit node number five and then we are going to visit node number six so we took care of all the nodes so this is how uh the traversal works for in order traversal now let's do the preorder traversal and inside the preorder traversal it's clearly see that we need to go to the left as much possible as we can so from the initial note do we have a left sub tree yes uh in the left sub tree we are going to go to this node now does this node has any left sub tree that we haven't checked no because this does not have a left sub tree then we can visit the node so while visiting the node the first node we are going to visit for the preorder traversal let me just write it over here so the first node would be node number two now the next node we are going to visit is going to be the right subt tree of this node now for this three it does not have any children which means we will have to visit this node so we are going to visit node number three first after visiting these two now for this node number one we took care of the entire left sub tree so we can actually visit node number one now after visiting node number one we need to take care of the entire right subtree but again with the same logic of left node and right so again we are at this position now this does have a left node so we are going to visit five first then we are going to visit the node and then we are going to visit node number six so this would be the preorder traversal for the given tree now let's see that what would be the postorder traversal for the given tree so in terms of post order traversal it is going to be actually quite simple uh again using the same logic we need to First go through every single left node then we need to go through every single right node and then only we will visit the existing node So currently for this one it does have a left node for this two it does not have a left node but it does have a right node so we are going to visit node number three first so in the post order traversal the first node we are going to visit is going to be node number three then the next node we are going to visit is going to be node number two and then we are going to visit node number uh one no we are not going to visit node number one right now because because node needs to be visited in the end and it still has right subt tree that we haven't checked so now we are going to visit the right subtree and this this portion now becomes the node and for this it also has a left node so now we are going to visit five then we are going to visit six then we are going to visit node number four and after completing both of these portion we are going to visit node number one in the end so this would be the full traversal for the given tree uh the in order preorder and post order traval uh this is the most trickiest thing to understand for any single tree and I hope you find you find it useful now let's see that what is going to be the searching sorting deletion and insertion for the given tree so let's say that searching if we are given a normal tree then the searching is for sure going to take big of end time but if we are given a binary search tree in that case searching would be bigo of log n only because every single iteration we would be uh moving half of the element on one side and we we can focus steadily on the target so that is why binary search trees are so popular now let's talk about sorting uh so for sorting actually if we are given a binary search tree then sorting is actually constant uh sorry because of log and time because it's quite easy to do uh we only need to Traverse over over the given tree and uh many for many sorting algorithm binary search trees are being used deletion if if we know which node we have to delete then it's a constant time deletion operation but if we don't know the node and we have to search first then it becomes big go of n or log n depending on what type of tree we are given and same goes with the insertion that if we know that we we can insert any randomly then it's B go of one but if we cannot do it and we have to insert it at specific location then it's B of n or big of log n depending on where we are trying to insert and what type of tree we are given so this is everything you need to understand about trees but now let's see that what are the uses on how on and where we can actually use trees so number one use case for a tree is typically a database management system uh why database management system because number one binary search trees then AVL trees then red black trees then B trees all of these are huge and very powerful in separating all the elements so that's why they are quite popular whenever you are trying to build a data stru database on top of that they are really po really powerful when you are trying to index all the values and indexing and enabling fast data retrival can only be possible using the trees if you have to use uh anything for file systems or file management uh so because tree they are already in hierarchical nature and whenever you see your windows path or your something something you will always see something like C drive it has a file called programs it has a file called uh Java it has a file called bin something like that so this is a parent child relation where every single node is connected with the other node and uh you can actually go over that plus if you want to create like a syntax trees you can also do that using the trees why syntax trees because let's say that if you're trying to build a scenario or a compile or something where you want to show that what class is connected with what other class and you are trying to avoid any infinite Loop scenarios so in that case tree data structure would be a huge help and on top of that you can actually use trees to build priority cues as well so this is also a very good benefit to use you can actually do that using Heap and uh I won't be explaining the whole concept but just know that this can be done okay so now let's try to see uh some examples for the tree based questions so one of the very common example is that typically we are being asked to validate a binary search tree now we all know by definition that what a binary search tree is that essentially every single node that is on the left side of the tree is actually less than uh the node value and every single node on the right side of the sub tree is actually greater than the node value and this property has to be followed throughout the entir of tree so let me give you a couple of examples where we will try to see that which are some of the valid trees which are not valid trees and how we can solve this problem in an actual interview or for our practice so assume we are given a tree like this where the values are 1 2 3 4 and 5 and uh these are the connection of the nodes so in this case we can clearly see that this is a valid binary search tree why because this is the middle node node number three now if we see the left sub tree for this node is actually the values are 2 and 1 and both are small than value number three same way in the right side of the sub tree the values are four and five and again both are greater than that particular value now we have couple of more sub trees as well that we need to check and that is this one so first sub tree is that this value of two and the value of one so again since the one is less than two and it is on the left side of the two uh it is a valid path same goes for this four and five as well and in this case we can Define this to be a valid binary search tree but now let's consider a scenario that if we are given a tree like this suppose the values are 5 4 3 and then this one is 6 and then this one is 2 and uh these are the nodes that are currently connected now let's break them down sube by sub tree so let's consider first this value number three and value number two they are just uh simple or Leaf nodes so they don't mean anything now let's consider this sub tree is this a valid sub tree yes why because three is less than four and it is currently on the left child of four so that is true now let's consider this entire sub tree so this is also valid because both four and five three are smaller than value number five now let's consider this sub tree this is also valid scenario where six is actually uh higher and in the greater value so 2 is smaller than six so that is why it is on the left side but when we consider this whole portion then it fails and why it fails because the value number for Value number five the expectation is that everything that is on the right side of value number five which means this portion has to be greater than value number five but since this two is actually less than five so because of this we can Define this to be a wrong wrongly placed uh value so this is not a valid binary search Tre now the question is how can we actually find the solution for this type of problem uh for trees so one simple approach is that if we do an in order traversal for any binary search tree if the tree is valid we should get a sorted array or sorted values in return and let me give you an example for this let me for a moment make this a valid binary search Tre so the method for in order traversal is first we visit the left sub child then we visit the node we want to check and then we visit Its Right sub child or right child and we keep on repeating for all the sub trees so so essentially first of all we will start our journey at this root position so at the root position first we need to check that whether a left child exist or not and yes because left sh exist once again this becomes our current root node or current node we are working with again this also has a left sh so three would be the first value we would visit so let's mark three would be the first value we visited then we would go back to the root now this node has no other left Sub sub trial uh that has not been visited so we would visit value number four and then it does not have a right child so we will again go back and now for this five we took care of the entire left sub tree so we can mark five as visited as well and then we will go to the right side of the sub tree now in the right side of the sub tree for seven we still have a left node available which means we would first have to Traverse that so we would Traverse value number six and then we would go back and since this seven we took care of the left sub tree so now we will take care of value number seven and this is where we would end and now if you see this sequence this actually came out as a sorted uh values so this is all we need to do that whenever we need to uh run for a tree we simply need to do an in order traversal if all the values are in correct sorted manner then we can Define this to be a valid binary search tree if that is not the case we can Define it invalid and let's try to understand this with a very small example suppose we are given the values as uh 5 3 and 2 suppose this is the sequence of values now if we do order traversal in this one first for five we are going to visit the left child so we are going to visit value number three that is good then we would visit value number five and in the end we would visit the right side right sub tree that is value number two now up until this portion this was a valid binary search Tre but the moment two entered over here this this is no longer a sorted uh sequence so that's why we can Define that this is not a valid binary search tree and let's see the code for this one right now so this is the validate binary search tree problem and now let's see the Java solution for this approach we already know that we need to do an in order traversal in order to validate that whether given tree is valid or not and for that we are creating a helper method where first of all we are checking that if the given root is equal to null then we can return true if that is not the case we need to do the in order for the left sub tree of the given root and the right sub Tre of the given roote so we do this that we call our uh recursive method once again where we call the left subtree uh as an input and we try to see that what is going to be its answer so let's say that if this yields the answer as false uh then we can simply return false if that is not the case then we can move forward and we will check that if whether the previous element was null not equal to null and if the value of the root is less than the previous element then also we can return false which means in this scenario we identified an anomaly where there has been a mismatch between any two values and they are not currently sorted if that is not the case then we are going to Mark the previous node as the root of the value of the root we identified and then we are going to call the in order function once again on the right side of the sub tree so this is a very simple piece of code but it's actually very powerful and help us Traverse the tree in the correct manner recursively plus we are learning that uh what type of uh tree it is now let's submit this code and our code runs pretty fast compared to a lot of other Solutions so that's pretty good where graph is a very similar data structure to a tree uh and if we just talk about the terminology that we are going to use in the graph even in the graph we are going to have a node but in the graph we can also Define node as a vertex and that essentially represents the same circular dot that I just mentioned where you can store all sorts of information like integer or character Boolean or class value or whatever he wants to store you can store that inside but on top of that apart from that nodes node having that important data information it also has the information of other nodes that is that it is connected to in the current system and those other nodes can be n number of nodes on top of that those other nodes can also be connected inter internally as well and there are some scenarios where one node is connected with another node but another node is not connected with that node and that node might be connected with some other node and that some other node might be connected with that node as well so there are lot of different uh ways uh graphs can work now one key difference between a tree and a graph is that graphs are graphs can be cyclic in nature and what do I mean by cyclic that let's say that you have a node that is connected with another node it could be possible that is also connected with another node and that is also connected with the previous note and this type of configuration would not be present inside a tree this this can only be present or prevalent inside the graph and that is the the biggest difference between trees and graphs and that's why they have their own entire set of different con considerations and connections so now let's just go back to the basic terminology that we need to understand first we understood that what a node or Vex is or vertices is next thing uh that we have to consider is The Edge and Edge is the it means the same thing that that is the connection point between any two values uh that are next to each that are connected with each other so Edge means the connecting points now there is also the concept of adjacent uh adjacency or adjacent vertices what do I mean by adjacent vertices let's say I have a graph that looks like this and in this case uh currently let me Mark the values as a b c and d so in this case if I consider this node number c I can say that node D node B and let's mark this node as node e so B D and E are actually adjacent nodes to this node C because they're directly connected with that with an edge but if the this node is not actually connected with vertices then in this case this node C and A are they are not adjacent nodes to each other so this is what what do we mean by adjacent nodes now there is also a concept ccept of degree inside for any single vertex and what does a degree means that degree means that how many number of vertexes uh or connections that every single node has so let's say if I have a graph that looks like this in this case I have node a b and c so I can Define that this node only has one Edge so I can consider the degree of this node to be one in this case for this B it has the degree of two and in this case this C it has degree of one now there is also another concept of the total degree depending on the incoming and out outcoming edges as well and where does incoming and outcoming edges comes to place well we we will talk more about that when we discuss the type of graphs but remember that graphs can have a functionality where two one graph is connected with another graph but another graph is not connected so in this case if we Mark if we have a graph like this where a has an edge leading to the B but B does not have an edge leading to an a which means from a we can actually go to B but from B we cannot go back to a so in this case a would have an degree of one but B would have degree of zero in this case so that is that is the difference between these two uh this concept of degree for the graphs now let's see that what are the types of graphs that we we can deal with so number one type of graph is a directed graph and what does a directed graph means that I just showed it to you you that this is actually a directed graph where one node is actually connected with another node but it is not the vice versa is not true and the directed graphs can get really complicated as well it is not always going to be this simple or this similar and it could also be possible that there can be hundreds or even millions of nodes that are connected with each other in this fashion as well uh where we would have various degrees and various directions happening amongst different vertices there could be undirected graphs as as well and undirected graphs are actually a graph where two nodes share a common Edge so in this case rather than treating is as a single edge typically this is used to be like this where node a has an edge leading to node B and B has an edge leading to node a which means from B you can also come back to a and from a you can also go back to B but in this case typically we only show them using a single edge then whenever there is an edge without an arrow it defines that both nodes are connected with each other in the simplest Manner and there are there is a bidirected connection or an undirected connection now there is also consider uh also a concept of weighted graph and what does a weighted graph means that let's say that you have different nodes and different nodes had different connections and different connections have edges so edges carry weight as well let's say if I'm trying to plot a graph of a city now in this city uh this node represents the Young Street and this node represents the main street now these two streets are being represented and there is let's say there is also third street called Queen Street now there is a graph that looks like this but in this case it could be possible that this is this graph I'm defining this is defined as a road so it could be possible that from Young to main though there is a road there is some construction going on so because of that this Edge is actually weights five which means it takes 5 minutes from Young to go to main but it could be possible that from Young if we need to go to Queen it only takes 1 minute because there is no construction and from Queen there is only uh there is an edge going to main that also only takes 1 minute because there's no uh traffic so in this case because this Edge contains higher weight if we have to choose the shortest path between young and Main Street it it has to go through the queen Street and uh this would be the concept of a weighted graph this is really powerful especially for GPS system and the shortest path that we have to create uh between any two edges like Google Maps use this like crazy uh now there is also another concept of unweighted uh Edge and unweighted Edge is basically an edge that does not have any parameter uh so let's say that I'm creating a graph of just friends so currently a is friends with B and B is friends with c and C is also friends with a so in this casee I don't need to have any weight on the edge um they are all just friends and none of them are best friends so that's why it's a common relationship and U we can do whatever he wants to do then there is also concept of Click graphs and a cyclic graphs so cyclic and ayylic both means the same thing essentially this is a cyclic graph and let's say that if I did not had this Edge in this case then this would have been an ayylic graph where cylic graph has means that there exist a cycle between the nodes and a CLI graph means that there are no no Cycles happening so usually in ayli graphs there is a very popular concept of dag which is which means directed ayylic graph and directed asly graph means that every single node has an directed Edge so let's say that there this is node a node a is connected with node B and node B is connected with node C and C is connected with node D so this is an example of directed A basically graph where we see bunch of different edges but there are there are no issues with the graph now because graphs are a little bit trickier uh we have to take care of two things we have to take care of vertices and we also have to take care of edges to represent that what graph is connected with which so that is why uh even in order to represent a graph we need to have some different set of data structure so one possible data structure is an adjacency Matrix and another data possible data structure is an adjacency list so I'll I'll give you give you an explanation of both of them let's just have a demo graph uh that is a simple enough so let's just say we have a graph that a is connected with B and B is connected with C and C is connected with d and this is a graph right uh that we are trying to represent so if we have to create an adjacency Matrix what adjacency Matrix means is that we are actually going to have a 2X two or sorry M cross n Matrix where for every single vertices and edges we are going to have uh a matrix looking like this so we are going to have rows a b c d same way we are going to have columns marked as a b c d now currently uh all of the these four values will always be zero because node cannot be connected or cannot be its own neighbor now now let's say that currently a has a connection with B so we are talking about node a and its neighboring Edge to be B so in this case we would mark this value as one now B has a connection with C so node B has a connection with C so we would also Mark this value as one C has a connection with d so C to D we would mark it as one and D to uh and D does not have any connection which means this is going to be zero and all the other values they are going to be marked as zeros because they don't represent anything which means currently we have a graph that contains four nodes a b c d amongst these four nodes we only have connection between from A to B so that is why this is one but we do not have a connection from B to a so that is why this is defined as zero let's say that rather than this being a directed graph If This Were to be an undirected graph and we only have edges like these in this case in our adjacency Matrix we are going to represent values differently where uh even from B to a we are also going to Mark as an edge same way from C to B we are also going to mark an edge and same way uh D to C we are also going to mark an edge over here so all of these values would also be one in this case so this is the way on how we can represent graph in The adjacency Matrix Now adjacency list is a little bit different where adjacency list we actually have a hash map and I I know I haven't talk talk about hashing yet but inside a typical hash we have two values we have a key and we have some value associated with those that key so as a key we are actually going to have the four vertices that we are given so in this case it's a b c and d now for this we are going to mark that what are all the neighbors that a is connected with in this case currently a is only connected with B so we are going to have a value like B Associated for a same way currently B is actually connected with A and C both so for B we will have a value of a and C both and this is actually going to be a link list that where which represents that there can be n number of children associated with a sing or n number of neighbors associated with a single node same goes for C that from C it is connected with b and d and d is only connected with c and this is how it would be represented in adjacency list now the question is which one is better and which one is worse well in my opinion both does the job well but if you're dealing with a low number of edges then in that case it makes sense to use an adjacency list because it SP it uses less space uh meanwhile over here you see that there are more zeros than the number of ones but let's say that we have bunch of different edges that we are trying to work with something like this in this case it would make more sense to use an adjacency Matrix rather than using adjacency list so so these are the two ways on which we can actually use uh to represent graphs now what are the operations we can do on the graphs uh speaking of operations well the common operations are always going to be there that in terms of operations we would be able to insert we would be able to delete we would be able to modify we would be able to search there is no there is very little concept of sorting in this case because it is not very optimal for sorting but apart from that these these are all the things that we can do but in order to do that we can only do it by traversing over the given graph because we would not know that where we are traversing so we must have to Traverse and for Traverse we actually have two options we have the breath first search and we have the depth first search so I'm going to talk about both of them in a simplest manner uh if you want to know more about this uh I have created an entire separate videos on these two topics so that's why let me give you the basic idea that BFS represents breath first search what does breath first search means that we are actually going to search our neighbors first and before going to their neighbors and DFS means that depth first search what does depth for search means that we will pick a neighbor then we will pick one more neighbor for that neighbor then we will pick one more neighbor for that neighbor and we would keep on moving forward in that direction so let's try to see that in let's say that we have a graph that looks like this where we have bunch of different nodes that are closely connected with each other and we are trying to find some particular value right uh let me draw out bunch of different edges and with every single edge uh we would be able to reach to a certain conclusion about the given graph now let's say that this is the graph currently we have and we also have a cycle in in it now we are currently located at this node number a and we are trying to find this node number B and all of these nodes they can have their own subsequent separate values so if we are going in the BFS manner breath for search manner what we what we will start to do is let's say that this a is also the root node because even just like trees graphs also have the concept of root node so let's say that this a is the root node so from this a we know that what are the neighbors of a through either adjacency list or adjacency Matrix so we are going to use that in information and we will start traversing to all the neighbors so first we will go to this neighbor okay this is not value number B then we will go to this neighbor this is not value number B then we will go to this neighbor this is not value number B then we will go to this neighbor then we will go to this number we ex ex uh excluded all the possibilities for all the neighbors none of these neighbors were actually value number B so then we will pick one neighbor at R random and we would keep on moving forward so let's say we pick pick this neighbor again we go to its neighbor and again we go to its neighbor none of these yielded any good any particular good result so what we do we backtrack in that case and again from this a we would pick another neighbor so let's say we pick this neighbor this time and through this neighbor we would go to this neighbor and we would also go to this neighbor and we found out value number B so we can say that okay this is the connection between a to B and let's just say for this example the value of this neighbor is node number c so we can say that there exist a path from a to c and from C to B where it is connected now this would be the strategy for breath first search uh and I hope that my explanation was clear enough so that you get the idea now let's see that what would happen in the depth for search scenario so in the depth for search scenario we will pick one neighbor and we will keep going deeper and deeper into that neighbor so let's try to understand this with an example suppose we are again located at this position number a so from this position number a first we will pick a neighbor so let's say we pick again this neighbor now again for this neighbor we would pick one more neighbor so one more neighbor we ex now we uh concluded all the possibility that there this neighbor does not have any neighbor that we haven't visited so what we would do is we would backtrack to this position again see that are there any neighbors that we haven't visited so we actually check this neighbor okay this one we haven't visited so we visit that and that also did not yield any result so again we backtrack we come back to our main a then we pick another neighbor so let's say in this case we pick another neighbor called C from the C we again go to deep okay so this one did not yield it result so in this case again we check for this one and this one yielded the correct result and we again created a path from A to B to C and again we got the correct answer now you must know that under which situation you need to use breath for search and under with situation you need to use depth for search let's say that you have a graph and you expect B to be somewhat closely to your current a if you expect that in that case it would make more sense to use breath for search because you are more likely to find a result within some of the neighboring graphs but let's say that you have a graph that is much more complicated and B can be located somewhere down the road uh somewhere very far far far away in that case it would make sense to use a depth for search rather than breadth for search in either case the time and space complexity for both breadth for search and depth for search is actually going to be bigo of M cross n where M can be the number of vertices and N cross be the number of edges so it could it would be B of Vertes multiply by edges and all the operations we defined for the arrays they are also going to have or they are also going to follow the same time complexity that whenever we need to to find any any two values it is going to be the same now let's see that what are the use cases when you have to use graphs number one use case is actually social network so in Social Network we know that let's say that my name is person a so person a can be friends with many other person so I can be friends with B I can be friends with C I can be friends with d i can be friends with e something something something like that right and E can have their own separate friends so e can have friends F and uh Zed and all all all of that now this is how a typical social network looks like and that is why it is really common to use that let's say if I'm using a social network like Facebook where if I am I can only be friends with someone if that person is friends with me in that case there would be an undirected relationship but let's say if I'm using something like Instagram where some X person can follow me but I cannot follow that X person so in that case let's say that I have a relationship like this where X is following me but I'm not following back X so in this case we have a directed graph or a directed relationship but either cases it works perfectly fine next there would be a great use case for uh different internet and because in the internet we have a many different web pages that contains lot of information and we have the HTTP uh URLs that are are connected with each other on top of that from every single uh web page we can also have many different HTTP web pages that connects to some other web page and from that it can have many different web pages that connects to some other web page so in this case graph can be a good way to store all of that information plus I already mentioned that if you want to create a GPS system or any navigation system graphs are a wonderful approach and you cannot build a navigation system without using graphs where cities or places are treated as vertices and the roads are treated as edges and uh that is how you move move forward on top of that wherever you have to resolve any dependencies you can actually use graphs to resolve that dep dependency so let me give you a quick example let's say that you are studying in a university and in the University we know that we can only take courses that are like 204 or 205 if we already completed its prerequisite of 105 something like this so if that relationship is done done if unless I have completed this I cannot move forward to this particular course so in that scenarios treating different courses as vertices and connections with them between them or dependencies between them as edges would yield to Greater success in terms of all the results so these are all the operations and all the things where you must use graphs so first of all we are going to understand a graph with an example so this is a very simple problem and I might use some terms or some Concepts that you might not be familiar with but don't worry about it I would be guiding you throughout the whole journey and it's actually a quite simple way to understand what does a typical graph problem looks like and how does it work so number one thing in the graph is that for this problem we are actually given an N cross n Matrix and in this n cross n Matrix we are being told that this n represents the basically cities and if there is a path from one city that connects to another city then there would be a link in this n cross n m Matrix so it would Mark as one for that particular cell and if there is not a path then there won't be U any connection and it would be defined as value zero so let's try to see that what we need to check we essentially needs to calculate that how many number of provinces are there so what provinces are being defined as that let's say that if there is there are cities connected with each other then they would be part of a single Province so this would be a single Province P1 and even if there is a unique city that is not connected with each other still it is a province on its own so we would consider this as a province as well and uh let's try to see some examples of what different questions or what different things that we can refer so number one example is actually quite simple let's assume that we are given the CI a b and c in this case and we can see that City a and City B is connected with each other City C is not connected with each other so in this case this is a province and this is in itself another Province so we can return that in this case there are two provinces present and we can return two as the answer let's consider one more scenario suppose we are given uh four cities in this case and let's say that for the four cities all four cities are connected like this and you see that there is actually no connection over here but still we can conclude these cities to be connected how because let's say that this is a so a is connected with B and B is connected with C and C is connected with d so in this case you can still reach to D so all of this entire cluster would be considered as a single Province only let's take just one more example to make things more clear let's suppose we are given four different cities and all four different cities are not connected with each other in this case we can Define that four there are in total four separate provinces available in this case so let's see that what is going to be the approach to solve this problem okay so let's assume that this is the example we are given and this would be its Matrix that is going to represents the connection connection between any two cities now in this example we can clearly see that there are actually going to be three number of provinces uh this is the first Province this is the second Province and this is the third Province but let's see that how we are going to compute these results and for that we are going to uh first Mark or populate these Matrix basically this Matrix is already given to you in the example but I'm just showing you that what is the approach we are going to take in order to solve this problem so first we are going to see that uh since there is a single ended or one unidirectional connection between a to B which means we can also Define that there is a connection from B to a as well and this is what we are going to represent in this n cross n Matrix so first let's see okay so we have u a connection between a to B so we are going to mark this as value number one same way we have a connection between B to a so we are going to mark this as is one as well and B to C there is a connection so from B to C there is a connection same way from C to B there is a connection up again from D to e there is a connection so let's mark that from D to e there is a connection over here and same way from E there is a connection to d as well so let's quickly Mark that and uh that is over here okay and then F there is no connection so basically these are all the connections we have apart from that all the values are going to be filled out with values of zero we can actually consider this as a uh adjy Matrix for our our given graph and we can treat each of the Cities as the node of a graph and the connection or the edges between these cities are actually the edges between the these nodes so now all we need to do is we need to find the number of connected components and that's it so that is actually quite simple to do but how to do it I'll just show it to you quickly now I already mentioned to you that in the graph we have to keep keep track of the notes that we have visited already so that we don't encounter any issues with the visited uh we don't have any issues in the future so we are going to have uh basically a hash map that where we are going to store the values of all the visited values and plus we are also going to keep track of the neighbors or the connected cities for that particular node as so we can actually skip that in the future and the approach we are going to take is we are going to do a breath for search starting from any node and we would keep on doing it until we exhaust or we take care of all of these six cities so let's start our approach and the idea is that we are going to start working from the node a so let's mark that currently we are located at position number a so we are located at this position now from a we are going to see that what are the places it it is marked as one or it is connected to those cities and we are going to Mark those cities as visited so let's just say since because we started a new province with this new traversal a we are going to increase the number of provinces so this probe is defined as the variable that keeps track of how many number of provinces we have been able to find so initial value was zero and now we have value as one now from a we see what who is the neighbor of a so the neighbor of a is actually value number B which means means in our hashmap we already had entry a then we are also going to add entry B and this can actually be a hash set rather than hashmap what is the difference you would soon find out uh when we talk about hashing but right now just consider that we are marking these values so this would allow us to let us know that these are the cities we have already visited so we don't visit them again okay now we are at position number B from B which are the cities B is connected with so number one city B is connected with is City number a but a we have already visited so we are going to skip this for now then we are going to visit City number C and C we haven't visited so we will mark C over here okay so now we are at City number c what are the cities C has that we have we haven't visited so C is only connected with b and we have already visited B so which means we can conclude that in this case since we visited C does not have any more neighbors that we need to visit so we will do a backt trck we will go to B B again does not have any more neighbor that we have to take keep track of so we and once again we will backt track to a and a we already visited all of its neighbors so we can conclude this a b and c to be completed over here and so far we have been able to find one Province but now in this case we will jump or have to go to the next city d by taking a jump because we are not going through a connection from any particular node so that is why we are adding one more Province or we are exploring one more Province so we will increase the number of Province to two and in this case uh at City number D we are going to visit all the neighbors of D in breath for search manner so since D only has one neighbor that is City number e so we are going to go to City number e and we are going to Mark uh both d and e as visited in our hashmap on top of it with e e only has one city as its neighbor and that is City number D so in this case we have already visited D which means we can Al conclude both d and e to be visited as well and now we will have to still go to a city that we haven't visited so far that is City number have the moment we go to a new city we are going to increase the number of provinces so now number of provinces is going to be three and we are going to say that we are currently visiting City number F now F does not have any more Neighbors which means we can conclude that from F we cannot go anywhere else and now we have visited all the cities that were present because we have that value in our hashmap and we so far we have been able to find three different provinces connected using this manner so this is how typically a graph problem operates where in most of the cases you are going to have vertices you are going to have edges you are somehow going to iterate over all the vertices through edges and you are going to use an adjacency Matrix Or adjacency List uh uh as the way that stores the information of what the graph is and most like you are going to use either hashmap or hash set to keep track of the Cities you have already visited so you don't end up in a a continuous loop so let's see the Java solution for number of provinces problem basically uh we are we are given the 2x2 or n cross n Matrix that defines that what are the components that are connected with each other so first of all we are going to define a number n that is be that is going to be the cities that we have and we are going to create a Boolean visited array to keep track of all the cities that we have visited so far initially the number of provinces are going to be zero and then we are going to run a for Loop to iterate over all the given number of provinces and initially we are going to check that whether that particular city has been visited or not if it is not being visited then we we will go to our BFS call or breath for search call and uh recursively try to find the solution and every time uh the Call Comes Back we are going to update the number of provinces now in the end we are simply going to return the number of provinces now let's see that how does our BFS function works now since we are doing breath for search breath for search can be done using a cube so we are going to first of all initialize a cube and uh we are going to have a link list for the cube you can have lot of data structures s Cube so first we are going to start with the start value then we are going to mark that start value as V visited and then through that start value we will keep on iterating to its neor neighboring cities until we have visited all the values inside the current q and the moment as Q is empty we are going to jump out and say that okay now we have visited all the connected cities and throughout our connection we are marking those cities as visited so that's how we are we have been able to calculate uh all the connected cities as visited and only increasing the number of provinces for the new cities now let's try to run this code okay seems like our solution is working let's submit this code code and our codee runs pretty efficiently compared to lot of other Solutions so you can imagine that how a combination of data structures are being used to solve a simple problem and uh KN knowing all of these data structures would help you quite significantly in order to break down and solve a problem and generate the algorithm for that problem okay now we will learn about hash based data structures now hash based data structure are actually quite unique in nature plus they have their own set of uh very important use cases that you are going to see out throughout your data structure and algorithm problems so first let's understand that what does a hash based data structure is typically when we talk about hash based data structure we are usually talking about a hash map and a hash set now both are quite similar in nature and both have very similar properties but the only difference is that hashmap is typically used used for to store a key value based uh mechanism where we have some key that we use to search through the given uh data structure so it will give us an idea that what are the things currently present inside our given data structure and what are the values associated with that hash set is uh where we only save hash based keys so nothing more than that so now first let's understand that what does a hash map is how to use it we will see an example of how it is being used uh in an actual interview and then we will learn about hash set so hashmap as I already mentioned that there are two properties associated with that first one is a key and second one is a value now let's try to understand hashmap from a real life point of view if you have ever seen any kind of dictionary well typically the dictionary is a very close example of a hashmap where in the dictionary typically on the first page we usually have an index index page and in that index page we are given the information that uh a starts from page number one uh something like B starts from page number 15 and so on and so forth and this is usually sorted so if we have to find any particular value all we need to do is go to the index page in the index page we can find the information that okay uh letters starting from um M are actually stored at page number 53 then all we need to do is that in our dictionary or in our book just go to page number 53 and we would be able to find the meaning of word man or map or anything that it would be present over there so this is the actual idea being used in the inside the hashmap as well where we are given two items or we are storing two items first item is a key and second item is a value now key is going to be the hash function that is a some computational method so this is usually the hash function we Define where the values are being stored as keys and whenever we need to search inside our hashmap that whether this particular key is present or not we can do that in B of one time in constant time so let me give you an example of how does this actually work let's try to understand that we currently have five different values that we are trying to store and these five values are 11 12 13 14 and 15 now for these values I want to create a hashmap function where I want to retrive these data in the quickest manner possible which means I already know that these five are going to be my values but I need to create keys for them and the key I'm creating is that I create a method where I say that any particular value that comes in I'm just creating a basic hash function so you would get an idea that I create a method where any particular value that comes in I'm going to divide that value by five and whatever the remainder is so the remainder I'm going to treat it as a key and now let's see that how would this work so first let me draw my hashmap and inside the hashmap I'm going to have two values key and value so first value is 11 that I'm need I'm trying to input so I'm going to divide 11 by 5 so 11 by 5 is going to yield me the remainder as one I'm only concerned about the remainder I'm not concerned that what does the division value comes in so remainder is going to be one so I'm going to create a value over here where the key is one and its Associated value is going to be 11 same way for Value number 12 the remainder is going to be two so once again I have an entry two and the value is 12 same way there is uh for 13 we have value number three and the value is three for 14 we have value number four and value number uh uh 14 and the last one is the value number 15 so what should be the key for Value number 15 well if you guessed five that's wrong actually the key should be zero because remainder in this case is actually zero when you divide uh 15 divided 5 you actually get the remainder as zero so 0o is associated with value number 15 now I have these currently these values being stored now let's say in my program for some purpose I want to check that whether in our hash map do we all already have value number 13 or not so what I'm going to do in this scenario is that for Value number 13 I'm going to uh basically divide this 13 by 5 so I'm going to check that remainder is equal to 3 now this remainder is actually my key so then I would go to the hashmap and say that hey hashmap do you have any value where key is equal to three so hashmap would say that yes I have key is equal to three present but I don't know what value is so you would say okay bring me this value so you you fetch this value and this value it turns out to be 13 and then you would be able to say that okay in my hashmap I have a value 13 that is stored currently present and then I can do some competition with this now can you identify some issues with the hash function I have created uh let me just draw the hash function again and currently these are the values I have and the associated values are 11 12 13 14 and 15 now this is currently my my hash function okay so far it looks good but now let's say that I'm trying to see that does value 61 exist in in my hash map or not so what would my Approach is going to be once again I'm going to do 61 divid 5 and remainder is going to be 1 so once again as a remainder I'm going to go to the hashmap and see that okay hey for this key number one what is the value associated with this the value Associated right now is only 11 so I can say that 61 is currently not present in the hashmap once again I got this result in big off one time but now what if it happens that I want to add 61 to my hash map as well well in this scenario I since the key can only remain constant so which means for this key 1 I have one more entry that is 61 that I need to add over here so in the place of value I might I might need to create something like a link list because there is a collision over here of the keys because the number of values are more and keys are less yes so in this kind of scenario collisions are bound to happen and because there is a collision now I have value number 61 let's say the value is 71 I'm trying to add so once again I will add one more node in the link list and I would add value number 71 over here so so far let's assume that initially when we only had five values we actually had five keys and five values so the equation was almost one to one relation and we were able to fetch any particular data in big of one time but now let's assume that we still keep only five keys and now we have uh for an example one 1 million entries so in this scenario or let's say 5 million entries and five keys so mathematically every single key would have 1 million entries ass associated with that particular key and in that case all of these 1 million values would be stored in a link list uh in the value section connect where one node is connected with the another node so so once again in this kind of scenario if I have to fetch any value now now it it's going to take big of end time where n is going to be 1 million in this case so this is actually really bad so in the hash whenever you are building your own hash map you need to make sure that the hash function you are you are using to build evenly distributes the values which means that for any single value typically the hash function tends to be a unique set of key and that is one of the biggest consideration now now lucky for us most of the programming languages like Java python or whatever you can think of they already have this functionality of implementing a very good hash function that usually tends to be unique and implements the keys in the unique manner so we don't have to worry about it all we need to do is just declare the hashmap and uh we need to declare that what type of key and value pairs are we are going to store so we can store like integer as the key and string as the value and then we can name our hash map as something like my hashmap and then we simply need to initialize it and that's it so this way it's it becomes really powerful so always make sure that even during the interview interviewers love asking this question that uh how do you handle Collision in your hashmap so typically you would assign a link list for to store values when you predict a scenario where there is going to be a collision in terms of values now let's see that what are the different operations we can do for any given hashmap and I'm going to store some values so let's say one is associated with 11 and two is associated with 12 so this is our current hash map right now hashmap tends to be dynamic in nature so which means that uh all the values you want want to assign if you want to keep on adding more and more values in this scenario essentially you don't have to do anything it will usually takes care of it and most of the languages are sophisticated enough to be smart in that regard so that is really good for us now first operation we can do in hashmap is we can add a value so typically this is done by using something called a put variable uh and we can put a new value inside the hashmap and this is usually done in big off one time where we need to provide the value of a key and Associated value with that remember key cannot be a null value you can have a key uh that does not have any value associated with that that's fine but still key cannot be a null value you cannot have a value that does not have a key associated with that in the hashmap second operation we you can do is you can delete any value from the hashmap and this is also done in big off one time so that's great next operation you can do inside the hash map is that you can search for any element and searching also takes big off one time because we are using the property of key value pair and we are searching using the keys we are not searching using the values so that is an important distinction you have to understand whenever you are trying to think that how you're going to use hashmap to achieve your goal next uh operation we can do is we can actually sort all the values but that we need to do it sequentially so there is no inherent method to do that so essentially this is still big of n log n uh time operation where you need to uh call some other data structure and then you need to populate all the values uh let's see what are other operations we can do you can of course you can modify all the values that are currently present and that can be done in B of one time and that's it so now you can see that uh hashmap on paper looks pretty good because all the operations that you can think of insertion deletion addition modification uh searching sorting they're all pretty fast and pretty efficient uh there is one big issue with the hashmap and that big issue is that you cannot have duplicate keys so uh the key value has to be unique so no duplicate keys and also the duplicated values would be stored under the same key because key these are typically generated based on based on their values so always remember that duplicate values cannot reside inside the hashmap and now let's see that how does a hash set work and then we will see an example of a typical hashmap problem so hash set is very similar to hashmap but the only difference is that inside the hash set there is no concept of key value pair it is only just the values that are being stored but these values are typically stored using the hash function so uh let's say that I currently have values 1 5 15 uh 31 and 21 uh that I need to store so so far I have stored these four values inside my hash uh set so I can of course enter these values 11 15 uh 31 and five now I want to check that whether 21 value is present inside the hash set or not so I can check this in big of one time why because just like a hash map hash set also uses the hashing function it just doesn't store the key but still it calculates based on the value that you are trying to input so there is going to be a mathematical function that operates and that would be able to immediately identify that whether this value has been processed and stored inside the headset or not and uh it's not stored so I we can add this entry now again just like hash map hash set also does not allow duplicates so there is there are no duplicated entries over here and uh one good property that since there are no duplicated entries allowed whenever you need to check that in any other data structure like a link list or um an array if any duplicated entries exist you can actually use hashset to solve that kind of problem quite easily and there are many use cases for that as well uh once again if we look at the operation operations are pretty much the same so uh everything like uh adding value takes big off one time once again deleting also takes big of one time uh searching takes big of one time sorting takes big of uh and log and time so this you can usually consider very similar to hashmap the only difference is that in the hashmap you can actually store the correlation between key and value in the hash set you only store the value now let's try to understand couple of examples through which we will understand both hash map and hash set so let's say for an example we are given suppose an array a where we are given five different elements and now our job is to check that whether uh the array contains any duplicate element or not and if it does what is the duplicate element so let me give you an example suppose the values are 5 3 1 2 and 3 so we can see that three is the duplicated element and the purpose of our program is to check or find that whether there is a duplicate element or not and if it if yes then which is the duplicated element so first let's understand that what would be the Brute Force approach in this scenario well it is quite simple we just take take any element so let's say we take element number five in this case and then iterate over the rest of the array to see that whether Val value five is present or not if it it's present we can return true if it's not present we can return false and go to the next element so for three we will repeat the same process and we would find that three is also present in this case so we will return return three as a duplicated element but this approach yields the big of n Square time complexity because for every n element we are essentially doing n minus one work so that is a multiplication factor and uh which is not too good so let's see what would be the better solution so better solution would be that uh if we try to sort this given array then things would become easier so if we sort this input we will get an array that looks like this that 1 3 uh sorry 1 2 3 3 and 5 so in this case uh then we only need to check the adjacent values and here we would be able to see that these two adjacent values are same so we would return return three as the answer now this better solution where we are sorting the array that is also bigo of n log n time solution so could there be a better approach and the answer is yes and that is by using a hash set in this scenario so what we would do is we would initialize a hash set our algorithm would be that we would first check that whether any element if that is present inside the hash set or not if it is present already and it is also in the array then we can consider that to be a duplicated element if it is not present then we would simply add that element to our ha set so let's try to run this method so first we would add value number five over here because it is not present already uh so then after adding it we would move to the next element now value number three is not currently present inside the haset so we would again repeat the same process then again we would repeat the same process for Value number one and again we would repeat the same process for Value number two and all of this insertion would take big go of one time Plus checking that whether the element is present or not that would also take big off one time so this is not any uh additional overhead now when we are at position number three we check that whether three is already present inside the hash set or not within big go of one time we would be able to find out that three is already present which means we would know that three is the duplicated element and we can return true in this case that yes this array does contain a duplicate element and if we are being asked to pass on that which value is repeated we can return three in the answer so either case this hash set works perfectly fine now what would be the solution in this case or the time complexity well time complexity is going to be biger of n because we are going to only iterate over the element or this array ones to solve this problem but in this case space complexity is also going to be bigger of one uh bigger of n because we need to create an additional hash Set uh and its size is dependent on the number on the given input now let's see that uh this would be an example where we would use hash set to solve the answer but now consider a scenario that in the same example uh we are being asked that rather than just giving out the value of the uh duplicated element give us the index value so again let's see that how would that scenario work suppose this is the uh given new array and we need to return the index elements of the duplicated element how what should be our approach once again we already know that brute force and uh sorting approach already works the way it does in this scenario as well but in this case since we need to return the index values hash set would not be the optimal choice and it would make sense for us to use a hash map where inside the hash map we would actually create a key value pair based database where in the key we are going to Mark these values and as their subsequent values we are going to Mark the index positions so when we need to fetch that which index positions are duplicated we can return that quite easily so now let's see the solution in this case so for first of all we would check whether five is is present or not five is currently not present inside our hash map so we would add an entry called five and we would add its index location zero now again one is also not present so we would add entry one and its index location is one three is also not present so three and index location two and four is not present so four and index location three now again this is key value pair so you understand what I'm doing now when we are at this position number five or position number four uh where the value is one we try to add one but we already see that one is already present because it is marked as a key and this operation can be done in big off one time because it's a hashmap so since we already found that we can actually return one uh is the duplicated entry and if we want to return the index positions we can return the index position from here that would be four and the value of this key one so that would be one and this would be the answer we need to return in this case so you can understand that how quickly we are able to solve problems using hash map or hashset and uh we are going to use them throughout this course for bunch of different problems so you should be able to understand them quite easily now after learning most of the basic data structures we are going to learn couple of advanced data structures and these Advanced data structures are actually quite popular in technical interviews and also a lot of computational problems as well so there are quite a lot of advanced data structures but we are going to shift our focus on two two main ones first one is called Heap and second one is called try now both are combination of various data structures but they have a very specific use cases where it is really popular and really powerful so first let's understand that what a heap is Heap is typically an extraction of a binary uh tree tree based data structure where it it maintains the property of a binary tree which means any single node has at most two children and it tries to balance out this property as quickly as possible and even if there is an anomaly it would only be at one of the positions where the number of children would be one but nothing more than that so you would never encounter a scenario where any single node has three children or something like that so after that there is also one more important property for a heap and that is that it is a common implementation for a typical priority Cube and we all know that in a priority Cube the most important thing is higher or lower priority depending on that so in the Heap usually we use it to keep track of uh the maximum value out of any given incoming data stream or the minimum value of uh any incoming data stream and both have very significant purposes and very significant importance in many of the questions so first let's try to understand that how does a typical Heap looks like how does it work and then we will see some examples so first we will try to implement a minimum Heap now the property of a minimum he Heap is that number one it is going to maintain the binary tree nature so one node is going to have at most two children number two is that every single parent is going to have less value than its child and number three property is that all the nodes that we would try to enter first we would enter in the root position if the root is already filled we would try to enter that node into the leftmost position if that is also filled then we would try to enter that node as a right child for any particular empty location so we would try to find the location first once that is done we would sort of heapify the given input or the our given Heap to maintain this property so let's see this in action suppose uh currently we have an empty Heap so let me draw an empty circle and now let's assume that the first value we are trying to enter is going to be value number five so initially we are entering value number five over here now the next value we try to enter let's assume that that is value number 10 so remember the scenario is first we will try to add it to the root value root we already have added which means we will try to add in the left children so let's add the number 10 in the left child and after adding that we need to check that whether this property has been maintained or not that whether the parents value is less than the children value or not and in this case since five is the parent it is less than 10 so this is currently correct so we do not need to do he operation for this step now let's see one more element so suppose we try to enter value number 15 now again 15 needs to go to uh either root place but root is already filled so it needs to go to left that is also filled so it will go to the right place and right place after adding 15 we would again check that whether the he5 property is maintained so again parents is still smaller than children so that is good now let's try to enter the value number 25 so once again 25 will go go to the left position and so far everything seems to be working okay no issues with this now let's try to enter the value number seven now again by this logic first of all seven has to enter to the right available position so this is not available this is not available but this position is available so let me enter seven over here but does there an issue with parents being lesser than child yes there is in this case seven is smaller than uh value number 10 so we would have to do the he5 operation so we would move seven from here and we would make it as parent and 10 would come to this place okay now everything is good so far now let's say that we try to enter value number 31 once again 31 would be entered over here and the property is still maintained now let's try to enter value number two so by default value number two is going to come over here but since two is smaller we will have to make a shift over here so let me quickly shift the values so now 2 is going to come and 15 is going to come over here once again two is still smaller so once again we will have to do a shifting operation so in the end two is going to come over here and five is going to come over here and now the Heap has been maintained so this is how typical Heap operates now in this case if you see always the parent is going to be smaller than its children so currently for the entire Heap we have the smallest value POS positioned at the root position so this is whenever if we have to identify that hey we have an incoming constant data stream that is coming in and we want to find that what is the minimum value at all times we can actually use Heap because it's a self adjusting uh algorithm or data structure that maintains its property of whether a Min Heap or Max Heap so in this case we can identify that okay the minimum value is going to be the value at our very first node and maximum value is going to be some value amongst the these Leaf node so in this case maximum is going to be 31 but we are not bothered about it right now now once again if we take any subtree so let's say in this case once again parent is still going to be smaller than child once again parent is still going to be smaller than children so Heap is a great algorithm whenever you need to keep track of that hey I have an continuous incoming stream of data coming in and I want to check the fifth smallest value from the beginning so in that that case Heap would be an ideal choice where you keep track of all the values in a Min Heap and then you essentially needs to go and select the fifth smallest value which can be done in log and time so that's great you will get the answers quite quickly now let's see an example for a Max Heap and Max Heap also works in the similar fashion the only difference is that now the value of parent has to be greater than the value of child so let's see that first we are try we have the element and we are trying to add value number two over here now the next element we are trying to add is value number three so in this case we will have to do an adjustment so first we will add three over here and then we will do our HEI so we would adjust the values so now three would be the maximum value and two would be the smallest value now we are trying to add value number 15 once again first we will add 15 over here but then again we will do the hepy principle and we will flip the values so 15 will become over here and three will come over here now we want to add value number five so by default five would be added over here but once again we are going to do over ep5 operation so according to that logic five will come over here and two will come over here and same way we can maintain a Max Heap as well so in this case whenever you would see the root node is going to be the maximum element at any given location for any particular subtree the parent is always going to be greater than child and Heap is going to Bubble Up and maintain its Max Heap property so this is how typically we use Heap in order to keep track of min minimum value or maximum value at any given moment on top of that we also keep track to for any questions like find the K largest value or k smallest value from the top so in either case the Min Heap and Max Heap or are going to be the ideal choice to solve these kind of problems and we would see bunch of operations later on in the course so now let's try to see that what are going to be the time and space complexity so ially the time complexity in order to insert any element inside the Heap is actually big go of logarithmic n why log n because it is already a sorted tree structure whenever we try to enter any value in any particular location we simply need to find that what would be the right place for it to be so at most all we need to do is make change to couple of places and then we can actually find its correct location so insert insertion is login same way deletion is also login same way finding anything is also login so this is a very powerful and very fast data structure uh from many point of you and that is why it has lot of use cases in the real world scenarios so this is the example of Heap now let's try to understand that what does a TR data structure looks like now try is also uh an additional abbreviation of a tree based data structure now inside the try uh we actually use try on a daily basis so whenever you see any system that uses autocorrect functionality so that is actually using a try so this covers your iPhone Android phone your messaging app anything plus wherever you see predictive searches so what do I mean by predictive search uh you can imagine that whenever you try to search anything on the Google or Amazon it automatically completes the statement for you and for that actually behind the scenes it is using try as a data structure so try is a very powerful tool since you can see that it has lot of practical applications and also remains favorite amongst technical interviews as well so that is why we are going to understand what a try is basically try typically operates on a string based characters so wherever you have bunch of different characters that you that you working with and you want to store them in a sequential manner where depending on the values you enter in the character You can predict the next element you can actually use a try so how does a try typically work is typically it has a root node and this root node tends to be an empty node but in its children we are going to store all the uh alphabets that are possible so typically in a real life try there would be 26 children one for each character from a to zed but in this case let's just let's just consider our example small and concise so we would try to add five different words to our try and we would see how they they would look look like so first word we are going to add is going to be the word rat second word is going to be R third word is going to be uh men and fourth word we would be uh let's say tree and fifth word would be uh try so these are the words we are trying to add first so let's just start with first one so first we will try to add R so we are going to create a child over here called r then the next word is a so again R is going to have a sub child called a and next word is t so T is going to going to be the child of a and now since this word has ended so now this is going to be an end node so we can determine this as a star or something okay that defines that this word currently ended over here now next word we are trying to add is R so once again from our root node we are not creating we are not going to create a separate child for R we are actually going to create a r as it as it is and then we are going to create a sub Branch so this R has already been taken care of now there is the word a so once again for a we are not going to create a new Branch but we are going to treat this R A to be of the same group so now you can see that how different words can be stored within a tree like data structure by their character properties because they are all connected with each other very deeply and next one is p but over here the next word is actually T so in this case we are going to create a new Branch over here and this new branch is going to have value number P and since the word ends over here we are going to have an ending node so that is denoted by star so now whenever I start typing r a uh the system would come over here and then system would predict that either I'm typing r a rep or r a rat and then that is how it is able to do a predictive search let's say that I print uh I type something like r a r rare but the system knows that rare is not a valid word which means system would predict that either the valid word has to be r or R so depending on the con uh context of the entire statement you are trying to make it will automatically adjust the word that you are writing and over here it would from this it might autoc correct it to the word rat and uh things would work fine so this is how typically autocorrect functionality works now let's try to add the word man over here now for M there is no child so we are going to create a new child and once again we are going to create a new child and we are going to create a new child and then we are going to create an end node so this is how men would look like now let's try to create the word tree so once again for tree uh we do not have any child so let's create a new branch and we are going to start with word t now next one is r and next one is e and next one is going to be e and then there is an end node but now let's try to add one more word try t r i e so we can already see for T and R it is going to have the same path or same Branch but now it is going to have a separate branch called I and then it is going to have a separate branch called e and then it would end the word essentially so this is how using just these three branches we can actually navigate all of these five uh words so this is the true power of the TR data structure and uh try is pretty popular in lot of technical interviews and wherever you see the example where you are given bunch of different words and you are trying to find some meaning and you are trying to find the best way on how to process them and how to store them try to consider or thinking of using the the data structure try and once again for try later in the course we are going to see an example so things would become much more more clear so I hope that you got the idea about Advanced data structures of Max Heap Min Heap and tribe and now let's move forward so first of all I would like to congratulate all of you for making up until this far uh we have cross the biggest hurdle in our technical interview preparation journey and that is learning about all the popular data structures I hope that you must have good enough understanding of each one of them and now we are going to shift our Focus towards algorithms which is not so complicated as data structures were but needless to say they are quite important so I hope you give your utmost attention to this portion because once you understand algorithms things will become much more easier for you to proceed for the subsequent parts now one of the most important thing that you have to master in order to master any technical interview is to understand that what are the different algorithms available to you and what are typical coding patterns that you need to to recognize but before we start diving deep into it first let's understand that what does algorithm mean algorithm is nothing but a simple set of procedure a computer or a program needs to follow in order to generate some solution so let's say that this is the problem statement given you need to follow a certain steps in a certain sequence in order to generate the results and there are many different techniques to that that we will tackle in this uh portion so following that would generate the unnecessary output that you looking for and understanding that what are the options available to you is going to be a significant key for your Tech preparation Journey now what is coding patterns let me give you an example suppose if I write down uh few words over here let's say 2 4 6 can you predict what is going to be the next alphabet or next character I'm going to write over here of course you can predict that I'm going to write eight why because by looking at this you understood that this makes the next logic sequential sound move and this is what we need to do in terms of technical interviews as well that depending on the problem statement we should get some idea that hey in this type of scenario it would make sense to use a data structure like an array and in the array we are going to apply maybe sorting and then with the Sorting we are maybe going to apply uh binary search and this would yield us the correct result but we need to understand this type of pattern and this can only be done if we examine many questions of a similar type and then understand or refer meaning to that so combination of algorithms and coding patterns are closely related with each other and you do that in tandem with data structures and that's it these are the three building blocks for any efficient data structure algorithm technical interview and uh we are going to take care of it so these are all the different techniques that we are going to cover so first of all we are going to cover the searching algorithm and sorting algorithm then one of my favorite topics that is dynamic programming and recursion so after that we are going to see bunch of different tree and graph algorithms and these are really popular because there are some very practical real life applications completely built upon the concepts of tree and graph algorithms then we we will see some greedy algorithms and backtracking techniques and in the end we would start talking about the divide and conquer sliding window two pointers and interval coding patterns so this would cover most of the topics that you can think of for any technical interview and once you understand this you would essentially able to master all the problems that you are facing so without any further Ado let's just get started and uh for each and every concept I will explain the concept first then I'll show you either one or two examples depending on how complex the problem is and we will solve that problem before moving forward to the next one so completing this would be one of the most important key factors for this uh course so first let's try to understand the searching algorithm Now searching algorithms are pretty common across data structure and algorithm related problems because at any given moment we need to find some elements from a variety of data structures and these data structures can be an array or something like a St or a CU and it on top of it there can be some other more complicated data structures uh maybe something like a hash or a tree or a graph so essentially for any given data structure you might be asked to search some data from that and typically we follow two main techniques so number one technique is a linear search and linear search is uh as the name suggest it's quite simple essentially you jump from one node to another node to another node until you find the element that you are looking for and the moment you find the element you simply return that search element so if we have to understand it with an example suppose we are given an array and inside our array the values are randomly jumbled up something like 4 3 1 7 and 8 now I ask you that hey go ahead and search for Value number eight the approach is going to be that we are going to jump through all of these values until we reach to Value number eight and the moment we reach we can say that okay this eight is located at index number number four or on the fifth position or we can simply say that yes eight is present currently in this array in either case linear search would work just fine and if we see time complexity for a linear search it's typically going to be biger of n usually whenever you are dealing with data structures like link list or even Q or stack typically you are going to deal on the linear search basis because that is the only way you can access data uh and if there are some additional versions of maybe Q something like a Min Heap or Max Heap in that case you can actually find the value you are looking for in little bit simpler manner but still essentially linear search you are always going to encounter uh in whatever you are trying to do next example uh for a searching is actually a binary search and binary search is quite powerful but it has some predefined condition associated with that and that condition is that whenever you are trying to use a binary search the condition is that the data set has to be sorted so it needs to be either a sorted array or let's say a binary search tree something like that where you can actually apply the concept or the principle of binary search and principle is actually quite simple say for an example we are given bunch of different elements over here uh and they are all sorted in a particular fashion so 1 3 11 15 19 and 27 these are the values we are currently present let me just add one more element somewhere so value number four okay so currently we are given Seven Elements inside this array now I ask you that for this array can you go ahead and find me value number 15 what would be your approach well of course you always have the option to go linearly and search for each and every value individually till you find the value you are looking for but since this is already a sorted property it makes sense to use the binary search approach where first we are going to find the middle element the middle element in this case is going to be value number 11 now we know that since this array is sorted we are guaranteed that if 15 exist it has to exist within this portion and there it it is not possible that it lies within these values so we can essentially get rid of all of these inputs and only focus our effort for this remaining portion now once again for this remaining portion again we will try to find the middle pointer and middle pointer in this case is going to be 19 which means once again again we can eliminate these two values because all the values are going to be either 19 or greater than 19 and in either case it is not going to be 15 so we are only left with one element in this case and that is value number 15 we which we can return so only in three itations we were able to find the our answer we are looking for in an array of uh seven total elements basically the binary search actually operates in bigo of log n time and this logarithmic time complexity is what makes it viable so this is what how you can understand searching algorithm and you are going to see them quite a lot in lot of different problems you are trying to solve now before we start understanding the example for searching algorithm let's try to understand sorting first and then combination of searching and sorting would would be what we would use to understand one of the actual data structure and algorithm Rel related examples so let's try to understand sorting first now sorting as the name suggest uh it is the procedure to sort all the given data in some particular fashion it could be whether all the data you are trying to sort in an increasing order or reverse could be true that you are trying to sort everything in the decreasing order or you are trying to sort everything based on the colors that you are provided or the names or alphabets in either case you are trying to bring an ordered list and sorting can apply to most of the data uh most of the data structures like arrays and uh link list and trees and graphs but mostly you are going to typically use it on the arrays that's what I have observed by solving bunch of different problems so even to understand the Sorting let's try to see some examples from array suppose we are given an unsorted array and the values currently are 2 3 1 7 and 8 okay now in this unsorted array if we trying to sort it how can we do it well actually sort there are multiple techniques we can use in order to sort the data and one of the in inefficient approach is actually something called bubble sort now bubble sort is typically where you compare any two elements and try to see that whether those two elements are in correct order or not and if they're not you swap those two elements and then go to the next element and you keep on repeating this process until all the elements are sorted so so if we have to see that in example we can see something like this where we okay we check two and three they are already in the correct order so we will leave them for now then we will compare 3 to 1 So currently 3 1 is not in correct order so we will bring one over here and three over here and leave 7 and 8 as it is now once again we would compare these two elements So currently one and two are not in correct order so we will add one over here two over here three over here and then seven and 8 once again we would repeat the same procedure so one and two are correct order two and three are correct order and three and seven are Cor in correct order and same same goes for seven and 8 so in this case all the elements are now in correct order which means we can return this as sorted array and uh we use the bubble sort method but the issue with the bubble sort method is that it takes big of n Square time because it could be possible that for every single element you need to keep on uh Shifting the places and that could be pretty bad so one better approach is actually something called uh M sort or there is also a quick sort so let me give you the better faster sorting approach once again let's assume that we are given some random array and we are trying to sort this now we only have four elements so a better approach is that we actually create an entirely new array and currently this new array is blank so what we would do is we would add all the values in the sorted Manner and whenever we have to identify that where any new value should go we would use binary search in order to find the correct location for that place to be entered and we all know that binary search operates in log and time so essentially our code should run in N log and time why because we will have to do the log and operation for every single element that is currently present inside our given input array So currently let's try to see for Value number one so currently this is empty so we will add one just anywhere now five for five we can we need to check that where five needs to added and five is greater than one so it has to be added on the right side of one so we will add five over here once again for Value number two uh let's see where it needs to be added now since 2 is greater than 1 it needs to be added on the right side of one but it needs to be added on the left side of five and this we can calculate quite easily using binary search that which should be the correct position for two to be entered so in this case we can enter two over here and then five we can shift on one position to the right and this whole operation would take logarithmic of end time once again for Value number eight we will repeat the same procedure and we can find that uh the ideal place for eight is going to be here on the very end and in the end we would get our sorted array now this sorted portion looks quite good and we were able to achieve this whole thing in N log n time which is quite nice so whenever you are trying to deal with uh any operations try to see that can you use searching and sorting to solve this problem and combination of these two would ultimately yield you better results because if you can do any operation on an unsorted array for bigo of n Square time then same operation can be done using n log and time uh if you just simply sort this that given input array so that is a huge Advantage now let's try to see one real example from a problems uh with from the lead code okay so now let's try to understand this problem that is how many numbers are smaller than the current number the problem is really easy to understand uh we are given an input array and we need to create another array where for every single position inside the original array we need to determine that how many number of elements are smaller than that particular value so in this case for four we can see that there are actually two elements that are smaller than four so in the answer we are going to mark two same way for three there is only one element that is smaller than three so we are going to mark one for five there are actually three elements smaller than five so we are going to mark three as the answer and zero is the smallest element so in this case we can Mark there are zero elements that are smaller than zero and this would be the answer we need to return now this is actually quite simple to understand let's see that what would be the Brute Force approach to solve this problem well in The Brute Force approach the most simplest thing we can do is that rather than uh doing anything else we can simply start checking one element one by one so we first make a pair from four to three and we check okay that this is smaller so we increment the value by one once again we make a pair of four to five We compare these two value since five is bigger we don't do anything then we check one more time and then since 0 is less than four so once again we add one more increment and the answer we store in the answer that for zero there are two elements that are smaller than that and we keep on repeating the same process so this Pro Force approach would yield as the solution in bigo of n Square time because for every single n element we are doing n minus one work so this is not really good so let's try to see that what should be the better approach and one of a very easy approaches that actually if we take the same input as it is but we if we sort that input then the answer is going to become quite easy so the answer is 4 3 5 and 0 now in this case we need to return that how many many number are smaller than that so first let's see that what does a sorted array looks like and in this case it's going to be0 3 4 and 5 now at any given position in the sorted array defines that how many values are actually smaller than that so in the case of zero there are actually zero values smaller than that same way for the case of three there is one value smaller than that and that value is zero for four there are two values smaller than that and that is two and for five all three values are zero so we can use this property to calculate that uh or to generate this array but how we need to do that uh we actually need to know the index location for all of these and then Mark appropriate value so for four we need to enter answer two but we there is one simple way to do it that is that uh for four we first iterate over this given sorted are and find the value and then again repeat the same work but that would be an additional overhead a better approach is to use a hashmap here so after we generate the sorted array we can put all of its values as keys and all the index positions as values inside the hashmap and then uh we can use that property to to populate our answer quite easily so in this case 0 is going to have zero value three as key is going to have value number one four S key is going to have value number two and five s key is going to value number three now all we need to do is from our example array let me get rid of this for now and now all we need to do is from our example array we will first iterate over this value number four try to see that which is the value associated with this value number four create an answer array and in the answer array just Mark that value same way for Value number three again check in the hash map and the associated value is value number one again for five Associated value is value number three and for 0 Associated value is zero and this would give us the correct answer we are looking for in the simplest manner so now let's see that what is going to be the time and space complexity in this case the time complexity is going to be big of n log n in order to generate the sorted algorithm or sorted array plus we have to do big of n work in order to generate this answer from this example by comparing this hashmap so that is pretty good so overall time complexity is going to be big of n log n now let's see that what is going to be the space complexity well of course since we are using an additional hashmap the space complexity is going to be bigger of n but that is still reasonable because we are saving uh quite some computation in the time complexity so now you must understand that how we are actually using sorting and then we are using searching plus we are using the capabilities of hashmap and everything is connected with arrays in order to generate one answer and this is is how typically data structure and algorithm related videos or uh problems are done so now let's see the coding solution okay so let's see that what is going to be the Java solution for this problem basically we are given an integer array called nums so first thing we are going to do is we are going to create another array and we are going to uh sort it so this is the sorted array and now we are going to create a hash map uh where inside this hash map we are going to Mark the indexes values for all the elements that we have in the sorted array so it becomes really easy for us to navigate and generate the results for our original array then all we need to do is initialize another array where we are going to store the results plus we are going to run a for loop on the original input array and we are going to uh check that what is the result from the hashmap for that particular uh key value and uh we populate the values inside our result array and we get the answer let's try to run this code and our code runs pretty efficiently so let's submit this code and our code runs actually very fast compared to lot of other Solutions so this how you can understand what are the powers of sorting storing and hashing and combine combining lot of data structures and to generate a solution now we will try to understand a very important topic that is called recursion recursion is highly used in many of the data structure and algorithm related problems plus there are many algorithms and many programming techniques that are heavily dependent on recursion to solve the problem so recursion is actually a method that we can typically use uh in order to complete any set of task where we usually see some sort of repeative work that needs to be done for a various set of uh different inputs and essentially we need to collect the results of the them to generate an answer now let me explain you recursion by a real life scenario first and then we will talk about what it is it and how do we actually use it in our typical technical interviews say for an example you are currently standing on a line and you don't know that how many number of people are currently in front of you so all you can see is that there are bunch of different people ahead of you but you have no idea and currently this is the person who is the very first person in the line now you decide that you want to check that what is your position inside the current line so the one approach is that you get out of the line and then you start counting all the people that are in between and then you try to come back to the line but there are more people behind you so if you get out you will essentially lose your place so there is one more way when you can identify that what is your current position that is that first you ask the person ahead of you that hey what is your position now again the person ahead of you also has no idea so he repeats the same position that hey what is your position and this question keeps going on and on and on until we reach to the very first person and because this very first person already knows what is his or her position is this person would say that hey my position is one which means this person would understand that his position has to be second second position so then he would respond back to the person behind him and this person would understand that his position is now the third position same with this person will conclude that his position must be fourth position because this person is at third position and same with this person is at fifth position and he tells you that hey I am on the fifth position which means you can conclude that your position has to be the sixth position in the current line now what you essentially did is you made a recursive call and you get the desired answer you were looking for and you ask the same question to a different set of input results until you f reached to a place who knew the answer and depending on that answer you started building all the other answers and that's it that's the recursion now I know at first it seems complicated to comprehend but if you try to understand with real life examples things would become much more easier let me give you one analogy that how it typically appears have you ever seen those Russian dolls that uh whenever you open one doll and then uh inside that doll there is another doll hanging and inside that there is another doll and it keeps on happening over and over for all the different shapes of dolls so the same concept applies for the recursion as well that behind any big problem or behind solution of any big problem lies the solution of a smaller problem plus plus some computation same way for even for that smaller problem there lies some other computation and same goes on and on until we reach to a base case where in the base case we directly know that what is going to be the solution for that particular case and apart from that from that we would build this solution and then we would build the other solution and we would keep on repeating the process again and again and again let's try to see that what are the things or areas of concern for us in any particular recurs so every single recursion has two items first item is that uh recursive function and this recursive the purpose of this recursive function is to call the next sequence or next input in line in order to get the answer so first one is a recursive function and second one is a base case so base case is a scenario where we know that this has to be the answer or this has to be the minimum answer now uh again going back to to our uh people standing in a q position the person standing very at the very first po position in the line knew that he was the first person in the line and this was basically our base case now our what was our recursive function in this case in our recursive function the case was to ask the next person that hey what is your position and keep on asking that to the next person and the moment we get an answer from the base case we need to return to the previous person that hey whatever the answer we get from the next element or the base case we need to add one to that so here base case would say that hey I'm first person so this person would say back to the back to his previous person so person who called originally this person he would respond back saying that hey I second I'm in second position same way this person would say I'm third position and so on and so forth the recursive call would keep on coming back until we reached to a point who originally called or initiated that recursive call recursions are very powerful and they are used in bunch of different data structures in many programming techniques data structures such as uh typical tree or graphs plus programming techniques like dynamic programming and also many of the Matrix manipulation all of this are heavily using recursion to solve their uh problem because typically in all of these problems we need to do the same computation again and again for different set of inputs and whenever we see things like that we have to try to see that can we solve this problem using recursion now there is also one more thing that you need to understand that any problem you can solve recursively you can also say solve the same problem iterative iteratively but the question is recursive solution is going to be typically very simple to implement so you can think of it like a simple manner just like asking a question again going back to our people standing in the line scenario you could have gone out of the line and calculated all of these values one by one by yourself but why did you decide it not to do and you just decided to ask to the next person because repetitively you can ask this question again and again and you can expect to get an answer coming back in return so that is how if you would have gone out and calculated all of this by yourself it would have been an iterative approach and if you would have stood in the line and waited for the result come back to you it would be recursive approach but there is a key difference between iterative and recursive that in the iterative approach memory is not being used that much why because in this case you are the only person calculating that how many number of people are there currently present in the line and then they can you can infer the result that you're looking for but in our recursive approach we are dependent on every single person to know that what is the position of other person and then adding one line to it and sending back the results which means we are actually creating a memory stack where we are keeping track of all the memories that actually called us back so all the places where we called we are placing their uh line in the stack and when we get the result we fetch these values out one by one because remember the property of a stack is last and first out so we get these values out and then we in the end conclude the answer so whenever you're dealing with recursion make sure that uh memory usage is not so significant that you actually end up in uh stack Overflow issue now let's try to understand a program programming uh example for recursion and that is something called a Fibonacci series now we all know what a Fibonacci series is Fibonacci series is basically the sum of two numbers now let me give an example initially so let's say that first value of Fibonacci series is Fibonacci of zero so that is going to be the value number zero second is Fibonacci of 1 Fibonacci of one is going to be value number one now if we have to calculate Fibonacci of 2 we will actually have to do the sum of these two values and that will give us the answer of fibon 2 so Fibonacci of 2 is actually Fibonacci of 0 plus Fibonacci of 1 so the answer is going to be 1 once again Fibonacci of 3 is actually the sum of previous two elements so Fibonacci of 2 plus fibon Fibonacci of 1 so the answer answer is once again going to be value number two same way Fibonacci of 4 is sum of previous two elements so Fibonacci of 3 plus Fibonacci of 2 and the answer is going to be value number three and this keeps on going on and on until whatever the value we are trying to find we get the answer so now in this case this is a very good candidate if you want to implement the solution recursively and how would the recursive function would work well we know that for recursion we need two things we need our base case and base case is lying right in front of our eyes that is that uh the Fibonacci of 0o is zero and Fibonacci of 1 is 1 now we need a recursive function and recursive function is also in place that fibon of any number is actually Fibonacci of number minus one plus Fibonacci of number minus 2 and you can apply it to anywhere so Fibonacci of 2 is going to be Fibonacci of Z or Fibonacci of 1 same way Fibonacci of 3 is going to be sum of Fibonacci of 2 and ion of 1 so this function applies which means we got our recursive function and we also got our base case so now to calculate any result is going to be very easy for us okay so let's say that I'm trying to find the Fibonacci numbers and I try to find the Fibonacci number of Fibonacci value number four so first let's see that what is going to be the recursive approach well first of all in the recursive approach we know that what is the recursive function for Fibonacci of 4 recursive function is Fibonacci of 3 plus Fibonacci of 2 now we all know that what is the answer for Fibonacci of 3 that is Fibonacci of 2 plus Fibonacci of 1 now we know the value of Fibonacci of 1 but we do not know the value of Fibonacci of 2 so once again even in order to get this value we are going to do Fibonacci of 1 plus Fibonacci of 0 and we know these two values so sum of these two values is going to be 1 + 0 so the value is going to be 1 so this is going to return us the answer as one so we get the value of one so in this case currently the Fibonacci of 2 is going to be of value number one and Fibonacci of 1 is already value number one so 1 + 1 is going to yield us the result of three now we got the answer three in this case now for Fibonacci of two we again need to do the same computation and that is Fibonacci of 1 plus Fibonacci of 0o now we don't know we already know the values of fibon 1 and Fibonacci of zero and that is going to be some is equal to 1 so this is also going to be one so in this case currently the value of Fibonacci of three is going to be okay this is not going to be three this is going to be two I think I Mis wrote this this is going to be two so Fibonacci of three is going to be two and Fibonacci of 2 is going to be 1 so the answer for Fibonacci of 4 is going to be three okay so we got the recursive answer now you see what you did what we did in this case we took the larger case and then we started breaking down into the smaller pieces and even for those smaller pieces we started breaking down into sub smaller pieces until we reach to a point where we are at the base case and through the base case we found the solution we return those solution to our previous calls and then we kept on repeating the process until we find to the main value we were looking for now what are the things we had to take care of we had to take care of base case we had to take care of the recursive function and we had to take care of the memory call back because this function is calling back to Fibonacci of 2 this function is calling back to Fibonacci of 3 same way this function is calling back to Fibonacci of 2 and we are getting the answer but at least as long as we are getting the answer now for the same problem let's try to do it iteratively so in the iteratively we are trying to find Fibonacci of 4 so obviously The Logical approaches that we are going to start with Fibonacci of 0 and Fibonacci of 0 is already Zer Fibonacci of 1 is already 1 now we are going to calculate Fibonacci of 2 that is going to be sum of 0 + 1 so that is going to be 1 okay so this Fibonacci of 3 is going to be value two and then we can calculate Fibonacci of four that is going to be value three and we will also get the same answer now in this case in the iterative approach we started from the bottom and reach all the way to the value we were looking for in the recursive approach we started from the value we were looking for started asking and went to the base case and then came back again for the previous case so this is one common way to implement recursion now you are going to see quite a lot of examples whenever you are trying to prepare for any technical interviews because recursion are one of the most commonly widely used programming techniques now we are going to learn the most important topic inside the Entire Computer Science in my opinion and specifically for the technical interviews because if you are applying for any Tech interview for sure you are going to be asked some questions related to dynamic programming so let's first understand that what dynamic programming is what are the different variations associated with that and then we are going to explore bunch of different examples so you can get the complete idea on how dynamic programming Works basically dynamic programming is nothing but the art of saving the data that we have already computed and then reuse that data for some future computation that's it uh now let's try to understand this with an example suppose we have a map like this where we are given bunch of different places or points and we we we are trying to go from one city to another city now in this case currently we have all of these variations and we are trying to get to a city number F now uh each of this path we can assume that they are let's say 1 km long on top of this from a we have some path directly leading to seat that is also 1 km long and from C we have one path that that is directly leading to e and that is also 1 km long and now the aim is to get to City number f Now The Logical conclusion is that most common bro Force approach would be that we start from City number a and we explore every single path and for each of the path we calculated that how much kilometers or how many kilometers did it took so we would first calculate a result for a path like this then we would calculate a result for a path like this this this and this and then in the end we would calculate the result for a path like this and we would find the answer but the question is uh is this the most approp rate approach to reach over here because we are repeating so many competitions here we already calculated for this portion and this portion and we are actually calculating it two times uh in order to generate the result one better approach is that we actually use dynamic programming to store the already calculated path and how we are going to do it typically in dynamic programming there are two approaches first approach is a bottom up approach where you start from the base case or the very first case and try to build a solution that would eventually lead us to the final result we are trying to get to so that is one way second approach is a top down approach where in the top down approach you start at the very end or at the very top and then you build smaller and smaller Solutions and try to come up or try to reach to the first point and then try to build a path in this manner now of course both of this are going to look quite similar uh compared in regards to the previous example we C for recursion because the top down approach is actually used by done by doing recurs recursive calculation and bottom up approach is typically done by using an iterative solution where we are storing the data of all the things calculated and that is a common factor we are going to store the result of already calculating calculated the data and we are going to use it for our next computation so let's try to see an example in this case the approach I am suggesting is that we start from F in this case and we try to go in the reverse order to find the best path suited path so the question is in order to get to the F what is the nearest point that leads us to Value number F and that is going to be value number e that say somehow if we get to Value number e we can reach to F in just 1 km so we can say that distance from E to F is going to be 1 one okay that's good now uh in order to get to e what are different options we have so first let's explore all of them so let's say that we are currently at position number D if we are at D we if we need to get to F we have this path where we are going to go from D to e and then e to F so in this case if you are if we are at D do we need to calculate this whole path from going to e and then again going from E to F no why because we already know that that once we get to e we can directly go to F with this effort so we are going to save our computation and we are only going to calculate that okay from D if I get to e using one e using one step then from E to F distance is already one so I can say that from d i if I take two jumps or if I go travel 2 kilm I can go to the value F that's awesome now once again let's repeat the same computation now we are at position position number c so from C how many options we have one option we have is that from C if we go to D we already know that from D to F is already 2 km so and from C to D it takes us 1 km so if we were to take this path from C to D then we don't care how many number of hops it has to take all we consider is that from C to D if we go there then within 3 km we would be able to reach to our final destination F so in this scenario we are not even going to bother checking for this path from E to F we are only consider the path between C to D and which is the true power of dynamic programming so now in this case we are actually we can say that from C if we take 3 km we would be able to get to D but at C we have one more option and that option is that if somehow we can go from C to e then at location e we can only travel 1 km and get to F so in this case now at C we have a path from C to D that takes us uh 3 km time and we have a path from C to e that takes us 2 km time and we are trying to find the minimum uh time it takes or minimum travel it takes to get to e so we can see that at C if we somehow end up at position number c then we can actually reach to F within 2 km so we are going to Mark the value of C S2 and then we are going to repeat the same process so now from B if we somehow end up at C we would be able to get to F within 2 km and from B to C it takes 1 km to get there so we can see that at B it takes 3 km to get to F same way from a if we go to B it takes us 3 km plus 1 km so 4 km to get there but if we from a go to C then it only takes 3 km so we can say that the minimum amount of time it takes from us to go from a to F would be 3 km and this is how we build the solution by already calculating the previously computed results and in this case we actually use a top down approach where we started from the top and we kept going in the reverse order and we can actually have a recursive function call to find the solution in the recursive function the base case is going to be that if we are located at position number e it only takes us 1 km to get there and then uh the solution would be that we need to check that how can we get to that next location in the minimum amount of hop so that's pretty awesome actually now let's see some other examples on how would a dynamic programming would work now previous example we saw that how does a recursive function work for a Fibonacci numbers now once again we are going to use the same Fibonacci numbers but this time we are going to use dynamic programming to solve the problem so let's see that in action in the previously recursive operation we had the example that if we wanted to calculate the the result of Fibonacci number five then what we would do first we would calculate the number of four plus uh Fibonacci number three same way for four we would calculate the number phys Fibonacci of 3 plus Fibonacci of 2 and plus over here we would do Fibonacci of 2 plus Fibonacci of 1 same way over here we would do Fibonacci of 1 plus Fibonacci of 2 and here we would do Fibonacci of 1 plus Fibonacci of 0 in order to calculate this value and in this case we will do Fibonacci of 1 plus Fibonacci of 0 in order to calculate this Fibonacci of 2 and Fibonacci of 1 we already know the value as 1 because this is a base case now see how many times we are repeating the same computation over here we are calculating the value of Fibonacci of 1 plus fibon of 2 in order to generate the answer same computation we are doing here as well Plus here we are calculating Fibonacci of 1 plus Fibonacci of 0 same way we are doing it for Fibonacci of 1 and Fibonacci of 0 so in both the cases rather than doing all of this computation what we can do is we can actually create an array and inside the array we are going to store the results that we have already calculated now we know that for our base case it's fibon of Z so let me mark down the value 0 1 2 3 and four for all of this and let me make one node for five as well okay now we all know that the values for 0 is actually going to be 0er and 1 is going to be one these two values are already calculated now let's start Cal start let's start our recursive function so first we start with four four and three now in order to do that we need to calculate these two values now we need to calculate this two value so this would be the first case we would be able to calculate where we need to calculate the value for Fibonacci of 2 so we already know what is Fibonacci of 1 and Fibonacci of 0o and this is going to be value number one so we can do that that we can put Fibonacci of 2 as value number one okay now for Fibonacci of 2 we need to do Fibonacci of 2 plus Fibonacci of 1 that is going to give us the result for Fibonacci of 3 and that would be value number two okay now we are done with this portion and this whole computation now let's do computation for Fibonacci of 4 so in order to calculate Fibonacci of 4 we actually had to do all of these three calculations but in this case we don't have to do it why because at Fibonacci of 4 we need to get the answer of Fibonacci of 3 which we have already computed and Fibonacci of 2 which we have already computed as well so we can just say that this value is going to be three and based on that the value of Fibonacci of five is going to be some of these two values and we can just mark it as five so see how storing all of these values actually saved us lot of time and imagine that if we were not using dynamic programming so if we are not using dynamic programming then the time complexity would be big go of 2 to the power n because at every single position we are doing two more computation and same way for every single computation we are doing two more another computation so that is a very bad time complexity meanwhile in this approach we can actually complete this whole transaction and B go of uh and time only that we are only traversing and we are only doing the all the entire transformation just once and generating the result so that is pretty quick and pretty efficient approach and this I showed you the example of top down approach now let me show you the same for the same example bottom up approach now in the bottom up approach once again let me just draw an array with all the values I have currently calculated so 0 1 2 3 and 4 okay and uh the values are going to be 0 and 1 these are my base cases now I'm trying to calculate the value for Fibonacci of 2 so Fibonacci of 2 I can easy easily calculate using these two values as value number one and in the bottom up we are actually using the iterative solution so we are doing it iteratively okay now same way for the third value we can do some of these two value get the answer fourth value once again do the sum of these two values get the answer and same way for Fibonacci of five do the sum of these two values and get the answer as five and return this in the answer once again pretty awesomely and pretty simply we were able to solve the entire computation now you must be thinking that this is a very simple scenario for dynamic programming and yes this is a very simple scenario so let me give you a more complex task and that is actually uh that we need to calculate the number of coins problem okay so what does number of coins problem suggest is that we are given a value and let's say that this value is uh currently value number eight okay and we are given some coins so in this case let's assume that the coins we are currently given are 1 and two now we are told that we can use as many number of coins as we want in order to reach or build value number eight but the catch is that we need to use the minimum number of coins so in this case the answer is going to be if we use 4 * 2 Coins we would get the value eight so the minimum number of coins we need to use in this case is going to be four but how do we actually calculate this so for this let me show you a bottom up approach and same would be true for the top down approach as well so I'm just showing it to you from the bottom of approach let me just quickly draw an array where we are going going to store the value for all the items we are calculating and initially our case is going to be zero that if we want to generate zero value how do we do that so let's say and for at each position we are going to calculate the possibility that what if we use coin with value one uh what how many number of coins would we use if we have to use coin number two how many number of coins would we use okay so both scenarios we are using and uh let's mark all of these values so 0 1 2 2 3 4 5 6 uh 7 and 8 okay now for zero we know that we need to use zero coins so let's just mark this as zero now if we have to generate value number one uh how many number of coins do we need currently previous results we can't get much information from because it is uh for the zero value now we have two coins available to us the coin if we use coin number one we can create one within just one coin okay so that is one option and and second option is if we use coin number two but that we cannot use to generate value one so we have to use one coin in order to generate value one and that one coin is going to be the simple coin one that we use I'm just marking white color as the the coin we use now same way in order to generate two what are the options we have we already know that currently let's say this coin is one coin number one so now our aim is to generate value number two but if we use one coin number one then we can already know that if we do 2 1 so whatever value we have stored on top of that if we just add one more coin over here that is this coin number one we would be able to generate this value too you will understand what I'm trying to say but let me just write it down for now so in this case if I use two coins with value number one then I can generate the value two so two would be minimum number of coins we have calculated so far but we also have the option for coin number two so if we take for check for coin number two two is actually the exact value so if we just use one single coin of value two we can generate the amount two so in this case the minimum number of coins we need to generate is going to be value number one and the coin we are using is going to be value number two okay now let's say that we need to generate value number three now once again the number of option we have for the coins is going to be 1 and two so let's redo the same calculation again now if we use coin number one which means if we are let's say somehow we are at this previous position two and then we use coin number one we would be able to generate value number three quite easily that's a given fact and we already know that in order to generate value number two we only need to use one coin and that is the true power of dynamic programming that we are using the value we have already calculated over here so in this case if we use coin number one plus the dynamic programming value of coin number two and how did we arrive at this coin number two we did a subtraction from the current coin we are trying to calculate that is this coin number three minus the coin value we are currently using that is value number one so we can make a dynamic programming function that would be that dynamic programming of let's say this one is currently value number three is equal to going to be the so first condition we have is that we can actually use dynamic programming of three minus coin that currently we are using and in this case coin is 1 so we can say dynamic programming of 3 minus 1 and if we use that then we will also have to use the current coin we have and that coin only takes one value one coin only adds one coin to the previous coins so this would be one consideration and second consideration would be the next option with value number two but currently in both the cases the number of coins are going to be two so I'm just marking coins to be two and you have two options over here you can either pick coin as one and two or you can pick coins as two and one in either case you will be picking two coins in order to generate value number three and we don't care about what coins we pick we only care that what are the minimum number of coins we need to generate that value now we are at position number four okay now let's again apply the same logic to our dynamic programming function and let's see that what are the options we have so So currently we are considering value to be one so coin we are choosing is one okay if we and we are trying to calculate for dynamic programming for Value number 4 so first option is that we do 4 Min 1 so 4 1 is going to be dynamic programming of three dynamic programming of three is already know that the minimum value is 2 so that is going to be 2 + 1 so we have the option of choosing three coins in order to generate value number four but we have another option where we can use coin number two as well so let's try to do that so again the second option is that we do dynamic programming of 4 2 + 1 because we are using the the coin with value two so in this case uh we know that we need to generate dynamic programming of two so dynamic programming of two's result we have already stored and that is one so second comparison is that 2 + 1 so these are the two comparisons we have and we need to find the minimum value amongst both of this so this would lead us the value of d dynamic programming of four or the number of coins needed to generate value four so first option is three and second option is actually uh three as well sorry second option is actually two because the value of dynamic programming of two is actually one so in this case we are going to mark this as two so among these two of course two is smaller so we are going to mark two over here and the coins we took to generate is going to be 2 and two same way for for Value number five what are the options we have we can if we subtract one value so then uh if we use coin number one then we can generate this in three coins if we subtract or if we use coin number two then 5 3 is going to be 2 so 2 + 1 is also going to be three so we this three is going to remain constant here same way in order to generate value number six if we use coin number one then we can use 3 + 1 so one option we have is four second option is that we can come up up to Value number four and then use one coin to reach to six and the value over here is two so we have two options to choose from that is four and three so we can actually choose the value number uh three in this case okay cool now after calculating this at 7 we again have two options we can either use coin number one or coin number two in either case the answer is going to be four so we can mark four over here now at this position number eight we actually we can actually check that if we use one coin like coin with value 1 then we need to do dynamic programming of 7 + 1 so that gives us the result of five second option is if we use coin number two then we need to do dynamic programming of 2 + 1 so uh sorry not dynamic programming of two dynamic programming of 6+ 1 so in this case that is going to give us the result of four since we we are picking the minimum value we only need to pick the value S4 and that's it we got the answer that it takes 4 minutes minimum coins to generate value number eight if the given coins are uh 1 and two so you see how beautifully we we were able to solve this problem in just one single go because we were calculating all the results we have calculated so far and that is the true power of dynamic programming in my opinion so now let's try to do a really popular lead code problem that has been asked in tons tons of interviews many times and you can see how popular It Is by number of people who have liked this video so basically uh you are you are being asked to climb a staircase now you it takes end steps to reach to the top you are given the value of n now we have the option of either climbing one step at a time or climbing two steps at a time now in either case we need to calculate that how many distinct ways can we climb to the top now for this problem I'm going to show you both top down approach and also bottom of approach and in the code we will see the solution for the bottom of approach okay that Mak makes sense so first let's try to understand the problem with a few simple statements so let's say that if you are currently standing at stair number zero how many steps does it takes of course zero that's a given fact let's say now you currently have one steps available and you are currently standing at position zero and you need to get to step number one how many distinct ways can you get there of course one distinct way because you can only take one step let's take one more example uh currently the number of steps given are two and you are standing at step number zero now how many distinct ways can you get to to Value number two once again you have the option to taking one step over here and then one step over here so that is one way and second way is you can take two steps directly to get to Value number two so there are two distinct ways you can get to Top Just One Last example that is for Value number three okay that let's say that you want to get to the step number three you are at zero and you have the option of 1 2 and three so now how many distinct ways can you go first distinct way is just taking one step each time so this would be way number one second distinct way is that we take two steps directly and then take one step so this would be second step and third step is that we take one step and then we take two steps directly so there are three distinct ways to climb to the top uh for Value number three but now if you notice some interesting property the interesting property is we already know that if we have just one step we need to climb there are only one ways we can do it if we want to climb two steps there are at Max Two Steps we can do it the moment we wanted to calculate that how many times what are the distinct ways we can climb to the top we don't even have to calculate all the values why because in order to reach to three there are only two possibilities first possibility is that we start from value number two and then take one step so that would be one way and second POS possibility would be that we start from value number one and then take two steps basically this would be second possibility now you must be asking that hey what if we take one step to get here still it is still going to be counted towards this distinct step so all we care about is that how many different ways can we get to this value and how many different ways can we get to this value some of these two would allow us to find the next value in our path and this is the important property for dynamic programming that we need so let's try to understand this with an example that in this case for in order to climb to step number three we have two options that we can climb from one is from Step number two and one is from Step number one so if we do sum of these two we can get the value 1 + 2 is equal to 3 now let's try to understand the same logic for five steps okay and now for five steps I'm actually drawing it on an array uh and starting from value zero we will go to all the way to five and see that how each iteration how many changes it takes for us to to get to the value number five okay now in this case uh currently we are using the bottom up approach we are starting from the bottom and then we are going up so initially this takes zero steps this takes one step and this takes two step that's a that's a given fact now in order to climb to step number three we can either take one jump from here or we can take one jump directly from here so we are going to do some of these two so the answer is going to be three once again from 3 to 4 it only has two possibilities one step from here or two steps directly from here so once again we are going to do some of these two the answer is going to be five now in order to reach to step number five we only need to do the sum of these two values and that is eight and eight are the distinct ways we can reach to Value number five see how easy it became in if we if you were to do this in the Brute Force manner you would actually have to first create all the different decision trees you can make starting from position number zero so zero now you have uh two options you can either take one jump and go to position number one or you can take two jumps and go to position number two once again you have two more possibilities you can go to position number two or position number three you can once again have two more possibilities you can go to position number three or position number four and once again you have two more possibilities you can go to position number five or position number four or five and here position number five and the moment you reach to the five you can consider that to be an end of the path and just over here you see that these are this is just one path you can take in order to reach to Val number five then this would be a second path this would be third path and so on and so forth if you keep on going on you would be able to find eight distinct paths and if you were to do it in the Brute Force manner without using the dynamic programming the time complexity would have been 2 to the power of n because at every single position we have two different options to choose from and this is a disastrous result so that is why you using dynamic programming was great now you understood that how we use bottom of approach let me show you the result for the top down approach as well where we are going to start from the very top element and we are going to come our way down to the very last element okay so currently the values are 5 4 3 2 1 and zero now we know that if we are at step number five how many distinct ways to get there of course zero because we are already at set step number five we don't have to calculate anything if we are at step number four there is only one distinct way to get to step number five so we are going to mark this as one if we are at step number three there are actually two ways to get to step number five we can take one step over here and then one step over here or we can take one step directly over here so in this case there are two options from now on we can apply the same logic in the reverse order because from Step number two we only have two options that we can choose from we can either go directly to step number three that would be one distinct way and second distinct way would be we can directly go to step number four from there on we already know that how many different ways it takes to get to step number five so we can just use that property so basically from Step number two we can go to three distinct ways and that came from some of these two values same way from value number one we can actually go to five distin distinct Ways by taking the sum of these two values because these are the only two possible jumps we can make and from value number zero we again have eight different ways that we can make this jump and this is our top down approach so see in both the sessions we got the correct answer we used dynamic programming to calculate the already calculated result and then we were able to come up with the appropriate and successful result in the end so now let's see the code for this and I hope you understood what dynamic Pro dynamic programming is and what are its key fundamental reasons so this is the problem statement and here is the Java code for that uh basically we are using bottom up op approach so first we are checking for the edge case that if the given n is equal to 1 we can simply return one if that is not the case we are going to initialize our dynamic programming array and we are going to check out or put down the base case values for uh number of stairs as one and number of stairs as two after that we are going to run a for Loop starting from the step number three all the way to the end and we are going to apply our dynamic programming logic which is quite simple to understand in the end we are simply going to return the dynamic programming value be found at the very end value now let's try to run this code okay seems like our solution is working let's submit this code and our code runs 100% faster than all the other Solutions which is pretty good to see and uh now you can understand that how simple it is to code the dynamic programming solution okay so now let's learn the sliding window technique this is a really popular coding technique and typically works really well with many of the array and string kind of problems now first let's try to understand that what does a sliding window technique means let me give you an example suppose I tell you that you have this rope and currently this rope the entire rope is actually in the color blue now I ask you that I want to change this color from Blue to Pink so how would you do that well you actually have a couple of options to do it number one and most naive approaches that you actually put down a table now on top of this table table you lay down your blue colored uh uh rope and then you start pouring on the pink color all across the table and then eventually entire table is now dripping up with p pink color and some of that paint has already stuck onto the Rope as well and now our rope is actually pink colored so this approach will give you the correct rope color that you want but in this process you would have wasted lot of paint as well so that is not a very good approach a better solution might be that suppose you are given this rope uh I ask you that hey paint this uh in the pink color you take a paint brush and now in this paint brush you apply the color pink for this portion and after applying whatever the current width of the paint brushes you take that width and try to paint that much area pink for now and once that is done you again take your paintbrush replenish it with the pink color and again repeat the same process for for the next set of uh remaining uh rope as well and eventually you would cover all the ground and eventually the whole rope would have been painted blue or sorry pink and that is the most simple example of what a sliding window is where in the longest input we had which was our rope we actually created a small subset of window that we applied on one particular portion of given in input once it achieved our con conclusion or the thing we wanted to compute then we took the same thing to the next area and then we took the same thing to the next area until we reach to the very end and we find the appropriate answer that we were looking for so this can be a very powerful tool in many examples and let's try to understand that with a simple example suppose we are given an input array a where we are given some arbitrary random values okay let's just Mark these values is 1 3 7 uh 2 5 8 and 9 okay these are the values we are currently given now I ask you that find me the maximum sum of three consecutive elements so what you what would be your approach in this case well one approach is that you actually start doing or making every single pair and try to come up with the solution so in that case you first take these three values do it sum then you take these three values do it sum then you take these three values do it sum and so on and so forth and eventually you will find the result or the second option is that you actually create a window of three characters and then keep on incrementing the sum uh and try to find that which has the maximum sum so let's try to use the sliding window technique in this one so suppose I create an element called Max sum that is to keep track of the maximum sum I'm also creating another variable called current sum and this is going to be our window of three elements that we are dealing with so first let's say that we take these three elements so now the sum is current sum is 11 and so far the maximum sum we have been able to find is also 11 okay now we need to check or move our window on the on the side but the window size will remain same so once again we are creating a new window and that new window is going to be starting with value value three okay so let's create another window now the moment we we created new window do we need to calculate the sum of all of these three values well actually no we have a better approach and that better approach is that we can actually take the previous sum we already had that had current value what we did essentially in this one we subtracted one from this window that we got rid of this value and we added two in this case so we can simply do this computation now you must be wondering that this is only three elements so why are we even bothering doing this imagine if this was like 500 elements and this was a very large area of million characters in that case this computation would save you so much time because every time you only have to subtract one element and add another element and that's it you will get the sum of all the consecutive values of those 500 values you don't have to to do much work and iterate over all 500 values to find the result so in this case now this sum is going to be uh 12 so 12 is definitely greater than 11 so we would update our Max variable that currently the maximum sum we have found is going to be 12 okay and we are also going to update our current sum as well to Value number 12 once again we got rid of three and we add value number five in this case so 3 + 5 the answer is going to be 14 once again we update our maximum variable to Value number 14 and same way we update our current variable as well so 14 and 14 and currently we were looking at this uh pair now let's subtract seven and add value number eight so in this case the current sum is going to be 15 which is also the maximum sum we have found so far so we would update that once again let's get rid of value number two and add value number N9 so in this case the sum is going to be 22 and that is the maximum sum and we can update that see how easy it became once we created a simple window and then we iterated or moved all the way over there so this is everything you need to understand about sliding window technique well sliding window is not very TP very difficult to comprehend and let me give you another example okay now this is one of the most popular problem on lead code and has been asked in tons of companies uh basically we are given a simple string s and we need to find the longest substring that does not have any repeating characters so if we see an example example over here in this case we have we are given a bunch of long string but we can see that first a b c is the longest string that does not have any repeating characters and its length is three so we are going to return three as the answer because apart from that all the other places actually has repeating character so the window is not large enough okay so now let's try to see that how would we solve this problem suppose we are given a problem like this that uh a b a c d a something like this this okay we are given this as the input and we are trying to find the longest substring without repeating characters so of course we are going to use sliding window in this on top of that we will also have to use some additional data structure to keep track of all the values we currently have in our existing window so for that uh hash map or hash set is actually great so we will use hash set because we don't need to have indexing in this place but we only need to know that what are the elements currently present inside our existing window okay so let me just quickly draw our hash set and now the approach is that we are going to have two pointers so first pointer is going to be left pointer second pointer is going to be right pointer initially we are going to keep moving right pointer until the point where we do not encounter any uh repeated characters and we would Mark its length uh as the maximum length we have been able to find so far the moment we encounter a repeated character we are going to take left pointer to move one step to the right right and then keep on repeating the same process and meanwhile we would only move right if the value is not currently present inside the hash set if it is present then we would move the left pointer and uh let's try to see the solution in action okay so first we are both are at the same position and we have our maximum uh substring length that is currently zero and hash set is empty okay so now let's see currently a is not in the hash set so we will add entry a over here and then move right pointer to the next element uh now after doing that now let's see a b are still distinct B is not added so we would add B over here as well and move on to the next element so next element currently is uh a again so because this is a once again okay what is the maximum window we have been able to find so far that was only two characters so we will Mark two two over here as the answer now because we find an identical value we are going to move our left pointer to the right the moment we move left pointer to the right whatever the value we had in the left pointer we are going to delete this so first let me get rid of this value okay now after getting rid of this value uh we we have our R located over here so we will have to add an entry a over here and now currently the window size is still two now let this R go to next element so it will go to next element c c is also unique now let this R go to next element d d is also unique so it can still still stay over here now the next element is once again a a we already have inside the existing hash set which means okay so far the maximum window we have been able to find is of size four so let's mark four over here and once again let's try to update the value so now we are going to move move our left pointer one step to the right okay after moving it one step to the right again remember we haven't added this a yet because it was a duplicated entry okay so we added we removed B from here so we got rid of B from our hash set once again this value is a and once again our right pointer is still stuck over here now this left pointer we got rid of a okay after getting rid of a now we can check that whether right pointer can be added over here or not yes now it can so we will add a over here and now uh we will try to move our right pointer but now it is the end of our list so this is only of size three this uh substring without repeated characters and maximum we have been able to find is four so four is going to be our answer and this is what we are going to return return so now you imagine how we had like a dynamically changing sliding window in this example to solve this problem and we actually use hash set and tandem to solve this problem now U this is quite a simple problem so I'm not going to show the coded solution but I do have the coded solution available on the GitHub link and I'm going to post it in the description so you would be able to check it out from there if you are curious ious now let's move on to the next topic that is called two pointers okay now let's try to understand one of the interesting uh coding pattern that is very similar to sliding window and that is called two pointers now this two pointers is actually really popular with data structures like array and strings and the idea is that just like a sliding window we are going to have two pointers but these two pointers are typically going to be located at the edges of Any Given array and depending on certain scenarios the pointers would come towards each other based on the various scenarios that we have available okay so this is the whole premise now if you want to understand this uh with a real life example you can think about that let's say that you are currently located on a Long Beach and inside this Beach uh you maybe lost something or uh some some of your maybe cousin or child or someone so the idea you are going to use is that you and your wife you both are going to go to different ends of the beach and you would try to come towards each other trying to find the child that whether that child is maybe located somewhere and try to consider that beach is just like a simple line so you are not moving in any other direction So eventually you would be able to find the child who is going to be located somewhere but essentially you and your wife you are going to be coming towards each other and the this is the whole concept of two pointer solution so let's try to understand this with an example okay so let's try to solve this problem squares of a sorted array now this is a very popular problem and also a very simple explanation yet it explains that how we can use two pointers to our maximum Advantage uh basically we are given a nums array and we are told that this array is already sorted in an increasing order now we need to return a new array that contains square of every single element but we need to make sure that this is also in non decreasing or increasing order so assume that suppose we are given an input array like this 1 2 and four this array is currently in increasing order so in the answer we need to return the square that is also going to be 1 4 and 16 and this is the answer we need to return now looking at this example you must be thinking that hey this is quite simple all we need to do is just square of two elements and then we can simply return it as it is but it's not as as simple as it is because we could have an input that looks like this where the values could be Min 8 1 0 and then 1 and then two suppose if this is the array given in this case the answer has to look something like this where the first value is going to be 0o because 0 square is 0 then 1 square is going to be 1 then once again 1 square is also going to be 1 then 2 square is going to be 4 and then 8 square is going to be 16 64 so see this value came over here this value came over here this value came over here so everything got jumbled up because we had some negative values and yet this satisfied the property of being in increasing order and this also became an increasing order so now how do we deal with negative numbers in this scenario so one root force or naive approaches that whatever input we are given suppose the values are 4 2 1 and 3 suppose this is the input value we are given uh one simple approach is that we simply do a square as it is so values like 16 4 1 and 9 and then we do the sort operation on this array so if we do that we will again get the correct answer that is 1 4 9 and 16 but this is going to be done in N log n time so we will try to see that can we do it faster in just log and uh B of end time rather than using log andun function and yes the answer is we can do it plus you already know because we are explaining two pointers for sure we are going to do it using two pointers the idea is we will have our left pointer located on the last location we will have a right pointer located on the rightmost position and then we are going to have our answer Square okay now what we are going to do is it is only possible that if this value is too negative it could either end up somewhere over here here or it could e if it is positive value then it has to end up over here there are only two possibilities so what we are going to do is at every single location we are going to compare the value of this with its right counterart and whichever value is going to be higher we are going to put that in the end and whichever value we put that pointer we would move to the next element and again repeat the same procedure so let's see the solution I'm proposing in ation action so first we'll compare this left with right and we are going to do square of both of them so square of left is going to be 16 and right square is going to be 9 so again left is greater because left is greater first we are going to add value number 16 over here and then we will move our left pointer and once again repeat the same exercise so now this time uh left pointer is located over here okay so now square of two is going to be four and square of three is going to be 9 so because 9 is greater now we are going to put 9 over here once again we are going to move left pointer in this case because we added nine here now this is 1 and this is min 2 so square is going to be four and this is going to be 1 so once again next value we have to enter is going to be four and then we are going to move our left Point pointer on the right and then since because left and right now both are at the same position we are going to add the one as the last element over here and return this as the answer so see how we were able to generate the entire solution in just one single pass and this is the beauty of two pointer approach that whenever you see solution where you need to compare both sides of given input array or string try to think that can you solve this problem using two pointers and most likely this could be one of the possible solution so now let me give you a quick trick after we have understood lot of things about array first thing is whenever you are given an array try to think that can you sort this given array to generate some result second try to think can you use some some of the hashing function like hash map or hash set then if not try to S think can you use a sliding window technique otherwise try to think can you use two pointer technique typically amongst all of these most likely you would be able to find the answer you are looking for and this is the key trick for to solve any array based question in any of the technical interviews okay so now we are going to see the solution for squares of sorted array uh so let's see first of all we are going to create a variable called n and that is going to be the length of given input array then we are going to create a new array to store the result we are also going to initialize two pointers first is going to be the left pointer second is going to be the right pointer left pointer is located on the leftmost position rightmost right pointer is located on the rightmost position then we are running a for Loop in the reverse order and we are we are going to have a function that basically takes care of the Square value and then we are going to compare the square of the left element with the right element so basically what we are doing is uh we are simply comparing the absolute values of left element with the absolute values of right element so we are ignoring the minus sign and whichever value is greater we are putting that in the square and in the end in the result of that particular I value we are just storing whatever the square variable we were able to find either left or right and then uh in the end we simply return the result array that we have created now let's try to run this code okay seems like our solution is working let's submit this code and our code runs 100% faster than all the other Solutions which is quite awesome so now you got the idea of how two pointer Solutions work okay so first let's try to understand a really interesting coding pattern that is called fast and slow pointer now this is most prevalent and very heavily used in link list kind of problem so you might think whenever you are trying to solve some linkless problem try to think that can you use this technique in this scenario and first let's understand that what does a fast and slow pointer technique is it is very similar to a twop pointer technique but uh in the two pointers where we have two pointers left and right coming towards each other in this scenario we actually have a fast pointer and a slow pointer both typically starts from the same position but fast pointer would would make double jumps so fast pointer would go to the next to the next value meanwhile slow pointer would only make a single jump like a normal uh typical traversal we do and doing this would yield us uh some good results in couple of specific positions so first let's try to see that how does a typical concept looks like let me draw a random uh link list now we are assuming that this one is a single link list but same thing would apply for a dou link list as well and this is the head of the link list and this is the last element so this value points to the null value now in this case the overall idea for the pattern is that we are going to have two variables so first one is a fast and second one is a slow variable okay so currently let's imagine that both fast and slow pointers are based at the head position okay now fast pointer is move in the Direction Where We are going to choose the next element for fast is going to be node do next do next so next to the next element for any given node would be the next node for the fast pointer meanwhile for slow pointer it is only going to be node do next that is the regular traversal so during the first iteration fast node is going to do node do next do next so fast pointer would end up over here meanwhile slow pointer would have end up over here in the second iteration fast pointer would end up over here meanwhile slow pointer would have ended up over here and doing this now fast pointer is is at the very last element inside the link list so now we can use some properties so the question comes that where does this technique is actually used so I can give you two examples right now first example is that I already showed you previously in the course where you need to find the middle of the link list in that case uh fast and slow pointer is very good use case to follow that if we want to find the middle of the link list typically we can do that and try to consider the same scenario in this example we are seeing that right now the fast pointer actually reached to the end position because fast do next is equal to null which means this is the last position around that time slow pointer is exactly located at the middle element and which we can see right over here so whenever we are being asked that hey go ahead and find the middle of the link list always try to use fast and slow pointer because that would be the quickest method to find the solution another one solution is that when you need to detect a cycle inside a link list and now the question comes that how can we actually detect a cycle inside the link list using the fast and slow pointer so let me give you an example for that as well now suppose uh let's assume that we currently have a bunch of different nodes lying around and we will try to see that how would a cycle inside the link list would look like okay now let's assume that all of these nodes are connected and in this case there is a cycle present like this okay now we don't know initially because this is a singly link list and we we have no idea that what are the next elements so let's assume that if you had to detect that find that if there is a cycle in this case or not how would you detect it uh one basic and naive approaches that let's say that these are all the values for this given uh link list what we can do is we can actually start iterating the given link list and we can have another data structure like a hash set and we can keep checking that whether this node has been previously visited or not and if we reach to the null value we can say that there are no Cycles in the link list like the next node is the null node then there are no Cycles in the link list if the next node is not null and we encounter some node that is already present in the hashset we can say that this node has been repeated so let's try to run this example first we will add all of these values so 1 2 3 4 5 6 7 and 8 all the values we would iterate but before that we would check whether it is present inside the hash set or not because it's not present we would add all of this 1 to eight values over here now the moment we would try to iterate to this value we would realize that this three has already been added to to the hash set which means we encountered a value that has been added so that's why we can say that yes there exist a cycle in this case but now issue with this approach is that we actually have to use an additional has set so the space complexity in this case would be big go of n which we don't want we want to do this problem without using the space complexity so the another approach is to use fast and slow pointer and let me show you that how would that look like the whole solution okay so let's get rid of this hash set and let's have our fast and slow pointer ready so initially our fast pointer would be located over here and slow pointer would be located over here now let's make two jumps for the fast pointer and one jump for the slow pointer so after which fast pointer is going to end it up end it up over here and same way slow pointer is going to end up over here okay now once again fast pointer is going to end up over over here and slow pointer in this position has ended up over here okay now let's repeat the same process now fast pointer would come over here same way slow pointer would come over here and let's get rid of the previous two elements once again fast pointer is going to make two jumps so fast pointer would end up over here and in this time slow pointer would have made one jump so slow pointer would be here now when fast pointer makes two jumps it is guarantee that it is going to encounter slow pointer in this scenario and the moment we find out that fast pointer actually came back to the slow pointer or the position where slow pointer is we can say that there is a cycle in this scenario and we can return true that yes there exists a cycle so basically this is the whole concept of fast and slow pointers so whenever you are trying to solve some problem related to link list try to think that hey can I use two pointers where one pointer is faster than the other and try to come up with the solution more than likely you will be able to find some good answers in that now let's learn an awesome technique called backtracking backtracking is highly popular in lot of different scenarios and you can typically use backtracking to solve problems like dynamic programming recursion uh tree problems and graph traversal problems so for all of these things backtracking is heavily useful so you can imagine that how popular it is going to be if you ever wants to implement these data structures and try to come up with a solution so first let's do this we will try to understand that what backtracking is then we will try to see that what is some real life example so I'll probably give you a couple of real life examples and then we will try to see how we can navigate using backtracking in the depth for search manner so that is how and we are we will try to navigate it within trees and graph and on top of that we will see one of the lead code examples as well okay so first let's understand that what does a backtracking is backtracking is nothing but an ability to go back to the previous place we were at essentially let's say that we are following some certain path and at any given position we have the option to choose uh some different paths as well depending on the CH choices we make so let's assume that in this scenario we decide to take down uh and go we initially started with this and we go down this path this path and from this moment we decide to go to next PATH over here and from this we decide to go to the next PATH over here but we did not find the answer we were looking for so what we would do we would come back again to this node and try to check a different path once again since we did not get the answer we would once again try to get back to this path where we originally branched out come back to the same PL same path and then choose a different option and keep a track that which path that we have already taken so that would help us determine or backrack our actions that's it this is the whole concept of backtracking if you have to understand this let's say that you are currently located inside a garden and this is like a maze Garden so you don't know where you are going okay so typically all the roads are crossed in weird manner where some roads don't lead to any other place and then there are some roads that leads to different positions in the garden so what would be the approach you would take let's say that you typically started from here what is going to be the approach you are going to take well essentially the idea is let's say from this place you started traversing this path you would keep on going and realize that hey there is no path in this case so of course you are going to backtrack you are going to come back to the position where you originally started once again try to take a different path and again make some different decisions so if you go down this path once again it does not work so you will backtrack to a previous position where you made the choice and once again take this New Path and eventually this New Path might end up might lead you to the Final Destination you are trying to get so this is one example of backtracking so now let's try to see that how does backtracking would typically work in a tree like scenario okay so currently let me just draw a very simple binary tree where I have bunch of different uh nodes and each node had has some children associated with them and for each one of them I'm trying to see that what is going to be the most optimal path or let's say I'm trying to find this value x uh this node X so first I go down this path then once again I go down this path and by the way I'm using DFS in this case depth for search which means I'm going in the depth rather than going in the breath so I go over here I don't find anything so I will backtrack once again from this I know that there is one option left that I haven't checked once again in this case I haven't checked the I didn't find anything so I'll backtrack once I know that I have exhausted all of this possibilities I can also go back to the original root node and once again repeat the same process and in this case since I don't find anything I will again backtrack and okay here I find the X I was looking for and I can say that yeah this is the correct path and I can return that as the answer so this this would be an example of how uh backtracking would work in a tree like data structure and same concept applies to the graph as well because trees and graphs are very similar the only difference is graphs can have Cycles trees typically don't have cycle so even in terms of backtracking the same logic would apply that let's say that you decide to go to this path and then this path first but this part does not yield the result you are looking for once again you would backtrack and you would go to a different path and through which you find the result you are looking for and you get the correct answer so backtracking is nothing but the ability to go back now let's try to understand backtracking with one of the lead code examples okay now let's assume that this is the problem we are trying to solve binary tree paths now we can see that this has been relatively popular problem and the problem statement is actually quite simple to understand we are simply given the root of a binary tree and we need to return all root to leaf paths in on any order so let's try to understand this with an example suppose we currently have a binary tree that looks like this now in this case let's give some arbitary values as well uh so the values are going to be 1 2 3 4 five and six okay these are the values for each node so in this case how many different paths we have from root to node so first path is that we can go down this this scenario and this scenario so 1 to 2 to 3 this is a path to leave okay once we identify and let's create our answer list where we are going to store all the results that we are we have been able to find so far Okay so we found one path after finding this we will backtrack to the previous element once again repeat the same procedure to the remaining path okay we completed the remaining path and now this path is 1 2 and four okay once again back track okay now we exhausted all the possibilities over here so once again we are going to backtrack to the previous element from one we still have unexplored paths so we will start exploring and we will keep on going until we find the leaf node that we are looking for so in this case okay we find the leaf node as six and now we will add one more path that is 1 5 and six and now we explored all the paths so this answer list we can return as the answer and basically that's it okay so this is the problem statement binary tree paths and here is the solution basically the first thing we are going to do is uh we are going to check for the edge cases that if the given root element is equal to null we can simply return the paths we have if not we have already created a new link list that contains the list of all the parts we are going to create now in order to implement the backtracking we will have to use stacks and in the stack we are going to add the current root node and then we will keep on going it to iterate all the possibilities until we find our stack is empty or not and when we learn more about DFS you would be able to understand this technique that how this technique actually really works and how it is pretty efficient way to implement the uh backtracking method for the depth first search scenario so so now we have our link lists initialized now first we are going to add the root element to our link list and then we are also going to add a new path to store the integer value and then we are going to run a while loop that while the given stack is not empty we will keep on repeating the same process and basically this piece of code does nothing but it only Travers through the left side of the node or the right side of the node until we reach to a point where there no longer exist any more children for any particular value and once we get that we would add those values to the subsequent paths and in the end we are simply returning the path so if you didn't understood what I mentioned I'm going to post the solution in the GitHub link as well so you can check it out from there and you should be able to understand let's try to run this code and seems like the solution is working as expected let's submit this code and our code runs pretty efficiently compared to a lot of other Solutions Plus this is this gives you an idea that how does a typical uh depth for search or backtracking works for any tree or graph related problems okay now we are going to understand another interesting pattern that is called intervals intervals are nothing but the spaces of time or sequence in between and we need to do some work with that or some computation with that typically in the intervals type of problem you would always be given some specific set of time based connections or intervals like something like a starting time and ending time starting time and ending time and then through this you would try to make some meaningful information so let's say that this is the starting and ending time chunks of the entire day uh between 9 to 5 and let's say that these are the meetings that this meeting starts at 10 and ends at 11 this one starts at 1 and ends at 2 and this one starts at 4 and ends at 5 so if this is the information given if I'm trying to create or schedule a meeting how would I be able to do it so what are the empty time slots available to me so this is an empty time slot available this is an empty time slot available so if I want to schedule a new meeting I can actually schedule in that and that is the whole point of intervals typically most of the times intervals are actually being used for various set of uh time management or calendar management type of activities and trust me this is important because I personally got asked interval questions in two of the very big company interviews I I I actually give so that is why interviews are intervals are really simple to understand on top of it once you know the technique it's actually quite easy to take care of it so let's see that what are the different possible scenarios we can have inside the interval number one possible scenario is that we are given the time schedule for A and B to two different people now we are being told that uh this is the time sequence now these are the times that a currently has a meeting and for B we are being told that these are the times B currently has a meeting so now if I if we want to arrange a common meeting between them to take place how can we do that and the idea in this case would be to create or merge a new interval common interval this is just for the example sake I'm telling you and in this case what we would do is we would take whichever the starting point is smaller at first and whichever the ending point is larger at second so if there is a conflict between any two entities that can be resolved quite easily and we would start creating new intervals that are combination of both of them so that would give us the idea that which are the empty times available so another interval like is like this and this one ends with the schedule so now this is the common time schedule for A and B which means we can say that there is only one empty space available where we can schedule a new meeting if you want to so this this would be one of the use cases second use case would be that let's say that for a we are actually being told that a is overbooked with multiple meetings on many places so which means a has overlapping meetings throughout his day and we wants to simplify this process so what we want to do is uh whichever meeting is smaller in the value we want to get rid of it so we want to get rid of the interval that is actually causing a conflict between the existing meetings so in this scenario we can check that okay currently this meeting is 2 hour long let's I'm giving you for an example and this meeting is only 1 hour long but we do see that there is a conflict in this case so because there is a conflict if we want we can get rid of this meeting entirely and say that uh now a does not have any conflicts same way in this case there is a conflict between this time and of course this meeting is smaller so we can also get rid of this one so this would be a remov of removal of interval kind of scenario another way to treat this is that we can actually move this meeting to the side so let's say if meeting is like this rather than canceling the whole meeting what we can do is we can just get rid of the conflicted part and we can create another new meeting that looks like this that okay now a has two separate meetings even though they are back to back with each other still they are not conflicting so this would be another type of scenario for inter interval questions and the third type of scenario would be where we are actually being told to merge intervals okay now let's assume that this is the problem statement given to us that we need to merge the intervals and you can see that this is a very well like problem on lead code basically we are given an array of intervals where at any particular position position defines the starting and ending point for that particular interval now we need to merge all the overlapping intervals and return return an array of nonoverlapping intervals that cover all the intervals so here we are given an example if you want you can take a look at this example but I actually plotted this example on a very nice like graph so you you should be able to see the idea now in this case we can clearly see that there are four different intervals given to us but among these four intervals we see that these two intervals are non overlapping they are just as it is now how do we know that on our side we can just see them and realize that they are not overlapping but if you wanted to check that if any two o intervals overlap or not all you need to check is the ending point of the previous element and the starting point of the next element and if there is a difference between them let's say that because this ending point is smaller than the starting point of the next one which means we can Define that there is no overlap between these two so because there is no overlap we can keep them as it is we don't need to do anything now in this case if we see this is the starting point this is the ending point same way this is the starting point and this is the ending point so starting point of this is one and ending point of this is three same way starting point of this new element is actually two and this uh this interval is actually six so in this case we can see that for this interval we do have another interval Who start starting point comes before the starting before the ending point of this previous uh interval so that is why we detect that there is an overlap because there is an overlap what we can simply do in this scenario is that we would take the starting point whichever is smaller so in this case the smaller starting point is one and then we would take the ending point whichever is greater so ending point greater is six so we would create a new interval called 1 to 6 and then we would take keep this 8 to 9 interval as it is and same with this 15 to 18 interval as it is so the new answer array is going to be this 8 to 10 and then 15 to 18 and this is the answer we need to return so basically this becomes a very simple problem to understand I don't know why lead code mentions this as a medium problem in my opinion this should have been easy all you are doing is comparing the values between starting and ending point between any two subsequent variables and remember in many scenario to trick you the intervals that we are originally given in the original input might not be sorted so if they are not sorted then in this case first thing you will have to do is sort them in the basis of starting time and once you have the sorted values then things becomes quite easy and then you should be able to solve any of the interval problem so let's quickly see the Java code for this problem so here is the problem statement merge intervals and let's see the Java code for that so first thing we are doing is we are actually sorting the given input based on the starting times and once we have that things becomes quite easy now we are just initializing a new link list uh named answer and then we are iterating over the original intervals array that we are given where we are given two values one for starting point and one is for ending point where we have all of these conditions that if the answer is empty or if it is the last element or whatnot we are going to add element to the interval if that is not the case we will have to do the merge operation where we are simply going to add the value of the last element or the maximum value of the last element compared to both the intervals and minimum value of the first interval that comes in the normal sequence and let's try to run this code okay seems like our solution is working as expected let's submit this code and our code runs decently efficiently so this is a very simple problem to solve once you know that you have to sort the given intervals based on the starting time now we are going to start with a very important topic called BFS now if you don't know what BFS means uh it is short for breath for search and it is a very popular tree and graph traversing traversal service so typically whenever we are going to see any data structure such as tree or a graph and we need to iterate over either tree or graph for traversal one of the very popular technique is is a breath for search technique and we spoke about this little bit uh in the previous sections but now we are going to go into much more deeper on how what are the considerations how it works and how to implement this plus we are going to see an example of uh an actual live lead code problem for this problem as well so we all know that in the breath for search essenti essentially you are traversing outwards towards your subsequent neighbors first before going out out to their neighbors so at any given position first you will encounter all the neighbors of that value then you will start encountering its neighbors and until you have done for all the cases you will not Branch out to the deeper levels so essentially you are traversing level by level for all of the nodes that are currently present inside your graph so if this is let's say that this is a graph that you are given now in this graph first of all you are going to start at the root position and this is the root position so first you are going to visit all four neighbors once visiting all four neighbors then for each neighbor you would start visiting their subsequent neighbors and one only after you have visited all the subsequent neighbors then only you would go to further higher or deeper levels so let's see some examples of this in both tree and graph like structures suppose this is the tree we are given I'm just drawing a very simple binary tree and and I'm going to associate some values to it so let's say that the values are 1 2 3 and 4 5 6 7 these are the values so if we if we have to apply breath first search in this scenario basically we are going to first visit for any root node we are going to first visit its neighbors so first of all we are going to visit node number two and node number three uh and then we are going to visit its subsequent nodes that are 4 5 6 and 7 so where this type of solution can be useful well let's say that at any given position you want to print out that what are all the numbers available at any given level of a tree then you can use this uh BFS approach or if you are trying to find some elements and you expect that element would generally be closer to the root element also in that case it would make more sense to use the BFS approach plus now let's see that how this would work in a graph like data structure typically in a graph we have bunch of different various data connected with each other and there are there can be some or many cycles associated with each one of them now assume that in this graph this is currently the root node so in this case for the BFS basically we will visit all the neighbors so this is the neighbor this is the neighbor and this is the neighbor and also this is the neighbor and only after visiting all these four neighbors we would start going to the deeper levels and that would be visiting neighbors of these neighbors uh so where is typically BFS useful for the graph likee structure is that let's say that for any particular node you want to know that how distant it is connected with some other node so in this scenario we can consider these two nodes to be Distance by two because this is directly connected with this so there is a distance of one and this is the distance of two this can easily calculated using BFS and there are some very real life practical use cases like uh websites like LinkedIn or even Facebook you can actually see that how what is your common connection between any two people and for that uh it's quite easy to implement the graph based bread for search method to calculate those values so you can calculate the degree of distance between each each other neighbor on top of that even for graph basically uh BFS is used to search any element plus Traverse over the entire graph and if you want to find any connection between between two end points you can do that if you have to visit all the neighbors of any particular element for any of your problem solving requirement you can also use BFS in that scenario and again remember any problem that you can solve with BFS you can also solve that with DFS as well the only difference is depending on the problem statement sometimes it would make sense to use the BFS and many times it would make sense to use DFS so always make sure that you are aware that which data structure approach you are going to choose now let's see that how BFS gets typically implemented and usually in order to implement a BFS we usually use a cube where we put one value inside the cube and then we add its children to that Cube and then we keep on repeating the process so the output of that CU would be the breath for search manner traversal for any given tree or graph and let me show you an example of a tree so suppose I'm given a simple tree and I'm just drawing uh five noes over here and let me Mark the values as 1 2 3 and four and 5 so initially we are at this first position now we are trying to do the BFS so let me also initialize my Q as well and in my Q uh we all know the principle first in first out okay so first the value I have currently is value number one so I'm adding one over here now before processing one I'm going to add all the children of one I repeat before processing one I'm going to add all the children of one so there are two two childrens's of 1 2 and three so I'm going to Mark values 2 and three over here after that and only after adding all the children I'm going to process one so let me print out the value one over here that this node has already been processed and also let me get rid of this now the immediate value or the very first element inside the Q is value number two so once again before processing two we are going to add all of its children so the values are four and five and then after that we can process value number two so once again let me get two out and uh second element over here would be two now in this case the next element I have is three now since we already process all the children of three or three does not have any children so we can take three out then same way after taking three out four and five also does not have any children so we will take four out and then we will take five out and in the end our que would be entirely empty because we process all the nodes so we are going to keep on processing until Q is not empty and using this approach we can actually solve the BFS for any given tree problem same logic applies for the graph problem as well so you would be able to understand what I mean now let's try to consider one example uh and then we will see the code for that the example is that we want to find the average at the uh level for any given binary tree so the problem statement is quite simple to understand we are simply given a binary tree and all the values we need to find the average at the its own level now let's give some arbitrary values so 1 2 3 and 4 5 6 7 and then 8 and 9 so these are the values now what is the answer going to be currently on the very first level there is only one element and its value is one so the average for this is also going to be one now for the second element we have two values 2 + 3 so the average is going to be uh 5 / 2 so 2.5 so this answer is going to be 2.5 next over here the average is going to be uh 4 + 5 is 9 and 9 + 13 so 22 22 divided 4 so I think it's something like 7 uh sorry 5.5 yeah I think it should be 5.5 so this average is also going to be 5.5 and now for this one the average is going to be 8.5 and this is what we need to calculate so you must must have understood by the logic of it that we are going to do the traversal based on the levels that we are performing and we are going to have our Cube and in the cube we are going to first insert the value number one we are also going to have a method to calculate the average and in order to do that we will need to know that how many children are currently Pro or how many elements are there because this is a root element currently we only have one element so I'm going to encounter a value called count and initially the count is only one for this one I'm going to add its children so I added children 2 and three over here because I added two values I know that for next time when I need to calculate the average the count is going to be two okay so now this one this time using this I can calculate the average one and I can print one over here same way uh before processing two and three I'm going to process its children and even for the children I'm going to keep track that how many what was the count and eventually I should be able to make all of this continuous a average calculation because it's a very simple problem and this is how we can actually Traverse in the level order for the given tree and solve this problem quite easily so now let's see the lead code solution for this as well this is the problem we are trying to solve average levels in the binary tree and here is the Java code for that first of all we are given the definition of the tree and then in the main solution first of all we create a new list where we are going to store the result values plus we are also going to initialize a q where we are going to store our tree nodes and on top of that we first add the root element to our Q now we run our while loop that while Q is not empty we are going to keep track of what has been the long sum plus what has been the count for every single children we added we are going to add a temporary node to for our Cube and we once again for that we are going to keep track of or add all the children of it and increase the value of the count and we are going to keep on incrementing until the left node is not equal to null or right node is not equal to null and uh after calculating that we are simply going to run the average function that is Su multiply by one divided by count and um uh that's it so we will add those results into the result list we created earlier and this is the whole solution now let's try to run the code okay seems like our solution is working as expected let's submit this code and our code runs pretty fast pretty efficiently which is awesome so I hope you understood uh that how things get easier whenever you need to Traverse in level order for any graph or any uh tree you can use BFS quite easily okay so just like BFS now we are going to shift our focus on the DFS and DFS is also a graph and tree traversal method and in this scenario we are actually going down into the depth before going into the breadth so we are going to pick a path keep on going on and on in the depth until we reach to the very last Leaf node on that path and then only we are going to backtrack our way to a different possibility and then keep on repeating the same process so let's try to see an example suppose this is a tree that we are given now in the same example rather than traversing in into the sequence of breath we are actually going to go down into the deep so first we are going to Traverse down this path then after traversing this we still have one node that we haven't process in the reverse order so we will go and do a backtrack after backtracking go back over here once again solving this we would again backtrack and through here we would complete the remaining uh path that we haven't taken and in the end we will return this solution of all the paths that has been traveled so this was an a depth for search for a tree same logic will apply for a graph based depth for search as well that let's assume that we have some complicated graph based algorithm or many different nodes that are connected with each other in all sorts of manner and once again we would try to generate some graph based solution for this one as well so let's assume that if this is our root node initially so we decided to go in in the depth for each one of them so first let's say that we pick this node now this node also has other neighboring connection node so we are going to go to its neighbors again this also has neighbor so again we are going to go to its neighbors and again this also has neighbors so we we are going to go to its neighbors after completing all of this we are going to do a back trck to see if we missed any other branches in the depth this one has no branches this one also has no branches this one also has no branches so we come back to our root node but root node we still have other nodes that we haven't traveled so we will go to that node first before traveling to the other nodes and every time we are going to do the backtrack function now we know that in the breath first search we were using Cube but actually in the depth for search we are going to use a stack T to keep track of of all the nodes that would help us with the backtrack function so how would this work I will just give you an example but first let me talk about that if you have to do a tree traversal using DFS you actually have three different ways to do it now I already showed you what those ways are but I'm just giving you the name that is in order traversal preorder traversal and post order traversal and all of these would be part of or would be considered a depth for search traversing methodology now the question is that what are some of the benefits of using the depth first search so first number one use is that if you are trying to find the full path between any two entities so in that case DFS tend to be more useful second thing is if you're trying to find some element so again in that regard as well that you are able to generate it very easily using DFS uh same same way let's say that if you are trying to make some dependency graph and and this is heavily useful in lot of scenarios let's say if you are trying to build a compiler or if you're trying to build like a schedule prerequisite dependency course kind of a module for our University so in all of these scenarios graph based DFS is going to be very useful so these are some of the most critical scenarios wherever you can think of that from one node in the graph you need to go to far away to some other node try try of thinking to use DFS okay now let's assume that we would try to do a DFS stack run example for any given note now initially we are going to have an empty stack and inside our empty stack just like BFS method in the DFS we are going to add the root node now remember stack has a different property that is last in first out okay and we are going to follow some principles so first okay let me add one value number one over here now the principle we are going to follow is the moment we take one value out from the stack we would see that how many children that value has and both of these children we are going to add to the stack after that and we are going to keep on repeating the same process okay so now currently we have element number one so we are going to take one out so if we take one out let me just node create a method where we are going to keep track of process node So currently we have process node number one okay now we are going to add its children 2 and three into the stack as well so let me add this value now once again just like the same logic we are going to pop value number two first so let me pop value number two so we process node number two but because we process node number two we are going to add its children into the node as well so let me add values five and four over here as well now once again same logic we are going to pop value number four first so after popping value number four we are also going to add children of four as well that is value 8 and N so once again even for 8 and 9 we are going to pop them now since 8 and N does not have a children of Their Own so even if we pop value number eight and value number nine they are going to remain as it is because they don't have any children that we can add so now we can get rid of 8 and N from here now next value we have is element number five again element number five also does not have any children so we are going to mark value number five over here and then we can remove that okay after that we are only left with value number three so we will try to pop value number three out the moment we pop value number three in this case we will have to add its children over here so first let me delete this okay so now currently we are going to add value number six and seven here and then we are going to mark three as presented and then we are going to pop value number seven out and then we are going to pop value number six out so this is going to be the whole flow of the sequence in which we Traverse through all the nodes inside the given tree using the depth first search method and uh we can see that all the iterations leads us in the in the graph sequence so here here first we visit node number one then we visit node number two then we visit node number four then we visit node number 8 so we go down in depth after visiting eight we do a back track and we go to the four and visit the remaining child that is nine so like this and after visiting nine we do another backtrack and two we visit value number five so this is how the sequencing of death depth for search is being followed and you can find plenty of examples of depth for search in all across places so I hope uh the concept of BFS and DFS is quite clear to you now so we can move on to our next topic okay now we are going to see a really important algorithm that is called greedy approach now as the name suggest in the greedy approach we try to be greedy in order to generate the answer and we try to find the solution on every substep as well in the given uh algorithm or given problem now before we start understanding the technical details of greedy approach let's first try to understand the local detail of the how greedy approach typically Works let's say that you currently have an empty truck and you are trying to fill this empty truck with bunch of different boxes uh that you currently have now in terms of boxes you have three different types of boxes first boxes that uh and remember all three box boxes are identical in size but they contents are different so let's assume that the first box we have this contains all the ion now second box we have this contains all the aluminum and the third box we have this contains all the feathers now in this case what should be our approach to fill in the all of these boxes into the trucks so that we can get the maximum return out of weight we are trying to put in of course the approach is going to be quite simple we are at every given position or every particular item we are trying to fill we will try to maximize the value of these pink boxes and we will try to see as many number of uh these boxes we would try to fit inside the given uh truck before we run out of them and once let's assume that we fit all of the iron boxes what would be our strategy in next case next case strategy is to fill out the remaining of remaining portion of the truck with all the aluminum boxes uh so doing this method would grant us the best weight ratio amongst uh inside our truck and in the end if we have space then we will try to put the boxes with feathers in them if not then we would essentially fill out our entire uh truck with these two type of boxes so the load we would be handling the heaviest load so what we did in this scenario that let's assume that we consider that filling one box inside the truck as one sub problem for the given algorithm or given step so in every sub problem amongst all the options we always choose the best fit option in order to solve our problem that we are trying to solve and this is the classical example of a greedy approach where even during the each and every suboptimal level we try to choose the most optimized and best available option in order to go to the next next step so now let's see that what are some of the important characteristics of a greedy algorithm so greedy algorithm as I mentioned it is built on piece by piece by piece and every single time we are always choosing the most available and best uh suited particular option for our graph in order to build the solution so no matter if there are how many number of choices available we are always going to pick the choice that is the most suited in order to F fulfill our need now greedy algorithm also suggest that the global Optimum or the best results we can achieve by every single time at every single sub problem selecting the best available option so that is one of the characteristics of the greedy approach and uh there is also one more choice or one more uh thing that we have to understand that is that in order to optimize or find the optimal solution for all we need to consider that what are the overall constraints available to us because many times the greedy approach might look okay at the beginning but it might not be the correct Choice uh because let me give you an example for that do you remember the scenario we were trying to solve where we had bunch of different coins and we were trying to make uh any particular number so let's just say that we were trying to make value number 11 uh to see that which are the smallest number of coins we can make or we can use to to build this property and let's assume that the available coins to us are going to be value number one uh then value number five and then value number s and we are trying to see that how many number of coins would it take for us to generate this value number 11 if we were to use greedy approach our approach is going to be that for first sub problem we are going to choose the coin with the maximum value So currently the maximum value is seven okay so after choosing the 7 once again now the remaining value we have to create is going to be value number five because sorry value number four because 17 minus uh sorry 11 77 11 7 so 11 7 is give us the result four so now we will have to create value number four for that we still have three options but we cannot choose value number seven because it is too high we cannot also choose value number five because that is also too high so the next option is to choose four different $1 coin so in this case we are going to choose 1 + 1 + 1 + 1 so in this case if you see in total it took us five coins to build this value number 11 uh and we use the greedy approach but do you think this was the most optimal way to solve this problem no why because we already have a sub option where we could have choose coins like 5 + 5 + 1 and this would have also given us the value number 11 and even though at every suboptimal level we did not choose the most appropriate or most greedy approach we still found the optimal result in terms or three coins so you always have to consider that whenever you are trying to solve a problem think about it that will greedy would be the best solution or could there be a scenario where rather than using a greedy approach you can try to think of using a dynamic programming approach which is what we did in this scenario so greedy problem and dynamic programs they go hand in hand they're very closely correlated with each other but you will have to make that decision and you can only understand that decision after correct directly figuring out the given input so this is really important now let's move on to the next property and let's try to understand this with an example now the example is that suppose uh we are given an we are given a text okay and this text contains lot of different characters now we are trying to build an editor where inside the editor we are trying to put the encryption of some of these values so now we need to identify that which character should be encrypt so that the that those encrypted values would be easy to travel over the given Network and that would consume less space so let's say that if there is a character like um chloroform and there is another character called the so which character should I pick in order to uh compress or in order to encrypt of course at first glance we would think that chloroform is is a bigger word so we should put the chloroform in the encryption but the idea the better choice would be the why because the is more likely to appear at multiple places throughout the document so if we choose to encrypt this character it would give us more value so what should be the greedy approach in this case to decide that which characters should be good candidates in order to uh have them have them available for the encryption and one of the best approaches that what we we can still use the greedy approach in this case we can actually create a heap for all the characters by their frequencies and frequ frequencies means I can see that how many times they appear now we can have the condition that if any two characters A and B if they have the same amount of frequency then we would choose the character with bigger length so this is our greedy approach that if the if there are like let's say that there are 10 10 times character a appears and 10 times character the appears in the same document so the would be our first choice rather than the character a because the contains three different characters so if we encrypt that there is more value behind it and in the end we would be able to written uh using the Heap whatever the top five answers are those five would be the characters that are most repeated bigger in size and also give us the best value for encrypt encrypting our result so this would be one of the good example for greedy approach and basically this sums up most of the questions we had regarding our different algorithms so first of all I would like to congratulate all of you for making up until this far I know it was lot of information to take in but you took it like like a champ so congratulations on that now let me give you some of the popular rule of thumbs and some tips and tricks that will help you come to the conclusion faster in an actual technical interview manner so first one is whenever you identify any question that deals with uh hey give me top closest minimum maximum of K numbers out of the given total n numbers in that case of scenario always try to think that hey can I use a heap in this scenario because Heap will allow you to store the values based on their properties either like maximum values or minimum values and let's say that I I ask you that hey out of the given input data stream give me the fourth maximum or fourth largest number the approach would be to generate a heap to store all of those values and then start popping out values one by one by one until you reach to the fourth character and that would be the answer you are looking for so always think about that can I use Heap in these kinds of scenarios and most likely the answer is going to be correct with that approach now second thing is whenever you are given a binary a sorted array always try to do a b binary search in that that type of input because binary search is going to save you lot of time because binary search operates on log and time meanwhile the regular search operates in bigo of end time so it makes huge difference in terms of performance now next step is let's say that whenever you are given or you are being asked to compute the all the combinations and permutations of given various path choices always think that can I use backtracking or breath first search in such scenarios uh why I'm telling you this because most of the time there would be possibilities where you need you are given bunch of different input paths and you need to pick one correct path and many times you need to try out different paths and then come back to some previous point and then again try another path so for such kind of problems backtracking and breath for search are perfect uh also one more thing whenever you see any question related to trees or graphs try to think about solving them using either breadth first search or depth first search we already talked talked in quite detail that what are the difference between each one of them and what are under what circumstances which one to choose but either ways you would be able to come up with the solution by using either breath for search or depth for search because most likely you are going to Traverse over the entire tree or entire graph to find the optimal solution you are looking for so always trees and graphs equals to BFS and DFS that's a golden rule next thing is whatever solution you try to make if you make a recursive solution you can all also make the same solution using iterative approach using Stacks so many times it would happen that during an interview you are discussing you are uh brainstorming you are coming up with the solution that is a Rec recursive approach your interviewer is for sure going to ask you that hey instead of recursive approach can I do something else and you you can say that yeah instead of recursion if you use uh an iterative approach you can come up to the solution using Stacks so that is a very powerful tool and basically they both achieve same kinds of uh results on top of it many times if the recursion is long enough there you could encounter issues such as like memory overflow or stack Overflow and things like that so that can be avoided if you are going to use the iterative approach next thing is if any problem related to array that you can solve using bigo of n Square time I repeat if there is any problem using an array that you can solve in bigo of n Square time you can solve the same problem using n log end time if you decide to go with the Sorting approach and you can solve the same problem in big off end time if you decide to go with either hash map or hash set approach and we already saw examples of that using two some problem um and many other array problems so always arrays and be go of n sare time complexity try thinking about sorting the array or try thinking about using a hash map or hash set in such kind of scenarios next one is is whenever you see that you are being asked to optimize or do the find the minimum or maximum value amongst all of the given path and you need to do some sort of optimization most of the cases you would be able to come up with a dynamic programming approach that would be able to do things in much faster Manner and we saw that using coin change example where we were given bunch of different coins and we were trying to make a particular value so in that case dynamic programming allowed us to come up with a much better approach and much faster approach now next uh Golden Rule has to deal with uh searching or manipulating bunch of different strings now we all know that try is a data structure very closely associated with strings and whenever you are given this kind of scenario try to think that if there are multiple strings and I wanted to do many manipulations can I use a try and more than likely that would be the correct solution uh so these are the nine golden rules let me me give you the 10th one and the 10th one is actually that whenever you are given a link list and you are explicitly told that you should not use any additional space so IE you should not use any additional hashmap or hash set or something like that to store any extra computation in such scenario try to think that in the existing link list can I use a fast and slow pointer method because that would yield us the correct result and we I already showed you two examples of that first example is finding the middle of the link list second example was that finding that whether a link list has a cycle or not and both are pretty popular and widely known problems amongst tech tech interviews so these are the most common approaches and rule of thumb that should be in the behind the back of your mind so always make sure that you are following upon them now let's talk about what are the common pitfalls to avoid because many times you can do everything right and still get it wrong during the actual technical interview and for that it's not only about your technical knowledge but it is you need to have a combination of smart communication skills uh optimized thinking and also being able to come up with the solution in the given limited time management so there are lot of things so let me tell you that what are some of the common pitfalls that you should also avoid during any of your interviews so number one is always make sure that you are well prepared if you're not well prepared you cannot blame anything on anyone else because if you are not prepared and you go to a battle you are for sure going to lose and missing out any opportunity for a technical interview could be a career changing opport opportunity that you might be missing out you might be uh saying goodbye to your favorite job or your favorite company so please don't do that always make sure that even if you are an experienced individual you have like 10 years of experience still go through all the data structures once go through all the coding patterns once maybe try to solve two or three questions amongst each one of them on the lead lead code or hacker rank or there are a lot of resources available because preparation is half half the battle one so that is the number one thing I would advise number two is always try to listen to your interviewer first because many times interviewers are intentionally giving you a very small and very a complete subset of the original larger problem St because they wanted to check that can you come up with the thinking that hey what should we do in this kind of scenario or what should we do in this other kind of scenario are you asking the clarifying questions so always try to understand the problem fully first before diving deep into start going on and solving the problem uh because I have seen and I have personally experienced this many times that whenever I hear a question I would get too excited if I know the answer and I would try to start building and start coding and after 5 minutes the interviewer would be like hey did you think about this scenario and in those cases interviewers were actually expecting me to ask that clarifying question so always make sure that you do that number three suggestion would be always manage your time accordingly because you are only going to be given 45 to 60 Minutes to complete an interview and during this 45 to 60 Minutes you need to maybe uh introduce yourself so 5 minutes go there there would be 5 minutes in the end uh to ask any questions you have so you are essentially your interview time breaks down to only 50 minutes amongst these 50 minutes you need to understand two problems you need to come up with the solution you need to explain the solution you need to walk through all the edge cases you need to code the solution check whether your code has any errors or not run through run through it and uh explain the time and space complexity maybe explain different approaches and also say that why did you choose this or why did you choose that data structure answer those kinds of questions so there are lot of things that needs to happen amongst those 50 minutes so make sure that you are not you are managing your time correctly and you know that what are the cases you need to do and you are you need to prepare for on top of that that brings us to our next point do not Overlook the edge cases try to think that what if the given input does not have any value what would be the result then what if there happens to be like a million values for this particular uh use case or this particular input how would your solution approach that is your solution scalable enough or not are you considering all the edge cases so so think about those things and always make sure that you are taking care of all the happy path plus edge cases and my next step is do not write any messy code because many times you would be solving these problems either on a page like Google Docs or maybe if you are in person you would be solving it on a on an actual physical whiteboard where your all your thoughts and your code is all over the place and you get lost of track and you don't realize that where where you have written what and which method or which class is pointing back towards which instance or Which object and then it gets confusing so you that would cost you your time and also it doesn't look good on your uh on your personality as a coder as well next step is always say what you are thinking because the interviewer doesn't like awkward silences it's okay that you you first ask the permission that hey uh can I take maybe 30 seconds or 1 minute to think over this problem that is uh fine that is acceptable but if you are just sitting quiet for long periods of quiet time then those uncomfortable silences doesn't look good on your interview and also it sometimes the interviewer gets the impression that maybe you don't know the answer or you are getting confused always say what you are thinking on top of it always reach out to interviewer if you are stuck at anywhere I have seen at lot of places uh where people don't raise their concerns and if even if they are stuck they don't voice that uh where they are stuck and what are they thinking most of the cases it is acceptable uh and interviewer also predicts that that you might get stuck at some place and they are there to help you they are it's in their interest that you get a job because an interviewer has so many things to do throughout the week and if they are spending 5 hours just speaking with five different candidates it is a major wastage of their time so they want uh they want to have a good candidate who have solid understanding and they would be more than happy to help you out to reach to that end goal but in order to do that the precursor is that you should be able to speak out loud and always mention that what is your thought process how are you processing the problem and what are you currently thinking what are the different options are coming that are coming to your mind so always make sure that you are voicing your thoughts next thing is at least be familiar with one of the programming language it could be Java python go JavaScript whichever you choose make sure that you at least have good command over at least one program programming language because you at the end of the day you would still have to write the code in any language so make sure that you have good understanding of different programming languages also don't become flustered or don't become frustrated if you make any mistakes let's say that I ask you a question and then you started solving and then you went on the wrong path and you went keep on going for five minutes before interviewer corrected you and then now you just you just feel burdened that I wasted 5 minutes on top of it I was not able to come up with the solution and interviewer had to point me back don't think about these thoughts have these thoughts after you done with the interview during the interview just stay focused that okay now at least you have the correct course now let's uh think about moving forward and reaching to the end line and finding that correct optimal solution so that would be the number one thing that your that should be your focus and coming up with that is don't give up even if you don't know the solution at least try to come up with a Brute Force approach see that what would be the most trivial most preliminary approach you can take and once you have the Brute Force approach then you can start building on top of that for that next block or try to see that why brute force is not optimal what are the things it is lacking are we doing a lot of repeated work can we use something else um maybe it's an array and we have to search it all the time in order to find a value can we use a hash map so things like this will pop up if you at least have the basic Brute Force solution so if you can't find any of the Optimal Solutions at least start with the brute force and interviewer would help you navigate through your thought process as well so that would look at at least in better condition that even if you did not knew the answer you still attempted and at least went as far as you got so that that will that can also work in your favor next thing is that do not fail to optimize your solution because many times you would think you would be thinking that hey my solution is the optimal solution and this is the best I can do but try to think about scenarios that okay can can I do better in terms of time complexity U maybe I'm using an additional space can I reduce that additional space and improve upon the space complexity ask these questions to yourself and also voice their answers in the interview towards the interviewer because many times let's say that you are building a great solution or you are using Dynamic program pramming and in order to do that you are actually using an additional hashmap to store all the results but as it turns out that you don't need to store all the results maybe you just need to store couple of results so rather than spending resources on creating an entirely new hashmap you can actually just have two variables and those variables can go through and solve the problem that you that was needed so these are the optimizations is what interviewer is looking for and if you can do that you would be a great candidate in everyone's eyes and the last note I would like to give you is after our interview is done make sure that within 24 to 48 hours at least you are sending a thank you note and after 3 to 5 days you are at least asking that hey what is the status on my application uh maybe they are interviewing other candidates and they haven't made the decision but still you do not want yourself to be uh hiding behind the scenes and not appear at least uh connect with them write a nice thank you email saying that hey thanks for the giving me the time I really like the interview process I learned a couple of new things and whatnot and it it's always going to look good imagine if you are an interviewer how would you feel if the candidate actually sends you a message and saying that thank you for giving me your time I find it productive of course it's going to bring a smile to your face so think about these things and uh I wish you best of luck in your Tech preparation Journey so now we are at the last piece of our our entire course and it has been an incredible journey for me I hope it has been productive for you as well now let me give you some of the important resources that would become quite handy whenever you are trying to prepare for your interviews so first resources at least get a lead code account I'm not saying that get a lead code premium account if you have the financial means for sure if you cannot still at least get your lead code account in line uh and there are some other websites like code Chef hacker rank geek for geeks they are also quite good so if you want you can check those out as well but in either case build the practice of solving the questions and the tech interview questions now first confusion comes in whenever you are you start grinding lead code is that lead code actually has more than 2,000 questions and you are not going to do all of them so the question comes that where can I find the curated list of important questions so I have actually created one list where I have listed down 125 most Tas most uh popular and most like problems from the lead code on top of that I have also curated the data associated with that which means that for any particular question how many companies have asked this that question and how popular that is uh also what is the difficulty level so I'm going to link that uh Google doc in the description as well and that is open to public so anyone can use it that can be a good starting point if you want there are other list available as well like blind 75 or need code 150 they are also pretty good so if you can you you can use that resource second resource I would recommend if you like to read stuff this is a great book that cracking the coding interview this has been the Bible for all the tech interview preparation so if you can buy the book if you cannot there are online copies available as well so you can read those uh and one last thing is don't stop practicing and if you can find a mock interview buddy or group of buddies or some friends or anyone there are some online forums available who also conducts mock interviews because by doing a mock interview number one you would alleviate the pressure of actually being in the interview this would be like a net practice for your actual technical interview preparation Journey uh and if you are playing the role of an interviewer during the mock interview with any of your friend you can also imagine that when your friend responds how as an interviewer you you are also considering or you are also thinking that this is what he's doing right and this is what he's doing wrong and you can build a sort of an expectation that how should I approach any question from interviewer's point of view and that would become that would become greatly advantageous um whenever you are actually appearing for your interviews also if you cannot find Solutions there are very good YouTube channels available so if you want you can go to my channel destination Fang or otherwise if you want you can also go to a channel called need code he is pretty good uh and there are channels by hacker rank that is also pretty good so there are lot of resources available there is no shortage of it uh the only thing is you need to keep on grinding and keep on preparing yourself now at the very last moment I just want to take this time and say thank you thank you to all of you because of your constant motivation I was able to build and make this entire course this is something I never thought I would be able to do but it has been an incredible experience so good luck with your journey and take care