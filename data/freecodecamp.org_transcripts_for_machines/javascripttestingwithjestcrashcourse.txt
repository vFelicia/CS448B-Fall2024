welcome to this comprehensive video course on JavaScript testing with just a powerful and widely used testing framework this course covers just features and capabilities and will teach you how to write run and organize tests efficiently to enhance your JavaScript projects popular teacher Tommy too created this course hi there and welcome to this course I am Tommy from free code camp in this course you will learn how to use just to test your JavaScript code just is a power testing framework for JavaScript and in this tutorial we will cover everything from the basic concept to mocking and also in synchronous testing by the end of this course you will have the skills to implement just into your project confidently now let's get straight into this course so now the first thing that we're going to do is to create a folder where we're going to be doing all our work so right now I'm just in the root directory of my computer I'm going to go into document and in there I'm going to go into my project folder and I'm going to create a new actually I'm just going to create a new directory named so I'm just going to say mkd i r just course and I'm going to go into just course now if I press LS to see everything in this folder you're going to see that it's blank so what we're just doing is kind of like creating a playground where we can experiment and see just in action so this is just the folder right here and as you can see I named the just C name it whatever you want to name it and yeah so now the next thing that we're going to do is to just like initialize a new mpm project so what I'm going to do is that in here I'm going to say mpm in it so this is the normal command you use to just initialize a new project but I'm going to add i y now the reason why I add i y is like a shortcut to answer yes to all the prompt so once I run mpm in it if there's any prompt that's going to come up once once I put i y right here it's just going to bypass all of that and answer yes so just so we can have like a default setup and also like a quick setup I'm going to hit enter and now that is done if I press LS again you can now see that we have a package.json file right here so what I'm now going to do is to open up this just C folder inside my vs code I'm going to swipe to vs code right here and what I'm just going to do is to save file open folder and then I'm just going to look for my vs code right here so right here in just going to try to find my project test course I'm going to open this up so right here as you can see so right here as you can see we have opened up just course and this is the package. Json that we have right here just a normal mpm project now what we're just going to do the next thing that we're going to do after doing that is to now actually install just into this particular you know this particular project so for us to install just um the next what we're going to do is to run mpm install two I say save dev then just so the reason why we choosing just again is just for it Simplicity and it's Rich pictures so just is like I think the most popular know frame or library that we can use to run JavaScript tests and that's why we're using just for this course so this is the command that you're going to use to actually install just into this project that we just created and now what I'm just going to do is to click on enter and that is going to start installing just into this project now as I said it's going to install just locally into this project and it's going to add it to the dep dependency in our package.json if I come here there's once it's done you're going to see something named Dev dependency and that just means that it is this particular library that we're installing is essential for the development of this our projects but is not essential for running the actual application so you don't really need to know all of those details what you just need to know is that what we are running right now is to install j into this project and now once that installs you're going to see a new folder here is going to be created named node modules as you can see that was created but let's wait for it to properly install now as you can see everything was installed successfully it added just so it says added 292 packages and found Z zero vulnerabilities which is what we want now if I come back in here let's verify that this installation actually worked so now we have a package look. Json and then we have the actual package.json so first if we come in here you can see that we have a node module folder this means that we actually installed a particular library or a module and in this package. Json once I come in here the dep dependencies I was talking about initially this is it right here so once this has been added under here you can see that we have just added to De dependencies now this just confirms that just has been added successfully as you can see so now that just has been added successfully the next thing is to actually configure our npm script to run just when we want to execute tests so what we're going to do is to just open up package of Json and change some stuff so npm scripts are convenient shortcut we can set up to run specific commands so we're going to set one up now for J now I'm going to open up package.json and right here this is package of Json is like our project manifest so let's just modify it to run test using just now on here what we're going to do is where we see I just come here where we see test so under script under the script section so this default tests we're going to change it to just going to say just right and then what this does this means that whenever we run the command mpm test it's going to use just to execute that test now this is what we want to do we're just going to save this this is what we need to do and then now with our setup ready we can dive into just and dive more into how we can actually run tests using this G now let's go into the basic concepts of testing with just so now that we have set up just and we have everything done the next thing that we want to do is to write our first test so this is going to introduce us to the fundamental concepts in just now what we're going to do is that we're going to write a very simple unit test and before we move forward let me explain what unit test is so unit test is the process of checking small pieces of code to deliver information early and often so when we are testing when we are doing or running a unit test it means that we testing small blocks of code so things like basic functions or basic classes that is unit testing now the reason why we do this is so that we can easily identify errors or any box that's going to come up right from the scratch so that instead of testing the whole code when it's done and that is going to be harder because once we get an error it's going to be harder to actually find where the error is coming from but unit test allows us to easily get or capture this error early on while we're still you know doing our basic functions and basic coding blocks now we're going to run a basic unit test using just and let me show you how to do that now the first thing we need to do is I'm just going to close this and right here I'm going to create a new file named sum. JS now this sum. JS is actually a Javascript file where we're going to be writing a function that is just going to add two F add two numbers together and return the addition or the sum of those numbers and I'm going to create another file named sum. test.js now this is a test file so once we write the actual function in here we're going to kind of like export that particular function and we're going to retrieve that function in this test file and then we're going to actually run the unit test so now what we're going to do is to come back in here and right here in sjs I'm just going to write a basic JavaScript function so I'm going to say function I'm going to name it sum just increase this a little bit and I'm going to say it's going to take two inputs A and B and we're just going to open and close that function and that function is going to return the sum of those two numbers so it's going to return a plus b now the next thing we're going to do is to actually export this particular function so that it can be used by other files in this particular directory so what I'm going to do is to say module. export equals to sum and I'm going to add my semicolon very important now that I have all of this done the next thing I can just do is to actually run a test so the first thing I just did is just creating this basic sum function taking two inputs and it's going to add those inputs and return the value or the sum of those inputs now I'm going to make as I said using this mod export equals sum it makes this sum function available to other files like this test file in nodejs right here so now I'm going to access this particular function in this sum. test.js and I'm going to run a unit test right there but now what I'm going to do is to just explain how this works so as I said we're using just and when we say sum do test.js once we add test before adding Js JavaScript automatically knows that we're trying to run a test so it knows that this is a file dedicated to running tests now what we're now going to do is to say const sum so what I'm doing is I'm using require to import this sum function into this test file so I'm going to say equals to require and I'm going to say dot SL sum now this Imports it into this particular folder file and now I can actually run the test so I'm going to say test not this say test and now this is going to be a description so this comes in two so it it has like a pair so once we run test and we have a bracket I'm going to have right here I'm going to write the description so I'm just going to say description and right here after the description I'm going to have like a test function I'm just going to leave it like this and we're going to come right here to now add an actual description so what is the description of this function so what are this test that we're going to run so we're going to say it adds 1 + 2 to equal three so what we're going to do is that we're going to run a test by giving so I'm going to come back in here so we're going to give it this values of one and two and when we add one and two theoretically this function should return three because it's just adding one and two and it's giving us three and that's what we're going to say in here so the description is saying it adds one and two and it should equal three and then after having the description now we're going to have the actual function so to have the actual text function so we're going to come here and do this like this and equals to the greater than sign then we're going to open the function and then we're going to say expect so expect some now we're going to use that function one and going to give it two one and two and we're going to say 2 B so this is like another pair and it's just saying once we run this one and two function the answer should be or the response should be three and then we're going to have our semicolon to close this and we also need to come here and close this now this is all we need and let me just quickly explain this particular code once again so now what we just doing is we are importing this sum function from here so we can run test of about that function and then we are basically introducing this test right here which is a like a a global case for defining a test case right here in this test function and this structure which is the description and then we have the actual function right here and the last thing is that we did is to input the pairs so we have the expect and 2 BP so as I said expect means we expect that once we run this sum function and give it these values the response should B three now what we need to do is to now just run the test so for us to run the test and get the results we have to save these two files make sure they are saved and then we're going to pop up a terminal right here and then all we just need to do is to make sure we're in this folder yes we are so let's just clear that and now we're going to say mpm test so as you can see that test didn't go through it says Echo error no test specified so that means there is a problem when we set up our package.json I'm just going to close this up and close that so right here where we have script just and we say all of this so as you can see it's basically giving us this error message that is what was given to us right here no test specified now this is because we replace the test with just instead of the actual value so this should be test the the key should be test not just and then the value should be just so we just need to rectify that error and once that is rectified we can close this open up that terminal again and now we can say mpm test and let's wait for that to run good as you can see it says one test is passed one total and as you can see one passed one total so it run one test in total and out of that one test one was passed so basically everything that was run was passed and snapshot zero total and this was the time it take to run to run the test and as you can see this is the main message we looking for pass some. test.js it adds 1 + 2 and it equals 3 so as you can see right here we have successfully run our first unit test and this is how we can use J to easily run a test or unit test right here in JavaScript so what we just did was to create a simple function and then we wrote a test for it and run that test now I'm going to emphasize how understanding this foundational concept is crucial for writing more complex test so this seems like a very easy and the most basic test you could write but it's actually crucial and important that you understand how to write basic test like this before you can go ahead and actually run more complex and advanced tests so we're going to be talking about matchers in just and matchers are just used to test different type of data so they basically let us assert values in different ways so right here this is a matcher this to be right here so when we have the function or the test function this is the test desription right here we have the test function so we have the expect and then we have the matcher so these 2B is one type of match there are various type of matchers there is Tob to equal to truy to faly to throw I'm going to talk about every single one of this right now the first one I'm going to talk about is to be and that is what we already I've already shown you in the initial example that we did now as you can see right here what this is is just to be and we saying sum 1 + 2 to be3 so what we're just going to do is to get rid of this and I'm just going to start again and show you how the 2B matcher actually works so what I want to show you is to Tob is basically used to for primitive values so values like numbers strings and booleans that what Tob is for and I'm going to show you what I mean by that so now let's just quickly write a simple test but we don't need to import any function from some. JS we were not really going to be working with this file for now we just going to be doing everything from here cuz I'm just showing you basic examples so description we're going to say 2 + 2 is four and then right here we're going to have to have open and close bracket and then we're going to have to a function now we're going to say expect 2 + 2 to B four now what this 2B is going to do if 2 + 2 is four then it's going to tell us the test has been successfully passed but we only use this 2B when as I said when we are dealing with values like numbers strings and Boolean so this is a number if it was a string if it was anything dealing with string or Boolean we're going to use Tob also now if I open up my terminal let me just make sure we save this let's bring back that terminal just going to say mpm test again and this is going to run successfully it says one pass now that is how we use to be right now the next thing that we're going to talk about is to equal so to equal is used when comparing the values of object or arrays right so what I'm going to do is I'm going to create basically a new dictionary in here so let's just say test let's create another one and and let's say something move this and let's say something like object assignment open and close and right here we're going to create a new dictionary we're going to say data equals I we just say one I one right and then right now what I'm just going to do is to say data two just giving it another value equals to two now we expect that the values of this data dictionary now should be 1 col 1 comma 2 colum 2 because we added a new key value pair which is two and then two right so that what we expected but in this case we're not going to say to be so I'm going to say expect data so we expect this data now that we created here we're going to say dot to equal so we expect it to equal now we can just type in what we need 1 col 1 and then 2 2 so this is what we expect it to be going to keep this spacing add the semicolon now come down here and add the semicolon so now I'm not going to say we expect this two be this because we are not like dealing with directly dealing with primitive values like numbers or strings this is an object basically so because we are dealing with object or arrays or anything like that then we have to say to equal now what we're just going to do is to come up here and then we're going to say mpm test again and because everything should be working successfully it says one pass one total now as you can see what this basic JavaScript code does is we're creating this new object name data and then we are now inputting another value in there as 2 col 2 so now the total value of everything that should be in data should be equals to this because it is equals to that that's why that particular test was passed successfully now we've talked about two be and we've talked about to equal now the next match we're going to talk about is the truthy and falsey matchers I'm just going to demonstrate how to test for truthy and F falsey values in just so the first thing we're going to do is to test for truthy values no we're going to test for FAL falsy values the first thing so when we're testing for faly values so the way we test for faly values is just the way we say to equal right here we're going to say to be FY and this doesn't really work in this situation but we're going to change that so I'm just showing you how you're going to test for it so I'm going to write a code now that is going to test that we're going to have to use this to be FY now we just used faly to check if a value is n undefined if it's false if it's zero if it's blank if it's n and or as I said undefined so that is what we use falc for and let me show you an example so let's just start test go back and we're just going to say no is falsy and then like this to and now let's say const nals to no so n is no and then we're going to say expect n do to be faly so because n is no we expect it to be faly so this should be this test should be run successfully as I said to be FAL is is to check if a value is not undefined ver false zero blank or n n now because this n is no this test should be true and it should run successfully so now let's pop up that terminal once again and then let's run mpm test it enter let me expand it you can see it has been passed successfully now this just shows that to be FC worked now on the other hand the next thing that we can check is TR to be truthful to be truthy so before we go there I'm just going to show you one more thing so as I said this is not just only for when is no if n is zero or n is false or n is any of those other values is going to also be true so let me just say let me say 0o is faly so I'm going to give this a value of zero now n is zero so now we're expecting n to be falsy going to save it if I run that again mpm test you're going to see that that run successfully now as I said next thing we're going to do is to check to be truthy so what we're just going to do is I'm going to show you how we used to be truthy to check or to test if a value is like not any of this so basically if a value is not falsy it is truthy so we say this is zero but if I say one because that is not falsy and I say to be truy right here and then what I can just do is to say Z is one trophy now this should run successfully if I come up here and say mpm test one should be truthy and we say one passed now if I change this back to falsey so you just see that it's not every time that actually passes if we make a mistake it's not going to pass now once I run this you're going to see it says one failed one total this is because to be FY should only be true or should only be successful when the value of of n is basically any of those PR any of those values zero you know false you know undefined null any of those stuff like that now the last thing that we're going to be talking about in matchers is error handling with to throw so what we use error handling for is just to determine whether a function throws an error and just the way we have to be FY to to equal and all of that we have to throw for you know checking error matches that's what we for checking errors basically that's what we use that for now I'm just going to show you how to use this practically so for us to basically use this practically what we're going to do is to write our own test again and once we write the test I'm going to show you that once a particular error is thrown or an invalid input is thrown then it should give us that error so the first thing I'm going to do is to make sure that you understand the to throw so the to throw so it's going to say like this to throw that's what this is and as I said is used for error handling so it's arror handling is a very essential aspect of testing in JavaScript in general so particularly when you expect a function to throw an error under certain conditions and it should throw that error that's why we want to test to make sure those errors are being thrown now as we are using just in here it provides us this to throw function so we can use this for this purpose and this basically helps us write test that verify whether a function throws an error when it is called so for the to throw specifically so this match in just is used to test that a particular function throws an error when it is executed just as I said now this is particularly useful when you're testing functions that are designed to validate input and throw errors when the input is invalid so let's do that right now so I'm just going to write a basic syntax of how to use this to throw and we're just going to say test nope and then we're going to say throws on invalid input right here open and close enter now we're going to say expect and then what we're just going to do is after expect we basically want to have something that throws an error so right here well we need to do say put one up in here so we want to do this actually we we don't because we already have so right here in expect we have open and closed we need to make sure the syntax is correct so we open this and I have another one in here this now we can hit enter and then we could just say for now let's say my function inval input and then dot to throw right here so in this example my function is a function that we are testing an inv valid input is some input that is expected to basically cause the function to throw an error so what we need to do is to write an actual function for this my function so what I'm going to do is to say going to save this we could write that function in here or we could you know write it outside and just import it in here so what I'm just going to do is to write a function to write another function and I'm going to name it my function and it's just going to take an input so we're just going to say if input is invalid we're going to take care of how to get if the input is invalid so if the input is invalid what we want to do is to basically do something in here we're going to throw not here right here throw new error we're just going to say invalid input so how do we check if the input is invalid so we'll say if type of input is not equals to A number that means in this case that input should be invalid if the type of the input is not equals to number so what we're just going to do is since this type of input is not equals to number then that should be invalid for us and and we're just going to have to export this particular function to just the way we exported the form the sum function initially just going to export that and then right here going to come back to just and we're just going to say const my function equals to require just slash sum we're going to sa my function so now we can use my function in here because we've already imported it from here so we exported this we don't really need this we could get rid of all of this and we could save this just make sure we're copying this correctly function and my function so now we can basically use all of this and what this does is if the input is invalid then it's not going to work so what we're going to do now is that right here in sjs so this invalid input uh we don't really have any value we giv it so I'm just going to give it like a string and let's save it now let's open this up and then let's say mpm test and let's see and it failed and let's see why it failed it said TR mode not found now this is because right here we're getting the sum file so this is saying do/ some. JS basically and then we could give it my function so now let's run this again the mistake we made was we changed some to my function and when we change some to my function there was no actual there was no any file here named my function so it gave us an error but now we got this my function from right here from do/ suum so that should work so as you can see now it passed it says throws on invalid input now because that input is invalid it throws that error for us because we are expecting a number but now let's say we actually put a number let's save it and then run npm test again so now as you can see it said one failed now why does one fail this is because this is not actually an invalid input this is a very valid input because we the for it to be invalid it needs to be not a number but this is a number so it's not going to throw an error that is why that failed so that is basically a summary of matchers in just and that is why why we use matchers and why matchers is actually very powerful in testing in JavaScript in general so now we are going to be testing a synchronous code in JavaScript so testing a secon code is quite complex and is um it's not as straightforward as testing normal functions that we've been talking about and writing this whole course so I'm going to show you how we're going to be able to test a synchronous code and it's actually quite vital and important that we know how to test a synchronous code because a synchronous code is used the law in JavaScript and it's very important so let me just show you how just makes this straightforward but before we do that let me just quickly explain the concept of a synchronous code so a synchronous code in JavaScript allows for executing some operations in the background and not blocking the main execution thread so this is crucial in JavaScript especially in web environments because it keeps the user interface responsive while handling tasks like networks request file operations or timers so there are different ways that we're going to different free method in testing a code ingest which are callbacks promises and async/await so I'm going to first start with telling you or showing you how to test callbacks so the first thing that we're going to do is to actually create a basic callback function in here and let's get started so right here in sjs I'm just going to get rid of all of this and then what I'm going to do is to just write a very basic function so this function is just going to as I said be a call back function and then I'm going going to show you what we're going to do to test it I'm just going to say function let's call it fetch data and the call back going to open and close that function and let's set time out I'm going to explain everything that this code does in a bit so then we're just going to open up that and now we're going to call back like a result so for this result let's just say something like peanut buttter let me colon and down here going to set it to like let's say 1,000 and now we can just add our semicolon right here now let me explain what this code does real quick so this is uh basic basic as I said a basic function and the name of the function is fetch data so what all of this does is that it kind of simulates a delayed operation so like an API call using set timeout and then it calls a call back with a result so once the API call has been done or whatever operation we are doing has been done then it calls a call back with your result in this case the result is pin Not Butter so that's what this basic code does and I'm just going to show you how to test that this code Works using just right here now before we go straight into testing this the first thing we need to do is to make sure that we're actually exporting this PCH data function so that it can be available in here in the test file so to do this we're just going to say module export equals to fetch data so now we are exporting fetch data and when we require it here this is going to allow us to just use that particular function let's get rid of all of this and now let's just write a basic test file basic test code that we can use to test this so let's say test and let's say Okay nope this is not what we want let's say the data something like the data is p not and then we can say done this done is very important again I'm going to explain what this code does then going to open that now we're going to write a function we're going to say call back going to take the data and right now we're just going to open this function and close it and we're going to have a try accept can say try open and close that I'm going to say accept data do 2b peut data PE but now we have to call it done so we have to call this done so just knows that we are done with what we're doing and then down here say catch so this is a try catch syntax error to catch any error then open and close that and say done error that easy close this and then right here fetch data is the function that we created right here fetch data and then we're going to say call back and then we're just going to add a semicolon right here like this now once again this is just a basic code that is testing for this and and I'm just going to explain what this does so first of all we require this particular fetch data right here from here by just importing this/ sum which is sum. GS and then we're just giving it a description of what this test is so we're saying that once this test is run the data that is being outputed should be pin data to write whatever you want to write here this is just the basic description so yes and now what we're just doing is to specify and once we have this call back function right here once we say we're trying and remember the matches to be and accept so accepting the data and we're saying it should be P not butter and once we are done with that we need to add the Dum parameter which we did right here so we need to add that D parameter because it is used for callbacks that's what we did here but now we also need to specify it here it's important in calling that done function to signal to just that the test is complete so that's what we did right here and that's also what we did right here so now we're just going to go ahead and actually test this particular or run this particular test bring up my terminal and what I'm just going to do is to say mpm test going to hit enter and now let's see so it says one test failed and let's see why the test is failed this is because it says reference except is not defined so let's go back can see why this is expect not accept now let's run that again and now everything should be working fine good as you can see it says pass right here which is what we need and it says the data is pin not data which is good say one pass one total so the amount of test we run was one and out of that one one was passed this is the time it used to run that test so everything is working successfully now in testing for callbacks now we are going to be testing for promise based functions so without wasting anytime let's just get into it so let's close down this terminal and we're going to come back into some. JS we could change this name to whatever we want but just let's just leave it at su. JS and what we're going to do now is to as I said test for promise based functions the first thing we need to do is to First write U we're going to introduce a function that returns a promise which resolves after a delay so let's do that right now so once again get rid of all of this right here and then I'm just going to say function let's just name it fetch promise and then we're going to open and close that function and we're going to say return new promise so once again um should have a basic knowledge of JavaScript to be be able to follow along with this tutorial cuz this is for people that already know JavaScript and want to learn how to test their JavaScript code so we're going to say resolve reject and so this resolve and reject just shows that it can be resolved and also rejected and I'm going to show you how we test for both if is resolved or rejected now what we're going to do is and close that we're just going to set time out this then we're going to resolve let's just give you the same thing we gave the last code we're going to say p Not Butter say th000 that all right here we're going to have the semicolon also now this is the basic code as I said this is just a basic you know from promise a basic function that returns a promise and as I said it resolved after a delay so now what we're just going to do is to make sure that we export this out so that it can be used in our test file so module. export equals to fetch promise semicolon now we're going to come and test this for us to test it once again the first thing we need to do is get rid of all of this and let's just say con going to say f promise equals to require so don't allow we're just going to say do slash sum and now we're going to write the test so we're going to say test this is actually quite straightforward test the data is peut butter and right here we're going to open and close to the same here and now we're going to return so we're going to say ex fetch promise so we're expecting a fetch promise the resolves so if everything works fine 2B why ising the 2B matcher and we expect it to be what it is right here P bottom so peanut butter and we're going to add a semicolon now let's save this and what we're just going to do is let's make sure we have our semicolon right here this is basically what we need and let me just pop this up and run mpm test now let's see what happens it should be passed as you can see it says pass this is because everything works successfully once if this is resolved right here it gives us pin up butter that happens but now let's just assume that fetch promise can also reject because of course it can resolve or reject now let's add a test for if it rejects so say test the fetch fails with an error something like that and then we'll just going to do same syntax and we're just going to say return expect fetch promise going to say do reject now we're going to say that to throw remember when we talked about the to throw matcher for if there is an error now we're using that right here and then we're just going to say error right here so right here is the way we can write test for if the data so let's just spell this correctly the data is successfully resolved or if the data is rejected so this is the basic way we can just you know as I said write test for for promises for functions that uses promises so it helps handling in handling resolved and rejected promises respectively now I'm going to show you how to test with async await now we don't even need to write any new function right here we already have an asynchronous function right here so we don't really need to write any new function I'm just going to show you how to use a sing await to test this promise function that we have right here so what I'm just going to do is to come back in here clear all of this I'm going to leave this out so we don't need to rewrite that and I'm just going to write every the code out and then I'm going to explain it to you in detail because this is very crucial for you to understand so the first thing I'm just going to do is to write a new test just as we've been doing we're just going to say not this test say the data peanut butter and now we're going to say a sync so a sync just basically signifies make sure we're writing that well it basically signifies that this is an asynchronous function that's what async does and now we're just going to open that up and we're going to say con data equals to await so AWA is is using tandem is using constru con is used alongside as sync So when you say a sync you should write await right here this just means that we are waiting for the promise to resolve before making any assertions so what we're just going to do is to say fetch promise and expect data and then we're going to use the 2B matcher peanut butter right here and then we do this so this is just what we need to basically test this out and what I'm going to do is to explain as I said in detail what this does so first I'm going to talk about this async right here so as I said it signifies once we have this async function ASN keyword before the actual function it signifies that this function is going to be asynchronous so it's like signal to JavaScript that the function can pause and resume at some point and especially to wait for as syn fonus operations to complete that's what that does and in testing this is very useful for handling promises returned by the code that you're testing so as you can see we use that to handle this fetch promise function now let's talk about this await now this await is a keyword that that is used alongside a sync so when you use await before a function or a promise what you are just saying is that you're telling JavaScript to wait till that promise settles and returns its result now what we need to do is to understand why what this await does so is used as I said to pause the test until the asynchronous function resultes so when we say this await is going to pause the test the test is not going to go on until we get a result or this promised function is being resolved so that is what that helps us to do and this I think a way it basically just leads to more readable and cleaner test code and that is why we use this most of the time and I'm just going to run this and show you that it works so I'm just going to say mpm test and right here you should see it says fast but that works successfully and that is how to use a sync await in testing now let's talk about mock functions and spice in testing so in unit testing I isolating the component being tested is very crucial and this is where mocking and spying comes in so mocks are fake implementations of real functions and spies are tools that are used to track the behaviors of those functions so they track behaviors such as whether the function has been called or how many times it has been called or with what arguments the function was called with now as I said mocking is used to isolate the unit of code being tested so it basically allows you to replace a complex or slow or unavailable dependency with simpler versions and this isolation prevents tests from being affected by external factors and makes them more reliable and faster to execute so let me give you an example of why and when we can use this so I'm going to give you an example of like a database call so pain this scenario imagine you have a function that calls a database now testing this function could be problematic because it involves Network calls database setup and stuff like that but by mocking the database call we can simulate Its Behavior and focus solely on testing the functions logic now this is why testing using mocking and spice is very important now let's create and Implement mock functions using just so the first thing I'm going to show you how to do is to use just. FN so just. FN is a way of creating a mock function and it can be implemented to return a specific value of perform a specific action let me just show you what I'm talking about so right here in sum. test.js I'm going to remove all of this and I'm just going to write const let me just say something like Mark call back equals to just FN now we're creating a mock function by saying just FN and let's just say x equal 42 plus X so as you can see this is a basic function and let's say I call this by saying mock call back and I give it zero now you if you understand JavaScript you know that this is just going to say 0 is equal to X so that means 42 + 0 is = to X so the new value of x will be 42 if I do the same and say call back one now this is just going to be 42 + 1 which is 43 now this is just a basic way that we just created a mock function but now I'm going to show you how to test for a mock function by using just so just going to get rid of all of this real quick and I'm actually going to write a real test now I'm going to say let's remove that and let's give it a description and the description will be something like mock implementation so this is just like a mock implementation let's say of a basic function and now that function just write this out that function open and close and now we're just going to create that same 42 plus X that we created initially and I'm just going to say const so as you can see right here we're not actually doing anything with the sum. JS because we don't really need to do anything here I'm just showing you how to implement a mock function right here so we're just going to say mock equals to just now we're going to use just FN and now we're going to say x is 42 + x as I said this is a very basic function we're just going to do is going to return 42 plus whatever value that we give it is basically what we want so now the next thing that we just need to do is to say expect more Mark and we call one we expect it to be do to be 43 so what this is just saying is that if we call this mock right here and give it a value of one or argument of one the what should be returned the value that we should get should be 43 and that is because once we give it one it adds that one to 42 and it should be 43 so let's make sure this is 43 give the semicolon and for now let's just save this and I'm just going to pull this up and right here what we just need to do is to say mpm test now when we say mpm test just as you can see it says one Past One total right now this is just a very basic way of using mock functions but we're going to do one more thing I'm going to introduce to you to have been C with so is it's kind of like another match up we haven't talked about this match up before I'm going to show you what this does right here so it's going to let's just say right here I'm going to say expect Mark do to I've been called with the H one now let's also add this semicolon here now this statement what it just does is that it checks that the mock function was called with the correct argument so if this assertion failed then just to provide an error message indicating what went wrong so what we're just doing is to make sure that we call this with one because we did call it with one right here we said mock one so this is just saying we're checking that mock should have been C with one we're just going to do the same thing that we did run mpm test and everything should also work successfully nothing went wrong so this is just a very basic way of using mock function for testing right here in just it's very easy it's very straightforward now I'm going to show you how to use just do spy on ingest so we're going to use it to spy as I explained earlier in this tutorial now what we're just going to do is right here in some. test.js I'm just going to go straight to writing this test I'm going to say test not this going to say spying on a method of an object we're going to create that right now and we're just going to say equals this and we're going to create this and we're going to say const video equals to I'm going to open that up and say play now we're going to open this play function up too just say return true right here and now we're just going to comma and right here we're going to add our semicolon now we're going to add just the spy on and why we're adding just the spy on is basically like tracking this particular video right here so we want to track and see if this play has been called in this video so what we're just going to do right here is to say con spy was just do spy on we say video and we're going to spy on play write that and we're going to say video do play open and close and add the semicolon and now we're going to say expect spy do two have been called and what we're just going to say spy. mock restore now this is just a basic test that we writing to track so let's get rid of this we're writing to track and make sure that this and track if this play has been displ function has been called right here and that's what we're just doing is we're saying cons spy we're saying just dop so this just dop is just a method to track CS to video. play so we're tracking when this video. play has been called and just the spy on this spy on right here it does not replace the functions implementation unlike just. FN that we talked about earlier so this allows us to observe the functions real Behavior now what we're just going to do is to just go ahead and run this and just going to save this and then going to pop up the terminal all right you are just going to say mpm test just going to hit enter so let's go back to terminal and hit enter as you can see it says one passed so that means it has been done successfully so as you can see everything works and let me just quickly explain this cuz we didn't talk about this so so expect spy. to have been called with so this line will check if the play method was called so this basically validates the spies functionality that we created so that's what these two have been called with does and the last thing we're going to talk about is this spy mock restore function so this spy Mo restore function in just is used to restore the original implementation of that function so the function that has been spied on using just do spy on this that is what is being used to restore the original implementation of that function now when we create a spy on a function just basically replaces the Spy function with a mock function now this allows you to like track calls argument and return values of that function but in some cases you might want to revert the function back to its original implementation that is why we use spym restore and that is what we did right here so that is the end of this tutorial and I hope you understood everything we did in this tutorial if you did please don't forget to click on the like button and subscribe and I'll see you in the next one