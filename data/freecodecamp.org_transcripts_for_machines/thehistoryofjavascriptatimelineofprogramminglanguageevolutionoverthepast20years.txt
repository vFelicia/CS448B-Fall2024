tonight i'm going to talk about what i'm calling the modern web and i mean that from a user's experience as well as a developer's experience so i'll try to refer to that back and forth basically i want to talk about how this rich javascript ecosystem developed and kind of some of the big milestones along the way and then i'll show a couple samples of how that used to look and how it looks today a little bit about me i work at vmware i am a user interface engineer on the clarity design team and the clarity design system is a tool kit of ui guidelines and resources as well as a ui javascript html component library and then the really advanced components are actually written in angular so that you can add data and functionality and really make them work with an angular app internally they're heavily used throughout vmware's products so we kind of evolved the project with a focus on the enterprise and that kind of led us to take a different approach to our design system because we were starting on the desktop and degrading for mobile because most of our customers work on a desktop so that kind of influenced some of the design choices we made along the way so a little more about me i started writing javascript i don't know around 2004 or 2005 and this was back in the day when there wasn't any modern frameworks there wasn't any one way to do things and let's see as i moved through my career i started working with different people and when i started up a group out in westlake village that just wanted just likeminded people who wanted to meet up i often got questions about why is it so complicated um actually sorry i'm gonna back up i messed up so tonight we're gonna talk about the history and where javascript came from we're going to look at some of the dev tools that have evolved to help the developer experience and then i'm going to walk through what i call this timer app which is a simple application that has you know some specifications we could talk about and then show you how it could have been written 10 or 15 years ago in ecmascript 5 or earlier show you how you can turn it into a more modern syntax with es6 and then i'll try to walk through a high level of what that could look like as an angular application in today's ecosystem so back when i started really trying to meet likeminded folks and and hang out with them i'd have conversations with some of the people who showed up to the meetup out in westlake village and they'd say things like um you know why is the web so complicated or i'm here i'm an engineer but i'm a backend engineer and i hate javascript or you know has anyone ever heard someone say i just want to use jquery in in a way that says it's not a good thing to be using jquery for what they're trying to do um so that's kind of who this this is for people who are new to web development or people who are voluntold to work on the web client and they have a lot to chew off and a lot to understand why things are the way they are so this will hopefully walk us through how we got to here you know we had things that people may be familiar with there's backbone.js knockout angularjs angular react vue we have javascript es6 typescript babel webpack gulp grunt and many many more that i didn't put on the slide even more than that there's so much out there there's no way any one person can be an expert or even know kind of all the tools so we got here you know by a couple different um important evolutions in javascript and i think it's important to understand those so that as you are bombarded with new tools every day you can kind of say you know what kind of niche does this fill and where did it come from you know what drove the evolution of this tool i'm using and the way i see it you know javascript has had a 20 plus year evolution and it has really five four or five phases or errors we could call them in the beginning it was very simple html css javascript throw it on a web server you're good then things got a little more complicated users want a little more functionality in their app it'll got a little more difficult for a couple reasons we'll outline in a minute but jquery came along and kind of helped solve those problems it helped really address some developer pain points and made things a little better for the end users of those apps but jquery had some problems too the more it got used the more pain that developers had using it and you know the some really smart developers said we can do better than this so what i call frameworks part one came about and these projects really helped kind of organize code bases organize teams around concepts and design patterns and then make it you know a better developer experience make apps a little bit closer to native uh a native app which users are really coming to expect around this time in the evolution and then i put tooling in between frameworks and um the the two framework parts mainly because it needs a home but it evolves kind of along the same time as the the the frameworks one and two there's a lot going on during that time and so we'll look at some of those tools and kind of how they they look in practice and then we'll we'll end up the history lesson with frameworks part two i'll look at two of the big big heavyweights in the industry today and then we'll go to a a demonstration i have of looking at that timer app three different ways um so way back when where did where did it where did it begin in 1989 tim bernerslee created the world wide web he he started sharing documents with his friends around the world and making new friends kind of laying the foundation for what the web could become and he did it with html and css you know a little bit information a little bit of style um it wasn't real pretty by today's standards but it was you know leaps and bounds ahead of what anything else was at the time and that lasted for a couple years and folks started kind of expecting a little bit more out of the web pages or products needed to do a little more with their web pages collect information submit forms other things had to be you know people said what if we could do that and in a short twoweek burst i think around 1995 or so brendan ike coded up javascript and you know here we are today but it all really started in the evolution of javascript you know that twoweek period and it enabled a lot of things it created a lot of problems but those problems got solved and new new tools were built to address those problems so it was actually a really exciting time even though by today's standards you know a 1995 website probably looks pretty pretty arcane right now so some of the problems that they had were around the issues with standards and the need to do the same functionality for addressing multiple browsers and you know that was a big big pain point for developers because they spent all their time coding a feature five eight ten different ways depending on how many browsers were out there that they wanted to support and the browsers weren't crop cooperating because there's some nascent standards committees out there but the browsers didn't implement the standards the same way so you know it had a lot of problems for developers and they solved them they got through it but they needed another tool and around 2005 or so i think john john resig was his name he's the initial creator of jquery and there were a couple other tools out there at the time that are worth mentioning um my notes are gone um but the tools that i remember are yui framework the mootools i think prototype was another tool that tried to solve these problems in a way that developers didn't have to worry about browsers they could abstract the layer on top of the the code that would work and then the client delivered to the browser would figure out how to address each browser quirk as it as it is probably called um but jquery did five things really really well and it really enabled a massive adoption and the first thing that it did really really well is it exposed something called the jquery object and this was a thing that no matter what else jquery would do for you it let you extend it it let you build your own functionality so when you use jquery and it solves some of those other problems but you had a new problem you could write your own custom solution in jquery style and plug that into your app without having to worry about the browser quirks the other things that were going on the other thing it enabled with plugins is it was really the first time i saw a massive sharing of these tools people were saying well we solved this drop down menu issue and now if you want a drop down menu you can go to the there was a a sort of a pseudo repository of jquery plugins you could look for something see who was developing it and and use it in their your project and maybe even contribute back to it in the early days before github so that was one of the big things that i think helped jquery become the de facto tool that developers use when they really started looking for some structure and organization in their apps and then the second thing they did is they standardized dom access they made it very simple to find an element and do things to it and they did it in a way that abstracted above almost all of the browser quirks that were causing developers to not waste time but spend a lot of time making sure their app was performant and working in a wide variety of browsers i think that one was really important event handlers is a similar pattern to the dom access but basically they provided a standard way to find elements attach functionality to those elements and have it and not have to worry about it working in one browser and not another browser so those standard wars drove a lot of what the fundamentals of jquery saw problems that they solved the first thing it did is it baked in simple animations you know hide and show slide up slide down etc if you've ever seen an app that does that jquery provided an easy way to do that and it did two things it made it easier for developers to add some polish to their apps and it also kind of started to raise users expectations for what the web could become like it wasn't just a toy anymore when it looked and behaved a little more like a native app it was actually kind of cool to work on it it was kind of cooler to use it and a little more fun for everyone on both sides of that table and the last thing that jquery really saw the last problem that it solved was ajax and before you know you had a standard jquery library or api if you will you know you had to write ajax for multiple versions of browsers and identify quirks in one but not in the other and and tailor your application to deal with all that well just by using jquery you could abstract above that layer and move on to doing you know app development working on what your users wanted and i think this really drove a large part of the web forward way back in in period between like 2005 and 2010ish where we we got to what i call frameworks part one and this is where the use of jquery has proliferated and adopted you know adopted it been adopted at a massive scale but it started causing some of its own problems and if you notice a pattern here i think it's something that software development has always had and may never be able to get away from is you know you you build a tool that solves a problem you have and that tool is useful and it gets used a lot and the massive use of that tool causes more problems so you build another tool so these tools that came about kind of in this period were some of the early things that i consider is frameworks you could call them libraries collections of utilities the first one i heard about but never really got deep into using was something that called knockout js i believe it was used or came out of microsoft or a microsoft related project and it pioneered this idea of model view view model pattern a design pattern so anyone who's who's kind of educated themselves in computer science will know there's all kinds of design patterns that are useful but before before this time javascript really didn't have an easy way to apply those patterns some folks did it because you know they they figured out how to do it but it wasn't shared it wasn't adopted as a standard way of doing things so knockout kind of identified this pattern and then wrote some code that let you create an app with this pattern in mind and it helps you abstract your app up a level or two understand here's the pieces of my app this is the model this is the view and the view controller is what kind of glues them together fast forward a year or two and backbone said hey we like what you're doing maybe but we're going to do it a slightly different way i don't know if they said that but you know you know what i'm saying is a new tool that was developed in a similar pattern and it was the first one that i used in a real production context but basically the the library gave context and structure to help organize the code base and they did that by providing these three big building blocks models collections and views you know models obviously is where your data will live views is where your data will show up and be presented and then the collections wires them together and in between you know you get to write what happens and figure out how that behavior works so that one was was the first one i used and then the second one that i used starting i think around 2014 2014 or so was when i first came across angularjs just a quick note it is now angularjs and angular not there's two projects with the similar name but they're not the same we'll talk about that in a minute but angularjs did a similar similar thing in that they provided the model view view model controller pattern but they also said we're going to ship this framework with some opinions you know we're it came out of google by the way and they're very some very smart engineers there they had strong opinions on how things should be done how an app should be constructed so baked into their library is a very opinionated way of writing a router for a web a web app you know writing an http api that is used throughout the web app writing services that glue various controllers in your app together so they they put all that out there and angular took off in a very similar way to i think how jquery took off and that was good apps were getting more functional they were getting more nativelike but developers were still having problems while these apps were being developed and so we had a wide variety of tooling kind of spring up alongside these frameworks and kind of evolve with these frameworks at the same time and there's really four i want to highlight here because they all sort of signify significant advances that make the developer experience in the modern web a lot better than it used to be the first one was um circa 2011 ryan dahl was i his name i believe he he coded up this idea of hey i want to run javascript on my on a server and so he he released it to the world and it was this crossplatform javascript runtime that you could write javascript and run it from your command line on your computer and that was crazy because before that you had needed a web browser to do anything and this sort of gave a lot of fuel to javascript and after that people started scratching all different kinds of itches to make their lives as developers easier with javascript and they needed somewhere to kind of share and store those those utilities they were writing so right after or pretty close after node coming out npm launched and eventually was baked into node but it didn't start they started out as separate projects but basically it became this command line utility that you could use to search find install manage this exponentially growing group of tools and utilities all written in javascript and i'll show a sample package json in a second but fast forward a couple years and people were you know really solidifying how standards work in javascript and they were moving forward but browsers were still kind of causing a little problem they weren't adopting them they weren't shipping browsers that could consume modern javascript constructs so a really smart fella evan lee maybe what's his name i can't remember his name but the the creator of babel basically took that idea and said i want to write modern javascript languages i want to use it in a way that makes sense to me that makes my code easier to understand easier to architect and i want it to run in some of these older browsers that don't understand it and so he wrote this tool that takes that es6 es7 esnex now whatever version you want to write his tool will turn that into something that you know ie11 can run and it's a very powerful tool and what it does is it does this thing called transpiling which i think i i generally use the word compiling although it's not completely accurate but it transpiles your source code into something that the browser understands and you know away you go you get as a developer you get a better experience using the modern language but your your code still works in the the environment that the products live in and then finally all these things kind of highlighted the need for this idea of well how do we okay we can compile it and create it but how do we actually optimize it and split it up and get it ready for this modern web as as we realize you know not all the bits of our javascript are needed right away so how do we figure out how to do that and webpack came along after a couple other sort of orchestration tools were used for a few years and they basically help you package up and optimize your application for delivery to the web so real quick this is a just a sample npm package manifest and i want to highlight three things here that i i think are they're important to me for understanding what npm is and what it does for you it lets you organize your dependencies which is turns into a little javascript object and it basically tells you what the name of your dependency is and tells you what version you have it have in your project and dependencies are things that are going to get packaged up and used inside your app when it's delivered to the client's browser it also lets you manage these things called dev dependencies because as these frameworks were evolving and getting more complicated you know files were getting bigger where webpack and grunt and gulp were doing things like let's concatenate all of our javascript into one massive file but now we need to make that file smaller so there's a bunch of tools that people wrote to help them automate that and do that and the dev dependencies you install will will help along those lines they'll provide some little effort that helps automate your app building experience and typescript is one of those that i use in the angular projects i work on and then scripps was one of the coolest things i think it was one of the first things i gravitated to in npm and basically with this complications that were added to the build process for an app you needed a way to not have to remember babel build command with arguments one and two and at this file in that file so the scripts kind of gives you an area where you can customize the developer experience for your app it it gives you the ability to write a shell script if you want write a node script if you want and then execute it with a simple npm run my command and do a lot of complicated things without having to remember what's going on except for the first time when you write write that script so that was a i think the npm besides jquery the npm evolution and adoption was a big milestone in in the javascript evolution and finally we come to frameworks part two and there are a couple out there i'm not going to talk too much about vue or elm there's a couple others but they're projects that do you guys use album no i do okay cool there's a big fan of it on my team but um they're projects that kind of built on what the first generation of frameworks kind of learned the mistakes they made they figured out how not to make them and the good things they kind of carried them over so react was the the first one i would consider was like the more evolved of the frameworks and it was kind of came out of facebook in 2013. it's its claim to fame was really they wanted to well they had a massive scale for their applications so i don't know there were 700 800 million people back in 2013 maybe a billion and so they had a really large data set that needed to get into their apps and use the data and they had a couple key principles that i think helped them manage the large changes that were coming down with these massive data consumptions by client apps and so they oops they they pioneered this concept of oneway data binding if you're familiar with an immutable state they figured out hey it's better if if our app knows there's one source of truth and when that source of truth changes everybody gets the update at the same time and the way they did that is by working with something called the virtual dom because we all know that it's extremely expensive to query the dom dig into the dom make changes to the dom what they said is instead of doing that let's just take a picture of the dom let's see what it looks like and then when we know there's changes let's take another picture that's a very lightweight process and then we'll see what's different and then we can narrow in on those small set of changes zoom in to that part of the the application and update it when it needs it and it helped really kind of increase the performance of apps and helped um i think consumers kind of become really comfortable with some slick apps that started to approach a native feel and then angular 2016 so i mentioned before there's angularjs and there's angular so the first version of angular angularjs today kind of was there was a line drawn in the sand and i think they had some some lessons that they learned and they wanted to move forward but they couldn't move forward with the legacy code base so it ultimately ended up being an a complete rewrite and so you know for developers like me we i i resisted jumping into angular for a while and then now i'm not even sure why i hesitated or waited because a lot of the decisions they made were really good for my developer experience but the couple of things they did that i think are worth highlighting is they wrote it in typescript typescript is a typed language that is a superset of javascript and it compiles down to javascript even more interesting is that you can one you can use it in in any framework if you want but you can target specific versions of ecmascript so you can say i need my code to run an es3 because we've got this ancient thing running on a kiosk in this little mall well typescript will help you do that and give you the tools to write code in a modern way that can run on browsers that may have been around 1520 years ago the other thing they did was they can't they instead of using the immutable pattern they have this idea of dependency injection which is a i think a carryover the first time i saw it was in java world where you annotate your classes with other bits of information so that when you build your app it knows hey this class needs to know about this service and a service in angular world is really just something that's a singleton that can act as a single source of truth for an application and finally the one thing that i think angular is kind of doing better than even react but react has something similar that's making pretty quick strides is they have this idea of the angular cli so the angular cli is a tool that lets you create a new app with one command line process and it will let you add a component and what it's doing under the hood is it's writing all this boilerplate out to the file so that you don't have to create a new class you don't have to tell your app module about that class because things have gotten a lot more complicated this is a tool that helps kind of alleviate some of that complications so that's that's what i have for the history lesson i'm going to jump over to my computer and kind of walk through that timer app and we'll see how it goes good um miss it sorry thank you all right all right so is that big enough can everyone see if it's too small let me just shout out and i'll bump it up so we have here what i'm calling a native timer app and we're going to look at it in es5 ish syntax this is something that i would have written 2000 2005 maybe maybe earlier if you look at the structure of the project you have an index you have a source we're going to ignore this i wasn't sure if i'd have internet access so i didn't want to uninstall my node modules you have this idea of assets where i just put an image and a css file but you might have had another folder for images another file for folder for styles if you had a more complicated web page you might have multiple ones of those but i think you get the idea that it was it was pretty simple it was an easy structure to understand and in order to run this app all you had to do was deliver it to a web server and clients just needed to go to the web url and they're good to go so my timer has some requirements um let me talk about those real quick so basically we need to start the timer we need to stop the timer we need to mark times and list them out somewhere we need to tell the user when the the timer is running and we need to tell the user when they've added a time to their list and the way i i did this in es5 is you know we have a simple html document and we add in our style we add in our script which we'll get to in a minute and in between there we we have an element we call app and that app has three parts i if anyone knows how to get rid of those things in vs code let me know because the things that pop up i don't probably have to disable an extension okay i'll have to look because it's been bugging me for a couple days but there's three sections there's the timer display where we show the the current time then there's the the buttons that let the user start stop mark do do whatever they need to do and then we have a list for each each time that we want to record and make note of so the way i i kind of went back to the early days at least as far as i could remember them is i i wrote it all in one script you know i had to know if it was running so i gave it a global state i had to know where my app was so i used the the native web apis to get the element and get a reference to it then i created a function that i could pass an element to and if you look closely at the code you'll obviously see there's some some room for optimizing it and refactoring it a bit but when you call this function it passes an element that is used in a couple different places to add in the time that is the current one for our calculations and then we have a couple functions that we can use to attach to elements for starting the timer resetting the timer marking the timer resetting the the timer and so that's kind of all encapsulated in a function and this is probably even more advanced than 95 to 2000 javascript was written but it was worth encapsulating for the purposes of this but then in order to get that functionality onto my elements i had to bind those functions to them somehow and the the way we have today is the web api for add event listener so i can isolate the click events and then add a function that does some stuff it checks the global state which we all know is a bad thing but you know we use the tools we have it adds it adds a class list to this app variable that if you remember is defined up top where we we know kind of what that reference is to and finally it it does a it sets an interval that calls this start timer function every 100 milliseconds and if you remember that timer function all it's doing is you know looking at what the current time is figuring out how much time has passed and kind of formatting that that a little that number a little bit so that we can have a decimal in our user interface and and that was that was kind of the extent of the early javascript projects that i could come across it was a lot of we want this functionality and we need to do it this way and so you you kind of threw it all into one file you tried to avoid global state if you could but you usually had something that couldn't be isolated and so it ended up in there and and it caused you know enough problems that javascript evolved past that and jquery came along and i don't have an example with jquery i'm going to move right to turning this code into es syntax so it's going to look very similar but it's uh worth highlighting that that's what drove you know the react and the angular's frameworks for today so if we check out the es6 app the builtin one for builtin one for vs code um oh i use the z shell and i forget with some theme whatever something i customized once years ago and forgot about so now you'll notice i have a similar structure to the es5 app but the index is gone i now have a package json that lets me take advantage of what npm brings in to the developer experience i have this git ignore just tells me tells my app when not to care about for version control and there's this babel rc which is an object that babel uses and this is where i tell babel here's what i want to do with this code and i'm telling them use this es 2015 presets and when you compile the code i'm writing for distribution include source maps in there so if i run babel without doing anything else it will look for this file and it'll use those preconfigured presets to generate output code you'll notice there's uh there's no assets uh oh oh interesting i hope i didn't mess it up um oh i forgot to show the es5 app running but don't remind me to show this one running i'll show it in a minute and now i'm not sure why that's there all right so in our source we have what you could consider the the structure of our application everything outside of it is some sort of dependency that we need to build the app and deliver it so we still have our index it still looks like the same html structure but we put our assets inside there we have some images and a style sheet and then we have an application that with uh with a saturday afternoon of time to do all these demos i turned into something that's es6 so basically the biggest difference here is that i removed the global state from the application and i wrapped it into a single class and i put as much functionality in that class as possible and using es6 i can do a lot of things in the constructor when someone initializes a new a new instance of this timer app we can do a bunch of things ahead of time and say oh you find this find this element and give me a reference to it find this other element give me a reference to it and that instance of the timer can now work isolated by itself in the browser and not worry about stepping on other bits of javascript's toes we still add an event listener and bind them to click handlers one thing to note is i had to pass in this which if anyone who's done a lot of javascript development they'll know scoping is a mysterious and dark art but basically passing that in lets my function run and understand what its state is you didn't want to use low dash i try to keep it as minimal as possible for for this demonstration just as pure vanilla javascript as possible and then notice that these these click handlers are inside encapsulated inside my class and they do basically the same thing they add a class if it's running they have a check and they set an interval to calculate the new time they have a a way to stop the timer remove the interval so that the timer stops and invite in etc we can reset the app we can mark the time and so then i now have a nice encapsulated bit of code that i can initialize in my global state with a new simple variable and a function call that says hey i want a new timer so to see what this looks like running i apologize for not showing the es5 it looks the same though except for the background image so if we open up that index.html if we open it up we get a nice little app we have some buttons we can start our timer and i broke it oh no let's go back to the es51 i'll show you running there i'm sorry about that i do not like live coding if it if it's at all possible but let's see kit check out actually yeah all right so we have a timer i can start it i can tell the user is running i can mark some laps when i mark a lap i let them know hey it's running i can stop the timer one thing to note is i could still add times and that's probably a bug you wouldn't want multiple things of the exact same value in your collection so i could write a bunch of code to kind of look at that array and and figure out do i put it in or not put it in or just put everything in there and figure out we'll only show the unique things but you know modern javascript gives us things like sets which we know you know is a data structure that lets you just put in one unique thing and if you try to put another thing in it doesn't even error for you it just says thanks no and goes on about its way so i'll show i use that in the angular app basically to fix this bug so that's the app it resets and that kind of takes us up to these modern frameworks where there's a bunch of tooling and so what i'm about to show in the angular app is going to be a little more complicated i'll try to hit these high level you know what's the global state look like what's the dom manipulation for angular look like and then what's the event binding and how would you get this app to production so if we go back to code all right i have this thing called an angular timer and so if you haven't worked with angular before has anyone worked with angular here before all right so not a whole lot so i'll try to kind of help you understand how the project is organized again we have a json file and you'll notice that it it has a couple scripts i generated this app with angular cli so i didn't actually write any of this it gives me something that i can use to start my application which has a builtin local development server so that gives me the ability to do things like write code save and it automatically reloads my browser so that by the time i flip over from my editor to the web browser i already see my code running or not running in the web browser linting is basically a way of keeping your code clean to certain preset configurations of like oh you should always have a semicolon or you should always indent two spaces etc so they bake that into the app generation for the angular cli tool and then ede is is endtoend testing um they have a another framework that is useful for testing angular applications there's a bunch of other projects out there that you can kind of dig into if your use case are different that are have their own sort of use cases and fans for following but you see here in our dependencies we have a bunch of angular stuff we have this core js we have this rxjs and we have the zone.js all the angular stuff is what makes angular work for me and the other stuff are things that angular depends on if you're not familiar with rxjs i'd say that's one of the coolest things i've really had to dive into in the last couple years uh it's worth it's worth learning if you ever went from jquery call back hell to oh my god promises are awesome you'll you'll be a fan of observables when you when you get into them that's worth noting there and then all these dev dependencies this is how we build and ship this app in an optimized way for production so everything that the angular cli needs to build my app is installed in my node modules and then when i run the the right command it packages it all up it optimizes it and it gets it ready for me to do something with so that's the package the code itself angular needs to know a couple things about my app and i can change them and configure them as i need to but basically it has a configuration object the main things to see here is this prefix and schematics prefix is something that we'll use so every component i build in an angular app will basically be very similar to a web component so it'll have its own um html like signature where i can bracket app dash timer close close bracket and then close close that like you would close any other div or section or whatever but this tells app when you create new components prepend this app so if i want to customize that for my uses i just change it there everything that gets generated gets that prefix and then schematics is something that i haven't seen anybody else doing this but it's this idea that i think angular wants to make it really easy to update and maintain client applications so the clarity project that i work on is a ui library it's a module it's not an app and our customers kind of depend on us to keep breaking changes to a minimum or not include them at all unless we're bumping a major version and the schematics is a tool that lets you work within the angular ecosystem and say ng add at clr angular and it'll install this tool the the clarity angular components it will also we also have the ability to say hey we know this is an angular application instead of you having to go and put our clarity module into the application we'll do that for you we know where it goes we'll import it we'll add that and when you use our components it's all ready for you to go you don't have to do that boilerplate configuration yourself the other really powerful thing that the schematics does for me as a library maintainer is that when i do have braking changes or deprecations and you install my project with the angular cli i can scan your code base and say hey this thing you're using is deprecated in this version and i can write a custom note for here look here and see how long it's going to be in you know in the clarity library let's see when we're going to remove it even more powerful if it's not too complicated of a change and we deprecate something and you don't update it when you install it with the schematics i can provide a template for hey you're using this old thing turn it into the new thing so that deprecations or removals magically get handled or notified hey you're installing a version that this thing no longer exists and and your app's going to horribly break and we want to let you know about it as soon as possible so that's a very powerful thing that schematics brings to the angular ecosystem so real quick what that looks like um is as i said angular is a tree of components and so you start with a root component and the way you you get that started is kind of glossing over the bootstrapping process as we still have an html file but it gets really simple you notice there's no styles there's no scripts so when we build the app angular cli and all the and webpack is actually the build tool underneath there um it's configured good enough for 90 of the use cases if you really need to you can eject out of the default configuration and customize it but i i don't see the need for my uses but what i want to say is our app gets started with this custom like element called app root and we have a component and you'll notice we have a selector called app root so when angular comes across this element it knows what it is it knows what template to apply to it and it knows what style to go with it and there's a couple different ways to do it but the default version of angular encapsulate all encapsulates all of that css in a way that makes style conflicts impossible so the names that i use for this component in this style sheet couldn't ever conflict with something else some somewhere in the the webpage of the application you'll notice there's not a whole lot going on here we just have this app root and this template so if we look into that template it'll kind of feel like we're starting to walk into a tree where we have another another custom like element called app timer and that's really the meat of what it took to turn that es6 code into an angular app and i basically had to have four components i had the timer component and we'll look at the code in a minute we have the the button bar we have the display and we have the mark list so if you remember those basic div elements we had they basically become first class citizens of my app they can have their own encapsulated style their own encapsulated functionality and the tools that angular provides gives me the ability to manage global state with basically in an angular app you don't really need global state you can encapsulate all that state inside the typescript files and kind of work confidently inside there um so for something like dom manipulation if we look at the timer display which is the big number of what the current time is you'll see we'll start with a template this time and this could have been in line into the typescript code but i apologize i was a little too lazy to to do that um but for smaller templates generally five to ten lines or less i'll inline them into the typescript file itself anything that gets bigger it's worth kind of separating it out it gets too complicated and there's two things going on here we'll come back to time format but basically in my in my timer display component class there's a variable called current time and whatever that current time is it will get interpolated in this template with that value the other thing angular will do for me is it will pass that value to this time format function which i'll show you real quick and kind of explain at a high level what it is and and what it does for me so then we have the component itself and you'll see it follows a similar pattern we have you know we import the stuff we need from angular we import our timer service which we'll talk about in a minute and then we we decorate our component with these this metadata for what selector is used what template is used with this class and what style goes along with it and angular does the work of packaging that all up encapsulating it and delivers it to your browser and our class looks pretty simple remember we have that current time property and we have two things going on here we'll come back to the timer service remember how i said you know dom manipulation and data binding and things that jquery kind of brought to the table well angular has this idea of decorators and so that component is a decorator at host binding as a decorator because angular views this class as the host anything that lives inside there in terms of an html template is is a child of the host it's a view it's part of the view for that host and so when i use the at host binding decorator angular knows hey when this cloud this thing is true add the class timer display to this host so in my browser i'll have this app timer display element and it'll have class equals timer display and now i can target css for that host and and write things that i wanted to do the other thing that's going on here is remember how i we we talked about not having global state but we still need to to maintain state for our app and pass it around so angular uses that rxjs project and it basically gives me the ability to create a stream of time events and if you're familiar with rxjs it's basically what i'm doing is subscribing to an observable that basically passes every new time to whoever subscribes to it so in this case i subscribe to new times and whenever they're generated i hear about them and whenever i hear about them i run this lambda function in line that sets the new time value to this dot current time and we show up in our browser is this similar to the idea of having connected components to like a redux state for example it's similar it's not redux though it's not oneway flow same same idea of having components to be listening to a global state uh it's it's it's components listening to a state but i could give a whole 20 30 minutes in how the angular providers are organized at a high level these providers are a tree so angular gives you this thing called an injector and you can put providers in there so if you put it high enough up the tree your provider is available to the entire app but if i i say hey i want to define my provider at a lower level at this component level then you'll notice where is that uh if we go back to highlight that if you look at my timer component you notice that i decorated my metadata with this timer service so i only i only inject it into this timer component but when i want to use it in my where is it timer display i don't have to provide it again because if i did that i'd end up with two instances angular would say oh you want one here and you want one here so it instantiate two different providers and they're two different states so by injecting it up top and then inject and then putting it into the constructor angular knows about it it knows what type it is it gives me access to it and then lets me subscribe to that single state so does that answer your question it's kind of multilayered you can do global or you can target it that state where you want to target it and then observables work the way observables work so it's different than that right so i set an interval oh and so every 100 milliseconds it called that function call that function and then when i stop it i basically wipe the interval out and it stops we can look at that um so so my service is a little messy it needs some cleaning up but basically this starts getting into what is rxjs and how does it work but we have the subjects which is the single source of truth and then i give access to those subjects those subjects with this public get time method it returns something with a type observable and basically it returns that time stream dot observe as observable so whoever subscribes to that will hear about changes on the or the time stream behavior subject the difference between a behavior subject and a subject is that a subject initializes and that's it a behavior subject takes a value and initializes with that value so if someone subscribed to it when they subscribe to it they get that first value so basically i want to populate 0.00 as my first timer value the way i add changes to it is i where do i do that so when you start the timer uh if we're running the time calculation we tell some people that we're running so whoever subscribes to this running behavior subject will get the next event in that stream and then uh for the time calculation i set this interval same same principle as before and i run the calculate the next time and then i update this this this is the way that people hear about the message that i'm sending when i get the next time i add it to this timestream.next function and so no matter how many subscribers there are to this uh property they all get the same time from that observable does that help yeah that's so i it's not a perfect timer yeah yeah there yeah yeah there's delay but it's pretty reliable in terms of propagating out without yeah no it's very consistent right right all right so what are we looking at so a little more dom manipulation and if we get too late i can wrap it up but if you're good i can keep going okay um so we talked a little about the timer display let's talk about event binding so we have our buttons and it's just we kind of took out that little bit of functionality from the es6 app and now we need to bind some functionality to our user interface and we don't want to use add event listener so angular gives you this convention of tying and tying into the native browser events so as you'll see here click is a native browser event and by putting parentheses around it this tells angular hey listen to the click event for this element and when it hears something run this function which is defined in my typescript class so it works for you know mouse over mouse move you know any any event that's a native one you can use and you can write your own custom events that kind of notify hey something happened so there's there's a lot of flexibility in using what's already there but kind of customizing it for your needs later if we look at the typescript class you'll see you know there's the metadata for the decorator we inject our service but we don't do anything in the constructor what we do is we we use those bound functions to tell the timer hey start the timer hey timer service stop the timer so we can very nicely kind of break out the pieces that need access to that timer service that global state and keep our our component class is focused on what its job is and the only job of the the timer bar is to start stop mark and reset and then that's event binding we'll talk about i think the last thing to really talk about is how would i get this to production but before we do that let's just show it running so you can kind of see that i do have a functional application so remember the package.json it gave me that and that list of commands they basically run the cli which tells it hey they want to serve this app so it goes and looks at everything i've configured it finds all my files it stuffs them all together and it starts a dev server for me and i can see running angular app that is a timer you'll notice it works pretty similar to the other ones we can mark times for our laps we can stop times you'll notice i can't add more than one number of the same time and basically i use the javascript set which does all the work of keeping values unique for my use case so i don't have to write extra the nice thing for me is that modern construct means i don't have to write extra error handling code i don't have to worry about that if i kind of pick the right tool for the job i'm trying to do and that's it so that's the developer's experience but the the uh well i think when it compiles down it's an array but it's got a lot of it does all the the deduping and unique of the values so that my array only ends up with the right values so um you're familiar with the concept of a set you're just adding one more array right adding an item to the set and then it notifies hey there's a new item and the user interface populates i can go into um oh no what did i do okay sorry um all right all right all right so here's that that mark list component and it's the consumer of that set so i already know i'm getting unique values and basically i subscribe to that stream and i update my timer list whenever i hear a new thing on that stream the way i get it into the user interface is the template actually does change from the the es5 es6 one basically angular gives us this idea of iterators so any templating language you're familiar with has had something similar but there's this idea of a structural directive and what that means in angular world is that anything with an asterisk is a directive on an element and that tells angular it's going to actually modify it's going to create and destroy elements at some point in an angular application life cycle you can have directives that don't do that they just add behavior but because we're going to actually conditionally create a list depending on how many elements are in our time array i i know i need a structural directive and angular gives us this ng4 so for for every time in my timer list it will stamp out a list item for me and then um i'm good i don't have to do anything else the last thing i forgot to show too is this formatting remember how i was formatting all the time strings based on the function it was running well that's kind of not use reusable or sustainable if i want to change that format i've got to change it in a bunch of places angular gives this idea of pipes and so a pipe is something that i can put into my html and then it's a function that basically receives the the inf information so whatever's mapped to current time gets passed to this function i write my formatting here and i reuse it in my html wherever i need to and when i want to update my format i update here and in one place and everybody gets it so the last thing i have to show here is production so the webpack app the es5 app was easy to get into production the webpack app would need some or sorry the es6 app would need some webpack you'd have to configure it and get it ready to you know concat and minify and optimize assets angular cli gives me a tool build and if i give it this command prod while it's running what prod does is it it does all those optimizations but it also if you're familiar with how webpack is really revolutionizing something that we're calling tree shaking so angular at build time analyzes my app and looks at stuff to make sure it's used used if there's something in there that's not used it removes it from the bundle that gets shipped for production thus making my files smaller my app a little more performant my user a little happier developers are happy too because if you're using the cli they've configured webpack for all that and you just have to type the right flag and you're off and going so that's all i have for the demo let's see here um so that's that's it i i think we kind of went through these three stages we we looked at you know where ecmascript sort of pushed the evolution of javascript es3 es4 es5 you know it was a wild wild west back then there was a lot of issues that tooling and jquery es6 came along and you know helped address and then finally the the idea of a framework or a library to work cohesively to use modern design patterns to bring that all together they you know have addressed a lot of those needs there's a variety of them out there i think they're all worth kind of knowing a little bit about because you never know what's going to be the next jquery angularjs angular or react which are all react as massively adopted i have one more thing um but i do yeah i do think it's worth kind of understanding those at a high level no matter what you're using in your day to day so if you're interested in the apps they are up on github in a repository feel free to take a look i hope this was useful i hope it took you maybe down to some fond memories or not so fond memories but this was sort of my journey through javascript as i understand it and that's all i have you