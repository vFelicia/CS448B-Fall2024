what's up programmers and subscriptors this is ryan here and in this course you are going to learn how to build a native android application using kotlin jetpack libraries and a little bit of help from firebase now before we jump into the android stuff please be aware that the audio quality does improve after the first section of this course be sure to check out the timestamps in the description box and also check out the pinned comment down below for links to more awesome educational content so that's it hopefully you enjoyed the tutorial what's up everybody this is ryan here and you are watching my jetpack notes mdvm android kotlin tutorial so in this video what i'm going to do is i'm going to demonstrate the application that we'll be building throughout this tutorial series or building in increments and then we'll also have a look at basically a huge list of topics that we'll be covering so that you know what to expect in this tutorial series so before we get to those finer details let's do a quick demo of the application jetpack notes has three features or primary user interface screens we're looking at the note list feature currently and as you can see we don't have any notes so it's kind of in an idle state so note list display displays all of the notes which are currently stored either in the local room database or the remote firestore database and the decision of where to save or retrieve notes is based on whether the user is logged in or not and that's actually a concern which is handled in the back end of the application so uh from this screen we can also create a new node so i'm just going to hit the plus button and we'll just create new oops i can't type new note like so and then i'll hit the check mark button this is also where you can delete notes and as you can see we have the new note here next thing i'm going to do is i'm going to hit the key i icon which will open the login feature and as you can see we are currently signed in so what i'm going to do is i'm going to sign out okay and then i'm gonna head back to the note list feature by hitting the back button and as you can see we have a totally different note currently present for because that is uh what's coming from the local room database so i'm just going to hit that hit the delete button and as you can see that's cleared that out and then we'll just log back in again sometimes it takes a moment there we go there we are and boom new note so that's a quick demo of the application and this is what we will be building in this tutorial so in order to follow along with the tutorial you're going to need to visit the repository link down in the description box below and you'll need to either clone or download the code so that you can follow along properly what i'll do is in each lesson i'll sort of go through with you i'll give you specific instructions on how to create a starting point so we're all on the same page and then we'll carry on from there this tutorial will cover both front end middle and back end topics for android development for front end we'll look at constraint layout simple android animations using animation lists using vector graphics which will basically allow you to have cool graphics and animations which will scale with whatever uh resolution or screen size you're working with i'll show you how to build a recycler view which happens to be the first thing i ever taught people to do on youtube and then we will look at implementing the navigation library from jetpack uh view models from android architecture components fragments and i'll do in the next video a big talk about model view view model frontend architecture pattern for backend topics i'll teach you about using firebase auth and google signin provider for quick and easy user management we'll look at using room and firestore for local and remote data storage respectively i'll teach you how to hide these things behind a repository so that the front end doesn't know or care where the notes come from and we'll also learn about simple dependency injection using android view model and view model providers to get everything nice and wired together and finally we'll talk about how to wire the endtoend application together using kotlin co routines and let me tell you i think you're really going to enjoy that part and in this video i'm going to be giving you an overview and kind of an examination of the pros and cons of using the model view view model architecture which is the architecture that we'll be using in this particular tutorial series we'll also have a quick look at the packages and files for the demo application just so you understand what's going on there now before we look at this pattern in detail i'd like to address what i consider to be a few misconceptions about not just model view view model but software architecture frontend gui patterns in general so i'm going to assume that most of you have heard about all kinds of different three layer architectures there's model view controller model v presenter model view view model which google seems to be putting all of their weight behind or sorry the android team rather and then we have other options like viper or there's model view intent by hannes dorfman and i'm sure what most of you are wondering is would someone please just tell me which one of these is the best architecture well i'm going to try and burst your bubble right now because in my personal opinion the answer and this opinion is fairly widely shared among senior developers is that the project requirements at hand will dictate the best architecture for you so one of the things that i've noticed over the years of trying several different approaches different patterns is that they work good in some situations and they can be uh counterproductive in others now it's better to follow an architecture which doesn't really work super well for your problem requirements than no architecture at all but what i'm trying to say here is that over time when you know things about all these different patterns you'll start to see okay well this particular feature of this pattern is useful in situation a but it's kind of a problem in situation b so what i would like to do is basically explain in this video that uh model view view model is not an exception to that rule it is not necessarily the best architecture for all situations even on the android platform but it does have some benefits and some deficits so what i would like to do is basically give you an idea of what those benefits and deficits are and uh yeah we'll get into that in a moment but before we talk about that i'm going to try to give you like a general overview of the architecture using whiteboard example okay so what we're going to do now is we're going to talk a little about the model view view model front end graphical user interface pattern before i jump into this one thing to note is that unfortunately developers do not always consistently build these things the same way so what i'm going to explain to you is a generalization this is my interpretation of the model view view model architecture but like i say you're going to find different variations of this and the most important thing for you to know is that different variations will work better in different situations so what exactly happens how does it work so the first and most important thing the the defining characteristic of model view view model in my opinion is that uh essentially we have this thing called a view model in the middle which encapsulates the both the behavior and the state of the front end of the view both the behavior and the state so state being the data and the behavior being what do we do when some event happens kind of deal so the thing that's unique about model v view model is that the this thing in the middle the view model you're not allowed to have this view model actually directly tell the view what to do i'm not allowed to draw a line from here to here which would be a dependency so if you're doing model v presenter you are allowed to do that in model view model you're not based on my interpretation instead what happens is we basically have to have two dependencies two different channels from the view to the view model this is typically how we like to set it up so one channel is just synchronous and this would be the kind of thing where let's say for example if we're coding for android or whatever the user hits a button and then the view can just if you know just do a synchronous call just a function call to the view model hey this button was clicked so that's one of the ways it can communicate with the view model the other way and this is how it actually gets the data out of the view model and this is confusing for some people is that do you see this eyeball thing here this is my representation of what's known as the observer pattern so you could use data binding what i like to do is i like to use basically a producer consumer consumer relationship or the observer pattern it's called between the view model between the view and the view model so basically what i'm saying here is at the start at some point the view model will ask for observables so it's going to ask for something from the view and this thing that it it gets sorry it's going to ask for something in the out of the view model and when it gets that object that observable object i want you to think of that observable object as like a pipe that data pops out of at on indeterminate time whenever the data pops out of the pipe whenever the v model asks the model the back end for some data it's going to then publish that data and if the view is listening then the view is going to grab that data that pops out of the the observable pipe and then it's going to render that on the screen so that's basically how model view view model generally speaking works so one of the things to keep in mind about this is that the the benefit of model via view model is can also be the deficit so one of the main benefits of it is we can have a many to one ratio of views to view models and that's because the view model does not depend on any view specifically the cost of that is that you lose finegrained control over what the view does so naturally in many cases you're going to have to actually have more logic in your view because the view is going to have to be able to interpret what's coming in from the observable streams so there's different ways to solve that and the logic isn't necessarily going to be super complicated but this is one of the things you want to think about when you're working with model view via model in particular so now that i've given you like a general overview of the pattern i just wanted to get a little bit more specific about the things i am fond of and not so fond of in this particular architecture with the hopes that it can help you inform your decision about whether you think it's a good idea to use it or not so the most important thing just to start with the cons here in this particular architecture is that the synchronization between the view and the view model presents a problem of separation of concerns if you're not sure what separation of concerns is i've written an article and i'll link it down in the description box below and it'll basically explain my perspective on separation of concerns but i actually do consider it to be probably the most important principle to observe in software architecture anyways the reason why the synchronization logic can be awkward and there are ways around it is because we don't have that fine range control over the view so this means we have basically two options and these are kind of what i would consider to be subsets of model view view model so option number one is to basically fill the view with a whole bunch of logic to interpret the data which the view model publishes to it so this approach will allow you to have very reusable view models but it's going to basically make it so that you fill your fragments or whatever view class you're using with a whole bunch of logic when you fill something with a whole bunch of logic that's really the time when you really need to be careful about testing now i personally don't like to test ui classes instead i use humble object or passive view which basically makes those classes generally speaking oneliners and it makes them simple enough that they don't even directly need to be tested if you don't take that approach and you want to fill your fragments or views with lots of logic you will need to probably use espresso or roboelectric to make sure that you're testing everything adequately so one of the ways around this and this is the key problem is the presentation logic is awkwardly distributed between the view and the view model one of the ways around this is to actually make it so that your view model knows a fair amount about the particular view that uh it's working with so what i mean by that is it's not that it has a direct dependency but you can fill your view model with all kinds of in this tutorial would be like live data observables uh you can fill it with a whole bunch of these observable fields which will dictate for example should this text box be highlighted or this that and the other basically details about the view without actually having a direct dependency so this will allow you to basically pull a lot of logic out of back out of the view and into the view model and that's going to make for a much easier to test view the caveat to doing this is that if you have all kinds of details about a specific view in a view model even if there's no direct dependency you are still tightly coupling that view model to that particular view so you lose the reusability of the view model if you take that approach in exchange for not having to have a whole bunch of logic in your fragments so with those considerations in mind which aren't necessarily application breaking but as you can see there's not actually a truly specific model view view model pattern here there's actually some variations in it and this is something that i've even heard the android team admit when they were looking into this particular pattern so as you can see we've kind of got these different approaches to it and they're going to have different benefits so if your user interfaces are like super simple then you're probably going to be able to get away with having fairly decoupled unspecific view models and that's kind of one of the main benefits of this particular approach is that if you don't tightly couple your viewmodels to particular views great english here um then you can promote the reusability of those view models uh side benefits is of course you are applying some kind of separation of concerns by separating these things out so you're going to get some benefits to testing and modularity as well and one important feature which this is something that's specific to android's particular tools so android architecture components and jetpack and that but one of the biggest benefits uh for this particular approach on the android platform is that concurrency and lifecycle really is a breeze when you apply this particular architecture and you use their components so the final more detailed point i'd like to make on this particular architecture is that if you confine yourself to just having model view view model then you are definitely well i won't say definitely but probably going to run into problems where you have this awkward separation between the synchronization logic of the view model and the view and you have to kind of pick one path or the other reusability or not filling your views full of logic there's actually another solution which you can apply which is actually what i apply in my production code i don't confine myself to just using model view view model in fact most of my architectures when you look at them you'll usually see something which is something along the lines of like model view presenter view model and the view model has a different role it's not so much a logic class as just a front end session data container so anyways the point of that is just to say here for the people listening this certainly do model view view model and carry it as far as you would like but if you get into a situation where you have this ugly awkward division of presentation logic between this the view and the view model another option is to actually create a fourth class like a presenter call it whatever the hell you want i just call it a logic class and then you can actually pull out that logic again decouple it from the view model and then you can have this sort of fourth object handle things like click events it's going to simplify your view models and i would kind of suggest that as you start to build more and more complicated applications if you're building simple applications though usually you can get away just fine with just having the view view model in the model so the last thing i'll be doing in this video is giving you an overview of the package structure of this particular application so the repository is at jetpack notes mvvm kotlin under bracket cove link in the description box down below and what we'll do is we'll just open up the app module here let me just zoom in a little and i just wanted to talk about what's within the main package here so we've got four primary packages or directories so within common you're going to find classes which are shared across different parts of the application so that's why we have this common module here so this is where i like to put things like for example base classes so we have a base view model which is like an abstract class which shares some code across a set of different view models constants and a lot of extensions so there's a lot of ugly kind of data mapping stuff and this is something that basically converts from a firebase task into uh uh rxj or sorry co routines not rx java force of habit and yeah just all kinds of mappers and stuff like that so uh we'll be going into more detail but i just wanted to give you a quick glimpse there so that's uh common uh we have the basically two primary features of the application so we have the login feature and the note feature within login you'll of course find the login activity login event login view and user view model and then in each of these feature packages you're going to find a sub directory called build logic which will basically contain the dependency injection and user review model factory stuff to create the view models no dagger 2 required so everyone can chill the chill out about that so anyways one important point here is that i did actually try to do a single activity approach in this particular application as per what they suggest in navigation i was not able to due to tight coupling to on activity result which as of making this tutorial is not supported by the navigation library if you're watching this in the future it may be now and that is probably my biggest criticism of the navigation library at this point is that it did not support on activity result which is problematic anyways i will be demoing the navigation library in this tutorial but i even though i tried to do single activity i literally couldn't so there's two activities and three features next we have the model package so this is basically going to contain everything which is related to storage and access to data so we're thinking repositories implementations firebase stuff room stuff data models that kind of stuff like i say we'll go into more detail later so then we have the note directory which contains all the different files necessary for the note detail and the note list features so as you can see here it's pretty much what we like to call package by feature approach but something which isn't doesn't necessarily fit into a particular feature i will put that in a common directory so within the note package you see we have the note detail and note list subdirectories and these this will contain the views and view events and build logic for this particular ui screen and i chose to group them together because they both work on the same concept conceptual note object and then we of course have the view models and factories and stuff like that for these different views so that's it for this particular video hopefully you learned not just about model v view model but a little bit about software architecture in general and my goal here isn't to crap on model view view model or to say that you shouldn't use that approach i think you can build beautiful applications with this particular pattern what i wanted to do though is kind of explain to a lot of the beginners out there who are confused about this particular point that the big kind of consideration with this architecture is that synchronization between the view and the view model can be a little bit awkward there's ways to solve it though and we'll talk about that as we progress through the tutorial so for starters i'm going to show you how to find free open license images like the one this animation is based off of i'm going to show you how to create scalable vector graphics out of these pngs or raster graphics using some free tools i'm going to show you how to import those vector graphics into android studio so that we can actually use them in our applications and finally i'll show you how to create some simple but effective animations which scale and it won't require you learning 15 different animation apis because we all know there's quite a few different animation apis on the android platform so if all of that sounds interesting to you please do consider hitting the like but like button down below consider subscribing and with that let's jump into some discussion on vector drawables and graphics versus raster drawables and graphics now you may be wondering what exactly is a vector drawable and how is it different from say like a bitmap png jpeg or all those other formats that you're used to working with well the key difference is that bitmaps or pngs or jpegs all those sorts of things which are known as raster graphics are in essence a collection of bits bitmap hence which ultimately represent pixels drawn on the screen so for example if we wanted to in a raster graphic type format render a triangle then ultimately you're going to end up with something that looks about like this if you zoom in close enough so we want to think of like each sort of segment of some screen or device has a finite number of pixels then we basically say these are the pixels that we want to draw this is the color and you end up with something like that so the problem with these particular formats which are as i said known as raster graphics is that they don't scale well across a variety of different displays or resolutions one solution to this is to provide many different versions of the same images the same image which have different resolutions so on a really high quality device you're going to provide a much higher resolution icon or image or something like that while this kind of works the problem with it is that you can end up with a situation where you're bloating your packaged applications or taking up a whole bunch of your users data by downloading a whole bunch of really large image files so if possible we kind of try to advise against having just a huge number of image files in your apk so as opposed to having say a finite number of pixels represented in some kind of collection format vector drawables take a different approach so essentially what we're doing is we're supplying a series of coordinates and you can add much more detail than just coordinates but say for example if we wanted to render a triangle we would for example give in this file we would write down a series of points so for example x1 y1 x2 y2 x3 x3 y3 and then what you would do is you would instruct the computer to draw say lines of a particular color between these points and as you can see the benefit of doing this is that the actual work of figuring out the scaling and resolution and how to render it on a particular device screen uh it's done on the fly and it's independent of a finite set of pixels so that's a big fancy way of saying it makes it scalable it's basically like saying hey here's what i want you to draw and then the computer basically figures out the mathematics of doing all the scaling and stuff like that the end result is that you get images one image file which can be rendered for basically almost any kind of screen size or zoom level or things like that the vector graphic we'll be creating today forms the basis of the rocket ship animation in my jetpack notes android architecture components application so just an important thing to point out notice how this animation scales really quickly and easily to a variety of different screen sizes as you can see here and so what i'll do is i'll show you where i got the basis of this particular image from please visit the repository link down in the description box below clone the application and in this application you're going to find a png image file which is of course a raster graphic type file and what i'd like you to do is go ahead and download that repository and this is the file that will be basically turning into a vector drawable so you don't have to download it from say open clipart so if you happen to have a more allencompassing video editing software tool like photoshop or something like that chances are it does have the option to export from say a bitmap or png to an svg file or some other kind of vector drawable if you have that option do export to svg and you can basically skip this part of the tutorial i'm going to be using inkscape and the reason for that is does not actually allow you to export to svg inkscape is a free open source software so that's why i chose it in particular but you can use whatever you prefer to create your vector drawable so what you want to do is go ahead and open up the particular png file rocket underscore one dot png from the repository and you're going to need to select it so click on it and hit control a and then go to path trace bitmap now there's a couple different options you can select here you're going to of course want to pick the option which renders your image as you prefer i'm going to select colors like so and as you can see here that looks about right i'm also going to click remove background and then we'll hit ok to actually execute the trace and looks like it has worked and now we have our traced out svg uh file going on here our collection of paths and the last thing we need to do is go to file save as and you can just save it right into the same drawable folder that you grab the png file from i'm going to name it the same thing just make sure that for the save as type thing you have selected here you're going to want to pick inkscape svg all right so we've created our svg file through inkscape but as you can see here it has a whole bunch of metadata and crap in here that we don't actually really want to include in the thing that we'll be using in our project so what we're going to do is you can just go right click on resources or drawable select new vector asset like so so uh just a quick little tip here if you in the asset type field here if you select clipart and then you can and then click on this clip art icon here you can actually select from a whole bunch of premade icons and then create vector assets in android studio out of those as well so just a quick little tip you don't have to go to the website and download these assets you can do it right here and this is far more efficient anyways we're going to go to local file and so go ahead and give the thing an appropriate name so i'm going to call this we'll call it i am for image and we'll call it what was it called uh let's say rocket one for example and then we need to of course select it uh find it in the path variable here so we're going to select rocket 1 svg like so this particular size variable can be easily changed and it's not actually that important i do like to leave the opacity on 86 percent especially in like a dark themed application like this one so i'm going to leave that at where it is and we can basically just leave all of these different defaults here once that is selected we're just going to hit next i'll pull this into view and it's going to tell us that the output directory is going straight into drawable that's totally fine res main is fine and go ahead and hit finish so what that has done is as you can see down here that's created a new uh drawable this one's called ic rocket one i thought i typed i am rocket one but i'm i'm totally confused now anyways uh so what you can do is go ahead and open up this thing and just notice that it's also an xml vector drawable file but it's just a little more purposebuilt for android we have our android variables in here and that's basically all we need to do to import our svg drawable into android studio and then now what we can do is we can just refer to this particular xml file like any other kind of drawable and it should show up uh appropriately so one of the easiest ways of thinking of and designing animations is just to suppose that we have a series of still images being looped through over time kind of like a projector with a film reel if you ever go to the movies so uh what we're going to do is we're going to create an animation list xml file it's going to be super easy and in this list we'll supply a series of different drawables to animate through and that's kind of how we'll actually create the animation effect so in android studio what i'd like you to do is you're going to right click on the drawable folder go to new drawable resource file and what we're going to do is we're going to call this thing rocket loop 2 i'm going to call it that because there's already a file called rocket loop and you can leave the qualifiers in that as defaults so the first thing i'm going to do is i'm going to change this to an animation list as you can see here and then in this animation list is where we will supply the different drawables that we want to loop through so we're going to create items and we're going to say item android drawable and so what we're going to do is i'm not going to show you the whole process of creating all three different drawables but what we want to do is we want to supply our scalable vector graphics here so the thing we had was i am actually got turned into ic rocket one and what we'll do so that's the one we created in this tutorial i'm actually just going to change this back to the default so this is i am rocket one and you can do this too if you downloaded the repository or you can use the ic rocket one i don't really care and then what we're going to do so we've supplied a particular drawable then we want to supply a duration in this case so i'm going to type 200 which is about a fifth of a second so this is going to be a pretty quick animation and then we can go ahead and close off that particular xml tag there i'm going to click at the end here and hit ctrl d twice and that's just going to copy to the next line and then of course we're going to add i am rocket 2 and then i am rocket 3 like so and that is it for our animation list so go ahead and create that and then finally we'll look at how to actually access this thing in the code all right so i've opened up fragment note detail xml which is the thing i demoed earlier and so what you can do here is uh using either an image button or in this case an image view you're going to want to specify the source of this particular uh view as being the animation not of course the drawables so go ahead and do that and then what i'll do next is i'll show you how to actually get hold of this thing and start the animation in the java or kotlin code alright so i've opened up note detail view which is in the repository and what we'll do now is we'll see how to actually start our animation list going so uh just a quick note here if you're wondering why there isn't any fine view by id or anything like that going on in this particular file it's because i'm using kotlin synthetic properties for the user interface but in any case however you prefer to get a hold of the particular views in xml you're going to want to do that if you have to use find view by id that's fine so what i'm going to do is i'm going to scroll down to the function where we actually start this animation drawable i'm just going to give us some more room here so the way that we actually start these drawables going is you're going to want to get a hold of the actual view uh which possesses the animation and then you're going to get a hold of the drawable so you could say say in java imv imb no detail satellite dot get drawable or something like that you're going to want to cast it to an animation drawable this is how we do casting in kotlin and then the function we want to call is start so what that's going to do is in this particular case that's going to start our animation here going now in this particular feature of the application uh the animation just runs uh permanently just as a little visual ui effect so i'll show you a few other little options for these particular animation list drawables okay so what i've done is i've opened up note list view which has a few more things going on with these particular animation list drawables or animation drawables rather so uh first off i've showed you how to start just a plain animation there are other animations in this uh particular application so there's actually a background space animation which is always looping and one thing in particular i do with that and i've actually just added this into an extension function in kotlin so i'll show you what it does so basically if you want to specify say a fade animation then you're going to want to set the enter fade duration set x at fade duration and then that'll allow you to fade between the particular drawables we don't need to do that with the rocket ship animation but it works nicely with our space loop animation and then of course we call start to actually get it animating now in this particular feature depending on what goes on we do need to actually stop the animation so when you want to do that again you're going to want to cast the drawable of the view that possesses the animation and then you just want to call stop as we see here so that's basically it so what we're going to do is we are going to build the login form of the space notes application quite specifically we're going to be building this layout and the purpose here is to teach you some of the basics of applying some principles of material design and also the basics of using the constraint layout effectively because one of the things with the constraint layout is that uh there's a way you can work with the tool in the design editor where you're clicking dragging like 50 different constraints and attaching all these things together and then more recently they've added some features where we can streamline a lot of a lot of that process so that'll be the main focus of today's video also talk a little bit about uh styles and a couple different things like that but yeah let's get started so before we build the layout itself i wanted to talk about some styles and resources that we'll be using so we will be using animation drawables for the animated background the space animation and also for the antenna animation and we'll also be using some vector drawables for our icons and also the antenna animation so if you're not familiar with those topics what i'm going to suggest you do is head over to the previous video in this series number three because in that video i cover how to create uh vector drawables and animation lists and how to do that with totally free tools and if you're curious about what a vector drawable is uh just go watch that video but understand it's uh you don't necessarily want to use them everywhere but the benefit of using them is that you can have one file which scales to multiple different resolutions as opposed to having to supply images for each particular resolution so definitely consider checking that out but what i'm going to ask you to do now is in the description box below there is a repository a link to the repository that'll be which contains the code that we'll be working with so hopefully you've already done this before but if you haven't and you're just jumping into this tutorial series go ahead and clone or download that code because that will be the basis from which we uh work from we'll also be using some styles which are located in the view styles xml file so the purpose there is just to remove some redundant xml attributes and try to get it so that if i need to change something i'm only changing it in one place i won't be going into detail about that in this particular tutorial but do consider checking that out because as you'll see we'll be adding some styles to our layout files for that purpose all right so the file that we're going to be rebuilding specifically is fragment login so hopefully at this point you have downloaded or cloned the repository if not you can of course still follow along with what i'm doing here so uh yeah as i say we're going to be rebuilding fragment login and in order to have the code easy for you to reference just go ahead and right click on the layout folder go to new layout resource file and we're going to create a new one called fragment underscore login underscore demo like so and go ahead and set the root element as a constraint layout there's a couple different options here so just make sure you select the constraint layout but if you have to change it later that's fine too there we are and we are ready to get started so first thing let's go ahead and give it an id here so i'm going to type id at plus id and this one's going to be called root fragment login just be aware there's going to be some overwrites here because we have the same layout in a different file but that should make things a little bit easier in terms of auto complete so yeah we've added an id to that layout and then the next thing we're going to want to do is set the background like so so the specific background we're going to be using is called space loop like i said before if you want a detailed explanation of how to set these things up you can you're going to want to watch the previous video but let me just open up space loop really quickly here so that was just ctrl shift n to open a file and this is basically what it looks like here so as you can see we've got a couple different drawables uh the root tag is animation list and the duration is basically uh it's going to loop through these animations kind of gradually this will be a like a two second delay and these drawables just are so you're aware these ones are going to be png files whereas we'll see with the icon animation they are actually vector drawables so anyways so what i'll do next is i'm going to click on this image button and just click and drag it into the top left corner of the screen like so this is going to open up a dialog to select some kind of resource so you can select some kind of premade resources that they provide for you for different uh just like kind of placeholders and icons and all kinds of different things in this particular case uh we also have these really horrendously weird looking avatars i have a specific file in mind which i've added ahead of time so the drawable we'll be using in this case is in the project tab and we're just going to navigate to let's see here this is going to be i see arrow back black like so so i'm just going to click on that it's not actually black as you can see here but that's fine so i'm just going to click on that and hit the ok button and that has added in this particular image button drawable so what we're going to do first is i'm going to show you one of the ways to kind of manually set the constraints for a constraint layout and then for the rest of this particular layout we'll see a way to do it way quicker that works in certain situations so the first thing i'm going to want to do is now that i've dragged this thing into a particular area of the screen i'm going to want to basically constrain the top of this view to the parent top so i'm just going to click and drag and then kind of bring it to the top of the screen here can't really see what's going on in this editor so let me switch to the blueprint editor here and i'm going to click and drag to the left side of the screen and as you can see that has constrained our back button like so and what i'm going to want to do is i'm just going to want to play with the margins a little bit i think i'm going to do 16 by 16 for the margins uh sorry for the very crowded screen so um we're almost done with the image button and this is going to be like our back button here but one thing i wanted to do is i want to make it so that it it's actually styled like a toolbar button since we're kind of doing a custom toolbar so one of the hacky but totally legitimate ways i do that is i type style so this isn't actually a style which i created i'm just going to type at style slash widget dot app compat and then we're going to select action button so that's going to do a couple of things it's going to remove that ugly sort of dark gray background it's also going to add things like an animation when the image is clicked and things like that so it's just going to add a bunch of styling information and i do recommend that you do that now in the text editor we're also going to want to rename this view so i'm going to call this thing imb toolbar back like so and that's basically all we need to do here so one quick point you'll notice that here android studio has automatically added this source compat attribute here so this is because we're dealing with uh vector drawables so just uh one quick thing to point out here if you're basically targeting applications on api lower than 21 then this thing isn't actually going to work properly with all views and i'm not sure if it actually is back ported to everything but if you're using vector drawables you're going to want to go to your app level build gradle file or module level build gradle file whatever you've called it you're going to want to add in this vectordrawables equals or vectordrawables.use support library thing into your build gradle file now in this case because we are only targeting api 21 and above i don't think that's actually necessary but just for backwards compatibility i wanted to mention that okay so what we're going to do next is we're going to add a whole bunch of different views to the layout and we're not actually going to manually set the constraints because that can be quite tedious and instead we're going to use one of the helpers in order to do that for us but before i worry about the constraints we're just going to add the views into the layout set the ids add a little bit of design time attributes so we can get a rough idea of what it'll look like and then we'll figure out how to do the constraints so i'm going to open up the palette and so we'll start with a couple different things here so first and foremost i'm going to want a text view and so our goal here uh basically when we click and drag these into the design time editor here they're not constrained but they're going to set like an absolute value of where they're positioned so i just want to kind of roughly position them where i think i want them to go and that should be adequate so we have our first sort of login status drawable then we're going to add in this is going to be an image view so we'll go to common and it's of course going to take us through the dialogue here so what we're going to do for this particular image view is it's going to be antenna loop is the drawable that we're looking for so again this is actually an animation animation list in resources and so i don't really want it there let's just kind of position it right there and we'll have to fiddle around a little bit with some of the attributes in a minute so i've got that thing positioned there and then we have another text view below that so i'm just going to click and drag i know this isn't super visible it's okay we'll figure that out in a minute all right so we've got that text view and then finally there's a button so we're just going to click and drag that down to the bottom and there we go so as you can see we have a basic setup but everything is really ugly so the next thing we'll do is we're going to hop into the text editor and then just set a couple of things very often what i'll do is i'll spend most of my time in the text editor but when it comes to like setting up the actual constraints then oftentimes i find it easier to do it in the design editor so the first thing i'm going to do is i'm just going to fix all the different generated ids so using uh whatever convention you like as you can see i have some habits of mine from other platforms but we're going to type lbl this one's going to be called login status header then we have our image view so i don't want this thing to be wrap content wrap content this thing's actually going to be 128 dip anyways we can fiddle with that in a minute uh for its id that's going to be imb antenna animation like so so i'm trying to find an adequate zoom level here that's not too obnoxious and uh yeah then we've got our text view so this one is going to be called lbl login oops login status display and then we have our button at the bottom so this one is going to be called btn auth attempt so you don't have to use my particular convention for naming these ids but i do suggest you use a convention i'll probably end up switching to camel case for these because using kotlin synthetic properties i end up having to have this ugly underscore case in my kotlin code so just something to consider all right so i wanted to set the ids in particular before we go messing around here with the uh constraint layout editor because uh once the constraints are set you need to mess around with the ids afterwards if you change them so now that we've got that set let's hop in back into the design time editor and so in this case uh i see that the image view has gotten positioned a little bit weirdly so i'm just going to again kind of manually position these things where i think i want them something about like that and then what i'm gonna do is i'm going to switch to the blueprint editor here just so we can have a pretty clear view of what's going on and then what we'll do is so i'm going to click on each of these views and holding shift i'm going to select all of them alright once we have everything selected just right click on one of the views and go to chains and then we're going to create a vertical chain so what that's done for us is it's basically constrained all of these views to each other and the parent as you can see in this sort of chain so let's just hop back into the design editor for a minute so as you can see we have everything kind of aligned horizontally the way we want but the actual spacing here is pretty ridiculous so what we're going to do is we're just going to click on this little chain icon here and this is going to change the type of chain so there's a couple different options there is let me just grab my notes so there's going to be spread inside spread and packed in this particular case we're probably going to want packed i think that's not it there we go something like that okay so we've got these views roughly where we want them what i'll do next is i'm just going to select each of them and then we're going to constrain them horizontally so again just click and holding shift select all of them this can be a little bit tricky with these buttons popping up just be aware that and then once we have these things selected i'm just going to right click on them and then we're going to go to center and then we're going to select horizontally and what that's going to do is it's going to horizontally constrain all of those views and as i said before this is a lot quicker than having to do this manually that's how i used to do it and it works but it's kind of tedious so one of the main takeaways here is just learn a little bit about these different options that they provide you in the editor and see if you can use them to expedite the process of building your layouts a little bit quicker okay so we've got everything roughly where we want it to go so the last thing we'll do is we'll play around with some of the specifics here just to get a more material design and stylish look so up here we can probably add some design time text to this particular view actually this thing i believe is always login status so we'll just set it to that and looks like that thing needs a little this bit of styling so i'm going to type style and we're going to use yeah that's the one text.primary.login header and that should just give it a larger font size as you can see here it's looking a little bit better uh we'll move down to the image view and for the image view it's already pretty close to being good to go one important thing if i wanted to support tablets and things like that i would probably not want to actually hard code these layout height and width values instead i would want to provide them in resources but like i say we're skipping a couple of things here for the sake of the tutorial anyways so what we want to change here is that uh the sizing is all good but we would prefer a white drawable in this particular case on the dark background so i'm going to type android tint and we're just going to hard code in ffff6fs which is the hex code for white and as you can see here that's looking like that so let's move to the next text view below so this one the text changes frequently i'm just going to type tools text instead and so we're going to type signed in as one particular example status and then we also have some styling for this view so this one is i believe text.primary.loginheader.sub yep that's looking a little bit better and finally let's head down to our button so i've made another special style attribute for this thing which is going to be style slash off button and this is the button that i actually used to trigger the google signin so anyways the text for this particular button is going to be uh it changes frequently at run time but we're just going to type tools text and then we're going to type sign out like so and let's just have a quick look at what that looks like all right not looking bad so that's basically it for the xml stuff here as far as the layout is concerned i know earlier i mentioned i wouldn't go into detail about the styles but i thought i would just show you a little bit about this particular file viewstyles.xml and so one of the biggest tips i can give you in terms of giving like a nice material design look to your application um use the sans serif uh font families and that'll give you some nice roboto fonts and then also the different sizes that i use to basically come from the android material design documentation so well the google's material design documentation rather so i do highly suggest you check that out and just try to follow what they recommend as best as you can but also you know feel free to take some creative license over what you do as well also one quick point with uh styles that you can actually use them like in sort of a css way so you can overwrite different values but also inherit from parents and and stuff like that and i use that quite frequently and in today's video i'm going to be showing you how to set up the navigation component from android jetpack so firstly as of making this video the navigation component does not work out of the box with on activity result i did see a couple people had some really hacky shared mutable state solutions for solving this problem but i wouldn't actually recommend them when it's actually easier to just not use the library in the activity which receives the result which is what i chose to do in this particular application so that's kind of one of my criticisms here is there's kind of a strong push to move to a single activity approach and this was one case where i wanted to do that and couldn't based on framework limitations now like i say as i'm making this video i have seen that there's some discussion about adding integration with navigation and on activity result possibly in later versions although it doesn't appear to be a very high priority anyways in fairness if you're watching this video several months or even years from now there's a chance that it has been integrated with the library and if that's the case then that would make me very happy i was also told recently by a friend of mine davora maric who's an awesome programmer that navigation does not play nice with few pagers and fragments so another thing to be aware of so while i'm not really happy about some pretty common use cases having some problems with the library i think those are things which hopefully will be improved on over time so let me get to the second reason why i'm not super happy with the library so i just didn't really feel like the steps required to implement navigation and the fact that we're basically pulling logic out of kotlin code or java code and putting it back into xml was really worth the effort of setting up relative to the problems that it actually actually solved in my applications so what i'm basically saying here is uh what this library will do for you is it'll allow you to basically get rid of some of the fragment transaction or start activity type logic which you would normally use to navigate to different screens in your application and so it's not that we're actually just getting rid of all of that logic in a sense we're basically pulling a bunch of it out into an xml file and then we're having this framework generate a lot of that logic for us now if you get fast enough with the visual editor and you're familiar with all of the features you can actually write this logic pretty quickly using the tool but i just wanted to mention that relative to say handwriting this code with kotlin extensions or something like that i didn't feel like i saved much time okay so with all that criticism in mind and let's just keep in mind this is a fairly new tool i did like the navigation feature in the parts of the app where it didn't cause any problems it worked quite well in that regard in particular i do like the say fargs option for basically sending type safe arguments between different screens of your application and i will be demonstrating that feature today finally if you'd like to follow along with this tutorial please clone or download the repository link in the description box down below okay so the first thing we'll do is we'll look at configuring this thing with gradle so in your build script function here in your project level build gradle file we need to add a particular configuration to the build script dependencies in particular we need to add this thing here android x dot navigation colon navigation safehargs blah blah blah and once you add this thing in uh that's going to allow you to use the safe arcs plugin and what we'll do next is we'll see how to add that to the module level build gradle file in the module level build gradle file you're going to want to add up at the top here apply plugin androidx.navigation.safeargs.kotlin now if you're in java you're going to want to probably delete the dot kotlin and i think that's the appropriate plugin for java anyways uh down in the dependencies the two dependencies that we'll really be working with are the navigation that fragment dash ktx and the navigation dash ui ktx so again i think if you're working with java or something like that you just delete the dash ktx and it'll work work for you but there is a page where you can figure out the particular dependencies so just go check that out in the android documentation okay so let's get started building out the navigation component so the first thing we're going to need is a navigation graph and this is basically like an xml resource which specifies all the different destinations which our navigation component can travel to along with plenty of other details so what i'd like you to do so presumably you have downloaded the repository so go ahead and in the res navigation directory just notice we have this file nav graph which is what we will be building what we'll do is we'll create another file so i'm just going to right click on navigation we'll go to navigation resource file we're going to call this nav graph demo you can call it whatever you like and so what we'll do is we'll basically rebuild this nav graph file over here and i just want to have it there so that you can reference it so here we have the navigation editor so we've got a couple different things here on the side panel we have this destinations tab here and as you can see we don't currently have any destinations and no nav host fragments is found so we can go ahead and ignore that for a minute and what i'd like you to do is uh we've got this new destination button up here so go ahead and click on that one and it's basically what we're going to do is we're going to add all the different uh fragments and or activities which we want to be able to navigate to and these things are known in this library as destinations obviously so we'll need to add the note detail view fragment then i'm just going to add in the note list fragment and as i mentioned before just due to the integration limitations with onactivityresult uh we're not actually going to jump to the login view which is a fragment we're actually going to have to jump to the login activity so we'll just select this option here all right so we've added all the different destinations but as you can see we have a little bit of work to do so the first thing i'm going to do is i'm basically just going to click and drag these things storyboard style and roughly where i want them so we're going to drag login activity up here and we'll note listview is actually kind of like the main sort of dashboard of the application and we'll bring note detail view down here and before we do anything else i just want to do a little bit of clean up okay so we've added our destinations but i think we need to hop into the text editor for a minute and just make a couple of adjustments so i'd like to be able to actually preview visually the screens that are that the application has in the each given destination and one of the ways we can do that is we can use this tools layout attribute here so for those who aren't aware the tools name space is basically like a design time namespace and whatever details you add here actually get stripped out of the packaged application so in this case we don't actually want to refer to the activity login layout because the activity login is just a container what we'll want is i believe it's called fragment login there we go and as you can see that should fix that up there we go that's exactly what i'm talking about there so we'll just add that in for the other fragment destinations here so in this one here i'll zoom in a little for everybody so on that one that's going to be fragment note detail and then up above here fragment note list all right loading and that's looking a lot better except i think i've reversed them okay so this is fragment no detail you know i could edit this out but i'm just going to leave this in here that's uh it's pretty spectacular ryan okay and let's just hop back to the design editor okay that looks more like it so as you can see it's added a two onto these names because we've already defined them in the other file but that's totally fine okay so the way that we actually kind of define how to navigate between these different destinations is by setting up actions so the way that you set up actions in the visual editor is uh you'll notice a lot like constraint layout each of these different destinations will have this little thing you can click on here so you can click and drag that to a particular destination and what that has done here is it's added this arrow and the arrow basically represents an action so go ahead and do that now how this thing basically works is that the note list view is able to jump to either the login activity or it's able to jump to the note detail activity so i'm just going to click there again come on there we go and i'm going to click and drag that to the note detail view now in this particular case once the user is done messing around with the note detail view either when they hit the delete button kind of hard to see but yeah there's either a delete or a check mark button there so once the user does that then they're basically going to jump back to the note list view so i'm going to select no detail view and then i'm going to click and drag this one oh that's not what i wanted to do and we'll just have it point back to the note list view so as you can see we've defined pretty much all of the different actions or navigation actions which we'd like the application to be capable of implementing uh there is one last thing we need to do here though well there might be a couple of things but what we need to do is uh in this particular case often what will happen is uh this is basically like a list view and oftentimes the user will be selecting an item in a recycler view here then we'll need to send the id of that item over to the note detail view and this is a very common pattern you'll see this all the time it's a lot better than actually sending the whole note item you just send the id over so what we can do there is we're going to click on the action between the note list destination and the note detail destination here and i'm going to click on the attributes panel here and what we can do is we can actually add some argument values uh to note detail view sorry don't actually click on the action here click on no detail view and this is where we can add arguments so in this tab here we have arguments we're just going to hit plus and so the name of this argument is going to be note id definitely try and give it a good name of course the inferred type is going to be a string sorry not the inferred type the type is going to be a string you can select inferred type but we're just going to use some simple data here and then it's not going to be nullable and we don't really care especially about a default value in this case so yeah just go ahead and type node id select uh string as a type and hit add and so just as a reminder to everyone all the stuff we're doing in the visual editor is basically just uh creating a whole bunch of boilerplate in the xml for us so what we can do here is uh now that i've added that particular argument to our note detail view uh it's added this little entry down here so that's basically all we need to do to actually configure this thing properly just one final note here up in the top of the navigation tab here we have this app start destination attribute so this is where you specify basically which particular destination you want to start the application from and in this case we don't want to start in note detail view we want to start in the note list view so i'm just going to type note list view 2 or whatever name it has and that'll be the starting point of the application now when i say starting point of the application that's assuming that your application's manifest file points to the activity which will be basically like the host for our navigation setup and we'll look at that in a moment okay so now that we've built out this particular xml file here uh what i'm going to suggest you do is unless you actually want to keep this thing just for notes or something like that please go ahead and delete this file we just created because we want to actually be using the old file just so it works well with everything in our application i just wanted to show you the actual process of building out the navigation graph using the design editor all right so now that we've got our navigation graph set up what we can do is we can set up our nav host fragment now uh again just a really quick bit of practical information here what i would suggest is so the one of the goals of this particular library is to go for a single activity approach i think that's totally great except as i mentioned before i literally wasn't able to do that due to uh library limitation but what i'm going to suggest to people is for different features of your application where you're running into trouble with this particular library my recommendation is to just pull that into a separate activity and you can you you can apply like a model view presenter or whatever to that particular feature of the application just have your navigation graph point to its activity instead of the fragment and then just do what you would normally do and when you need to jump back into the navigation graph you're of course going to have to start the uh sort of navigation host activity which in this case is note activity so anyways enough rambling let's go ahead and configure that node activity and so the node activity basically manages both the note detail view and the note list view okay so what we'll do is again we're going to create an extra file which we'll delete afterwards so just go ahead and right click on the layout here and we're going to go to new layout resource file and this file is going to be called activity note demo and for the root layout we're going to select a constraint layout there we go and that's what we'll start with here okay so what we need to do here is we need to add this thing called a nav host fragment and we could add that manually but there's actually a way to do it really quickly in the design editor so in the palette here just on the side there's the containers menu here and in the containers menu you're going to find down below this thing called nav host fragment so what you'll want to do is just click and drag this nav host fragment we can center it doesn't really especially matter here and it's going to give you a list of navigation graphs to select from of course select nav graph and as you can see here it's done most of the work for us we're just going to hop into the text editor so for the layout width we're going to say match parent same thing for the layout height and there's a couple other things we can just remove the absolute layout editor here so we're specifying the navigation graph that we built um we have this thing set as the default nav host so this is kind of like a default configuration which will work kind of easier and then also when we see this android name attribute this actually refers to the particular class name of whatever fragment so in this case just note that nav host fragment is not something that we are going to actually create we're going to use the default implementation and this is basically how we point to it up here now in this application we of course call this thing fragment i can't type fragment nav but yeah this is basically all the configuration we need to do and then what you can do is just go ahead and delete this file or keep it if you like okay so the next thing we need to do is we need to have a nav controller which generally speaking will be an activity so what we're going to do is in the note package of our main package here just open that up and so the file will be rebuilding it won't take long is note activity and again what we'll do is just right click on note go to new kotlin or java class whichever you prefer go to note active type note activity demo and don't worry about actually creating a proper activity and adding it to the manifest okay so what we'll do next is we'll just type class note activity demo and then that thing is going to extend app compat activity like so give it a constructor and the particular function that we're going to need to add in here is we'll need to override oncreate so usually it'll auto complete for us here let's see let's go with this option here okay so what we basically need to do here is we need a nav controller object which fortunately is super easy to correct or to create and what we'll basically do is when we need to actually perform these navigation operations we'll be basically getting a hook to this nav controller through the library so anyways what you need to do is go ahead and add private late init var nav and that's going to be of type nav controller like so then we need to create this nav controller so we'll say nav equals navigation dot find nav controller and what we'll do is we'll pass this for the activity and then it also requires a layout res id which is the nav host fragment and so the nav post fragment is basically what what we sort of swap the views in and out of so in that case that thing is called r dot id dot fragment nav like so so it's complaining that i need to import r but i'm just not going to worry about that if i hop over to note activity as you can see that's actually all we need to do and this was one part of setting this thing up that was actually like really quick and painless so now that we've got that done we can actually take a look at how to actually use this library in action okay so i'm going to open up a note list view and we'll look at some different ways to actually use this library to navigate to different destinations so i'm going to hit control n note list view and we'll just look at two particular situations here so in the first case we have a situation where we're basically just navigating to a particular destination without any arguments so there's actually a lot of different options we have as we can see for navigation so basically how this tool pretty much works is at least when we're calling it from a fragment here we have this find nav controller function so what happens is we call find nav controller and that's of course going to through the framework grab this thing we have here in the activity and then we can perform navigate operations among other things to jump to different destinations so this is almost kind of equivalent to like saying start activity except we're not working with activities here so i just want to bring your attention so if i click within the parentheses of this navigate function here and hit control p i just want you to notice that there are a lot of different options for what you can pass here so in a really simple case we basically just pass it the id of a particular destination so we have r dot id login view if i hop into the nav graph here just notice that if we go to this activity uh the id of this destination is login view so that's where that's coming from so that's kind of the first case now what about when we actually want to pass arguments type safe arguments to a particular destination and let me tell you this is one of the things that i actually quite like about this library and probably the main reason why i'm actually doing this video to be honest is the safe arguments feature here so when you want to navigate with arguments to a particular feature so in this case we want to go to the note detail view and here and we need to pass some kind of id to it so when we're creating a new note so when the user hits the create new this is like a floating action button and they want to create a new note then we pass just an empty note id and just understand that on the other side node note detail fragment and its uh view model is going to be aware that this is a new note so that's just in case you're wondering why we're passing that now what we need to do when we actually want to jump to a particular destination with arguments is we need to use this note list view directions dot action note list view to note detail view where the hell did that come from obviously we didn't write that so this is kind of one of the main points of this library is that the work you do in the xml will generate some functions like this that you can use to perform these different navigation operations so obviously in the simple case we can just call navigate in this case we need to use these note this note listviewdirections object and where this function came from and this uh or sorry where this class came from and this function of the class came from is based on some generated code from our xml configuration here so with that in mind you may need to build your project in order to actually create these things because i'm pretty sure they're made at compile time so in this case once we've created our direction and we've given it the particular action and the arguments that are required of that action and all of this has been generated for us then we pass that direction object to our nav controller and then that's how we actually get to the other uh fragment with the arguments okay so the last thing we'll do is we'll look at how to get the arguments out of our receiving destination which in this case is of course a fragment so i'm going to scroll down to the viewmodel.handlevent function here that's within onstart and so basically what goes on is uh we have this note detail view args object which is of course generated for us then we call dot from bundle and we supply the arguments property of this fragment and then where does dot note id come from so this is actually the name of the arguments that we defined in the nav graph as you can see here and in this case once we grab those arguments we just pass them to the view model in the form of a sealed event class and then the application figures out what to do from there and in this video i'm going to be talking to you about using fragments as views in model view view model architecture and we'll also look at how to use kotlin synthetic properties to eliminate boilerplate ui code and refer directly to xml views now how this is going to work is in this video we will write the fragment and then of course in the next video we will write the view model which our fragment currently talks to before we get to coding the fragment i just wanted to talk about model view view model architecture for a moment so as discussed in the second video in this series and you should probably go and watch that if you haven't and you're curious about this particular pattern there's a couple really subtle ways to do it differently which don't actually break the pattern entirely so i won't be going into great detail on this but basically what i'm saying here is the style of view model and view that we're going to be writing today is basically such that it allows the view to be very simple and easy to write and easy to test at the expense of moving a lot of the presentation logic of the view into the view model it'll basically simplify construction of the view but the key point here is the more details or the more presentation logic we include about a specific view in a view model the less reusable the view model becomes so what i'm saying here is if you have a view model which you plan to use for a variety of different views you're going to want to take the other approach that i discussed not the one where you have lots of details about the view in the actual view model just so there's no confusion about what i just said there let's have a quick look at two different view models in this project so the one we'll be writing today or sorry the one that our fragment that we write today we'll be talking to and the one we'll write in the next video is the user view model so the thing about this view model is in keeping with the pattern it does not directly reference any particular view however it does have like i said before specific details about a particular view so we see fields in here like sign in status text auth button text satellite drawable so as you can see this view model is going to work really well with a particular view but it's not necessarily going to be something that we can reuse with a whole bunch of different views when i open up note view model i basically you will pretty much not see any specific details about a particular view within reason so we're not going to see these show error state type functions we are going to see things like note was deleted note was updated and we'll see that we do actually publish a note object to whatever observable is or sorry whatever observer is listening but the thing about this is by taking this approach of having more reusable view models we're now relying on the fragment or the view to basically handle this presentation logic okay so if you would like to follow along with this tutorial and i do suggest you do if you're going to watch it then check out the description box down below you'll find a link to the open source code repository and you can either clone or download it anyways what we'll be looking at first is how to configure kotlin synthetic properties in gradle so the first thing you need to make sure is that you have the kotlin gradle plugin installed this one here sorry my word wrap is going to screw it up so if you check marked the box that your project is supposed to be a kotlin project in android studio most likely you won't actually have to add this in manually it should be there if you've configured a kotlin project in a more recent version of android studio but i just want to point this out in case there's any confusion secondly one thing you probably will need to add is go ahead and open up the app level build gradle file and this is true for whatever module you might want to use the kotlin synthetic properties in you're just going to want to apply this particular plugin here kotlin android extensions apply plugin and that will allow you to use kotlin synthetic properties so the view class that we'll be writing today is called login view and i just want to make one more final note here uh there are two functions in it so in particular i'm talking about start sign and flow and on activity result and we're actually not going to be coding out those two functions and the reason why is that i'm going to go over those when i talk about implementing firebase with google sign in provider so we won't be coding these two functions here in this video but like i say we'll get to that eventually okay so what i would like you to do to get started here is you can either make a new file with a slightly different name for login view because that's what we'll be rebuilding or what you can do is you can just select everything under the package declaration here just scroll down and have a good delete and that will be our starting point for today's tutorial all right so the first thing we'll be doing is we'll write out the class declaration so go ahead and type class login view extends fragment like so just line that up a little better and of course we will have to import the appropriate library so in my case i'm using the android x library so go ahead and pick that so the next thing we'll need to do is we want to add a reference to our view model and we'll have to use a late in it var for that also in general since i don't want anything else kind of messing around with this particular reference we're going to make it private private basically just means that we can only see it in this particular class all right so when we're working with fragments we need to tell the fragment which layout to inflate now if you're using data binding there's a slightly different process for this but what we're going to do today is we are going to override the on create view function like so and uh really appreciate that autocomplete there all right so go ahead and select everything after this return statement here and delete that so what we're going to do instead is we are going to inflate a specific layout so we're going to take the past in inflator and we're going to say inflator dot inflate and the resource we're going to give it is we're going to point to the fragments layout file so we're going to type r dot layout dot fragment login now it's going to be complaining because it wants to import r so you can go ahead and do that i just hit alt enter there to import it and that's satisfied that particular problem and then we need to give the container so this is where the view will be inflated into then we're going to type false for attach to root now this particular option falls for attached to root can be a little bit confusing for people but just understand that most of the time you want to leave it false and it will still actually appropriately add our fragment to the activities view hierarchy so don't worry about it anyways what we'll do next is we'll begin writing out our onstart function so again i'm going to type override fun on start like so and so what we need to do at this point is uh we're going to already start to refer to a couple different views in the xml layout from our onstart function here so what we need to do is we need to set up our synthetic functions now luckily this is like seriously one of the easiest things to do ever once you've added the library as we discussed before so all you need to do is just go up to your import statements here so what we're going to write is we're going to type import kotlin x dot android dot synthetic dot main dot fragment login dot asterisk so in case you're curious the asterisk is basically saying whatever is a for lack of a better term uh member of fragment login then we want to import all of those things so effectively what that's going to do is if i open up a fragment login here which is the actual view oh that took a while to load so basically what's going to happen is we can now refer explicitly to these particular view ids we don't need to do any fine view by id stuff all we need to do is just add in the appropriate layout and we're good to go okay so what we're going to do now is we are going to assign our view model now we'll type the code out here by hand but i'm actually going to be covering how to actually set the dependency injection and view model provider stuff up in a different video so if you're curious about how to do this in more detail i will eventually get to that covering a lot of stuff in this tutorial so what we can do is we're going to type view model of course referring to our reference above then we're going to say equals view model providers with an s of and then for this particular thing let's just go ahead and import that so it stops screaming at me um we're going to type this passing in our fragment again i'm not going to go into detail about this we're just going to type this out all right and then we'll type login injector which is a custom written dependency injection class which extends android via model so when we do that we need to type require activity this might be a new function for some people around here i'll get into that when i talk about this particular code in the other tutorial but this is kind of a handy little function that's been added somewhat recently and then we're going to refer to the that's going to get our activity and then we get the application and then once that happens there's one function in this particular class login injector which is provide user view model factory like so now we're not totally done yet because uh we've configured that aspect and now what we need to do is we might need to type dot get on our view model providers and then we're going to pass the specific view model that we require here so we're going to type user view model which is the view model that we will be talking to and we need to kind of refer to the class file here so what we're going to do is we're going to type double colon class dot java like so this is one of the things about kotlin the uh the um when you need to reference a particular java class the syntax for it is kinda wacky but whatever it works so uh that's all we need to do to assign our view model our first order of business now is going to be starting the background animation so if i briefly look at the layout that we're writing the fragment for or vice versa you understand what i mean it has a background which is like a space background basically and in the application it actually kind of animates if you're wondering how i did that i did cover vector drawables and animations in a particular video in this series i'm sure you're tired of hearing that but yeah go and watch that video if you want to figure out how to do that in detail so we're going to need to cast it as an animation drawable so type brackets first and then what we'll type is root fragment oops i can't fragment root fragment there we go holy crap that was pathetic and then so what we need to do is we want to get a hook to the background of this layout the space loop drawable here so what we can do is we're going to type root fragment login so we're referring specifically to this layout and then we're going to type dot background which is going to return a normal drawable now this the thing we have in this drawable is actually an animation list so what we can do is we're going to type as sorry animation drawable is what i meant animation drawable okay and then what we're going to do is we're going to type dot start with fade so immediately you're going to be wondering ryan what the hell is start with fade so it's actually just an extension function that i wrote in this project so i'm going to hit ctrl shift n and we'll type android and then there's a file called android extensions in the common package and you'll notice it has this particular function here start with fade so all it does is instead of having to repeatedly write this code out i've just pulled that code out and put it in an extension function which just means that i can just type start with fade and have instead of having to type this crap here so there's no magic this well there's the magic of kotlin extension functions which i really like but there's nothing too crazy going on here so the next thing we'll do is we will set up our click listeners and kind of bind them to the view model appropriately so since there's a couple of lines in that function or there's a number of things we need to do in order to set that up we're going to create a helper function so we're just going to call this thing set up oops set up click listeners i've got my keyboard in an awkward position and it's just ruining my typing skills my apologies set up click click listeners like so and then i'm just going to click on that hit alt enter create function and that's going to build it down there and then this is what we'll do next so like i said before now that we have kotlin synthetic properties set up we can just refer directly to the xml ids so the first one we're going to assign is the auth button so that's going to be this button in particular here the thing that currently says sign out but what it says changes frequently so we're going to type btn underscore auth attempt let it autocomplete dot set on click listener and we're going to give it a lambda expression here and so what we want to do when this on click listener fires it's going to basically call the code in our lambda that's how this kind of works in that event we want to type view model dot handle event so this is basically like a generic function which you'll see in all of my view models and how they work let me just pull the code up really quickly here type base view model so we'll go into more detail about this in the next video but just so you understand what's going on here we have this abstract function handle event and it takes some particular type so let's have a quick look at the view model itself that we're going to be working with that's again going to be user view model and just notice that it extends base view model and the generic type which i pass for each given view model is some particular kind of sealed class which represents different events i know this is a lot but just understand that what this login event thing does is it basically just represents different events which could possibly propagate from a particular view or a set of views so i just wanted to show you the code really quickly so you know what's going on here anyways back to our view so uh we're going to call our viewmodel.handle event function and what we're going to pass to that is login event dot on auth button click so this is basically our way of telling the uh user view model hey someone just clicked the auth button so you need to do something so that's not the only thing we need to assign here we're we're also going to basically make it so that if the user hits the back button then it's going to start the list activity so what i'm going to do is i'm going to type imb toolbar back is what it's called dot set on click listener there we go again lambda that pardon my language and then what we're going to do is we're going to type start list activity so this is actually a function we will code so i'm just going to hit alt enter create function start list activity down below so we're going to use kotlin single expression syntax so we're going to type require activity again dot start activity and in our start activity block we're just going to go ahead and create an intent so we're going to say intent and then in this intent we're going to type activity which is uh basically the activity for this particular fragment then we're going to type where we want to get to which is note activity and then we'll do our handy reference to java class syntax like so and that'll need to be imported okay so with that when someone hits the back button they're going to be sent to the note activity now some of you may be wondering hey i thought you were using navigation in this particular library well actually because of limitations which i discussed in the video where i covered the navigation library we do use the navigation library but not in this particular feature of the application and the reason is because it doesn't play nice with on activity result okay so we're almost done with our setup click listeners function there's just one more thing we need to do we need to intercept on back pressed and the reason for that is just because of the awkward integration with the navigation library which is not really my fault so we're going to say require activity and then we're going to type that dot add on back pressed callback i can't talk today for some reason so uh we're going to have to monkey around with this a little bit so we're going to basically put some parentheses here around our lambda we will still need the lambda expression so for the first parameter we're going to type view lifecycle owner and that's a property of our fragment here so if you're wondering where that's coming from that's where it's coming from and then we need to create an on back pressed callback from our lambda so we're going to type on back pressed callback actually autocompleted this time that was handy and then what we'll do inside of this on back pressed callback is uh we're going to type start list activity and this thing's complaining because this function must return a boolean and the boolean that we'll be returning is true so the reason why we return true here is because we're basically telling the operas operating system hey don't worry about handling that back click event we've got it covered don't do your thing anyways let's move on here so the next thing we'll do is we're going to write our basically another helper function called observe view model and what this particular function is going to do is we are going to observe some view models so i'm just going to hit alt enter create function down below so basically what we're going to be doing here is we want our view to pretty much attach to if i can find it here pretty much every publicly visible observable that our user view model possesses so basically what that's going to look like is we're going to be typing view model so the first one we'll do is sign in status text dot observe so we're going to pass view lifecycle owner which is a property of this fragment so it knows to pay attention to that particular life cycle and then we're going to create an observer lambda function and so again this is basically just what do we do when this particular observable publishes data so how do we handle the data and this is where this particular style of view model is really quite handy because basically all we do is we just bind it directly to whatever gets passed in so in this case i'll type up here that if you don't understand how lambda syntax works just understand that whatever gets passed in here is inferred to be this variable called it so for the first one i'll actually give it a different name than it we're just going to call this text and then i'm going to hit the arrow thingy here and then we're going to type um we're going to leave it like that and that's going to assign the name text instead of just using it i'm just doing this so hopefully you kind of understand what's going on so this particular field that we're working with here basically dictates what is displayed in this text view down here i know that's hard to see but this uh basically login status display down here so what we can do is we can refer to that particular view so lbl login status display and we're going to get its text property and we're going to assign that to text so for the rest of them we're going to use the it syntax but i just wanted to demonstrate that here in case anyone's confused about that i did do a video about that what what does it mean in kotlin so you can go and check that out if you like so what we'll do is we'll type out another uh observable here so we're going to type viewmodel.off button text so this is going to be the text for this button here that currently says sign out and it's the same process here so we're going to type observe give it the view life cycle owner give it a hook to our fragments life cycle and then we're going to give it another observer and in that observer so now we're referring to btn auth attempt then we're going to say dot text equals it so the rest of this observe view model function is just a whole bunch more livedata.observe functions so there's nothing really new there and i don't think there's actually any point in us typing that code out together what i'm going to suggest is if you'd like to practice maybe try implementing the rest of this function yourself and what you need to do is basically you just need to write one of these statements one of these observed statements for basically everything you see here now just one important thing to note these two live data observables here as opposed to well actually this one does affect the user interface but this one in particular is actually just a way to communicate back to the view based on what happens in a particular auth state so we're going to learn a little bit more about that in the next video where we actually write out this view model but yeah that's basically all i wanted to cover in this particular tutorial and you're watching video number seven of my android 2019 tutorial playlist so in this video we're going to be looking at wiring up the view model and in the previous video number six basically uh we'll be writing the view model that we hooked our fragment up to so if you're curious about how to actually write the fragment that this particular view model is going to publish events to or data too then you want to go back and watch that video first now once again before i proceed if you haven't already watched video number two where i go into detail about the model view view model architecture on android you might want to watch that first and the reason why is it's important you understand that there's a couple different ways to do uh the interaction between the fragment and the view model or the view in the view model in general and the approach we're going to be taking today is basically good in a situation where you don't need to reuse your view model and you would prefer to have a fairly simple view which doesn't have a whole lot of logic so basically like i explained in detail in that video what we'll be doing today is we'll write a view model which basically allows us to pull pretty much almost all of the presentation logic of the fragment the view out of the view and the good thing about this approach is that we can still maintain the model view view model pattern uh by communicating with the fragment only through live data objects so like i said in the previous video you can also use data binding but today we're just going to be using live data to communicate between the via model and the fragment all right so before we proceed you may want to grab the repository or the code that we'll be working with today link down in the description box below and you're going to want to either clone or download that particular project and pull it up in android studio or whatever is your preferred ide anyways before we get to the specific view model that we'll be writing today i wanted to show you the abstract class called base view model which the v model that we'll be writing extends so we're not actually going to write this class out but what i wanted to do is basically just talk about it really briefly and what it does for us so there's a couple different options for extending the functionality of existing sources in kotlin and when we want to really object oriented solution one of the best ways to do that is with an abstract class so the purpose of this base view model class is basically anything that is going to be common to basically every view model in this application i want to include that in the abstract class so if you'd like a detailed explanation of this kind of thing i do go into a detail about all kinds of different things including how to achieve similar behavior with extension functions in my kotlin course link in the description box down below so do consider checking that out anyways what we're looking at here is our base view model class basically is going to be containing a coroutine context object and it extends of course view model from architecture components and then it also extends coroutine scope so the reason why i wanted to bring this up is it's important you understand that this is how or where we're going to kind of launch our co routines from now i'm not actually going to go into detail on core routines in this particular video i will go into more detail in another video in this series but just understand that uh when we look at a particular view model so for example we have our coroutine scope set setup in this class and then we have our routine context down here and just notice it's going to be basically placed on the ui context dispatchers.uh main thread and then we have our job tracker object which allows for cancellation uh functionality so when i open up a particular view model which basically that's not a view model good job ryan when i open up a particular view model which extends our base view model just under understand that every time we're making this launch builder here it's going to be an extension on our root coroutine scope so anyways i'm not going to go into more detail on that in this video but i will talk about that in detail in another video and i just wanted to mention it here in case you're wondering why is the launch thing all yellow here uh that basically means that it's an extension on our view model so one other thing i would like to mention so the thing about working with this view model is obviously our live data objects have to be publicly visible but since we're not returning live data objects from the back end we have to work with mutable live data so one suggestion from al warren who's been a really awesome contributor to the wyze slack channel he just mentioned that one of the ways you can kind of get around this issue of having a publicly visible mutable live data object is to basically make the live data field which is publicly visible or the live data reference rather you basically make the actual data the actual mutable live data object as what you would maybe call an implicit backing field in technical language but basically what we're talking about here is this thing here the error state which is the mutable object and we'll see a couple different examples of this we can kind of hide those behind hide them the mutable live data reference behind a immutable live data publicly visible reference so basically what i'm saying here is if you want to improve your encapsulation then do consider taking this particular approach here all right so the class we'll be writing today is user view model so there's kind of two ways you can do this so i'm assuming you've downloaded or cloned the repository or you can just watch if you like but you can either basically just uh delete everything in here except for the package statement up top or you can just create a new file maybe call it login view model and build them kind of side by side whichever you prefer today what i'm going to do is i'm going to just actually select everything here and delete it now before i do that i just want to mention very briefly one thing we're not going to code today in this particular view model is the on sign in result function now the reason for that is that i'm going to be covering that in the part of this tutorial where we discuss using firebase and google sign in provider anyways with that being said i'm just going to delete everything there and maybe i'll leave this comment up top just for the fun of things and we can get started building our view model so the first thing we'll do is we'll build out our class declaration so we're going to type class login view model actually sorry user view model probably should have picked a better name for it so we've got a login view model and this thing is going to extend our base view model class now when we extend the base view model if i just hop back to it really quickly we have this function here abstract fun handle event and then we also have what's known as a generic type so basically what this is all about is that uh t is going to be some kind of sealed class which represents different events which can propagate from the user interface so we won't write that particular class but i'll just uh show you what it is in this particular case so it's going to be a login event class let me actually just pull that sealed class up so you know what's going on so we've got login event and uh so yeah as you can see just a pretty runofthemill uh sealed class here now one of the things to mention is that we in some cases will be returning this login result class here so that's just basically like a data wrapper essentially so it just maintains a request code and a user token so this is the stuff which will be dealing with in the firebase video but again since we're kind of using it in this particular tutorial i just wanted to briefly mention what it is so we've got a not too many different events here just the three so there's on off button click on start and on google sign in result and these are all events if i open up uh so this is going to be fragment login so that's basically all the events for this particular layout here back to our user view model all right so we have our login event class and because we have that one type in here we do need to supply a particular type for our ceo class so that one is going to be a login result like so and then we need our constructor our initializer i think it's actually called and uh that's not all though so i'm just going to give our curly brackets here so base view model is expecting a coroutine context object so what we're going to do is we're going to basically pass in a reference here called ui context which is going to extend coroutine context and so that's going to get passed into our view model here so in our base view model here that's going to get passed in so during testing we would basically want to mock or fake this particular object and return dispatchers dot unconfined but when the application is actually deployed then this is going to be basically running on the main thread or rather our coroutine scope will be scoped to the main thread anyways back to our user view model all right so we've got our ui context object so what we need to do is we don't actually want to hold on to this thing in our actual view model we just want to pass that thing to the super class here the base view model class so i'm just going to type ui context and that should satisfy that particular error and now it's going to scream at us because we need to implement our handle event function so i'm going to click on that hit alt enter and then implement members handle event and there we have our handle event class with the appropriate sealed class accompanying it all right now there's one more thing we need to do with our constructor so the way that we actually get data basically in and out of this particular view model is through a repository again i will go into more detail on this in its own particular video in this series but what we're going to do is we're going to type val repo and that's going to be of type i user repository all right so we'll actually get to coding our handle event function a little bit later what i wanted to start with here is the various view model objects or sorry the various mutable live data objects that we'll need to be working with so uh let me write one out here and then we'll talk about how this kind of works so the first one we're going to write is the actual data model which this particular view model uh holds on to and we are going to make that one private because i don't want that one to be uh tampered with whatsoever except for within this particular viewmodel class so we're going to type private val user state and that's going to equal mutable live data and the type is going to be user so if you're not familiar with live data so basically how this works is it's going to pretty much wrap some kind of object it could be a string in this case it's the user data model i'll just open that up really quickly here and it's just like a really simple data class which has a uid and a name so this mutable live data is going to basically wrap that object it's complaining because i need to add that and then that's how we'll actually kind of persist the data in this view model now some of you might be wondering what's the difference between mutable live data what's and live data and when should you use them so i would basically put it like this live data is essentially an immutable class so basically what that means is that you can't change a live data object sort of within the class that's holding it so what you can do is let's say hypothetically we were actually working with a uh user data model which was coming in from a back end tool like say room so the important thing to know here is if we were returning a live data object from the backend then you would want to make this live data but in this particular case since we're returning an object just the user object which isn't a live data object that means we need to make our live data mutable so this basically means as you'll see in a moment that we can actually from within this class change the particular value that our mutable live data object wraps okay so we've made our actual data model wrapped by a mutable live data object and then what we need to do is we basically need to write out a couple different more live data objects with the goal of basically covering all of the different widgets and control operations control logic which our view will need to implement or or listen to essentially okay so what this particular thing is going to look like is we're going to type internal val off oops auth attempt so the reason why we're using internal is i basically want these things to be visible by anything within this particular module so for example our fragments but just for better encapsulation we're making it uh invisible outside of any outside of any other context so anyways we've got internal val auth attempt and then that's going to equal uh mutable live data again now for the type here we're going to use unit so why exactly would i use unit this is very similar to like void in java not exactly the same but quite similar in fact it does get mapped to void in uh when it's decompiled into java anyways how this thing basically works is i suggest using unit when you want to trigger some kind of event but you don't actually care about any particular value being passed into that event so what i think i'll do is i'll just show you really quickly what this looks like in the view so if i look at auth attempt here just notice that we're not actually returning any kind of value there is kind of an it which is of type unit that will get passed in here but in this particular case all we want to do is we just want to call a particular function uh when this particular mutable live data is changed so we're changing it and triggering the function but we're not actually changing it to a particular value anyways what i'll do next is i'm just going to hit control just put my mouse right there and then i'm going to hit ctrl d which will copy the line and then we're going to have a second control logic observable here so this is going to be called start animation and again that's just going to return unit same idea all right so we have our two control logic fields here or observables or whatever the hell you want to call them and in case there's any confusion here the reason why we're doing this is we need some way to call back to the view so in this way we can call back to it indirectly anyways we need a couple more mutable live data objects so in this particular style of building view models we basically want a live data object to represent every item in the uh layout that we're dealing with here so i'm just gonna again open up let's do ctrl shift n and let's see fragment login so what i'm saying here is we basically the way i actually built this thing is i said okay for every item in this layout every widget which changes we need a mutable live data object to basically represent the value that it will have so in this particular case we have this animation drawable here we have this text view which basically just displays the current login status and then we have this off button down here which is how we trigger auth events and this thing's text will change as well so it follows that we'll need a mutable live data object for each of these things so uh what we'll do is uh so i'm just going to type ui binding here because that's basically what we're doing and then we're gonna again use internal val sign in status text so that'll be for our sign in status text view and that's gonna be a mutable live data object and it's going to be of type string perfect now since even the animation drawable we're going to be giving it a url to a particular resource all of these things are going to be strings so again i'm just going to hit ctrl d twice like so and we're just going to update the names here so the first one is going to be off button text and by the way pick good names for these things like don't don't do short ugly names that leave people guessing about what they mean then we have the satellite drawable like so i can actually probably pick a better name for that one too to be honest but that's okay good enough all right so we have our live data objects and then what we'll do next is we'll get started kind of working with our handle event function here all right so what we'll do next is we will code our handle event function and that way you'll get to see our sealed class in action how it actually works so what we're going to do so there's a couple different things going on here what i'm going to do is i'm going to stub out the presentation logic functions and then we'll kind of implement those towards the end here but we can actually get started with them so we're just going to type show loading state and i'm going to hit alt enter create function show loading state and i'm actually just going to leave this to to do function here this is actually quite a handy function because if we do end up calling this particular function when we've forgotten to implement it then we will actually get a an error popping up which is actually what we want we want to know if this thing has been implemented or not before we ship the application so anyways we're actually going to as i say we're going to implement these functions a little bit later what we'll do now is so this is kind of the the main point of using a sealed class is we can represent a number of different finite states that the sealed class can represent and that can represent different events in the front end or back end of an application so i use sealed classes all of the time and if you're not familiar with them you probably should be if you're right in kotlin so uh what we're going to do is we're going to use a when matcher so we're saying when event which is what is passed in here then we'll give it some curly brackets and then this is where we list out our different cases so this is quite like a switch statement in java and csharp and those sorts of things so we're going to type is login event dot onstart so we're basically just going to make a function for each of these objects here and the data class as well and then we do an arrow sign thingy and then what we're going to do is we're going to type get user so we'll need to code this function out and what i'd like to do first is i'm just going to hit alt enter again create function get user and then we'll just finish off this particular handle event function before we get to that so we have two other cases so again i'm just going to hit ctrl d just speed things up a little bit this one's going to be on off button click and in that case we're going to type on off button click and again click on that hit alt enter create function cool and then for our last event here we have on google sign in result so in this particular case we're going to type in the on sign in result and then how do we actually get data out of our sealed class here so what we can do in this particular case is we type onsign in result and then by saying this is clause here this actually will cast our event to the on google sign in result if it does happen to be that particular class how we get our data out of that is we say event dot result which returns our login result object here okay and that's the property right there and then again we'll just hit alt enter create function now this is the function that we're not going to be coding out today so i'll just make a note here not coding this one today but in a later video where we talk about firebase and coroutines and stuff like that all right so that is our handle event function and then what we'll do next is let's go ahead and get started with our get user function here so for get user we are going to be talking to the repository object up here repo and let me just open that up really quickly i note repository sorry this is i user repository and just notice that these things basically they're all suspend functions so we're getting into coroutines land so in order to actually call these suspend functions we need to basically use uh some kind of coroutine builder generally speaking in this particular case since we have configured our base view model to be our root coroutine scope and our user view model extends that and i do recommend this i do recommend this approach for co routines uh we need to basically make this function into a launch builder so what we're going to do is we're going to type equals launch like so now it's important to note if you do not configure uh the appropriate coroutine scope just notice that this thing has this this protein scope thing right here if you do not configure that properly things aren't necessarily going to work the same way you're not necessarily going to be constrained to the appropriate con coroutine scope and i do not recommend you use globalscope.launch so what we're going to do it's actually really simple the way i build applications so we're just going to type val result which is going to be uh we won't specify the type here we're going to say val result equals repo dot get current user like so so if you're wondering what the type is here we're returning this result wrapper so this is a result wrapper that i've written myself there's a couple different libraries and stuff like that you can use i'll just open it up really quickly result and it just basically represents a value so like a success case and then it represents an error so like an error case big surprise there and then the way that we actually use it is with this handy build function so anyways that's what we're going to be returning but more specifically it's going to return either an exception or a nullable user object so why does it have both exception and then a nullable user well the reason for this is that we might end up checking our firebase auth for the current user and there's no current user so in that case we would return null this isn't necessarily an error case maybe the user just hasn't logged in yet so i'm trying to be a little bit more specific if there's an actual error occurring then i want that to basically be a different path that the event stream takes so anyways what we're going to do is we're going to hop back to user view model so how i like to use these result wrappers is again we're going to use a when when matcher so when result is oops not os result dot value like so then in that particular case uh we have a block going on here so there's a couple things we need to do here if we actually get a user object from our repo the first thing we want to do whether it's null or not is we want to say user state dot value so this is the value of our user state object here and this is how mutable live data mutable live data works so we can say user state dot value equals result dot value so what we're doing is we're taking the value out of our result obviously and then we're just assigning it to our mutable live data object so that fixes up our uh the the state of the view model here but of course we're still going to need to update everything else appropriately so in particular we need to update our ui binding so how we're going to do that is we're going to basically represent the user interface with a couple of different finite sort of states so what we'll do is we're going to write out all of those one after another i'm just going to actually stub them out first off so what we're going to do is we're going to hit enter again so the first thing i want to know is is this thing a null value which again isn't necessarily an error case and if it's a null value that means the user is currently signed out so we're going to type show signed out state like so then we're just again going to hit alt enter stub that function out and then we'll add an else case so we're going to say else show signed in state there we go just stub that bad boy out awesome so the only other thing we need to do here is we need to handle our error case so we're going to say is result dot error if that's the case then we want to show error state cool all right there we go and as you can see here we have all of our different ui state functions coded out okay so we're still not ready to implement these particular functions yet what we'll do first is we'll implement our on off button click function so basically what this is going to look like is we're going to type if user state dot value which is our live mutable live data object equals equals null which means that the user is not logged in then we want to call auth attempt dot value equals unit so what that's going to do is it's going to trigger the auth attempt observable in our login view here what that's going to do is that's going to call the start signin flow function down below here and this basically prepares the application to open up basically a new sort of activity using on activity result and what's going to happen is the user can basically choose to sign in with their google account and then once that process is ready then that result will be propagated to on activity result when the activity returns so anyways going back to the view model that's what we're going to trigger here so if user state value is null the user is currently logged out and they have pressed this particular button here except it would say sign in for example and that starts our sign in process now if the user else if the user value is not null then that means the user is currently logged in and they want to basically log out so in that case we're going to call sign out user and let's just code that function out so once again in order to actually sign the user out we need to talk to the uh repository object which means once again we're going to be dealing with our suspend functions so we can go ahead and make that into a launch coroutine builder like so just get rid of that there and so what this thing is going to look like is very similar to get user we're going to type val result equals repo dot sign out current user and then we're going to use our when matcher so when result is his result dot value do something so in this particular case what we're going to do is we're going to type user state dot value equals null so in this case we're not actually returning a value we just want to know if the user was successfully signed out or not if they were successfully signed out then we just want to make sure that the view model reflects that so we type user state dot value equals null and then we're going to again call our show signed out state function cool then we'll handle our error case is result dot error and then again we're just going to call show error state as you can see there so that's it for the different control logic functions that we're going to be coding out today there is of course the on google signin result but as i said several times we're going to cover that in a different video the last thing we need to do is we need to actually code out our different states here so i'm actually going to select all of this hit control x and i'm going to bring it up top to just below our view model objects here and then we get started all right it's time to code out our presentation logic functions now before we do that i just want to share really quickly i have this file in the common package called constants.kt so what we have here are a whole bunch of const val references so these are compile time constants which means that they're very efficient now if you need to localize your application for uh different localizations then probably you would want to go with strings.xml in this particular case this is me just being super lazy and efficient and just typing out different strings which ultimately will be rendered on our uh ui here uh just in an easily accessible file so what we'll do is uh instead of sort of hard coding these different values we're gonna refer to each appropriate constant and that'll just as you'll see in a moment make our presentation logic a little bit easier to write and a little bit harder to screw up so the first thing we'll do is we'll work with our error state here so in this particular case we're going to say sign oops sign in status text dot value so again we're updating the value of our live data object so the first one is going to be login error and then the next one so pretty much how this is going to work is i'm just going to hit ctrl d twice and we're going to update these values this one's going to be off button text dot value and so when there's an error we want the user to be able to sign in again so that one's going to be sign in and then for the uh next one we have the satellite drawable which is like the animation right here so if there's an error then we want to basically show antenna empty so that's a url to a particular drawable it's actually this one here the empty antenna animation here all right so once we have that figured out and let me just double check to make sure i didn't screw anything up ah looks okay good enough for now uh goodknow anyways uh so i'm gonna hit ctrl c and i'm just gonna paste this into each of these functions since this won't change too much again this is the kind of work that you really need to test because when you're doing this kind of copy paste crap you almost always screw something up all right so show signed in state is what we'll be working with next so when the user is signed in we want the sign in status to say signed in we want our off button to basically say sign out and then for our antenna drawable we want it to say antenna full which is basically this drawable here except with the wavy things on top just deploy the application if you want to see what it looks like okay so we've got our state here so show signed in state signed in sign out antenna full that's looking good next we'll go to show signed out state so it's basically going to mirror this one here so for show signed out state we're going to say signed out up here and this one is going to say show signed in state so this one's going to say sign in that's correct and then this one's going to be antenna empty that's actually correct it's quite similar to our error state as you can see all right so for show loading state it's actually going to be much simpler so we're just going to type sign in status text and we're going to set that one to loading oops kind of need an equal sign in there okay and then all we're going to do is we're going to call our start animation function here value equals unit so uh earlier on um you may have noticed in the view if you watched it previously what we ended up doing is we actually set the animation drawable in the view so the reason why we're doing that and not actually uh updating the particular drawable in this case is if we hop into login view notice that i actually specified explicitly that before we animate our drawable it must be assigned to our antenna loop drawable so the reason for this is that antenna loop is actually like the only drawable which is actually an animation list and i don't want to have a situation where i'm say for example assigning just a regular svg drawable and then somehow accidentally i forgot to change that to the actual animation drawable and then we are starting an animation drawable which isn't actually an animation drawable so basically what we're saying here is this is a little place where i actually did include a little bit of presentation logic in the view but this is for the sake of avoiding problems with shared mutable state so the very first tutorial i ever made at least on the topic of android on youtube was for the recyclerview way back in 2016. now back then there was a couple things about it which made it kind of tricky to set up for people so that's kind of what inspired me to try and make a video on it well i'll be basically teaching the same api today but luckily there are a couple improvements to it which will allow us to do a couple of things so for stars the recycler view we'll be building today is going to be the adapter at least is going to be decoupled from the fragment which is kind of important it's going to handle click events super easily as we'll see we don't have to have like seven different interfaces going on we'll actually handle click events just by using a mutable live data object and then finally our recycler view that we're going to build here we're going to use a particular class called list adapter which is like kind of a specialized adapter and what it's going to allow us to do is it'll basically remove our need to have to call functions like notify dataset changed notify item range change notify item inserted there's basically if you're not familiar in earlier recyclerview api implementations you had to call these different methods on the adapter based on what happened in your recycler view and it could actually get pretty annoying and complicated so what we'll do is we'll basically set up a bit of a boilerplate class called a diff util and dot item callback i believe it's called we'll see it in a minute but basically what this thing's going to allow us to do is it'll basically remove the need to call all those different functions and instead we'll just be calling one function and then we'll let this diff util our list adapter and a couple other things which we'll go into in the video handle all of those updates for us so it's going to be way simpler and best of all this particular implementation is going to figure out the or calculate the changes that need to be made to the recycler view on a background thread so no more blocking the main thread now since this is tutorial number eight and i've already covered a whole bunch of topics such as writing a view model writing a fragment model view view model architecture in general constraint layout all those different things what we're going to do is there's certain parts of this tutorial that we're not going to go into much detail in however i will show you all of the different steps necessary to actually set up the recyclerview what we won't be doing is we won't code out the whole fragment which displays the recyclerview and for the layouts that we'll be using in the recyclerview i'll show them to you and mention anything that's important but we're not going to build them on camera if you want to learn how to do that i have a whole tutorial on constraint layout which will help you figure that kind of thing out now before you proceed if you want to actually follow along with the tutorial in real time you're going to want to either clone or download the repository link in the description box down below now this could end up being a fairly long video so i'll make sure i include timestamps in the description box down below if you want a detailed idea of the topics and when we cover them in this video the first file that we'll be looking at is called fragmentnote list so this is the layout which actually contains the recyclerview so as i say i'm not going to go into too much detail here but here's a preview of the layout you can't actually see the recyclerview here but this is basically what it would look like if there are no items in the recycler view so i'm just going to open up the text editor here and we'll just look at this particular xml view so the first thing i want to bring your attention to is we have this color transparent black background so what i wanted to do here is instead of just setting the alpha of the which alpha means opacity or the degree to which something is transparent um instead of just setting that directly on the recycler view and kind of blurring things i just wanted to make sure that the background of the recyclerview basically made the elements in it a little more viewable a little more visible but you could still see the space background behind it so the way that i achieved that effect is i basically just set the background of the recyclerview to color transparent black and if i open up colors.xml that's basically just the color black with a hex value of 52 for the opacity so in the sense this is like setting the alpha except only for the background image so the second thing to point out here is that i've specified a linear layout manager in the xml so i used to do this in the java or kotlin code but i actually find it simpler to just do it declaratively in the xml in this particular case and notice that i'm using a linear layout manager depending on what kind of layout manager you use that will kind of dictate how your recyclerview behaves and how it kind of arranges the different items within it final thing to note here is that i've specified the default visibility of this particular view to be invisible and as i explained before that's because when there's no items retrieved from the database then i basically just want the recyclerview to be entirely invisible all right so the next file we'll be looking at is itemnote.xml so again i'm just going to talk about some general things but we're not going to actually code this particular view out so uh the first thing i wanted to mention is that both the primary graphic and the little icon down here are vector drawable resources so i have a tutorial on that and you can go and watch video number three in this series if you're curious about how to set these up but just to explain really quickly how they work uh basically they will scale to pretty much any screen size within reason and they won't lose quality or anything like that and the best part about that is that all of that happens through one single drawable resource so we don't need to specify resources for different screen sizes with vector drawables now looking at some of the more specific details here i just want you to note a couple of things so the way that i arrived at the general dimensions margins padding and those sorts of things is i basically went to the material design guidelines website and pretty much copied what they did now i do align things a little bit differently than what they suggest and so what i recommend is if you want to figure out how to align these things appropriately go check out what their guidelines are start from there and then tweak things a little bit in order to get the effect that you prefer so there's one last thing that i want to mention about this file if i scroll down to our primary text view here i just want you to notice that i've specified single line equal to true and then i've specified ellipsis dot end so what exactly is a lip size dot end this is kind of important if the text in your recycler view may end up being longer than the screen what ellipse size means is it's just whenever the text kind of cuts off it's just going to add a dot dot dot or ellipses as they're known and that's just going to make our recycler view look a little bit prettier in the event that the text is too long for the screen okay so we will end up coding the adapter by hand but there's one little boilerplate class here which is necessary to write before our list adapter and basically what it is is it's a diffutil dot item callback object so don't let all these scary names confuse you all this little class here does is it basically takes in some kind of datum model so let me open up note so note is basically the conceptual data which each item in our recycler view will represent so whatever data model you're trying to display so it could be like a user it could be an exercise it could be a note for example you're basically going to want to create a diff util dot item callback object which basically includes that particular data model as a generic type here so what is that going to do all it's going to do is it's going to allow you to to have some way if your data models have a unique identifier which they probably should of figuring out if an item at a given position has changed or not so if that's not super clear i think once i dive into the source code of the list adapter you'll probably understand how it kind of works all you need to understand here is that if you want to set this thing up properly whatever data model you have needs to have some kind of unique identifier in this case i've chosen the creation date of when the user basically creates the new node to be its unique identifier and then at some point as we'll see later on some internal class is basically going to use our callback object here in order to determine what uh items in the new list are different from the old list type of thing okay so in a moment we're actually going to basically delete this entire class and then rebuild it this is our adapter for our recyclerview but before we do that i want to take you through a bit of the source code of the list adapter class so as we'll see in a moment this thing is actually a sub class of recyclerview.adapter but it's integrated with a note or not a note in particular but some kind of diff util dot item callback and so as we'll see in a moment we that's why we needed to create that particular thing first and what i'd like to do is i'll take you through some of the internals of this class so that you can actually understand what's going on here so what i'm going to do now is i'm going to hit ctrl n and then i'm going to delete that because that's totally in my way and what i'm going to type is list adapter now up in this check box here you can see we have this include nonproject items so i'm going to click that and i want you to notice that all of a sudden we have a whole bunch of different options that have popped up so the one we're actually going to look at from the library the recyclerview library is list adapter here okay so what's going on here so all of a sudden we're in java land because this is a java class but what i'll do is i'll just kind of explain what's going on here so the first thing i want to point out here is that this list adapter class as i said before extends recyclerview.adapter so it's capable of behaving as a recyclerview adapter now the most important thing you need to unders understand with this particular class is that it has this async list differ member here called mdiffer now there's two constructors we can use to create one of these list adapters and the one we use accepts our diffutil dot item callback object that's important because it's going to basically create a new mdiffer member partly out of the callback that we supply so in a moment we'll actually see how this diff callback actually saves us time and effort but there's a couple other things in this class that i wanted to point out so as i mentioned before how we used to have to deal with our recyclerview adapter when the underlying data set that it's looking at changed is we had to call all these different functions like notify item inserted notify item range removed and all kinds of things like that so this was really annoying and caused a lot of problems for different developers and also the thing about using notify dataset changed is that it was a very inefficient function so anyways what we're going to do is as we'll see in a moment this list adapter when we want to actually update the contents of the adapter all we have to do is we just call this submit list function down here and we provide a list which contains whatever data model that we're working with so what i want to point out here is that when this function is called it's going to call the same function on our mdiffer object and then it's going to pass the list in what we'll do next is we'll look at the async list differ source and then we'll kind of see what goes on inside of there okay so there's one more source class that we're going to look at and understand i i'm just trying to give you an idea of how this thing works under the hood so i'm going to hit control n twice and then we're going to look up async list differ here so this is a pretty complicated class all i want you to want you to understand here is that this async list differ class has a main thread executor object here and what that's going to do is it's going to allow it to call back to the main thread and then we'll see it also is capable of doing work on a background thread this is important because if you're making a huge update to a recyclerview that could potentially be a longrunning operation so this is part of the magic of using this particular setup with listadapter and async list differ is that it's going to allow us to figure these updates out on the background thread appropriately and you don't actually even need to know what's going on here i'm basically just taking you through the source code as an extra step so we have our main thread executor and the only other thing i want to show you uh in this particular object here is i want to scroll down to the submit list function and just remember submit list is what we're calling on our list adapter and then that's going to get called on our mdiffer member okay so if we go down to submit list here we'll see the first function here accepts a list and then the next one is basically going to call the uh it's going to call an overloaded version of this function down here submit list and this is actually where the magic happens now the thing you i just want to point out to you is if i scroll down i i know this is a really horrendously uh huge function here but if i scroll down here just understand at a certain point we're going to say mconfig don't worry about what that is it's basically going to get a background thread executor and this is how it's going to actually calculate the difference between the old list and the new list and do that work on the background thread for us now importantly one little detail if you're wondering how it actually gets a hold of the note diffutile callback that we created understand that it's going to get a hook to that class through this m config object here which we actually created up in the list adapter somewhere here and we have a little builder class there and so it's going to get a hook to the diff util callback that you wrote and then from there it's going to ask it to compare the different items and that's ultimately why we needed to create our diff util callback once all of this is done it's going to dispatch this result to the main thread okay so now that we've had a look at the internals of the list adapter class that we'll be working with and hopefully that was interesting to you uh if you enjoyed going through the source code then please let me know down in the description box below and i'll try and do that kind of thing in the future so anyways at this point we're going to rebuild our note list adapter class and what we're going to do is just go ahead and open it up and we're just going to select everything in here except the import statement at the top and we're just going to delete it like so all right so you might be wondering at this point ryan how exactly is that making things easier for us that seems kind of complicated well the good news is that the complexity in the classes that we just went through is going to result in less complexity in the classes that we're going to be writing momentarily so in order to actually write out our adapters constructor we need to create our view holder object first so we'll start with that so this class is going to be called class note oops can't type note view holder it's going to have one property here which is going to be called root and it's going to be of type view and we'll see what happens in a moment with that and then it's going to have it's going to extend recycler view oops that's not what i wanted recyclerview dot view holder like so and what we'll do is it's going to complain because it's expecting this thing to accept a view so that's where we'll pass in this root view object here and so that will become the item view property of the view holder and just take note of that because we'll use it later on so the purpose of this class is it's basically kind of like a bridge between our note data model or whatever data model you'll be using and our item note layout so it's kind of like a virtual representation of the layout and so in our particular layout we really only need to represent the in this case the creation date and also the contents of the note in the actual layout so it follows that we just need to include two different uh references here so the first one is going to be called var content for the contents of the note it's going to be a text view and it's going to equal root dot lbl message so again don't forget root is referring to this thing here and then i'm just going to select at the click at the end of here and i'm going to hit ctrl d and this next one is also a text view it's going to be called date and it's going to point to root dot lbl date and time so just a really quick aside here about the note view holder if you're wondering where the name recyclerview actually comes from or what it refers to it basically means that as the user is scrolling through their list of items in the recycler view the recyclerview adapter is going to recycle the viewholder objects instead of creating a viewholder object for every item in the recycler view so minor point here but it's just kind of important to understand that that's where we actually get the efficiency of the recycler view and why it's called as such okay so now that we've got our view holder set up we can actually write the class declaration for our adapter so what that's going to look like is we're going to type class note list adapter i'm going to leave the constructor empty for a moment but we will put something in there and then this this class here is going to extend list adapter and it's going to basically accept a couple of different uh types here so what we need to do here is if you want to figure out what this particular what a given class needs in android studio for constructors or types like this generic types we can hit control p and it's actually going to kind of give us some kind of idea so in the case of t this actually refers to our data model so in this case i'm going to type note and then for the second one we have some kind of view holder object and that's going to end up being our note view holder and that's why we needed to create that thing first so in here i'm going to type note list adapter dot note view holder now it's still complaining because as you can see here we're referring to something which is supposed to be within note list adapter so i'm just going to throw down some curly brackets here and then we're going to move that note view holder object into the adapter like so so there's obviously a couple things we need to fix here so go ahead and click on the red highlighted note list adapter here and what i'm going to do is i'm going to hit alt enter and then we can click on implement members or hit enter and make sure you select both of these and then hit ok and so these are the functions that you basically need to implement in order for this thing to work properly notice how there's a couple fewer functions than compared to a normal recyclerview adapter and that's because some of those functions are actually handled inside this list adapter class so we'll get to implementing those in a moment there's another thing we need to deal with so our list adapter is showing up red and if i click inside the parentheses here and hit ctrl p it's going to say that it's expecting some kind of diffutil dot item callback object so all we need to do in this case is i'm just going to type note diff util callback and then we'll add brackets at the end of it and that's going to actually create an instance of the note diffutile callback object so in my older tutorials the way that i handled click events was basically to either nest the adapter inside of the fragment or activity which it was supposed to call back to or by holding reference to whatever class it was trying to call back to as an interface so we're gonna do neither of those and take an option which is a little bit more decoupled and i think a little bit safer so what we're going to do instead is we're going to use a mutable live data object to call back to the fragment so what we'll do is we're going to type val event and it's going to be of type mutable live data and the type is going to be a sealed class which is note list event so if you're wondering exactly what this is and how mutable live data work go and check out the particular part of the tutorial where i actually discuss these topics just really really quickly note list event is a sealed class which represents different events which can occur in the front end and mutable live data is basically something that can be observed but this mutable word means that we can change its value and the value is what's basically wrapped up here whenever we want to and when we change it if our fragment for example happens to be listening to this mutable live data object then it will know when a particular event happens and what the details are so in order to complete this we're just going to have to actually create this thing so we'll say equals mutable live data and we'll give it our constructor so the first function that we'll implement is oncreateviewholder so uh beyond what the name implies here basically what this particular function does is this is where we actually inflate the layout which our recyclerview will use so what we're going to do is we're just going to mess around a little bit here so we're going to say val inflator equals layout inflator dot from and so we're going to use this parent object here which is a view group so from parent dot context and that's going to get a hold of a context object now this is really important whenever you're messing with context you need to be careful about memory leaks and there's a particular step we're going to go over in the fragment which is going to prevent this particular adapter from leaking this is kind of a problem with adapters is we have this ugly situation where it's a class that needs to have access to things like layout inflators and the view hierarchy but it might be somewhat detached from the life cycle of say the fragment so like i say we'll see a specific step we need to follow in the fragment in order to make sure that this isn't an issue for memory leaks anyways once we have our layout inflator object what we'll do next is we're going to type return note view holder like so and inside of this note view holder object which expects a root view this is where we'll actually do our inflation so we're going to say inflator dot inflate and so in here we're going to provide the actual item note layout which is the layout of each item in the recycler view r.layout.item note and then we're going to give it parent which was passed in up here and then we're also going to provide we're going to say false for attach to root okay so some of you might be wondering what exactly is this attached to root and why is it false if we leave it false does that mean that our views our view holders are going to be magically floating around the user interface and unbound to anything the reason why we're passing false in here is because we do not actually we don't write the code to attach this particular view to the view hierarchy so basically what that means is that it's going to inflate this r.layout.itemnote view it's going to get some layout parameters from this parent object and if i hit control p notice this thing is called root and so just understand that everything is going to work fine when would you want to use attach to root true that would be if you are writing some particular class which is responsible for attaching a view to the hierarchy in this case this occurs internally so we can just leave it false and we don't have to worry about it all right so what we're going to do next is we're going to write out our onbindviewholder function so the first thing we'll do is we want to basically get a hold of the note item at a given position and position is provided here so what we'll do is we'll call getitem which is a function from the adapter and then we'll pass in position then we're going to say dot let so basically what's going to happen here is we're saying okay get this thing and then in this block of code as soon as you get that thing i want to do something with it so in this case just to make things a little bit more legible instead of using the it reference which is a little bit confusing to some people i'm just going to type note so we're going to give a name to the thing that is returned by this function and then it kind of pops up up in here then we need to add an arrow thingy here so what we're actually going to do is once we get our note object here we need to bind it to the viewholder object which was passed in so what we're going to do is we're going to type holder dot content for the first one and remember that's just what we defined down here holder.content.txt because it's a text view equals note dot contents i'm going to hit control d and for this one we're going to say holder.date.txt equals note dot creation date and then what we'll do after that is we're going to add a click listener to the entire sort of root layout of the view holder object so we're going to say holder dot item view dot set on click listener and we're just going to use a lambda in this case again so what's going to happen is when this on click listener is fired whatever we write in here is going to be executed and so what we're going to do in that case is we're going to publish an event to anything which is listening and the way we're going to do that is we're going to use our event mutable live data property up here so what we want to do there is we're going to type event dot value to get the value of the mutable live data object then we're going to set that value to a particular kind of event in this case the event will be note list event dot on note item click and then that thing requires a position which will be the position that is passed in in on bind view holder now i'm sure some of you are wondering what this class looks like so i'll pull it up really quickly so note list event and just understand it has a couple different events basically any event which can occur in the note list feature of the application and the one we used is on note item click and as you can see here it accepts a position as a property which is what we pass into it so that's actually it for our adapter object so what we'll do to finish this video off is i'll take you through the fragment which holds the recyclerview and interacts with the adapter now we're not going to code everything out because that would take a needlessly long time and i've already explained how to code up fragments in a previous video but what i will do is take you through specific steps which you probably should take to avoid things like memory leaks and to make sure that everything gets set up properly okay so i've opened up note list view now as you can see here we have a reference to the adapter in the fragment i do recommend taking that route and not putting a reference to the adapter in something like a view model the reason why is that you don't really want to be putting classes which have a reference to like layout inflator and context and the view hierarchy in something like view model so in this case like i say we're talking to it through the fragment here now this is a really important step here you can see i've overridden on destroy view in the fragment so what was happening is that after i got this thing all set up i was getting a very strange memory leak and i figured that out by using the tool leak canary a very awesome tool so i was trying to figure out what was going on here and after a bit of googling i figured out that in certain cases and again this is just the feature a feature of the fact that our adapter is tightly coupled to the view hierarchy and context and layout inflator and all that stuff if you do not set the adapter property of the recycler view and that's what this thing is here to null then chances are you may get a memory leak i think it partly depends on how you have everything set up here but in this particular case if we want to have our adapter sort of separate from the fragment i did need to include this detail here otherwise i got a memory leak now some of you may be wondering and i went over this in the fragment tutorial in this series but the way that we're able to just directly refer to these xml views like so is by using kotlin synthetic properties up here so go check the fragment tutorial out if you want an idea of how to do that it basically completely eliminates fine view by id which is really handy anyways the only uh function well there's two functions we're going to look at next so one of them is going to be setup adapter here and so this is just a helper function that i've created so that we don't have just one giant onstart function and when i scroll down to it this is what we have here so what we end up doing is we create a new instance of our note list adapter and we assign it to our adapter reference the next thing that we do is we get a hook to the event property remember that's our mutable live data object and then we observe it so that when a click event happens in the adapter in the recyclerview it's going to pop up here now since our fragment has referenced the viewmodel as well what we'll do is through this lambda function here that's where we will pass the particular event and remember that contains the position of the item that was clicked we passed that into the view model and then let the view model figure out what to do from there now the last thing that we do after we get that set up is we assign our recyclerview its property its adapter property to the adapter we just created and now for the moment you've all been waiting for how do we actually get our data into this particular recyclerview adapter and recyclerview so if i scroll down to the observe viewmodel function and just note that i'm calling that after i set the adapter up so just for people watching this make sure you kind of don't mix these steps up here we're setting it up first and then we're asking the viewmodel for the data so if i scroll down to the particular observable which is note list so that's of course our list of notes we observe it and then when we receive a new note list all we have to call is adapter dot submit list now don't worry about this function here this is just like ui animation boilerplate stuff this is seriously all we need to do to provide a new list to our adapter and anytime we change the underlying list it's going to pop up in here we're going to call adapter.submit list the diffutil is going to figure out what to do from there and then we are set no more notified data set change notify item inserted or confusion with creating a new list of data or all those kinds of things because for anyone who worked with recyclerview before it was actually kind of difficult and confusing how to like for example update an entire list or change part of it or things like that so all of that work that we did earlier did actually ultimately make our adapter simpler to work with and in this video i'm going to talk about integrating firebase auth and google signin provider in your android applications so in order to set up firebase authentication with google signin provider we will need to perform the following steps we'll create and configure firebase for an android project we'll set up a shawling certificate in android studio for debug builds we'll download the google services.json file after all the configuration is done we'll have a quick look at what we need in our project level and module level build gradle files and once that's all complete we will implement firebase off and google sign in provider in a small little android application and i will show you where to get the source in a moment now before proceeding i will need you to have an account set up with firebase so go ahead and do that if you haven't already so assuming you have an android app which you want to connect to firebase the easiest way to integrate it in recent versions of android studio is to select tools firebase authentication and then click connect to firebase if this process worked for you it should have created a new android project in firebase if it doesn't i suggest you enter the firebase console and create a new android based project manually next click the add firebase authentication to your app button this will add in some gradle dependencies to make things a little bit easier for you for the next step we will set up authentication in firebase go ahead and open up the firebase console and click on the authentication page next click sign in method in the following tutorial where we actually implement code for firebase auth we just use google sign in provider for your first try this you might want to just stick with email password authentication before we can do much else we need to configure a shell one certificate for our application this is just a unique identifier which we will add to our firebase project's configuration to get the debug certificate which android studio generates for us simply build your project at least once open the gradle tab in android studio and try either project name tasks android signing report or if that doesn't show up try app tasks android signing report in the run console locate your sha1 certificate and copy it back in the firebase console navigate to settings towards the bottom of the general tab you should see a card which holds your app id and allows you to download your google services json file on that card click add fingerprint and paste in the debug certificate now there's something very important i need to mention i'm going to show you how to set this up using a debug sha1 certificate which android studio automatically creates for you so this will allow you to test debug versions of your application but just understand that when you upload your application to google play if you sign that application with a different sha1 certificate which you really should do then you're going to need to add that certificate back into firebase as well and also if you're like me and you use app signing by google play you're going to want to go into the play console open release management and then app signing and you're going to want to paste the public sha1 certificate fingerprint in the console into firebase as well now that we have our certificate set up it's time to download our google services json file this file contains keys and configurations which will allow our client app to work with firebase and google sign in now if you downloaded this file before adding your shawlwind certificate you will need to download it again alright now that we have all that configuration done it's time to see how we actually implement firebase off and google signin provider in the application this will require properly configuring gradle implementing start signin flow and on activity result which are functions in the front end and implementing firebase auth in the back end of the application now i will only be writing out a couple functions in an entire application so please check the description box for the source code for the entire application i also build this application out in many different segments in this whole tutorial series so consider checking out the other videos if you want to know how i set up the view model the rest of the view and things like that before proceeding please double check that in your project level build gradle file you have the google repository present in the all project script within the build script and also that you have a dependency to google services in the build script as well in your module level build gradle file you'll want to have at least firebase core firebase auth and play services auth if you wish to use google signin in this app i chose to build a custom login ui and if you want to learn how to do that please watch part 4 of this tutorial series where i demonstrate how to build a custom material design login ui using constraint layout alright we need to write a couple of functions in the view so the first one is start sign in flow start sign and flow will start an external activity which will display the google signin user interface this will briefly pause our application and open up an external application now important point here r.string.defaultwebclient.id is not something that you actually write yourself and add to your strings xml file this is something which is generated dynamically from your googleservices.json file in older versions of google sign in and firebase you did have to add this in yourself but at this point there's just less configuration you have to do for google sign in dot get client if you're writing this in an activity you can just type this since this particular login view happens to be a fragment instead we'll just type in require activity like i said before we're going to be actually starting a different application so that's why we're creating an intent here and whether or not the user signs in the result will still get passed into on activity result once the user finishes the google signin user interface a quick point here rc sign in is just some unique integer key let me just show you it really quick yeah it's literally just leat so rc sign in which stands for request code sign in is going to get passed into on activity result if you are working in an application which uses on activity result for a couple different things then you're going to want to actually check to see if rc sign in equals leet in this case in this application we're only working with google sign in so i don't expect it to be called in any other case so basically what we're writing here is this is just a bunch of boilerplate code to see if the user signed in properly and also to see if we were able to get a user token from their google account what will happen is if we successfully get a user token we will end up passing that to the back end of the application and that's how we'll kind of connect both google signin and also firebase together but yeah this is pretty typical boilerplate code now google sign in dot get signed in account from intent returns a task object and our task object can throw an exception so we'll just need to make sure that we're handling that somehow since this is a demo application we'll just print it out to the console the last thing we'll do is we'll actually inform the view model that onactivityresult has been called here i'm using a sealed class to kind of model that particular ui event and i'm also creating this login result object let me show you what login result looks like it's actually just a simple data class as you can see it holds the request code and the user token which could be null all right now that our view is wired up the next thing we'll write is our implementation of firebase auth and google sign in provider in the back end now there are a couple different ways to write this code depending on what tools you use for concurrency since this is a kotlin app and i want the back end to be very decoupled from the front end we will manage concurrency and callbacks using coroutines so our first function here is called sign in google user this function takes in the id token we collected when the user successfully signs in with their google account this function is used to create a new user and to log in a user which already exists assuming they're using google signin as i explained in my kotlin course an easy way to move a longrunning operation into a background thread in a suspend function is to use the with context dispatchers.io coroutine builder to wrap the function body my general goal with coroutines is to write code in direct style which is basically a word for no callbacks this makes code more legible and helps to avoid callback health so the first thing we'll do is we will request a credential from google auth provider then we're going to try and give that credential to firebase off so firebaseauth.sign in with credential returns a task object which we can add an oncomplete listener to in order to keep my goal of writing code in direct style we will create an extension function which will wrap the callbacks using the suspend coroutine builder so we're not actually going to write it out but i'll just walk you through it really quickly so we're going to be using await task completable what that basically means is we're going to await the task and we want to know if it completes or not but we don't actually care about returning any particular value in order to create this function we simply take in a task as a parameter and then we use the suspend coroutine builder so the way that this works is the continuation object is how we actually call back to the call site of the function which will be using our extension function here so what we do is uh we just add an oncomplete listener to our task object and we check to see if it's successful or not if it's successful we just resume the execution of the call cite function now i'm returning unit here because it doesn't actually matter what value i return and if it fails we call resume with exception let's see how that works back at the call site so what we'll do is we'll add a try catch block to wrap that particular function call now if it just resumes then like i said before it will just synchronously jump to the next line after await task completable in this case we will create a result wrapper result.build to signify that we just want to return the function successfully if we get an exception we will catch that exception and throw it also in our result wrapper all right so we only have two other functions to write out here so signing a user out is very easy at least in this particular application all i do is i just call off dot sign out now what i'll do is i'll just add that particular call into a result wrapper if it succeeds it will return unit which is basically a signal that things happen successfully but we don't care about any particular return value next we have get current user when the user opens the login screen the first thing the app does is request the current user from this particular backend function now it's important to understand that i've initialized firebase ahead of time in this class by calling firebaseauth.getinstance generally speaking you will want to initialize firebase ahead of time instead of calling it just before you call for example auth.currentuser and the reason for that is if you call off.currentuser before firebase is properly initialized then it will basically just return null to you no matter what happens that's even if the user is actually signed in so if off.user does equal null then we will actually just return null in the result wrapper we will return a user object now again this is basically just a plain domain model which will hold on to the uid and the display name of a user if they happen to have one now the truth here is that i don't actually use the uid or the display name for anything so i could actually just return unit here as well and that would function perfectly fine for this application so that's all you need to set up firebase auth and google sign in provider in this video i'm going to show you how to put together a room database using kotlin coroutines here's a quick overview of what we'll be doing in this tutorial first we will build a room entity which is kind of like a bridge between sql and kotlin or java then we will build a data access object interface which is how we will actually get the data in and out of our room database then we will look at our room database class and a bit of information on threading and concurrency and finally we will see how to perform crud operations on the database using coroutines code operations stands for create read update and delete just a quick reminder that as usual the source code for this example will be in the description box so let's get started entities in room are essentially a bridge between a java or in this case kotlin data model and the schema of an sql database in simpler terms an sql database is basically a spreadsheet and each property of our entity will represent a cell in that spreadsheet so to set up an entity in room what you want to do is you'll want to start with a basic data model like i have here so what we'll need to do to set up this data model for room is we'll need to add a bunch of annotations to it above the class declaration you will want to add the entity annotation this annotation accepts quite a few different arguments depending on what kind of configurations you want or you can leave it blank for defaults this annotation accepts quite a few different arguments depending on what configurations you want or you can leave it blank and it will just use the defaults table name and indices shown in blue here are what are known as kotlin default arguments table name basically states that i want the name of the database table to quite specifically be notes if you were to leave that blank then room would simply use the name of your entity class by default as for indices here i'm basically saying that i want this particular value creation date to be indexed and we'll actually see where that comes from in a moment but what the indexing does is it basically just makes it more efficient to look up these particular room note objects by this particular value creation date every room entity needs to have at least one primary key you can also create a primary key out of multiple different properties using a composite primary key but we won't worry about that here what this annotation does is it basically tells room that this is the actual value which we want to use to distinguish between the different objects in our database in essence we are saying that this is the unique identifier for each room note object now in case you're wondering creation date is actually created in the front end of the application and it's essentially just the system time at which the note object was created at and then translated into a legible date format another optional annotation is the column info annotation basically what it allows me to do is specify a different name for each column in the database and this is really just convention sql doesn't typically use camel case like in java or kotlin but you don't really need to do this if you don't want to one final note here if you've read the documentation then you're probably aware that room can auto generate and auto increment primary keys we don't do that in this particular tutorial but i just wanted to mention that that is a possibility it does have some consequences though when it comes to updating rows in the database which i'll talk about later next we have our data access object or dao now essentially what this is is it's just an interface with a bunch more annotations which we'll look at in a moment this dao object will allow us to give our room database a bunch of functions which we can call on it to manipulate our data basically what it'll do once we set up all of the annotations is it'll handle most of the work of writing really ugly sql queries if that's not something you're interested in now there's an important point here many people use live data with room and that is acceptable since i'm a big fan of clean architecture i don't actually like to be passing live data objects through my domain layer so instead of using live data objects for concurrency we are going to be using coroutines thankfully in recent versions of room it basically works out of the box all we need to do is just add the suspend coroutine keyword and this will actually make it super easy for us to get the data in and out of the room database without blocking the main threat anyways the first annotation that we'll need is at the top of the interface declaration just at dao for our first function we will use the query annotation so basically how this works is the particular things we put within this query annotation will be translated into proper sql this basically just makes it so that it's easier for us to read and write the particular queries this first statement here select is pretty selfexplanatory but when it's followed by this asterisk it basically means select all from is also quite selfexplanatory and just remember notes is what i called the actual database so basically what we're saying here is get everything from the note database now when we want to get a note by id basically what we're saying here is select any note from the note database where the creation date which is a particular column in the database matches this creation date string which we pass into this function so notice how in this particular case we have this colon followed by the name of the argument that we give to the function this is how we actually pass that string data into the sql statement delete is much simpler all we do is we just add in this delete annotation we pass in the room note object and room will sort out the rest of the details for inserter update i'm doing something a little bit more complicated now remember how i said earlier that room is capable of auto ids dynamically for you since we are not doing that that's actually going to allow us to use this kind of upsert functionality here so how this basically works is we pass in a room note object into the room database and room will search to see if there's any note which exists in the database that matches the one we passed in here if it does happen to find one where the creation date matches then we are telling it explicitly using the on conflict default argument to replace that particular note object so effectively what we have here is both an update and a create new entry in the database at the same time now this works because creation date does not change whenever we update the particular note object again if you're using dynamically generated ids you have to be a little bit more careful about that before we move on to writing the database it's worth mentioning that room will generate an implementation of our dao class in the build folder of your android project you don't need to look at it but for those of you who are curious about how room works under the hood it might be interesting in particular notice how it does have a reference to a room database object and also it does override the functions in our interface such as insert or update note delete note and so forth in the case of get notes as you can see here it does a lot of tedious work for us so that is kind of the magic of room next we come to the room database class now this class is basically just a bunch of boilerplate and i would not advise you to write this out by hand just copy and paste it and change what you need in my case i copied and pasted this originally from android sunflower which is from the google samples repositories anyways there's only a few things to mention here notice how we are referencing our room note class also for some reason we change the structure of our database schema we will want to increment the version by 1 or something like that and also notice that we have a function which returns our note dao object as we'll see in a moment we actually create the room note database object and then we request this room note dao from it and that's how we'll actually make calls to the database as for this companion object it's basically just a really powerful singleton initializer and it ensures that we never have more than one instance of our database in memory for those curious the volatile annotation ensures that no matter what thread tries to access the instance it will always get a current instance not something that's cached and therefore out of date also this synchronized block here is kind of interesting so this is a lock which is a concept you'll be familiar with if you've studied operating systems basically what this means is that whenever a thread of the application enters this particular code block it essentially locks it off so that no other threads can access it at the same time it will go about doing its business building the database or retrieving it if necessary and this essentially doubly ensures that this thing does not get created more than once now if you're just here to use a room database this kind of concurrency stuff is not really that important to you so if it didn't make sense don't worry about it i just thought it was worth mentioning one final point here just like our dow you can actually look up the implementation of your abstract database class in the build folder if you want to see how it works the code is really ugly but i always encourage people to actually look at the source code of these things to better learn how they work so before i show you how we manipulate the room database i just want to show you how i actually create it each feature of this class has its very own injector which is a very simple dependency injection container written by hand so how we actually do things here is we will create an instance of our room database which requires context but we don't actually want to pass a reference to the database itself rather we will call dot room note dao to get an instance to the data access object in this app i use a repository which handles both online and offline calls to different data sources essentially how this works is we just check to see if there is an active user if there is an active user then we will of course perform our operations on a remote firestore database if no user exists then we just write to our local room note database so this reference local refers to our dow so working with the dow is super easy again we're using cortines so note that these are suspend functions anyways all we do is we just call whatever function we want on the dao so get local notes we call local.getnotes and it's a similar situation for the other functions we have here now you may be wondering why i'm returning unit here in these result wrappers just note that for the case of deletes and insert or updates i don't actually care about returning a particular value so to satisfy the signature of these result wrappers i just return unit also note that in my result wrapper if an exception is thrown it will be gobbled up by the result wrapper so that's basically how i handle errors at the same time the only other thing we need to look at here which i've added as kind of a custom addition is i have a bunch of extension functions and properties to map to and from note objects and room note objects let's have a quick look at those so in this project i have a big file called dataextensions.kt and i put in a whole bunch of different extension functions and extension properties so this is pretty typical mapping stuff the reason why i do this is i don't want all of the different room dependencies to be passing through my domain layer so basically before i write to the database or retrieve data from the database i just make sure that i'm mapping to and from some kind of plain note object as you can see this is why i choose not to use live data i want to try and keep things as clean as possible and in this video i'm going to show you how to manage a firestore cloud database quickly and easily using kotlin coroutines before proceeding please create a new firebase project for android let's enable firestore through android studio to do this you can go to tools firebase scroll down to the bottom of the assistant tab there you'll see firestore click on that click read and write documents from cloud firestore and click add cloud firestore to your app if necessary click connect your app to firebase then click add cloud firestore to your app which will add the appropriate gradle dependency to your build gradle file next we will hop into the firebase console and set up firestore we'll start it in test mode which does not have any access restrictions on reads and writes but obviously you want to avoid doing that for production builds once that process is done we're ready to go firestore is schemeless so we can start adding data without needing to configure things further as discussed in a previous tutorial number 10 where we built a room database this application uses a repository to hide the details of the end from the front end how it works is that we first check firebase auth to see if a user is in in this get active user function and depending on what that result is we either make our operations on the local room database or we perform operations on the firestore remote database also note that i have created a specific data model for firestore notes the only difference here is that i store just the user id in the firestore node whereas in the other node object it stores a nested user object this makes it easy to serialize and deserialize the data and also keeps references to firestore out of my repository interface finally as usual i encourage you to check out the source code in the description box as this is an open source application let's take a look at the functions we will be implementing for firestore get remote notes will get all notes by a particular user get remote note we'll get a particular note by a particular user delete remote node is pretty selfexplanatory and update remote note will be used to both create and update notes which already exist now like i discussed in part 9 of this tutorial i've created some quick and easy coroutine extension functions which wrap the calls to firebase as you can see here please watch the tutorial for a detailed explanation all of our calls to firestore and that's what this remote reference is here we'll start with this collection function which accepts a collection path argument of type string instead of having rows and columns which represent different items in a database firestore has documents to represent individual items or models grouped into collections so while it's important to remember that firestore is not an sql database this collection path is similar to the name of a table in a database if you happen to be familiar likewise each document is in some sense similar to a row or entry in a database table this app only has one collection and it's just called notes as we'll see with all of these different functions here we start everything by retrieving a collection and then we'll add some other functions to start manipulating it this call to the document function will either retrieve or create a reference to a document based on the path we give it now in this case the document path is a combination of the date at which the note was created down to the second combined with the uid of the firebase user this set function which accepts an arbitrary data model is how we actually populate our newly created document with the appropriate data so in other words what we're basically saying here is grab a reference to the notes collection create a document with this particular key or name or path and set the data at that path to be equal to the note which we passed in converted into a firebase note object in any case all we do is call this function here and if it succeeds properly we will return unit which basically just means hey this thing was successful and if an error gets thrown in away test completable then our catch block here will gobble it up and we'll know that something went wrong delete is really easy we just do exactly what we did before except instead of saying dot set we just call dot delete the process for retrieving a specific node is also similar in this case we call the same thing except in this case we will call get at the end of our change document request now this will return a task object which possesses a document snapshot so what we do is we call this to object function to turn it into a firebase so what we do is we call this two object function here which accepts some kind of data model in this case firebase note which is what i used to upload originally with and if we can successfully retrieve that i just turn it back into a plain old note object and then it's good to go forget remote notes which will return all notes for a given user again we request a particular collection and then we use this where equal to function which accepts the name of the field in firebase and then we just pass in the user id of the currently logged in user and then we call this get function now this particular task object will of course hold a list of document snapshots so what we end up doing is i pass it into this function here result to note list and it just returns everything as a result wrapper containing a list of notes that's just a basic mapping operation going on here so that's actually all we need to do to set up firestore it is ready to go and out of the box it actually works both online and offline which is pretty handy in this tutorial i'm going to show you how to set up dependency injection in a very simple modular way which does not require you to use a dependency injection framework this handwritten dependency injection implementation or build logic as i like to call it is suitable for small to medium scale applications if you are building a very large scale application then writing this code can be very tedious in which case i do recommend using dagger 2. dependency injection in simple english really just means giving an object its dependencies in the application we've been building our viewmodel classes talk to repository interfaces to perform i o operations on the data these repository interfaces can therefore be said to be dependencies of the viewmodel classes again the key difference here is that if the view model builds its own dependency as you can see on the right example here this is not dependency injection as i have said time and time again likely the most important concept in good software design is separation of concerns dependency injection is a form of separation of concerns except that instead of separating things like user interface code logic and data we are separating things which use dependencies from things which create dependencies as martin fowler summarizes it very well dependency injection is about separating configuration from use the way which i separate objects that build repositories from the objects which use repositories in this project is by writing an injector class for each feature of the application this class extends androidview model which is a subclass of view model designed to hold onto an instance of the application context the idea is simple for each dependency that i require i will write the code necessary to build that dependency and provide a public function which can be called for another class to get a hold of that dependency in this case we will be providing dependencies for a view model so we actually end up giving the repository to a view model factory object which we'll look at next note list view model factory is in some sense also an application of separating configuration from use this is the class i give the repository to and then it in turn gives that repository and the appropriate coroutine dispatcher to note list view model the only other piece of this puzzle is the place where we actually make our calls to our di implementation which in this case is within the onstart function of a fragment view model provider which is how we actually get a hold of our view models accepts a view model provider factory object as a second parameter which i showed you moments ago so all we do is we create an instance of the note list injector give it context so that it can build room and then invoke its function to return a factory there are many other approaches to separating configuration from use such as using the service locator pattern which i also use quite frequently the approach i showed you today hopefully gave you a way to start applying dependency injection without spending weeks configuring dagger 2. we've all been there and yeah it sucks