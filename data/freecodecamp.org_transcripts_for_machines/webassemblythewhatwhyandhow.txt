hi i'm titi i'm a software engineer at google and i'm here to talk about webassembly so um what is webassembly um webassembly is a portable efficient binary format so say you have a c c plus plus a robust program you can compile it to webassembly and run it on the web so there's a couple of interesting things on the slide the first one that says that the initial version of webassembly has reached crossbrowser consensus what this means is uh that representatives from different browser vendors like chrome firefox edge webkit they've all agreed on what the api surface should look like and the binary format the other super exciting thing to me is that webassembly is being designed in an open standard in a community group w3c community group um so aside from the fact that it includes representatives from all of the major browser vendors there's also representatives from intel arm of different companies that are potential users for web assembly so um some of the things that uh are awesome about webassembly are that it's efficient and fast um it's load time efficient in the sense that it's designed as a binary format so it's fewer bits over the wire and it's more efficient to load it's fast because it tries by design webassembly tries to make use of hardware capabilities to give it the speed that it needs so it's safe because it tries to enforce the same origin uh security policies that are in use in the rest of the web the other exciting thing about this is that it's part of the open web platform in the sense that it can call in and out of javascript it uses the same api surface that javascript uses to use browser functionality and i think the important thing to talk about here is also what webassembly tries to not be it is not a replacement for javascript by design uh webassembly is a try webassembly should interoperate well with uh javascript if you noticed a logo it has list this tiny slot on the top where the javascript logo is supposed to kind of fit so it's definitely not a replacement for javascript the other thing to note that it is not a programming language i guess you could think of it as a programming language if you think of assembly as a programming language as well in the sense that this is something that the compiler should generate and not something you should be writing by hand you can write it by hand to try it out but to make it efficient and get it to use all of the optimizations you want the compiler to generate this for you it is not a plugin in the sense that is internal to the browser engine so it shares the same stack the other important thing that you want to note here is that it's not a target for dynamic languages yet in the sense that we have proposals that are ongoing that uh you know that we're exploring to support gcd objects and in webassembly so you can have different languages that are not limited to a linear memory model like c c plus plus or rust so one of the primary uh motivations for webassembly is that you want native code on the web so um what is what exactly is native code and why do we want it uh so if you look at applications now there's more and more complex applications that you want to port to the web these are game engines image decoders uh a whole variety of computer intensive performance intensive applications that you want to port to the web and ideally you would want these to work at near native speed so have the performance that native applications give you you want it to be portable in the sense that you want to compile once and run on different platforms so you want it to be safe you want it to run in a sandboxed execution environment so those are the things that native code offers you and these are some of the primary motivations for working on webassembly the other interesting thing is that you can you have all of this existing native code that uses webgl different native capabilities that you can now compile to run on the web one of the reasons why webassembly is actually useful is the fact that it's challenging to use machine capabilities through javascript so if you have threads uh simdee these are things that are easier to use if you're on a native application but you have to jump through a whole bunch of hoops to actually be able to use any of this on javascript there have been previous attempts to get native code on the web uh one of these was a chrome's solution which is portable native client uh this gave you a performance security a lot of native uh functionality but it was only supported on chrome so it wasn't uh portable uh i mean it's portable in the sense that you can run it on different architectures but it's just it's specific to chrome and you can't possibly run it on firefox because of architecture limitations the other mozilla's approach to this is ashi azam js so let's talk a little bit more about azim.js so asim.js is a subset of javascript that can be optimized and used as a lowlevel target for compilers if you see that program on the right there it so one of the things about javascript is that it's a dynamically typed language so the engine has to do a lot of work to figure out what types exist in your program and optimize according to those asm.js gets rid of some of that in the sense that it uses type annotations for its parameters and return types so you can optimize based on that you you can give the compiler give the engine a hint and say okay use azim and um this it would try to use the specific subset of javascript that asm.js specifies so why not just use asm.js why do we want a whole different thing uh like webassembly um first off uh slower startup that's also known as parsing is expensive um asim.js is a textual format so textual formats are usually orders of magnitude slower than binary formats to parse um so that's uh it gives you it kind of hinders speed in that way um you also have limited functionality what do i mean by this it's just that uh where asimjs is still a subset of javascript so you there's a whole bunch of things that you can't actually use like 64bit integers if you have loads and stores you need to unalign loads and stores you need to mask them it's again harder to get to cpu specific features the other thing is that even though you're kind of giving the engine a hint that says use azim on a validation failure this falls back to uh regular javascript so the performance in this sense can be inconsistent the most uh important reason why we cannot use asm.js that is that it's not a standard so different browsers have different ways that they optimize asm.js so you have varying levels of performance across browsers so we're at the node summit why are we talking about webassembly so first off uh node 8 supports webassembly so node 8 is built on top of v8 5.8 which enables webassembly by default so you kind of get this for free the other thing is that one of webassembly's high level goals is actually to support nonweb embeddings reasonably well and webassembly modules can be imported into a node.js app so you can expose webassembly functions for use via javascript so the what are the benefits of you know having a webassembly module in your app at on the back end because webassembly is a portable ir you can ship a single binary to any platform in the sense you build ones and you can ship it for different platforms the important thing to note here is that portability comes with a cost so if you want portabilities there's there's a chance that you're making a performance tradeoff in the sense that your native binary is always going to be faster i mean with caveats but uh your native binaries will be faster because they can directly go to uh the machine code but it's just it's just something to keep in mind whether you want portability or whether you want the same speed um another way uh to think about this is you know think about your app in general so you have the client side and the server side so when on client side applications that things you do like image compression and language detection and other things mainly image compression let's take image compression as an example this is something that if your image is large enough you would want to send to the server but with webassembly you have you can do this kind of compression on the client side itself so you can kind of rethink what goes on the client side and what goes on the server so we talked about importing a webassembly module into your node.js app so what does a webassembly module look like so this is a webassembly module a webassembly module has a linear memory which is a contiguous uh pythagorean byte addressable range of memory um and it can go from like the offset of zero to whatever dynamic memory size and whatever memory size and you can also dynamically resize this memory a table is similar to a linear memory so instead of being bytes these are opaque values of particular table element type the main use of this in the webassembly mvp is you we use this for indirect calls other interesting elements of the module are you have globals so you store a single value of a fixed type in a global and that you know it's it's kind of separate from your linear memory so it can be arbitrarily accessed um functions obviously are the most uh interesting part of your module because they have all the code um so this is this is kind of these are the basic uh building blocks of a webassembly module um so the webassembly module can also define imports so a module can declare a sequence of imports at instantiation optionally these can be memory table functions globals uh the the main point here to note is that you can only have one linear memory and one table right now in the mvp you also have exports so a module can declare a sequence of exports that are returned to the host environment at instantiation so with all of this i've been talking about instantiation so the instance is the one that has all of the static state that you need to run a module so if you look at this like the imports and the exports are uh you know kind of openended in the sense of how you interact with your host environment so you can import functions that are defined by the host environment that can interact with your webassembly module or you can export functions from your webassembly module to your host environment and it's it's kind of openended what you want to do with it so we've been talking about uh webassembly module what does it look like so there's two things that have been uh defined in the mvp which is the textual format and the binary uh uh format so the code below is what the disassembly of a function looks like so if you this function is just like an arbitrary function that has some memory operations and it takes two parameters and it adds them so if you look at it the first uh section is the textual representation of the function so and you have a onetoone mapping at the bottom to the binary format um everything on the left is offset so the actual compressed uh code is just yeah so if you look at it it's if you look at the i32 ad line 6a is the op code for i32 add so you can see how much it's been compressed so it's just you know a string of bytes that represent that function um so if we want to take a step back and uh see what a module looks like um so this is a webassembly module and it's just again it's a string of bytes everything on the left hand side is actually just offset and you can see what the bytes uh the bytes after the colon in the sense the first colored section there represents the binary version you have a section that defines uh what functions are present so you have you know you have a function you just number of functions is one you the signature index you also have a memory section which defines the number of memories memory index 0 what what are its limits etc in this case we have one exported function so the exported export section also defines that and the function body is what i've kind of splayed out there to look at so how is webassembly implemented in v8 when we look at this uh this is how your v8 parses javascript code so if i'm sorry v8 the compiler pipeline this is what the compiler pipeline of way it looks like uh kind of glossing over some of the things there but if you have javascript source code it gets parsed and you generate these asds and the javascript graphs are then get inlined lowered and passed to the javascript optimized so so you have it it tries to figure out what the type information is and run all of these optimization passes um so how does webassembly fit into this picture so what the wasm compiler does is webassembly all is already optimized it has a static type information so you just directly feed it into the machine graph which goes to the back end and it generates machine codes specific to the platforms which could be on intel arm mips whatever a native code you want to generate so there's some things that i want to point out here we've been talking about performance we've been talking about speed uh some of the caveats that you should take into account is performance is really tricky to measure so based on your bench if you decide you want to put something over to webassembly this doesn't mean that this will make it fast on all your benchmarks uh it's it's on a casetocase basis it's you know it's just there's a lot of things that you have to worry about when you're doing performance measurement the other thing that is also important to note is webassembly is an emerging standard so you know there's use cases where you assume that webassembly is fast and in case it's not you know we have bugs like everybody else does and it's something that we're still working on um the other important thing to note is you have to use the right language for the job so if you have computation intensive programs or cpu intensive programs webassembly makes a good case uh for you it makes a good case for you to use uh port your application to webassembly but if you don't um you know there's cases where javascript does the job right and there's cases where webassembly is the right way to do it ties into the same thing that webassembly tackles specific use cases and it's not a blanket solution to all your performance problems so what are some of the use cases that you can use webassembly for you have encryption video augmentation game distribution you have image video editing there's just a whole bunch of applications a serverside computation of untrusted code there's a lot more applications and use cases that i haven't actually put on the slide but you kind of get the general idea there so um we're at mvp and what are some of the post mvp features that we're actually considering so we are considering threads atomic operators it's basically to provide low level building blocks for a p thread style shared memory you shared memory between threads you have atomics and futexes the other thing that we're exploring is fixed with simdee we've made efforts to do this in javascript with simdi.js but it's it's been tricky in the sense that you know it's probably not going to be as performant in the javascript cases there's not as many use cases but it fits well into the webassembly use case there's also exception handling you can emulate exception handling uh through javascript but you know it gives you the correct semantics but it's not going to be fast so one of the things that's in progress is uh stereocast exceptions so i talked a little bit earlier about c c plus plus and rust and uh you know use these modules in compile these to webassembly so we want to be able to support different languages so what do we want to do when it comes to dynamic languages we're trying to build a you know build like a garbage collection mechanism that can efficiently uh allocate and manipulate gc objects in wasm code so um contributing like i said earlier with webassembly one of the high level goals is that we want to work well for nonweb use cases so uh you know it's we appreciate input from different web communities to see if this actually fits their use case if it doesn't we would love for you to come up to us and tell us why it doesn't work there's a lot of information on webassembly.org including a really cool tanks demo that's based on the unity engine there's also lots of tips and tricks to get started that the github page is up there like i said earlier we work as a part of the w3c community group we have regular meetings that are over we see and sometimes in person to discuss uh use cases to discuss uh future features to discuss implementation like what all the kind of applications that we're trying to cover so um you know if this is something that interests you we would love for you to come up to us and uh tell us how this doesn't cover your use case and you know talk about it to the other implementers as well um thanks