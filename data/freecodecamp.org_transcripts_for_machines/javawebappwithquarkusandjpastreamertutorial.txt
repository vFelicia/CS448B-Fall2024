in this course you'll learn how to use corus and jpa streamer to build a rest web application corus is an open source framework tailored for Java optimized for building Speedy Cloud native microservices and serverless applications especially in containerized environments like kubernetes jpa streamer on the other hand is a Java library that simplifies database interactions by allowing jpa entities to harness the expressiveness of java stream operations when combined corus's rapid startup and minimal memory footprint works well with jpa streamer intuitive database quering offering developers a seamless efficient and cohesive environment Julia gustofson teaches this course she is an experienced Java developer with speed minint corus provided a grant to make this course possible hello and welcome again to the free code Camp YouTube channel my name is Julia and I'm a Java developer and today I'm very excited to be introducing you to two fairly recent additions to the Java ecosystem corcus and jpa streamer so the reason I pair these two tools up for this tutorial is because I believe that they have the potential of changing the way you perceive Java development and really my hope is for this tutorial that at the end of it you will approach Java development with much more excitement than before so the reason I'm saying this is because I feel like in recent years the Java language has felt a bit outdated in comparison to something like type script or python which comes with these environments where you can recompile your code really quickly whenever you make a small change and the nature of the language being objectoriented and types safe sometimes got in the way of making it like intuitive to write and read because you have to create a lot of objects and things that may seem unintuitive at the time and then also of course Java applications are known to be slow to start and have a large memory footprint and that sometimes makes them unsuitable for cloud deployment but quirkus is really here to redraw the map for us because it's an open source Java development platform that gives you a lot of value at first go so unlike many other platforms quirkus doesn't come with a steep learning curve you can really write your applications as normal but it's the build process which is completely reimagine and that means you're going to be able to restart your application in a split second whenever you're developing using the quirkus dev mode and you're also going to be able to perform continuous testing without the tests getting in the way your productivity and finally once you're ready for deployment the native build capabilities of corkus is going to boost your performance significantly both in terms of the startup time and it's going to reduce your memory footprint by a lot to show off cor is I'm going to be taking you along while developing a rest web application from scratch on the corcus platform and that's going to be reading data from a film database using hibernate and jpa streamer so JP streamer is the second component that I would like to introduce you to today today and that's because it addresses the other problem that I mentioned about Java being sometimes wordy and unintuitive so basically JP streer is an extension for hybernate that doesn't impact how you would use hybernate normally but it does extend the API with the capability to express your queries as Java streams so what that means is that you can use the stream API as a way of expressing your SQL query and upon execution it will be automatically translated to SQL to ensure that it's still efficiently executed in the database rather than in the jbm during development I'm going to be showing you all the relevant features of both corkus and JP streamer and at the end of it all I'm sure you're going to have enough knowledge to go out and utilize these tools on your own if you enjoy them as much as I do but before we get into coding I want to provide you with a little bit more background on what makes quirkus and JP streamers such good libraries so quirkus was initiated by red hat but being being an open source project it has grown a lot since with contributions from various individuals and other organizations I often see described as a cuttingedge cloud native framework that's tailored to the needs of both Java and cotlin applications but why is this important today well its mission is really to tackle some of the challenges that have shadowed Java in recent years because Java has struggled a bit to fit into the modern Cloud environments and that is not to say that Java isn't a great development language it's just a result of the fact that at the time Java came about there was different priorities you were used to building monoliths that would just deployed and ran for extended periods of time but then came the cloud environments and now we need to be much more concerned with the amount of resources for application consumes otherwise it's going to get really expensive and if we consider serverless we need to be really concerned with the startup times because we don't want our clients to wait several seconds for application to respond but the Great thing is that with corkus you can actually say goodbye to Long application startup periods the high memory consumption and to some extent even the rather slow development experience in my opinion now is also a really good time to learn corkus because as it's been maturing for the past few years all of the major Java libraries has become available on the corkus platform so that means you can use hibernate spring junit and all of those libraries just like you're used to doing for some developers the lower startup times and the model application footprint is definitely going to be perceived as the main perks of corkus but for me personally the biggest advantage of corkus is really the lifechanging developer mode I've always envied no developers who can rebuild their applications in a split second when they're making these small incremental changes to an app so when I first tried the quirkus live reload feature I was just thrilled to learn that Java developers can also enjoy such a fluid development experience and as you'll see later on all the changes that I apply to my applications are reflected immediately and I don't ever have to wait for the application to make a full restart before I can validate that things are working so as part of the demonstration of the corcus platform I also wanted to show you a library that you may not have heard of before but that is really useful in the context of database applications and it's called jpa streamer like corkus jpa streamer is also an open source project but this one was initiated by per mbor who is actually working fulltime as an oracle core Java developer today and this is a library that simplifies database access in Java applications that uses the Java persistence API or jpa so it can pretty much be viewed as a lightweight hibernate extension that will extend the API of your existing application to include this really expressive and typesafe stream query API that makes the coding experience much less error prone and it will help increase your productivity so to better understand what JP streamer is doing I'm going to show you this example because this is a stream query that will fetch 10 films from a database each starting with a letter a and are at least 1 hour long can you see how simple that is to read so critics will say that this is going to be the same as using hibernate's builtin method get result stream and then just apply the same stream pipeline but there is actually a fundamental difference in working with streams in the current hibernate API and working with jpa streamer because if you call get res stream to stream an entire table you're going to materialize every entity and that can get very expensive if your table is big but with JB streamer your pipeline is going to be translated to an hql query and that ensures that only the resulting entities are materialized as if you were using SQL all along so hopefully this made you inspired to follow along and learn quirkus and JP streamer in the upcoming tutorial so to follow along you're going to need a basic understanding of how to use Java and Java streams and I'm also going to expect that you have worked with SQL and some kind of jpa Provider such as hibernate before so that you understand how to set up the jpa entities because I'm not going to be going over hibernate in any detail your Dev environment also needs to comply with these requirements so we're working with Java 11 that's the earliest release of java that's compatible with quirkus and jpa streamer you're also going to need some kind of build tool in my case I'm using a recent version of Maven so that's going to be Maven 391 but if you're more comfortable working with Gradle I'm sure you're going to be able to adapt many of the steps to Gradle instead the same goes for your IDE you're free to choose whatever you like of course but I'm working with intellig and it's going to be easier to follow along if you're using intellig as well the final requirement is Docker because I'm going to be using a sample database that's available as a Docker image Docker is also going to be used for the native compilation Step at the end but you can also choose to install grow VM locally rather than using the grvm distribution so with that covered we're going to start building our applications so next up is the project setup once you have your jdk and IDE ready it's time to create a new corcus project and there are a couple ways you can do this either using the corcus command line interface leveraging your ide's corcus integration or using the corcus project configurator to keep the number of installations down to minimum I will refrain from using the corkus command line inter face in this video although I do recommend that you check it out if you wish to continue using quirkus in future projects configuring the project in intell has worked really well for me in the past but if you want to make sure that you find all available corkus extensions I recommend that you use the corus project configurator as I will do here the project configurator is available on the corkus website so that's corkus doio and you find it under the start coding tab on top here so this page is going to going to allow us to configure our project and that means naming it selecting what build tool to use what Java version and also adding in any dependencies that we need for the application we also need to select a corcus version and in this case I would be sticking with the latest one which is 3.2 3.2 also happens to be a longterm supported release which means it's going to be maintained for a long time since we're using hibernate for the database integration I also just want to note that quirkus 3 is compatible with hibernate 6 and later for anyone starting out fresh that's not really going to have any implications I'm simply saying that because there may be someone watching who has hibernate code in an existing project that they wish to reuse and in that case just pay attention to any breaking changes between hibernate 5 and six when you import that code moving ahead I'm going to give my project a group ID of org. freec cod camp and an artifact ID of corkus tutorial as my build tool I'm going to stick with Maven simply because that's what I'm most used to working with but you can also choose grle for example if that's what you prefer looking at the other options here I'm going to stick with the version number and I'll be selecting Java 17 as my Java version I'm also deselecting the starter code option simply because I know what application I'm going to build and I don't need a template for it otherwise if you select a dependency that has starter code that will be included in the zip file that you download so now we can go ahead and add in our dependencies and as the application will be using a mySQL database I'm going to start off by adding the jdbc driver for MySQL next I'm going to go ahead and add our GP provider which in this case is hibernate with a flavor of panach and panach is corcus specific so therefore if you're a hybernate user but never heard of panage you should just know that you can still write your hibernate applications just the same way you would in a regular job application but panach comes with some really neat features so next we're going to need the rest EC Jackson dependency as that will allow us to create rest end points very quickly and let's not forget about jpa streamer that I introduced in the beginning of the video which is going to allow us to express our queries as Java streams and finally I'm adding in small R open API which is going to allow us to use Swagger to test our endpoints so now that I have all the dependencies I'll just go ahead and click generate your application to download a project zip folder then I'll just go ahead and unzip that folder to reveal the contents and as you can tell it contains the palom XML which indicates that this is a maven project so I'll be opening it up in intellig and I'm just going to start by expanding my window to full size and then I'm selecting open and I'm locating the pom XML file because in my experience this works well when importing Maven projects so I'll open that as a project and intell will automatically add it as a maven project for me so the first thing you'll see is a read me which contains some instructions on how to run your application with corkus but as we're going through this together I'm not going to show you that now instead we're going to look in the sources directory and you can tell that there's an empty Java folder and if we peek into the pom XML file we find the dependencies I just selected including corcus itself hibernate with panach jpa streamer and the jtbc driver at the bottom here you can also see that the testing Library junit 5 was automatically added for us in the testing scope so our project is mostly set up but we're missing a very important piece of infrastructure which is the database so when I play around with new technologies I often find it useful to use something like a sample database base just to get up and running quickly and in this case I'm going to be using the seila database which is provided for free by Oracle the Aila database doesn't have a very descriptive name but it models an oldfashioned video rental store like the ones where you would actually bring your film home on tape or DVD and as you can expect most Central to the database in this case is the film table but there are various other tables that support the overall business of renting out films such as inventory customer and payment for this application though I'm going to be focusing on films and the actors that star in those films almost as if we were building an IMDb like service therefore our job application is also going to have to model the actor table and the film actor table which represents the many to Mena relationships between films and actors because a film can star many actors and an actor can star in many films the database is available as a Docker image on Docker Hub so I'm just going to be using Docker run to download and spin up the image in a container as I've used this database many times before I happen to know that it was actually built for Linux amd64 infrastructure and I'm currently on an M1 Mac and that means that Docker will by default go out looking on Docker hub for images that were built for my platform meaning the M1 in my experience the image still works fine on the M1 I just need to force Docker to accept Linux images by adding the platform flag and specify the Linux amd64 platform the D flag will detach this process from my terminal once it's up and running and I will publish my runting service on Port 3306 here making a mapping between the internal and external ports I will name the running container seila and finally I specify the name of the image that I want to fetch namely rest SQL MySQL sakila so running this command you can see that the image is being downloaded as a wasn't located locally and then finally once the image is pulled the container is started great if you have Docker desktop installed you can also try opening up the app and looking under containers to just confirm that the container seems to be up and running and in this case our cila container is there and it's looking healthy before we go on I usually think it's helpful to kind of inspect what's in the database so I'm using intell to connect to it selecting data source and MySQL as that's our database type and this will pop up this dialogue and I just need a few settings firstly the username is root and the password is sakila the name of the database and I'm also specifying here in the connection string that the name is sakila and the port is 3306 which is correct let's see if it connects yeah perfect it found it so then let's look at the contents H okay so this often happens to me in and what usually works is just making a refresh of the databased content so yeah perfect that worked opening that up we can see that we have 23 tables and that includes of course the film table which is Central to our app that has the film ID as its primary key and a number of other values associated with films and I'm just going to open that up real quick because this database contains totally made of movies and it seems like the person who came up with these descriptions had quite a fun time take this one for example Fair Prejudice the description reads a fancyful documentary we have a frisbey and a lumberjack who must chase a monkey in a shark tank well this would have been easy with chat TPT but I'm pretty sure that this database far predates it so if we also have a look into the acture table you'll see that we find lots more of these half madeup names how about zero cage well and apart from first and last name we have an actor ID that acts as the primary key then finally as I mentioned before there's one table that defines the relationship between these entities and that's called film and actor and in here you just find actor IDs and film IDs so that's foreign keys to the other tables now our goal is of course not to just view this data in intelly we really want to serve this up and be able to manipulate it via some endpoints so next we're going to need to make hibernate aware of our database and we do that by setting up the configuration and the configuration resides in the resources folder as you can see here it's called application properties and this is really the corkus configuration files so that means anything Quirk is related that needs configuration is going to be done in here it's also good to know that the database config that we're going to apply can be picked up by any dependency that needs a database so that means means the configuration is not going to be specific to hibernate however it is pretty similar to what we did before when connecting to the database and intellig we just first need to specify what jdbc driver to use and in this case again it's a mySQL database so that means we're using the MySQL driver which we have on the class path we're also specifying our jdbc connection URL and that's referring to Local Host 3306 where the database is running and then we pass along the user name which is root and the password which is sakila finally I would like to tell hibernate to log every query that we issue in the database and that's simply because it's going to be easier to follow when we use jpa streamer to see what queries it renders okay so far we've only been concerned with the setup but now we're going to move on to the fun part which is coding so in the next section I'll be creating the entity classes and setting up the jpa repository so saying that we were going to start coding was almost a lie because I'm actually going to use intellig to generate the jpa entities and the reason I prefer to do it this way is because I tend to avoid writing boilerplate and in the case of jpa entities it's mostly just beans with Getters and Setters so I generate the bulk of the code that I need and then I adjust it slightly to fit my needs so I'll revisit the database tab on the top right here and right click on my database and on the bottom I have the option of generating a persistence mapping and then I just specify in what package I would like to place the generated entities and start by deselecting all the tables because I simply want to generate entities for the actor table and the film table and lastly I make sure that the option generate jpa annotations is selected as you can see my entities were placed in the package that I spef speci ified and if I open up the film class I see that I have mappings for each and every one of my columns and this is going to cover most of our needs for this application but there's a ton of annotations that you can use to customize these entities further however as this is not a full course on hibernate I'm just going to show you what we need to get this application working and one of the columns that needs better specification is the ratings column and by rating I don't refer to a rating on a 1 to 10 scale like a one you would see on Rotten Tomatoes but rather the recommended age rating so going back to our database view again on the right we can see that the ratings column holds an enum that can take on five different values G PG PG13 R and nc17 by adding this information to our column definition we're going to help hybernate the values of the database for now the rest of the columns we can leave as is and I just need to add one more annotation to our entity as a whole because I know that hibernate will need to know what table this entity maps to and in this case that's a table called film in the schema seila and then I need to open up the actra table and add the same table annotation to this class but now I'll specify that the entity maps to the actor table but the schema name is of course the same I also know that intell hasn't helped me to specify the relationship between these two tables so I'm just going to go ahead and add that manually as I mentioned before they have a many to many relationship and this is going to be described mainly by the field actor in the film table I'm going to set that up in a second and to be able to interact with the films that an actor starson I'm going to set up this field which is a set of all the films that this actress starson and this field also needs a getter and Setter in order for it to be read or updated and next I'm going to have to go back to the film table to make a more detailed specification of this join or this relationship so again this is not a jpa tutorial and I will not explain everything that's going on here there are much greater resources on how to express jpa relationships and I recommend that you check them out if you want to learn more about this specific topic but in short I just need to specify the fact that film actor is our joint table and then I'm saying that my film entities are characterized by the main join column which is the film ID and secondly as my invers join column I'll say that I'm referencing the primary key in the actor table which is actor ID and I'm going to facilitate interactions with the actors that star in a film with a list of actors and just as in the case of the actor table I'm going to create Getters and Setters for this field so that we can read it and update it that completes the creation of the jpa entity model and from that we're going to go ahead and generate the jpa streamer meta model so why the need of two meta models you may ask well that's a good question but it has to do with the fact that JB streamer is going to translate your stream pipelines into SQL queries and in order to do that it needs some extra meta information uh about the columns basically that you wish to query so as you may have noticed a pipeline like this could have been expressed using regular lambdas but those lambdas are quite Anonymous and doesn't contain any information about the database columns that we need at all so looking at this query that I showed you previously you can notice the presence of a film dollar sign entity and that is part of the jpa streamer meta model and will expose any fields that belongs to that table so that you can easily construct these predicates which are interpretable by JP streamer luckily though generating this meta model is as easy as rebuilding your application so let's do it once your application has been rebuilt it's going to place the meta model in the Target folder and as you can see here an extra entity has been generated from both the film and actor entity usually however this folder is not considered a source folder in intellig so you have to manually mark it as a generated sources route by doing so we ensure that these classes will be made available to the application I should also note that the jpa streamer documentation contains instructions for how to place these generated classes in a different package or to name them something else than just The Entity named followed by a dollar sign but I'll leave that for you to check out if that's something you want to do so that finishes the section on meta models and now we can go ahead and build our application and just as a bit of a reminder the goal here is to provide a number of endpoints that serves information about films to clients so I'm going to structure this application using a repository pattern simply because I think that does a good job of separating the data layer from the rest of the application so here's an overview of what the architecture will look like once we're done starting from the bottom we have the sakila database and it's going to be the repository layer just above that that is going to handle all the database interactions in the Java realm our resource class on top of the repository is going to define the rest end points and we'll call the repository whenever it needs some information from the database so that means any requests performed by the clients are going to Cascade down the hierarchy hit the database and go back up to the client so all in all a very basic architecture nothing really strange here but it's still a very effective and useful way of structuring your applications and with that overview I think we're ready to start implementing our film repository and film resource so I'm starting by creating my film resource and please ignore my mistake of placing this in the model package I would rather move it one level up but I discovered it after recording the entire tutorial but as it doesn't impact the functionality at all I'm just going to leave it and go ahead with implementing this class I'm using decarta to Define my rest endpoints and by annotating this class with the path annotation my application will automatically pick up the end points that I'm going to Define in here I'm leaving the base path empty simply because I'm only having one resource in this application so there's no better way to test something out than creating a hello world base case right so that's what we're doing it's not creative it's not original but at least it's a good way to just see that we get the basic concepts so here I'm creating a get endpoint that is available at the path hello world and it will return a simple text string so basically we're just returning hello world so with that we just defined our first endpoint and I'm going to go ahead and fire up the quirkus development mode so that we can test that everything is working as we expect so the read me that we got from our template contains instructions on how to run the development mode and as you can tell the command is pretty simple mvnw compile quirkus Dev and it takes a little while to fire up okay seems like something's malfunctioning let's see what that is okay great we got some instant feedback from hibernate saying that there's something wrong with our jpa model specifically the special features field oh apparently I said this was an enum it's actually a set I believe yeah okay so it's a set of features that's allowed not just one so we're just going to go ahead and change that and if I go down to my terminal and press S I will restart the application and now it works since I haven't specified any ports it's running on the default port 8080 however the base URL does not contain any content so the corkus demoe desperately tries to provide me with other options including a link to Swagger UI and if you haven't heard of swagger it's a really neat tool that I recommend if you're working with rest applications simply because it picks up or detects all the available endpoints and allow you to test them interactively in the browser so thankfully it picked up our hello world endpoint and since it doesn't accept any parameters I'm just going to execute it and see what it says hm our response body contains hello world so that's all good and now I'm just going to take the opportunity to show you just how easy it is to make incremental changes to your applications that are instantly detected by corcus so in this case I'm just adding a second hell World endpoint I'm restarting the application by pressing s on the keyboard returning to my browser refreshing the page and there we go I have a second endpoint just like that and again I can execute it and you can see that it returns hello world 2 and this live reload feature is the thing I love most about corus I believe simply because it's just so nice to be able to stay in the Flow by avoiding these 3 to 5c latencies every time you need to rebuild and restart your application manually okay back to the practice of show don't tell so I'm just about to set up my first real endpoint but to do that I first need to create the film repository that is going to serve content from the database and again I wish I place this repository package one level up but we're going to ignore it again so here's our film repository and since we're using jpa streamer for our queries I just start by injecting a jpa streamer instance to give us a handle for our queries I'm then starting out really simple by creating a and point that can be used to fetch a film given its ID so the reason we're having an optional as a return value is that we're only going to populate this value if we find a film with a matching ID so now it's time to use jpa streamer in our application and our first query is going to remind you of the example that I showed earlier and we're basically just going to query the film table and look for films with a matching ID and considering the ID is the primary key there can only be one such film so if we find anything that's the value we return just like with a SQL query the jpa streamer query starts with the a select statement or in this case JP streamer stream film class which says that we're interested in streaming the film entities and the stream that this method returns is a standard Java Stream So any operations that can be applied to Java stream can be applied to this stream however you need to be a bit mindful about the fact that JP streamer can only translate jpa streamer predicates efficiently and not regular lambdas but they're not hard to use and I'll show you how that's done if you're used to SQL queries this would have been a worse statement but in the realm of streams we're applying a filter to check if the column film ID matches the given film ID and using the databased rumor meta model is generally not any harder than this you simply just specify which column you would like to use for your predicate and all of the common operators for comparisons are available the execution of the query is delayed until we apply a terminal operator and in this case I'm using find first so with a query in place I want to go ahead and create an endpoint that allow clients to fetch films based on their IDs so I need to start by injecting my film repository so that I can call the method I just created and from there I create an mpoint much like the ones we already have but with the one exception that I'm going to take in a parameter and that's done by placing a variable name inside curly brackets like this making sure that your method here accepts a parameter that shares the same name that it knows what to match it to and now we just simply need to call the method we just created but since we're getting back an optional I'm going to check if there is any value present because if there isn't then I know that there was no film in the database with a matching ID so if a film is present then I'll get that and I'm just going to print the title and otherwise I'll just print a message saying that there was no matching film okay so let's test that we'll restart our application oops I thought so um corus is again telling me something is wrong okay I miss the fact that when I want to inject my film repository here I need to make sure that it has an annotation that allows it to be injected so in this case I'll be using application scope to indicate that regardless of how many other classes that injects this class I want there to be only one instance of it even intellig seems to think that this looks more healthy so restarting it again looks much better so back to Swagger to test this out this time I have to provide a film ID so why not try it with the 35 and apparently that has a title that I won't even try to pronounce but it contains the word roller coaster and I can go back to my database and intell and look if this seems to be correct so opening up the film table scrolling down to 35 oh there it is all seems to work if you pay attention to the terminal logs now you can see that our application has printed the query that was issued by JP streamer but we're going to take a closer look at that in just a second I've already started here on our next query and that's going to be a paged one so we're basically going to look for films that are at least a certain length and then we're going to return the results in a paged manner so our page size is going to be 20 and we're creating the stream much like before we're streaming the film class meaning the film table and we're applying a filter to check whether the length is at least the minimum length so length greater than Min length and then to achieve our paging I'm going to skip a certain number of results in this case the page I want to access times the page size and you may notice that this is going to be a zero index paging and then we'll limit our results to our page size and just for fun we're also going to sort the films according to their length so to test this out I'm going to need another endpoint so let's go back to our film resource and craft another endpoint in this case I'm calling it page films and I'm taking in the page number and the minimum length and again it produces just plain text so this time we don't need to look for any optional values we're simply going to stream any results we get back and format them so once we get a list of films back from our page query we are mapping each film to their title and their length so that we can check that we're actually sorting them according to the sort order and also that we don't get back any films that are shorter than the specified length and then I'm using the terminal operator collect and I'm collect using the joining operator and I'll make a line break between each of the results okay so we're going to restart our application again to test this out and this time it all seems to work right from the start good so our new endpoint is detected by Swagger and I'm providing a minimum length of 1 hour and let's go with page three three perfect here we have a list of films and none of them is shorter than 1 hour and they're sorted and if we check out page four yeah we get longer films which is what we expected but now let's go back and look at our query that was issued in the database so even though we expressed our query as a Java stream this is what's being executed on the back end we have our rare predicate checking for the length condition and our sword operator expressed as an ordered by on the SQL end but you may notice that we're selecting all of the columns but we're only really printing two so I think we can do a bit better here by making a projection to only fetch the columns that we're interested in so to do this I'll have to modify my query slightly and in this case I'm going to modify the stream Source because in our select state I'm going to make a projection instead and that projection is going to refer to the two columns that I'm interested in but it also needs to have the primary key which is the ID we also need to have a matching Constructor for our film object because when JP streamer gets these three values back it doesn't know how to populate the other fields so you're going to see here that if we just try to run this with again a minimum length of 1 hour and page number three we get an exception saying that there's no matching constructure and one or more arguments were not defined so this is easy to resolve by just making sure that our film entity here has a Constructor that matches the arguments that we're going to pass in so in this case we need a Constructor that accepts the ID the title and the length and then we just simply initiate our uh Fields with these values and that should work but we'll see what happens if we try it again okay so our results look the same as before but what about our query did anything change on the sequel side yes great so now we're only selecting the three fields of Interest meaning we're saving ourselves from fetching a lot of data that we're just going to throw away anyway so for our third query we're going to make a join because now I'm interested not only in the films but also the actors that star in those films and if I want to fetch information about the actors that relates to certain film I need to join in the actor table so in this case our join is constructed with a stream configuration and that's basically just a way of saying that we want to fetch the film table still but we want to join in all their Associated actors and if you remember from before our film entity has annotations that describes this join already so we really only have to say that we're now interested in joining in these objects and then we simply replace what used to be our film class with this new stream configuration that describes a slightly more complex stream source and from here we're free to manipulate our film entities just as we did previously so first applying a filter here to check for films with a title that starts with a past in string and then I'm going to sort these films again according to their length but this time I'll reverse the order just to show you how easy it is to do that and that's all I'm going to do for this query so again I'm copying this time the other endpoint and making small modifications to it so accepting a starts with value passing that in and then calling my new join method but this time the formatting is going to be a bit more complex because I have a stream of films and I'm GNA start by printing out the again the title of the film followed by its length and then I will list all the actors that stars in the film so the first value here is going to correspond to the title and secondly the length but then my film actor field actually returns a list of actors so to print that I'm going to stream over the list of actors and I'm going to map each of the actors to their first name and last name so just simply concatenating together those values and then joining them with the collector operator separated by commas and finally I'm again joining all my film entities separated by line breaks okay so simple restart of the application will give me access to my newest member of the rest endpoint family and I'm trying it with the character a and here we get back a list of all the films that starts with an a and you can see all the actors that relates to those films and now again if we go back to look at the query you can see that the join is being applied in the SQL query and of course I'm not saying that you should come back to the sequel that JP streamer generates every time but I do recommend it as a great way of understanding what JB streer does especially if you're starting out and want to understand what your pipelines are being translated to especially if you're working with large data sets in which case the performance is going to be critical and you may have to optimize your queries in certain ways so before we move on I'm just going to show you quickly how easy it is to combine multiple predicates so here I'm just combining both of the predicates that we worked with before checking that our title starts with a certain string and also checking that the length meets a certain condition and for that to be effective on the rest endpoint side I'm just adding that second parameter here restarting and testing so let's do two hours now and an a as our star character again yeah we don't get back anything shorter than 2 hours but let's make it a bit more restrictive so that it's easier to see that we're actually getting the right results yeah nothing's shorter than 170 minutes and all of them start with a I'm also going to show you how you can actually use JB streammer to filter out films you would like to update so we can in this case up update the rental rate of our films and the rental rate is of course what you would charge to rent out one of the movies for demonstration purposes we're going to use a rather unconventional algorithm in this case so we're going to set the price of the movies that are longer than a given length oh I also just recall that the type of rental rate is actually a float so updating the movies that match this griven predicate is really simple you just again use datas streumer to select the films of interest and then apply the for each operator to set a new rental rate of each of the movies that remain in the pipeline and that's really all there's to it but before I create another endpoint to facilitate these updates I'm going to create a small utility method for my response value that just sends back all the movies that have been updated and their newest price so again just creating a stream of all the films filtering them to make sure that they are longer than the given length and then sorting them by length Okay so for some reason this is not compiling found an extra parenthesis there perfect so this is going to be our final endpoint and in this case we are actually going to perform updates so let's make sure that what we just did is working so I'm naming this one update and then I'm accepting a minimum length and a new rental rate you know the drill by now right just updating my method parameters so I'm just going to start of course by updating the prices by calling the method update rental rate that we just created and then we'll call the utility method to return back all the movies that should have been affected by our update so just get the films of a certain minimum length and then I'm updating my string formatting here to include the rental rate as well so that we can see the new price okay restarting the application let's see how this goes my new endpoint is there looking all good so now let's just update a few of the really long ones so minimum length of 170 and a rental rate of $10 okay so I see no price change whatsoever and this could be explained by two things either we didn't make any updates at all or the updates were not reflected in my second query just fetching the films again but we're going to take a look okay so looking in the database none of the prices have actually changed so that means my update wasn't effective at all and I must admit I did this intentionally just to point out that your updates are not going to have an effect unless you apply the keyword transactional to your your update method so The transactional annotation here indicates that we would like to persist any updates that we make on our film entities in this method so if all goes well this should fix our problem and thankfully it did so now you can see that our updates have taken effect and the new price of our movies is $10 and if we now go back to the database it's going to be a different story because this time I'm sure that the prices are reflected okay first update yeah there we go our new prices are showing so up until now we've been testing the application manually just going back and forth to the database printing things and this is of course not the way to do testing this is way too error prone so corkus has this really cool feature built into its development mode that allows you to create tests that are run every time basically your application is restarted and that way you get instant feedback on whether or not things are working the way you intended them to so with that said let's go on to make some continuous junit tests so if youve been following long from start using the corkus starter page then you should be all set up in terms of dependencies but I'm just going to restate what is needed to get the continuous testing working the way I'm going to show you now so first off you need to have the porus junit 5 dependency and this should be automatically added for you but if you don't have it make sure to add it and as a final less obvious step you need to set your Maven Shire plugin version and that is because the default version does not come with support for junit 5 so make sure you set it to something recent in this case I'm using 3.00 from this point on testing is really not much different from creating your regular Jun tests so to start I just need to create the standard Maven test folder which which didn't exist from before and then I'm going to go ahead and create a film resource test since I will be testing out our rest end points then to have them run automatically when you rebuild your application I'm applying The annotation quirkus test and from here I'm sticking with the Jun annotation test to create my first test of the rest endpoint hello world as we're testing rest end points I also want to take the opportunity to show you a really convenient Library that's specifically designed to test end points this is of course totally optional but if you want to use it then add the dependency rest assured just as I'm doing here and I'm also going to put it in the test scope since I don't need it for my application so rest assured in combination with corkus is really powerful since this will allow you to run integration tests T only by specifying what the endpoint is that you would like to call what parameters to call it with and then Define the expected result so here I'm saying that I want to call the endpoint film with an ID of 343 and then I expect the status code to be okay namely 200 and I also expect that my body contains a certain string in this case I'm expecting it to contain the title of that film and I just need to quickly check in the database what I'm really expecting here so I'm going over to the film table looking for it frantically there it is okay I figured I might as well pick another ID which is more easily available so I'm going to change the ID to five and I'm expecting it the title to be African egg so all I need to trigger this test is to reround my application and you can see on the bottom that it says press R to resume testing so I'm pressing the key R and now it says running one of one all tests passed and that's great so that means the title was actually African egg but I can add in a second test to also show you what it looks like if the test is failing so if again I'm querying the same endpoint film with an ID of five and still expecting the status code to be 200 however I'm going to put in a different string for the body to show you that it's going to warn you if it's wrong so in this case I'm expecting it to be Titanic pressing R again to rerun my tests and now we can immediately tell that something is wrong because we got back African egg and we were expecting Titanic so there's a number of aspects of this that I just find so powerful since a lot of this tutorial has been focusing on developer experience again this is a Fant fantastic example of an API that is so fluid and smooth to work with we also didn't have to do any special configurations um letting quers know how to run our services where to find these endpoints all of that just works out of the box it will spin up the services for you on a designated test port and then execute all of your tests even though I find this part more impressive it's also of course really useful to be able to just perform unit tests rather than integration tests so I'm also going to add in a film repository test and that is just to show you how you can perform unit testing meaning in this case we're going to test the film repository class directly so again I'm adding in the corcus test annotation to allow corkus to pick up my tests and then I'm injecting my film repository just like we did earlier for the film resource and then I can just go ahead and create a normal junit test where I'm going to call the film method directly to get one of the films for Simplicity I'm using the same argument as before so that we know that the title of the film is African egg but as this method returns an optional I'm actually first going to assert that the optional is not empty meaning there is a value present in this variable and after that I'll assert that the title is African EG okay let's rerun the tests oh I'm going to get rid of the failing test in the other class just to have our output show us that all of the tests are passing there we go so now you know how to perform both regular unit tests and also integration tests with corkus continuous testing luckily in this case uh both of our simple tests were passing but if we discover that one of our tests were failing and we didn't know why then it might be useful to use the debugger that's built in in intell so next I'm going to show you how you can attach the debugger to the corkus dev mode so that you can try your arm points in Swagger and hit break points in your code due to the order in which I was recording this uh we've gotten back the failing test on top here but let's ignore that for now and restart our development mode with an extra flag namely D debug and that's going to fire up uh the corcus development mode in debug mode so now I'm just going to go ahead and create a run configuration which will allow me to attach intellig debugger to my corcus application so in this dialogue I need to select the little plus sign on the top left here to create a new configuration and in this case it's going to be a remote jvm debug so let me just find that option and the default settings are actually fine here because uh the corkus log said that the corus is listening on Port 55 so I'm basically just naming my R configuration and then uh restart corkus and also starting my debugging process in int and it instantly says that it's been connected to my target versal machine on Port 50005 so let's just go ahead and add in a break point to see that it's all working so I'm using this simple endpoint get film and just like before I can make a request from Swagger and this should hit my breakpoint if everything's working out fine yeah it did I'm pretty sure that you already know how to use intelligence debugger from here so I'm not going to go into any more depth I just wanted to show you what it looks like working with intell debugger and the quirkus dev mode at the same time now that we actually have a working application I think it's time to think about how we can improve the application's performance because as I stated early on when introducing corus native compilation is one of the reasons why you should consider using this framework so we're going to have a look at how much we can improve our startup time um by building the corcus application in two different ways the first one is using the corcus build command and this is the standard way if you just want to package your application as a standard Java jar and the build process is of course also going to run the test that we've created to assure that our application seems to be working and once the build process is done we can find the jar in the Target folder at the root level here you can see that there's a corcus tutorial one snapshot jar and that's your regular Maven build jar um so that's not runnable it Just contains all the classes and resources for your project however if you look into the quirkus app folder you can see that there's is a corkus run jar and that jar can be used to execute your application however if you want to deploy your application somewhere like in a container then you would have to deploy the entire corcus app directory because this jar is not an Uber jar it doesn't contain all the dependencies that your application needs to run but since we have access to this folder now we can run the application from with inside that folder so here I'm just using the regular Java command to run a jar file so as the application starts it's going to tell us how long it took to fire it up in this case 1.7 seconds while we're at it I'm also again just going to test that this works so opening up Local Host 8080 but this time I'm not running in the corkus dev mode but rather um running the actual built application so an ID of 34 gives us back Arabia DOA and the logs are still showing that we executed a query so the REM file that we got with our project template actually contains instructions on how to build your application natively as well so there are two versions of this script the first one uses grvm and the second is using a container based version of grvm in case you don't have grvm locally but since I do have grvm installed I'm running the First Command you're going to notice that this takes uh quite a long time compared to the regular build but that's totally according to plan because what we want to achieve when compiling natively is really to first off get rid of all the unnecessary unused code uh which is going to require some code analysis and grvm is also able to build up some of the state that we're going to need at the time when we start up our application and that's also going to save us some time here I've been speeding up the process so you wouldn't get bored but it took me about 4 and 1/2 minutes to complete the native build and the result is a runner script that can be executed just like any other shout script and you'll find this runner in the root of your target folder so here it is corkus tutorial one0 snapshot Runner so I'm firing that up in my terminal and immediately you can see that my application now started in a tenth of a second so this is a massive Improvement from what we had before okay that marks the end of this tutorial and I would like to thank you so much for watching I hope you picked up some new Java skills along the way and I also hope that you like Java a bit more now that you've seen what quirkus and date based RoR can do as a reminder they're both free to use so I encourage you to go out and check out their documentation that is linked in the description below because there's so much more to discover that I didn't have time to cover in this video