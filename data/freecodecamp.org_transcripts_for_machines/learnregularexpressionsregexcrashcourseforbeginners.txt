hello and welcome to this course on regular expressions regular expressions or regex define a search pattern that can be used to search for things in a string now this course focuses on using regular expressions in javascript however almost everything you learn about regular expressions in this course can also apply if you're using regular expressions in another programming language my name is beau carnes i will be teaching this course i'm with freecodecamp.org in fact this whole course is based on the free curriculum at freecodcamp.org it's not required to go through that curriculum to also do this course but it could be helpful however this course is designed to be standalone but if you want to go through the curriculum on freecodcamp.org as well you can look in this picture where it has the arrow right to the regular expressions part of the curriculum so you can see where that's at well let's get started regular expressions are used in programming languages to match parts of strings you create patterns to help you do that matching so for instance if you have the sentence the dog chased the cat and you want to match the word the you can use this regex here you can see that there's a slash then the word the in another slash you will also notice that quote marks are not required within the regular expression so javascript has multiple ways to use regexes one way is to test the rejects is to use the test method the test method takes the regex applies it to a string and then returns true or false if the pattern matches something so in this example we have the string hello world we have this regex and we have my regex i'm going to do dot test and then inside the parentheses i'm going to put my string so we are going to see if my string contains this regex which is hello and then we'll put it into the result in this case it will be true because hello world does contain the string hello here we want to match the word waldo we have this sentence somewhere waldo is hiding in this text so i'm going to change this regex instead of search it's going to be waldo now one thing i want to point out is that this is case sensitive so if i had a lowercase w then this would not match but since this starts with an uppercase w i have to make the regex start with an uppercase w also so this result the waldo regex.test while waldo is hiding it's going to return true because it found waldo in this sentence regex has an or operator which is a single pipe character so in this example let's say we want to try to match for multiple words instead of just a single word let's say we want to match dog cat bird or fish so what i would do here is i'm going to change this i'll do dog and then i'll put pipe which is just a straight line up and down and then i'll do cat pipe bird type fish so this is going to match any of these four words dog or cat or bird or fish and since one of these words is in the sentence this test is going to return true so far all the regexes we looked at matched literal strings so the case mattered if it was a capital letter that's completely different from a lowercase letter you can match both cases using what is called a flag so there's the i flag that ignores case so let me show you how you would do that let's say we have free code camp and we'll see it's all lower case in here but we want to match it no matter what the case so we want this to also match this where there's a capital c and another capital c so just after the last slash i'm just going to put an i so this is the flag this means ignore case so now when it tests the string free codecamp for the regex which is free codecamp all lowercase the result will be yes because they will match so far we have just checked if a pattern exists or not within a string but we can also extract the actual matches that we found with the match method so let's see how to extract the word coding from this string so we'll just change this to coding and then here we'll use the dot match method match and then in the parentheses we'll pass in coding regex and then if we just run this we'll see in the console coding because it's logging out the result see the result extracted this word coding out of the sentence and into the result variable and it got logged so far we've only extracted search patterns one time but it is also possible to search or extract a pattern more than once using the g flag let me show you what i mean we have this test string up here repeat repeat repeat now we're going to search for repeat and the way it is now when it matches this it's only going to return the first repeat just this one but if we add the g flag after the slash here it's going to find every single occurrence of the word repeat so it's going to return an array with three elements and each element is going to be the word repeat let's see it again down here where it says twinkle twinkle little star i want to match the word twinkle so i'll type in twinkle right here and you'll see that the first twinkle is capitalized the second one is not so i'm going to have to use a flag i'll have to use the i flag which makes it insensitive to case so it's case insensitive i'm also going to add the g flag that's going to match every single time twinkle appears so you can use two flags at once on the same regex now here for the result it's gonna be twinklestar.match and then i'm going to pass in the star regex okay now we'll log this and see what happens you can see twinkle twinkle the first twinkle in the console is the capital t and the second is the lowercase because it matched the first one and the second one and return them both in regex a period is a wild card character it can stand for anything so let me show you an example we have these two strings up here and the first one has the word hum the second one has the word hug you'll notice that these two words start with the same two letters h u and then the third letter is different so look at this regex here h u period this will match any word that starts with the characters hu and then then has a final character which could be any character so if we look down here we are going to take the first string alhamsong and match it to our regex it's going to return hum and then when we take our second string bear hug and match it to our regex it's going to return hug so let's try that with another sentence we have this sentence here let's have some fun with regular expressions so i want to match the word fun but i also want this regex to be able to match the word run sun pawn none or bun basically any word that ends with you in and starts with another letter so i'll change this regex to dot u n so when we run our regex and search this sentence for something that ends with you in it should find fun so let's load that and look in the console and it says true because it matched the word fun in that sentence we talked about the wild card character which matches basically anything but you can also match from a predefined group of characters if we look at this right here it we have the b and then we have these brackets and inside the brackets we're saying that the second letter that's going to match has to be one of these three letters so we know the first letter is going to be b the last letter is going to be g and the middle letter is going to be a i or u so this would match bag big and bug so down here what we want to do is change this so we match every single vowel in this quote sample here so what i'm going to do is put open and close brackets and inside i'm going to put the vowels a e i o u and then to make sure i match every single vowel and i match uppercase or lowercase vowels i'm going to use flags i'll use the i flag and the g flag now down here i'm going to have to do quote sample.match and then i just pass in the valve regex here if i run this in the console you'll see all the vowels from that quote sample you can also match a range of letters so let me show you how to do that right here i'm going to try to match every single letter so i'm going to put the open and close brackets and instead of typing a b c d e f g and writing every letter i can just put a through z so it's going to match every letter between a and z and then to make sure it matches every uppercase and lowercase letter i'll do i and then g to make sure it matches every letter in the whole string so now i can just do quote sample match and then i just pass in the alphabet regex here and if i run that we see in the console it has every letter in that string just like you can use a regex to match a range of letters you can also match a range of numbers so if i want to match range of numbers it will be like this i'll have the brackets here the opening and closing brackets and this time i'm just going to match the numbers 2 through 6. so i'll just put 26 so that will match 2 3 4 5 6. also in the same regex i can match a range of numbers and a range of letters so if i want to add some letters i can put h through s so now we can see this is going to match a range of numbers 2 through 6 and also a range of letters h through s so i can do an i to make it case insensitive and a g to match every occurrence in the whole string so i'm going to put that into my results so i'll do quote sample dot match to match this regex and here it's going to console.log the result so let's see what happens and we have every letter and number between those ranges we've talked about how to match for specific characters but what if you want to create a set of characters that you do not want to match these are called negated character sets and you can create them with the carrot character so let me show you how to do that this we want to make a regex that will match everything except all numbers and all vowels so we are going to put a opening closed bracket and i'm going to put a carrot character that's right underneath the six on a keyboard and i'll put zero through nine so we are not going to match all digits zero through nine and we are not going to match a e i o u and then i will put my flags here i g so this will match everything except zero through nine and a e i o u so to finish this up i'm going to put quote sample dot match and then i'll pass in the regex here and now i'll just run this and you can see we've returned everything except the vowels and the numbers it includes the spaces and periods and punctuation also sometimes you want to match if a character occurs one or more times if you want to do that you can use the plus character so let me show you how to do that in this case we are going to try to match in the word mississippi whenever an s occurs one or more times so i'm just going to put s plus and i'm going to put a g to match it every time it occurs and if i run this you'll see we've matched the first ss and then the second ss if there just happened to be another s in here we would then match three times and you can see the third time only matches the single s because there's only one s in a row there is an option to match characters that occur zero or more times that's with this star character here so this regex means match a g and then match an o zero or more times so with this word gold it's going to return g o and then every o after it and then here gut feeling there's a g with no o's after it and since it's matching zero or more times it's going to match that and just return g now this one has no it has an o's but it doesn't have a g so it's going to return null it's not going to match at all so down here we are going to do some coding and match a zero or one time so i'm going to change the change word here and we always want to get the capital a and then for the lower case a we are going to do it a asterisk so it can match this whole thing of a's here so if i just do a console.log here and do a result it should match all of the a's it worked i am going to talk to you about greedy and lazy matches a greedy match finds the longest possible part of the string that fits the regex pattern and returns it as a match a lazy match finds the smallest possible part of the string and returns that regex patterns default to greedy let me show you what i mean let's look at this string here titanic and we'll look at this regex to find something in the string titanic first we're looking for the letter t and then this part means after the letter t we want zero or more of any letter so remember this means any letter a through z the asterisk or star means zero or more occurrences of this a through z and then finally we're looking for a letter i at the end so when we run this match here it's going to do a greedy match and find this t i titani so it's going to start with a t it's going to have zero or more letters and in with an i however if we put a question mark here it's going to be a lazy match so it's going to start with the t and then remember this is zero or more occurrences so instead of having all these letters we're gonna go to the zero occurrence and not have any letters and then end with this i here so it's just going to be t i so a greedy match would be t i t a and i a lazy match would just be t i so let's do the same thing down here we have this string here which is a bit of html with an h1 tag some text winter is coming and a closing h1 tag if i run this now you'll see in the console it's going to return the whole thing so we're going to start with the more than sign here and then we have the dot which is a wild card character so this means any letter or character and then the star or asterisk means zero or more occurrences so this means zero or more occurrences of anything and then we end with the greater than sign so we're going to start with the less than sign right here this is to open an html tag and then we have the dot which is a wild card the asterick or star which means zero or more occurrences so when you have a dot asterisk that means zero or more of occurrences of any character and then end with the more than sign or that the closing tag here so it's going to go from here and then it's going to have zero or more occurrences of any character all the way to this final uh character here this greater than sign so what we're going to do is change this so instead of just get instead of getting this whole thing which was which is greedy we want to do a lazy match where it starts here and just ends at the first occurrence of this greater than sign so all i have to do for that is to add a question mark so if i run this now you'll see in the console it just has the opening h1 tag this is a basic regex challenge so here is the scenario a group of criminals escaped from jail and ran away but you don't know how many however you do know that they stay close together when they're around other people you are responsible for finding all the criminals at once so the criminals are represented by a c so you can see here we have these three c's together these are all the criminals so we need to write a regex function that's going to match any times there's there is one or more c's in the string that's passed in so this is how you would do it it's actually pretty simple we're just going to put a c and a plus so it's going to match one or more c's and if we load that you'll see that it matches the ccc and we solve the challenge you can match patterns that are only at the beginning of the string previously we talked about how the carrot character inside a character set is used to create a negated character set well if you're not in a character set if you're not in brackets you can use the carrot character that looks like this to only match at the beginning of a string so here i'm just going to match the word cow if it's at the beginning of a string so if i load this you can see true because it is the cal is at the beginning of the string however if i take the word cal off here and put it in the middle here and i reload that again it's going to say false because it does not match it anymore since cal is not at the beginning of the string a carrot matches a beginning string pattern a dollar sign matches an ending string pattern so if we want to match the word caboose at the end of the string here we'll type in into the regex we'll type in caboose and then i'll put a dollar sign if you remember when we were matching a beginning string pattern we put the care at the beginning but when we're matching an ending string pattern we put the dollar sign at the end so if i run this we'll see true because it's at the end of the string now if i actually move this over here and i run this we'll see false it's no longer at the end of the string so it no longer matches caboose earlier i showed you that this with the brackets in a through z in it would match any letter a through z there's something called a shorthand character class that's used to match a a wide range of things and there's one called slash w that you can use to match the alphabet so if i put slash w here that's going to match capital a through z lowercase a through z the digits zero through nine and underscore so just doing slash w is just a shorthand way of pretty much matching any letter or number plus underscore if i put a g after this that will make it match every occurrence so if i load this up you'll see that it returns 31 because we're getting the length the length of this whole string excluding the spaces in the period is 31. there are 31 letters in this string slash w matches all letters or numbers but sometimes you want the opposite sometimes you want to match everything that's not a letter or number so in this code we want to just match everything that's not a letter or number which are the spaces and the period in this string here so instead of a slash lowercase w we're going to use a slash uppercase w and then i will put a g to match every single occurrence and we're gonna get the length here so if i run that we get a length of six there are six characters that's those are the spaces and the period that are not letters numbers or underscores there is a shorthand character class to only match numbers or digits and it's slash d so if i put slash d here it's going to match the digits here which is the five the zero and the zero to match every single one i'm going to put a g at the end for global and then now the length should be three so if i run that we'll see three in the console sometimes you want to match all non numbers if you remember this slash d a lowercase d would match all numbers and the g made it match every occurrence of a number so if we change this to an uppercase d this is going to match all nonnumbers so that's going to be every single character in this whole string except the five the zero and the zero so we'll run this to get the length of that and we get 24. we're going to create a regex that can be used as a username validator in this case there are three requirements for the username so here's the first requirement if there are numbers they must be at the end second requirement letters can be lowercase and uppercase and then the third requirement is that it must be at least two letters long two letter names can't have numbers uh which is kind of a fourth requirement so let's create the regex here so first we are going to do the requirement that the number should be at the end so if the numbers should be at the end then letters should be at the beginning so to specify what's at the beginning we are going to use the carrot sign and then we're going to specify the letters that can be at the beginning which are lowercase and uppercase letters so i'll do a through z uppercase and then 8th a through z lowercase so now it shows that at the beginning is going to be a through z uppercase or a through z lowercase and to specify the number of letters that are going to be at the beginning we're going to use the following i'm going to put a curly brace 2 comma in curly brace the curly braces indicate the number of times the previous thing can match so the previous thing are these letters and these can match anywhere between two and infinite number of times so the number before the comma is the minimum number of matches and the number after the comma is the maximum number of matches so we know that every username is going to start with at least two letters and since there's no number after the comma it can have an infinite number of letters in the username if we wanted it to have at max eight letters then we could put the number eight after the comma but since we don't care about the max we're gonna leave it as nothing after the comma so next we want to show that the numbers must be at the end and you can have any number of numbers so i'll put slash d and that represents all numbers i'll put a star so this star or asterisk means that there should be zero or more so this means zero or more numbers and now to show that the zero or more numbers are at the end i will put a dollar sign we can now run this regex to make sure a username meets all of these requirements we can match white space characters with slash s so slash s is going to match a space a carriage return a tab a form feed and a new line character so if i add a g for global and run that we will see an array of all the spaces in that sentence the white space is important in separating words sentence now i'll show you how to match all nonwhite space characters first make a guess so remember this is how you match white space characters and if you've been noticing the pattern so far you'll realize to match nonwhite space characters is just a capital s so if we run that you'll see an array of every character that's not a space you can specify the lower and upper number of pattern matches with quantity specifiers quantity specifiers are used with curly brackets i actually talked about these a little bit before you put two numbers between the curly brackets for the lower and upper number of patterns so let's say i want to match anything any oh no where the number of h's is between three and six h's so what i'll do is type o no but after the h i'm gonna put these curly brackets and put three comma six so this means we're gonna always match the letter o and then we're gonna match the letter h but we only match if there is in between three and six h's and then we'll also match this space in o if we had not had a number here and we just had three comma and the nothing in the in curly brace then it would match for an infinite number of occurrences so it would be three h's through an infinite number of h's but we'll just leave it at six here's another example with quantity specifiers where we're going to match four or more of the letter z so i'll put the letter z and then the curly brackets i'll put four comma and then there will be nothing after the comma because like i said before when you have nothing after the comma there's an infinite number that it could go to so it has to be at least four and then it can be an infinite number of z's we can use quantity specifiers to specify an exact number of matches instead of just a lower and upper bound so if we want to search for the word timber with exactly four m's you can do it like this pim and then i'll do the curly braces and then just put the number four and then ber so remember before we had the up the lower bound then comma upper bound but if we know we want exactly four m's we can just put the number four in the curly braces you can specify the possible existence of an element with a question mark this checks for zero or one of the preceding element it's kind of like saying that the previous element is optional for example there are slight differences in american and british english so the word favorite can be spelled with just an o or with an o u with british english so let's create a regex that that searches that can match both forms of the word favorite so do favor and i'll put a u with the question mark rite so this is this is saying that it may have a u or it may not have a u but all the other letters have to be the same lookaheads are patterns that tell javascript to look ahead in your string to check for patterns further along this can be useful when you want to search for multiple patterns over the same string there are positive lookaheads and negative lookaheads so let me show you how they work so this right here is a positive lookahead so we have parentheses and then we have a question mark so the lookaheads always start with a question mark and then it's going to be equals for a positive look ahead or an exclamation point for a negative look ahead so let's look back at the positive look ahead so question mark equals means a positive look head and u so it's first going to check for the q and it's going to look ahead to make sure there is a u later in the string and if there is a u later in the string will return just the q so when we run this regex on the quit string it's going to return q because it finds the u later in the string but it doesn't return that u a negative look ahead it's going to make sure that something is not later in the string so here it's going to search for a queue and make sure there's not a u later in the string and if there is not a u later in the string it's going to return this so when we run this look ahead on the no quit screen string it's going to find the queue and it's going to look ahead and find out there is no u since there is no u it's just going to return the q because that's what we have before the parentheses and it's going to return the q here a more practical use of lookaheads is to check two or more patterns in one string so down here in this example we are going to use lookaheads in the pw regex to match passwords that are greater than five characters long and have two consecutive digits so for a greater than five characters we'll do parentheses and then it's always gonna start with the question mark equals if it's a positive lookahead and i want greater than five characters so slash w would be all numbers and letter characters and we want there to be five characters at least five characters and then we also want two consecutive digits so i'm going to make another look ahead question mark equals and we're going to say there can be any number of characters that are not digits this capital d the slash capital d is a character that's not a digits and the asterisk means there's zero or more characters that are not a digit but we also want to make sure that there are two or more digits so we have the slash d to say that there are going to be digits and then we have two so it's going to be two or more digits so this is going to match for five or more characters and then two or more digits you can group things you are searching for in a regex with parentheses so here we have parentheses around here so we are searching for any number of characters and then after that there's going to be a space you can also use these parentheses to repeat sub strings so this is called a capture group and you can repeat this group any number of times so in this regex we have this first group in parentheses and we can re we can repeat that first group with a slash one if we had a no another group with parentheses we could repeat that second group with slash two so in this case we are searching for any group of any number of letters followed by a space followed by any number of letters that are the same letters as before because we're doing slash one if we test this regex against this string it's going to return true because it has any number of letters it has a space and then it repeats any number of letters the same letters from before so that's any number of letters the space and then we're repeating the same no letters as before now here where we did slash one we could have just put this whole thing again the parentheses with the slash w i'm gonna copy and paste here so this would have been the same thing uh but instead of repeating this twice we can just put slash one to save space so we don't have to repeat if we want to repeat the same search over and over again in a in a regex so if we look down here for the match at first this may seem confusing what it's returning but what it's returning the first element in the array is the full match so that's the the any number of characters plus a space plus any number of the same characters so the full match is this and then the second element in the array is just whatever is in the capture group this is the capture group and we and what's in the capture group is just regex that's why we have regex regex which is the full regex and then the second element of the array is just regex which is just the capture group the thing in the parentheses here so down here we are going to attempt to use capture groups to match numbers that are repeated only three times in a string each separated by a space we want this regex to match something like this 42 space 42 space 42 we would also want it to match something like 136 space 136 base 136 it doesn't matter what the number is and we only want to match a group of three so we don't want to match four numbers five numbers six numbers just a group of three numbers separated by spaces so let's see how to do that we are going to use a capture group so i'm going to put a parenthesis slash d plus that means any number of digits and that's going to be the end of our capture group and then it's going to have a space and then i'm going to put slash one which just is a shorthand way of repeating the first thing in parentheses which is this and then we'll have another space and another slash one so this is going to look for any number and a space any number and a space any number so it's a number three times we're not quite done yet though because remember i say said we want to match only three numbers so this regex would also match this if the number was in there four times because it would find 42 42 42 and then stop and it would say oh we found it but we don't want to match it if there's 4 42s in a row we only want to match it we only want this to return truth there's three 42s in a row so that's simple to fix we just have to have a bracket or i mean a carrot at the beginning and a dollar sign at the end so remember a carrot means that we want this at the beginning of the string and then a dollar sign means we want this at the end of the string so adding the care and the dollar sign just means we want exactly this we don't want anything before this we don't want anything after this so now this will return true for any group of three numbers not a group of four numbers not a group of five numbers you can search and replace text in a string using the replace function on a string the inputs for replace is first the regex pattern you want to search for and the second parameter is the string to replace the match or a function to do something so let's look at this example we have this text the sky is silver we're going to search for silver this is our regex pattern so we're going to do a replace here we've got the wrong text dot replace we're going to pass in the regex the silver regex which is searching for the word silver and it's going to replace it with the word blue so this is going to return the sky is blue now you can also access capture groups in the replacement string with dollar signs let me show you what i mean down here so here we have a string code camp and we're going to call the replace function on that string now look at the regex so up here we just use the variable silver regex which was set to this regex here we're putting them in the regex directly into the function instead of using a variable so look at this regex we have this capture group which just means any number of letters then we have a space and then we have this other capture group which just means any number of letters so that's going to find this code space camp any number of letters space any number of letters so let's look here so up here we just put in the word we want to replace with but here we do something different it says dollar two dollar sign one so dollar sign two means the second capture group the second parentheses in the regex so the second capture group is this which has matched to the word camp so we're putting camp at the beginning and then a space and then dollar sign one means the first capture group which is this section which matched the word code so this is a way so you can see it returns camp code so we pass in the text code camp and it returns camp code so that's another cool thing you can do with capture groups when you're doing a replace so let's get back to the easier one up here we're going to actually make some changes down here that follows this pattern up here so this sandwich is good well we are going to find the word good here and we're going to replace it with the word okie dokie so here it's going to find the fix regex which is good and it's going to replace it with the replace text which is okie dokie this is a regex coding challenge the challenge is to write a regex and use the appropriate string methods to remove white space at the beginning and end of this string here now the trim method would work here but the challenge is to do it with just using regular expressions so we are going to do a replace but we have to write a regular expression that's going to figure out what we're going to replace well let's write a regular expression that finds all the space at the beginning and all the space at the end so this is how we'll do this to find everything at the beginning it's going to start it with a carrot which finds something at the beginning of a string and we'll put slash s which is all the white space and the any number of white space characters i'll do a plus now we also want to find all the space at the end so i'll do a pipe character which means or so all the space at the beginning or all the space at the end for all the space at the end we'll do slash s plus and then a dollar sign which means this has to be at the end and so we find both the space of beginning and the spaces at the end i'm going to add the flag g here so now we've found all the spaces we just have to finish this replace here so hello dot replace and then in parenthesis first the regex w s regex and then we are going to replace all the spaces that it's going to find with just an empty string so this will effectively remove the spaces from that string uh oh i need a parenthesis here and let's test this out you can see in the console hello world with no spaces at the beginning or the end congratulations on finishing this regular expressions course well keep learning and thanks for watching