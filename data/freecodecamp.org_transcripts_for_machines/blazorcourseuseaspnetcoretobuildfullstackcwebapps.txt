laser is a single page application framework created by microsoft with blader you write c sharp to generate dynamic content and with blader you can become a full stack developer with c sharp on both front end and back end my name is frank liu i'll be talking about the architecture and how it works for the first three modules then we'll get into every aspect of laser indepth towards the end we will be creating a reusable data grid component using the knowledge that we are going to learn without further ado let's get started blazer is for web development so to talk about laser architecture i want to talk about two typical web development architecture first the first one is the very typical request and response model where you have a browser and you have your user interact with the browser and whenever the user wants to see something the browser sends a http request to the server side server and the server process the request here and returns a rest http response and what's in the http response is html and then the http the html will be rendered on the screen and the user sees it and the user is happy so this is the first architecture and a lot of the development technology actually uses this for example the original from microsoft's original classic asp right so asb and then you have jsp and then you have the microsoft asp.net web forms you have asp.net mvc and the asp.net core mvc yeah a lot of them are using this architecture with some help wizard without some help of javascript and the second architecture is it's more interactive that's when the um the web development world notice that that this first architecture it's good but the performance wise it's it's not great and when the development world notice that the the browser actually it runs it's its desktop application it runs on the computer and has its own powerful um compute computing power and as the client computer is getting more and more powerful the smartphone also gets very very powerful the browser has a very powerful computing power the storage is getting bigger and bigger as well so then why don't we take advantage of this computing power so that introduced the second architecture where we actually use this javascript running directly on the browser and renders the result to the dome right and here let's start from the user side so the user interacts with the browser and then um the browser the dom actually uh sends events like the user clicks on button so you have a on click event right and then some other controls may trigger on change event so on key down on key up those kind of events are handled in the javascript and then the javascript since calls the web api running on the server nowadays you have more options but uh let's just use web api for uh for example right so it sends a web api so this is a http request and then the web api actually uh communicates typically communicates with a database to get the data so here in this example i was just uh i didn't talk about the details here but in the second architecture i have to so javascript calls the http uh the the web api or just let's call it the rest api and then it returns a http response typically in the format of json and then the data is consumed here in the javascript right that is consumed here in the javascript and html is created or updated and sends to the renders to the dome the user sees it so that leads stood blazer so um we have javascript frameworks the friend and frameworks um so we have uh jquery so jquery is probably a library so we have frontend frameworks and frontend libraries like jquery react angular vue.js all of these right so we're asking a question that i react is from facebook and uh angular is from google so then where is microsoft everybody's uh kind of expecting that um but just recently we have been waiting for a long time just recently microsoft came with a new technology that's called blazer and the blader architecture is actually other two actually two kinds of architecture from blazer one is the client side one is the server side and the client side is actually very very similar to the second type of architecture so if i can copy this i can copy this so laser is very very similar to the first architecture so the only thing that is different here is instead of using javascript we're having csharp here it means that we can use csharp on the serverside as well as on the client side that opens a lot of doors for us javascript is nice it's good but then it's actually evolves in a very dangerous speed so let's also talk about the server side so blazer has a hosting model that is blindside as well server side and let's start with the on the browser so we also have the stone here and instead of having the c sharp code basically the service hosting model we pull the c sharp code from the client side to the server side okay so here instead of c sharp we're having blazer it's a javascript file i forgot the name but once we go to the computer i'm going to show you where the file is so we're having the c trap library pulled over to the server side and that's why they call it hosting model so we have the laser the blazer applications can call the service layer and then the service layer can call the repository layer and the repository can work with contacts db contacts if we are using entity framework but how the server side communicate with the client side that's where we have the websocket wrapped around by signing our right so this is dedicated communication channel it means that we are using instead of http request response we're sending messages back and forth and um so this channel is maintained constantly and that's uh this very smart way and this blazer dot js this this this file is used to communicate with the um laser application this rc short code there and the performance is also pretty amazing and this uh so the architecture that we're comparing the architecture between laser clientside and blazer serverside is that if we are with this clientside application actually um we can create microservices uh by creating different web apis or yeah and but server side we can also do that um if we do that then the we cannot call the service layer and posture layer or to context to be contacts directly in the same machine because this is monolithic so we if we're trying to do the monolithic architecture on the server side then we cannot um uh yeah it's not gonna be very efficient and if we want to still support microservices then we have to pull the service layer and postulator outside to a different machine to different hosting environment the request response architecture is stateless the second the frontend frameworks um architecture we maintaining state on the client side but this part is also stateless right the communication part with the backend api and with the laser client side we're maintaining the state also in the client side um and with the server see the problem is that we're maintaining the state on the server so if we are having we're having a lot of users on the client side that means we're going to host a lot of state and that really we're going to host the state on the server side for you know many many times and that's really costing a lot of resources and that's going to be a issue that we need to consider whether or not we are having the service layer hosted somewhere else as apis this is something we need to consider uh in in the next video i'm going to take a deeper look at the architecture the blazer architecture to explain why we can host csharp directly in the browser how microsoft does this and then how it actually works let's take a deeper look at the blazer architecture have a browser here and again i'll draw the dome here and we need to be able to run the code on the browser and how do we do that there is this thing that's called webassembly and if you go to the web apps assembly the website they say that web assembly is a compiler target so then what is a compiler target we have a compiler here there's this compiler source and then there's this compiler target so compiler source is the source language and compiler target is just the target language so compiler is basically when it compiles convert the stress language to the target language so for example csharp after compilation it turns into right it turns into intermediate language and how does an intermediate language runs on us on a computer so if we have a computer here the immediate language is not a machine language that can run directly on this on the computer so what it does is that it has we have a net runtime right and the intermediate language actually runs within the context of dynamic runtime so if we come back to this later topic so websimply is a let's say it's a language that can run directly in the browser and how can that be possible that's because most of the vendors like chrome google chrome microsoft edge internet explorer firefox most of the vendors they agreed on this web assembly standard and most of them most of the products they are able to support this web apps only standard so as long as your code is written in this web assembly language then there's browser supported and there is actually a kind of like natively dress really fast performance is amazing so how can the c sharp run inside the browser the answer is it runs as a web assembly that's not entirely true in terms of how blazer runs on the browser blazer actually does not we do not actually turn the csharp codes into web assembly what it does is that there is this thing that is called mono web assembly and the mono web assembly is a runtime mono web assembly itself is a web web assembly so it runs on the browser so if i draw if i draw another square here and if we call this mono web assembly so this is the um when the server runs so if we have server here and if we have our uh blazer application hosted in the server and when the user sends a http request through the browser the server actually first it pushes the mono web assembly to the browser all right and it it is actually a run time it works like a runtime so after that our blazer applications the blazer framework as well as dotnet standard libraries all of the dependencies of our blazer applications will be downloaded to the server so the next layer would be would be our um done at runtime so oh sorry not the the dyna standard done standard and the next layer so this would be also downloaded and all right so we have our blazer framework here and within the blazer framework our blazer application actually runs here so lastly our replacer app runs here and how does the blazer app actually produces the html as we know that blazer actually uses a componentbased architecture which means our developers actually created a lot of components we create components inside the blazer applications so and we call it the component tree so for example if we have a computer if we have a ui design that looks like this so we have a menu items and then we have we have uh some area that looks like that and within this area we have uh two like kind of like two panels and something is displayed here and then some things will play here and then a picture maybe displayed here then here we actually have a component tree here right so we have our root component which is this one right the biggest one so we have a root component and then we have two components on the second level and then we have in here we have three components right so it's component tree so this component tree constantly changes when user interacts with the use with the interface right so the user clicks somewhere or press keys changes the data so the data would be changing the components would be reloading right sometimes it may switch to a completely different set of components so this component tree is actually being tracked by the blazer application so we would have two so this is the previous component three the previous tree and this is the current tree currently so whenever user makes some changes it generates the current tree and then it compares with the previous tree right so here it makes a comparison between this two uh the previous tree and the current tree and then it creates a div it calculates a component tree div and this component tree def will be sent to the dome and used to update the dom and then the user would be able to see the changes so this is the the client side blazer right this is how it works so to summarize a little bit the blazer application they are actually so all of these are c sharp dlls right c sharp d allows c sharp dll and um and this is mono uh webassembly this is actually a web assembly so this is the client side so the server set let's cover server side here the server side blazer works very similarly just like in our previous video we covered but all these things actually happens on the server side that's why it's called server side so if i try to cover that again here so we have a browser here right and then we have our dom here and in here we have the blazer now i remember the name blades are server dot js and then on the server i have to draw a bigger rectangle here to represent the server so in here of course we're going to have our dotnet if i follow the same way of drawing we're going to have our dotnet framework so we're not limited we can use the fold on our framework here it doesn't have to be using that.net standard we can have our.net framework and then within that you can run our blazer please a framework and within it we have our laser app and then we have our previous tree and current tree and uh so our bridger applications also communicates where's the where uh through the signal error channel right signal our websocket channel so then what happens is that the um the user sends requests and then the message is sent over to the blazer application and the components gets updated the data gets refreshed and the comparison happens here and then this christie ui dev all right so this ui div is sent over to the browser through the blader server dot js file and then gets the actual dom is updated that the user sees the results so that's how blazer works in detail when it comes to the pros obviously pros with the web assembly model is that you fully utilize the clientside resources and all flows the burden of the server right because everything that is needed is already on the clientside browser but the cause of the webassembly hosting model is that because it it downloads everything so the initial load is low and that's those are the main pros and cons of webassembly everything else is pretty minor so i'm not going to mention for the server side the server side there's also pros and cons and obviously the pros of one hosting model is going to be the cost of of the other one and the cost of the one wholesome model will be the pros with the other model right so for the pros of the blazer server the the first one is you have a very fast initial load because everything is actually within the server side and there's there's not much that you you need to uh to be sent to the server right the only thing is this ui difference and it's it's it's very minimum because it's only the difference between the two uh the previous render tree and the current render tree plus this ui difference is in a battery format all right so it's very compact so you you have a fast initial load that's obvious for the first server setup laser and also for developers because everything is hosted on the server side so we can directly call the service layers repository layers without going through apis for example rest api right so all of the concerns related to calling rest apis are you don't have to consider it if you choose to not incorporating the rest apis right so for example you don't have to worry about security concerns you don't have to worry about the api mapping from the json results to objects and all of those things right so you have a much faster development speed so it's good for prototyping so um but what what are the columns of the the server side hosting model because everything is hosted on the server side let's say you're going to have a variable that stores thousands of hundreds of rows of data and that data has to be rendered to the render tree and you have two render trees and because you have you already in the variable you already have thousands of rows okay and then those rows has to be reflected within those two render trees one is for the previous previous version one is for the current version so you actually keep a large amount of data on the server side and that's just for for one user and if you have many users imagine you have used a large amount of memory for for just one user session and you have many users like this right you have like 1 000 users so you gotta do like a thousand times uh three because you have basically three copies of that data one is in the variable one is in the previous render tree and one is in the current render tree and then that amount of memory you use for each for that variable right and if you you have 10 000 records in that variable 10 000 rows and each row takes a lot of a lot of a large amount of data then this is going to be huge amount of data for for all of the users to use and all of that comes from just one server right your server side this one whereas if you use a clientside hosting model then all of this well you're not gonna first of all you're not gonna have this 1000 right you're gonna have three copies you're gonna have a variable but but this is gonna be on the client side it's gonna be within the browser so as long as you have a very good client a slide is not a very thin client then it is going to work but whereas if you do this on the server side it's not going to work so so let's let's list out the pros and cons for each so for the for the client side we have uh what is the pros for the web assembly right so fully utilize the power of the client right and uh what are the cons so the cost is slow initial load because there are so many files to load like this this part so many files uh and then this is this is the web assembly right and the server side the pros fast first initial load and then we have fast development right and what are the cost the burden on the server and last one i forgot to cover is because of the signal r channel here what if the channel the signal signal r gets disconnected right so i think i personally think that if you want to create a small application then the server side is a very good choice and and you also need to be if you were to use the server side blazer to create a midsize or big size application you really need to pay attention to to how you load the data do not load large amount of data always always load the data that you want to display and then use paging or something like that to to get the next screen of data to to the browser do not load everything that will really slow down the process uh and uh for the problem problem with the signal arterial disconnection just always make sure that you save your data often and so when there is a disconnection and you have to do a screen refresh to to reconnect the signal or channel then then you only lose the limited amount of data all right so overall i do think that a better choice is to use the web assembly hosting model instead of the serverside hosting model but um but with very careful design you do you can use the serverside model for for a large project i want to talk about the project structure of both the web assembly blazer as well as the blazer server side so first i want to create a project and it's going to be blazer and i'll call this blob blazer web assembly and i'll choose the web assembly template all right that's pretty simple and uh let's run this right away before so before we go into the uh project structure i wanted to show you guys something else for both the wipe assembly blazer as well as the server side blazer so if i run it let's see it's loading and then we can see the the pages the user interface so what i wanted to show you guys is if i use the developer tool and i go to network tab i have to do a refresh you can see all these things are being downloaded you see the loading it takes a long time and then all these are downloaded so let's take a look at what are actually downloaded so at the beginning we have this blader webassembly.js file that is downloaded and then this file initializes the download of the other things this is the mono web assembly which is the the only web assembly this is the uh the context so all of the other ones run within this context as i've covered in the second video so we can see that we have the blazer framework and we have the net assemblies all the dependencies we have uh also our uh application as well so this because i call it blazer webassembly this is the project this is the project so this is our application dll and our debug information is also downloaded here so that's what i wanted to show you on the clientside map assembly blazer so if i stop this for now okay let's open another video studio instance and create another project which is the blazer server side it's the same process but this time i call it laser server side okay and i choose the server side app all right so again before i go into the structure i want to run the app all right same drill we're going to look at the developer tool uh we'll clear it refresh and this time let's take a look at what's our downloaded so we only have this js file that is downloaded and then we have this and then we have this uh the websocket which is the signalguard signalr channel so we can see that we clear this so each time if i do anything clear again click on this see each time i do anything with the components the channel there is it's being used to pass message back and forth because all of our components and the state of the components are actually being capped on the server side and we're using the signalr channel to send back and forth the message and yeah that's that's also this the thing that i want to cover before we go into the structure so on the left hand side is our web assembly the server client side blazer on the right hand side is our serverside blazer so we can see that they look pretty very very similar and uh and it's all based on asp.net core so the entry point is always the program files and they're pretty similar too i also covered the asp.net lifecycle that includes the configuration as well as the middleware pipeline in one of my other videos so this program actually this program file has a main method this is the entry point of the whole application same as the server side and this basically builds the hosting environment of the web application and the startup files are the actual uh configuration file that we can use to configure the uh the application so let's actually um focus on our client side for now so we have our program files which calls our startup files to configure our applications by default there's nothing in the configure services which handles the dependency injection and there's only this adding one components which is the root components of our application if we look at the this folder it has the www root folder we have index.html file which has the basic html structure and the most important thing the two important thing here one is this app loading thing then this is the the root component and also this blazer web assembly that i have showed you that this this one downloads the all of the dlls and initialize the runtime to start running our application so then when this page gets loaded uh the app component which is root component is being used and the root component set up the router for the clientside routing all right and then it uses the layout file which is under the shared folder the layout file and it provides a layout for our application and the most important part here in the layout file is this body placeholder which is a placeholder of all of the relatable components so the rob rotable components are the component that has the for example here has the page add page directive which tells the blazer framework or toster tells the water that this component is a rotable component and in order to get to the component we can use this rod right we can use this path and when we use this path what's happening is that this component will will be displayed at the place where the add body placeholder is which is inside the main layout so in this add body layout sorry this is main layout we have this add body placeholder and if we go to slash counter this placeholder will be replaced with with with the information here this is the client side structure and if we focus on the server side structure for now it's very very similar the only thing that is different is in this startup file it has more information here it configures the default route here which is our host file this is the entry well that's the entry point is still the program dot cs file but on the front end this page is gets loaded first which has all of the html structure just like the index.html in the client side and we also have this blader server.js js file which kind of handles the signalr communication channel and some other tasks as well and we also have this app component placeholder here that loads our root component right and the root component basically from this point on everything is almost the same if it's not exactly the same so we goes to the main layer we load the main layout so so the app component here also configures the router and then it loads the main layout and the main layout also within the shared folder we have the main layout here and it also has the body placeholder it's the same mechanism that allows the routable component within it so the opposite of wrong component is is unboundable which means that a component that does not have that page does not have this add page directive so those components are basically kind of like controls that can be used in um in components in other components so i also wanted to draw this project structure on whiteboard i think it is going to be more help so we have this program entry point program.cs file entry point um and above that we have the startup startup class um that does the um dependency injection and also middleware pipeline setup and about that we have our either is the host file or the index the html the host file is for the server side blazer and index.html is for the client side and above that we have our root component which set up the the rotting the client side running and last but not least is our our main layout component and within the main layout the most important part is the uh the body placeholder which uh which is the placeholder for all of the other wallable components so we have c1 c2 etc cn and all of these are actually will be eventually loaded into the um the body placeholder one by one and will be displayed to the to the user and of course we also have our unboundable components which will be used within the the rotable components and they also can be used within each other so that's the product structure of the um the both the serverside uh blazer as well as the web assembly blazer and since we have seen that the product structure is very very similar so you can actually switch between the web assembly blazer and server side blazer so if you want to start with the server side blazer because it's production ready and the web assembly blazer is not production ready as of today um april 8 2020 then you can start with the server sub laser and until these the clients have laser come out and then you can easily switch to client step laser if that's what you want to do if that makes sense for for the application and for the business if you want to switch i think the only thing that you um other than changing a few lines of code and configure the program's startup classes a little bit differently the only thing that you need to pay attention is to keep your components very very thin and encapsulate the other logic in in a different layer maybe in the service layer so also i forgot to cover the import dot razer file on this file it has all of the name spaces so it uses using directive to import the namespaces so it has a a lot of these so you don't have to use the using inside each component you can just put it under the inside the imports imports.razer and this will import all of the namespaces for you and then you can use use the classes inside the namespace within the components that you want to use you don't have to use the using in each component so so it keeps the code very clean data binding for blazer so for any software that that has a ui the software needs to do two things the first thing is to display information the second thing is to manipulate the information and we look at the data flow okay for the first one for this display information we have a ui and we have data i'm just using a database symbol to represent data so it flows from the database to the ui okay so this is ui this is ui and this is data and the second one is data manipulation right so we have ui and we have data and data flows into the ui when you do your data manipulation on the ui you always want to save the data back to the data source so from this we know that there are two kinds of ways for data flow one is this one weight and this is second is the two way for data binding this are these are the two ways of data binding we have oneway data binding and twoway data bindings but why do we even need data binding why can we just program without it yes we can we always need a ui we always have a ui regardless whether we have data binding or not we always have a ui and we also have a variable that represents the data right we have a variable and we need a variable to be displayed on the ui right so we load the data from the data source to the variable and we need to need to display the variable on the ui right without data binding we can manually find the element on the ui and set the variable value of the variable into the element so we can manually populate the data onto the element and once we modify we manipulate the data within the element on the screen we can save the data directly back to the data source without even going through the variable right and if we want to load the data we can load the data to the to the variable and then again display directly onto the element so this is one way we can do it but that um you know this is a process we wanted to to avoid so that's why we have this thing that is called data binding right where we actually binds we actually find the the ui element or element to the data so variable actually the variables as if they are one right and there's two two kind of uh two type of data binding with one is oneway data binding will only bind the data to the ui element the other is twoway data binding obviously we not only bind the variable to the element but we also bind the ui elements to the variables so that way whenever we look at the variables they always represents the ui elements on the screen all right so having said all of that let's jump into the computer and look at the uh the codes so i created a server side blazer project and uh this is the index page i in this region under this region i have a view model that is a for a sales person this is the amount um well maybe it's a target amount or something like that and then whether the salesperson is active and under which locations the sales person is uh is active and first of all let's uh initialize the data first of all let's initial data we need to overwrite our initialized method and in here we are going to create a new person new um well yeah yeah that's right indexed view model and then i will have the sales person give it a name and amount locations some default locations all right so i have the data initialized and uh for uh for oneway data binding we can do very simple thing to display the the salesperson's name right so it's as simple as you know doing this it's a add sign and then you just put the variable here so that's why we did a binding right and let's display a few things um name an amount maybe and you can of format the data like this so this is oneway data binding and if you run this code run this code we can see the name alex let's have a line break here then we save it so um so if we use ctrl f5 to run the project instead of just uh just a 5 then you will have this page once you make any changes uh the page will detect the change from the signal signalr channel and then you just do a refresh you will see your changes reflects reflected so i added a a line break which for whatever reason wasn't displayed so i uh i'm trying to add another one yeah now we can see the line brick here and uh we have this formatting here these two are the oneway data binding just to bind the variable the variables to the front end so to implement the twoway data binding we need to use the bind attribute so for example of course if we want to manipulate data right we want to let's say i want to manipulate the amount then we need to bind we need to bind not only from the variable to the to the element to the input element but also we need to bind the element to the variable and for that we can use the bind command the band the bind attribute so we have bind value and what do we want to bind which value do we don't bind we want to bind the amount right we want to do this and then and then here if we do this and we save come over here and refresh the page we'll see the amount here 15 000 okay so we have this 15 000 here and if we make a change okay and we tab out from the text box notice this amount is also is also changed accordingly so if we change this number to 100 and tab out from the text box this number is also changed this means what this means that uh when we're changing this and type out our change event the uh value is passed to the variable and then the variable because the variable is is also bound to this uh this place so this this value is displayed here so this is oneway oneway data binding this is a twoway in the case that we want to so in the case if when i want to uh change the underlining variable while i'm typing directly in the input box in that case i need to add another another vector build which is the bind value event so that that's trying to tell the blazer framework of what event or what happens the value is passed back to the variable and here we want to say on input so while we are inputting into the text box the variables gets updated that's what we're trying to say to the laser framework so once we refresh we can see while we're typing the amount is passed to the underlying variables so here i want to say a little bit more so if you wanted to use bind in this case you have to use bind event all right so if you wanted to use bind value then in this case you have to use bind value otherwise they're going to be exception so um the next i wanted to demonstrate checkbox checkbox is a type equals checkbox and here we want to bind value don't have space so here bind value to percent is active i also wanted to display the person active directly here just so that we can see the changes okay so we have this checkbox but we don't know what it is so we're gonna have a label and and here we say is active give us space here refresh all right so we can see that it's active is false and but when i check it you know it's directly changed to true immediately uncheck false so you can see the twoway data binding for checkbox next one we want to i want to go to i want to go to radio buttons for for radio buttons it will be a little bit different there's no direct uh there's no direct twoway binding for radio buttons we have to kind of you know create our own so the name variable is is is the group indicates the group so in here um we would have you know so we have radio button one and uh radio button two okay so we have this i can see it works like uh exclusive selection it's within one group but we need to add a binding to it for that i wanted to um perhaps just add another variable here i call it selected selected group all right and at the beginning nothing is selected so i changed to zero so we'll put zero here and uh because we don't want to select any checkbox uh when the screen is loaded so we need to bind that value to the radio buttons and to do that we need to use the check checked attribute here we can use the expression here and say that if the selected group equals 1 then we check this and here if the selected group equals two then we select this one all right so so in this case we're not selecting anyone so after a refresher screen i expect to see that the radio buttons are not selected right now selected by default but if i change this to number one and i save and refresh the screen refresh the page i see that i'm expecting number one to be selected which is exactly what happened so next we want to make changes to this radio buttons and we want this change to be reflected in the variable selected group how do we do that so we can use the on click event so in here we can say on click okay and again with assigned and parenthesis here we can add a arrow function we can say that when this event happens we call this selected group function same thing here equals two when i click on number one i want the selected group to change to number one and when i click on number two i want the circuit group to change to number two right and here maybe here i'll display the selected group refresh the screen at the beginning i'm expecting number one being written there yeah and change to number two immediately we see the change perfect so we cover checkbox radio buttons and what else do we need to cover perhaps a drop down list right so the drop down list is simpler simpler than radio buttons radio buttons probably the most difficult one here let's bind to a selected location right so which i don't have a variable here so here we're going to create a selected location variable and we can see that our location has an id and we're going to bind that to id so i'll create a selected location id equals um 0 indicating that we're not binding to anything at the beginning so i have this here and then um that's the select and for options we want to have a for each loop where we you know location in person let's give it better name so i call location under the person locations variable we have we want to create an option element the value is log dot id all right and the here we want to display let's display the city the thought is messy so after that we'll have a list of cities but about the beginning we wanted to be you know empty yeah empty after that it's fine so and we wanted to show i wanted to show the selected location id here okay so let's refresh the screen all right so the beginning select location is zero which is an empty item and i have toronto montreal all right so i'm going to select you can see the id changes which is pretty cool that's basically it for drop down list we're binding to the selected location id and uh the list of locations is kind of a oneway binding to the dropdown list and then another way binding back is to a different variable select the location id and next perhaps we want to do a list right i want to show a list so we would have an ordered list and we're doing basically it's very similar to the down list we want to display the location in persons locations we want to have a list and we want to show the city all right and we want to show the province state and we want to show the country all right so we have that now come over here and refresh yep we have a list so what about a table table will be pretty similar but i'll demonstrate more than that so i have a table and we want to be using the bootstrap and for here we have a list of rows and that we have for each again we use this in dot locations a person.locations and we have we have as many rows as locations and i want to show everything for the table well and if i save it and refresh i've i've lost a table and that's a list of countries in the table but what if we wanted to create a table that it actually updates the underlining data for that what do we do so of course we can change this to an input let's use this a city for example we change to input and then the type is text right and um if we do bind to bind value if we say bind to what i bind to uh location.city let's see what happens if we do this refresh as you can see it's working right and if we want we can change the bind event to oh input and yep so we have it only in here as well pretty cool right so if we change copy all of this to actually uh let's give it a class to be a form control that looks pretty good and let's copy this to replace post this and the country and then we just need to change this to profs state changes to country and all right there we have it so we can change this to some other city right new york and new york usa so you can see that it's updated here also in the drop a drop down list so and if we have a submit button right then once we submit we can handle the submit event and we can look at the locations and we have all of the changes in that variable so this is the beauty of data binding we don't need to manually go into each one of them to grab the data we have the data already when we're handling the click event of a submit button in blazer random programming is component based which is in line with other frontend framework or libraries like angular react vue.js a web page consists many components like header sidebar page component or maybe some reusable components inside the page component and footer as well traditionally websites consist of pages and reusable areas within pages are called controls a name that comes from the desktop application programming realm later simplifies things and use components represents both pages and controls to distinguish the two let's call them page components and then page components so if you create a blazer application the default application that comes from the visual studio templates it looks like this i added a sales component here but if we go through this we have four pages here the home counter fast data and sales the sales one is the one that i added so um we'll go to home page right we can see this highlighted area is a page component counter this highlighted area is also a page component same as this and the sales component that i added so which part is a reusable num page component it is the area that highlighted in blue so let's jump into the computer visual studio and take a look at some demo about page component as well as numpage component so let's add a page component first we can see that a page can there is a page folder already so these components are page components except this uh this entry point file right so to add a page component we'll go to page right click on page footer and we click on click on new adam select reader component and then give it a name remember to make sure that the first letter is capitalized let's call it sales component i always want to append component this word at the end of the the name just to to make sure when you later create classes for example if you want to create sales it does not cause a namespace conflict so so we have sales component all right so we have sales component here because the sales component is a page component so we have to be able to navigate to the sales component so in order to be able to never get to the sales component we use the page directive and actually before we do this we can take a look at the other ones right so fetch data we have the the page directive and slash fascida which means that when we um have the url that that says domain name slash fetch data it will go to this uh fetch data component same as the counter component when you say slash counter it will go to the counter component so when you want to go to our sales component i want to i want the url to be slash sales okay so in this component i will do nothing and then uh let's navig let's make ourselves navigate to the sales component through the manual and let's call this this is the the url this is the routing path right so we have the fetch data sales counter so this basically means when we click on this navigation link it goes to the counter component here when you click on this link go to the fast data component and we can click on sales it goes to the the sales component so if you watched my video about the product structure i've covered uh the project structure there uh if this is a little bit confusing about the navigation link and how all of the files work together you can go back to one of the previous episodes about project structure where i covered that part so here i have added the navigation link here uh and i've added the component it's the sales component and make sure that the uh the routing path is sales right so then in the the body part when we when we input in the url slash sales the body placeholder will display our sales component okay let's give it a try right it's right here so we click on sales sales component right and if we are not sure whether that's our component we can add some thing here okay so this is save else here refresh so we get this this is the sales component so this is our component a page component is also called a writable component which is highlighting the fact that we're able to rot to the component by using the the rotting path here i also want to cover rotting for a page component a page component must be audible meaning that you have to be able to access the page component by following a url right so we already talked about this a little bit uh but i also wanted to point out that you can have multiple one page component you can have multiple uh rot right so if i added this and go to our page and refresh by the way what i did is i did ctrl f5 right so that way after you add it you can do you can refresh your page and then all of the changes will be picked up so we have salesperson and add another route which is salesperson right so we can use both sales and and sales person to go to the same page component however uh it's only a onetomany relationship from page to routes it's not the other way around meaning that if you want to use the same um the same rod in a different page it's going to give you an error for example if i copy the sales person rod and put it under counter inside counter and if i refresh here see it's going to tell me that the following rods are duplicate we have two pages that have the same bots and those two page components are sales component and counter component so the error message is actually very informative and the moment you remove this is going to work again fresh all right so that's working again so i want to just cover a little bit about how the page how the routing works when we put when we use the page directive for each page component and provide a path to the page component we are basically applying a rod attribute to the page class so if you have used if you have created web api or mvc in asp.net or asp.net core you know that you can use a rod attribute for a class you can you can decorate a class with a rod attribute when these components are compiled they are turned into csharp classes and they would basically look something like this right so you would have your whole component the raw facet is root root fast right and you counter with this rod you fast shade it with this rod and the sales component we just created was this rod so when the laser framework is loaded it actually loads all of your component sort of another list right it doesn't create a component yet but it lowers the metadata of these components into a list it knows that you have these components it knows that which component has which rod and then when you are using different urls by inputting them into the broader address bar or you're navigating inside by using the nav link it's going to go through that list and look for a component that has that rot and then it will initialize that component and if it cannot find it see the app component actually says uh router and if it's not found it's going to say sorry there's nothing at this address and if it sees that there are two components that are the same rod it's gonna spit out an error so for a none page component a numpage component the purpose of having a numpage component is to encapsulate some functionalities whether the component is reusable or not right we don't want to write component with thousands of lines of code we want to be able to encapsulate certain functionality within different components so that it's easier to manage and if they are reusable then it's even better so in this case let's create a component that tells us time so to do that i like to call the reusable component controls right but i i just put them into a controls folder although i still call them component and then we're gonna display it right here and we're gonna display in this format okay so we have this and we know the namespace is the the root namespace plus control plus the folders so we want to add that namespace here so we're going to say laser demo dot controls and to use that let's say we want to use that in our newly created sales component to reference to to use the page numpage component we can just declare them as by using html element syntax so we're pretending the the component that we have is a html element and so here and that's all we need to do so i would add a two of them then we go to our share do a refresh all right so we have our daytime here today is may 3rd sunday toronto ontario canada all right so we covered page component we covered none page component uh as you have noticed that our numpage component does not require a page directive right another thing i want to also mention is that you can also use a page component as uh as a reusable numpage component for example i want to show the counter right inside the sales component so what do i do i just declare it here it's very easy i just say counter right that's it and let's go to here and refresh all right so we have so as you can see if i go to counter i see the counter component if we go to sales i also see the counter component and it works okay now let's cover component structure a component has basically two areas one is the the html markup and the other part is the csharp code blocks right you can have more than one of this you can have you know two still works right so you can separate them so this part covers some functionality and this part can cover different functionality you can use this to do it so the html markups obviously it defines the look and view and the c sharp code blocks it contains ui logic so let's take alex i have no logic here uh let's take a look at the counters right so here this place some some dynamic information this is the title so these are all for look and view right and here defines a button and then when the button is clicked we uh we increment the the variable so so when we combine the c sharp code blocks along with the html markup together they dynamically render the component now let's talk about component inheritance so let's say that all of our components have a common property and let's just say that property is called date right because all of our components want to be able to display data so in that case what do we do do we declare a date variable inside all of our components so that would be um code duplications and we don't want that so what we can do is of course yeah we did this part did this way but if we want to use that date uh variable not only for display but also for some other logic process then we have to be able to reference that variable inside each one of the components so how do we do that we don't want to create a variable inside each component we want to be able to inherit it from a base component blader supports inheritance so let's create a base component it's basically a csharp class maybe let's call it the time based component and what do we have here is a basically a property that is a date time and uh let's call it daytime so another thing that we need to make sure that our component needs to be based on need to derive from component base and if i do ctrl dot it will generate that using statement there now let's use this uh base component let's go to our sales component and in here we want this page to derive this page component to to derive from our uh daytime based component which we have to actually do the uh using statement here we can we don't have to do it in the imports.reader we can do it directly in here but because i did it so we can access the class name directly here so we are inheriting from uh we make the sales component inherit from the datetimebase component and let's delete these confusing lines and let's just use the uh let's just display the datetime variable right here right and in order to make sure that we have it i put the date label here all right so as we can see we have this right here well it doesn't have it's uh the value was not initialized so it would be the minimum date time here laser programming is component based as was covered in the previous episode and you would have page components and nonpage components right so for example you would have page one page two page three page and each page may deserve to have sub components and those components are nonpage components for example this page one has two sub components and page two does not have any sub components or none page components and page three is even more complicated and has you know a component tree like this and page a may have something like that so now the interesting happens interesting thing happens so now when we have a complicated structure like this what needs to happen is a communication between these components and the communications between the page components this kind of communications are done by passing rotting parameters rotting parameters and the communications between the parents and child this is done by parameters regular parameters rotting parameters rotting parameters and this is also rotting parameters but these ones are regular parameters all right so this is also and this is also right so these are regular parameters so we have rotting parameters and we have regular parameters and the third type of parameters are cascading valid parameters so in that case uh we have a a deeper tree structure like page three and sometimes we want to pass the value down from the parent from the page component all the way to the leaf right all the way to all of them and we can do that by using the regular parameters right all of that can be done but laser has a better way to do that it's called cascading parameters i'm not sure whether i'm spelling correctly or not so another type of communication is that when the child when the child when the children are trying to tell the parents about something some interesting that happens right for example your child calls you from university about something right and you would have to react to it so that kind of is called event callback that kind of communication so this is event callback right these blue ones are event callbacks and another type of communication is when you want to tell your child about something right when you call your child about something happen something interesting happen and you ask your child to do something and that kind of communication is um is when the parents calls the child this type of thing we reference you know we reference the child component and then we can call a method on that child component directly what you're looking at is a standard visual studio template for blazer serverside application and i added a few components but today we're going to look at the sales component which is empty and the order entry component which is currently also empty in order to see them they're both page components and as you can see i give them different roth and the page the order entry uh component uses the order slash order rot and the sales component uses slash sales block and in order to see them we are going to add the navigation links copy two of them and then this i'm going to call it sales and this we call it order entry and i'm going to change the route to sales and this is going to be order and we if we go back here and refresh we're going to see sales and order entry and what these two represent are the sales represents sales department and the order entry uh represents the order entry depend department both of them are page components so um as you can see if you have many department you might want to consider having this title part as a component by itself right so let's do that let's create a numpage component and as you know i have a habit of calling it controls but you don't have to call it controls and i'm going to create a new component razer component and call it a title component and this is none page component so it doesn't have a rot but what we're gonna put here is we're going to go to the page component and copy one of them uh it's basically this right and we're going to come over here and then we'll say welcome to the and we're going to change this part dynamically right so we're going to give it um we're going to give it a a variable here in order to populate that but it's not just any variable cannot be private a variable because this variable has to be available to the to the parent component so it has to be public in order to allow the parent component to access this variable it has to be a special variable and it has to be a property and it has to be a public property and we call it uh we can call it department right and here we have to use a parameter attribute to let later know that this property department is a public parameter that can be accessed from the consumer which is the parent component right and then we can use this over here or actually over here and we can say department right and then when we use that component in the parent component we can do this as i have shown in the previous episode we can use the child component as actually in order to do that i'm going to import the namespace and then i'm going to come over here and i'm going to type in title component which is right here and as you can see the parameter is right here okay and then in this case it is sales okay i'm gonna copy this code and i'm gonna go over to order energy department and i'm gonna call it order entry this way when we go to our code and hit refresh we're going to have the sales and water entry department represented by our one component our title component and the good thing about that is if you want to change the wording or the style or the theme or whatever um of the title you can change it from one place right so we can go to our title component and um if we want to add for example you want to want to be in the scored we can have this and then we go back refresh as you can see the underscore is right there right if we want to change the font color to actually change change to uh header we wanted to change the fun color to blue dark blue then we can change it to dark blue like this and then we go back and we refresh there we have it changing in one place passing in parameters so to some to sum up in order to pass a parameter from the parent component to the child component we need to create a pro public property and decorate it with parameter attribute and then we use our component child component in the parent by declaration and populate the parameter with the value that you want to use so the rod parameters are used to help us communicate between page components as well as between none page component and page component to demonstrate i created teams component and team component right the teams component the list of teams and the team component is detail of that team and also showing the member of that team and uh in order to display them because currently we don't see it on the menu so in order to display them um i am going to also added the navigation menu uh just like last time but make sure we have proper route when we come to the navigation menu we clean up this a little bit we change this to teams and we change this to teams as once we refresh the page we can go to our teams and we see a list of teams and for now let's take a look at the codes that i have so so i basically have a teams variable here and i initialize the variable and popular hardcoded some values here and i created this uh team class here usually all of these should be created separately as models and dependency injection into the razor components but since i haven't covered dependency injection so i'm hardcoding these over here what my expected behavior is is that when we click on any of these teams we go to the team component the team page component and display the detailed information about that particular team that you clicked on our code here our markups html markups we can see that i used for each loop and created the uh the rows within the tables and it's displaying team and team team region and also i have a anchor element here going to the the team page component so when i click on it it goes to team component unfortunately uh every single one of them got a team one team component is empty right so let's go to our team component over here and uh it has prepopulated some codes but it does nothing as i said that these should be created as models and dependency injection into the razer components but i'm just hard coding it right right now so don't worry too much about them so i want to display the detailed information about the team as well as the members so i have these data here to kind of represent the member database table right so you have a list of members and you know um you know uh the you know the ids of them and you also should have a the team team id right to indicate which team the member belong to so for that i'm going to create a team id property and then i'm going to go over here and populate that property team id equals one and i'm going to let them to become different teams all right so but the thing is how do we pass that uh information about which team we have selected that's where the rod parameters come into the picture so in order to do that so here we can say that basically here we can say slash team and then we give the team dot the id slash all right so that gives the proper rod parameter here so if we go back here we can see that at the bottom left corner you can see each one of them has a team id appended at the url right but the thing is when you click on it it's going to say it's you know there's nothing at this address right so we have to change our team component to accept that parameter and to do that it's actually pretty easy we come over here and we say you know this is i'm not expecting a id parameter uh and then we come over here and we create a corresponding property and we call it id right and within here you can say parameter and uh and this corresponds to the id right and let's see what happens when we do this all right refresh click on it all right so we have received a uh exception and so what is happening let's um take a look at the uh developer tool so it's complaining that unable to set property id on the object of team component the error was unable to cast object type string to integer okay so that is telling us that it's considered as a string but we are expecting an integer so what do we do in that case we set up a constraint here we're saying okay i'm expecting integer right so if another way to do it is that we can change this to integer sorry change this from uh integer to string so let's do that and then we refresh all right so now we're going to team to the team component but we're not loading any data yet at least we're passing that property right we can say you know we can say over here we pass in that id let's display that id refresh the page okay it will properly pass it in the id from uh the teams page to the team page so that's the communication between different pages right so in order to properly properly display the page uh we we can come over here and we can say that you know uh i'm searching through the uh you can use link to query the teams variable that i have it here we can say that if the id equals uh this dot id which is our parameter block parameter then that's the theme that we are looking for right and it gives an error here right because uh this is a string and this by itself is integer right this is integer so it doesn't want to do that so let's change it to integer and then we will add the parameter constraint and we're telling that we're telling blazer that this parameter is an integer right so so now this is fine so we will have our team so once we have our team we come over here and we say that the uh you know the name is team dot dot name intellisense is not great yet it seems that it's a little bit slow so here we can have a region right and let's see whether that works or not so i saved and then i refresh okay let's go to red team so we have right team here properly the parameters properly passed in and our link query is also working okay cool um all right next is that we we're trying to display the members right and we're going to create another place here and then we are going to find our members first which is uh we have it here and we need to find all of the members so the members are from the members i want to find the members who belong to the team so team id equals this dot id which this id again is the parameter value the raw parameter value so then we would have all of the members right so we'll have our members here and then we'll come over here and say for each sorry um actually so here we want to uh display it in the list to save some time instead of displaying a table and here we're going to have for each and we're going to have variable member in the staff members and here we're going to say our i and we're going to say number dot name well um pipeline member dot uh h intellisense what else do we have yeah name and age and that's good and then let's see when we refresh our page so go to our right team we have team name is rad region is region one and john's h is 20 mike's age is 25. going back two teams got a blue team and we have joe 26 ross21 and yellow we have ryan 23 and fox 22. so there we go we have uh parameters passing as raw parameters and going to the different page from parent from teams page to team page and we are successfully load data and display data based on the passing raw parameters let's talk about cascading parameter uh so if we have a component three like this where i have the page component that contains several levels of component so these component these components make the tree a little bit complicated so in this case if we want to pass the parameter value from the first level from the page level down to the leaf if we want to use the regular parameter we have the passive parameters as many times as the number of levels that the component tree has so one way that microsoft has came up with to solve this problem is they created something that is called cascading parameter it's something that you can use to cascade a value from whichever level downward to the lower level components you don't have to cascade one by one okay let's jump to the computer and see how it's implemented all right and this is a standard template blazer template it comes from microsoft and we go to the counter page you can see when we click on it the current column increases so we're going to modify this to mimic a scenario where we have many levels of components we're going to create another two level so all together we have three levels so this is the counter component let's uh create two more components let's create two more components let's call it component one and component 2. and in order to distinguish them i'm going to add some css cell so we're gonna add some margin um to component one and then we're to add another margin to component 2 which will cause some indentation so that we can see the different levels so with this we are instead of displaying the current count inside the counter component we are going to remove this and we are going to display the counter con in the component number two right but before we do that um we are going to add the components in we have component one and then within component one we add component two right so component one contains contaminant two and counter component contains component one right so if we uh refresh our page right so we're gonna see component one component two like this was the margin indicating the different levels of components so uh now i wanna display the uh counter value inside component 2 right how do we do that we need to wrap our components with a cascading value element and we're going to tell that i'm going to tell blazer that this value is called counter and the value itself comes from the current the current count and we wrap this component one with it so current count is here so what happens is that when we click on the button it calls this event handler and it increases the count and this current count is passed into the component tree no matter how deep the tree is how many how many levels the tree has you can access this count value from within the components so let's say you want to access from component two you can actually access it from component one or component two or both right so uh in this video let's directly go to component two and we're trying to display the count here right so let's say i want um tell that the count as the count is is the the corner value right and to do that we need to declare a parameter and that is the same type um and the name can be any name let's call it contour value but the we have to decorate it with this cascading parameter and we call it sorry the talent name of this custom parameter is counter right that's the same name that we give it here right so you can name your cascading parameter with anything but then as long as you declare that the in the attribute part that you make sure that this counter value name is the same with the name that you declared inside the cascading value element all right so now with this setup you would be able to rate this counter value directly from the contour component the parent component uh the ancestor component okay it will contain this value so let's see whether we'll get it to get the correct value so we're gonna display this value right here counter value and then we're going to go back and refresh our page right so now it shows counter value 0 and we need to increase when we increases it goes up okay so we have successfully passed down the counter value so this helps us a lot when we want to pass values around component 3 it's very convenient one of the disadvantages of this is that when you have when you need to pass the values around all of the components in the component tree the blazer framework would have to monitor all of the components you use just one cascading value that you want to cascade then the blazer would have to monitor all of the components if you want to pass the value to all the components for example uh about a theme a theme of your application once you set it it has to be accessed by all the components and the component each one of the components will monitor monitor the change of that uh theme once it changes then each every one of the component will change so this kind of makes the um laser framework have too much to handle right if you have just one variable to cascade it adds a lot of work and then you have two then it has more work that's three then has even more work so by the way let's see how um we want to cascade multiple parameters how do we do that okay so let's do that first and then we'll come back to the drawback to the um to one of the problem was this and how we can fix this and how we can fix this um kind of a performance issue right because when blazer has too much to monitor it takes too much resources and it costs performance issues especially with blazer server side that the uh it monitors each user has its own session and uh it holds the session state and everything so that's um if you give it more work was uh with the cascading's parameters it's gonna create more performance issues so we're gonna go come back in in the film in a minute let's see how we can implement multiple cascading parameters so let's go to counter and uh let's just uh cascade let's say we want to change the the color of that so we would add another level of cascading parameter and we call it you know we call it uh let's say um color and value is i'm going to directly give it a value right here let's say the value is is blue okay and now we can go to our component child component we can just color declare another cascading parameter and making sure that the title matches and here it doesn't matter you just call it color and then we are going to modify the the color right we call it we call this color value here and if we refresh we're expecting the level 2 component i mean component 2 becomes blue refreshing it's not blue and why is that title counter title color oh tito color all right so it's blue all right so we're now we're actually cascading multiple uh levels sorry multiple cascading parameters multiple values so let's go back to the point that i was trying to make about the performance issue so um and this is actually a good example that we are cascading a color to down to the component too right but it's static means that it's not changing like the counter the count value it increases or decreases uh it's static it's fixed so but even though it's fixed because we have we have the clarity that's getting parameter here laser framework will still try to monitor this and and try to see whether this color will change but it's actually not going to change but this is actually a text resource from uh from the laser framework right so it will actually impact the performance so one way we can avoid this is to come over here and say you know uh this is a fixed this is the fixed value so when we go back and refresh it's not gonna affect it it's gonna still work you're gonna not you're gonna you're not gonna see any differences but um but it's gonna avoid the performance impact so this is what you need to do when you need to cascade a fixed parameter for example if you have different departments right you have water department your sales department you have different departments and if each department has its own page component and each page component has its own complicated complicated component tree but inside those inside the two component trees you you want those child components to know about which page component you're in i'm in the order department componentry or i'm in the sales department componentry i want to know the department right so this type of value although it changes when you click on you will never get to the the page component but it will once you are there it never changes so in this case you should use the is fixed equals to 2 to top laser framework that the value of the cascading parameter will never change so this will will not impact the performance will not affect the performance so that's something we need to pay attention to another thing we need to know about is that cascading parameter it can only you can only casting it down you cannot pass the value upward so one way to resolve that issue is to add some event callback or add a delegate parameter basically a regular component parameter that is declared as a delegate and then from the parent we register to the delegate and when you click on the button you trigger that alligator basically you trigger that function inside a parent component and then your parent component react to that handles that delegate and increases the counter increases the variable in the defined in the parent component so that's one way to do it but um if you have many levels you have to pass you have to declare that delegate parameter for many levels up to the top components right and that's uh that's a pretty in my opinion that's not a very good way to do it uh if we go down that rod i would uh suggest to use a uh centralized state management which i'm going to cover in later episodes so that's the other thing i want to the other point that i want to make which is that we cannot pass parameters up the component tree of another thing that we really need to pay attention when we use cascading parameter is that it can quickly become pretty messy right so when you have a when you have a complicated uh component tree like this you can have the cascade you can just declare that consequent parameter cascading value element on any levels and then on any lower levels you can receive that with different names and if you can if you you come over here for example you click on this and you say okay i want to i want to know where does value come from right so you can't right click and go definition because it will not go anywhere right this is defined right here you click on it you know it's it's you can follow it you don't know where it's defined right so when you have many many levels so this is not as many levels as this is not too complicated but when you have many levels um when you have very big trees you don't even know where it's defined right and you have to use search uh in in your ide to find it in your visual studio to find it which is not as pleasant it can quickly become pretty messy so um again in in those cases where you want to uh use um when you have what you find yourself that you declare you find yourself declaring a lot of cascading parameter values cascading parameters that's probably a sign to tell you that you should use a centralized state management system instead of using the cascading map parameters so we should really use the cascading parameters sparingly event callbacks are for communication between parent and child component and it's when the child component has something interesting happens then it basically calls their parents and say hey parent i have something interesting happen please react to it let's take the contour component as example let's run the default application uh go to common components click on click me then it increa increases the value and if we change it a little bit uh so that the counter component because becomes a sub component then we can demonstrate the event callback so let's create another component let's call it a parent component and lab disk parent component to use the same route of course we have to remove this route so we can make the counter component itself becomes a sub component because it becomes a child component of this parent component and we use it like this and if we run this code refresh right here it's basically going to do the same thing except you're going to see a title here it's parent component because now the common component becomes a sub component because becomes a child component and it work the same way but what if we want this current count to be displayed um inside the parent component instead of under the counter component itself uh so for that we can remove this we remove this and then we come over to the parent component and we declare a variable here and we call it private integer count okay so and then go back to counter component and and then here we declare a public property okay and we have to make sure that the it it's the event callback okay and with a parameter and the parameter value is uh parameter type is integer and we call this set current count and this has to be a parameter and then we are going to invoke this set current count under the event handler of the increment count right so basically we're gonna say invoke async and it's current count then we're going to come over here and refresh the screen and then of course we didn't do we didn't hook it up yet but let's try that okay and we are not seeing any exceptions so keep that in mind then we'll come back and talk about that so in order to implement this we need to go back to the parent component and then we're basically come over here and set d parameter the side current count as a basically you can just say second account and then in here we're gonna have this stack current count with integer value and then we are going to say current count equals value and what we're going to do is we're going to display i'm going to display this current count right here current count current count then we're going back over here refresh all right so current column initial is zero neutral value is zero and then we click on it now it works all right so coming back and just to summarize that so first of all you need to do is that you need to create a parameter that has a special return value which is a event callback this type is event callback there's two versions of this this first version is without the generic type the second version is with a generic type depends on whether you want to pass a parameter to it or not so this is basically the parameter type of this set current count right so when you invoke it this current count parameter has to be this type integer type in this case the second step so once you declare the parameter like this then you go to your parent account and then you basically set the parameter just as any other parameters except that this is a function name instead of just a value it corresponds to this you can call it any function it doesn't matter doesn't have to be the same as the parameter name and uh if we refresh the screen you're going to see it's going to work anyways doesn't have to be exactly the same right so those are the two things uh it's two basic things we need to know about it uh and then we just dig a little bit deeper into this event callback so the event callback is not just any parameter it has a special type and this makes us kind of think that it's similar to a delegate in c sharp right but it is very similar uh to delegate but it's not exactly the same as a delegate for example you don't have to when you invoke it you don't have to test whether it's uh empty or not right it's not going to throw an exception if it's empty right we have seen that so let's try that again if we remove this which means that we are not actually providing any registration to that delegate if we call it delegate it's not even a delegate but when we rush this it's not throwing any exceptions right it just doesn't work anymore right so let's put that back so coming back over here so it's not a delegate that you have to check the whether it's registered or not you can just directly invoke it and it's going to work secondly it's different from a delegate because we can actually declare a delegate right now right so we can declare a delegate like this and uh basically we can do the same thing let's simulate this uh with you know set count let's call it sitcom and then over here we can declare this as a parameter as well and then when we go to the parent component we can we can give that delegate assigned to the same function right and then if we remove this and then we'll go to the counter component and instead of calling this we just call setcount dot invoke we're passing the current count right let's see how whether it works or not okay if it works then there's no difference between a delegate and event callback you see there's it doesn't work i'm clicking on the click me button but it doesn't work why because your parent component you're basically triggering this event from a child component and expecting your parent component to truly render right but it doesn't rerender the value is set but it doesn't rerender rerender and the reason is that your component does not render if the event is triggered from from other components learn as you specifically say that you want to rerender it but if we are using a event callback then the whoever whichever function that is connected or assigned to that event callback your parent component is going to watch that and once that function is called it's going to rerender the component but in order to make this work we have to say hey state has changed right because this function is currently assigned to the set count delegate and the second delicate when the set delicate invokes this function is not going to trigger a render and unless we are specifically saying that we know the status changed and go ahead to rerender and now let's see what what happens right so now it works so that's why it's different and another thing that we can try is that if we remove this and see what happens if we remove this and then we click on it immediately with a c and handout exception has occurred see the broader dap tools for details why let's see that bother the browser tools and then at the bottom the console actually let's look at the console here it says no reference why let's go back and take a look at our child component where we invoking the delegate without having the delegate assigned to a actual function right so there's no there's no registration to that delegate so we can just invoke like this but for event callback we're okay we can just call it whether there is a whether there is a registration to this event callback or not all right so going back here and set current count it pulls well if we don't set anything refresh again but it doesn't work but it doesn't cause any problems so that's uh that's the difference sometimes from the parent component we want to directly invoke the methods or properties of the child components outside of the declaration so for example some event happened you want to trigger some other things under the under your child component let's take example uh very quickly let's create a let's create a chart component uh actually it's going to be a control so let's create a folder and call it and chose and then under here let's create a new razer component just call it child component we are going to be displaying the child component under the counter component and let's have a line break here and then let's call it let's call the chalk component right here uh right here well let's that's ugly let's import our name space right here um let's play the three dot controls so then we go back and delete this and we call it child component and now if we refresh the screen we'll see our child component right there and under under here and uh uh what we want to do is that we want to we only want to display the child component when we click on the button all right so uh extra line break and then uh we're gonna have a button and we're gonna have and now we want to when we click on the button we want to display it so uh basically means that we are not going to display whatever markup that we have uh at the beginning so we're going to declare a number here that says it's a boolean and we're going to say and call it display and we are only going to display this if it's true right so we're going to put this right here and then we go back and uh this button would complete that button later so if we refresh then we don't see that we see this empty button here but that's okay so the important thing is that we're not seeing that child component anymore so we want to click on the button and uh to show the the child component and over here we're going to say unclick and what we want to do is we want to display the child component we are going to say here we're going to how do we set the display variable under the child component that's where the uh referencing child components come into place so how to do that is that we do we say reference and we say you know child and then over here we create a attribute and we say child component and child so this name and this they have to be the same and then we can use this to reference the child component so we can inside here right we can say child dot uh something right so what do we do we go to the child component and we create a public method you say show and then just say you know display equals then going back to the counter component and then we say child so when we click that button we reference the child we say show yourself my child okay so go back and refresh now we're gonna see that button this button is using bulma so i do have vomit here and this button is controlled by bulma it's using the bulma class but i haven't referenced the bulma and they're the host you can see that i have this but i don't have bulma right so as soon as i reference boma then it's going to be displayed uh yeah we're gonna take effect refresh again all right that's boma style and i like boma much better so in future demos i'm going to use boma for developing components actually today as well so now you can see that we are not seeing that child component but if i click on it it's going to trigger that child component show method and uh set it to true so the child component is going to show itself okay so the reason why the child component is not showing again we talked about this in the last in the previous episode it's that's because the component will only render itself in four under four different conditions first is when the component is created it's just created secondly is when parameter changes parameter value changes thirdly when there's event uh handlers for example you click on that button and then under that event handler you change the state of the component and that component is gonna gonna rerender itself and force fourthly uh that's when the developer want to rerender the component by calling the state has changed method so because we didn't call the status change method and because we are calling the show method from outside of the component or within the component right uh if you had a button right in the child component and then you triggered a show method and then you change the property you change the state of the child component then the child component will will be rerendered but in this case we have to specifically as a developer we have to specifically call the status change and then it will render itself so let's refresh you see when i click on it shall component shows right so go back uh every time we we never get to a component it recreated it's recreated so now you don't see the child component but when i click on it now it's jokes all right so let's have even um a better example let's let's create a dialogue with with boma style and then we we kind of toggle it right so let's go to bulma and uh let's go to yeah bowman model dialog and let's go to model and what i want is this model card and it looks like this and it's pretty clean and uh in order to show the model dialog you can see that in order to so to activate the model just add this active modifier to the model container right so we're going to copy this and then we are going to create another component we're going to call it gonna call it uh dialog component right and then over here we're gonna remove this and have this over here we're gonna actually add this is active active right there and but we are not gonna change the class what we're gonna do is we're gonna have again the same same sort of thing i'm gonna have this and uh uh we're gonna initialize it was false and and get over here and say hey if you display is true then then we display otherwise we are not going to display anything right so go over to counter and remove child component we are going to say uh we are going to reference we are going to add the dialogue component right here and we want to reference the dialog component by using the name dialog and over here we're going to say dialog component dialogue and we're going to trigger this right here but it doesn't have the show method yet let's go to our dialog and create a short method public void show this display it goes to and we can also have our close method right over here and call us display false and another thing is that here's a button you see this button it's a close uh it's a close button and we also need to make sure that we close this as well and we're going to call on click right and again we're going to have our uh i'm going to call this and we're going to say close i'm going to call the close method that we just created and and we know that this is not going to work because we have to say state has changed all right and we get over here and call this as well now we go to the counter component we refresh it um actually we should change the name to show dialog go to counter and we change the name to show dialog and come back refresh again and then click on it we see the dialog right well it's not doing anything but we click on this button yes it closed so going back to dialog component and get over here and we also call this um uh let's just to make it simple we just call closed like this right and of course on these event handlers we should actually do more than just closing but for today's demo we just only call the close my third and that's everything we do for today let's go back and refresh the screen all right so we have this and these buttons work as well as well as the close button this is the documentation from microsoft regarding the templated component and there are three key factors within a templated component the first one is render fragment right this type of parameter the second one is a parameter that is a generic type list and the third one is a render fragment with a generic type with the same generic type so the three of them they don't need to exist in the templated component in order to make it work so today i'm going to only talk about the render fragment and then future videos are going to cover the other two this is the visual studio server side template from visual studio it's just nothing new and let's build it and run it and as you can see it's just the default template of laser server side and let's uh talk about what is the purpose of having a templated com in my opinion template component gives the developers the ability to provide some sort of template to the component itself and the component also provides some sort of layout right so this is more on the ui side the functionality is mostly on the consumer side right so the consumer of the component which is the parent of the component are going to provide more functionality and the components of provides more layout right so let's take a example that uses the render fragment right so uh the render frame fragment itself is uh a it's used as a as a type of a parameter right and this parameter is basically a when when you use it it's going to be a wrapper of some html let's have an example so that it's easier to explain to it's easier to explain so let's take a look look at boma right so for beaumont to have this field what it needs to do is to have this this much him up so if i copy this and paste it over to our let's create a component actually let's just use it on the counter actually use it on the index right and delete this survey control and paste it over here we need our boma css which is not in here so i'm going to copy this over to laser four and then we're going to go to our host and copy this and that's it all right so we have our obama in here and this is going to work i believe all right so let's go to this uh blazer 4 and refresh uh it's the home control right so you see this right but if we go back and we look at this well yeah so this is it looks pretty good right looks pretty neat the style is whatever what we like but then what's what's gonna happen when you have many views on the form so you you have to sorry you have to kind of copy paste and this whole thing right so suppose we have name is over here so we have name uh we have title and we have department right so for only three fields we're coming the lines of html from line number nine to line number 44 so it's it's getting crowded with just three filled right so what what can we do to make this uh the number of lines of uh html shorter more compact so we can actually make a component by utilizing the render fragment right so let's let's do that let's create a component and i want to create controls folder and create a component under the control folder so let's go over here and go to component and then let's call this build component right so and then what we need is this let's copy and paste it over here and see how we can make it easier so we need to provide a name of the label right so that means we need a parameter and a public property with a string type and that's um let's call that label name or let's just call it label okay and uh we also need input to be somehow in there but this input it cannot be inside the field component because it may not be just an input control it can be maybe a radio button right so you don't know the type it's better to be provided from outside and here is why we need to use a render fragment right so we can take this out and then we create a special parameter we call it uh we call it uh so it's going to be also a property and this has to be render fragment okay and today we are not going to cover the one with the generic type um so and here it's going to be called let's call it control okay and what we can do here is is that we render this render fragment right over here right when we do this laser framework we'll recognize that this control is a render fragment therefore it's going to render the html that the consumer or the parent control provides to the child control okay so with this right what we can do instead of having uh these number lines of code we can have it way shorter oops sorry uh we can go over here and we can use our field actually let's import that namespace so that you can see it get over here and then if we enter again you can see we have that and then we provide a label and we call a name right we do the three fields and then uh what we can do here is is supposed to be okay so it's the intellisense is not working very well so here we have this right and control inside here we can have this input right and placeholder and then we copy this three times and this is gonna be title right title and this is the part right and look we completed the three fields with only about a little more than 10 lines of html okay so let's delete all of these we don't need them anymore and let's go back oh all right so we forgot to change oh we forgot to add the type label here so uh let's label all right going back refresh okay cool so we have this all right so we just learned how to use the render fragment by creating a filled component right and this field component can be used everywhere else whenever you want to create a field and let's just summarize what we need to do in order to use the render fragment so that the developer can provide a template for your component to use right so it's actually pretty easy you create a component right and you create a special parameter that the the type of the parameter is render fragment and then use this in the html markup place where you want to render that template and then when you use it as a child component from a parent component you just declare it as html and then use that render fragment parameter as a html instead of use it as a parameter like label you use it as html right and then within that wrapper with the render fragment provide you actual html then blazer is going to render this html inside here to replace the render for recommended parameter i want to cover the second key factor of the templated component which is the generic typed list of items the purpose of this items is to provide a list of items for the generic type render fragment to use but is that the only purpose can it be used for any other purposes today we're going to talk about using the generic typed items by itself uh we're going to learn that by creating a automatic rendered grid let's call it auto grid the way i do it is that i'm not going to have the render fragment i'm only going to have this items and then i'm going to use reflection to create a automatically generated grade okay let's jump into the all right so let's create a control uh component let's call it grade automatic automatic grid all right so we don't need the title first we need a parameter let's create this type param right this is the type of the this is the generic generic type of this this list right and this we would call it items so instead of uh using the render fragment with those items we can use this item by itself so how do we do that right so we need to use reflection in c sharp we need to see all of the properties of this item itself before the component is rendered and there is a event in the event lifecycle that is called on parameter set and that function that method is called when the parameters are set and before the components rendered so let's override event if the items is not now and items can't is greater than zero then this is the place where we use reflection okay type of item is a reflection to analyze what kind of parameters what kind of properties the item has right and the type of the type has a members method which is gonna give us some information about our all right so this member info we need to include we need to use the uh system.reflection name space roof and okay so now we have this we've got the member info and we can do this all right so this member info has um the information about of all of the members gloating like constructors methods properties and other stuff right so and then we can use this to uh in our markup so in our markup we want to render we want to render a table right so the grid is like a table right so um this is like we only render the table if the member information has inform has value uh like this and we're gonna render a table and we're gonna call it um uh i'm gonna use the table class and let's first render the header right and uh it's gonna have a list of columns and that list of columns corresponds to the 2d properties we're going to loop through the list of numbers right you know this member has a member type property and this in indicates whether it's a constructor or it's a property or it's a method so we will only create a column for the members that are properties so if if number dot number type equals remember type stock see we have property field method unless it's type and all this stuff constructor event so uh we will only render if it's property right and then in this case we render number dot name and we're going to use it in our index the home page here we need to create some data to it all right so i have prepared some data so we have this first we declare a class it can be any class and then um i'm going to override the uninitialized event circle and weather and in here we're going to initialize that actually we're gonna have a uh list right and then in here we're gonna create a list of employees let's just call it employees okay initialize this list employees so we have this list of employees and we want to provide this to the great component okay because we already have this items in others parameter inside the grid component so now we are going to call the grid auto component and we know that there is a parameter that is items and we are going to provide employees list to it and let's see when we run it what it looks like okay so we see this id name title department right and uh now we go back to our grid component and complete the rest of the markup so in the in the body we're gonna get the value of of each each property right so in here we are gonna say you know uh for each item in stock items okay so it's gonna have as many rows as the number of items um so we're going to create a row under here and then we're going to loop through the basically the same thing we're going to loop through the properties and then we got the value of each property right so in here instead of th it's going to be td and we are going to call item.type got property and then which property is this property providing the name of that property and then there is a uh there is another gap value and um so it's for this item uh oh so and i believe this is it and let's go back and refresh all right so we have our automatic uh grid so this is great but i don't want to show the id right i don't want to show certain columns so what do i do okay so we can create some create another property here parameter here and let's call it let's call it you know columns to exclude and it's going to be a csv and how do we use this so if this contains so i guess it's going to be in here and then i'm going to say that if it's a property and if the name uh sorry no it's not it's the other way around and if the columns contains if it doesn't contain and it's going to be case insensitive and negation so if it doesn't contain the columns to exclude then we're going to render it right so the same logic would be also applied to here right and going back to our place then we can provide that extra parameter that columns to exclude and and call it id right and in this case i think it's going to work let's refresh all right so we don't have the id column and if we don't want the name column uh well that's probably not a good idea let's see we don't want the department column we can add the department column and then we refresh you notice the department column is going to be gone all right cool and i like the department column so let's put it back another thing is that uh we are using boma right and for bulma table it has different kinds of uh classes to modify the uh the appearance so let's do a search bulma table and go to boma and you can see that it has different modifiers right so it's bordered is striped so how do we giving the developer the ability to add these modifiers so that's an easy job we go to here and actually we're going to have another parameter and let's call it it's going to be string type and let's call it css plus right and we are going to come over here and i'm going to modify this to dynamically create the classes here so um so css plus actually let's use this uh it's going to be a table right so that's the basic thing and then we are going to have a desktop okay okay it's gonna be like this and css plus if we don't provide anything uh i hope it's still work all right so we're not providing anything it still works so let's make it uh strapped let's go over here and then we add another let's call it cs class and we add the is strap over here and see whether that works refresh the screen again right so as the uh the modifiers to it all right what else we can add we can add is bordered right it's narrow uh it's horrible that's this is interesting let's add this and you know add this over here and go back and refresh cool see i'm hovering my mouse over the rose and it's highlighting it we have learned one of the purpose of having the generic typed uh list of items right we can use reflection to create a grade automatically and uh if yeah i think you can i would i would see myself use this kind of grade uh pretty often uh in those cases that i don't care about providing some specific control over the look and feel of each column and if you care about that then in my next video we're going to create a another grade that is not automatic and allows the developer to provide a template for each column if you just need to simply display the list of information in a grade like this so you can basically have this automatic generated great component and use it in a lot of different places you can even provide another parameter for the developer to use to provide the list of names of the columns because sometimes you don't want to use the variable name um yeah so that's uh that's it for today that we learned how to one of the ways to use the generic typed list items by creating a automatic generated grid the most common usage of this is to use this templated component as a repeater and there's actually another way to use it i'm going to cover both ways and let's start with the repeater concept so let's imagine you have a list of customers you want to render this list of camera customers repeatedly following a custom template and if we try to write a kind of element out it may look like this so you want to feed the customers to the repeater component like this and then within this you want to repeatedly render each customer and you want to provide a template for each customer and that template can look in your own way so let's say you want the customers company name first and then with the indentation you want the customer contact name and after that you want to see the customers phone number and obviously this is a template and this template is going to be repeatedly rendered as many times as the number of the customers in the list so um laser templated component provide us a convenient way to do this and let's jump into video studio and look at how we would render this kind of how we would create this kind of component in laser so i have a so this project i just created it's uh a web assembly project it would be very similar to create the same thing in bleeder server side but this time let's try web assembly let's create a new folder let's call it controls as url i like to call components controls the none page component controls and let's create a component and just call it repeater first the generic type to temporary components it needs to have a parameter that holds the data so let's create a parameter first to host the data and that data is of a generic type and it's a list right so it is a generic type and let's and let's call this t item and that we call it items and this you see it's giving an error because we need to actually say typo parameter is t item and this will make the error go away it's a generic type meaning that you can pass in whatever type you want so generic in csharp is actually a convenient way to use type as a parameter so we want to render the items one by one so we need to do a loop okay so we'll say item in the items and here we want to render the template that the user provided so we need to provide a template parameter so create a parameter again and then here is a render fragment but it's not this render fragment without the the type so it has to be this one was the generic type and it's what's the generic type t item that we used just now and then here we give it a name so let's call this the the row right because we are rendering the one by one as we're running rows of of uh of something so here we can say sorry at row but we can't just do this it's not going to render the item we have to use it sort of like a function and we provide the item here we feed the item here we're telling the uh the row template that this is the item that we're dealing with right now and then at the moment we use it let's say i want to use it here we are going to import the namespace first controls so once we have it uh we go into the index component and let's delete this add some line bricks and then here we're going to use the repeater component and notice that it has a items parameter here but we are going to create uh some data here so i have prepared something let's so we have the customer here and then let's initialize it from uh from the i initialized let's override the initialize method and then so now we have a list of customers and we populated the values of the customers and we can provide the items here so then we need to provide the row template so when we go over here we can say row and uh like we just did and in here we wanted to use customer company name customer contact name custom phone number and the way to do it is to say hey we are in the context of the current customer right so we give it a contact name and then here we are going to implement exactly the same thing as as we planned we want to have the company name and then some indentations and with the contact name and phone number like this but we want an indentation and uh we are using the default template comes with bootstrap css so we can add the left margin so it's margin left is let's add five make a little bit bigger so that it's noticeable and um yeah so we have phone number contact name phone number company and that's i believe that's what we planned and let's build this project the the web assembly you have to build it i don't see a way to just refresh as in server side later so let's refresh and then let's go here and you see the companies are sorry the customers are rendered like we planned and let's give it a little bit uh clearer uh formatting so let's have a line break between each customer and let's highlight the name of the company so that we can see a better format and you see if i just refresh it would not pick up the changes and if i build it it will so this is the difference one of the differences between uh blader side server side blazer and uh clientside blazer so now i pick up all of the changes that i have this is the the first weight is the main way to use a generic type the templated component and usually a repeater also comes with a header and a footer right and uh i would implement that as well so that we would have a render fragment without the generic type and we'll call it header and i would have another one here let me call the footer and if you want to put something as a header or footer you can use it and in our case let's use the header today um and in the header i just want to let's say we just give it a title this h2 and let's say this is customers and render this right over here you see because we are giving the user the control of the template so we don't want to add a div anything around this header or in between because that will interfere with the user's control so now i have the customer right here and have all of this and if you want we can add some margin over here as well but in this case i'm going to skip that so the second way using the uh generic type parameter is uh it's actually it's actually pretty interesting that if you look at the documentation from microsoft right here it only talks about a way how to use it as a repeater right you basically repeatedly render the item in the item list but there is a way to to render a form use it by using the generic type parameter uh today i'm going to show how to uh use that to create a kind of an added form template to edit each one of these uh customer and to do that let's create another parameter and that parameter is a t item you see this becomes interesting because the documentation doesn't mention anything if you use the t item it has to be a list right but we are going to come to this interesting part of it by declaring a parameter without a list so we have a t item here and then we're going to say an item to edit so this is the item for editing only and then we're going to provide another render fragment that that we can use this item to add it um that is going to be a render fragment it was a generic type and yes it is the same generic type so and let's call this edit template and you can usually we display a edit form in a uh in a dialog like a model dialog but in this case i'm just going to display right under the uh the feature because we have a footer i forgot a runner and filter so let's display a right and there we'll have a line break so display this form right under here so we're going to say edit template right but then again because it's a generic type you have to use it as a method and so what are we going to provide here so we have to declare we sorry we already declared this so i'm going to provide this as a parameter here so basically we tell them later that we are rendering this we are rendering this um edit template sorry this this render fragment right over here and the data we're gonna use is the item to edit right and then when we use it basically we have to provide this item to edit with the item that we want to edit in our case of the customer that we want to add it so to do that we want to change our temp to provide a um an edit button and that will go under the first step and we're going to provide we're going to write a space here and then button and uh since we're using we are using uh we'll just call it a button we're using the stripe so using the strip class and then um and then we call it edit okay and the event handler of editing we are going to say add we're going to say edit with a parameter and that i'm going to say add it um and what edit the um add in the customer right because we have the contacts here so we are editing this current customer right um let's just call it a customer and then we're gonna we're gonna create this method right here private so this is the customer we over here we have to pass this customer to the repeaters added to item to add edit so in order to do that we have to reference our component so we create a reference right here it's a reference and we just call it repeater simple and clear and declare that right over here as well repeater and this is our customer we're going with this customer right so provide this and repeater and we call the repeater right over here we say when we add it we want the item to edit um to be the current customer we are trying to add it and then i believe we're going to see an error here yes why because it says component parameter should not be set outside its component right so what we have to do is we have to remove this attribute right so um we are having this over here and we are having this over here we don't want to display the template unless we uh we're trying to add it right we're in the addin mode so we have just have a logic here we're going to say this dot item to edit only when it's not now do we do we display this added template plate implemented edit template like this and uh we are going to display we're going to have let's say name i'll make it simple and i just use an input whereas a class so it's bootstrap is form control okay and uh we're going to bind it to uh yeah we're going to specify a context right here so the context is the current customer and then i'm going to call it the current call the current customer and then specify the property to bind to and uh and come over here and make sure this is assigned correctly and then we build it and let's refresh all right so let's click on first customer yep this time we see the um company name so so uh in the future one of the future videos i'm going to talk about lifecycle and uh here we are seeing that we are actually triggering the event from um the parent component and usually um it and also we notice that this item to edit was defined was defined not as a parameter so usually changing the public property that is not a parameter outside of the component will not actually trigger a rerender but in this case it did and the reason being is that one of the reasons one of the ways to trigger a rerender of a component is is a event right handling event although this event is handled outside of that component right the repeater component but because you see this advantage triggered right here right right over here on click event and this button this button also is it's defined outside of the repeater component but because it's provided as a template so that is considered that is actually rendered by the repeater component and so any event handling for this button is also um considered as a um like its own event handling that's the repeater components on event handling therefore when you uh trigger this event it automatically render the repeater component so i'm going to talk about more about that um about the lifecycle in future reviews so yeah so let's let's take a look at this and uh we have a form and if we have a dialog then we can display this in a dialog and any changes uh is actually applied right there right so we can change the name you can change a phone number right there and you know and and it actually works and then you can you can click on different things so the company and everything changes and if you come back you see the changes actually retained so yeah this is very interesting way to use the template component if you're more creative then you can actually take advantage of this very well so the second way using the generic type parameter is is actually it's actually pretty interesting that if you look at the documentation from microsoft right here it only talks about the way how to use it as a repeater right you basically repeatedly render the item in the item list but there is a way to to render a form use it by using the generic type parameter uh today i'm going to show how to uh use that to create a kind of added form template to edit each one of these uh customer and to do that let's create another parameter and that parameter is a t item you see this becomes interesting because the documentation doesn't mention anything if you use the t item it has to be a list right but we are going to come to this interesting part of it by declaring a parameter without a list so we have a t item here and then we're going to say item to edit so this is the item for editing only and then we're going to provide another render fragment that that we can use this item to add it um that is going to be a render fragment with a generic type and yes it is the same generic type um so and uh let's call this added template and um you can usually we display a edit form in a uh in a dialog like a model dialog but in this case i'm just going to display right under the uh the feature because we have a footer i forgot a runner and filter so let's display right and we'll have a line break so display this form right under here so we're going to say edit template right but then again because it's a generic type you have to use it as a method and so what are we going to provide here so we have to declare we sorry we already declared this so i'm going to provide this as a parameter here so basically we tell them later that we are rendering this we are rendering this edit template sorry this this render fragment right over here and the data we're going to use is the item to edit right and then when we use it basically we have to provide this item to edit with the item that we want to edit in our case the customer that we want to add it so to do that we want to change our template to provide a um an edit button and that will go under the first step and we're going to provide we're going to write a space here and then button and since we're using we are using or we'll just call it a button we're using the stripe so using the strip class and then um and then we call it edit okay and the event handler of editing we are going to say add we're going to say edit with a parameter all right and that i'm going to say add it um and then what edit the um add in the customer right because we have the contacts here so we are editing this current customer right um let's just call it a customer and then we're gonna we're gonna create this method right here private void and then we're editing what we're adding a customer so this is the customer we over here we have to pass this customer to the repeaters added to item to add edit so in order to do that we have to reference our component so we create a reference right here as a reference and we just call it repeater simple and clear and um declare that right over here as well repeater and this is our customer we don't know this customer right so provide this and repeater and we call the repeater right over here we say when we add it we want the item to edit to be the current customer we are trying to add it and then i believe we're going to see an error here yes why because it says component parameter should not be set outside its component right so what we have to do is we have to remove this attribute right so um we are having this over here and we are having this over here we don't want to display the template unless we uh we're trying to add it right we're in the edit mode so we have just have a logic here we're going to say let's start item to edit only when it's not now do we do we display this added template plate implemented edit template like this and uh we are going to display and we're going to have let's say okay and uh we're going to bind it to uh yeah i'm going to specify a context right here so the context is the current customer and then i'm going to call it the current call the current customer and then specify the property to bind to and and come over here and make sure this is assigned correctly and then we build it and let's refresh all right so let's click on first customer yep this time we see the um company name so so uh in the future one of the future videos i'm going to talk about lifecycle and uh here we are seeing that we are actually triggering the event from um the parent component and usually um it and also we noticed that this item to edit was defined was defined not as a parameter so usually changing the public property that is not a parameter outside of the component will not actually trigger a rerender but in this case it did and the reason being is that one of the reasons one of the ways to trigger a rerender of a component is is a event right handling event although this event is handled outside of that component right the repeater component but because you see this advantage trigger right here right right over here on click event and this button this button also is it's defined outside of the repeater component but because it's provided as a template so that is considered that is actually rendered by the repeater component and so any event handling for this button is also um considered as a um like its own event handling that's the repeater components on event handling therefore when you trigger this event it automatically render the repeater component so we're going to talk about more about that about the lifecycle in future reviews so yeah so let's let's take a look at this and uh we have a form and if we have a dialog then we can display this in a dialog and any changes uh is actually applied right there right so you can change the name can change a phone number right there and you know and uh and it actually works and then you can you can click on different things that's company and everything changes and if you come back you see the changes actually retained so yeah this is very interesting way to use the template component if you're more creative then you can actually take advantage of this very well blazer components are stateful component and if we don't have a good understanding of the components lifecycle as developers of our mind can be confused and we don't know where to put the logic that we want to implement today i want to cover one of the core concept of component lifecycle which is uh you know when do a components render components actually render under four conditions components render when components are just created or when components events are triggered or when components parameter values are changed or when developers manually trigger the rendering of the components so let's cover uh them one by one first one is when components are just created all right so so let's uh let's take a look at video studio so this is uh this is the project that i just created with uh with blazer web assembly and uh let's see the first one is uh the components renders when it's just created right so it's this one is easy right the reason uh it's obvious that when a component is created you want to render the component otherwise like what's the what's it's a ui component right so it needs to be displayed so but when um when is component actually created right so the components are created when you uh just load the component for the first time or when you navigate away and it'll get back right or you try to refresh the page and the components are recreated so let's um let's see whether that's uh those three things that i said it's true or not so let's uh let's take a look at the counter component okay um let's see if we override after render method and if we run this so we pressed alt shift d and so this is this is page as we see right and we're using chrome so we just copy this all right ctrl c and then we we use uh windows r see it's writing right here so windows r and paste that in and then click on ok so we'll open another browser so this is actually the browser that we need to use to in order to debug so from here we do ctrl shift d again and this is the window that is launched so from here we can actually set breakpoint so go to the files folder and then we can see all of the even the program files right so we can go to our counter component and see whether this is rendered um but debugging this is pretty tricky so if we just uh refresh this counter page you can see that uh the it's the trick the the breakpoint is not actually triggered so yeah it doesn't actually trigger the breakpoint for the first time when the components just created so in order to debug go to our code and then we can just write console dot red line and this is uh this is very similar to console.log in javascript and then we save it and we we build it so once we build it we come back to this uh developer tool and we go over here refresh it and come back to the developer tool if we look at the file uh the file is actually changed as you can see let's refresh again and then we go to the console and you can see that on counter component on developer render is rendered at this time so now we know that the when the component is just created the component is rendered right because this event is wrongly triggered after it renders so this kind of proves that the event is just uh it's just rendered another possibility is that if we never get away okay and we never never get back then see the breakpoint is also triggered and uh it's first render is true meaning that it's just rendered uh it's just created therefore it's rendered right so those three conditions first one is when you just come to the page second one is when you refresh the page third one is when you navigate away from the component or from the page and come back to that page that contains a component then the components are created therefore it's rendered the second one is the component renders when the components events are triggered so for example in this counter component some people think that this current count only when the current account changes do the components actually does the component rerender but that's not actually true so let's actually comment out this line and then rebuild the application and once that's done let's go back to here and uh let's refresh the page right once we refresh the page we can actually go to the source code and we can see that the counter component actually doesn't have that see this is the color component so this is already common out right so this line will not actually run at all so what we can do here is that if we click on it see these uh i'll render after render event is also triggered so this proves that as long as there is an event that is triggered then the component is rerendered right and you can see that this parameter is false meaning that this is not the first time this is not the components just created this component already created and we clicked on a button and that button does nothing but the component is still rerendered so that's the first point i want to um i want to emphasize here the second point is that the when events are triggered that's true but it's not every single type of event it has to be uh it has to be a ui event like clicking a button change your drop down list that sort of thing has to be a ui event so let's do a demonstration uh that what if we are increasing the account the counter count by a timer right so if we come to the application and we if we add a timer here so basically we create a timer that runs every two seconds right 2000 millisecond and then it triggers the increment count function to increment the current card value and let's run it and see what happens so let's refresh the page so it picks up that and uh you can see that the current card is not actually increasing but if we go to the page here we go to the console we can see that the counter value is being actually being increased every two seconds right but this event is not a ui event therefore it's not rendering the rerendering the component even though the variables value is actually being changed and if we click on it you can see it's 18. why it's 18 because it's 18 right here right it's 18 right here that's when it rendered because we clicked on that and that's a ui event that's why it has this so that's that one as long as not a ui event it cannot for example if if you have an event in a child component or in a parent component and you're implementing um a matter that uh registered to that event and when the event is fired uh from the parent of the child components and and you you have a function within this component to be called and uh even when there's values there's variables that are being changed and that even when that variable is actually being used on the ui your component will not be rendered rerendered just because not a ui event right so similar to the timer event so another point i want to emphasize when the component ui events are triggered uh the components rerender that's usually the case but that ui event has to happen within the component right it cannot happen outside the component and hype outside the component that's um it's not going to be rendered so for example if you have a parent component the parent component has a button and if you click a button click on that button in the parent component the child component will not be rerendered right and if you have a child component that has a button you click on that button the parent component cannot be rendered will not be rendered and we can do a demonstration but let's let's stop this timer so i want to create a component right here okay we can see the component is rendered and if you go to the other developer tool you can see that the conjugate component render and the child component also rendered the child component rendered after the the color component render after the parent component render but if we come over here and click on the click me button and we go over here you can see the counter component is rendered again right but it's not actually triggering a rerendering of the child component the child component is not being rendered so if i'm going to click on this a few more times right i can see it's all about the counter component the child component is not rendered right and uh the same thing will happen again if we try if you try it if you put a button under the compo under the child component and uh you're gonna see that the child component renders let's actually do that let's go to the con the child component and let's put a button right here and let's have a method all right and we refresh and we come to the window clean it up click on click me you will see the child component actually rendered i also click on a few times three more times you can see so the important thing to notice here is that you although the event handler here is not doing anything you have to have a event handler in order for the component to rerender right although it doesn't do anything and also another thing you notice that they the uh rendering is only the component the child component renders the parent component actually does not render right so and uh but there's only one exception so this this is the point that i want to emphasize that the event has to uh trigger from inside the component only when the event that is triggered inside the component that's that same component gets rerendered so um but there's only one exception when you use a templated component right so let's say that we have a template so i have covered the templated components a couple of videos couple of episodes ago so if you are not familiar with template components please go back and and look at my previous videos and refresh we see this click body template and let's clear the uh console and we click on the body template i click on once and we see that the color component that's render and child component also gets rendered right so if i click on two more times one two go here you can see that both counter component and child component gets rendered get rendered so why is that uh well the reason is that the the body template is kind of special that when you have buttons uh or html elements within the uh body template or template within a template it's also considered part of the child component right it's considered so this button is considered part of this component so when you click on the button it's as if you're clicking a button within that child component right it's actually part of that it's actually within it but because the fact that it is also part of the it's also defined right in the parent component so that's why the parent component is also rendered okay okay so that's the second uh bigger topic here you know the components rerender when the components events are triggered so i covered uh the three important thing i want to emphasize again so events uh we don't need variables to be changed as long as you have an event handler for event even the event handler you do nothing about it the components also gets rerendered right the second important point is that the ui it has to be the event has to be a ui event any other events like a timer time defense or a uh event delegate you register to a to event delegate within some other components and that the events get triggered within this component this component will not be rerendered when the event happens the third thing that i wanted to emphasize is that the event has to be triggered from outside sorry from inside the component not outside the component except for one case that if you have templated components then that template the but the the event happens within the template triggers both the parent and the child component so okay so now let's uh move on to the third thing which is the uh component parameter values changed but this this is a simple one uh if we go over here and uh we got a component and if we create another parameter and that parameter would be the counter if we just display the contour value right here so let's encounter and from the parent component if we feed that counter value right here with the current account then every time you um every time you click on the uh the button every time you click on this button the click need button um your child component also gets gets rerendered right so without so let's delete everything that is distracting and we don't need this either i don't need the template component we don't have this and uh we don't need this rebuild it so uh here if i click on it you can see that the color value does not change so weird because we are not passing it and and uh if i click on it again you can see that the only thing that changes because we render is the component which is the parent component but if we can go to here go to the parent component and if we pass that parameter right over here to be the current account and if we build this we refresh the page and well we click on it we can see that all of them suppose both the parent component and the child components get rerendered every time we click on it right so you can see both are rerendered so that's the third and the fourth condition is when developers manually trigger the rendering so again if we remove this and if we just come over here and even we remove this and if um from here if we reference the child component let's say child and then over here say private component um child all right so this is that component and uh if we just uh every time we do this we say child that will contour current account if we do this let's see what happens so basically we are increasing the counter value of this property right it's not a parameter but we're not expecting that this value would change so you can see that it's not changing right although the value is gets uh increased the only reason why it's not changing is because the child components not render rendering that's because none of our four conditions are right we're not doing any of these so the child components is not being rerendered um so in order to rerun it we have to as developer we can manually trigger that rewriter we can have a public uh method callery render this stage refresh and we call it we call it and then when we come over here we can call child dot refresh and that will trigger the rerendering of the cal component and let's go over here refresh the page to pay to pick up the change and let's do this you can see that both the counter component and the component and the child component pick up the change and if we go over here we can see that the uh we can see both are rerendering okay so that's everything i uh want to cover today remember there are only four conditions that the components get rerendered first is that when components are created first second one is when components events are triggered third one is when components parameter values are changed third one is when developers manually trigger the rerendering so i'm going to cover the sequence of each one of the lifecycle event in terms of in what sequence they are being triggered so i'm going to cover both the serverside laser as well as the webassembly blazer i'm going to divide this into two categories the first one is the first time rendering right and the second one is after the first time so the first time rendering is when the page is just loaded or when you navigate to the component to this page component let's first cover the first category with server side laser so i have server type laser default template i have all of the events written down and i break break points same with the shot component i have all of the events i have the breakpoints for each one of them and i have the child component used by the parent component so i'm going to run debug and let's pay attention to uh in which sequence these events are triggered again this is a server side blazer right so the set parameter is async in the parent component it's trigger first and then i'm going to hit continue and on initialized second on parameter third and when i press continue again now i'm expected to go to the child component instead of carrying off so i have five and the side parameter is async in the child components ahead and secondly the initialize the trigger and the child component followed by our parameter set so if i press continue again it's actually not going to go to the shoot render or after render same with in the parent component these two events are not triggered so let's go over here this is where our breakpoint is currently at so i'm going to hit continue again now we're jumping back to the parent component and again the same parameters async is rendered and our initialize and then so i'll initialize and then press continue again on parameter set and then actually when i when i come when i click on continue it's going to jump over here again and then on the slide and then practice that so why are they rendered uh twice these three events are rendered twice that's because if you look at the diagram we look at the diagram we have the browser and we have the server side the first request sent by the user and then the first rendering is so this is ser again this is server side blazer okay server server type the browser sends requests first and then renders for the first time including the the javascript for server type laser and that's javascript establish a signal r connection and then server set renders the component again that's why i render twice that's why those three events are called twice right so after this watch what happens if i continue from here so i jump back to the parent component and cause the um on after render skipping they should render because this is the first time and it has to render it doesn't make any sense to allow the developer to to control whether to render the component or not it has to render the component and then i continue jumping to the uh child component calling the on after render event handler again and if i continue now the page is rendered uh i when i first asked that the the double rendering only happens when the application when the component is loaded for the very first time so if you never get away from the component and then navigate back because the signal r channel is already established so those three events that are called twice will not be cut twice again so let's demonstrate that so let me so let me refresh the page okay so we notice that we're on the parent component three events child component these three events going back to the first parent page these three events and secondly on the child component so we notice so far these three events are called twice both the parent component and the child component that's because i refresh the page by refreshing the page the signal arc connection is reestablished that's why these three events are being called twice and then we're going to the on after render on parent page parent component and uh unlock to render our child component right so if i'm not doing that if i never get away from the uh from the home component from the index component navigate back to the index component watch what happens now okay these three events and then truck component these three events happen again but then those three events are not going to be called a cut twice so we're actually moving on to unlock surrender from the parent component and then i'll have to render for the shot component okay let's summarize so the one sequence that we are experiencing in server type later in the first category which is the first time rendering is that the these three events are being called uh one by one in the parent component and then the same set of events are being called in the same sequence in the child component and then after that the same thing happens again right for the parent and for the child and only after that the parent component after and there is called and child component after ender is called seeing this any initialization code that you put inside these three methods uh on server type laser is gonna be called twice so when you're initializing your data you have to really pay attention to where you put unilateral initialization there is a on after render async with a parameter that indicates whether it's the first time or not so for server type laser i recommend that you use that to initialize your data in the on after render depends on whether you are going to use that data to render on the screen or not if yes then you need to call this state exchange method to rerender the page again now let's look at the same thing in laser web assembly because it does not actually trigger the breakpoint uh so you can either debug it through the browser uh which i have demonstrated in the uh previous episodes so today i'm going to actually use console.write that is similar to the console.log in javascript so you can just do this and then expect to see expect to see the the log is written in the console window in the developer tool so i'm just going to do that all right let's go to blazer let's go to developer tool and we can see that uh it's actually the same sequence right parent component called this three uh three events trial components again this is three events and then parent components called unlock to render child component calls unlock to render the only difference is that the only difference is that the parent component these three methods are only caught once because this is web assembly thus the second rendering is no longer needed because there's no signalr channel that is this is that is established now let's moving on to the second category which means rerendering right and from the previous episode that we know there are four different cases that would trigger a real render let's use a button i have a button here and i have invite handler here so this is server type later so i have a breakpoint up right here and let's run it and see what happens if i click on the click me button here the first event that is called is actually the event handler of this button right and then after that so we are on the parent page the button is only on the parent page current component so click on the continue button we're calling the shoot render and then if i click on it again we're calling on the i'll unlock to render and notice that we're still on the parent component and you see that the child component rerendering is not called if you watched my previous episode that you know the reason why the child component is not rerendered right so those none of those four conditions satisfy so the child component are not going to be rerendered whereas for the second category which is the rerender category uh this let's summarize that it actually looks like this right so first you have your parent component and if there's no condition for the child component to render what you're going to see is something like this right you have your parent component shoot render and then your parent component after render and if there's parameter change or any other condition that triggered the render of the truck component what you're going to see is something like this you're going to have your parent component should render and then these three events and then parent component after enter and then child component afterwards something that is interesting i want to uh point out is the true should render okay so let's do a let's change this to return false now let's see what happens so i'm going to click on the queen button and then the event handler of the buttons are called first going to shoot render and then you see that the count is now changed and so that means the child component is not rerendered and the parent components are actually not rerendered we did not go normal over here didn't see the breakpoint of this render and it's called so it wasn't rather so for the the second category which is a great render scenario uh the server side and the the up later like the web something blazer are exactly the same so i'm not actually going to run the demo again i want to go over a pitfall in data initialization in blazer components so i have a parent component which is index component and an employee detail component right here right the parent component is using the employee detail component to display the details of the employee and the employee is initialized or loaded in the parent component and i'm hardcoding the employee here to mimic the situation that we're loading this con this employee and each employee actually has a bunch of records to be loaded uh once we go into the employee detail component this employee is the records of the employee is loaded so we look at this code we have uninitialized here in the child component and also all initialized here in the parent component and we run this there's going to be no problem right so let's demonstrate that as you can see the homepage just loaded was the employee detail there's no problem nothing is wrong with this but it actually has a potential issue what if this employee is loaded slowly there's some kind of network slowness or a lot of data needs to be loaded so let's use the sleep method to mimic that scenario so let's go back and refresh the page okay still no problem when we never get away and then we get back uh it takes five seconds right four five right so five five seconds to load it but there's no problem okay but but the potential problem is that sometimes you you have to load these in asynchronous version of the initialization or in some other lifecycle events right so instead of using the um the synchronous version you may have to use the asynchronous version so let's demonstrate that so instead of using this if i use this kind of code here right and then if we use this asynchronous version here as well then let's refresh the page all right there's no problem if we never get back still no problem right that's because this is actually called first right and then they all initialize methods in the child component called secondly afterwards so what if we add that sleep uh thread back right so what if we have a method like this in our parent component we're using we're using awaytask.1 to mimic a asynchronous call and then we use the sleep five for five seconds to make a long running process here and let's refresh the page and see what happens in this case right so it's throwing suction complaining about the object references now which happens in this place the employee is now when the low records is being called so that's through the exception how should we deal with this kind of situation right i would suggest that that we first uh we need to call we always check whether the object that we're trying to do with is null or not now we need to do the null check now reference check and then also instead of using our initialize we should use i suggest that we use onprem intercept because it's always called when parameters change and then inside here we have to check the reference as well because we don't want to load the records over and over again right whenever there is a change unless that's something that you intend to do so in this case we will see that if we refresh the page then it's going to be fine except that it takes five seconds one two three four five right let me get away and then we go back two three four five traditionally we're using this regular forms for user to input data and if we look at the contents of this we have a formal element and then we have input field and then a submit button so when user clicks on the submit button the forms will be posted back to the backend to this location but application written with blader is a single page application which means only the first page load goes through the http request and response pipeline the subsequent actions will not be posed back to the back end in order to still perform forum submissions microsoft came up with a set of components to perform the task so instead of using regular forms in blazer we should use the edit form component instead of using the regular input we should use input text input number input date input select etc don't worry about the error here i'll fix this error later when the submit button is clicked event handler specified which is valid form submitted and if you want to handle invalid form submitted so then you would do on invalid form submitted and connect it to a function right so here's two things we need to know first we need to use a added form instead of a regular form and then we use input first differently another thing we need to know is in order to handle the submission we specify the method the next thing we need to know is that the edit form has to be bound to a model i declared a lot of class here person and then i slide the person right here and then in other form there is a parameter that is called modem and i provide that person model instance to this model and next i need to use bind value to the data binding and i'm associating each properties inside the person class to the input elements the next thing we need to know is validations in order to validate the model we can use data annotations we need to first use that name space and then we can annotate the properties which the annotation attributes like required string lengths max lens range we can specify the data type like email address etc in order to trigger the validation and display the validation messages at the top we need to use the data animation validator component and also we need to put validation summary here and that's all we need to do for a basic validation scenario okay so let's run this form and see what happens right so if i don't do anything i click on submit button it will give me the required error messages if i put 1 here and click on this it would give me the range error message and emails is also still required if i put abc dot abc so let's put this then it will directly say that email address is invalid so if i provide a correct email address format then this becomes green and if i give it a correct number then all everything is green okay and the submission will trigger the uh um will trigger the unviolent summat event and this event handler will be triggered okay so that's the basic of validation uh i just wanted to before i finish this episode i wanted to mention a couple of things notice that this v is a capital v so usually when you use a data binding outside of added form you would use a lowercase v and if you keep using the lowercase v you will encounter very weird errors so remember to use capital b here another thing is that if you put buttons here like this the button's default type is going to be a submit button okay so if you put buttons here expecting it behaving like a regular button it's not going to happen it's going to work like a submit button so if you want extra buttons to work just like a button then you have to specify it as a button first i will quickly go over what dependency injection is so it will have two modules or two classes one is higher the other is lower and higher one depends on the lower class for example the customer service class needs to use the functionality of the customer data access class right in order to get data from database then we say that customer service has a dependency upon customer and data access in order for the higher module to use the functionality of the lower model you know we have different ways to do it right the first obvious way is to have an instance of this customer class right over here right and then we'll just call it customer da right and then in our constructor say custom da equals new customer that access you know with a problem with the connection stream from somewhere right and then you can use it to for example get a customer get customers right and then here we can just say customer return customer dot got customers and that's actually you'll have a numeral right so we get a list of customers like this so this is uh one way to make the uh to make use of the functionality of the our module but as you can see that the customer services uh is uh tightly coupled with customer data access it is aware of the definition of this class and there are many different problem problems with this for example if you want to have different teams work on higher level optic one team work on higher level module the other team work on lower level module because this um tight coupling it's very it's very difficult to work in parallel right and also if we were to change this the name of this class then you have to go to change uh all of the codes over here right you got to change you're going to change this you're going to change this so uh and you you need to recompile the higher modules in order to do that change right so the maintainability is is not good right and later and if we want to uh so if this dead access layer is going against a file system right and later you want to create another class all right that's going against uh going as a database right single database for example like this right then you would have you would have to go inside and change to change the code right so that's extendability is also not good so there's many different uh this is a disadvantage of doing this kind of tight coupling so there's this uh dependency inversion principle which says higher level modules should not be dependent on the lower level models both should be dependent on abstraction so what is the abstraction abstraction is because the dependency there is the dependency between the service class and the data access class right so that dependence cannot be removed instead what we need to do is to abstract that dependency and that dependency is the functionality right so dependency is the functionality and we need to abstract that functionality and in c sharp the way to access uh to abstract that functionality is to use interface so we can create an interface like this and then we can say i customer data access and in there we can just say you know all we want to do is to have a is to get a list of customers this is the abstraction right so basically it just says i have a way to get customers then whoever implements this interface we'll have to implement notice that this method doesn't have a body right it doesn't have an implementation so whoever actually implements this interface okay they need to they need to have this uh this thing implemented so right here we need to implement this in the concrete class right i'm not going to implement anything i'm just going to do this right so uh in this way we are not actually using the concrete class here we're just doing this and that um takes the dependency away but again it's still having the same problem we're actually creating this instance of this concrete class right here means that the higher level object is still aware of the lower level object so how do we do that we have to take this responsibility away from from the customer service and this responsibility is is the instantiation responsibility and we need to take that away and this is called inversion of control right but don't worry about that and how do we do that we need to um create it from outside right the simplest way is just to you know just to create it from outside like this the a let's use a different variable name right and again you can just do it this way and then um when this class is instantiated or we can just uh just do it like this then we're going to say da because da and that's it right so our private instance has this and then when from outside we can when we instantiate this class then then we can just say you know pass this into it so that's these are the main two steps first we need to use the abstraction which is the interface in c sharp right secondly instead of directly instantiating the concrete implementation of the interface we use constructor and then pass that instance from outside into here so this is the dependency injection in csharp and it's the same concept in every other languages of course there are different ways to do it this is through this instructor you can also create a property of that and then just just say if we were to create a property instead of doing like this we can just say have our constructor stay right here and then we can just say you public i so in that case we don't need this all right we can say i customer data access and then we can say your customer data data access equals uh well let's use this name because it is set so this is the property in c sharp and then when you use it like this you can just say instead of doing like this you can just screen this and then from here cust service and then you can say custom data access close data access and then and then you can use it in other methods so that's dependency injection in general and then next let's go into video studio and see how dependency really works in blazer components let's see how dependency is injected into laser components first let's look at servers app laser let's create a class let's call it customer service this customer service will have a public method that returns a customer and for that let's first create a customer class as well and that's it let's keep it simple and in here we will return the customer will say get customer by id and the parameter is an integer which is the id okay so create a constructor and this constructor let's initialize a list of customers and then in here okay so we have this service and uh we want to inject it into blazer components and let's inject into the index component which is a page component that has a routing path here right let's delete this survey prompt and let's display let's use this in our gold okay so one way to do it is to declare a customer service and then we'll just say customer service equals new customer service okay so this is not this is this has this dependency problem that is that that is making the index component tightly coupled with the customer service class but that's not we that's not what we want to do right so we have learned what dependency injection really is the two main steps first is that we need to use interface so that our index component is dependent on interface so we need to do is to create an interface okay give it an interface because i customer service right um there's only one behavior right here which is getting the customer buy id right so we copy that and paste it over here and that's it that's the uh once again must declare a body oh okay yep so this is abstraction so it doesn't need a body and then go over here we just use our customer service right so we have already implemented the abstraction and uh the second step is to inject right so first we need to register into the container which blazer is based on asp.net core and asp.net core there's uh to in order to register the services classes service classes into the container we can use configure services okay so we can we can register right here but there are actually three different lifetime scopes right um there's singleton there's scoped and there's also transit okay so first let's examine transient giving the pair of the interface as well as the implementation all right and then when we ask for it we go to our component where we want to use the customer service and we just say right inject customer service right and then right over here um we can just uh we can just declare a private customer customer this is our model class so it's okay to be dependent on our model class right so and then in the override let's overwrite all right i just just want to set a breakpoint just so that i can show you when this component is disposed okay so i'm going to debug so if i move away you can see when i move away it actually just poses right when we move back it creates again we move away it is poses and it will move back it grades okay and if you pay attention to these numbers right seven six seven when i move away let's remove the breakpoints and move back number changed from seven seven six seven to one b7 right you can see every time i do this the number changes and the reason every time i move away you can see the disposed method and never get away from the index component you can see the disposed method that's called because the index component corresponds to this home page right so uh this dispo dispose method gets called which means that every time i move move away this component is actually destroyed right and when i come back this component is created whenever it's created this dependency injection injects the method sorry injects the class to our component then we can use it here right so this is and every time it changes and this is the behavioral transit transit says that i register a service to a container and every time i ask for an instance the container will create a new instance of that class and inject that into our component right into where we want to use it so that's what we call transit and if we want to see what scope means let's actually see what singleton is first all right so let's change this singleton and this time i'm actually going to use control f5 to debug it also so that i can run it without debugging actually i'm not debugging it all right so you can see that we have this number here and if i move away and move back you see the number does not change so that's singleton singleton means there's only one single instance of the object the custom survey object in the container throughout the lifetime of the this application right even when you refresh which actually resets the connection you can see the number does not change and that's the behavior of singleton singleton there's only one instance and if we want to look at how sculpt means how scope works let's change this to scoped all right and then let's come over here refresh this screen because we used control five so this hot reload works so let's refresh it and see the number change right and then but if we never get away and never get back you can see the number still the same it doesn't change so it seems like it's a single 10 but it's not so if i refresh which uh by refreshing this it disconnects the connection and reestablish the signalr connection right because this is a blazer serverside so so then the connection is broken and reestablished so you can see this time the number changed after i've refreshed and that tells us that the scoped lifetime configuration makes the service live as long as the connection okay so as soon as as long as the connection does not get disconnected you will always have one instance you have to choose the the best suitable lifetime configuration for your services class right because some of them you want to use trends and some of them you want to use scoped for better performance or for whatever reason and sometimes you want to use singleton right for example you don't if you want to use some classes to contain some data and try to use uh try to implement state management that way and you don't want to use singleton because that way you are sharing the data across all of the users even users from different browser sessions from different part of the world are going to see the same data unless that's your purpose so for state management that's very specific to particular user you can use scoped and that's that's related to that one particular connection which cannot be shared between different browsers right but for very light services you want to probably use transient right for uh services that is not threat safe which means concurrency doesn't work for example the db context from entity framework you don't want to use singleton you don't want to use scope even for transient it's created every single time it may still have problems so you really want to consider the different services and different scenarios so this is blazer server side so next let's look at laser laser web assembly we're going to have another instance of register 2019 and then we'll click on placer app this time we don't see that startup file that's uh this is webassembly so it doesn't actually have it and you can see that they are registered right here so we can do a similar thing and we can say builder dot services dot app transit so we're gonna say customer service okay so we don't have this namespace as well so we have our customer eye customer service providers to it so basically we're just saying that uh for this interface this class implements the interface and then we ask for instance of this interface uh the container the builtin container is actually going to create an instance for us by instantiating this customer service right and what we want to do here is uh same thing we're going to do do it within here where we will inject our customer service over here then we are adding this we're actually going to copy this code from uh right over here here we register trending all right so let's run it ctrl 5 again so we have this running and you can see the number is ce2d and when we move away number change go away number changed again if we refresh number change all right refresh again never change it again all right so uh so this is trended right so basically it's the same thing as later server side where every time the component's class is substantiated a new instance is substantiated and injected into the component okay so that's that one and then singleton actually basically works the same way okay which is also you know every time you ask for it you're gonna have the same instance all right so refreshing downloading that again so you can see that it's c97 and if i move away move back c97 when i refresh see that this works differently now the refresh actually changes uh changes changes the number see every time i refresh i get a different number so i explain this a little bit uh later but we just take a look at the scope and i build again and then come over here and refresh downloading the whole thing nine four nine when the movie move back is the same right it's the same number but when i refresh it also changes so it looks like the singleton and the scope are working exactly the same way right only trending works differently and the reason for that this because this is web assembly so the whole server set code is actually downloaded all of the dlls are downloaded to the client side in the inside the browser and inside there we have this um webassembly context and all of them are actually hosted within that context right so which basically means that's program this console application here this console application here is actually running uh inside the browser that's why when every time you refresh it it creates a new instance of this program right because this program is the cost application is basically destroyed and then this it's recreated and the main method is run again and that's why you see the even with singleton it's it gets different number different ids every time you refresh the browser right and the scoped because there's no connection and there's no requests so a blazer webassembly doesn't actually have a scoped uh lifetime management configuration it's if your scope is gonna work the same way as singleton all right so that's um everything i want to cover for today uh there's a one last piece about uh dependence injection blazer which is uh which is about uh configuring owning components and that one is probably not so you don't use it so often so i'm not going to cover in this video you can go ahead and read the documentation the components in blazer are stateful and with stateful components on the front end you will very soon run into problems with uh state management and that's why uh they're different architectures from managing this state and one of them is flux from facebook today we're going to look at what flux is and how we can implement it in c sharp and using in our laser components all right so let's get started so with a component whether it's a laser component or angular or ugs or react it does not matter what's the component uh there's always gonna be a view right and then you know the user will interact with the view and then uh that interaction triggers some events and events are handled events are handled and then handling the events will mutate the state and then when the state is mutated the view is updated so you're in this in this triangle but the problem is if we only have one component a very simple project and we're maintaining the state in components themselves within components themselves that's not a problem but once you start writing more complicated code um doing more complicated projects you may run into situations where you have to share the state within different components that's where we need to extract that com state outside of the component put it somewhere else in what we call a state store and it's more look like this so we have a state store where the state is stored and then we have different components okay and will be the same kind of triangle right because the the user will interact with the views it will trigger some events events are high note and mutate the state right and then the view is notified and updated but in this case it's slightly slightly different in style when the status muted file is mutated uh the notification is not only sent to one component it will be sent to multiple components in this case you can see that notification is sent to this component one as well as component two so the same thing will happen if the user interacts with component two then events are handled and state unified and then notification sent to both components and update both right so this is all good and this is uh this is actually what we call a observer pattern okay so observer pattern you have you have subject and then you have observers right so the subject in this case is going to be our store stick store and the observers in this case are our components the observers actually listen to this to the subject of interest to the store and then as soon as there's anything changed in the subject the observers will get notified it's more like a you know push notification um on your cell phone cell phone apps and whenever there's a change you receive a push notification right but you have a choice to to react to it so this is all good and works pretty well but when your project get more complicated you will run into situations where one user interaction was the component we'll need to mutate space in multiple stores that's where the dispatcher comes into play right for example you you're building this messenger app you have you have a whole bunch of friends on your left right and then you have your uh user you have your user component so this is going to be your friend's component on the left your user component on the top and then your message components in the middle but what's happening here is that what if i log out right so i log out and that that message has to be sent to most components right so you would have a user store here and then a fret store here and then your message store here three different state stores but when you want to log out right that message is to be sent to to both of these stores actually all of the stores right so you would want to sent to all of these stores so that's when we need a dispatcher right that's when the dispatcher come into play so dispatcher works like this so same workflow the user interacts with the view to view trigger some events events are handled and some actions are dispatched are sent to the dispatcher dispatcher is is going to dispatch the actions to different stores right and then the stores will mutate the states and the states will update the component again right update the view if you compare this with the original store with only one store this is nothing more than a two level observer pattern so you would have your store as a subject and your components as observers the second level of observer pattern is your store as observers and your dispatcher has subject stores observes dispatcher as well and you may notice that there are actions being passed around those are messages right and the reason why we need is because a dispatcher dispatches all kinds of different messages and we need to distinguish the differences between the messages right because they may maybe for different purposes so that's why we have this action message object here being passed around another thing to notice that these actions are like messages right and these actions when the dispatcher dispatches the actions to all the stores that are registered to the dispatcher the stores can make decisions to ignore it or not just like you can ignore your post your push notifications on your cell phone so to simplify this architecture the flux architecture flow actually looks like this where the user interacts with component the component send a notification action to the dispatcher the dispatcher dispatches the action to the store the store handles the action and mutate the state and and then send a notification to notify the component that the state has changed then the view is updated so normally the facebook team presents the flux architecture flow like this and i think the reason why they put action here is that they actually put methods within action instead of using it as a pure model as a pure message and that's confuses me a lot so i i change it so that the action is only working as a message and so when i implement it i implement as a pure model so let's jump into video studio and try to implement it first let's create a blazer app doesn't matter doesn't matter which one we should create let's use player server app all right so we have this later server app created and if we run this ctrl f5 we see the default default blader app has this contour we're going to change this counter page to use a a store instead of a local state so if you look at the counter page right now the counter component it has a it has a local state right and this local state is referenced in here in the markup here and uh the increment the click click me button calls this increment method to increment the count and then it's displayed here so what if we want this display not only in this place what what if we want to display the counts not only in this um in this place but we also want to display right here right so we need the state to be centralized somewhere and that's when we want to introduce the store so we have we may have multiple stores so let's create a store folder let's call it stores so that you know it may have multiple stores and uh let's create a another folder do we need another folder yeah because we may have different actions right so let's create a counter store folder and for now let's just create a class and let's call it calendar store and that counter store it needs to have a state okay so let's implement a class that represents that state let's call it counter state and then in here we just need a variable that has a integer type right so uh so we want to so we would want to have integer type count and i don't want it to have a setter so let's initialize this in a constructor instructor right that's it so we have this that only has a scatter so that our state is immutable which is which is better than mutable this is we're actually using that in the central place and in our store we'll have to use the counter state right so we'll um use our encounter state like this well let's just call it state doesn't matter what state it is so our counter state here and then we'll expose a gas state method all right so we'll get the counter state expose this method so we return this state and here comes the um the observer pattern we have to implement that you know we have we have to have a listener so i'm going to put this kind of you know code right here right underneath here so we'll have a private member which is a listener right listeners right we have this action that kind of like an event handler but we use action so that it doesn't have actual parameters uh so i have this private action listeners and then i need to implement a ad like register the listeners right so we're actually you know we call it a state change listener right because it's listening to the store for stick change okay so let's call it this way and we're adding the listener and uh what we do is that we just say listener then we have another method for removing the listener and that's when we do this um and then whenever it started to change in this state our store will block us that change okay so we need a method to broadcast that change we come over here yeah so instead of using this local state into dependency in jack the connor store right so if we go to our startup class computer services and just add scoped okay so because we don't want to share the state with all of the users scoped is scope to the connection right so we can have our store uh connoisseur it's called corner store right here we're not implementing interface just yet so adding this one instance associated with that connection so as long as the connection is not broken it will be the same instance of this kind of store and that's good enough so in here we just say inject counter store oh let's actually import this so we don't want to see right there so i've got namespace imported and then just leave this so we'll have this counter store on the store so this corner store um right here so we can delete this and then you can go over here and say current store dot state dot gas state dot count right and then uh our kind of store will also also so let's actually use a region here because this is boilerplate code i want to see it all the time so this is listeners well actually let's call it observer pattern observer okay so let's close this and we're going to implement increment okay and then increment the count and then we'll create another current state all right because it's uh immutable so i had to create a new one and then we'll call broadcast we call broadcast change the same thing will be same kind of implementation for decrement um and then all the differences right here okay so then um increment count here we'll say you know on her store dot increment this broadcast thing i wanted to be now i wanted to be proud so uh increment and then we have to register our component to listen to the store right so for that we'll override initializer just automatically formatting things in a weird way so over here we would say we're going to store counter store dot register um add stay change listeners and you know we would just add an inline arrow function um i just say you know whenever there's a change i want to call this stage changed in the third right so we have an increment and then we station that's it i'm not going to implement the i dispose interface and to dispose that so just because i'm doing this for demonstration purpose and because we want to also display that in the menu so go to the shared folder to find the menu navigation menu where there is a counter right so in here we also want to inject and we all let's copy over this code from here so i'm going to the manual and okay so we have this and so we'll listen to the change right so we register this and we add a listener so that the nap menu component will become another observer to observe the state changing the counter store and right over here we'll add a colon and then we'll say under store.gastate.com okay and let's go ahead and look at our page refresh our page no reference okay so the problem is right here we forgot to initialize the state and to do that we will come over here and say okay the constructor and then we'll say state counter state and zero right so the initial value is zero and then control five all right so we have our counter number displayed right here and here and if i click on it it increases both places right so our observer pattern works so that's the first step what if we want to do some change and in fact multiple stores that's when we want to use dispatcher right so we don't have to use this pattern um in simpler situations like this you know it's it's okay to just use the store observer pattern right there right but if we do want to use the dispatcher then we can implement the dispatcher we have implemented the conor store with the observer pattern and that works pretty well and next i'm going to implement the dispatcher so that we have the two two level observer pattern to implement flux the flax architecture is nothing but just two level of observer pattern okay i've implemented the at the first level which is this one okay and i'm going to implement the second level of the observer pattern all right let's jump into video studio and work on implementation of this pack last time i have implemented this contour store which contains a counter state this conor store allow the components to mutate the states in two different ways one one is increment the count the other one is decrement account okay so there's two methods that corresponds to that and also it allows the counters allows the components to register and the register from the store right so basically listen to this store or remove the listener right so add listener and remove listener and uh if we go to our counter component this is from the initialize method we are adding the listeners right and then we're using the magazine injection inject the comma store into our component and we're using counter store gas state dot com to display the code and from our navigation menu navigation manual we're also dependency injected kind of store and display in that store and when we we are incrementing decrement we can see the color change uh and changes in two different places one is on the navigation menu right here the other one is in the counter component right and that works very well so today i'm going to continue implementing the dispatcher okay so let's go back to our store and before i continue to implement the dispatcher i want to point out one thing sorry let's go to our counter component i want to point one thing before i continue working on the dispatcher which is this uh ad listener i have to remove state change listeners there but i didn't use it and um and in my previous video i said this is i said that this is a demo so i'm not going to implement that but i want to emphasize that this is very very important because the connor store is a dependency independence injected into our components and connor store is added as a scope right uh a scope which is scoped to the connection right this is blazer this is a serverside laser so a scope is a scope to the connection so if you don't refresh your page the kind of store what will live as long as the connection so unless you click on the refresh button then that's you know this is recreated so that means that because we registered to the counter store essentially we make the component has the same lifespan as the store which is a scope right as long as the connection so when you navigate away later's framework's supposed to dispose it but it cannot dispose it because the store holds a reference to the component so it cannot dispose it and when you when you come back to the counter component it will recreate and create another instance of this so because it cannot dispose it when you never get away and never get back and never get away but it will create multiple instances with the same component right it will never uh release that will never cl recollect that so this is a memory leak that we have to do with so in order to do that i want to emphasize that that we have to do with that and the way to do that is we need to implement the i disposable interface and then inside of our code block we need to implement the dispose method where we have to say your counter store remove remove what so instead of using the inline arrow function so if we use private void update do right and in here we're going to call this state change okay and then instead of doing this we just just put update view here and when we remove we also remove the view so so this is it this when the component is disposed this dispose method will be called and then it will deregister the listener right so detach the content from the counter store which in turn allows garbage collector to collect the the instance of the counter counter component all right so let's get started with implementing this pattern so in order to implement a dispatcher we first we need to you know this pattern dispatches the actions so we first have to implement the actions so the actions um that's the different kind of actions right so first will be increase like increment action so add a class command action all right and in there we can declare a constant which we can call it increment or let's just call it increment all right and then create a moment uh but remember that we're going to have a decrement actually we have all kinds of different actions but this pattern should be able to dispatch all kinds of different actions so for that we need to use poly polymorphism and we can use interface so we're going to have a i action interface and and for that we will go outside here we'll add another uh interface here we say called i action and the action has to be able to identify itself about you know what kind of action it is so that our store is able to distinguish what kind of actions is in decide whether the store will handle the action or not right so for that we need to um uh we need to have a read only property just to get the name of that the action so we can have that have it like this and so so um we're going to implement the interface right so we have this and then we're going to say is we just we just return increment and that's it all right so and and we're going to copy this and change the strip decrement because we are going to demonstrate two actions right um increment and decrement action and then come over here we call it uh decrement action and then here again i want to mention that the reason why we use classes as actions instead of just use a string or constant or enumeration is that sometimes action will not only carry the information about the name of that action to identify what type of action it is but also carry some useful information like functional information in it for example if we were to allow our user to set the count of the counter directly instead of just incremental decrement we need to allow the user to input a number right and when we create a set number action that actually need to contain that number the user input in that case having a class like this right and then input a sorry implement a no property like this well it's going to be a number right like this will help us to transfer that information from the component to the dispatcher and from dispatcher dispatch to different components that subscribe to this spectrum so that's the reason why we need classes and another thing about the good thing about classes is that you can see all of the actions that the particular store has to handle so so now we have two actions and let's go ahead and implement this pattern okay this pattern should be outside of the store so i'm gonna add a class right here and let's call it action dispatcher action dispatcher so action dispatcher will will allow different stores to subscribe to it right so remember this is a publish subscribe pattern which is also called observer pattern right so first we need a you know we need action and we just call it registered action handlers right and then we're going to have a public method register right we register basically or maybe you should call it subscribe okay um subscribe so we're passing an action which is delegate right um passing the action handler and we're gonna call register action handlers we do we attach the handler and that's it and and another one will be the and action handler as well and only thing that is different is doing this and of course we need our it's actually very simple we need our dispatch method which will be called by our component dispatch different actions so we'll just do this and then here we're just saying already store if it exists then we invoke and pass in the action all right to simplify this we can include this magic wand symmetric one thing and this expression body right and we do the same thing here it will make it look way simpler same thing will make look simpler but remember this dispatcher right it has to be called by all kinds of components so we need to do dependency injection in order to do the dependency injection we need to have a interface and we don't have to do it line by line so we can just go to edit and then go to refactor and then select extract interface right right here we can also just do ctrl r i right ctrl r ctrl i so this will so i action dispatcher and we're going to create a new file and we are going to have uh all three methods to be included all right so let me implement that and the i action dispatcher is right here and that's exactly what we need okay now we need to go to startup and right over here and we don't want to do a single 10 right here because if we do a singleton then the action will be dispatched to different users we want to be scoped to the the connection so we call it you can still use scoped and then we are going to use i action dispatcher okay and associate that with the concrete implementation and that's it for uh dependence injection configuration so now we have the action dispatcher we have implemented the the action the actions which are the increment and decrement action now what we need to do is we need to use it in our store because our store need to be able to handle those actions right so we will depend is inject first we need to dependency inject dispatcher with dispatcher and control dot will select the second one okay so i have this that actually dispatcher action dispatcher so this is right here and it put it right inside our observer pattern here and i don't want it to be here so i will put it up here actually i'll put it up there and then so i have a dispatcher and what we need to do is that we need to register to the dispatcher so what we can do is actually dispatcher dot register actually subscribe right and we need to subscribe we can put in our action handler and where is our extra action android we don't have it yet so so right under done under here we can create the action uh the handler which can be a uh private method and no actions and we need to be able to pass in different kinds of actions right that's why we need action and and then we can subscribe we can pass into this so this is the um action handler right in here so in here we're also facing the same question are we going to call and subscribe here okay so are we going to implement the destructor right the finalizer that so i'm sorry are we gonna do this counter store and uh i'm gonna say desktop action dispatcher dot unsubscribe window actions are we gonna do this uh i would say we don't need to because they both scope to the same actual same connection right so they have the same lifespan so when one is collected the other one is also gone so in order to simplify our goals i'm not going to implement that so here we are going to handle different kinds of actions and we have a choice to not handle every not handle every action because dispatcher is going to dispatch all kinds of actions to all kinds of components that are subscribed to the dispatcher right so all components the subscriptive dispatcher will need to determine whether the action is something that that they want to handle so because every action has a name right so we can use that so in here we can say increment action remember it has a constant so we can do this and then decrement if it's a decrement action decrement action then it also has has its name action dot name so we can uh in here what we need to do is that we're gonna call the increment account that we implemented last time right and then here we're going to call decrement and this can become private so so we registered right we subscribed here and then we're handling the actions right here and now we need to go to our counter because you're going to see problems here that this is private so in order to fix this problem so we are not actually directly calling this method anymore we are going to independently project our eyes pattern action dispatcher so we call it action actually this patchy and then in this increment here we're going to dispatch a action and what that action is it's going to be the increment action and that's it so this uh because this is um in the memory it's centralized and this will publish this action to all the stores in the store well currently we only have one store to deal with this uh 12 stores and the store will will determine that we're going to handle it or not in our counter store yes we're handling both the increment and decrement okay so this right here we will still keep it right here because uh this remember we are two level of we have two levels of observer patterns so this is to attach listeners to the store in order to get notified when the state changes so this we have to keep right here the only thing we need to change is this action dispatcher thing so instead of calling the store directly we're dispatching this action through the action dispatcher and to that will actually publish the actions to all of the stores that subscribe to the action dispatcher right so let's give that a try so i'm gonna do control f5 running the application right here yeah that works okay so this is uh how i implemented the dispatcher you can implement in different ways another thing you can do is you can have this action dispatcher action interface and i action dispatcher you can extract this into a class library and use it in different kinds of projects and you can even implement a store state store base and in there you kind of subscribe to the action dispatcher and when you implement a stage store you can just inherit from state store base so that you don't have to do this subscription all the time in this section we're going to talk about authentication in serverside laser first let's have an overview of a typical authentication system and see what are the components in a typical authentication system so that we know what we are going to configure because to configure authentication for sp.net core there's many components so having a big picture will help us to understand what we are actually configuring right so there's three basically there are three different layers of any authentication system so we'll have the ui layer which will interact with the users to register login recover password manage user profile etc and then we'll have the core functionality for authentication which is to authenticate and to authorize right so this is where we receive the user information and we authenticate the user information or authorizing from information right so we will have a ticket either ticket or token to deal with and then we verify the ticket and see whether it's valid that's the authentication and then we'll see whether the user has sufficient permission to access the resources the user is trying to access so that's the authorization so it fails for authentication then it will return http 401 which is unauthorized right and if it fails to offer fails on authorization then it will um return http 4 3 which is forbidden and last but not least this is the db or the rm or the db and rm combination that's where the user information the rows information and everything else the claims are stored and the data is and operated right like saved or updated or deleted so those are the main parts of a typical authentication system so now let's look at how we gonna configure them first let's create a server setup blazer application and let's select later server site and let's change authentication to individual user accounts and store it under user accounts in app right we're now going to cover the cloud scenario and then let's click on create so then let's first take a look at the project file so remember we have three parts the ui the functionality as far as the database okay so for database this is the package okay this is the new get package that we're using which is the rm which in this case is led framework core okay and uh for functionality we're using identity framework right so this is the identity for led framework core so this handles the authentication and authorization and for the ui so this is the package that contains all of the default user interfaces that handles login logout register and all those other user interfaces okay and then let's look at the startup file and see how these different packages are configured right how those three different layers are configured so we have configure services and configure so configure services are configuring those basically the packages right and the configure method is actually configuring for office configuring the middleware right so again we're going to look at our you know database or rm configuration which happens right here on the top right so this configures our entity framework and it's it uses this connection stream which comes from this app settings right so this is our connection stream this is our database and then uh the second one this is configuring the functionality this is configuring our identity framework right and also providing a identity user model this model corresponds to the spdat user table in our database okay so basically this configures the identity framework also connects from here back to the database here right and this is providing that model that corresponds to that and this is the the database context which corresponds to the database and then so basically this configures the database this configures the functionality so which part is configured in the uh the ui so there is a the ui is actually inside the solution uh but this authentication state provider this is when the ui needs information of the current login user that's uh that's what this is for all right so this gives us the user information then let's look at the configure method and the configure method uh it configures the middleware for authentication okay so this user authentication and use authorization there are two middlewares that handles the authentication authorization when these middlewares are being used it look looks for specific concrete implementations of certain interfaces like eye authentication handler right and those interfaces are actually implemented inside the identity framework which we have dependency injected by using these these calls so then you're for authentication authorization it will use these injected classes to to finish those works and then last but not least this map controllers can configures the routing for our default user interfaces because we're going to see that the user interfaces are not laser components right not reader components but reader pages so those razer pages need a default routing which is the default attribute rotting and also this map controllers uh set up the default reader page rotting which is actually according to the the page structures and that's uh now let's run this so first we need to register user we can use any email doesn't matter right and then we're gonna give it a password and then we register this comes up because there isn't a database right so we need to apply our migration to create that data because if we look at our data folder we can see this migration here that actually create all these tables the rows the users and all of the the other ones right the role claims the user claims everything else right so these tables are only for now models in our c sharp code so those c sharp codes has to be mapped to the database and that database has to be created first by clicking on apply migrations it's going to run this these mega research migrations and the database will be created so that's um that's entity framework so i'm gonna click click on apply migrations right okay so register confirmation so we click here to confirm our account so normally this is going to send an email but here it's just a dummy one and then because we have already register so we are going to login okay so we logged in right now we can access all of these what if we log out can we still access all of them yeah we can still access all of them so then how do we secure our blazer components okay to see you secure a specific component for example if we want to secure our counter and both counter and fast data pages then we go to the component we go under pages go to counter and we use we give it attribute right so which is um if you're familiar with sp on an mvc or a speedometer coordinate c or so this is a attribute sorry uh the authorized attribute that you you usually use for your controllers so we use this here and then we copy it to fetch data as well so now uh we go back to our component refresh go back to our page and refresh that's good so both counter component and fetch data component says not authorized so this is how we secure our individual components another thing we can use is the authorized view component which we can the authorized view component is a templated component so we can use that to so it has two templates which first one is authorized right and second one is not authorized okay so these are the two templates and if we copy all of these actually let's leave the title outside to make it more realistic because we are not going to hide our title but we are going to hide everything else to be inside the authorized view and then you say you are not authorized please contact admin then here we can remove this and come over here and refresh the data refresh the page going over here you can see you are now authorized please contact with me go to counter you see not authorized okay and so this is the this is so removing that authorized that's important so don't use that authorized attribute because when you use this it's not controlled by the authorized view component right it's controlled by something else so this using authorized view and the authorized template as well as not authorized template we have covered this so if we revert let's revert all of these okay and we use this so how do we provide a global authorized view that's under the app component so here you can see that we have this authorized walk view which is also a a template component right so here we can give a global information about not authorized in here it's say you are or you don't have her permission to access the page please contact admin okay so if we do this you can see that you don't have permission to access the page please contact me and if you go to fetch data you see the same thing so both of these are seeing this uh same message so this is how you provide the not authorized message globally but if you want to provide an individual message message you can use the authorized view like what i've just showed another thing that you typically want to do is to utilize the user state or the user information inside your logic so for example under the home page if we want to display some user information here right so we're going to go to our uh index component which is the home page so i'm going to do this survey thing and then give some line break and here if our logic requires user it requires us to provide some uh to to utilize the user information that comes from the authentication state so if we go to our app component on the root component again we can see this cascading authentication state and this is similar to the this is similar to cascading value we're actually cascading the authentication state down to the component tree right so in order to use that cascading parameter we need to declare a cascading parameter here so first we have this code block and then we're going to declare a cascading parameter and that parameter is going to be because by default cascading parameter are mapped to the parent level the root level by type right so here is authentication state so this is the type of state we're going to keep this as a product parameter it doesn't need anywhere else so we can use this and then certainly we can use this as a in user actions for specific logic but what i would do for the demonstration is i'm going to override the uh initialized async and then in here we're going to say this off state we're going to actually await this off state right okay let's change this to underscore all state and then here we're gonna say state and we are going to use this and what we're going to do is i'm going to say if our state is not it's not now then we're going to display some uh some information about the user right so let's say the username is uh state dot user.identity.name over here we're gonna flip through all of the claims okay let's all of that please and we're gonna display type okay and i'm gonna display um value all right so this is so this is how we are going to get the authentication state which is basically we're using the login user information so let's test this we'll refresh the page we don't see anything because we didn't log in so let's login uh my password and we don't see anything oh okay okay so that's because of this refresh all right so we have this username it's just basically the email address and then we have all of these claim type and claim claim values not very useful in this case but it could be useful in if we ask some more meaningful claims at least this uh this name and the value this is more meaningful all right so that's how we use the authentication state inside our component next one is if we were to customize our identity uh framework model let's first look look at our database okay so this is the database we're connecting to our local local db right so let's go to server explorer so this is going to be our database and testing connection everything is fine click on ok c is the tables so we have the esp9 users table right it has all these information what if we need something else inside here let's say we're designing a you know a education system or a learning system and we need a school information for each user right we need to be able to store in here so then how do we customize the model so in order to customize the model under here we can create a a class i would call it sp net uses users right and uh currently if we look at our iterations and their which we have seen it's using the identity user right so what we will do is we're gonna inherit from the identity user okay here's our identity name space and uh so because we're inheriting from the identity user so we will have all of the existing columns but what we need is a new column that is called school right which has a string type so that we next we're going to go to our application uh db context in here we need to provide our specific user type right the user model the corresponds to that asp.net users database okay so we actually have this just created here right so just to be sure f12 goes to the class that we just created right and next thing we need to do is inside the startup uh instead of use the default identity we can just uh we can change it to use identity and change this to sp not users right and then the second parameter identity row and then we would add a migration so in order to do that we're going to go go to our tools new git package manager console i'm going to say add dash my migration uh we say extended asp net users all right so build succeeded generated the migration second version uh in the up method we can see it added school column we go back to the console here and we're going to say update update database build succeeded okay start let's look at our server explorer and whether the whether we ever refresh it do we see school yes we see school right so we added this so that's how we customize our model so now let's talk about how we can customize our user interface so if we look at the project structure here we can see in areas the errors folder which contains some pages under account we have a logout page right then we have a login partial what if we want to customize the register page right where do we do it how do we do it we go to right click on the project click on add and then here there is a new stuff scaffolded item click on this we choose identity select identity here click on add now it says scaffolding right it's trying to find inside that you get packaged wood are actually included inside that new gap pack here we can see all of the user interfaces that we can customize so we are going to customize the register user interface and so this scuffle is going to connect from ui all the way to the database that's why it needs to select a database contact data context class right which is this one that we have and then we click on that and then it says it's scaffolding all right so under the areas we are going to see a register reader page here right so we have this freezer page here what if we want a uh what if we want to add the school information here right so we're going to go over here and if we look at our input model which is here email password right confirm password what if we need school information here so we're going to say school and this is school right and on post on post we're going to say school equals input.school so this is the information that will be will be used later and to persist the data into the database so our our logout page are still using identity user in fact we can just search in the whole solution to see where our identity user stu are and then we'll replace all of them so inside here we have identity user so we're gonna have to use our identity user okay to solve that problem uh we can come over here and uh we can say add default ui to go to default behavior and then add default token providers as well okay that should fix the problem and now let's run the application again and if we register okay so we're missing the school field let's go to our register raiser component let's copy this all right so it's going to be here and then school copy and paste and that should do it let's build the solution again and come over here refresh the page we will see so school field and let's do our tester at gmail.com that's tester2 okay and password is going to be our password and school is let's call it my school and then click on register okay so i'm going over here and then all right so we have our uh page and we're able to access all of these um so now let's take a look at our espy.net user table to see whether that email is there let's run a query new query i don't know why the screen is flashing like this so let's select star as net users and then let's run a query like this and we have test her too and the school is my school right okay so we have successfully customized our user interface to include our new field which is the school field and we also successfully customize the asp.net users table by going through the led models and add migrations update database i want to create a data grid component i want my datagrid component to be very similar to device devexpress or dive stream data great component at least i will have some column configurations i will have the functionality of sorting and paging and perhaps something else as well so in this video i'm going to cover the column configurations so let's get started this is a serverside laser default template from visual studio so let's create the datagrid component under the controls folder razer component so in order to have the data passed in i needed to be to have a generic type and then from there i need to use the generic type to have a list of items and let's call up data items after that i need to define like to configure the columns and for that i need my columns to have to indicate what kind of data field within the t item that that we're going to use for the column and we'll come caption uh data type and format and alignment as well so let's have a configuration folder okay and let's create a column definition class so have this and what i need is data fill and i would need the caption as well right because the name of the column we know can may be different from the caption of that column and then i would need the data type so for that i would need a data type class right it has nut set string number date date time boolean currency and i would use it here as a data type and after that i will have a format and this format is i plan it to be a free format that's why it's a stream and then i would have alignment as well and for that i will create alignment class and that i will create here and it's going to be an enumeration as well and it has not set left center right okay so with the column definitions i want to have a constructor of this and i want to initialize the data type to be set now everything is not sad at the beginning right alignment not set okay and then let's go back to our component and from the component and from the component we will have a list of columns as parameters so that we can define our column and uh i need the controls to be in here in the import file so the namespace is here so i have column definition i'll call it columns okay and with this i should be able to render a and i'm going to use the boma all right so i imported my bulma css file and uh so with that we start uh we're gonna start creating the html here and for that we will use a table because it's a great and uh class will be uh full west okay so it's a former plus and let's create the header first okay uh so we'll have um a row of header and if we don't have the columns that's where we're gonna use a reflection to you know to deal with here we'll just uh we will need to loop through and here we need to create the uh th element right so it's going to be um ph and then the column are captured so let's let's test this um let's use the index component and uh let's import i think we import that already so we will have our data grid while we don't and that's because yeah we don't have it yet we have this let's import this namespace controls and then we go back to here we can have our data grade and i don't know why it's still complaining that uh so controls and let's go back to here and we'll data grade degree component and we have our data items column definition and everything right so let's just use it just for now it's going to complain but let's add this code here then we need to initialize the definition and stuff okay with that um we have i have some definitions created for um i have some data created from previous videos uh and i have extended that so let's just copy that over so i have an employee class specified here right and i need to define a list of employees um in here and initially i need to initialize that i also need a column definition right and that's that is here and i have my initialization method created already so let's copy and paste that over here and let's take a look what it's trying to do is it's trying to initialize if it's null then we create a new definition and that of definition has name title department employee employment date and salary and captions are named title department employment date with the space salary is annual salary right and then we have our employee list hardcoded over here just for testing the data component data great component so with this we can specify the tm t item to be employee right and then we can specify our data items to use the list employees and then we can use we can assign the column definition to columns okay so with this i expect that the component starts showing i expect the components start showing something okay so we have nothing here we have nothing here and that's because we are not calling the initialize method yet so we're going to overwrite it and we're going to call the uninitialized lifecycle event so that our list employees sorry so that we can initialize this right here right so both have column definitions both have both we're checking whether it's now or not on both attributes so uh so we're using so it's okay to use it in the uninitialized lifecycle event because the uninitialized left circuit un is actually being called twice if you have watched my previous episodes you know this it's going to cut twice on the first first page load so um and we made a change and go back and refresh the screen all right so we have our name title department implemented in annual salary so that's pretty cool and we noticed that we have a space here and a space here so it's actually picking up the um the caption and that's that's pretty good uh so the next thing we are going to work on is uh we're going to display the data right so for that since we have already initialized data let's go back to our data grid component and let's add the tbody body element and from here what we need to do is just simply loop through the data items right and in here we have the rows and we just need to you know go also loop through the columns and uh provide so inside the double loop we use um reflection t item and then we just got property got what property and that's where the data field you know the data field is being used here right because if we go back to column definition we can see the data field here and if we go back to our initialization data initialization we can see that the data data field you know it corresponds to each one of the properties in the employee class right so here so we use the reflection and provide the data field as the name of that property and that's that will get our corresponding property from the employee class right and here we just need to get value and get value of what value of the current current item right and that should provide us with the data and let's go refresh the page and see whether we have all of the uh data displayed here all right cool so we have the data here and uh we noticed something that you know we want to have some formatting uh the salary is not showing dollar sign like it's not being displayed as currency an alignment for numbers should be aligned to the right i want to see it to align to the right uh i want the employment date to only display the date part so we have some formatting to do so let's first go with alignment do with alignment and for that we we already have the alignment in the uh in the definition and for alignment we have not set left center and right and uh to use alignment we need to do something with um header and as well as data so let's deal with the data since we just finished data here so so inside here i think what we need to do is um if if column dot alignment is not not otherwise if there is a definition for alignment then well let's implement the else because it's simply just this okay and if there is a alignment then we need to have um we have need to have it here so just say column dot um alignment yeah alignment uh i don't know maybe you guys can tell me why whenever i type uh whenever i use the intellisense the dot goes to the to the end of that line instead of instead of at the at the right place i don't know i don't know how to resolve that problem i tried space i tried uh enter i tried tap it has that problem sometimes it has that problem so then i go over here and i do two string um and then i can do i need to make sure it's lower and lower case right because it's it's left it's left center and right and that corresponds to css style so i can just use a tostring here and i think that's it for alignment at least for the data part right and let's go back and refresh and see what happens i'm expecting um the alignment to be to be right because um if we go back to our definitions here you can see that i have um alignment to the right for salary the salary column right so yeah so it's working right uh then we need to have the um the header to be also aligned to the to the right i need to go to uh the header part and then let's see whether we can do the same thing um we just copy this and get it over here and instead of using that complicated stuff for data yeah just remove this say column dot caption and remove this part and let's see whether we can get the alignment right okay so i got the alignment right but then it changed the changes style right so i think it's uh it got rid of the um something related to the th because the alignment that we assigned here oh okay so it's td we use td so let's go over here and refresh again i change to th now ah okay so let's inspect and see what happens so i have it on the other window and uh moving it over here who has the we have the alignment to the right but something is overriding uh this and that should have something to do with the th here and that's and what is that okay so inherits it inherits from something okay so if i yeah if i add it back then yeah then if i remove the inherit then it works so i may have to add another class and that's when that's where i usually in bootstrap or oma i create a override class and let's take a look at the and let's just create a override style stylesheet so stylesheet style uh stylesheet and i'll just create a let's call okay and uh in here i will have uh i want to create a alignment my style is also targeting th and i wanted to align to the right okay and that would have uh text aligned to the right and since i'm trying to override so i'm gonna use import important and since i'm doing this i'm gonna create for left center as well as right center okay so and i have that and if i go back and i just um alignment right so here i have to do switch statement switch um dot alignment right case column dot alignment dot uh sorry case alignment dot left right and case alignment dot center case alignment dot right and uh another case just do nothing in other case fix this typo and i think the formatting is weird so let's format it okay coming back up and so so instead of using it right here let's put it inside and we need to use the class that we just created so we have class and i will call a line left over here and if it's if it's alignment or if it's default then we and use should be okay let's see what happens if we refresh our uh still not working and why is that inspecting okay and we have our class here's our class we have the align right class right but it's not loaded perhaps um let's go to i think perhaps we need to the style sheet here so we have this already here and i need my phone to be here and i also need my uh override to be here as well and let's see whether this would fix that problem okay very cool so we have our class correctly applied here next thing is i want to have the formatting as well and uh and for that i uh planning to do something simple uh if we have if we go back to our here um where we define our columns if we have our format if we have our format see i have this data type as currency i have this format as well um and i have the format here as well so if there is a format then then i want to format it otherwise i'll just leave it alone right so going back to the data grade component and we need to add some formatting in the in the tea body area right and that's where we will have some kind of if statement right so let's say if the format is not empty right or null if column dot format is not empty or null and uh f column dot data type we also because the format is kind of dependent on the data type so i also want to say if it's if it's not if it's set already then i would actually format it and in here i also need to do some switch statement according to you know different data type i would format it differently so if it's date um let's state constant date you know state or if it's a um date time then i would you know what i'll create a string here and this is the value and if it's a date or the type of value would be in time dot parse the because this value is basically an object so i would have this and then i would call tostring oops oh okay so to stream and then i have you know i have this and then i just to string because this is a daytime and then i use what i use the column dot format right and that should do it so that's for uh day two or day time and if it's a boolean if it's a boolean then we're going to do it a little bit differently right we're going to say value sorry value equals again it would be similar to the daytime thing we just instead of daytime we use this we're gonna parse it and then we're gonna we'll just say two string and this should give us whether it's true or false and and then if it's currency currency uh why there is a problem here i don't know why okay there's no problem so as a currency um i also wanna just copy this over here and so i'm going to use you know it's double and i want to parse that value and this would give us uh currency i just uh you know what i'll just i'll just use this and i also want to run it i will use mascara and i'll provide this okay okay so i run it first and then i convert it to currency format so then i have the format here and so i have sorry i have the value here and so i have the volume value here and this here there is the alignment and i just need to put the value so instead of this i just need to use the value i think all right and that will be like this and yeah same thing as here i'll just put the value here um what's the complaint does not exist well it's right here okay that value is supposed to be inside here all right so that's when it has format and if it does not have format oh yeah it should use the original which i got rid of um yeah so let's revert i'll copy this first and i'll revert okay that's good and then i have it right here and else so this if statement is if there is a format right so we're dealing with otherwise here otherwise we just use the original one which doesn't go with any format okay so i think we're good and going back and refresh the screen all right so cool we have our um employment date format we have our annual salary as well so that's i think that's what i want to cover for today i covered um column definitions column configurations i covered uh formatting and i covered alignment let's implement page for a paging under the configuration folder i will need a paging configuration class to be able to configure paging so create a class and i'll call it paging config and i think i would yeah let's make it simple so i would have enabled property and page size and i would also have let's have just these two for now so yeah in theory if given a page number we need to go to that page right and we can do that with link query so with was link right in c sharp uh given a number of let's say we have we're working with data items right so we can use link query like this data items dot skip so if we are on page one then we skip zero number of records and then we take take how much we take the page size right let's let's say each page size is has 10 items each page has 10 items then i would say skip 0 take take 10 right and uh if we want to go to the second page then i would skip 10 right and take 10. knowing this what we can do is we can implement some of these functionality here so for example i want to know how many items to skip right so i would implement a function here i want to know the number of items to skip and i need to provide the current page number right and if enabled right so if paging is enabled then we would apparently it would be the current page number minus one and times the page size right because for example if it's we want to go to page one number of items to skip well let's call it page number not current page number it's the page number that we want to go to and let's say we want to go to page one then this would be zero so number of items to return to skip is zero otherwise it's not enabled okay then we would return uh zero simply zero right so we're not skipping any items so if this is page two uh we want to go to page two then number of items to skip is the same of the page size right so if it's 10 then we skip the first 10 items so on and so forth so the next one uh is you know number of items that we want to take right so i want to implement that two number of items to to take right um and again if you know enabled but if it's not enabled number of items to take is basically the total number of items so so i need to provide a total items count and we are returning this total items count by the way i got a silent keyboard it's not that silent it's not silent but i think it's hopefully it's quite enough and won't be so distracting um so if it's enabled then we're basically returning the page size right so if we only have let's say we if the page size is 10 and we only have two items in the list i think by returning page size 10 uh and we were executing link query take 10 i think it will not throw an error let's see let's see what it does so we have the number of items to skip we have number of items to take next one is that we basically want to go to a specific page page right so if we know a page then we can just use these two functions to go to that to um to know along with the link query to go to that page um but what if we just want to go to the previous page number or the next page number knowing the current page number so i'm going to create those functions first okay so um let's do the previous page number given the current page number okay so that's uh that's that's easy i think if it's enabled oh well no if we want to go to the has been enabled right so if the current page number is greater than zero then obviously we're returning the current page number sorry greater than one then we're returning current page number minus one right otherwise if it's not then we're just returning the first page okay so this is the the edge case scenario so we don't want to return minus like negative number um the next one also like the next page also has a edge case scenario where when it bridge when it reaches the launch pad the the last page so for that i want to pass in the total items called because i want to i don't want to exceed that so that condition um we should say that if you know the current page number is smaller than the maximum page number right well we don't have that let's say let's just put this here so that we in our mind is clear so if it's if it's smaller than that then yeah we can just return the current page number plus one because we want to go to the next page if it's not smaller meaning that we're already on the last page then we just simply return the current page number right so how do we know the maximum number a page number it has something to do with the total items count so i'm going to create a i'm actually going to create another function here and that i will call it max page number and providing the total number of items right and here i'm going to say um and you don't know the total number of pages obviously right so that is um i think it's yeah so it's number of pages equals total total items count divided by the page size but these are integers so to receive a double i want to force a conversion here and knowing the number of pages then we just need to do some so if it's the same as the floor number of pages right then the maximum number of uh maximum page number so we're basically returning this which you can say next page number so next stage number equals the number of pages and uh it's complaining yeah this is double so just force it to integer otherwise if it if it's if the number of pages is it's not a integer then it's reader so the maximum page number must be equal to number number of pages plus one right so then here i just return the maximum page number okay so we have the maximum page number here and i can use this here and pass in the total items count and that we will get the next page number previous page number next page number and i think we're good now now let's jump back to the component what we want to do here is um we want to display so we have this currently it's going through all of them all of the data items that we have and it's played all of them and this case there's no paging but if paging is enabled right um because in our page page and config we actually use the enabled in these two functions we're checking whether they're enabled or not so we can just use that directly so in here we would say we're looking through items but it's filtered right we want to skip we want to skip we haven't declared that paging here yet so let's define that declare the paging parameter which can be passed through the parent component basically the developer provide that information and that's um paging convey class that we have just defined and let's call it and let's go back and say if the paging dot skip not if we know that paging and we're skipping the number of items to skip number of items to skip right and it's a function that we need to provide the current page number so um the current page number has to be let's make it a parameter initialize that to the zero because you see the print page number may be used by the developer yeah so let's let's do that for um so in the case that the developer i'm going to provide a custom pager in that case um that current page number needs to be exposed to the developer right so and we can yeah we can we can initialize that to zero and current page number is uh is going to be skipped over here right and then we want to take sorry um that i think you know it's good and then we take and how much we want to take how many items we want to take which we can just get from the so number of items to take which i need to provide so this part um we have defined and we want to it takes the total items count number of items to take let's think about whether this function is right or wrong number of items to take we provide the total items count and if paging is enabled then we return the page size otherwise we return the whole thing yeah i think that's right so so here we need to provide that total number of items right and that's count like this okay so we change this part and that should render our data items correctly now we need to provide the page we need to yeah we need to provide that pager so let me search for uh data great pager images let's see so it's on the other one so good images i think i want to do a simple style i don't want to display all these numbers here i think i want to use something like this um okay so let's implement the pager here again i prefer to use the beaumont style which we can just use level okay so if you haven't used level you can go to bulma website and we can use bulma it's actually pretty simple right so in order to i want the page to be on the right hand side right which is similar to data grade in that extreme and under level i can just say level to the right all right and within it i haven't i need to provide another one which is level item and here i can just define so here i would say if paging is provided and paging the enable is true in that case i would render the pager and this is pretty plain pager and i want to also be able to give the developer the option to provide custom pager so i going back to the paging config i want to add another property here i want to say bowling and um custom pager right so if it's a custom pager then we render the custom pager so if paging dot custom pager then we render the custom pager um which we can provide a render fragment here as a parameter so which i also covered in one of my previous episode if you haven't used render fragment and this is going to be a simple render fragment with dot generic type surrender for recommend custom pager so um and it's pretty simple to use going back over here to say if the custom pager is enabled i mean if we want to use custom pager then just use custom page that simple and then otherwise we use our predefined uh pager here and the predefined pager for now i just want to use buttons i wanted to have yeah we use button for now and then we'll change to to better style so button and in bulma it's simply called button um and then um yeah and this is called previous right and then we'll have a next button as well we just want to make it work for now and um obviously when the button is clicked we want to go to free prep page okay and again when it's next button is clicked we want to go to next page all right so let's implement these two yeah i think these two should be public uh because for custom pager it's just me public right so go to previous page and then go to next page and was that we can use the paging functionality to say you know current page number we basically reset the current page number right and then that current page number can be just used in here right and so that we know how many how many items to skip yeah and then we use take to display so current page number should be equal to what should be we have that paging next page number which we only need to provide the current page number right and the total item code is just data items.com and what if the data atoms is now do we have a columns it's not create a header reflection the columns is now what if the columns are no okay so that's that wasn't handled properly yet all right so this has to be handled uh to see whether otherwise you're gonna throw exception but i'm gonna assume that the developer will take the responsibility to populate the data items right so um data items shouldn't be now let's consume that and uh and if you want to extend my code you can go to my github and to extend that so next page number is this right so and this one is also the same paging dot wait this is previous so this is wrong sorry about that so this is previous for this page number and i should only take the current page number as a parameter so we have the premiums we have next what else do we need we probably don't need anything else and let's give it a test by providing the configuration um let's go to the index page and we need to provide the page the paging definition here and we could just use the line let's say that paging configuration here and what do we have we have enabled so i want to enable right and what else do we have here just say custom pager false uh page size let's use how many items did we provide last time i think it was 10 items okay so let's say we have three page size and we can test the scenario that the last page should be only have should only have one item let's see whether that caused any problem so so yeah so this should be working let's say let's see whether it works or not so i'm going to just run control f5 so that enables the heart reload okay so we have the previous next button unfortunately i want it to be on the right but it's on the left so let's see what went wrong here um so going back to the degree component i have level level level level level maybe i need a level left ready to go okay so i put a level i put a level i'm putting a level left here and then we go back and refresh the screen and see whether that works or not okay yeah then empty level left solve the problem and i see three items right hopefully that's i'm gonna click on next page i'm gonna see something magic happens oh boy it works okay it did work one two so this is on the third page right because i clicked twice and the last one should have only one item which is great so it's working so that take functionality um i'm saying take three but there's only one item left which is fine right it didn't cause any problems so we're going back and i'm clicking uh yeah this is on the first page so no matter how many times you click on it it's not gonna go because we always return zero uh yeah number of items through to skip is always zero and then we take the we take three from there right so let's let's see if i what happens if we change that to two all right so to two we're gonna have uh five five pages okay so first page it's weird though i can't click like the first click did not work and then the second one started working so this is the second page and then the third page the fourth page and the fifth page which is right so it all go all the way to the first one and then if i click on the next it's working but then something is wrong if i refresh the page and click on the next button for the first time it's not responding and let's check what's happening uh yeah let's check what's happening so i have this oh so this is index page so i have this next button divide handler and the current page number was set to be zero at the beginning right oh no the current page number cannot be zero i'm surprised that it's skipping correctly so if i provide zero here what's going to happen if it's enabled so if it's enabled 0 oh it's going to return minus 2 oh so skipping minus two all right so that's that's something around there so yeah i think the initialization is wrong uh which i have to fix in here so the first page number should be one and let's go back and refresh the page and see whether that fix a problem or not all right so i'm clicking on next button that works that's not the problem okay last last one first one let's play with some other numbers here just to make sure all of the edge cases are covered so index component and what if i use four uh then i would see three pages the last page should only have two items right so click on refresh all right so four items first page four items second page two items last page and that's working very well for me okay cool so i need this these buttons to become i don't like the huge fat buttons to be here i want to be um a little bit prettier than that which i will do going back to data grid and replace the buttons with uh um actually before doing that i want to show which page we are on first right so i want to have a span here and then i want to show a number of pages page uh current page number red page page number of the total number of pages right so we do have a maximum number of maximum page number here again this problem happened so i need to provide the total count right so data items dot that should be good takes long time for this to disappear i don't think i did anything wrong okay good all right going back and we'll see whether that's better or not all right so page one well you need some spacing there at least it's showing the correct result okay so we need some spacing i need some spacing here and bsp i need i'll put two over here and two at the end and that should be pretty good all right that's good okay let's replace these uh big buttons to uh just just expand and uh what should we do with this band i want it to be bold and i want to just use the yeah just use this right so for previous just use the less than less than sign and then this would be greater than sine greater than sine right and yeah so both greater than sine and that should be well i should have just changed the button but okay next page so that's fine all right so let's see whether that looks okay or not okay cool so we have these um i think this is wrong it should be the other way um so i think it's should be this side and then any other thing i want to change i think i want this to be smaller and then i want to have a cursor uh pointer cursor right so i'm going to use inline style font size yeah i want it to be bigger let's use 14 and then the cursor going to be pointer right and i'm going to use the same style here and i want these to be smaller size and definitely not cursor oops so i want this to be smaller and i want to be not as prominent as the buttons so i want to change this to yeah great all right so let's see what happens okay i like this look if you have the time you can kind of disable make this look like disabled when um we are currently on the previous sorry on the first page right and then make this look like disabled when we're on the last page which i will not do uh during the video so yeah so i i think we have done pretty good job and i just want to perhaps cover the custom pager right what if we want to want the developer to provide a pager so which have partially implemented this custom pager here so what if we go to here and then we enable this oh sorry it should be true all right custom painter you go true and and we go back i expect this pager to be gone right this is pretty fine pager like we just defined the picture yeah so that's gone so the developer need to come here and provide that pager right so we have that custom pager here and what should we do here we should have maybe we should just use buttons or yeah let's use you know let's use some buttons right and instead of use so let's let's make it look a little bit different let's use um bootstrap right so btn primary yeah so you see that blue button which i don't like but just make them a little bit different right so how previous next and uh and what should we do so the previous button when we click we need to call a function like this oh this is previous all right and this is next page well for uh to make it clear so let's use a different function name than the one before and i'm gonna call it priv prep and next here and then at the bottom here i'm going to use a private function page and i'm going to call the great dot go to next go to previous page and then avoid next page great dot go to next page okay all right so we have our previous and next button let's see whether they work or not click on next well it's doing its job right i like it this thing is top previous one is not working previous is not working oh and there's a typo and it doesn't even give me an error that's very weird all right okay so ctrl f5 again next previous okay everything works um so what if i want to provide that number of pages per page uh per page number off page number so i'm going to go over here and copy this where is it where is it here okay so we have this over here but what i want to do is instead of provide this just as a um this is a label for read only i want to i actually want to implement a uh input control here right and that's number right and i think there is maximum and that maximum number is supposed to be i don't know whether when i call great it's going to give you any problems maximum number oh it's not returning the maximum number so we're going to go back and return that maximum number so that's going to be a property of maximum number maximum page number all right and it's going to be read only and i believe it's going to be paging that why not supposed to be i just say paging dot yeah okay so maximum page number do i need to provide the total what can i do so data item stop so going back and gonna say maximum page number all right maximum page number is a property um and the minimum is is one right so we want to bind this to um current page did we display that i think we did the current page number is a parameter right i don't know whether we can just do this parent page number let's see whether this works or not so so we just use this i'm going back and refresh the screen okay it worked see i have this input box yeah so will it work click on the next very cool right so f three whatever i type four zero nothing twenty five times minus one the first page great so i'm now going to demonstrate how to control these numbers um yeah not supposed to go under one if we use these buttons it's actually doing that control but we can actually type in any number we want but it's not actually creating any issues like any exceptions so yeah we definitely gotta control this number so it doesn't if we type in eight the moment you leave this like the uh the focus the moment the focus leaves this input box it should revert back to the i believe it's three right the maximum page number i want to add the sorting functionality and first thing i want to do is to find the arrows to indicate a sorting functionality and on dave extreme or devexpress the sorting functionality actually has they support both single column and multiple columns sorting uh i only want to implement single column sorting and first i want to find the arrows so it's gonna be css arrow and uh usually i'm pretty happy with the w3schools uh css and i think i like this up and down arrow so i'm going to use this styles and so i'm going to go into my css folder and create a data grade class style style sheet and that's going to be data grade and in here i'm just going to paste this here and uh so this is the the base one i want to change to store instead of arrow and i don't need right i don't need left and up and down so that's pretty good the next thing i want to do is go to my component and i want to go to my component and find a place to apply this style that's going to be my header under my header which is somewhere here yeah it's going to be somewhere here eh alright and i think i'm going to add a span here right and that's going to be i'm going to flow to the right just like uh in dive extreme and the class um i want to call a method that's called class sort class and uh i want to provide the current column right of course we don't have this method yet so let's go here and create one it's gonna be private method and we're gonna have store class and here we're gonna have our column definition and our column here and that's going to be the logic would be something related to the star direction and we haven't created this redirection configuration yet right so we have to add a class here and let's call it sort direction and it's not going to be a class it's going to be enumeration and that's going to have not set right ascending and descending and that short direction has to be also added to the column definition and from here we're going to say prop tap tap and use the sword direction right in here and uh call it uh sort direction and we initialize that sword direction to not set short direction dot not set okay that's good and then in here we're gonna have a logic we need to check whether the sort of direction is so um story direction is sad or not set if it's set already okay if it's set already then we are going to return because we go to this uh class so we'll see that how they're the how they are using it they're using they put the arrow and then the direction right in our cloud in our case uh we are going to use um sort because we change it to sort instead of arrow and then this direction is going to be um column.sworddirection.com to string and two lower this is very similar to alignment we can use that the enumeration to string and if it's sat already so of course here this has to be a string right and if it's set already then we return we return something let's call it no sword and we are going to add this no sort thing in uh you know cess did it great here and we're going to say no short and because we are using it on a spend so in the only thing we want here is to say display it goes none which we're trying to hide that span when when there is uh there's no direction right so i'm pretty happy with this going back to the header place um this span will need store class yeah so it's already coded here that's pretty good and we will actually need this on all of that um um all of okay so it's gonna be this part well actually i'm just going to copy this over to here and this code should be cleaned up i'm just using this just so that it's clear what we are trying to do but we should use some sort of function to clean up this uh this whole thing here so we have our direction yeah we have our direction and so we can test this by initialize our data so we're going to go in here and then let's say i want to i want to sort with name okay so sword direction equals uh sword direction sending and then we're gonna go to our application refresh the page okay so it's not being displayed i wonder why so i'm gonna inspect okay so in here i do have my span oh i see because i included that css but i didn't uh reference it in the whole stop ch chm cs html so of course in here i need to include my new class which is i'll use this obviously i'm going to copy both of this to be included later then at the last place so in here uh it's going to be data great right okay and then we just need to refresh again i'm going to do a control high five all right so this doesn't look like it's the right direction to die this is a weird direction um let's go back to our css and see what actually happened so direction is oh okay okay so i forgot to change this because it's gonna be ascending or descending okay which corresponds to our direction uh in the enumeration which is uh where is it yeah in this enumeration we have ascending and descending and in our component sort class we are using this to string so it's going to be either asc or um or not set or desc right so in here just change that to corresponds to the enumeration and then if i just refresh this again then it's good so we have uh well data we haven't sorted yet right but we have already initialized our data to be ascending sorry yeah in here to be ascending right we have this to be ascending and then it's showing a up arrow which is correct except the alignment is a little bit off and see what we can do to adjust this so we have this here and then so let's see whether we can do something about so um this is a sending class in the data great and we want to do something here and uh i wonder whether i can add some kind of you can see this using padding in the sort let's see whether i if i add some padding here wouldn't happen in the ascending place if i add three pixel what happened three pixel of padding uh didn't do anything right did it do anything if i change it okay padding just make it make the size change so what if i add some marvin and three picks of margin um actually okay so it's actually seemed pretty good so if i use margin 8 then that would be probably okay so let's go to my component and then go here and so if i do margin a pixel that's going to be probably okay and the next one we're going to test is to let's make this descending and see what happens so for now we're not sorting the data yet uh we're dealing with the arrow the indicator of the sort direction okay so we also have this problem and we want to add this uh as well and we added margin last time let's see what happens if we use three at three pixels if we i think six is pretty good maybe five yeah let's use five so let's go to our data grade and under here we would say margin six pixel so when you say five okay five pixel all right so we're happy with our direction the indicator of the sword direction and the next one is we need to sort our data and to sort our data let's go back to the data grade component and in here whenever we click on the header we want to unclick okay we want to sort data and uh we also want to provide this in here and you need to to do it to call it uh that way we uh yeah it's gonna complain so we use our proper syntax here um to provide that and let's define this sword data function and that's going to be stored data here and again it's passing in the column definition um right and column right and in here what we want to do is because we only support single column because we only want to support a single column sorting then first of all so what is this column this is going to be the column that you click on right so it's going to be a sort by column let's name it meaningfully and uh what we are trying to do here is because you may click on one column and then you click on some other columns so first of all we need to clean clean up the sort direction of other columns because we only want to support one sword direction we only want to support sword direction on one column so first of all i want to run through all of the columns right and then if our column.data field doesn't equal to short direction the sort by column data field if it's not the same data field then we will set this uh column to store direction.not set right so then let's reset any other columns that have a a star direction already and then we're going to switch we're going to see what direction we are on currently for this column that we're clicking on okay so if it's if it's not set right so if it's um if the current column is not set then we are going to set it to async ascending if the current column is already set um and if it's already set to ascending then we want to change it to descending right and if it's set to as descending already then we change it to ascending and if it's default then that should not since theory happen but if that happens we just set it to setting again right so that changes the uh i think typo here to change the direction that set the correct direction right and then we're going to look at our direction that we just set right so if it's ascending then we need to order our data so we need to order our data by using the sort method and that has a overload and we just need to provide the comparison uh delegate and uh i think what we should do is to basically we're just uh we are um we can so at the x is t item right which is our in this case is our employee i think in this case it's our employee right but it's t items so we have to use reflection here and then we just need to get the uh data of that of x and then data from the y and then convert it to string and then we compare them all right so we've got to use um reflection again so we're going to say t type of t item then we got property right and then uh we get this data field from the sort direction a sort by column and then we can get value get a value of the x and then we change to stream right and then because string has to compare two so we can then use compare two compared to what compared to y so it's going to be the same same thing here but then we change this to y right and that's that's all we want to do did i close this this is correctly right uh let's complain okay so no complaints good and then if it's the other way then we just copy this and then instead of using x here we change this to y and then we change this to x okay that should do and uh and then this should be called in here did we implement that this should be called in here providing the column that is being sorted and uh also we want to make sure the same thing is being called in all of this column again this should be cleaned up but i'm not going to do that here i think in my github i have already cleaned up the markup so let's go to our code here and close this and refresh all right so we have our uh okay we have our header and this used to be descending and this definitely wasn't sorted yet right so we're missing something here so the initialization is not working uh so we what we should do here is that we should call our we should call our sort data um method when we shoot our sort data method when we are initializing the telegraph component and that should be that should that sure let's implement let's override the unparameter set on parameter set and then oops and then in here we need to call these sort data but which column are we which column are we i think we need to modify this method to make this a default as a default value which is now and then we need to check if this column is now that means we already had a um sort direction configured in the initialization in our case in this case it's the first column name column right so in this case if it's null then we need to find we need to say sort by column equals to the columns definition so there's got to be a column that already has a short direction so i need to find a column that already had a short direction which means not that and then if we we cannot sorry we cannot find it which means if this redirection is no then we're not doing anything okay so do we call it properly double check so we call it here here here here here and then here on on parameter site okay so let's go back and see whether it works um everything is sorted but i'm wondering why it changed to ac ascending and if i click on it it does work but why is it changed to ascending did we quote it correctly so if it's not set okay if it's a set then we find it when we find it we get it and then we clean up here and then if it's not sad since ascending oh okay okay okay yeah so this will change it that's making the behavior that we're clicking on the column but we're not clicking on the column in the uh here so we have to say that if sort direction if sort column um so we're going to have a in here is because it's called initial initial because false issue because um sort by column so if it's not in this initial is going to be true otherwise it's going to be false so this has to be false if it's not the initial method then we're going to change direction otherwise we're not changing direction so hopefully this will fix it okay let's refresh all right so yeah this this looks right okay this looks right uh let's change this uh let's add a cursor here right so which is going to be part of our data grid class and that's going to be it doesn't matter whether it's ascending descending on it has to be added here so it's going to be cursor it's going to be pointer and then let's refresh and that should do it that should do why it didn't work did i save it oh okay okay okay we are this is not the right place this is the span um i think we need to add here going to add this cursor thing here that should do it okay yeah it's it's working and then we click on this okay this is working and i like the alignment as well okay yep sorting works pretty well okay so now let's see whether the sorting works with the paging i hope i don't need to make any changes so i need to go over here and then i need to really reenable the the paging thing editing is uh is enabled in here okay and refresh okay so we have our paging enabled and looks like the sorting is just working fine with picking so j k l r t and then uh we test with uh if we test with the number here that's also working correctly all right so all right cool so we implement our sorting functionality this is the end of the course i hope you have learned something and if you enjoy this kind of content feel free to come to my youtube channel at youtube.com franklyu software thank you so much for watching