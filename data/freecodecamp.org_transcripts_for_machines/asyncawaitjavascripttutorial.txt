hello and welcome in this video we are going to talk about a sync await feature in javascript first of all we'll go through brief history of async programming in javascript we'll see how it evolved over time we'll quickly take a look at the callbacks promises generators and finally a sync away so let's get started okay so i already mentioned this but this is a history of async programming javascript so it all started back with callbacks in the past and then we were able to use promises which was a major like shift from callbacks and then we're also able to use generators now i didn't use generators much i pretty much like skipped over them so i went straight from promises to a sync weight but generators are in between those two stages and finally like right now in the present time we have access to this honestly like amazing feature that is called async wait so what i want to do next is i want to present to you a piece of code and then i want to show you the same piece of code in say callbacks promises and async in the way for the generators i honestly wouldn't want to show that because i personally don't have a lot of experience using generators so i don't want to show you something that maybe i badly written so i'm going to skip over the generators so um let me show you that and here it is so this is the callback exam now i really didn't want to create like the most complex callback example ever but trust me that like this isn't the worst that you can see it can get much much much more uglier than this is right now so what we have here is a function that is supposed to be and endpoint handler so for example let's say you you were building some sort of a website and this handle over here will receive requests from the client for example the browser sending requests to the server and this response object is what you can use to actually write back something to the client for example to the user browsing your website so now what we have in this example is we are talking with a database and let's say we have a table or say a collection of users and we want to find a particular user that will be sent to us via this request so we want to call this function user.find by id and simply pass this requested user id property but now this function is async 1. we don't know how many milliseconds it is going to actually run for so we need to do this in async manner because otherwise we're going to block the code and given that javascript is single threaded language that wouldn't really work so now we we call this function and what we do then is we actually pass it as a second argument a totally different function that will get called once this operation finishes so we say here like okay you go on database and try to find me this particular user and when you do that then and only then you call this function that we passed over here and pretty much like everything starting at this line over here and ending over here is the function that we passed to that function over there now what this allows us to do is say after this same the next line over here we can maybe do something like console.log and whatever we do inside that console.log once this entire code gets executed will be printed out before we see any of these because this isn't done instantaneously but anyway you can see how it looks like and when you pass a callback function so this function over here is called the callback function that's the reason why this pattern of programming is called callbacks after all and when you provide a callback function you should always provide error as a first argument so then we can easily check if there is an error by first doing that and only if there is no error then we can move on and do something else so in this example if there were any errors we would simply respond back to the client pretty much forwarding that error to the client now you see that we have this other argument called user and what's going to happen is this function over here user defined by id in case there are no errors and in case it is able to find that particular user it will send that user to this callback function and it will be stored in this variable called user so now we have access to this user in this callback function from here to here by referencing this user variable so now what we want to do is that user variable is going to have a property called tasks id and pretty much in the same manner let's say that we want to get access to those tasks so we again like query the database for those tasks given by that id so we do pretty much the same thing and then again we supply the callback function again with uh error as a first argument and now tasks as a second argument and then we again simply check and if there were any errors we simply want to respond back to the client with those errors and if that wasn't the case we want to do something with those tasks instead so what we'd want to do is for example like imagine that that tasks had a property called completed that is a boolean type and we simply want to change that to b to true so now once we so now once we actually modified that row or document in our database we don't want to save those tasks and saving the tasks is again async operation because it is not done instantaneously so we again need to provide a callback function to it and this time we don't want to see to receive any returned value from it instead we just want to make sure that that operation was successful so then we simply check whether the error was there and if so we again respond to the client with such error but otherwise we simply respond back to the clients with the message of tasks completed okay so hopefully like this will make sense and you're able to understand like the flow and you're also able to understand like why is there a need for these callback functions and now let's take a look how all of these like the the exact same code is handled when it comes to the promises and this is a promises example and one thing you can spot straight away is like how how much clearer and cleaner this code actually is so this time what we're doing is giving that user that find by id is again the same function and it is again async function we simply call it and we pass whatever argument we actually want but then instead of supplying a callback function to this line over here what we then do is we take on the dot then function and then there we actually supply you can think of it like callback function what will happen once this operation is completed so you can pretty much read it like this like user.find by id requested user id like started this process and then once it's actually completed only then do you do whatever the code is over here so when that's done we can then get a handle on that user subject and then we can do something now here we are going to start another async function called tasks.find by id so we pretty much just returned it and then what happens is we can just attach on like another then to this piece over here and then this part over here will only get executed once this async operation inside of here is actually completed and now in the same manner we can do these lines of codes over here and then task.save is yet another async operation so we want to return that as well and then we supply another function that should be executed once this is done and now we don't need any parameters here so we just respond back to the client saying tasks completed now you might be surprised how we didn't do any error handling so far so what's going on is using promises you can actually call dot catch at the end which will catch all the errors for you and then we simply want to respond back to the client with such errors if that was the case so as you can see it's much clearer because one uh error handling doesn't need to happen all the time we can just like have a specialized piece of code that is going to handle errors no matter where they actually happened and to um as you can see we don't have that nesting pattern that gets really hard to read that is called um callback hell and sometimes it is referred to like christmas tree shape because as you can see it goes kinda like this and then the opposite so it is definitely like a much neater way to write async code in javascript now let's take a look at the same example using the async weight and here it is as you can see it's much much much much more clearer than what we've been able to see previously it almost looks like a sync and blocking code but fortunately it isn't so what's going on here is whenever you want to write a async await function you need to write this keyword async before the function keywords and once you do that you actually have ability to use this await keyword inside of that function that is declared to be a async function async await is actually all promises under the hood so like if you really want to get a deep and detailed understanding of async await feature it's best if you learn promises first but i'll do my best to at least explain you what's going on over here so first thing you can notice is we have this try catch construct and that is how you're able to handle errors in async weights functions so this sketch piece over here is similar to the catch piece we have seen over at the promises example we do all of our error handling inside of here and inside of our try block over here what we do is next we call this user defined by id and again we pass the parameters that we wanted but now we actually uh write this await keyword in front of it which will actually tell this function that this operation over here is a sync operation and it's not going to happen instantaneously so this pretty much awaits this function to be resolved and then it stores the result of it in the variable that we assign on the left and now this next line tasks equals away task with find by id will only execute after the user equals of eight users defined by id gets resolved so you can almost like read it like a sync blocking code so next we wait for the tasks and then we supply this user the tasks id as an argument and then we get those tasks and then we can simply like task that completed equals true like modify the tasks and we can also save the tasks and you can see because all these three operations are async we need to put this await keyword in front and then we can simply respond that send to the client back message saying task completed now if error happened during any of those three operations the execution flow will jump straight to this sketch block over here and it will respond back to the client with such error so i hope that now you can appreciate the abilities that asynchroid feature actually gives us as we do our daily javascript async programming so what i want to do next is i don't want to stop here but instead i want to go with you through a bunch of async await examples in which i could show you the sequential flow the parallel flow i also want to show you like all the loops and iterations that you can do with async awaits i'm going to show you some common gotchas that you might be unaware of at this moment and all in all i just want to like go through a bunch of examples so that you feel confident in your ability to start using this async await feature today okay so now let's do like a bunch of examples so that you can see all the ins and outs of using async weight in your code so what i've done is i've made like three different folders over here first we have a sequential then we have parallel and then we have loops so those are three topics that we want to go through and in each of these these topics we have like for the sequential we have like a naive approach then i'm going to demonstrate like an issue that happens with it and then i'll also propose a solution and that's the same with the parallel and then for the loops i'm just going to like go over like the different types of iterations that you can go with using a sync away and explain like what you can do and what you can't do so let's get started with the sequential project example and let's go in this naive approach so we have two files that we care about we have a main.js and we have a processes.js so if you open main.js file you see that we simply get a handle on those two processes that we actually have inside of that process file and the whole idea about this small project is that we have two processes that are async and that we want to run them sequentially so now like in that example that i've shown you in the slides we have this function main that gets called over here and then we attach this async keyword in front of this function keyword and then we do all sort of things inside of here so what we do is we await for those two processes and then what we want to do is we want to store their values in these two variables over here and then simply when all of this is done we want to use the console.log to actually print out to the terminal the value states we got from those two processes and then these consulate logins simply for like formatting purposes and we also call this console.time and console.time end functions which will tell us how long the the function has been running for in milliseconds and if there are any errors we simply constantly error them again to our terminal over here so now let's take a look in this process.js file and see what's in there so over here we just export uh two functions that are also async ones and in them we simply like output that process has started we again use time and time end to show to the terminal how long this particular function has been running for and likewise for this second one and then we we kind of fake this operation by simply waiting 5 000 milliseconds and for this weight function i'm actually using um set timeout but because settimeout is expecting a callback we're actually using this promisify function from the util package in node.js which will actually turn the set timeout into a promise based function that we can use inside of our async code so remember like the async is pretty much like promises with uh a different interface that we can interact with so we we can't really use callback functions inside of our async function all of that needs to be promises that's the reason behind this and i didn't tell this before but i'm using node for this because it's much easier for me to using all sort of things like these that are already built in but you can of course learn a single weight and use it for like everything that you do inside of javascript be it backend be it frontend your choice so hopefully like this is this is making sense like this is really a simple fake made up example and when both those processes are finished we simply return some value for example process 0 1 is going to return this process 0 1 dash value string and process 0 2 is going to return this value instead so now let's actually run this and see what's happening so i'm going to use my terminal let me just bring it up a bit and then i'm going to navigate to that directory and that subdirectory and then i'm going to execute node and then main.js as entry point so as you can see process01 started and it is taking some time and then it says process zero one ended and it took roughly five thousand milliseconds then the process zero two started and then the process zero two ended and that one took three thousand milliseconds and then we seeded processor one returned back to us this value and likewise for the second process and then we can see that the total running time for this entire example is eight thousand and so milliseconds and that makes sense because when you take a look here this one takes five thousand milliseconds roughly and these three thousand so that totally adds up so that's all good and as you can see uh it seems like it's working but you might have noticed that i didn't use try catch blocks inside of these two functions and that is kinda okay because if this or this function returns an error it will simply bubble up to this main function and then we are able to catch it inside of here so that's that's good but we'll see like what bad can happen in doing so in our next example and now i'll navigate to our second example and show you the changes so if i open this file main.js over here and i close the other one so i don't get confused we have the same code in our main.js file over here and our process.js file is also the same but we did add this draw new error line in this process 01 function so this is the process zero one is going to actually throw an error once runs and we'll see how it how it affects everything over here so let me quickly navigate to that directory and let's see what happens when i run it so i'm going to type node main.js and as you can see um process zero one started and then we get this error over here that process zero one failed so what happened is this code started going sequentially it came to this point over here um then the process zero one through an error and then the execution flow jumped straight from this line to the catch block over here and that's the reason why nothing of this executed afterwards so if you have multiple processes that you want to await sequentially these wouldn't really work because as soon as one process were to return an error the rest of them wouldn't get executed now sometimes this is really good because maybe if this process failed you just want to like exit everything and then you can use this approach but if you really don't care if this process year one throws an error or not and you simply want to get like as much value as you can from the other processes then this wouldn't work for you so now let's take a look at one approach that you can use to avoid having this sort of issue so i'm going to close both of these files and then i'll open this 03 solution directory and here we have the exact same main.js file but this time the process.js file is different we again throw new error inside of the process zero one and we again don't draw any errors in the process zero two function but we did add this try catch block into both of them and what's going to happen is as soon as this process 01 throws an error it is not going to actually bubble up to this part over here but instead it will actually jump to this line in the same function and simply do this and we'll see how this would totally like save our lives if we want to get this value no matter what happens with the first process so now let me actually start this example i'm going to go back again and go back into this new example and then i'll execute node main and as you can see process 1 started and process 1 failed but we're still doing something after that then we are starting the process zero two and then the process zero two actually successfully ended after three thousand milliseconds and then we see that we have undefined value from the process zero one since that is the process failed but we do have a returned value from the process zero two because that one was successfully executed and we see that the total running time for this small example is 3 000 milliseconds because this first one failed and then we didn't need to wait those 5 000 milliseconds to pass by so with these three examples um you should feel more and more confident in writing async obviously the more you learn and the more you know about promises it is going to benefit you a lot so even if you're interested in seeing kuwait exclusively i would suggest that you like take some time and go over promises in your spare time but now let's take a look at what happens when we want to execute things using a sync weight in parallel this time clear this console i'll close this file and then i'll navigate to our second directory that is called parallel and again as i already told you we have three different subdirectories so let's open the first one this is called naive and let's take a look at it so this time um the idea is the same again we have two processes and we want to run them but this time we want to run them in parallel and not sequentially that is what this small comment says and how can we do that well first of all let me take a look at the process.js file just to show that it is the same as we had previously and it is also stripped of try catch blocks and we are drawing no errors this time so in this main.js file what we do first of all is we have this promise that all function okay so what this promise total function does is it returns a single promise to us that resolves when either all of the promises in its argument gets resolved or if there are no promises over here and this promise that all also rejects with the reason of the first promise that got rejected in its argument so all of that might be a bit confusing but the most important thing is that promise at all will call all of these for us and will return a single promise for us that will get say completed when all of these are completed and if any of these fails then the promise dot all will also fail on that return promise with the reason of that failure and what we can do here is that the all the returned values from this get stored into this data variable that is actually an array and then if we wanted to access the returned value from the process zero one since it is the first element in this array we can access that by using the notation of zero so we we're referencing the zeroth element of this array and likewise for the second process returned value it is second element in this array and because it all starts from zero that is the first element in that array and if we actually run this example and if i run it we'll see that both process this time started straight away the process zero two is actually the first one that ended with three thousand milliseconds then the process 0 1 ended with nearly 5 000 milliseconds and we can see that we have access to both of those returned values and really importantly this time we see that the total running time of this example is 5000 milliseconds and it is not a thousand milliseconds like it was earlier because like we have those two operations and the operation zero one is the longest one so the running time is pretty much going to equal the longest operation that we are running because the other operations are going to be completed by that time so this is all great and it is working and now let's take a look at one potential issue that you might have with this approach okay so i'll close all of these and let's go into the second folder okay so the issue um okay so this is the same like it was before but if we come to these processes we see that it looks awfully similar to this example over here and in fact i tried to keep them in the same manner so the only change is this time we are drawing new error in the process zero one and let's see how that affects our promise.all um function now if you remember what it just said is that the promise at all returns a single promise and that single promise actually fails with the reason of the first promise that fails over here so let's see what happens i'm going to start this and there it is so we actually um let me bring this up so we started both of the processes and then the process zero one failed and then the process zero two ended but as you can see we don't this never got executed because it jumped straight to this block over here and the total time running we also didn't see that because again all of these was avoided because of that error so this is no good if you were interested in at least say this value over here no matter that the first one failed so um the solution is going to be pretty similar to what we did in the solution for our sequential problem that was of the same nature pretty much so let's quickly jump into it and see the difference okay so the main is the same and now let's jump into the process.js file and see what's changed and it is similar to what we've been able to see before so the only change is that we added the try catch blocks into both of these functions and again we're throwing new error inside of this processor one so let's see how that affects things so i'm going to navigate to that directory and then i'll type node main and as you can see so both of them um both of them start running but immediately the process zero one fails and then we get a notification that process zero two started but this could be slightly misleading because both of them got executed at the same time so let me make one small adjustment because now in the second look this could be a bit confusing let me just simply before we drew a new error let me actually just await um for let's say 100 milliseconds or so just want to show you that um but by reading this you might think that this this is executed sequentially because you see process one started process two process one failed and only then processor started but if i actually rerun this example now we see that both of the processes actually started then the process zero one failed and then the process zero two ended and now we have access to all of these over here because we handled the errors more carefully this time and we see that process zero one returned well we don't know it failed but we have access to this value that pros zero to zero to returned and it is correct one and the total running time is three thousand milliseconds because the first one failed and second one it was running for exactly that amount of time so now if you ever need to run some operations in parallel that are not depending one of another you can use the promise at all just be careful with the errors if any of such process can actually throw an error and most of the time they indeed can make sure that europe that you're handling those errors inside of them and don't simply rely on those errors bubbling up in your main because as you can see it will totally mess up the application flow so now we've seen sequential execution we've seen parallel execution now we're going to take a look at loops and iterations and see how can you do that using a sync weight so i'll quickly close everything and sorry i'll quickly close everything and then i'll open the loops directory and let's get started with a simple old good for loop so i'm going to open the main and this time the idea behind this example is different which should be cool because we got a bit too used to the old example that could be a bit boring by now so this time we have our secret algorithm that we made and we want to benchmark our algorithm and indeed make sure that it is running in the time that we think it is so what we want to do is we want to run it multiple times and figure out the average running time okay and here we have number of tests or number of runs that we want to to do and just thinking about that let me actually rename this number of runs because that makes more sense okay so we have number of runs that we want to do we have our main function and we have our for loop so as long as i is less than number of runs we want to do it and keep incrementing that i variable over here so we pretty much just want to evade secret algorithm 10 times in the loop but we want to do some but based on the description of this problem that we are dealing with we are also interested in time so i did pull in this performance dash now module for the node ecosystems and i'm simply saving storing it in this new variable and then what i simply do is i save the start time of each algorithm run and after it is done i then save the end time and then i pretty much like calculate the difference meaning how long the secret algorithm was running for and then we simply increment this variable that will hold all of the running times of our algorithms and then what we do is at the end we say total time is exactly that number of retries is number of runs that we have over here and then we say the average running time is we simply divide this total time by the number of runs we actually did and we simply format it to three decimal places and in case of an error we simply air it over here so it's so it is really easy the only confusing part could be this performance now but that also should make sense and now if i open this process file things are slightly different this time we again export some functions this time we simply export one function which is our secret algorithm after all and then we again use time and time end to measure the running time by the way um if you're wondering why we didn't simply use time and time end like we did in previous examples to measure this total time over here well it's because time and time dot end actually just outputs the running time in our terminal but we need to somehow store them in a variable and be able to divide them by the number of runs so that's the reason why we needed to use this as well so now let's let me get back to this so what we do is we simply await some time but this time isn't static so instead this is a small function that i wrote that will simply return a number between a and b so here we're returning numbers between 1 and 7 inclusive so both 1 and 7 could happen and then we simply multiply that number with 100 and that's how we get our milliseconds that this secret algorithm should wait for so it's really simple and it is all like just made up for this example but now let me run this and let's see what happens so i'm going to navigate to zero three loops and then zero one okay and now if i execute that example we see multiple secret algorithm runs over here in fact there are 10 of them we then see that the total running time so all of these values combined together is 5 000 and nearly 300 milliseconds we then see that we had 10 retries and one and once we divide this by 10 we see that our secret algorithm is running for roughly milliseconds on average so this is one example in which you can use simple old good for loop and you can see how the regular for loop plays really nicely with a weight we didn't do any new stuff really we simply awaited whatever we wanted inside of our for loop and everything was well so now let's take a look at the for each which i really like and i made a video about it in my es6 series and let's see what happens when we use it instead of this for loop so i'll close both of those files and let me open the main.js now for this example i wanted to create a slightly different example so that i keep things interesting and fresh so in this example we are actually running a grid of power plants and we want to somehow group them together in a single array and be able to quickly turn all of them on and off so we have this power plant class over here and let us first of all take a look at that so if i open this power plant file we see that this is a simple es6 class that is called powerplant we have a constructor and in that constructor we simply pass in an id now id could be anything so that's just like the name that will assign to that power plant in particular and then we have two async functions to this class we have turn on and turn off and what we are doing we are simply outputting that like turning on power plant and then the name that we gave it and then we're using time and time end to actually measure how long this turning on operation took and then we're using again the same weight weight and we're getting some random number and we're multiplying that by 200 milliseconds and then we simply do this for like to get a new line so that formatting is a bit prettier turn off function is exactly the same we're just like outputting different words to the console okay so it's it's really easy to understand and now inside of the main what we're doing is we're creating a new array new empty array of power plants then we are adding to that array a new power plant five times and we are simply giving them an id of zero one zero two through zero five and then what we want to do is really quickly to be able to turn all of them on and turn all of them off so we use the forage helper for our power plants array and then we get access to every power plant in that array and for each power plant in that array we want to have a weight in operation of turning it on and turning it off so let's see what happens so i'll navigate to that folder and i'll type node main and as you can see really quickly something is really wrong and it's actually not even running so it says syntax error unexpected identifier power plant which is a bit weird because we kind of defined it over here but the problem is simply that you can't use a weight keyword inside of your forage so if you wanted to use for each with a weight you unfortunately can't do it but there are other ways that you can and one solution to this problem is using the for of so we're going to take a look at that next so let me close this file and let me open this next example which is exactly the same so i don't need to do any explaining we again have the same situation we again do the same things we again have the same class over here so the only difference is this time we're not using the forage but we are using the four off which is you simply start with a four keyword and then you write like the name that you want to reference each and every element of summary a and then you simply type array name so for every power plant that will be in the power plants array we do something and now like this needs to match um our array but this over here you can call it simply x if you wanted this is just a new variable for you that is scoped for just this block of code and then you can use it over here so i'm going to undo that because this makes more sense but just so you're aware this is this is the same that you had over here so you could call this one x as well okay so now in this four four of um example you can see everything is the same and simply let's run it and see if this works this time so i'll go back and i'll go in the for off example and i'll start that off and as you can see it seems to be working so we are turning on power plants so we turned on powerpoint zero one zero two zero three zero four zero five and all that worked and then we proceeded to turn all of them off with this piece of code over here and we turned them all off so this is example how you can use the four of and how you can't use the for each so that should be main takeaway from these two examples over here and now for the final example let's take a look at the while loop so i'm going to close both of these files and i'll navigate here so this time we're back again in our benchmarking example so we're benchmarking our algorithm again let me simply um rename it like i did in the previous okay in the previous example so we have really similar so the the sixth algorithm is the same so i don't need to do any explanation over here but the main is a bit different i mean i made it so that we really want to use while just so that i can demonstrate while loop so what he did is we have this retries variable that is equal to zero and we have total time which is equal to zero and then we simply repeat this piece of code over here while the number of retries are less than the number of runs so this over here will run 10 times and then again we store the time before running algorithm we store the time after running the algorithm and then we save the difference in this variable over here now after each run of this algorithm we want to increment this retries otherwise this will be in infinite while loop and then at the end we simply output total time number of retries and average running time this time we can either divide it by number of runs constant or we can divide it by three tries because they will store the same number in the end so let me do that let me run this example okay node main and let's see what happens um secret algorithm starts running 10 times and this is our average running time so this example i simply wanted to demonstrate that you can use while and that you can simply use a weight keyword in the while and everything works as you would expect it to so and this is it i have run out of examples unfortunately so i don't have anything else to show you but let's simply do a quick recap so we've seen that during the evolution of async programming in javascript we had different approaches with dealing the async code we started with callbacks we've seen that while they do get the job done it isn't the prettiest code ever and it can get really tedious to follow the logic of the the code that you wrote so that that is a downside of callback approach then we have seen that the next best thing were promises and in fact promises we are also going to use promises in our async code you've seen that promise.all function you've seen that if you have some legacy code or simply the the module that you're using is is implementing the callback interface meaning it is expecting you to pass in a callback function you can't really use it directly in your async function but what you can do is turn that function into a promise and then you can use it with a weight keyword so promise is really important they are what allowed the async to actually function so be sure to like study on promises then i briefly mentioned generators now i don't really have much experience using generators so i didn't want to rush in and like create some examples because i don't think it's really necessary given that we have access to uh to async await nowadays and then finally we've seen about the sinkhole weights we've not only seen like a difference in code that it produces in the slide but i also like walk you through all of these examples and you will learn how you can do sequential things using a single weight like this you've seen the potential issues you've seen the potential solution in the strike catch then we went over the parallel flow you've seen how you can use promise at all function over here and then we again seen some issues and some solutions and then last but not least we've seen how you can use a single weight when you need to iterate over through some data and we have discussed for loops for each for of and while so all of that should help you out in the future and i hope you learned something from this video it is a really long one so congratulations for sticking with me through the end hopefully you learned something it wasn't too complicated to follow me and if you liked it please leave me a like if you dislike it please dislike it and if possible let me know what i can do to improve in the future thanks for watching see you in some of my other videos