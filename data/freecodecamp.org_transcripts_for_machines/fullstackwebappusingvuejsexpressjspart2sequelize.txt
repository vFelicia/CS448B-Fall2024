hey everyone i'm cody cyber and welcome to part two of building a full stack web application using vue.js and express.js so if you remember on the last part one we built a register page which hits a slash register endpoint on the server so in this part two one of the things we're going to do is actually connect to a database or have our api connect to a database and in this case we're going to be using sqlize which is an orm to connect to like sql related databases such as like mysql or postgres or sqlite um a couple people asked if we could do mongodb but i also i feel like you know sql databases are still one of the most popular ones so i think it's more important to learn how to use sql versus mongodb and also i think the data that we're working with is relational which is another reason why i think we should be using sqlize to connect to a database to store these relational models all right so before i get started with bringing in sqlize let's go ahead and just look at it really quick so inside the sqlize project they have this these docs defined these docks are pretty good they're not the best but um if you read through these you can get a good understanding of how you use sqlize you know how you define models how you can use models but basically then in a to sum it up sqlize provides you with data models where each model maps to a table in a database so for instance if you wanted to create a user model that has a email and a password you can just create a sqlized model and then it'll automatically connect to whatever sql database such as sql lite it'll create your tables and then create your columns for that table and then you can use objects inside your node or express server to kind of manipulate that data or add records or move records etc that's kind of all i'm going to cover with the sqlize documentation so let's just go ahead and get started using sqlize so start off we want to first install those dependencies so on the right i'm going to say npm install save sqlize and we also want to include sqlite 3 and i'm going to do version 138 just because i ran to an issue in the past with a newer version of sqlite3 so anyway when that stuff is done installing it shouldn't take too long what we can do in the meantime is we need to first kind of get our project set up to start using that sqlize package so to start off we're going to go ahead and pretend like we have a file called models which is going to export a sqlize object so if i do consequence equals require dot slash models if i spell that correctly so basically we're assuming that there's a models folder which has an index.js file which returns an object that has a sqlize attribute on here and what we want to do is just go ahead and do sqlize.sync which will basically connect sqlize to whatever database that you have it configured for and then create the tables if they don't exist and just get everything that's set up and ready to go and once you're done sqli or syncing sqlize to your database we're going to go ahead and just start our server and to kind of make this more useful when the server starts just go ahead and print out a message so we can actually know when it started so i'll say console.log server start it on port and i'll say config port and then here i'm going to refactor this a little bit and just say config port you'll notice that we don't have anything called config defined in this file so up here i'm going to say const config is equal to require slash config config so the first thing i need to do is create a new folder called config and i'll create a file inside that folder called config.js inside config.js i want to export something that says port 8081 so now app.js can include that file and then kind of use whatever is defined in that config to spin up the application another refactoring i'm going to do before i actually start working more into sqlize and define the models is if you notice here we have the routes defined it's kind of useful if you have a separate file where all your routes are defined so what i'm going to do is in the source folder i'm going to make a new file called routes.js and that's going to export a function and basically what we're going to do is cut that code out and put it inside that wraps function or that routes.js module save that file and then here what we can do is just go ahead and require that file so i can say const actually i could just say require routes and then i'm going to pass it app because if you remember our routes file basically just returns us returns a function for us where we can pass an app and it's going to just go ahead and attach all the different endpoints onto that application or that express application variable all right so by this point sqlize and sqlite3 should be done installing which it is i'm going to go ahead and just close out of that tab and then additionally we're seeing an error print out because the routes file does not have a new line at the end of the file so i'm just going to fix that really quick do the same thing with config okay so it says right now cannot find module models because we haven't even declared that yet so that leads us to the next step of part two which i'm going to start building up a a user sqlize model so to start off let's just go ahead and make a folder called models and inside here i'm going to make a new file called user.js which is going to be my user model so the first thing you need to do is if you read through the sqlize documentation you can kind of figure out how you define sqlize models and we're going to do a little bit of custom logic and linking for our models so that we can kind of easily put new models into this model folder and not have to worry about importing it somewhere else so what i'm going to do is i'm going to say user.js is a file which exports a function which takes sqlize and data types and then what this is going to do is i'm going to use sqlize to define so you do sqlize define a new model so the first argument is the name of your model which is going to be user and it's going to be used for storing user related information so first one we want to or so the second argument here this is are the options or attributes that are attached to your table or model so the first attribute we want is email because you know you sign up with your email and password so say that's going to be called email and the type is going to be a string and then we're also going to say that this is required to be unique because we don't want multiple users signing up with the same email account and then the second attribute we're going to say it's going to be called password and it's also going to be a string so this point again user.js is a function which takes equalize and takes data types and then it's going to return or define a user model which we can use so now the next step is if you remember in the app.js we included slash models so we need to create a index.js file and inside this index.js file we want to do a couple of things first we're going to declare a db object which we're going to export later on but more importantly we first want to include a fs module which is the node.js way of like reading through the file system we're going to include the path module which is used for kind of dealing with you know absolute paths relatives paths or whatever it's so we're going to use that in conjunction with fs um we're going to include the sqlize model because we're going to need that to actually create a sqlize object and connect it to a database we're going to include that config file that we created earlier and okay so at this point the first step we're going to do is we're going to decline declare a sqlize object so we can say consequence is equal to new sqlize and that's going to take in a couple of arguments so the first argument is going to be the database that we're connecting to so let's just assume in config we have something called db.database and we can also assume that we have something called user we have something called password and then lastly we have additional options that we can pass to sqlize so at this point what we can do is we can go in to that config file and i'm going to go ahead and declare a db attribute which is going to have that database it's going to have user get a password it's going to have options so for database we're going to load in a couple of environment variables and fall back to tab tracker so this is the name of the database that we're going to use so typically if you have like mysql or postgres you create a database so your postgres instance is going to have like 100 different databases inside of it and each database has a unique name so we're say database is equal to this environment variable db name or tab tracker and we're going to use this later on when we like deploy to a real environment but it's good just to have this here in the meantime and if it's not defined we're going to fall back using the or to tab tracker and the same thing with user we'll say db user password process env db pass and that's also just going to be tab tracker for local and then finally when we get to options there's three things we need to define so first is dialect and that's a useful option in sqlize to tell it what type of database you're going to be connecting to so obviously we want to set that to sqlite when we're local we have host and that's used for telling sqlize the location of the database that you want to connect to so in this case we'll say localhost is the default and then lastly we want to put storage for sqlite and that furniture tells you where to store your sqlite file so i'll say tab tracker sqlite cool so at this point we have again a config file that declares the port in fact i'm going to do process env port or 8081 so we can overwrite that as needed and then we have an attribute called db which has all the different sqlize related configuration we need so this if i go back to models folder and then index.js you can see how this makes sense that we're just grabbing that config and passing it to the sqlize constructor here now the next part is we want to just go ahead and write some short functionality to just automatically read through all the models in this models folder and set it up to be used with sqlize so i'm going to go ahead and do fs dot read sync and then pass it down name so basically this is going to read through the current directory and give us an array of different files and i'm going to filter out any file that is equivalent to index.js so we don't we don't want this index file but we want every other model file and then after we do that filter we can just say for each file that we found we want to go ahead and declare a model and basically sqlize has a import method where you can give it a full path to a file and it will go ahead and just import that and set it up to be used with sqlize so i'll go ahead and use path.join to join the door name to the pet file and then tell sqlize to import it and then finally we can say set the db dot name of the model so in this case would be db.user is equal to model and then lastly we can just go ahead and declare a couple of useful variables onto this db object so i'm going to declare db sqlize and capital sqlize so that when we use this in our code we have access to the sqlize object we have access to the capital sqlize object and then we have access to the actual models alrighty so at this point let's go ahead and make sure that you know we don't have any linting issues okay so we saw that the server restarted itself when i saved some of the files and then it executed this sql command and said create table if not exist users and then it gave that table a couple of columns such as email and password and that's about it so basically sqlize will create your table if it doesn't exist and give it the columns that you've defined in your model and that was pretty easy to do like a lot of this stuff like this we didn't even need to do but it's more of a helper function that allows us to easily add more models down the road without having to like for each one require it import it and set it up in sqlize okay so again as a recap we installed sqlize so if you look at package.json we installed sqlize and sqlite3 sqlize is an orm used to connecting to sql databases and sqlite3 is a local instance of a sql database without having to go through all the extra work of setting it up and whatnot and then once we installed those we're going to we went ahead and created this models folder which has a sqlize model which we're going to be using for our user accounts which has an email and has a password and then we have this index file which is basically used for connecting to our database which is going to load in a couple of configurations which is defining our config right here and then it's going to go ahead and read all the files that are in this models folder that do not equal index.js and it's going to go ahead and load them into sqlize and then we just go ahead and return that which we can use later on so at this point we can actually start modifying our route to use this sqlize stuff so another thing i'm going to do let me just close out of all these tabs so we're requiring routes here so if i open up the routes file i think we're done with app.js for a while something that is useful and you'll see this on a lot of frameworks is that you're going to have a folder called controllers and a controller is basically where you have all of your endpoints defined so inside controllers i'm going to go ahead and create an authentication controller dot js file and inside this file we can go ahead and just export our model or export whatever routes should be associated with authentication so in this case we obviously want to have a register route right so if i were to do this and just put that same function let me just get rid of uh this stuff so basically i took the same function that was defined in route and i put it in register but we're only caring about the callback function right here which is the express endpoint or middleware or whatnot and then what we want to do is in routes we can up here just go ahead and include that so we can say const authentication controller is equal to require controllers authentication controller so then whenever we hit this register endpoint we can just say authenticate authenticationcontroller.register so this is a nice way to kind of simplify and keep everything isolated so your controllers again are used for declaring all your endpoints and then your routes are for declaring your routes that point to your controllers so again just to make sure this works let's go ahead and hit that register endpoint and make sure it returns that message and it does everything's still working as expected so now we can actually start implementing some logic to kind of create a user model and save it to a database when someone hits this register endpoint okay so if we take a step back and just talk about what we're trying to do or if you remember from the front end the user is going to pass us an email and a password in the payload of the json all right so on rec.body we should have an email and a password and we already demonstrate that we have email here because we're returning that message so what we are trying to do is we want to create a new user record and store it into our database whenever someone hits this endpoint so first of all let's go ahead and insert or not insert but let's import or require that user model that we declared so we can say const user equals require dot dot model or actually this would be mod tools because we're going to include that index file.js which had all the models declared as attributes on this object so now we can actually use that user object here that we defined inside of our callback so what we can do here at this point is we can say const user is equal to await user.createrec.body i'm going to go ahead and get rid of this stuff for now and of course i'm going to use async instead of promises because it just makes everything cleaner so basically we want to create a user using the body that was passed in on the request and that will create us a new user and if for some reason there's any error such as you know user or email already exists we're going to catch it inside this try catch statement so if we get an error we can say res.status is a 400 error and then go ahead and send some type of error message so in this case i'll say this email account is already in use and you've seen that on front ends where you try to sign up for the same website with the same email account it'll tell you like you know this email account is already in use so this will be returned to the user if this fails to run for some reason and then if it is successful we can just go ahead and send back that information so i'll just go ahead and say res.send user.2 json to basically send back that user object to the client who has requested this endpoint so go ahead and save this file make sure that there's not any linting issues or crashing the server seems like everything is fine and what we can do at this point is if i go to register and i go and try to pass it testing gmail.com it should return a 200 status with that user object that was created right so now this is actually inside the sqlite database we actually have a user so if i were to try to do this again we should get that catch error back it says this email account is already in use all right so that's pretty cool i mean we have a server running that's connected to a database using sqlize we're able to store information inside the database at this point we can't really grab it yet from any endpoints but we've demonstrated that yes the data has been changing because now we get this error account our error message back when we try to create an account with the exact same email and again the reason why that constraint is failing is because in the model we added line five which is unique true saying that the email has to be unique so it can't already exist inside that record okay so at this point you may say okay well if i were to try to pass in a bogus email account so like one two three to this endpoint it's still gonna work it's still gonna try to create an account with that email so another useful thing to do to have on your backend is validation so what we're going to do at this point is let's go ahead and make or include another framework called joy so i'll do npm install save joy and joy is a framework used for validating the request dot body the request.query or the request.parameters and so as an example of how you set that up typically in these bigger frameworks you're going to have like another folder called like policies so i'm going to go ahead and create a folder called policies here and i'm going to go ahead and create an authentication controller policy and inside this file we want to kind of create express middleware which is going to validate that certain requirements or data constraints pass or fail so to start off we'll say module.exports and then we're going to export the name of the exact same method that we've used in our controller so we'll call it register it's going to be a function which takes wreck res and next and what we want to do is first we need to include that joy framework that we just installed which should be done by this point yep it is so i'll close that and then we also want to go ahead and actually that's all we need to do right there so again we included the joy framework we created this module which has a register method and for now i can just say call next and how do we actually use this right so if we go back to routes we can include this up here and say const authentication controller policy is equal to require and i'll just say policies so go ahead and require that in and then what we want to do is call that policy as a middleware function before we hit our controller so how this works in express is we're going to hit this endpoint and it's going to continue to go down the list and invoke whatever middleware that you have defined so it's going to hit this controller policy.register file which is declared here and then when this method calls next it's going to go ahead and go to the next line which is going to be our registry endpoint which again is defined here so again this is express middleware you can read more about it on their documentation page and i think it'll make more sense as we continue making more endpoints down the road so what we want to do inside this middleware function is we need to validate that email and password kind of match a couple of constraints so the first constraint we need to do is we need to do const schema is equal to an object and in that object we're going to have email we're also going to have password and email is going to be required to be a string and it's also going to be required to be an email format so joy has a bunch of different like builtin prebaked validations and email is one of them so we're saying email has to be an email and then password we can say make sure it's also a string and make sure it matches a particular regex expression so i'm just going to pass a new regex expression and what we want to do here is pass it character class of a through z capital a through z or zero through nine and then of course make sure it's at least eight to thirty two characters long and then go ahead and put a money sign to end that string so i think i might i think i did that correctly so basically again email has to be an email address and then password has to be a string which matches this regex expression and again if you don't know much about regex you should probably go read up on regex but basically we have these classes which say everything that's passed in has to be the character lowercase a through z uppercase a through z or zero through nine and it has to be a minimum of eight characters and a maximum of 32 characters so after we have the schema defined we need to actually use it so we say const error value is equal to joy.validate and the first parameter you do for validate is you need to pass it the thing you're trying to validate so in this case we want to validate the request body and we want to validate it against our schema so this will return an error if there was an error so i'll say if error else we just go to the next so basically if there's no error everything's good we just go to the register endpoint and register that user if for some reason there was an error we need to figure out which validation failed so i'll say switch error details of zero context of key so that gives us the key that failed in this case it's going to be either email or password and then we're going to have a switch case and just check if it was email we need to do something if it was password we got to do something and then default do something else so starting off if for some reason the email validation failed we could say resolve status of 400 and then go ahead and send an error message saying let's say like you must provide a valid email address cool and then for password a similar thing but we're going to say uh this time let's just return a little bit more information so i'll say the password provided failed to match the following rules and then we'll just make this html so we can easily format this i can say it must contain only the following characters lowercase upper case numerics and then i'll say rule 2 is it must be at least 8 characters in length and not greater than 32 characters in length so again if there is an error we check if it was an email error we can send back you must provide a valid email address we check if there's a password error and say you know the password has to match these rules and then otherwise we can just say like i don't know resident status of 400 send an error saying like invalid registration information so that should make sense let's just again do a recap we included the joy framework which is used for validating different things in express then we created a module which has a register method which is an express middleware which takes a wreck a res and a next and again rec is the request that comes in res is what you use to send something back and next is what you call to invoke the next thing in the routes path and then we declared a schema which says emails must have an email structure passwords must match this projects we validate the against the schema here we check the error we check the key of the error and return different error messages depending on what failed and then if everything was good we just go ahead and call next so at this point i'll go ahead and save that file and i'll double check to make sure that we don't have issues so on the routes we have no trailing spaces let me go to the routes file cool all right so now at this point let's go ahead and test out that the policy is working as expected and to do that we can again go back to postman and we can try to pass it bogus data so we'll say pass it just testing sends back an error you must provide a valid email address with a 400 bad request response and so if i were to give it a good email address and try to send it's gonna say the password provided failed to match the following rules so cool that's working if i go to seven and eight and send that it says this email account is already in use so i'll change that and see what happens so boom we're allowed to create a 123 at gmail.com with the password one two three four five six seven eight and it returns us back the exact user that has been created all right so now at this point we have a pretty good setup for registering a user into our database and we have policies that kind of return errors so that the user knows what exactly is required um we also need to at some point hash the password because you're not supposed to be saving no raw passwords into your database but we can kind of cover that in a second so let's go ahead and move to the ui again so if i go back to that register component up here just a recap we had an input for email and input for password and we had a button to register okay so now that the backend is returning different error codes and messages we want to kind of display that in our user interface so what we can do is if we want to catch the error that's returned we can go ahead and just wrap this in a try catch so if for whatever reason authentication service fails to return or if it fails to for whatever sorry let me rephrase that for whatever reason authentication service the endpoint returns a status other than like 200 or whatnot we can catch that error here and we can go ahead and say this.error is equal to let me change this to response actually i'll say error so i'll say error.response.data dot error and this is basically what is returned from axios and then error is going to be that message that we've defined and of course if we're going to try to access this.error we need to define it in data oops and then lastly we need to kind of print that out so up here if i above the button i could just do div and i could say v html is equal to error i can just close up close that off here and again put a break i'm also going to say that this is going to be a class of error so down in the style i can say error is equal to color of red so if i were to save this file now and then try to register with some bogus data we get you must provide a valid email address change to gmail.com password provided field to match the following rules it seems like that kind of truncated some of the data so maybe this isn't like big enough let me just double check what's going on here because it looks like it's returning okay so in my my back and you see there's a little i'm missing a carrot here so let me just go back to my backend code really quick to my authentication controller actually i'll go to my policy and i'll change that to that now if i try to hit the end point again boom okay so we get the actual full error message now cool so again as a recap i didn't really explain view components before but basically every dot view file is separated into three sections you have your template which is used to define your html template and then inside your html you can have special attributes like v model or v html technically anything that has v hyphen is a view specific attribute and that's used to kind of bind to your script tag down here which is the second part that every dot view component has and the script is basically an object that has a different lots of different methods on it so data is the data that you can bind two way in one way to your template and then methods would be any type of method that you want to be able to access from your template and there's a couple others which we'll cover in the future but it's just for now we just focus on those two and again the last one is your style section which is going to be in this case scoped so any styles you declare here will not affect anything else on your view application assuming that you have scoped so dot error will only work for this template so again everything in view is really like compartmentalized and isolated so it's really nice um let's try to think again here's an example at click means whenever the button fires a click event call the register method which is what you saw down here that's how we're calling register so just a little bit more information about the view component that i don't think i really talked about in part one i kind of started doing stuff without talking but hopefully by now that kind of makes more sense all right so for i think the last thing i'm going to do in this part 2 video is i want to kind of bring in a new um project inside the front end to allow us to see easily style and kind of do layouts so there's a there's a um a project called beautify which is a framework that can be used to build like material designs apps so again their documentation is pretty good here on the left it has like you know all the components you can use so if i wanted to do like a grid list or a form they give examples of how you do it you can go and check out their code here they give you a template um i think you can see the code somewhere maybe not let me find a different one data tables here we go so again they give me an example of a data table you can go here and view the source code what you get is the template and they give you the script here so again beautify is just a framework that's used for building really nice material design apps so be fit feel free to check it out and that's what we're going to be using so what we want to do to include this in our application is we first want to go over to again our terminal and go to our client and we want to mp install a couple of things so first of all we want to include beautify and i think actually that's the only thing we need to include is just beautify okay so now that that is done installing we can just go back to our ui and we want to include it so if we go to our main.js file here up here we can just say import viewtify from view to phi and then we also want to import the style sheet so i'll say beautify dist beautify min.css and then to kind of enable that we can say view dot use viewify go ahead and save that and hopefully assuming i didn't forget anything that should kind of load in the project so now we have the beautify and the beautify css ready to go so let's go ahead and try to style this there's some there's a cup of the design i kind of like doing is putting stuff in panels with like a drop shadow i'm not really a style or a designer so um feel free to critique me or give me feedback so what i'm going to do here is i'm going to go to the register.view file here and beautify gives you the ability to kind of like change up your layout so they give you something called like v layout and you can pass it like a column layout so i'll do v layout and this is pretty much um like flexbox so this is a v like a flex grid or whatever and then here we can do v flex which is going to be a flex item and then you can change it kind of like a bootstrap where you can change it depending on the size of the screen we can say for small screens we want to offset it three and then just make it a width of six and then in here we can say let's make a div and then the beautify css gives you a couple of um prebaked css so we can give it an elevation of two and a white that's going to make like a white um panel with a little bit of box shadow or drop shadow another thing we can get from using beautify is a v toolbar so it's a v toolbar i'll pass it a flat and a dense attribute and i'll give it a class of cyan i'll give it a attribute of dark so that it turns the text white and then inside the toolbar again this is on the beautify examples so if you just want to go and copy and paste from their examples you can do that too um so let me just make sure i got this all right basically i can copy this code out and put it underneath here wrap this in a div in case we need some padding and then also beautify gives you a couple of classes so i can do like padding left is four padding right four padding top two padding bottom of two so make sure all these line up kind of running out of energy so i might wrap this up pretty pretty soon so hopefully if i save this it should be a styled panel with register and then we have our email account and we have our password here and then we have a register button in the button we can actually change from button to i think v button so if i were to do v btn give it a class of cyan should change this to a register button so that's i think good enough for right now we can come back and make this a lot nicer looking but i'm kind of running out of energy so stay tuned for part three and again as a recap we included the beautify project which again you can find the docs here on beautifyjas.com they have a bunch of different components and styles that are prebaked it's really awesome library so check it out and then we use beautify the kind of style this register panel i think part three we can just try to fix the styling and do more by adding like a header or side nav or something like that all right thanks for watching and stay tuned for part three it should be coming in a couple of days hopefully thanks for watching