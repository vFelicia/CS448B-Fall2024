Astro is an allinone web framework for building fast contentfocused websites like landing pages blogs technical documentation and more in this course James Q Quick will teach you about this increasingly popular framework James is a popular instructor and keynote conference speaker he's the perfect person to teach you about Astro let's learn all about Astro one of the most exciting and upandcoming JavaScript Frameworks my name is James he quick and I absolutely love Astro so in this crash course we're going to cover some of the Core Concepts of Astro along the way we'll talk about file based routing creating and managing markdown and MDX contact with content Collections and typescript we'll talk about Dynamic routes and we'll even at the end of this video get into deploying this to netlify and versel we'll also talk about the serverside capabilities of Astro going from a statically generated site to a serverside rendered site and show you how you can add server endpoints to your Astro application as well lastly we'll talk about a few neat features of Astro along the way like view transitions which allows you to add beautiful transitions between your pages and your Astro application with just one line of code now if you enjoy what we cover in this crash course and you want to learn more you can check out my full course at astrocourse.dev to learn all the ins and outs of Astro 3.0 that said let's go ahead and get started let's start on the Astro documentation page where we can see the getting started instructions for creating a brand new project with Astro version 3 which is the most recent version of Astro now on this documentation page they kind of give you an overview some of the things that we've talked about some key features Etc and then if you scroll down they'll give you a couple of ways to get started with Astro one cool way to do that is with the astro.new website and what this is is a collection of different Astro projects that you can open up that have already been created and kind of get started working with them right inside of Stack Blitz now in this case we're going to create our own project from scratch so we're going to do this inside of our own vs code window and terminal to be able to create the project and then go and work and build out the tutorial or the blog that we're going to build now one thing I do want to show and we'll kind of reference this throughout this crash course is the ability to search for anything that we might want in this course on the Azure documentation page so once you get to the Astro docs you can come up to the top left and you can click to open the search window and you can search for a server or anything server side rendering for example and then click on one of these and go straight to those pages the other thing I want to show you that's pretty neat is on this page you can hold command K on Mac or control K on Windows to be able to pull that up as well so you don't have to go and click that yourself you can just open that with the shortcut window that said what we're going to do is copy this command to be able to create a brand new Azure project and then run this in our terminal so that we can get started so I'm going to scroll over to my vs code window and this is an open mtvs code window and I'm going to first switch over to the directory that I want to create the project so I'm going to switch into code and then my demos directory and then from here I'm going to paste in that command from the Azure docs to create the new project so once I press enter this will ask me a few different things first of all are we okay installing the package that's needed to generate our project and this is actually a good error to have here so with the latest version of Astro you're required to have a version 18 or higher of node.js to be able to run the installer so I wanted to leave this in as a reminder that you'll need to be working with a version 18 or higher now for me personally I use NVM to manage my different versions of node to handle this this is the easiest way that I found to handle working with different versions of node so I can use my NVM command and then NVM use and then type 18 and this will let me use a version of node that is a 18. now I can also use NVM to install a version of node like 20 for example and that will go and install a different version of node that I could use at any time but in this case since I'm now using version 18 I can scroll back through my commands and run that same create command inside of my terminal now you see we get the really awesome animated experience where Astro is going to walk us through creating this new project so in this case we need to give it a folder that we're going to create the project in I'm going to call this FCC Astro crash course so you'll just do dot slash and then whatever the folder is of whatever the name is of the folder that you wanted to create in this case we're going to start with sample files you could also choose a Blog template where they'll have a lot of the stuff done that we will be building from scratch you could also additionally choose an empty project to just start completely from scratch in this case we'll accept the sample files and what it's doing now is it's going to start to copy over the sample files which is done and then it's going to ask whether or not we want it to install the dependencies and we can press enter on yes and let it go and run and install all of these dependencies so we'll let that run for a second and come back when it's finished all right so those dependencies have been installed and the next question is do we plan to write typescript which in this case we do so we'll click yes and then we'll choose the strict or recommended version of how strict with typescript we should be lastly the question is do we want this to initialize a new git repository in this case we'll say yes because we're going to use this repository to deploy this later on to netlify and versel so we'll click yes here and then we get our out animation from Houston which is the Astro mascot we'll come back to Houston in a little bit and the next thing I want to do is open this project inside of vs code so I can use the command code R which means to reuse the window that I'm currently in and then I'm going to choose my SEC Astro crash course window notice it pops up here with this intellisense if you're curious where this little window is coming from this is coming from an extension called fig dot IO which is really great to kind of supercharge your powers inside of your terminal so I'm going to press enter and then we'll open this up inside of that same window in vs code and now I'm going to go to the bottom and open my terminal again and inside of here I'm going to run npm run Dev and this should now start our Astro project and it will run it at Port 4321 they chose this port because it is kind of like four three two one blast off which is kind of neat so I'm going to open a new tab in my browser and open up my browser to localhost 4321 and you see this is the starter application that we get with Astro where we have a welcome to Astro we have a little code challenge of how to make an update to this which is right here then we have links to documentation integration themes Community Etc so we have our beginner Astro application created let's go and walk through the code and talk a little bit about what all is there so first off we have our public directory this is where we would store any public assets like images or other things that we want to be publicly available from our site now these are going to be directly available after the end of the URL so what this means is since we have favicon.svg we could come to the end of our URL and type in favacon.svg and now that'll take us to that file which is not going to show a whole lot because it's an SVG and we're not going to have good visibility here but we do have the access to be able to access that directly so anything that you put inside of the public directory will just be shipped with your built version of your site and included and would be available after the slash in your url after that we have our source directory this is where all of our code is really going to live and what Astro really depends on is this page based routing where we have different files under the Pages directory are going to represent as you might have guessed it different pages in your application so let's just open the index.astro file and take a look the first thing we'll notice is that it is a DOT ASTRO File it's not a DOT JS it's not a DOT TS this is dot Astro and this obviously is going to signify to the developer to yourself and to your editor we'll talk about this in a minute that this is an astro component now Astro components are made up of two different sections there is the kind of JavaScript section which goes in these three dash blocks we could call these front matter we'll talk more about front matter inside of markdown files but inside of these three dash blocks we can add any sort of JavaScript that we want including importing other components so you can see we import our layout and our card and in this case we can find both of these in their appropriate directories under layout is the first one if we scroll down we see a reference to slot now slot is where we're going to take whatever information is in between this component when we use it the layout component and then inject that right inside of the component that we have defined here so what this looks like if we come down to our index.astro since we wrap this entire page which has a lot of code in it since we wrap this entire page with this layout component all of the stuff in between the layout tags which is here all of that is considered the slot and that will be rendered inside of this layout component right here so inside of the body now inside of the layout you'll also see a few other things you'll see that we can Define typescript interfaces for our props after we Define those we can then destructure those properties and then use them inside of our application just like we're using the title inside of the title tag inside of the head for our application now notice we can use these JavaScript variables by putting them in between the two brackets so inside of these two brackets we're able to basically kind of write JavaScript here which enables us to use variables that we defined up above so in this layout file you'll also see the other components that make up a basic HTML file you'll see the doctype defined at the top you'll see the HTML tag you'll see head and we'll we'll see a few different of our meta tags here like description viewport Etc we'll also see a reference to our title and then if we scroll down we'll see a lot of CSS in here now Astro has a few different ways that you can write CSS one of the ways that you can do that is just by adding a style tag right inside of your Astro components now this may or may not make you excited this is something that gets debated about whether or not your style should be colocated with your actual markdown and with your JavaScript but in Astro you have the ability to write all three together so your JavaScript your markup or your HTML and then your Styles in here as well now style is typically in here are scoped to a given component so you can see here that we have an is global tag that's associated with this style which means all of these styles are going to be applied to every single page on our application versus if we go to our index.astro component and scroll down there's going to be Styles here and these styles are not Global they're only referencing material that's inside of the component that it's in which in this case is a page component which is the index.astro now we can see another good example of this with the actual card component you can see we Define our props here we destructure those props we have markup we reference those properties inside of our markup and then we also have style tags down here as well now again these styles are only applying to things that are inside of this card component and won't be applied anywhere else so an example of this is if I were to select the main tag and did a background color of red this actually won't appear to have any difference or make any difference on our application and that's because there's no main tag inside of this card component and these styles are only applied to that however if I went to the layout and I now chose to select the main tag and did a background of red now we'll see that this red color is going to come into play because these styles are Global and are going to be applied anywhere there is a main tag so really important to remember that the Styles inside of Astro by default are scoped to that component and won't be interfering with other styles that you have in other components now in this case in this crash course we're going to use Tailwind CSS to style our application so we're actually not going to worry about all these styles that are defined inside of here we'll come back and clean these out in a minute and kind of reset this with some beginner styles for us to work with but if you were building an Azure project yourself you do have a few different ways that you could choose to do CSS in this case we are just going to use Tailwind CSS which has become incredibly popular so that's the majority of the basics of the layout for your code inside of the source directory there's a few other files a git ignore file which is pretty standard there's also the astro.config file and this is really important because this is where we can add Integrations in Astro we can also Define different things about our project like how this project is going to be built and where it's going to be hosted so by default Astro is a statically generated site we'll talk more and more about this we don't have to configure anything for that to be supported but if we wanted to convert this to be a serverside rendered site we could configure this in here and then configure where and how we want to deploy this at the end of this video we'll talk about deploying this to both netlify and versel but in this case we don't have anything to change yet in the Azure config although we will come back to this shortly next up we have our package.json with a few commands on how to run the project we have the readme and then we have a TS config which just extends the typescript config that comes from Astro so is going to give us all the basic rules for working with typescript inside of our Astro project you could go and customize that in any way that you want to but in this case we don't need to now I want to take a few minutes to talk about setting up your vs code instance to work with Astro in the best way now the most important thing you'll need to install is the actual Astro extension which comes from Astro themselves now what this does is it allows these Astro components these Astro files to be recognized as Astro files so that we get appropriate intellisense coloring Etc so notice down at the bottom here that vs code is recognizing this as an astrophile and then based on that and based on this extension knows what to do and how to color this now if we were to disable this just to show you what this looks like and we restart this all of our code highlighting our syntax our intellisense Etc goes away inside of these Astro components and vs code considers this to be a plain text file which is obviously not what we on so you'll want to make sure to install the Astro extension to get all of the benefits that come along with it it's by far the best way to work with Astro so I'm going to enable that and notice all of that comes back now another one that I have installed is an astro Snippets extension there's lots that you can do with Astro in terms of different types of file different things you might want to do this is a great set of Snippets that you could start with that kind of help generate components quicker and easier for you as you're going along now there's one more extension from the Astro team which is the Houston extension now Houston is the actual mascot for Astro and they've built a lot of fun things around this so with the Houston extension you get the Astro vs code theme mimicking the colors from Houston which is pretty neat I like this a lot in addition to that inside of the file explorer you get a little Houston Tab and you get kind of an animated Houston icon that shows you whether or not your application is running well or not based on it being happy or sad so it's a nice little touch to kind of feel like you're inside of the Astro community so you can install this and kind of have some fun with that if you're interested now me personally I'm using my personal James Q Quick theme so if you're interested in having your colors look exactly like mine you can search James you quick to get set up there the last thing I want to show you is the Tailwind CSS intellisense extension this is one that I use all the time when working with Tailwind so that it helps me kind of auto complete or remember what all the different styles are that that I'm trying to work with so you'll see this more as we work work through this and start writing some code now with all of that set up let's go back to the Azure documentation and see how to install Tailwind so let's just search in the documentation for tailwind and we'll be taken to the Astro JS Tailwind extension or integration that we can add which is one of the really cool things about Astro is that it comes with Integrations which makes it really easy to add support for other UI Frameworks for example to be able to deploy SSR to different places and a bunch of other really neat things so let's scroll down we can kind of skip the why tailwind and let's come down to the npx Astro ad Tailwind command which allows us to add Tailwind in one command and be able to work with it right after that so let's stop our running application let's paste in our MPX Astro ad Tailwind command and this will kind of walk us through what it's going to do to make sure we're okay with it doing all of these things so do we want to allow it to install the Tailwind CSS extension and the astrojs Tailwind package yes absolutely in this case it says it's going to generate a tail 1 config file which we absolutely want so we'll say yes and then lastly it says it's going to update the Astro config file to be able to support Tailwind so we'll say yes to that as well now just to confirm what this did let's search for the Astro config file let's open this up and what it did is it added an integration section here and then inside of that array it added a call to the Tailwind function that gets imported from the astrojs Tailwind package so this in theory is how we would manually install Integrations into our applications but in this case Astro gives us this command the Astro add command to be able to do all this stuff for us which is really really nice so let's go into our layout file and let's get rid of all of the styles that are defined in here because we're going to use Tailwind for our Styles and not use the builtin styles that come with the application now just to make sure let's go ahead and run this to have this running we can make a few changes inside of this layout file to start to get the base of our application going now the first thing to notice is that we're only defining one property that could be passed in as props which is the title now we could additionally add extra ones like the description we can have this be optional so we'll have that be defined as a string so the optional question mark or the question mark denotes this as optional and we can also Define an image in here as well so now that we get all three of those we can destructure them so that we can be able to use these as well all right so we have these three properties but we're not using all of them just yet we're only referencing the title and not the description or the image yet so inside of the content for the description we could reset this to be description and we can also reference our image by using it for the OG image type now we're not going to get all the way into all the different OG tags that we could use let's start with a meta tag with a property of OG image and then we'll say the content is going to be that image property that we pass in so we'll put this in here as image now one thing you might be wondering is what if the description and the image are not passed in here we should probably have a default property that we can use so in this case for the description we can set the default right in line in here by doing equals and then assigning this to a string now what we're building is a an application called Rhythm Nation and this is a community of music producers and in enthusiasts and then we want to give a default value to the image as well now we'll come back to this in the images section but I'm going to set this to a default of Slash Images slash band dot jpeg now remember we talked about the public directory what this is referring to would be a file ban.jpg inside of an images directory inside of public but we'll come back to that in a little bit for now we're just kind of setting these by default now just to show that these are coming up we can come back to our running application which now looks a little bit different because we got rid of those Styles and if we look inside of the head we should see that we now see our description here we also see our OG image which if we try to access will not be available yet then we still have our same title which is great so all those things are working well there's a lot more that you could dive into with OG tags for helping your website show up on social media post for example or embeds and slack or Discord but that's a conversation for another day just know that you have complete control to add all of those inside of here now inside of the layout what I want to do is add some Tailwind classes in here and what we can start with is a Min height of screen so before we save that let's go and look at the body tag in here and if we see this body tag is not taking up the entire height so we can start to style that a little bit with Min h of screen and now we should see that this body is now taking up the entire height which also is confirming that our tail one classes are working now from here I want to add a header component that can show the basics of our application so in this case I'm going to copy a little bit of code but inside of components I'm going to create the header.astro component and I'm going to paste in some starter code for us to work with now we'll walk through the code that's here so we Define our header we give some Tailwind CSS classes again this is not a crash course on Tailwind specifically but we have some classes for our header we then have an image icon that we can have to show in the top left we'll come back to that in a second then we have a few links to the different pages on this application like the home page the about and the blog so from here what I want to do is import this into our body or into the body of the layout component so I can actually Open Bracket and start to type our header and then oftentimes I'll get intellisense for this but it looks like it's not opening for me so I can go and do a manual import up here instead so at the top of this we can import header from and then we'll go back a directory into the components directory and then grab the header.astro so we could save this and we should now see the basics of our application starting to come together we have our header up here we have a missing icon up here and we'll need to add that inside of our source code so that we can actually have this show up so one of the things that we can do is go ahead and go to the Astro course demo final source code and then inside of the public directory we have an images directory and we have a heartbeat.png both of which we're going to need so we can click on the heartbeat.png and we can download this so we can download that file and then additionally we're going to need the images directory as well so from the images directory we can download this directory as well all right so that should download all of those files and so what you'll need to do is go and find the heartbeat image and then that directory that we just downloaded and it will add that into our source code so in this case I'm going to take the heartbeat.png and I'm going to add this into the public directory so there that is there and if we look inside of our header it's referencing slash heartbeat.png which should reference a heartbeat image right inside of that public directory so now if we come back and go to our application and refresh we should see that heartbeat icon is starting to show up which is great now the other thing we wanted to do is take those images that we downloaded in the zip folder and add those to the public directory as well so inside of the public directory I'm going to create an images folder and I'm going to drag all those images that we just downloaded into that folder so into the images directory here now one additional benefit of that if we remember is back in the layout component we defined a default image for our OG image to be inside of the images directory just like we did and then the band.jpg so this now should be the default image that shows up for our OG image tags and actually we can test this by going directly to this inside of the URL so we go to slash images and then slash band dot uh not jog but JPEG and we should now see this entire image showing up so we know that that is working as well so we have our images copied over which is exactly what we want we have our header showing up up here above we have links to our different pages which we haven't created yet and now we can go into our index component that root page and we can get rid of all of the Styles so we can delete all of these Styles and we can delete all of the main content that's in here as well so let's just scroll all the way through and get rid of everything inside of Main and in this case we're going to update this title to be relevant to the blog post the blog site that we're working on which is the Rhythm Nation blog so it's just the demo idea here but let's go ahead and type that in Rhythm Nation blog and now we can add a title to this as well so I'm going to actually create a new component for an H1 that we can reuse so we'll create an H1 component dot Astro I'm going to copy over the tiny bit of code that we have for this where we Define our props we take a text property as our prop we destructure that and then we put it inside of an H1 that already has the Tailwind Styles created so I'm going to save this and then back inside of the index we can now reference our H1 component and we'll pass in a property of rhythm nation and then we'll need to import this component so that we can reference it so we'll import H1 from and then we'll go into that components directory and then we'll grab the H1 dot Astro and now we should see a basic title showing up now one thing you might notice is that we need some spacing on the outside of this so one more component that we're going to create is the main dot Astro component and what we're going to do is use this component to wrap all of the other things that we do so in this case I'm going to open up a main tag and then we'll pass in everything in between as the slot and then we'll just add some Tailwind classes in here so we'll have a px of 24 which is padding X we'll set a Max width of 7 XL we'll set MX to be Auto which is going to automatically Center everything horizontally and then we'll set the width to be full and then lastly we can set the padding to be 5 on screens that are at Max small size so this is saying that we'll have a padding X of 5 on screens extra small and small and then above that anything bigger will have a padding X of 24. now the last thing we'll need to do we can actually duplicate this import we can import the main component from that components directory and we can now use our main component instead of just the main tag and that should wrap everything and give some spacing on the outside so now we have a clean section here for our main content that has that padding on the outside we have our header we have our images loaded and we can start to do more with this application by building out blog functionality and leveraging the content collection feature in Astro which is one of my favorite features of Astro now if we look at the final demo from the full Astro course we can see we have a home page where we show a bunch of blog posts we have tags Etc but what I want to show you is that if we go to the slash Blog Page we can see a list of all these blog posts which is what we're going to start to work on now so we can see a list of all the blog posts in addition to all the images that are associated with them so if we scroll through we can see these blog posts and then if we click on one we'll actually be taken to the specific route for the individual page so notice inside of the URL we have our root URL slash blog and then slash the title of that blog post and a sluggified version which means having dashes in between all of the words so let's start to work on setting up our application in this crash course to be able to work with markdown using content collections in Astro so let's go over to the Astro documentation and let's search for Content collections so what content collections are are a way to organize and manage and author content in any Astro project and in my personal opinion this is the best experience for working with content specifically markdown and or MDX content that I've ever seen across any platform which gets me really really excited so our content collections again give us a way to organize all these inside of a special directory in Astro called content directory so under Source slash content we can then create a directory for each different type of content that we want to create in this case their demo they have newsletter in our case we will have blog and that's where all of our blog posts will live as markdown files inside of there now you can scroll down and find a lot more about this with multiple collections Etc but the one thing I do want to show you is how to define collections inside of the content config file which is a typescript file and allows you to Define types for your individual collections like the blog collection using Zod to have typescript type associated with each of your collections so you define a collection you define a schema and you can Define all the different properties that are going to be associated with each piece of content now before we actually get into the code the one thing we will need to do is go back to the Astro course demo and we'll need to download some sample markdown files that we have in here to reference inside of our application so inside of the Azure course demo there is the source directory and then inside of there just like we talked about is a Content directory and then inside of there is the post directory so what you'll want to do is go and download this entire directory of all of these posts now after you do that you'll want to make sure to extract all of those and then we'll go inside of our source directory we'll now create our content directory and then inside of there we'll create another new folder called posts and then we'll take all of that that we just copied and drag it into the post directory now one thing I did Skip from copying over is the images directory that you can see here but that's something we'll come back to when we get into image optimizations so let's just take a real quick look at what we have inside of this content so inside of here we have our front matter at the top of each one of these markdown files and we have an author we have categories we have a date we have whether or not this blog post is featured we have a cover image to be referenced and then we have a title now this is all the front matter what we're going to do with content collections is Define a data type that represents this and stores or or gives us intellisense inside of our Editor to know which of these properties to associate with our given blog posts specifically with a given collection which in this case is our blog post now at the bottom of this you can see all of the sample markdown that's included here so this is just some getting started markdown so we have something to render you could obviously go and create your own markdown with your own content if you wanted to now one thing I do want to change is the reference to where these images are stored so actually I'm going to select this whole thing and I'm going to do command shift F on Mac or Ctrl shift F on Windows and I'm going to change this slightly and I'm going to get rid of this leading dot in each one of these blog posts or each one of these markdown files and we'll come back to that again when we talk about updating our images to work with the image component that comes with Astro to optimize our images but right now I want this to point to the public images directory where those different images are again we'll come back to this in a minute so we have our sample markdown and now we need to go into the content directory and we need to create our config dot TS file so let's start to work on defining a Content collection inside of this config file now to start we're going to import the Define collection function and then the Z for Zod from the Astro content import so this is giving a little bit of an issue saying it cannot be found this should be okay so as we go through this we'll make sure to run it just to make sure and then from here I want to Define my post collection and this is going to call the Define collection function we'll call this and we'll pass it a config object now this config object will then have a schema and we'll say that the schema is going to be a z dot object which is a function and we'll pass that a configuration object as well so we're using Z dot object to say that this schema is going to be an object and then now we can Define the different properties that it's going to have so we can Define it to have a property of author and then using Z which is Zod we can say where this is going to be a string then we'll have a date which in this case is also a string will have an image which is a string we'll come back to this in a minute and then we'll have a title which is a string as well now the cool thing about Zod is that it has other data types that you can work with where you can add a lot of customization on what exactly these types should look like and then lastly what we want to do is export a variable called collections and this is going to be an object and we'll say a key is going to be post and then it's going to have a value of posts collection and it's really important that this word here match up with the name of the directory that that content is in so those two things should match which means our post collection should be inside of this post directory inside of content so now that we have our definitions for our content we want to start to query this content so that we can start to display this inside of our slash blog page so to do this we'll need to create another component inside of our Pages directory and we're going to create the blog Dot Astro component now in here we can start to query our content by referencing the get collection function that comes from that Astro content namespace so this is going to be a function that we can call to get the content associated with a specific collection so in this case we're going to assign this to a variable called post we're going to await a call to get collection and then inside of a string we're going to pass it the name of the content that we're looking for now notice it gives me intellisense in here because it knows what the different content collections are that I've defined so I can now query these posts inside of here and now we can be able we should be able to log the post to the console so important to note with Astro is all of this code is going to be run statically at build time so it won't quite look this way when we run this now but when this is deployed all of this content is going to be queried and generated at build time and then deployed statically we'll talk more about this as we convert to SSR later in this video but in this case we should be able to go back to our site we should be able to click on the blog page nothing will show up but if we go back to our logs we should see that this is actually querying all of this content which is pretty nice so what I want to do is start to be able to display the basics here so one thing I'm going to do is copy over the structure of a page from that root page and now we'll say this title is going to be a Blog and then Rhythm Nation maybe not Rhythm Nation blog because that's repetitive we also have missing Imports so I can do command and period and go to add all missing Imports this would be control period if you're on Windows machine now we have all of our Imports and then we can also update this to be blog so now we should at least have the basics of a page kind of showing here so Rhythm Nation blog so that's great but now we want to actually be able to display that content so one one of the things that we could do is we could iterate through our posts so we could say post Dot and then map and then get a reference to each post and then for each post what do we want to return so inside inside of here we could start with an H2 and then reference the post Dot data that's going to be all of our front matter and then inside of here when we press enter we now get intellisense for all those properties which in this case I'm going to choose the title so this is not going to look great but at least we have the ability to show that all these post titles are being queried here now the other thing we might want to do is wrap this all in an anchor tag so if we kind of stub out an anchor tag here and wrap our H2 what we want to do is we want to set the href to a particular URL that will take the user to that blog post so in this case we can Define this ourselves by using an ESX template literal string and we could say this is going to take the user to slash blog slash and then inside of our Temple literal string we can reference the post dot slug so this is going to be the sluggified version of that based on the name of that actual file so now each one of these should be a link to that blog post even though that page doesn't exist yet so if we hover on this on the bottom left you can see it links to slash bog slash blah blah if we click on this it doesn't exist and that's our responsibility to go and create that so we want to do a couple of things in here to make this look a little bit better we'll cheat a little bit and copy in some components to help us we'll start with the post list dot Astro component now in this case what we're going to to do is Define our props to take in a prop of post which is an array of a collection entry of the type of posts now again post is going back to that collection that we Define and we're just saying we have a an array of those posts that we're passing inside of here now then we have our Tailwind CSS to be able to display a CSS grid here with two columns on bigger screens and then go down to one column on smaller screens and then we display each individual post with a post component that we haven't created yet so inside of our post our inside of components we'll create one more component and this is going to be the post component that we can paste in all right so very similar we Define a prop in here where we're going to take one property which is a collection entry of posts so it's one post we then destructure that and now we can reference each piece of that data so notice we also have the same kind of Link in here with an H2 where we have the post.data.title then we have the link that's linking to slash blog and then the slug we also are referencing the body of our blog post but we're using a few CSS or Tailwind CSS classes or one and here to say line clamp of two this will give it a maximum line maximum display of two lines and then use ellipses to finish it out and then at the top of this we're also referencing our image which will come back to in a minute as we go and optimize these in a second so we can save this we can save the post list component let's go back to our Blog Page and let's get rid of this log and just make sure all this stuff looks good so let's scroll to the bottom of these logs in the terminal there we go and then now if we refresh our page here nothing looks different because we actually need to use that post list component so we'll replace the anchor tag that we wrote we'll reference the post list component and then we'll pass into that our post property that we queried above and then we'll need to also import this so I'm going to copy the layout import paste in and post list and then paste in or type in post list here as well and this is from the components not the layouts directory so now we should see that we're actually loading each of these posts and it's linking to the individual page for that post so notice this doesn't display yet because we haven't generated those pages but we do have the ability to link to each individual blog post which is pretty neat now let's go ahead and generate the pages for each one of these now to do this let's go to the Astro documentation really quick to kind of show you how we're going to so we can search for dynamic routes and in this case what we do is Define a file that basically is going to have a placeholder in the file name that tells us some property that we can use to then query and display the appropriate information for that post now in our case what we're going to reference is the slug of the blog post so inside of our Pages directory we can create a new folder slash or blog and then inside of here we're going to create a new file that says inside of brackets Slug and then dot Astro now what this means again is that we're going to be able to get the slug for each one of these posts by defining each one of the different routes that we have now the way we Define each one of these routes is we open up our JavaScript snippet here and then we're going to export a function called get static paths this is going to be an async function and then inside of here we want to query all of our posts so just like we did before we'll call git collection and we'll pass in the posts name and we'll need to import that git collection function so we'll import this git collection and we'll also import collection entry from Astro content and once we have each one of our posts what we want to use what we want to do is use those posts to be able to generate the path that should be created by Astro for each one of these different individual blog posts so we're going to create a paths property we'll take our post variable we'll map through it we'll get a reference to each post and then inside of here we want to return an object and this is going to have a couple of different properties the first one is params so now inside of our prams these are params that we can pass directly to this component so we want to pass in that slug property and it's going to come from post dot slug and then we want to pass in our props so our props is going to be the post itself so by the by exporting this get static pass function we're basically defining a path and a property for each one of these blog posts that will generate statically for application now from here we can kind of Define how this component is going to work so we'll Define the props type this is going to have one property of posts that's going to be a collection entry it's also going to be referencing that post collection so we'll have one post is being passed in we can then destructure this so we can get the post from Astro dot props and then from that post we can grab the content so we can destructure the content itself from the post.render function which is an async function now from here we want to kind of lay out a blog post page just like we've done a few times before so let's copy over a few of these different components and let's just paste this in so I have our layout we'll have our main and we'll have our H1 and we can import all of these at the top so we can import layout and we can import the H1 and lastly our main and so we've imported all three of the components that we're going to use in here and just to start we can now start to update a bit of information based on this individual blog post so in this title we want this to actually be the title of the blog post that we're on so we can take post dot data dot title and then inside of our H1 on the page we can do the same thing so we want to reference our post.data DOT title so what we should have done now is we should have generated a page for each one of our blog posts that will in this case just display the title of that blog post so if we click on one of these blog posts from the slash blog page it should take us to this page but it looks like we have some sort of error in how we defined our git static path function so it's expecting an array but got undefined so let's go back up and double check that so it looks like we defined our path but we didn't return this in the end so the most important part about the get static path function is it has to return those paths so that Astro knows what to do with them to generate the individual pages so hopefully that will handle this now if we refresh we see the title now coming up at the top and we have our individual blog post Pages for each of these individual blog posts so that's great we have each of those defined we can now kind of copy a little bit of code from the post component so if we go back to the post component and look at the image we can now copy this end just so we're starting to display some more things on here so if we paste this in under the H1 we should now see our images popping up so it looks like it's not quite the size that we want because we're now shrinking this to be a width of 600 so we can update this to be 1024 and I think that should give us now kind of the full screen or almost full screen page that we're looking for and then lastly we can render this content component that we got from the render function of our posts so up here we called post.render we got the content component we can render this but it's not going to look great so you can see we have all of our content here but this doesn't quite look great and that's because we don't have any Styles defined for this now in our case what we're going to use is the Tailwind CSS typography package to handle this for us so Tailwind CSS typography you can search this basically what we're going to do is install this plugin and then we'll be able to use this inside of our page to be able to display this stuff appropriately so I'm going to copy this install command let's go back let's paste this in this is going to install the Tailwind CSS typography package then inside of our Tailwind config we need to make sure to reference this so we're going to inside of this array require and then we're going to require the Tailwind CSS typography package and then lastly for this to work inside of where we render our content we're going to need to wrap this in a class or a div that has a few classes primarily the pros and Pros 2XL class so those are the classes that kind of activate this extension or to be able to use that plugin to be able to render all of our content so let's go ahead and run this with our run Dev command we can now come back to our application we can refresh this and we should see that this now is looking a lot better and this is starting to feel like a real blog so we have if we go back we have a list of all of our blog posts and then we can click on the individual Pages see the image and see all the content which is pretty neat now one thing that's interesting that's not very optimized on here is the way we're referencing our images so if we go into our Network Tab and just look at our images as they load in we'll notice a couple of things a couple of things we're loading all of these images even before we scroll down to see them so that's a little bit unnecessary it would be more optimal if we were only loading images as we're getting close to scrolling down to them then we'll also see that these are being loaded as JPEG files which are not the most optimal format webp would be a better format and see that these are really big images so six megabytes four megabytes Etc so we can use the Astro image component to make this a lot better and much more optimal so let's go back to the Azure documentation and let's just search for image and let's just go to the top level images here and let's go down to the actual image component which is what we're going to use to be able to do a lot of optimizations with our images so we can import the image component from the image assets namespace and basically just replace the regular IMG tag that we were already using we'll have to do a few more things in here but let's start with that so inside of our post component we can copy in the import for this image component and we can now replace that IMG with our image component now if we come back to our application we can see that this is going to work but nothing has really changed so we're still loading all of these files and they're still jpegs and they're still pretty big so one of the things we want to do is actually move this image's directory into our content directory and actually specifically we're going to move this into our slash post directory because these are going to be all the images that are associated with these posts now then inside of our markdown we're going to update if you remember we changed this at the beginning we're going to select this little bit and we'll do command shift F or Ctrl shift F to select all of that and what we want to do is we want to update this to go from slash to dot slash so slash implies that it should look at the root of the application which is at the end of the URL dot slash now means we should look relative to where the actual file is so in this case it's going to be relative to where this markdown file is and that's going to be inside of that post directory so I'm going to update each one of these posts to reference dot slash image and we would think that would work but we actually have an error in here of something isn't working that's because we need to go back to our config for Content Collections and we need to update our image property to actually use and image object that Astro gives to us so what we're going to do is turn instead of returning this object directly we're going to turn this schema value into a function and so this is going to then return that Z dot object but by defining this as an a function we can now destructure a property called image and now we can reference our image type to be of Type image or call that image function so this is going to more explicitly references as an image in a way that Astro can understand in a way that could also import those images from the content or inside of the source content directory so let's try this one more time run this again so the first thing that you notice so you might notice is that the URL for these images are looking kind of weird that's because Astro is using kind of internal URLs to Define how to render these images so if you look really closely you can see it defines the format and width and height Etc but we can see that these are loading webp images and that these are much smaller than what they were originally so our page now is going to load much faster because these images are much more optimized and they're a better format and they're much much smaller now if we click on one of these individual Pages notice that this isn't working and that's because we're referencing this using the old image IMG tag which can't be referenced here so let's go into the slug page and let's just update this to use the image component from Astro assets and we should be able to just say this as is and have this be working so now we're able to load this image and this should also be choosing a webp version of this which should be smaller than what it was originally so now we have a working list of all the blog posts we can then go to the individual page for a blog post we see an optimized image and we can see all the content associated with that blog post as well now with all this in place there's one really neat thing that we can add that's really easy in Astro and pretty amazing if we look at navigating between these Pages we see kind of this page refresh we actually don't have the about page created but we see kind of the page refresh as we go between individual pages and we can actually make this a little bit easier by using the view transitions API in Astro this will only take a second to add but it does make a big difference in how you can view and navigate through your application so inside of the view transitions API you can you can read a lot more about this we can basically import this component and then use it inside of the head of any page that we want to have those transitions between so since we want to by default use this on every single page we can actually just import this inside of our layout file and then somewhere in the head we can just reference this View transitions component and save and now we're actually going to be be able to see a difference between how we navigate our Pages this is pretty neat so let's go from this page to home notice we get kind of that animation we go to blog we get animation we see this page we get the animation so it looks like a much much better experience of navigating between pages with just one component that we can add now there's some additional ways that you can customize this you can also Pass State from one page to another which is pretty neat we won't go any deeper into this but it is nice to know that we can add this pretty easily to make the transitions that our application look look a lot better now one additional thing I wanted to show you is that you have the ability to not only use markdown inside of Astro for your content you can also add MDX and the support for this comes with a an integration that we can add with one of those npx Astro ad commands so let's go and add support for markdown by pasting in this command this will make a change to the Astro config and install that package so we'll just go ahead and say yes to all the things that it needs to do yes all right so that should be added and now we can do an npm run Dev to start this again and what we should see if we come back to our markdown files for example the behind the scenes is we can now rename this file and we could rename this to an MDX file and now all of this should still stay the same so if we come back to the application so if we refresh this we see this stays the exact same which is exactly what we wanted but now we can harness the power of MDX in addition to just the markdown that we were already using now if we scroll back up there's a quick section on why MDX so now we're not going to dive deep into this but there are lots of really cool things that you can do like MDX only features so you can use exported variables inside of MDX so if you wanted to create variables at the top you could then reference that you can also use your front matter variables so you could use those directly inside of here as well and the last thing is you can reference Astro components and UI components of other Frameworks like react view Etc inside of this as well so if we look in the example in here inside of the MDX part we're importing two different components one Astro component and one react component that we can then display right in line inside of our markdown content now this is really useful for as an example to do like a call out inside of your blog post if you want to customize a call out to send somebody to a newsletter or something else you could Define those components and bring those into your H to your MDX files anytime that you want or need so we're not going to dive any deeper into MDX that's kind of a section on its own but it is nice to know that you have the ability to work with both markdown and MDX files in your content with Astro now we can start to work on deploying this application so we initialize this initially as a GitHub or a git repository so we can now do a git status and we can see all the things that we've changed now in this case we can add everything with Git add star and then we can do a get commit Dash M to say initial commit and all of this stuff has been committed to this local git repository now the next step is we we need to connect this to a GitHub repository that we can then use to deploy to netlify or versal so on github.com you can go to the top right you can click new repository and then we can call this FCC Astro crash course test we'll have this be a public directory we don't want to add a readme because we'll take care of that ourselves we don't want to add it get ignore so we can create this very blank repository and then what we'll do is just take the code into our terminal that pushes from an existing repository to our local git repository to this GitHub repository so you can copy this section where it adds the origin and the remote or it adds the remote origin and then pushes everything locally to that remote project inside of GitHub all right so it looked like it pushed all of that code up if we come back to the GitHub repository we can come in here and see that this has been added and so now our next step is to go to we'll start with netlify we can do netlify and versal these are both free so you'll sign up with a free account after you do you can log in on netlify and basically what we're going to do is add a new site where we're going to import from an existing project we'll choose to deploy with GitHub and then what we'll need to do is go and choose that project that we just created so I can search FCC Dash and this should be enough to pull up that project all right so we can now pull this in we don't need to customize anything it should pick up on what the build command is automatically so we can go into go ahead and deploy this and it should run a build and then have the site ready for us to use after it's done all right so it looked like this build has finished you can now kind of choose the random URL that they gave you and we should see that this is deployed our application successfully so we can see our Blog Page we can go and click on individual ones as well so that is on netlify we could also choose to deploy this on Verso almost the exact same process you'll sign up for a free account you can then come and add a new project you're going to import this from a git repository choose from that FCC crash course project and GitHub choose all the defaults and then go and deploy and then after this is finished we should have this deployed on versel as well all right so it looks like this has finished on versel we can continue to the dashboard then we can visit this at the random URL that it's generated for us also now so far everything that we've done with Astro has been statically generated pages but we can start to look into the SSR capabilities of Astro so Astro actually has the ability to do a full back end if you so decide and you have the ability to Define what type of output your site is going to have so by default it is static which takes no additional configuration for us to do but there also is the ability to Define it as a server rendered application by default it says to use this one most or all of your sites should be server rendered you can also opt into prerendering or static Pages for individual Pages you also have the option to do hybrid which is basically saying it's going to prerender by default and then you can Define for individual pages to opt out of prerendering before we make this transition into serverside rendering in our code let's actually take a couple minutes to talk about the difference between static site generation or SSG versus SSR which is server side rendering and we'll talk about this while using diagrams to kind of explain the differences between the two so let's start with what we've already been using which is SSG or static site generation and this is what Astro does by default quick reminder if you want to follow up on this diagram later on you can find the link in the description below so what happens here is when we deploy our application we deploy this to something like netlify or versel or there's lots of other hosts that you could use as well so when this thing is deploying it actually runs a build and during that build process what happens is for each one of those individual pages that we have in our Astro application it actually generates the HTML file at build time for each one of those so we have one for our index.html page we have one for our blog.html page and then additionally we have a an HTML page created for each one of our blog posts and that's where we Define that export or we exported that get static paths function where we defined each one of the paths that we wanted to be able to support and then to generate the content for so the important part about this is SSG at build time is going to go ahead and create the content or the HTML Pages for each one of these Pages at build time so that it's ready and accessible by the time someone comes and tries to view one of these blog posts for example or one of these other pages and that's an important next step to talk about is the actual request time so what happens well these individual files that are generated during the build process are then saved to a CDN or a Content delivery Network that are replicated all across the world what this means is that those files now are very fast to access and return When a request comes in from the browser so let's say that you go to the browser and you type in local not localhost but you type in the URL of the application that you're trying to work on and you go to the index page that's going to make a request to the CDN it's going to now return that index.html page now let's say you then want to go to the blog page while you make another request to the CDN the CDN now is going to return blog.html or if you're going to one of the specific Pages for an individual blog post it's going to return those pages as well again because they've already been predefined now this starts to differ a lot when we look at SSR or serverside rendering so I've got almost an empty diagram here for SSR build time so with serverside rendering you're still going to have a build process to go through and run all of your code you may run tests if you have them but basically this is going to go through and do the build of your application and you may have some static Pages we'll talk about how to mix these in a second but for the most part what this is going to do is now kind of have that server configured so that it can handle those requests as it comes in so notice there's no predefined HTML pages that are already calculated for us that means if we scroll down now that something has to happen at request time when this request comes in from the browser so notice instead of having a CDN we now have an application server so requests will go from the browser to the application server now for this application server to respond back most likely specifically in this case with our blog post individual blog post Pages it's going to need to get the information necessary for those blog posts from the database now in our case we're not using a traditional database we're using embedded markdown in our source code but it basically works the same way so let's say that we make a request to slash blog slash blog dash one for example that's the website that we're trying to go to well this is going to now make a request to the database let's add a new piece of text in here and it's going to say give me all the information that you have about blog one so from the database the database is going to return back the data for blog one to the application server the application server is now going to turn that back into an HTML page which will look like if we add our corresponding piece of text to your slash blog slash blog1 Dot HTML we can move this up a little bit for readability so basically with SSR or server side generated Pages or applications every request that comes in is going to go to an application server it is it is then going to query the database or in whatever format it is which might be embedded markdown that will return the data the application server will then take that content and turn it into an HTML page that can be rendered on the browser and viewed by the user so that's a quick overview of the difference between SSG and SSR let's go back to our code and start to make this work inside of Astro so in this case we can start by going into the Astro config and we can choose the output property to be server now if we try to run this we should see that this is going to break and that's because we're doing a couple of things that are specifically geared towards statically generated pages so let's go to our running application and refresh and we see that we now are having an issue on the individual blog post pages and that's because the way that we're generating those pages is using this get static paths function and that doesn't exist inside of an SSR deployed application now one thing we could do is we could look in the documentation and we could see how to define this as a prerendered page that means it's going to generate this page statically so if we add this at the top of this file and refresh this actually will go back to working as we expect so now we see we have that blog post we can go back to all of them and go to another one Etc but just for practice and kind of experience let's go back and get rid of the prerender and let's see what it would take to actually figure out how to generate generate these Pages inside of an SSR environment now in this case what we're going to do is go back to our page and we can actually get rid of this entire get static paths function and we can start at the top here and most importantly what we're going to do is destructure a property called slug from Astro dot params now what Astro is going to do is because of this slug definition up here it's going to pass this log into the Astro dot params object to let us reference it and use that in here to dynamically query that post from Astro we can also get rid of our definition for the posts and our prop types and then what we're going to do is we're going to get that post from in a weighted call to git entry by slug now this is a function up here that comes from Astro content it's a function that they give us and we can say what content collection we want to get this from which in this case is post and then we can pass in the slug now in this case it's going to throw an error or show us the typescript error because slug could be potentially undefined so we're just going to say this is going to be a string so that we get our appropriate type in here now in this case it's throwing an error because it's saying that we might query for a post that also doesn't exist and what we could do we could say if that post doesn't exist we could do an astro redirect so we could return an astro redirect to the slash four or four four or four page just just to show that that thing wasn't found now we could go and customize this and do anything that we wanted to handle it but in this case this ought to be enough just to get this working and now have these dynamically generated Pages be dynamically generated with serverside rendering instead of statically generated pages so if we go back we should see that we have all of these showing up in our blog index page and then clicking on one should be able to show all the details for this blog post as well so we've now completely flipped how we're rendering these blog posts Pages now they're server side rendered and what this means just to clarify is as the request comes into this URL it's going to send a request to the server the server is going to query based on that URL the individual blog post return that back and then use that to render the page that shows up on the screen as opposed to previously we had each of these Pages generated statically at build time for all the blog posts that we have now the cool thing about this is we can still go back and configure individual pages to be configured as static so as an example on the home page there's no reason that this shouldn't just be a static page so we could still export a kant's pre render variable that's set to true and now we'll mark this index page as static so if we go back here this will be a static page versus this is server side rendered and this individual page or all the individual Pages for our blog post are server side rendered as well now I do want to show one more thing that you can do is when you have server side rendered enabled you can Define API endpoints so we can search for Server endpoints in here and basically what that allows us to do is have a file inside of our Pages directory that just basically serves as an API endpoint instead of actually returning an astro component so if we go into our Pages directory we could create a new folder slash or called API and then we can just create a test dot TS now notice this is a TS file instead of an astro component again because it only runs on the server and if we look in here just copied kind of the basic uh starter code that they give us but we're not going to reference any of this so we can kind of get rid of all of this information about products and then we can return back an object with a message that says hello world so this is how we Define a starter function four API endpoints so in this case we're also not referencing this params parameter so what we defined is a git endpoint where we're basically just going to return hello world as Json so we can save this we can then go back to our application we can then open the URL and go back to the root and then slash API slash test and we should get back that message with hello world now what's really cool is we can Define all of our HTTP endpoints with this as well so we could also export a post function if we wanted to we could return with the same thing now unfortunately there's not a way to be able to test this inside of the browser because the browser can only send git requests so I have the postman extension inside of vs code installed so if you wanted to follow along you can install the postman extension this has been kind of my default way of doing testing apis for a long time but now they have the the vs code extension to go with it so we can create a new HTTP request and we can now send a post request to the same general idea so localhost4321 and this will be slash API slash test and we'll send that and we'll get the same response that we just got back with the message of hello world now inside of handling our post requests we could also destructure the request as well and then we could get the body from that request by calling a weight request dot Json and then we could just return this just to show that we're actually getting it so let's just return that body which is going to be an object so we're destructuring this request notice we also don't have typescript types around this so we could Define this a little bit differently if we wanted to I'm just going to copy in a new kind of function definition here so this is going to use in Arrow function syntax where we Define now our posts to be an API route so we can add the missing import for that and now it's going to give us intellisense for the request so if we do dot we can see all the things that we have access to there we also then can see things that we might have on our params in here as well so we can now save this and what we should see is if we go back to our request this is a post request but it doesn't have a body so we can now inject in here a raw body with Json and we could have an object and we could have a property of a name we could say Astro crash course and then what this should return back with is that same object that we can see down here so we have the ability in Astro to Define any and all kind of server capabilities that we wanted we could handle form submissions we could Define API endpoints for all of our different methods which is really really cool and really really powerful so I think the only next step is to show how do we actually deploy this to netlify and versel now that we're doing server side rendering so inside of here we have a plugin or an integration for both netlify and versel so I'm going to copy and paste this command so here's the netlify one and let's paste this in here for netlify and this is going to add that package and then it's going to make an addition to our astro.config file to use netlify as the host so notice it says adapter is netlify we'll say yes and then if we look inside of the Astro config we should see that it's referencing adapter and netlify here so now what we want to do is we we will add everything we'll do a git commit with a message of added SSR and deploy to netlify and then since this is already connected to our netlify site we can push this and netlify ought to automatically pick this up pick up that change let's just log back in it should pick up that change automatically and it should be building a new version of that that now is going to be our serverside rendered version so we'll let this go through our build and then we'll open this up to make sure everything looks okay now as this is building one thing to notice it's referencing netlify functions I actually just missed it but inside of building you can see that it references deploying this to netlify functions so that's how it's actually able to deploy this it looks like everything is complete we should be able to open this production deploy hopefully everything now continues to look okay just like it did before and we can see the individual blog post Pages as well now next we'll need to do this for versel so we can copy in that same command and then add in versel and this is going to go through that same process add the versel package and then it's going to update the Astro config to reference that versl adapter so we can say yes to that as well so now this is updated we can add everything again we can commit and say hosting on versa then we can push this now do note that this deploy in netlify we're still connected to netlfi so this will kick off another build that next build will fail in netlify but what we do want to see is inside of our cell we should see that this is kicking off a new build and versaille so we can see under the building tab that it's going through and it's doing this so when that finishes we should see that we have the same deployed application hosted now on versel using SSR all right so it looks like it's finished we should now be able to visit this and we have the same experience where we can go to blog we can see all the pages we can go to the individual page Etc now going back to the idea of SSR inside of Astro one of the coolest things that you could do in addition to API endpoints and other things is you could start to incorporate authentication into your applications so you have the ability with Astro to create fullfledged full stack applications and you can do authentication in here by referencing cookies as an example so you could track a session in a cookie for a user and you could gate pages to prevent users from getting to certain pages if they're not logged in or if they don't have certain permissions or anything like that with authentication in that full Astro course we actually build a basic authentication strategy using SSR and Astro as well as taking advantages of taking advantage of cookies and then having that reference users that are saved inside of a Zeta database so another really cool full stack implication or example of what you can build with Astro now if you want a full overview of what we build in that course you can go to Astro core Dev and it breaks down everything that we're going to build inside of this full application including all the topics that are covered the pricing Etc so if you're interested in that you can find that at astrocourse.dev all in all I hope you're as excited about Astro as a framework as I am obviously I'm pretty excited so thanks for checking out this crash course and I really hope that you enjoyed it