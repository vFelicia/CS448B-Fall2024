i've been a maintainer of mocha since mid 2014 i work at ibm as a developer advocate in the iot and emerging technology uh area um i'm bone skull on on github and uh twitter um except with a zero on twitter um and so i'm gonna talk today this is kind of just a introduction to um unit testing node.js apps with mocha um this is this is really kind of low level it's i kind of wrote it with you know um having someone who's never really done this before in mind and so um yeah i'm just gonna kind of run through some fundamentals um of of testing um just just a couple concepts just just i'll keep it really short because there's a lot of concepts but just just i'm just going to do a couple um then we'll talk about how to write a unit test with mocha and i'll show you that process and then we'll move on to an integration test um with mocha as well and if there's questions about anything along the way just pipe up and stop me um so um what is mocha mocha is a testing framework um so a testing framework um has a few responsibilities one of those responsibilities is providing an api to help you write tests automated tests against your software a test framework will also help you organize those tests some uh test frameworks more than others will actually let you run the tests too and mocha is one of those um and uh also another responsibility is they report the results of the tests so you you write them and you run them and at the end you get you know in various human or machine readable formats you know this is what happened with the test this is these are the ones that failed and this is why etc etc um so mocha mocha runs in node.js of course and that's what i'm going to talk about i'm not going to talk about testing in the browser with mocha um because moka also runs in in the browser uh it runs in um right now uh the oldest browser we support is ie9 but i think we're going to ditch that soon i then the oldest one will be ie11 um hopefully you don't need actually we've never tested opera i have no idea i just pulled that off anyway so um so what what's cool about mocha mocha is simple it's got this it's got a very small api surface um it's it's easy to learn there's there's really just not a lot you have to remember when working with mocha it kind of does one job and it seems to do it well um it lets you write your tests and it kind of wants to get out of the way and and because of that um it's actually it's very versatile so um it will kind of bend how you want to you know how do you how you want to push it um uh you know it's it's not limited to simply one kind of test you can write many different kinds of tests you can run that test in many different environments you know you can use reporters designed for node.js um running in a headless browser and still output you know like weird stuff to the console and just you just they're things i never consider that people use this for and of course you know they file bugs about all this weird stuff um so uh one of the things about moka is that the entire user facing api the thing that you in uh you interact with with as a developer writing your test the whole thing can be swapped out there's a default which is this kind of rspec style api but but it can also moca also ships with uh if you're more comfortable with with the way q unit works um which is uh i think originally q unit was written to test jquery itself if you're if you're familiar with that you can write your mocha tests in in in queue unit format or there's several different ways you can do it and if you don't like any of them you can even write your own and just use it and i haven't seen too many of that too many of those the defaults work pretty well for a lot of people mocha is also i dare say fun for a testing framework i suppose because there's really no other testing framework that has a nan cat reporter that i know of anyway so now i'm going to talk a little bit about some fundamentals so this is kind of this is what milk is and now we're going to go into um fundamentals of testing and so this this this is just going to be like three this is terminology this is not we're not going to go very deep it won't hurt i promise the first thing is the assertion and so um what is an assertion it's it's a fundamentally it's a comparison um and if the comparison is is true or truthy nothing happens if the comparison is false or falsy then it throws an exception and it's really trivial to write your own assertion function and here's here's an example so you pass assert and a value if that value evaluates to falsie throw an error that's that's basically what an assertion is testing you know testing you're going to make a lot of assertions in your tests that's that's kind of that's kind of the idea um so the next term uh is the unit test um and so a unit test is kind of like this recursive acronym or not it's the definition is is it's well it's a test of a unit and and that doesn't mean anything right but you have to know what a unit is and so um a unit test asserts a unit behaves as intended so a unit is the smallest testable chunk of code so you know generally that's going to be a function because you can't very easily crawl inside a function and pull a little bit out and just test that piece so we're talking about functions most of the time but not always you know you can have a unit test that maybe is testing events or something like that um where it's it's not a function itself that you're testing per se um so a a unit test then has two responsibilities one it executes the unit and so uh i may refer to this as the unit under test or code under test um the uh unit test then makes an assertion about whatever it just did and so in the case of a function that returns something like say you have a function and it adds two numbers um that is your unit you call it call it add or something and you pass it you know two and two your unit test is going to execute that function and then it's going to make an assertion that the function returned four so um that's that's one way uh if your unit just does some side effects um and we'll see that here um in a minute like you know maybe it modifies some application state um you can just you know your unit test is going to execute your function and then it's going to make an assertion about the state of the application so here's the last concept there's only three i'm going to do so it's the integration test and so um i found when i started writing unit tests i would not really be sure what i was doing or in some cases the code i was trying to test was just very poor and coupled too tightly and i was trying to write unit tests in fact that's what i thought i was doing but i was writing integration tests and so um an integration test asserts like a a it's a test across multiple units or multiple modules multiple layers of your application or multiple subsystems when your unit test starts testing other units too you you just wrote an integration test and and it you can get really confused and uh your your whole tests all your tests can get really confused and but if you find yourself doing that all the time it might be a sign that that it's not the test that that's the problem it's it's that your code's not very testable um so an integration test is is a test across you know groups or layers and if that sounds vague it's because it is vague it depends on your your software's you know the kind of application you have maybe a web server will have an integration test um you know between i don't know you know that something is going to hit hit hit a a json endpoint or something maybe a command line app is going to have something different um a desktop app whatever you know an integration test is really just depends on what you're trying to test you may not know how i feel like this is this is like required to put in a tutorial like this this is how you install mocha with npm um how you install most things i recommend you use a is save it as a development dependency with i i like capital d some people like save dev but you know whatever so this is how you install mocha in node if you're going to use it in the browser it's a different story maybe so never mind that i'm just talking about node this is how you do it in node and so what happens when you do this well mocha is added to your manifest which is package.json it's in the dev dependencies property it becomes part of that um you know that object and it also gives you the mocha executable which lives in your local node modules in the dot bin folder i have no idea what that looks like on windows all this is going to be you know linuxc unixy type stuff i'm not sure exactly how that works in windows but so you get a mocha executable it's in it's in your your manifest and next time you're on npm install you'll get mocha so great but if we're installing mocha that means we have something to test and so this is what we have to test so this is the obligatory contrived example which is some express middleware i couldn't think of i mean i i don't know what else to do it's something that's kind of practical but really really simple um so if you're unfamiliar with express express is like the the the defaults like like web framework web server framework for node.js it's what you're probably going to reach for there are other ones but most people just use express it seems and so expresses is kind of this wrapper around um you know node's built in http server uh and it it it basically functions as this as as like a list of it it's it's built out of these things called middleware and so middleware is just a function um and this is this is this is middleware it's its function accepts uh three parameters when you build an express act you basically chain all these things together you set up routes and um you know what happens when a a request comes into your server is uh that request gets filtered or it's sent through all this different middleware and and eventually something happens and you get your response um and so a middleware function accepts a request which is req which is this object that represents the the request whether that's a get request a post request some somebody some machine hitting your web server and the re uh response object which is going to be this thing you're building and that's what you're eventually going to return and send it back to the requester and then there's this this third parameter to middleware which is this which is next and it's a function and it says i'm done doing what i'm doing go ahead and execute the next middleware whatever that is you don't really care what it is it's just just like it's it's like a cue and it you know knocks off the next one and so this particular bit of middleware um it adds a time property to the request object and so it's it's not a uh it's a javascript timestamp which is not a unix timestamp because it's in milliseconds anyway that's what it does and that's all it does and so we decided we wanted to write a unit test for this and so we're going to make one um mocha will it has some defaults which i think are pretty reasonable if you make a folder called test mocha assumes that if you give it no other information it assumes your test files are in there and so if you make a test directory and and put a file in it with a dot js extension it will find that file and execute it by convention we like to name these files with the dot spec.js i i don't know where that came from but it's just one of those things well we always did it that way so um that's kind of how we're doing it but it's it's a good way to say you know to just visually tell oh this is a test and not not a source file some people like to put them next to the source files which is another way to do it so but anyway uh by default it looks in this test directory and the file we're going to create is request dashtime.spec.js which will contain unit tests for this middleware and before i go any further um and this is this is something that that people get really religious about it's that moki uses globals when you go and you want to write a test that the you know moka is going to run you don't have a like require mocha like give me all these functions at the top of your test file you don't have import stuff from mocha mocha doesn't even use a namespace it doesn't even have like that like sort of you know courtesy it simply just dumps everything into the global namespace and in the browser that's going with the window object and node it's the global object um and so why um the only reason that i can think of it no i didn't write mocha i just maintain it but the only i can only speculate why some of the the decisions were made but it reduces boilerplate plain and simple it's a tradeoff a design decision that was made this is you know what i don't want to have to require all this crap at the top of every file because i got 400 test files if we simply throw things into the global like you're not supposed that but we did it anyway and so there it is it's for developer ergonomics more or less it reduces boilerplate and some people don't like this um but it is what it is um what we want to do is create a suite and so um what's a suite it's it's a way to organize your tests so a a suite will contain tests that will contain something called hooks that i'm not going to talk about but you can also put other sweets in them we use a function called describe to create a suite and you give it a title and a callback function and the callback is the body of the suite and so the title um is you know basically this is this is this logical organization whatever makes sense to you you can nest the hell out of these things or not it's up to you but since we're going to write a test for the request time middleware that's what we're calling the suite um ostensibly we would have more than one but in this talk we do not um and so uh next we're going to start trying to turn the variety unit test but another another kind of gotcha about mocha is that it doesn't actually contain anything to oops but so the question was uh ken about um conventions uh for uh naming suites naming tests and and so you know i i feel like some people who really are into this the whole bdd thing which i'm not going to go into you can look it up it's behaviordriven development it's it's more than just like it's more than just coding you know it's it's like a whole like business process thing and if you're really into that i'm sure they have some really nice rules that you get to adhere to but i'm not one of those people um and i don't think most people do that and so i think at some level it doesn't matter too much um what i like to do personally is i will have like a suite and it will um you know kind of give give a basic description of of where we're at um if i have some sort of condition um uh i might want and and within that condition i need to have multiple tests i like to have one assertion per test and so if i have um a a suite with uh you know with with some condition and then i'll have some tests in there and then i'll like try to try to chain them with and and say so you know we'd start with describe request time middleware um uh describe when such and such is true and then we're going to have another describe and such and such as false it should blah blah blah blah and so i try to make it kind of like a sentence but i don't go crazy about it i mean i'm there there's there's things i mean if you have a test test this you know like typescript i think is the biggest consumer of mocha that i know of they have like thousands and thousands of tests maybe you should ask them how they do it because like i can't imagine how to organize something like that but you know i think just just whatever works for you is is fine there's there's really there's no reason in my mind to you know some some people like to have like um special tokens in there so they can grep for things and stuff and i don't know but so uh and you'll see that there's um i talk a little bit about this kind of english language type type thing um but so mocha mocha doesn't have any functionality in it to make assertions which is odd for a test framework it seems like kind of a fundamental part of the test framework right um so with other test frameworks like maybe jasmine you get the whole enchilada and like jasmine is really similar to mocha um you you just you get everything with jasmine you get your spies your stubs your assertion framework blah blah blah you get everything in there but um mocha doesn't and again i don't know why one can speculate maybe maybe the original author felt that it was simply you know the the best way to to give people the flexibility to work the way they want maybe he was lazy and didn't want to do it i don't know but i could i can look at this problem now with with hindsight and say you know he made the right choice because you know after he he wrote mocha and it started to take off it started this kind of you know a market or is this like um you know all these little assertion libraries started popping up and and now there's quite a few and they're all different and so people have found lots of different ways that they want to write assertions and certainly now mocha couldn't support all these you know it's it's kind of there's like unexpected and and chai i mean try especially as an assertion library that has its own ecosystem i mean it's there's there's just like a ton that you can do and i think i think originally the the right choice was made not to kind of go there with the assertion library but node comes with one there's a assert module uh node uses this assert module to test itself um and we're also going to need our middleware and so this is our unit test file and we're just going to pull in the assert module we're going to pull in our middleware and next we're going to create a test and so uh before we had described for a suite and then in the sweet body we put a test and you create a test with it title callback very similar um you can see here it kind of went out a little bit but so putting this more together so we have request time middleware it should add a request time property to the rec parameter which is basically all that little middleware function is doing and so uh here we have a call function make assertion with notes this is what's going to go in there and it's if if you kind of write your tests like a sentence can we know it um then the reporting will look a little nicer but um so here we go here is here is my first try at at the unit test and so my unit test um is going to call request time it's going to pass a empty object and um why is it going to pass an empty object well you know this this middleware function you have to when you're writing your test you have to think of that unit as a completely standalone piece of code it doesn't it shouldn't be coupled to anything else really and you know the the middleware as you wrote it it doesn't know anything about express all it knows is it gets three parameters and and you know it adds a property to some object and so the the object that it adds a property to might as well just be an empty object and this is an example of a unit that just basically has side effects it doesn't return anything so um we get we have this uh you know we call request time and so now uh the state should be modified and um we can make an assert and so uh make an assertion so assert okay okay is is maybe it's the same thing as the assert function i don't know but basically you pass something to okay and if that something is truthy then it passes if not it's false it's very very simple just pretty much the same kind of bare bones assertion function wrote before um and so if you know what's going to happen here don't spoil the surprise it's a good surprise i promise now we're going to run this and so how do we run it we it ends up in node modules and so we just call mocha it looks in a test folder it runs all the files in that test folder and it fails because why so what do we see here um we see um this first line request time middleware this is the suite um below that is a test and i believe that yeah that number shows up to crossreference down here it's a number if it fails it's a check if it passes and we can see we have no passing tests in seven milliseconds one failing test in seven milliseconds and what happened so it gives us the sweet again that failed it gives us the test title that failed and right under that it gives us a stack trace and this stack trace goes on a while i cut it off there but the important part is next is not a function and so why is next not a function it's because our middleware tries to call a function called next and we didn't give it one oops so let's take a look at that quest time source again okay so what can we get we could we could do it like this so we have that empty object again and the second parameter it needs a second parameter we don't use the second parameter for anything but it needs something in there right so null um it could be void 0 it could be anything it could be foo if you want it doesn't it doesn't use it doesn't matter and but the third parameter is is a function uh it simply calls the function and so it has to be a function that function doesn't have to do anything um and so then we assert that the request time property is greater than zero and run it again and great it passed so does anybody have any questions about this kind of this this flow of of uh writing unit tests and ex executing mocha and good yes it's stubbing it's just i would call it a stub yeah and so you're going to find yourself creating something called stubs when you're writing unit tests quite often um where you have some dummy data or maybe that that unit calls a another function somewhere and maybe you need to stub that out because you don't really care what that does or or you want to say oh so i have function a that calls function b well what happens when function b what happens to function a when function b returns such and such you have this stub or this this uh yeah that basically pretends it's function b and returns a certain value and that's kind of up to you and so um there's there's a lot of kind of bickering about what's best there and i think i think it more comes down to not how your tests are written more importantly how your how your actual code is written but your test can be indicative that your code is not good and so this passed that's great um we have an integration test example um and so again an integration test is it's like it's the next level up from a unit test um it's it's like you pull back and you get this higher level view um it's it's as far as we're going to go with this one but um so what do we have uh you're looking at an ex like an expressbased web server here and so all this thing is doing is it's it it creates an express server it pulls in our middleware and then it registers a root that's this app.get and so when i start this server on port 3000 and if i go to the path if i go to you know localhost colon 3000 forward slash unix timestamp it's going to execute this code and so what this res.json thing does is it it it sticks a g sooner response in the adjacent object in the response built from my object here and remember if um i mentioned that a javascript timestamp is not a unix timestamp but we want a unix timestamp and so we need to you know turn that into seconds and that's about as good as we're going to get there and finally this bit at the bottom i don't know some of you may have seen something like this before but basically um what you can do with this file is you can either acquire it or you can execute it straight away so you can say node app.js and then it'll start listing on port 3000 but if you require it from some other module it will not listen because that's not the main module um it's just kind of a an easy way and maybe not the best way but it's a way to to get at this application that we've created and and test it from you know an integration testing uh standpoint and um one thing with integration testing and as you get kind of to a higher and higher level when you're testing your code if you go to integration test or finally you end up with end to end tests where you're you know you're hitting a browser maybe and and and clicking some buttons and and it tests all the way through the data layer um you know the higher up you get the more tooling you need um and so here we are at integration tests and this would really be a pain we asked the test without some nice helpers and so there's a great helper called super test and supertest is a it's basically it's like a mutant assertion framework that helps you test express servers and um you're going to need express too but uh super test so uh basically it it runs these requests against an uh a server object you don't have to start a server in process a and then tab over and then start your tests and start hitting hitting the the the endpoint um you just give it the server object and you can work with it directly which is kind of nice um you know you don't have to listen on a port apparently it's a lot quicker you know i haven't used it too much but here it is so super test and so we have our assert as before we have our app and so this was that thing i just showed you which is uh this this dude this is app.js and so we pull that in and we have our suite uh get unix timestamp so so all the stuff that we want to test when that endpoint is hit with a get request we might have multiple tests in here but we just have one and our test should respond with json object containing timestamp and so this is the same type of thing um that we're asserting before but we're asserting it at a at a higher level now we want to make sure that you know um not only was uh request time you know written properly not only does that function do what we thought it should do but our whole system works and you know the point of our system is to have an endpoint with returning a unix timestamp and without this integration test how can we be sure um other than the test manually because our unit test won't tell us if our app actually works um this won't really tell us that but it'll get this closer so um there's a couple ways to do it one is this node back style with with callbacks um and this is an example of a uh asynchronous mocha test and so um when you're using supertest you're making http requests in tests these are asynchronous in this case so it's kind of magic in mocha you give it this done function and if that done functioning exists mock will expect you to call it um it doesn't care when it will eventually time out after so long but um it wants you to call done at some point and so you can do all sorts of async stuff in here and then when you're finished you you call done um and so super test is this request function um and we pass it our app instance that we had before dot get would be um you know pretend i'm gonna get requests to the unix timestamp path of this server uh we expect this is kind of the assertion portion we expect uh 200 okay status back and then finally when we're done if there's an error which i don't think there really could be an error here but if if if there is we we can hand that back to done and so this is the kind of air first callback thing that was so popular um and still is for some people but um finally uh if that's okay we can make our assertion again and so what i did there was um you know now that i've you know divided this millisecond style timestamp by a thousand i can now be sure that it's a unique style timestamp maybe if it's under this very large number um if if i didn't do that you know division this would fail anyway so that's one way to do it but that way sucks so this way is even better and you can probably get even better too with async await but um with moka you can simply return a promise and if you return a promise from a test it it says oh you're an async test okay great and so this just works with promises it's the same exact test as before so we we check to make sure we got a 200 okay and then we look at the response and in that body which has been like magically becomes a javascript object out of its json format we check the timestamp and so there we go and so we just run mocha it finds that we just added this other uh i can't remember what i called this file but we tossed it in there and into the tester and it just ran both of them so the question was do if you have an asynchronous test um is it reported asynchronously or is it is reported in in order the answer is report it in order mocha is uh it only works in serial um it it will not execute two tests at a time if it's doing something like that you're probably gonna get a really hard to debug error and you're doing something wrong but um yeah it just runs it's gonna run unix timestamp and it's gonna hang out there and wait until that's done before it goes to this other file uh it's yeah it it runs everything in order and it it it will not try to um you know do two things at once um that's that's that's about all i got so you know before this uh ben said i was super positive which is really weird and so but i don't want to let him down there you go that's all folks balloons an emoji and a poop and um this this these slides and the example code is up there at this url and you can download it and install it and run it and stuff um there's all sorts of all that code is in an example folder and that works i think you