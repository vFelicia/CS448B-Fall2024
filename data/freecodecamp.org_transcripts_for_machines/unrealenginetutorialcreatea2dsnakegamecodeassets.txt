What is up by here from my senses calm and welcome to another Unreal Engine mini course here on YouTube. I mean, where else could it be? You're on YouTube, this is YouTube. Anyways, before we begin, you always know that I first show you the game that you're going to create. But before we do that, help the algorithm promote my channel so that we can grow together, hit that like button, make sure that you comment, share the video so that others can see and subscribe that way you're helping me This is the only thing I'm asking you. Okay, so now let's get inside and see the game that we're going to create the if I hit the play button, we have the nice snake over here, it's the snake's head. Now one thing that we see over here is that the controls of the snake are pretty hard. As you can see, I still cannot get the first food. And the reason for that is because we have one variable inside of our game that is going to allow us to control the snake, you see that I just die. If I press the restart button, we restart and that variable is a delay number. And the smaller that number is, the faster the snake will be. And it will be easier for us to control it. As you can see, the more we eat, the larger the snake gets, and the faster the snake will get. And that means we will be able to control it much faster. As you can see, the larger the snake gets. I have more control over it because well we need to have more control over the snake when this knee gets larger. If you're wondering, what's that circle circle in the middle, that dot i have no idea. It's probably some kind of glitch. It's not part of our game. But it doesn't bother us anyways, as you can see, now the snake is much faster and I can control it much better. But I still died. We can go back here in the game. And we can set this delay from point two to point one. So the smaller the delay number is, the faster the snake will be pay attention. Now the snake is crazy fast as you can see, look at the speed of that snake. Look at the crazy speed of that snake pay attention. We also have the score at the top. And yeah, I can control the snake now very, very well. Very Val Val. Well that is. So yeah, we have 1000 for the score. I am pretty good at this game. I'm the best nobody can beat me and yada yada yada. You saw someone we die the snake please. Short that animation, like everything disappears, goes transparent, so on and so forth. I'm going to die over here. And you saw that what I just mentioned. Anyways, this is the game that we are going to create. And we are going to learn a lot inside of this game. Even though it looks small, it looks a small game, we're going to still learn a lot, a lot of cool techniques, a lot of things that we're going to implement, especially in 2d because Unreal Engine is mostly for 3d and people don't know and they're not basically no to the tutorials for Unreal Engine out there. Except for some official ones anyways, I don't want to bla bla bla bla bla bla bla, just make sure that you comment, like the video, share it and subscribe to the channel and enjoy the course what else can I say, see in the next video, or in the next part of this video. Take care. So let's get started. And as always, you know that we first create or open the Unreal Engine Project Browser, click here on games and click on Next. Over here we can have a blank project that is not a problem, click on Next again, blueprint, we can leave that because you're going to use primarily bla bla blueprints in this project, no Starter Content over here, you are going to select where you are going to store your project and over here you are going to name it. So here I'm going to say well, we cannot begin it with a 2d. So we can say snake 2d. And then I'm going to click on Create Project. And of course, as always, we need to wait until Unreal Engine takes mercy upon us and you know, opens the project and so on and so forth. So what I'm going to do is I am going to cut out the video right now. And I'm going to come back when the project opens project. Yeah, so see in a few. And here we are, I was surprised it opened pretty quickly. Anyways, that is not important. What's important is that we click over here where it says show or hide the source panel. And then over here we have the content. Of course everything is empty, we don't have anything. But we do have these assets that you can download by clicking the link below this video. So simply download assets and you also have a complete project there as well. So this is what you need to copy but before that over here in the content, you're going to right click and click here show in Explorer. And over here it is going to open in the Explorer which is well a folder and it is going to open where your content is for this project. Let me just go back over here for the assets now copy everything you see over here. So copy this so simply you're going to right click and copy and go back over here and paste it when you paste it you will see it in your project and there you go. So we have over here the sprites that we are going to use. We also have here are flipbooks don't worry about that you can just click them now and Open them over here. We will see later on what they are, how to use them, so on and so forth. But what's important is that everything is working and we have everything set up. Now what we are going to do first things first, I'm going to right click here and create a new folder, and I'm going to call it maps. And I'm going to Ctrl S to save this current map. And in the maps over here, we're simply going to add a no name ID gameplay, because you're only going to have one map, everything is going to happen over there. So you can save it as a gameplay map over here. Now before we do anything with it, so we are not going to touch anything right now later on, we will do, the first thing that I'm going to do is go over here and again, right click and create a new folder. And I'm going to call this bad boy blue prints. Inside of the blueprints for folder, we are going to right click, and we are going to create a user interface. And it's going to be a Widget Blueprint. And I know this is not what we usually do. But you know, we are going to do it this time. So BP underscore u i HUD, this is how you can call it you can call hire however you want to call it you can call it Carl Kenny, you know, I don't know, whatever. But I'm going to call it BP UI HUD. What's going to happen here inside of our BB UI HUD. First things first in our canvas panel over here, I'm going to go on the palette here at the top, and we are going to search for a horizontal box. And I'm going to add the Horizontal Box over here inside of our panel. And here you go. This is our Horizontal Box. What I'm also going to do with the Horizontal Box is that I'm going to call it score box. Next, I'm going to click on it and I am going to click here on the anchors and set the anchor at the top center. So over here, and we are going to reposition it as well. So what we are going to do for the position x is going to be negative 150. Position y is going to be 32. The size x is going to be 400. And the size of y is going to be 64. There you go. So position x minus 150. Position y 32 size x 400. Size y 64. As the title suggests that this is a score panel. So what we are going to do with the score panel is that we are going to add a text to it. So over here in the palette in the search, we are going to filter for text and we don't want the rich text block but the usual normal text block and put it over here. Now this text block I am going to call it score title. And what we are going to do with this one is that over here, padding, we are not going to touch that alto everything can be as is over here over here for the text block, we are not going to leave it like that. Instead, we're going to say score, column and space. Also over here for the font, we are going to set it at 44 so that it is a little bit larger, as you can see over here. And also for the color, I'm going to click in over here where it says hex linear paste 741 c 00 ff and when you click OK, it's going to well be this color. Now of course you can pause the video and see this number over here. So 741 c 00 ff, but it's not important, you don't have to do it the same way I did. It's not mandatory, you know, because I know that a lot of people follow this. And they think like they need to have everything as I do. It's not mandatory for you to do that. But if you want you can pause the video and again I you know dictated two times the hex color for it. Anyways moving forward. Next we are going to again, take a text and put it over here. And this text over here is going to be our score value. For the score value. We are going to set the font size to 44. Same as what we did for the score. Over here where it says text block or the text that's inside we're simply going to say zero. And again for the hex linear color paste 741 c 00 ff and click OK. So now this is what we have, as you can see here, score there you go at the top, there you go. So we can compile and save this. Now of course we are still not done. Over here in the palette. What we can do or what we need to do, we are going to filter for a canvas panel, click on it and drag it over here not as a child of the score box, but as a child of the canvas panel because this canvas panel over here is going to be our game over panel and that panel. So the game over panel, what we are going to do with it is we're going to click on it, and over here, it says anchors, I'm going to click on the drop down list over here. For the x, I'm going to leave it at zero for the Y minimum is going to be point five. For the maximum of x, I'm going to say one, and a maximum of the Y minimum is going to be point five. And you can see now where the anchor is, is basically here in the middle, and it's stretched. So this is our anchor, again, for the minimum for the x over here, point, or actually for x is zero. for y, it's point five, for the maximum of the X is one, and maximum for the Y is point five. Now over here, where it says offset left, we are going to say 512. For the position y, we're going to say 550. So 550, for the offset, right, we are going to save 404 the size, why we are going to set that at 598. There you go. So this is going to be our canvas. And purposefully, it is here at the bottom, because later on, we're going to animate it and move it up. But before we do that, what we are going to do is the following, we are going to, again, go here in the canvas, or actually in the palette and search for a text and apply or drag and drop that text under the game over panel. Now this text is going to be our game over text and we are going to hit enter Of course, you can Compile and Save this so that we can save all of these changes. Next, what we are going to do for our game over text is that I am going to select it. And for the anchors, I'm going to leave it at the top left corner. So we're not going to touch anything here for the minimum, the maximum, we are not going to touch anything, the size x is going to be at 100. And the size y is going to be at 30. But over here in the font, we are going to leave it at Roboto bold, the size for the font is going to be 90. And where it says text block, we are simply going to say game over like this. And over here for the color and capacity. For the hex linear, I'm going to paste FF and then we have 1234 zeros. So ff 0000. And again, FF at the end, which is going to be our red color. What you can do as well over here for our game over for the text, I'm going to select it and over here we can, you know, like add a few spaces over here or a tab, and it looks like this. And you can add it all caps. So you can have it all caps as well. So again, this is not mandatory, you will not like ruin the game, if you don't put the red color. And instead you put the blue color or whatever. So I'm just saying that putting that out there anyways, Compile and Save. Last but not least save the text again. And over here in the game over panel, add that text and this one is going to be a re start text for the restart text over here inside of the anchors, we are going to set the minimum for the y to be one maximum for x going to be zero and maximum for the Y is going to be one again over here minimum for the x is zero, minimum for the Y is one maximum for the X is one and a maximum for the Y it is one over here for the offset on the left side, we're going to leave it at zero position y is going to be negative at the offset the right is going to be zero and the size y is going to be 64. I am also going to set over here I'm going to leave it the font at Roboto bold but the font size is going to be at 50. And over here for our hex linear color, I'm going to paste ff c 600 f f. So again, it's f f c 600 f f and I'm going to hit OK. Where it says the text block we are simply going to say press and over here in quotes are actually in single quotes are with capital. And again single quote and to start a new game. There you go. simply going to this play this over here. As you can see press R to start a new game and Compile and Save that as you can see, this is with single quotes so you don't have to do it. I mean you can again but it's not mandatory, it will not destroy our game and it will not make it you know like better or what ever Moving forward, let us now animate our game over panel. And in order to do that, we need to select it and over here we are going to click on the animation. And I clicked over here on the green button in case you didn't notice over here in that animation step, and now I'm going to select animation and first rename it. So this is going to be game over animation. And now we need to select this game over animation. And over here in the timeline where it says track, we're going to click on over here, and we want the game over panel Canvas panel slot, this is what we need. And when you click on that, there you go. So we have the canvas panels, slot one. Now when we click on this bad boy, now over here, when you hover over on the plus button, which is the dark plus button at the right side, you're going to click on this track. And from here, we're going to select the layout data offsets, and there you go. When you click on the plus button over here, we have the left, top right bottom, so on and so forth. And automatically, as you can see over here, we have the keyframes for all all four of these. Now this over here is the timeline or however you want to call it a basically, that's, you know, like the the track that you can move and this is the track over here, what I'm going to do is I'm going to move with you over here on one, which is one second. And for the top over here, we are going to click on the plus button to add a track over here. And for the top, we are going to move it from 550. So 550, we are going to move it over to negative 64. So over here, we are going to add and let me just type in minus 64, which is as you can see, it is going to move the panel at the top now again over here only for the top, we're not going to touch the left, the right the bottom, the so on and so forth. So we are not going to touch any of these Now make sure that you Compile and Save this bad boy. So again, it is only for our top, and it goes by clicking here on the animation to create the animation, I'm going to remove it when you create the animation. So click on the plus button. When you create that animation over here for the track, you are going to select First things first, like this one over here. And now select the game over panel Canvas panel slot when you select that, and from there, you're going to click on the plus button over here. And you're going to select the layout data or offsets. And of course for the top we are going to move it so there you go. So now we have the animation as you can see over here. So there you go. This is animation, Compile and Save that. Now before we proceed, we are also going to do a little bit blueprinting, which is what I call the blueprint programming. So over here, select the restart text. And over here, when you select it over here, in the details tab you have this is variable. So we are going to click on that. So click on each variable. And over here for the game over do the same thing, click on each variable. And for the score value as well click on his variable, let me just Compile and Save that, when you do this, you are enabling these variables are these elements, the text elements, the UI elements to actually be variables. So now we can go here in the graph at the top right corner, as you can see, so over here, when we click on the graph, we're going to go over here. Now we don't need the pre construct, we do need the construct and we will use the tick as well. Or actually we will create an invent for that. But over here in the event construct, what we are going to do is we are going to take the game over text, so we need the game over text and we need the restart text. There you go. And from here, we are going to set visibility, so drag a note from them and click on Set visibility. And I'm going to plug in the execution order over here. And I'm also going to plug in the restart text over here as well which means both of these now are the targets for this and we are going to set the visibility to hidden which means they will not be visible. So when we run the game, we are not going to make the game over and the restart text visible. Next over here below that I'm going to right click and create a custom event. And this custom event is going to be update score. The update score is going to have a parameter so click on it and over here for the inputs click on the plus button and the parameter over here is going to be score and instead of Boolean we are going to make it an integer. So now from here, we're going to take the score value. And I'm just going to move a little bit down. Take the score value and put it over here. From the score value I'm going to say set text Like this, plug in the execution order over here, and plug in the score in the text, and of course, it is going to automatically convert this integer to a text and plug it in over here. And this is how we are going to display the score to the user. So this event is going to be used to display the score as I already said. And last but not least, again, right click and create a custom event. Now this custom event is going to be our game over event like this. And for our game over event, we are going to take our text again. So we can select all of these and we can Ctrl C to copy them, and then Ctrl V to paste them. And I'm going to plug in the execution over here. But this time, it's not going to be hidden but visible. So the visibility is going to be visible, which means we are going to be able to see the game over text and the restart text. And last but not least, we're going to take the game over animation, the one that we have created a moment ago over here. And from the game over animation, we're going to drag and know that we're going to say play animation like this blog in the execution order over here. And everything is going to be as easy as playback speed is going to be one, the Play Mode is going to be forward over here in animation Game Over animation start at time zero number of loops to play is going to be one and Compile and Save that. So this is what we are going to use later on when we create our UI widget, we are going to use it and we are going to first get a reference to it. And then from there, we are going to use these custom events to play the animation when the snake dies, update the score when we have the new score. And of course hide the text. When we start the game. Moving forward, we are going to go back here inside of our gameplay. And I am going to select everything inside of the level. So from atmospheric fog to sphere reflection, capture, and simply delete all of that, and yes to all delete everything, and we have a dark level. Of course, this is not what we want. So we are going to go here inside of the sprites folder. So this is our sprites folder. And I'm going to drag here, the background sprite, so I'm going to put that inside. And I'm also going to find the gray back ground. And let me just find it here. Here it is. So we have that gray background sprite, and we have the back ground sprite, what we are going to do is select the back ground sprite for the location x over here inside of the transform. So this bad boy over here, the location x is going to be at zero. And what did I do, I apparently deleted it. So select the background sprite over here location is going to be zero for the X for the Y is going to be negative 20 for the Z it is going to be zero rotation, we're not going to touch that. But over here for the scale, we are going to set it to be 555 on all three axes. So x, y, and z, all three of these they are going to have that scale. Now also, what I am going to do is here for the sprite color, instead of white, we're going to set over here the hex linear 2345 C, nine zero FF. So again, it's 345 c nine zero FF and again, you see it just changes a little bit the color. And again, what I wanted to say is, you don't have to have exact the exact same color as I do, but if you want just pause the video, we're here, take a look at this hex linear again, 345 c nine zero f f. Now moving forward for our gray background Sprite. So for the gray backgrounds, right, we are going to set the x at minus 50. This is for the position the position y is minus 10. The position z is going to be minus 50 rotation, we're not going to touch that. And over here for the scale x is going to be 12. Scale y is also going to be 12. And last but not least the scale z it is going to be 10 There you go. Now also for this bad boy, we are going to click here on the sprite color and where is that it's basically right over here in the sprite. So when you click on this bright color over here hex linear, I'm going to paste this for two to a five nine c c. So 422 a five, nine cc or simply pause the video and check out for yourself. I'm going to click ok and this is what we have. So this is going to be our game background. Now of course we're still not finished because we do need to add one more thing over here. So I'm going to go over here where it says please actors in search for classes here. I'm going to filter for the camera and I'm simply going to drag and drop this camera over here. Now for this camera, we of course need to reposition it. So select the camera, the exposition is going to be minus 50, the y position is going to be 100. And the Z position is going to be also minus 50. So it's minus 50. There you go. And the rotation on the z axis is going to be negative 90. And this is what our camera sees. If we select the camera, you see over here, when you select it, and you click on it over here in the world outliner, this is what the camera sees. But of course, one more thing that we need to do is over here, the projection mode, I'm going to change it from perspective to orthographic. And automatically, you can see how the preview of the camera over here changed. Now also over here, or toe width, I'm going to save 4500. And again, you see over here, how the camera view changed, or what the camera sees, has changed. Now again, I'm not going to like experiment with this, you can see this on your own what is what this is doing the order the width, and you can change from orthographic to perspective to see the difference. So that way you can instead of me explaining what it does, it just changes the view of the camera and the width, and so on and so forth. But again, as I said projection mode, just change it from orthographic to perspective, and vice versa. And you will see that now we do have one thing that is not working if I hit the play button, this is what we see. And this is not how we want to see our level we want to see it, as we saw in the preview of our game. How the camera is looking at the level so that we can actually see it better. And in order to do that. While we are over here inside of the gameplay tab for the gameplay level, we are going to click here on this blueprints drop down list. So click on this drop down list. And we're going to click on Open Level Blueprint. And it is going to open this over here, we don't need the tick event. But what I'm going to do is I'm going to move this over here and go back. So as you can see I have a floating window. So I have a floating window of the gameplay level over here on I'm simply going to do is take the camera actor and place it over here. So from the world outliner here it is simply get the camera, drag it and drop it over here. And now we can well dock the gameplay tab again. So now that we have the camera actor, what we are going to do is from it or simply over here, can I do it like this set view target with blend, no I cannot I need to drag a note from the camera actor over here I need to say set view target actually. So we need to do this actually from the Player Controller. So right click over here we need to say Get Player Controller and from him. So excuse me for this one. from him, we need to see set view target with blend, there you go. So this is where it was. Unreal Engine has so many functions, sometimes you forget where they are. So over here, the new view target is simply going to be we're going to plug in over here, the camera and everything here we're going to leave it as is blend times zero blend function vt blend linear blah, blah, blah, blah, blah, blah, Compile and Save that. So again, it's from the Player Controller. So right click, and over here Get Player Controller This is how you get the Player Controller. And over here we have from the Player Controller, you drag a node you type set view target with blend, and this is going to be or this is going to set the view on the camera that we have specified. And over here new view target is the camera actor from the level. So Compile and Save that again. And if we go back over here in our game plan, kid the play button, there you go. So this is this is what we want to see. And this is well our desired outcome. So if I hit the play button, now this is our level. So this is how we want to see it with our main camera moving forward. Now we are going to start adding elements inside of our game. So over here inside of the blueprints first we're going to right click and go over here under blueprints. And we're not going to create a blueprint class or none of these except for the enumeration. So click on the enumeration and we're going to call this one food color underscore e num There we go. So again, it's right click under blueprints and then enumeration and when you open it over here what is this well enumeration or enumerators are basic we can create them however want to create them. So for example if we click here on new, you see over here we are going to click on new and we have a new enumeration and we can give it a name What whatever we want, and we are going to create four of these. So the first enumeration over here is going to be blue. This is what I meant when I said we can create however, we want to create them. So we can give them names, whichever we want. So over here, we can say purple. For the third one, we can say red. And for the last but not least, we can say yellow. And same way you can create I don't know, like, you can create enumerations for Kenny, Carl, Johnny, Bobby, whatever, so you can give them names. And later on inside of our game, we can use these enumerations to compare them with each other to basically check if we have the same item. For example, if the color of our actor is blue, or purple, or whatever, we can even use this for tags, we can give them tags over here, we can compare them later on, so on and so forth. So this is for what we are using the enumerations. So the next step, now that we have the enumeration, we are going to go back over here, I'm going to right click, and this time, we are going to create a blueprint class. And it's going to inherit from the actor. And we're going to call this bad boy BP food. So we are going to use this to actually create the food. So I'm going to double click this, open it of course here in the Blueprint Editor. Now the first thing that we are going to do is over here is click on the Add Component. And we are going to filter for sprite and we want the paper sprites. So this will be one of the paper sprite components. If I hover over you will see it's a paper sprite component. It's a component that handles rendering and collision for a single instance of a new paper. Basically, this is a component where it will allow us to display an image and I'm going to make it a default route. And I'm going to rename it to food sprite, there you go. So I can compile this and save it. And of course over here inside outside, of course, like you knew that was coming. So we're here in the variables, we are going to create a score variable. And this is going to be an integer and I am going to make it public and Compile and Save this bad boy. So this is when it comes to our food Sprite. Now of course, we are still not done. Instead, what we are going to do is we are going to go here in the Event Graph. And from here, I'm going to remove these two in the Event Begin Play, we are going to create a custom function. So right here below, we are going to get a custom event and I said function with a custom event. And we're going to call this set food. And from here actually First, I'm going to click on it. And what we are going to have here, so click on it and over here we're going to have an input which is a parameter. So we're going to call it the type and from the drop down list over here we are going to click here and in the search, we are going to say food. And there we go. So we want the food color e&m so this type that we're going to pass here, inside of this custom event is going to be the food type enumeration that we just add it. Now over here when we begin the event, or will we begin play we're going to call set food. And let me just find it over here. Where is it? Where is my custom function, here it is. So set food. And we are going to leave it at Blue and pay attention over here because we set the type over here of this parameter to be the food color enumeration. You see that we have blue, purple, red and yellow, which are these over here that we have created. So we can Compile and Save that There you go. Now what we are going to do with this set food is that we are going to get our food sprite so we are going to put it over here get it because based on the food we are going to order based on the color of the food we are going to change the sprites appearance. So from here I am going to say switch on first from here from the type we can say switch and it is going to create a switch on the food color. And over here as I said on the food color, we have the blue, purple, red and yellow, which are the ones that we have created. So I'm not going to go back again because we already know that now from here from the food sprite, I'm going to say set Sprite. And there you go. Now what I'm also going to do is copy and paste this, paste it again and paste it again. So you have four of these possibilities. When I say possibilities that is we can have the blue color over here we can have the purple color, we can have the red color, we can have the yellow color. Also this food sprite goes into every single one of these. So make sure that you do that you can move this a little bit away like this so that you can see it more clearly. That's up to you. And there you go. So this food sprite needs to go in every single one of these for the target, as you can see, because we are targeting that food sprite, now that we have our everything is set up. So for the switch on the food color, we plugged in the food sprite over here, when we have the blue one, we are going to click here and we're going to select the blue polygon Sprite. Because again, as I said, if the food if the in among the food is blue, we are going to set the blue polygon. And this is what I said a moment ago. So over here, based on the switch on the enumeration food color, it is going to tell us if it's blue, then it's going to execute over here. So if it's blue, it's gonna execute this if it's purple is gonna execute this if it's red, this and so on and so forth. So over here, if it's purple search for purple, there we go purple polygons right over here, we have the red, so type red, and we have the red polygon, not the Red Square, but the red polygon Sprite. And last but not least over here, we have the yellow. So over here we have the yellow polygon, Sprite, there you go. Now what we are also going to do is we are going to set the score. So over here, set score, like this, copy and paste this bad boy, and it does go This goes over here, paste it one more time, this goes over here. And last but not least for our yellow, also paste it like this, this goes over here, come on, let us go back. There we go. So now over here, if we have the blue color, we are going to set the score to be 100. If we have the purple color, we're going to set the score to be 50. If we have the red color, we're going to set the score to 20. And last but not least, if we have the yellow color, we're going to set the score to 10. And we can compile and save this. Next, we are going to wait and delay. So we're here we're going to delay. And we are going to delay for three seconds. If is the blue color copy and paste this and I'm going to plug it in over here. If it's the purple color, we are going to delay two seconds. And last but not least, if it's the red color, we are going to delay one second. Now we are not going to delay if we have the yellow color. So we're going to leave it as is Compile and Save that. After we delay what we're going to do well over here, now we're going to set the food like this, there you go. And we're going to set the color to purple. And I'm going to copy and paste this. And this goes over here. And let me just move these a little bit like this. And generally move the whole function over here. There you go. And I say function. It's a custom event. But it's basically, if not the same thing, it's similar. And over here we have another set food and this time this is going to be read. And last but not least over here we have the food. And we are going to set this bad boy to yellow there you go Compile and Save that. So first, when we go into set food, we are going to go into switch and we explained this based on the color we are going to set the sprite of our or the color of our foods prior to that Sprite. And then we are going to set the appropriate score based on that as well. And after that we are going to delay. Depending on which color we have, we're going to delay a certain number of seconds. And after that, we're going to change the color of the sprite again, so simply Compile and Save this. So this is for our BP food. Now before we proceed to create the gameplay mechanic, we still need to create a couple of more actors over here blueprints. So we are going to create another blueprint and it's going to inherit from the actor. And this one is going to be BP block. There you go. So double click this bad boy open it over here. And what's going to happen is we are going to go again under Add Component and filter for paper sprite, and it's paper there it goes sprite, so this will be one and this one is going to be our block Sprite. What I'm going to do with this one is over here for the source of the sprite, we are going to click on the drop down list. And we are going to filter for gray square sprites. This is what we want. So this is going to be a sprite that's going to represent our block over here for the location for the why we're going to say minus 10, just so that we can move a little bit backwards. And we're not going to touch anything else. So make sure that you compile and save this as well. There you go. Moving forward. The next thing is let me go back over here and right click blueprint class and again, it's going to inherit from the actor and this one is going to be BP underscore snake body part. So there you Go. And what I'm going to do is double click this bad boy and open it to open it over here inside of our editor. Now what's gonna happen with the snake body part is that we are going to use a paper flip book. So over here at component, we're going to filter for paper flip book. And what the hell is a fake paper flip look, first, let me just set it to be the default scene. There you go. So we have our paper flip book, we are not going to add anything over here inside of our source for it. But over here for the variables, you're going to click on the plus button and we are going to see is head and this one is going to be public. So make sure that you check this eye box or this eye over here, so that we can make it public. Because of course, we want to, you know, access it later on in other sprites and determine if this is the head or not. Now what the hell is a paper flip book, paper flip book in Unreal Engine will allow us to create an animation and here it is, you see flip books, and we already have the bait, the beat flip book and the blank flip book. If I hover over over here, if I hover over if I right click and go to paper 2d Here is where you can create a paper flip book. So it's simply right click paper 2d paper flip book. And you can call this one test book, for example. And you can double click on it, and you can open it here. So what is this what the hell is this, let me just open the one that we already had over here, the beeth one, there you go, you see, and let me just stop it because it is animating. So this is basically a way inside of Unreal Engine to animate sprites. And the way this works is there are multiple ways how you can create animations like the ones you saw over here, you can go over here and you can right click to add a keyframe and there we go, we have a keyframe and you can right click on that and then over here you can pick a sprite for example that that sprite one and you can save that so when you save it and this is not what I want. So save it if I preview it, let me see do we see it actually for some reason we don't so let me just do this. I am going to close it go back over here and open it and now we see it. Now you can also do it like this you can go over here and click c you can move this handle over here to go at the last frame and then you can click on add the new frame so now we have a new frame and again a new frame a new frame a new frame so we can do it like this as well. And let me just delete these so we can delete them all because you can also drag and drop them so the lead the lead save you can also move this over here and then from here from your sprites you can then drop your sprites for example can drop this one over here or simply over here in the frames to create an animation you can drop one then the second and the third and so on and so forth are over here the new keyframe and you can click here and pick a dead sprite one image add the new keyframe right click pick new sprite lets that to sprite image and let me just save that. So when I preview it, you see automatically the animation is being played. So it's a simple, it's very simple. It's not complicated. getting something is not clear, make sure that you ask in the comment below. But basically, you'd simply right click Add keyframes or click here to add keyframes and then on those keyframes, you right click and select the sprites you want so that you can create the full animation. This is what we did over here. I already prepared this so that we don't have to do it. But I explained right now how it is done. And if I preview it, this is that animation. So we have 11 sprites or 11 frames. And again, paper flipbook is a way to animate sprites in Unreal Engine. So here in the flipbooks weekend, let me just save everything, we can delete this textbook because we don't need it anymore. This was just for an example to show you how it works. And you can also delete it from here because we don't have to like we don't need to keep it over here. Again, if something is not clear about what is a flipbook and how it works just make sure that you ask in the comment below the video, let us move on the main part of our game and here in the blueprints we are going to right click Create a blueprint class which is going to inherit from the actor and this one is going to be BP underscore main game and I'm going to drag and drop this bad boy in side of our game now inside of the level that is and this is we are going to position 000 for all three axes. But you know it It's not important, just some I don't know, I'm weird like that I like to, you know, position things. Anyways, this is going to be the main blueprint, or the main actor that is going to control, initialize and do everything with our game. Now before we start programming everything over here in the Event Begin Play, I'm going to remove everything and over here in the variables, first, I'm going to click here, and we're going to have snake parts. So snake parts array, not a rat, but it's an array like this. And over here, we are going to search for our snake body parts. So here BP snake body parts, and I'm going to click here object reference. Now, as I said, this is going to be an array, there are two ways how we can declare an array if you don't know that, so you can click right click on this blue circle over here, or you can click on here. And then from there, you can choose so from here, if I click on you can see we have a single variable, we have an array, we have a set, we have a map, we are going to click here on the right, or as I said over here, we can right click, so we can right click over here. And there you go. So when you see these, like these grids over here, if you didn't know that this is now an array. Now moving forward, we are going to click on the plus button, we're going to have over here direction z, and this one is going to be an integer and click on the plus button again, there's going to be direction x, there you go. So Compile and Save that now directions in direction x, they are not going to have any default value. So they're going to have default values of zero. Moving forward, I'm going to click here on a new variable, and we're going to say can change direction, this is going to determine if we can change the direction with the snake or not. So Compile and Save that moving forward, we are going to have x underscore max. And this one is going to be a float. And by default, I'm going to set the value of it to be 1200. And click on the plus again and we're going to have z underscore Max, make sure that you Compile and Save that and for the Z, the maximum is going to be 1000. So for the x max or x maximum 1200 for the Z max, it is going to be 1000. Moving forward, I'm going to click here and we're going to have a food actor reference. So food actor ar e f, and from here I am going to search for food. And we want the BB food and we want the object reference Compile and Save that. Moving forward, we are going to have our wall blocks array which not again a rat what is what is wrong with me with the rat. It's an array not on a rat, anyway is this going to be RBP block. So from here, click in search or filter for the block. So this is what we want BP block and just to be sure BP underscore block here you go select the object reference and make it an array. So we want the wall blocks to be an array moving forward, click on the plus button over here to add a new variable and this one is going to be delay not the ol I what I wrote over here a delay variable which is going to be a float. So from here we have a float. Let me just compile this so that I can add a default value over here so the default value is going to be point to Compile and Save that. Moving forward we are going to have another one which is going to be is dead. And of course you can assume this is a Boolean because it is going to determine if the snake is dead or not. Next we are going to have the HUD r e f or the reference to our HUD which is going to be our game Hots over here simply filter for HUD. And this is what we want BP you I heard and this is the one that we want which is the one that we have created. So Compile and Save that moving forward. Last but not least we are going to have the score which is going to be an integer so make sure that you compile and save that as well. So this was the preparation for our main game blueprint which is going to control our game. As you can see over here we have all the variables for the snake parts we're going to store the snake parts that we create because you know the snake eats a jam or eats a fruit or whatever in the game and then it grows. Whenever we eat a new item we need to make the snake large Those parts are going to be stored inside of this array direction z and x. This is pretty self explanatory, it's the direction where the snake is going can change direction can we you know change the direction self explanatory x, maximum z maximum, these are the speeds for the x and the Z we will see later on how we are going to use that food actor reference self explainatory wall blogs, these are the walls that we are going to you know create like this in the game to strip the movement of the snake. So, this is the reference where we are going to put them that the lane is going to be the speed of the snake we will see later on how we can increase it is that self explanatory hard self explanatory score self explainatory. And I don't think that, you know, we need to explain that moving forward here in the Event Graph, first, we are going to right click and create a custom event. And this custom event is going to be called spawn new snake part, which is going to do what the title says or it name says is going to spawn a new snake part. Now we are going to have two parameters. So click this new parameter here on the input two times one, two. So over here, the first parameter is going to be our spawn location. And the second parameter is going to be is head for the spawn location, it is going to be a vector because vectors represent a location x, y, and z. Next, what we are going to do is from here, I'm going to say spawn actor from class. And the actor that I'm going to spawn over here, we are going to select the class we are going to say snake body part. There you go. Now here we are going to have the spawn transform, and we have here the location. So what we need to do is right click on the spawn, transform and split struct pin so that now we have the spawn transform location, and I can plug this into the location, we are not going to touch the Transform, rotation and scale and so on and so forth. Over here collision handling override specifies how to handle commit collisions at the spawn point. Basically, we are going to click on the drop down list and we are going to say spawn always are always spawn ignore a collision. So we don't we don't care if there are any collisions at the split space or the spot where we are going to spawn our snake. Now moving forward, we are going to drag from here from the head, we are going to say select like this, and you want this one over here, see this one that has this over here, this like yellowish icon. So that's the one that you want. So I'm going to do it again select and here we go, this is the one that we want. I'm also going to double click here on the pin so that I can you know, restructure it like this, I can make this a little bit clearer, it is better, it looks a little bit better. And we are going to do it like this. So there you go. So what we are going to do on these pin structures is that we are going to based on what's going to happen over here. So based on the value if it's true, or if it's false, I am going to let me just see it like this. So over here, let me just Compile and Save that. So this is okay. What we need to do over here is first drag from the drag from the paper flip book. And for some reason the target over here needs to have it so we're going to get the paper flip book. Let me just see it over here. Here it is the paper flip book from the returned value which is basically let me just go over here and this thing body parts This is that paper flipbook. So we are going to get that paper flip book and we are going to from here we're going to say set flip book. There you go. And we are going to set this the return value, we're going to plug it in over here as soon as we plug it in. As soon as this value is plugged in over here, the true and the false will automatically give us it will give us an option to select a paper flipbook. So I'm going to plug this in there you go, bam, you see right there. And let me just move this here. There you go. This goes over here like that. So if the is head, if it's false, we are going to select the yellow square flipbook. So this is the one that we want. If it's true, we are going to select the Red Square flipbook and we are going to Compile and Save So again, if it's false, we are going to select the yellow square flipbook. So yellow square foot book. If it's true, we are going to select the Red Square flipbook. So if it's a head, it's going to be represented with red. And this is what we are going to do. Now the next part or the next step that we are going to do is, after we set the flipbook, we are going to get the snake parts array. And we are going to from here, create a node and we're going to say add, which is going to add to this, it is going to add to this array. Now we need to add a new element, the new element is going to be the returning value over here that we have created from our spawn snake body part. So I'm going to take this return value and plug it in over here. But before that, I am also going to double click on that, no, then move it like this and double click on the node again so that I can you see it so that I can create like this. And now we see that it goes, the node goes from here to here, and then goes over here to add it into the snake parts array, which is what we want. Now the next step that we are going to do is from here, from this one, we are going to say set is head, and that goes over here. And again, I'm going to double click on the node just so that it is more visual, visually clear what we are doing. And here is head we're going to plug in this one. And again, I am going to double click on this node and move it over here like this, we can clearly see this goes from here his head, and then we're going to plug it in over here and then it goes from here over here. And we're going to plug it in and set it to the node if it's a head or not. So now moving forward, we are again going to drag from this node, which is again the snake body part that we have created because now we are going to set the actor or rotation for the snake body part, this goes over here and then we double click again on the node itself. This goes over here. And in order to set the rotation for our snake, what I'm going to do is I'm going to get a random integer. And this random integer is going to have maximum of three because over here, if I hover over returns and uniformly distributed random number between zero and maximum minus one, so we can get well as you can see, so zero maximum minus one, what we are going to do over here is we are going to plug this into a select. And there you go. So we have now the Select over here, I am going to add two more pins. So we have options 012 and three, and option one First things first, I'm going to split the pin structure here for the rotation. So split struct pin. And we are going to plug in the return value over here inside of the why for the pitch. And when you do that automatically, these options that are going to convert into integer actually float values. So when I plug it in bam, they have converted into float values when we have option while we're going to say zero when we have option two, we are going to say 90 degrees. Option actually options here, option one is 90, option two is 180. And option three is 270. And we are going to Compile and Save that. And if you're wondering why I added option three, well maybe you decide to later on add here maximum for four. And there you go. So Compile and Save that this is going to be our spawn new snake and I'm going to put it in a comment, right click Create a comment from section I'm going to say over here, spawn new snake part there you go, Compile and Save that. Next we want to spawn our food. And in order to spawn the food, the first thing that we are going to do is this, we are going to get our x maximum and we're going to get our z maximum, we're going to put them over here. Now what's going to happen is for the x maximum, I'm going to say minus float. And the float that I'm going to subtract it or subtract from it is going to be 100. So 100. Next, what I'm going to do is from here, I'm going to multiply this with a float. So I'm going to multiply this with a float, the float that I'm going to use to multiply is going to be negative one. And the reason for that is because you see subtraction, A minus B, the return value over here is actually the result from this. So I'm going to multiply the result with negative one, because I am going to use over here a random, random float in range. And the minimum is going to be this value multiplied by negative one and the maximum is going to be this value. Let's assume z or x maximum. Well actually it's 1002 100 minus 100, we are left with 1100 multiplied with negative one, we have negative 1100. And over here we have the positive 1100. Next, what I'm going to do is from here, I'm going to right click, and I'm going to say division, and we want the division with the whole and remote remainder. The You see, if I hover over returns, the number of times divisor will go into the dividend. So the divisor is this number that we have over here, it will return how many times this number goes into this number. dividend is this number over here, the last the random float in range, and the divisor is going to be 100. So this is going to return how many times divisor goes into the dividend, it is going to return the value over here, but the remainder is how much did it remain from the dividend. For example, let's say the dividend is 1050. The divisor is 100, it goes 10 times into 1050. So the return value here, we'll say it goes 10 times inside, but what's remaining is 50. Because 10 multiplied by 100 is 1000 1050 minus 1000, we are left with 50. And this is what we are doing over here. Now last but not least, we're going to take that return value and multiply it with a float. And that float is going to be 100. Now we are still not done, we are going to go back over here for our x maximum. And here we're going to say minus float and do the same thing. So minus float, the minus value is going to be 100. And over here, we're going to multiply that with a float. So multiply that with a negative value over here. So we are going to say minus one random float in range, this is going to be plugged in over here, this is going to be plugged in over here, basically doing the same thing. So we can copy these two and paste them over here because the return value goes into the dividend. And over here we have 100 for the divisor, and we're going to multiply this with 100 as well. Because now over here, I'm going to right click, and I'm going to create a custom event. And this custom event is going to be called spawn food. And from here, I am going to say spawn actor from class. And the class that I'm going to use is the BP food or simply type food. And there you go. Now what we are also going to do is for the transformer going to split the struct pin, but I'm also going to do that over here for the location, right click on the location and split struct pin, because now I can plug in this one on the x. And I can plug in this one on the location z and the location y is going to be equal to negative 0.1. Because we are this is a 2d game. And we have the x and the Z. So over here, x and the Z and Y is basically to move it backwards like this. So we don't care about why. And for the collision handling, we are going to say always spawn, ignore collisions, and you can Compile and Save that. And of course, the last step over here is that we need to set the set food actor AR F. So we are going to set the reference to the food actor because later on we need to test if our snake is colliding with the food actor. And I'm going to right click and create a comment over here and this was going to be spawn food and make sure that you compile and save that as well. Now what is happening over here? Well basically again, we are just doing some basic calculations over here from the x maximum and the Z maximum. So that we can as you can see, x maximum is 100 or 1200. And the Z maximum is 1000. Now why is that if I go back over here, and let me just take a sprite and let's say this is the food and this is where we can put the foot pay attention to the x value over here. It's at 1000, negative 1180. And on the z axis, if I move it down like this, it goes to negative 900 or negative 1000 here is the positive 1000. So this is basically what we are doing. And again, if you are wondering why am I subtracting 100 from that because again, if I said the Z to 900, you see it's right over here at the top. So this is what we are doing. So there you go, and this is why so basically, we are going to use the these values to randomly So again, it's these values to randomly spawn our food within these bounds because As you can see, if I go over here, if I select the food, and if I go over here, this goes up to negative 1000. You see 1100. This is where it goes, if I move a little bit here towards the edge, it's negative 1170. If it goes over here, it's positive 1000. So there you go, is going to spawn it within those bounds. Basically, this is what we are doing. Did I move this by any chance? I don't think I did. I don't think that the negative 50 minus 10, minus 50. Yeah, that's okay. 12 to 1210. Yeah, that's okay. That's okay. So yeah, we are again, these values are going to randomize and spawn our food within that range that we just saw. So this is what we are doing. And now that you know that you can easily calculate or see which numbers are going to basically this is going to return a random number between negative 101,100 and positive 1100. And this is going to do the same thing, but for the Z max, but because the max is 1000 is going to return a random number between negative 900 and positive 100. There you go. Positive 900. Excuse me. Anyways, moving forward, I'm going to right click here and create another Custom Event. And this custom event is going to be called kill snake, which is basically going to do the killing of a snake symbol going forward, you're going to set that is that and is that is going to be true. So make sure that you said that over here. After we set the snake to be dead, we are going to take the snake body parts. And we are going to right click over here. And we're going to say for each loop, because we want to loop through each element inside of this array, I'm going to plug this in over here and the array that we're going to loop is going to be the snake parts array. Now what's going to happen over here is that in the loop body part or loop body, we are going to set the from the array element, I'm going to get the paper flip book. So let me just get it here it is get the paper flip book because we know that the snake body part has a paper flip book. And from here I'm going to say set flip book. Here it is. So this goes inside of our loop bodypart There you go. So every loop, we are going to set the paper flipbook, and we're going to use the array index, and we're going to say e select on it, there you go. And based on the options, we are going to our actually let me just remove this we are going to take the array index and we're going to test that if it's equal to zero. And based on the options over here, we're going to say East select now on this Boolean. And let me just move this over here. And I'm going to plug in the Boolean over here, which is going to give us the options to if it's false. We are going to select the beat flipbook. If it's true, we are going to select the blank flipbook. What this means. Basically, in our snake body part, the first element that's inside of the array is going to be the head. So what we are going to do over here, if the array index is equal to zero, that means it's true. So we have the head for the head, we are going to use the blank flip book, because the head is not going to explode like this flip book over here. Basically, this is the animation for this flipbook. So this is how we are going to animate the flip book for the snake body part. It's like you know it's dissolving, it's going away, this is what we are doing. So if the element is if the array element index is zero, meaning it's the head, then we're going to use the blank. If it's false, it's not the head then we're going to use the beat flipbook. This is what we are doing now when it's completed when all of this completes, and I'm going to move this over here. So when it's completed, when the looping completes, we're going to go inside of the delay, and over here the delay is going to be point five of a second so we are going to wait half a second and after that we are going to go inside of for each loop again, for snake parts array again. So over here, get the snake parts array, and we are going to go in the for each loop. We are going to loop through this snake parts array again and this time we are going to set every paper flip book so the loop body part from the target. We're going to get the paper flip book, which is this one over here, get the paper flip book. And over here we're going to say set, Phillip book. Here you go. This goes over here. We're going to plug it in and this time we are going To set the blank flipbook. So here it is, for every single one of these when it finishes. Why? Well, because we want to simply, we want to simply make the snake disappear when we set the blank flip book. And if you go back over here, if you selected in the blank flipbook, there is nothing, which means nothing will be represented in our, in the snake. So the snake will simulate disappearance, this is what we are doing. And I'm going to right click over here, I'm going to say kill snake. If something is not clear, make sure that you ask but basically going through this again, when we call the kill snake event, we're going to set the is that to true, then we're going to loop through the snake parts array. And if the index is equal to zero, that means it's the head if that is true, set the blank flipbook so that the head is not visible. If it's false, it's not the head, it's the rest of the parts of the snake then set the beat, which is going to preview this animation that we already saw. And when the loop completes, and when we loop through every single element in that array, we're going to wait half a second and then loop through the snake parts array again, and this time for every single element inside of our array, we are going to set the blank flip book, which is going to make the snake not visible and look like we killed it in the game. Last part for our custom event, we are going to create your custom event and this one is going to be update score there you go over here, the score is going to have a parameter which is going to be the value, we know it's the value and the value is going to be an integer, Compile and Save that. So now we are going to take the score over here get the score. And this video we are going to say plus integer, so we are going to add these two. So we are going to add to the value that we pass over here the current score value. And after that, we are going to set the score. So set the score and plug this in over here for the new value. And after that we're going to get the HUD Reference that we will create in a moment. Don't worry about that. And over here, we're going to say update score. And this goes over here. And this goes over here. There you go. If you're wondering what is this update score, simply double click it go over here. And you can see, we are going to have the score value over here. And we're going to plug it into the score text that we already explained inside of our UI, HUD, which is going to display the score to our user. And this is how we are doing it. So we are going to pass the value over here. add to it, the current value of the score said the new score value passes through the update score function of the HUD Reference, make sure that you compile and save that and let me just right click over here create a comment and this one is going to be update score. Again, if it's not something it's not clear, but this should be self explanatory because this is not complex at all. But ask in the comment below. If it's not clear, and I will explain it. Now we can start adding all of these features in our game. And first, you're going to start over here with the Event Begin Play. And inside of our Event Begin Play, the first thing that we are going to do is we are going to create the HUD digit, and we are going to do it like this, we're going to right click, and then we are going to see, say over here Create Widget. But before we proceed, I'm going to right click on this node. And I'm going to click here to collapse notes. There you go. And now that is collapse. I'm going to call this node create herd widget. Now what the hell is this collapse? No. Basically, when we click in here, this is where the action happens inside the Think of this as a function. That's the best way to explain it, we group nodes inside of this collapse graph, so that they don't take too much space over here. So if I double click this, what we need to do is put this place this node on the input over here now and when I compile and save that and go back, you will see now that we can drag a note on this collapse graph like this. And if you're wondering how I'm going back and forth, well, I double click this to open it over here. But in order to go back, you're going to click this back button, which is right there. Now over here, I'm going to select the BP UI HUD that we want to create. After that we are going to set our HUD Reference. I'm going to drag the note for that. So we're going to set it this is the HUD Reference. There you go. And last but not least, we need to add it to Viewport so we need to say Add to Viewport And who are we adding to the viewport? Well we're adding our HUD And last but not least drag this node on the output to create the output line node but you can also do is Over here, right click, and over here you see, I can go back and I can click in here instead of then I can say, for example, next or something like that you can see, it's renamed to next meaning what is the next thing that we will do if you click over here, for the input that says execute, you can do something like do or whatever. But you can see over here do and then it continues the execution. So again, this collapse, no does he do and then next, basically, you don't have to do that. But you can, it's not mandatory, it will not change the game, it will not do anything. But you know, if for your own reference, if you want to do that, you can. But again, this collapse graph allows us to group all of these inside of the single graph. So instead of having three of these, so three of these over here, we only have this one collapse graph. So the next step is to get a random integer. So I'm going to say random int. And I'm going to right click on it and collapse the note. And I'm going to call this one select. So this is going to be select random direction random start start direction. And before we actually proceed on this one, we can test the UI widget if it works. So let me just go quickly back over here, if I hit the play button, make sure you see over here we have this score, we don't see the game over tab, or the game over panel because it is down there. So it's down there when the snake dies, we will see it. But what you need to do in order to have this if you don't see it, you need to drag from the blueprints, you need to drag the BP main game over here in the level so that it is over here visible in the world outliner. If you don't do that, then when you run the game, you will not see this score, and so on and so forth. So if I go back over here, now we have the Select random starts direction. And what we are going to do over here is from the random integer, I'm going to set the value to be three. And what I'm going to do is do us switch on this int some way to say the word shits like this switch on integer, there you go, I'm going to plug this into the input over here, and we're going to have 1234. And this default I am going to remove so we have these from zero up to three. Now what's gonna happen is, if we have zero, we're going to say set direction x. And from here, the direction x is going to be one. And I'm going to copy and paste it because if we have one, we are going to have the set direction x but this time direction x is going to be negative one. from two, we are going to have set directions z, which is going to be equal to one and copy and paste it again from three over here, we are going to have our direction z, which is going to be minus one. Simple as that. And now we are going to drag all of these nodes. So from here, plug it in like this, and I can do something like this, double click on the node. So now we can plug all of these nodes over here in this single dot, which means over here in the input, we go and we get into the switch integer based on the random value of 301. And three, we are going to select the random direction x to be one, or minus one, or Z to be one or minus one. And after that we are going to go into the output, make sure that you Compile and Save that. So now we can plug in this over here. And we can continue the execution because the next step is to get our delay. So from here delay, I'm going to set it I'm going to right click on it and collabs the nodes and this one is going to be set up date delay in parentheses, Snake speed, because as I said, if you remember, the delay is the snake speed. So this goes over here, this goes over here and the speed of the snake is going to be point two in the beginning. And I'm going to compile and save that and go back over here, plug this in. And as I said, this serves a weight as a way for us to group our nodes. And you can think of it as a function, which means that basically, the execution goes like this, the Event Begin Play begins it goes over here inside of this create UI widget collapse graph inside it is going to create the widget, set a reference to it, add it to viewport and then exit outside of that collapse graph. And then from here, when it exits, it's gonna go inside of this collapse graph and execute everything in there and then from there, exit and I entered this one and so on and so so forth. So this is what we are doing over here. The next step is to spawn the snakes head. So over here, what we need to do is get the snake parts array. And I'm going to right click on it and collapse the graph. And I'm going to call this one spawn snake head, there you go. inside of this bad boy, we are first going to clear this array. So we are going to say clear, which is basically going to remove every element from this array. In case we have it but we don't but you know, just as a precaution, we are going to clear everything. And after that, we are going to say over here, spawn new snake part. There you go. And I'm going to plug this in over here. So it's going to pause, spawn the snake part, and I'm going to click here is head to denote that it's a head, the spawn location can be 000. And over here, now this goes over here, so that execution flow continues. And next we are going to spawn our food. And in order to do that, I'm simply going to right click over here and say spawn food. Now we can leave it like this. But since we are doing these collabs graphs, just to you know, be consistent, I'm going to put it in the graph and I'm going to say spawn, first food, there you go, double click it. This goes over here. And this goes over here, and I can Compile and Save that. And if I go back, plug this in, there you go. I can compile and save this as well. And we can test this spawn first food and snakeheads if I go back, if I hit the play button, there you go. So over here we have our food. And you can see the food is changing also. But for the snakehead, let me just go back quickly over here, spawn snake had. So over here spawn new snake, it's a head and we left everything as is so basically 000 snake parts array. Let me just double click this bad boy. spawn new snake part at the location. Okay, so this is what I've missed. As you can see, from here, I didn't drag the execution to this to set it the flipbook stupid, stupid. I know. But as I said, there we go. So this will fix our issue. So drag the node from here to here. This is what I forgot, then you probably saw that then you were like, stupid teacher. And yes, I am. But as I said, anyways, there you go. So let me just Compile and Save that we can go back out side of here now and Compile and Save again, compile, then save. If I go back and hit the play button, we should see the snake as well. Here it is. This is our sneaky, sneaky sneaky. And we also have our foodie foodie foodie. And there you go. Of course the snake will start moving, but at the moment, it will not start to move because we still didn't program that but every single time we click the play button, they are going to be spawned within these bounds because that's why we have the maximum x and the maximum if I go back the x max and the Z max. So that is for the to put them inside of these bounds. Anyways, moving forward. The last part over here is we are going to right click and I'm going to create a for loop and every single time I write for a loop with two O's, so for loop not for each loop but for loop, right click collapse and know that this one is going to be spawn walls and double click it. So what's gonna happen is I'm going to plug this in like this, the execution goes over here, the first index is going to be zero so we're going to loop from zero. But next what we are going to do over here and I'm going to put this over here, then we will move it if there is a need to do that I'm going to get the x maximum and the Z maximum. Now for the x maximum, what I'm going to do is we are going to go inside of our division hole and remainder I'm going to copy and paste it because we're going to need it for the Z maximum as well. So the x maximum is going to go eat to the dividend and the divisors value is going to be 50. And basically these can go a little bit away from here something like this. So dividend is the x maximum divisor is 50. We explain what this is. Next here for the return value we are going to say multiplied with integer. Now what we are going to multiply is we are going to multiply the return value from here so this goes over here, and this goes over here. And also z maximum goes into the dividend and the divisor is going to be 50 as well. So what's gonna happen next is from here I am going to say minus into And the value is going to be one, so I'm going to subtract it from one and that is going to be our last index over here. And I can move this a little bit over here. So what's happening over here basically, for our what's happening for the last index, or how many times you're going to loop is we are taking the x maximum and z maximum, we are setting them to be dividends, and the divisor is 50. And you know, I told you that the return value is returns the number of times divisor would go into the dividend. So if the divisor is 50, and the dividend is 200, for example, divisor will go four times into 200. Because 50 and 50 is 150 is 150, and 50 is 200. That means four times 50 can go into 200. And what's remaining is zero, this goes until what's remaining is zero, or the number that has remained is not the divisor bowl with the divisor. Because for example, if we have, let's say, 210, and we use the divisor 50. So how many times 50 goes into 210, it goes four times, because four multiplies by 50 is 200, what's left, it's 10 1050, cannot go into 10. So that's not possible. So there, this operation will stop. From here, we are doing the same thing for the Z, and then we're using and we're multiplying these two values, the return values and subtracting one from them. And we're setting that as the last index. Now, what's gonna happen over here is that we are going to move the output a little bit over here, what I'm going to do is, I am going to take this index from the loop, and we are going to divide an integer. And the integer that's going to be divided by this number, or this number is going to be divided by the return value from here. So I'm going to plug it in, so the return value goes there. Also, what we are going to do is from here from this pin, actually, from the return value, that is from the return value over here for the x maximum. And let me just move this over here, move these two over here so that we can see clearly what they're doing. So from here, I'm going to say minus integer. And the number that we're going to use to subtract from it is going to be one. And from here, I'm also going to take the index and I'm going to use the modulus. So this is modulus which is basically the same operation as this one over here for the division. And the divisor is basically going to tell us how many times this number goes into this number over here. So how many times and we are going to set the return value from here. So basically, how many times the return value from this value is going to go inside of the index. There you go. Now, also, what we are going to do from here is again, we are going to subtract, so we are going to see minus integer, and the value that we are going to subtract is going to be one. So what we are going to do with all of these, well, let's go here on the top, the first thing that we are going to do from this one, I'm going to test if it's equal to from here, we are setting if it's equal to zero, and from here, we are going to say if it's equal to as well. But here we're going to test if it's equal to the value that we have over here. And now I'm going to save or because we are going to test these Boolean so or if this Boolean is true, or this Boolean is true, or this Boolean is true, and we're going to have one more, then this whole value is going to be equal to true. But before we proceed to do that over here, I'm going to test if this one is equal to zero, the one with the modulus operator and I'm going to plug this in over here. And last but not least, we're going to test if these two are equal as well. So if this goes over here, if they are equal, this one goes in the last plug in over here. And this one goes inside of the condition. And that condition, let me just do it something like this. There we go. This goes into the branch from the loop There go the loop goes inside of our branch and I'm going to move this over here. The condition goes over here now. And what's gonna happen next is I'm going to take the x maximum again. So from here, I'm going to get the x maximum. Actually from here, x max on here it is get x max. And from here, I'm going to multiply it with a float. and the value of that float is going to be one or actually negative one. Excuse me for that for Our operation over here that we use to divide, we are going to multiply that with a float. And that float value is going to be 100. So we're here, it's 100. Why it's giving me so 100. And now from here, we are going to add these two. So we're going to say plus float. plug this in over here. And this is going to be our value that we are going to use over here to spawn actor from class. There you go. This goes over here. If it's true, this goes over here, the execution continues in the output. But from here, we're going to spawn the wall blueprint. Actually, the brick, excuse me, how did I name the block, excuse me, it's not the brick, but the block. There you go. So BP block. From here, we're going to say try to adjust location. So we are going to say try to adjust location don't spawn if colliding. So let me just see, try to adjust. There you go. This right here specifies height to handle and we talked about that. So it was it is going to try to adjust the location so that every block is pond like this right next to each other. And it's not going to you know, it's don't spawn if it's still colliding. So basically, if they're colliding with each other like this, they are not going to be spawn over here from the spawn transfer, I'm going to split the pin structure and also here for location split the pin structure, this one goes into the spawn exposition. Now we are also going to have for the Z position. So over here, what I'm going to do is move this like this, this goes over here, I'm going to get the Z maximum. And for the Z max, and I'm also going to multiply that float like this. Going back over here with minus one, Next, we are going to take this value that we have here from the modulus operator, and we are going to multiply that with a float and that float value is going to be 100. Same as what we did here for the x above, so 100. Now from there, we are going to add these two together. So we're going to say plus float, this goes over here. And this float last but not least goes inside of the Z position Compile and Save that now this is probably, you know too much what we did. So what's happening over here is that we are using the division, the divisions for the whole and remainder. To set the last index, we explain what this here is, after that we are using these operations with divide minus modulus and minus again, with the index over here from the loop body because that index is the current value of the index that we have over here, which is going to be divided with the return value from the for the z axis, it is also going to be used here for the modulus for the z axis as well. And we're going to compare all those values if this is equal to zero, if these two are equal, if this from here is equal to zero, and if these two are equal, and we're going to plug them into the OR operator condition or test for the boolean value, which means if this Boolean so if this is true, or this is true, or this is true, this is true, then this whole thing is true, we only need one of these to be true to for this to work. So that goes into the branch over here, if it's true, we are going to spawn the actor block, and over here, the position x so the location x and the locations, you are going to use that by using the x maximum multiplying it with the negative because when we multiplied with the negative, we are going to spawn them over here in over here, because the negative values are here on the edges. So that's why we're multiplying that with the negative same thing we're doing over here. Next, we are using this value that we got from dividing the index with the return value from the xemacs. So we're using that value, multiplying it by 100. And adding to it adding to add this value over here. This is going to be the location x. Doing the same thing for the locations the multiplying with the negative because we want to put it on the edge moving forward the value we got here from the modulars we are going to multiply with the 100 and then add these two and this one goes into the locations and of course from here, it goes into the output or actually I don't think we need to do that. We don't need to add To the output, we can even break this, because we don't have any more operations over here. So from here, we don't have any more operations, this goes over here, but you can leave it like that it's not important. But what we need to do is this. From here, we do need to take these walls, so we need to take the wall block array. And from here, we need to say ad, which is going to add every single time this new block that is created. And no, that's not what we want. This goes over here. There we go. And this goes over here, Compile and Save that. And from here, you can go in the output. But as I said, you don't have to do that, because we don't have an output. We don't have any more executions going from here. But I mean, you can leave it like that it's not important at all, it will not affect our game. But what's important is that we do this, as you can see, we need to take the wall blocks array, and every single time we create here, a new block actor, we need to put it inside of this array, because later on, we're going to test if the snake is colliding with those blocks by comparing them to the position of every block in the array, we will see that later on. So Compile and Save that then make sure that from here from the spawning for his food, you plug the execution order over here. As I said, this is not important, this other execution order over here. So this one, it's not important, but you can, you know, leave it like that it's not important. Going back, we can go here in the gameplay, if I hit the play button. Now there we go. And thanks to this pay attention over here, let me just try to use shift and f1 to eject myself. And if I come close, you will see that these blocks are not colliding with each other, they are exactly put together on like their, you know, like this, I don't know how to explain it. So they're exactly right next to each other, they're forming a whole view over here or a whole, there's no space between them. But they're still not colliding with each other, which This over here is going to help us achieve that what we said try to adjust location, don't spawn if still colliding, there you go. So we can try this one more time. So Compile and Save that just so that we can see it actually works. If I hit the play button, there you go. So these are the walls that are going to be the bounds where the snake will be able to move. And if it hits those bounds, then well, the snake is going to die moving forward. Let us go back here in our main game. So now we have everything over here set up, I can select all of this here. And we can put in a comment like initialize game or something like that. And every single time I make a mistake, so it's lowercase a even though that's not important, but I'm crazy. And I have to you know, redo it anyways, moving forward, I'm going to right click over here and we are going to search for our tic event. And why well, because in the TIC event is where the magic is going to happen. First things first, we are going to get our is dead. So we are going to get it and right click and collapse the notes. And over here, we're going to call this one check for that collision or actually condition one, there you go. From here, what we are going to do is you're going to take our is that variable and we are going to go inside of a branch. And I'm going to plug this in over here. And then what we are going to do is you're going to plug in both of these true and false in the output. So it goes over here and it goes over here. So now we have true and false. And what we can do is over here you can change these names for true you can say is that for example and for false, you can say is not that so that when we go back now over here, pay attention so I can plug in and now we have two execution orders that we can use. So we have is that and is not that meaning when we check over here the condition is that if it's true, it will return over here true. If it's false, it will return over here false. So we have two ways if it's true, if the player is dead, we can do whatever we want over here if he is not that we can do whatever we want over there. So what we are going to do, well we are going to and let me just move this a little bit down then we can move it up again just so that we can then more clearly see these notes. First I'm going to get the input r so let me just find it over here. Where is the R button rrr Here it is. Now what we are going to do with the R button is we are going to Create a sequence. But for that we are going to actually not a sequence but a collabs graph. But for that, we're going to get a gate. And for here for this gate, I'm going to collapse the node and I am going to call this one restart sequence. There you go. Now what we are going to do is we are going to have when we entered the gate, so we're here we are going to have when we enter and when we have opened the gate. So over here, as you can see, enter and open Compile and Save that. So now what we are going to do over here, and let me just go back is that if the player is that, we're going to go over here to enter in the sequence, or basically enter in this gate. And when we are going to open the gate is when we press the R button, but let me just move this a little bit up, and our button is here. And when we press the R button, we are going to open this gate. So again, as you can see over here, when the player is that we are going to go and enter inside of the gate, when do we open the gate when we press the R button. Now what does that mean? This gate, if I hover over allows for opening and closing a gate to control the execution flow. When we enter the gate, it doesn't mean that we will execute what's after over here only when we open the gate, then it then that is when we are going to that is when we are going to execute what's over here, but we cannot open the gate if we don't enter it. So we are gonna enter the gate when the player dies. We know over here we tested this condition. So if the player is dead, we are going to enter this gate. But we only open it when we press the R button before we open it, it will not do anything. And even if we try to open it without entering the gate, it will not work. So think of this as a control for the execution flow. So what's going to happen when we enter and open the gate from here we are going to do once. And the name says it all output fires only the first time the node is hit, but can be reset. What's important over here is that we know that this will only execute once so we can only press the R button once to execute everything that is over here. Which means now we can take the HUD Reference. And from here I can remove from parent. So we can remove from from parent this widget. There you go because we already have one. And actually, when we start the game are going to create a new one. So that's why we can remove the old one from our from the current parent. Next, what we can do is we can get the current level name. And this is going to give us the name of the current level we are in because we want to reload that same level. And next we are going to open the level. So we're going to say open level here. And I'm going to plug this in over here. And last but not least plug this in over here and it is going to convert because this returns a string and over here we need the name. So this is going to convert a string to a name value the output we don't need to touch it because well, there is nothing more that we are going to do over here. Basically if the player is dead, and then we just go back. So if the player is that this is only what we are going to execute when the player presses the R key, he is going to restart the game same as what we saw in side of our preview, when I say the preview, I mean the preview of the game when we first started it. So there you go, this is what's gonna happen here. If the player is not that what's gonna happen First things first, we are going to wait and in order to wait we are going to get the delay from here, I'm going to right click and collapse the nodes and this one is going to be called wait. And what's gonna happen is we are going to call the delay function. So over here called the delay, this goes over here and the duration is going to be the delay itself or the value of the delay when it's completed. We are going to go here in the output meaning we are going to continue the execution order and what did I do over here let me just go back there you go. So, if the player is not that we are going to wait for the specified time that we just saw for our snake and when we wait after that, what we are going to do is we are going to go inside of sequence now what is a sequence so how did I read it see Quinn's There you go. Now what is the sequence first I'm going to right click and collapse the node and this one is going to be sequence one. What's going to happen over here is that we are going to enter in the sequence and we are going to put put this over here and put this over here and what we are going to say over here for them Zero, we are going to say do first. And for the den one, we're going to say do second. Now a sequence, if I hover over, it says executes a series of pins in order, meaning it will first execute this over here. And then it will execute this over here. And if we have more pins, you can click here plus to add more pins, then it will execute the other pins in order. In this case, what we did over here is that so this goes over here like this. First, we will do what's in this sequence. And then we will do what's in this sequence. And whatever we put over here, it will not be executed. Until this first one over here finishes, because is the first one. So what's going to happen is that we are going to let me just Compile and Save that first, I'm going to get the snake parts array, and I'm going to right click on it collabs, the node and this one is going to be called check head self collision, this is basically going to check if the snake collides with its own head. So what we are going to do over here, for the input output, we're going to move a little bit away because over here, I'm going to right clip, right click, and I'm going to see for each loop with the break. Now what is the break, this goes over here, by the way, the array goes over here, break is we can call break, to break out the loop. So it doesn't matter. For example, if this snake parts has, you know, 30 elements, that means the loop will loop 30 times, we can call break to break up that loop on the I don't know, let's say 10th loop, so it doesn't have to loop 30 times if we find what we need. Now how does that work? Well over here, I'm going to create a custom event. So Custom Event. And I'm going to call this bad boy brake self collision test loop. And simply from there, we are going to plug this in over here in the brake and there we go. So when we call this custom event, it is going to break out of the loop. So what's going to happen over here is going to happen that output when this completes, we are going to plug in the output so when it completes, this is going to go in the output meaning we are going to go let me just Compile and Save that we are going to go and continue the execution from here. But what's going to happen in the loop body first in the loop body, we are going to go inside of our branch. And the condition for the branch is going to be the array index and I'm going to test if it's not equal to zero. So if the index is not equal to zero, that's going to be our condition. Now the reason for that is because while for the first head, we cannot check if the head is colliding with itself because the snake has a head then it has you know the body like this. So there you go, there you go, there you go. We can we cannot check if this head collides with Excel because it's not possible, we only can check if it collides with one of these body parts. So what's gonna happen over here is from the array element, from this array element, I am going to get the actor location like this. And I'm going to move this over here and get it like this. There you go. So we will need our accurate location, we will also need our snake Bart's array from here and we are going to get so we're going to get a copy and we're going to get the element that's an index zero meaning that's the head of the snake. And from the head of the snake, we are going to get the actor location like this. So we have now two locations. Again over here this is going to execute, the branch is going to execute only if the index is not equal to zero, so we can rest assured that the array element we get over here, and the actor location is not the location of the element that's at the index zero meaning not the location of the head, but over here we're getting the location of the head. And why do we need that? Well, now I'm going to equals equals test these two vectors if they are equal with the tolerance 0.001 meaning do they overlap is the head of the snake. So for example, this is the head of the snake, this is the body this is the Body Body buddy buddy, buddy buddy body so on and so forth. And this is the head so we can test if this location of this head is for example same as the location of this and that can only happen if like this. So this is the head of the snake and the snake goes for example, like this, as you can see and then down over here or here, over here, over here and over here and over here. So over here is where the head would collide with one of the body parts and this is what we are doing. So if this is true, we are going to go inside of another branch and inside of this branch, we are going to test or plug in this condition, meaning we are testing if the body part that is at the current index does it collide with the head of the snake. If that is true, then we are going to go over here and we are going to call kill snake event, which we already know we created this in the previous video. So here it is, our custom kill snake event which is going to set is that the true for each loop is going to go here and we explain everything what is going on. So kill the snake. Next, we are going to get the HUD Reference. And from the HUD Reference, we are going to call the game over event. And we know that our game over event in the HUD Reference, if I double click it, it's over here, it's going to set the visibility to visible to the game over text and the restart text. And it's going to play our animation that we have previously created that we also explained. And last but not least, if this needs to loop 30 times, for example, as I said, if the snake has 30 body parts, and this leads to loop 30 times, but the head is colliding with let's say the 10th element in the array. Well, we don't need to loop anymore. And what we can do is we can simply break out of the self. So break self, re, self, how did I name this? Brett, I said the bake. So it's break. There you go. So break self. Again, let me just go over here break self self collision test loop. And this is pretty self explanatory. So this is going to call this Custom Event over here, which is going to simply break the loop and it's going to stop looping, Compile and Save that. Now there is no need to explain this, again, what is happening. So if something is not clear, as I already explained everything, you can rewind and see, if it's not clear, something is not clear, make sure that you ask in the comment below. But over here when all of this happens. So if we make a test, and none of these is true, so this over here, it's not true. So we don't go inside of this condition, then the loop will complete then it will go over here in the output. So this output now I can go back in the main event over here. So this output now goes from here, now what we are going to do is I'm going to get the wall. So wall block array. So now we are going to test if we are colliding with the wall, meaning all of those bounds that we have over here. So if we are colliding with these bounds that are set over here that we saw a moment ago, but I'm going to right click on the wall and collapse the node and this is going to be check head wall collision. And notice I'm only checking with the head because it's not possible for the body parts of the snake to collide. Now the output over here, we do not need it, because we are not gonna do anything else over here. So what's gonna happen here, again, we aren't going to have a for each loop with a break. And execution goes over here, the array that is going to be looped over is this one wall blocks array. And again, we need to create another Custom Event. So custom event, and this is going to be break wall collusion test loop, and this one is going to go inside of the break. There you go. So Compile and Save that we're basically going to do the exact same thing we did a moment ago for the for the wall, except what we did is for the snake. So over here, we're going to take the snake parts array and we are going to get the element that's at index zero meaning the head so get, and is going to get over here see this is the index here. If I hover over given an array, and an index returns a temporary copy of the item, and over here, as you can see the index is zero meaning the head is the first element then from here we're going to get the actor location. Now over here, we're not going to test if the array index is not equal to zero because we can collide with any wall part. There is no wall part that is an exception over here. So from the array element, we're going to say get actor location. And over here now we are going to test these two. So what's gonna happen first, let me just move these a little bit back so that they are something like this close to each other. I'm going to test equals equals with a tolerance over here 0.001 As you can see, and that means we have collided with the wall, which means over here, the loop body goes in a sign of a branch. There you go, and this is plugged in over here. So Compile and Save that. So now if this is true, basically Everything is going to happen same as what we did before. So over here, we're going to kill the snake. Next, we are going to get our HUD Reference. And from there we are going to say Game Over event. And last but not least, we are going to break outside of the loop. So we're going to call break wall collusion, test loop, and output can stay over here. Now again, the only difference between this what we did over here and what we did over here is that over here, we're testing if we are colliding with the head of the snake. But over here we are testing. If we are colliding with any of the wall elements, as you can see wall block, were getting that array element, its location, if the location matches with the location of the snake head, if that is true, kill the snake Game Over event, so on and so forth. Everything else you already know, we already explained, then over here, the execution continues. So make sure that you Compile and Save that if something is not clear, make sure that you ask in the comment below. Moving forward in the second sequence over here do next or do second, excuse me, we are going to perform a check again, if the snake is dead. So over here, I'm going to right click collapse nodes. And this one is going to be check that condition to and this goes over here, double click it and simply we are going to go in a branch which we know is a true or false statement. So over here, we're going to plug this in. And only if it's false, it is going to go over here. And what I'm going to do is I'm going to say not that like this, and we can Compile and Save this bad boy. So the next step is to so this goes over here like this and moving forward. Next, we are going to go in a sequence again. So right click over here, sequence search for a sequence, right click on it to collapse a node, and this one is going to be our sequence to double click it and it goes like this, these two go in here. So let me just go and click here, then we are going to say do first same as what we did before. And over here, we're going to say do second, and Compile and Save that. Let's go back, and this goes over here. So again, we have a sequence. If the snake is not that, notice that here we have not that condition. And over here. We also have the knots that condition but we also have the is that condition for the snake as you can see. So moving forward, what's gonna happen inside of this sequence now? Well, in this sequence, we have a couple of things in the first one that is. So for the first one, I'm going to right click, and I'm going to create a branch. And I'm going to right click on the branch and collapse a node and this one is going to be check had food collision and you got it right, this over here is going to check if we have collided with the foods for our snake and it goes like this, so Compile and Save that input goes in the branch and the condition for the branch is going to be from the snake bites array. So from the snake parts array, we are going to get the element that's at index zero meaning the head of the snake and we are going to get the location of it. So we're going to say get actor location. There you go. Next, what we need to do is we need to get a reference to the food actor. So here is our food actor, we can only have one food actor in the game at any given moment. So we only have one and we are going to get the actor location as well, for the food actor like this. Now we are going to test these do so equals equals and plug this in but over here, this time the tolerance is not going to be 0.0001 instead of that the tolerance is going to be one if I hover over returns true if x vector is equal to vector b within a specified error tolerance. So this one so one unit is the specified tolerance that we well specified. So that's like you know, one one unit or one centimeter in Unreal Engine in Unreal Engine measurements. So if it's true, we are going to plug in over here the execution if it's false, we are not going to plug in so if it's false, we're not going to do anything but output goes only if it's true what we're doing again, we're getting the element that's at either zero we know that's the head of the snake, getting the location of the head of the snake, getting the food actor and its location do their location match with one centimeter or one measurement unit of Unreal Engine tolerance. If that is true, then Go into the output, make sure that you Compile and Save that. So this goes over here like this. So only if it's true the next step what we are going to do, and I'm going to take these two inches mobilebet down so that I can move these over here. The next step is we are going to update the game score. So what I'm going to do is I'm going to get my actually we are going to get the food actor, here it is, and right click on him and collapse the node and this one is going to be update score. So actually is going to be update games course excuse me for that one, because we already have a function name or an event custom event name update score. So update game score, it goes like this. What's gonna happen with the food the actor, we are going to get the score. If you remember, the food actor has its own score, if I double click it, so can I double click it to open it in the foot doctor, apparently not for some whatever reason, but here it is, we have this score, and we set it over here we talked about that, she can rewind those videos if you need a refresher. So now from here, we are going to right click and we're going to get the update score. And this goes over here, and the score value goes over here. And this goes over here. There you go. So this is going to update our score again, you can double click this function and go over here and see what it is doing. It is taking the current value over here the score, adding it to the score, setting the score over here and then passing it to the HUD Reference so that we can actually have our score. But this only happens again, this only happens if this is true. So if we collide with the food actor, because if we don't collide with the food actor, of course, we are not going to update the score. Next, now that we have collided with the food actor updated the score, we are going to destroy the reference to the food. So we're going to get the food actor and I'm going to again collapse the node and this is going to be this truly correct current food. Because we picked it up, we don't need it anymore. So from here, we are going to call these Troy actor. There you go, this goes over here, the plugin goes over here and this is plugged in over here. Again, we picked up the food, there is no need for us to have that food anymore in our game, because now we are going to create a new food so destroy the current one. Let's go back, this execution goes over here. The next step for us is to spawn a new snake part because the snake if it's this big, for example, and it eats a new food, it go it grows bigger. So for that we are going to get our snake parts array, right click on it and collapse the node. And this one is going to be spawn new snake part spawn snake. So we're going to say spawn snake new part like this, because we already have spawn new snake part, apparently. So here we have our snake parts array, what we are going to do is we are going to get over here, but we're not going to get that element that's at the first index instead. From here, we're going to say last index, and this is going to return the last index of our snake meaning the element that's at the last place inside of our snake. And the reason for that is because we need to get the location, so get actor location, we need to get the location of the last part of our snake so that we can call over here our custom event spawn new snake part as you can see. So from here, this is plugged in over here. And we can do something like this. This goes over here, this goes over here, this goes over here. And this goes a little bit over here, just so that we can clearly see it. So this is going to be plugged into the spawn location. Of course it's not a head because we're spawning a new snake part. And notice here the beauty of this. So as I said we're spawning a new snake part it needs to go at the end of the snake. So this is the snake's head Part Part Part Part snake eats this food we are spawning a new snake part over here, which is the last element. So what we are doing, we are getting the last index gets the last valid index in this array, we are getting that and then we're getting the location of that actor and we are putting that as a spawn location here in our snake bar because we know that we're going to use the location to actually spawn so we're using the location to actually spawn that snake part. So Going back over here, this execution continues here, spawn snake bar response snake new part. Moving forward, we already know that we have destroyed our food, which is over here. So we need to spawn a new one. So we're going to right click over here, we're going to say spawn food, this is going to spawn a new food, we can connect these right away. But in order to follow what we did so far, with the collapse graphs, we can simply right click on it, then we can see spawn new food, there you go. And this goes over here like this, and this goes over here, like this. And we can go back and now we can plug in the execution. But as I said, we can directly do that on the, on the custom event, as well. so we can directly do it. But just you know, because we are having all of these collapse notes. Well, we can follow it over here as well. The last step that we need to do over here is to speed up the snake. And for that, we're going to get our delay and right click on it and collapse the node and this one is going to be speed up snake. And what's going to happen over here, now we have our delay, I am going to go over here and I'm going to say minus or actually plus float, and the value of the flow that we are going to add to our snake is going to be negative 0.01. So we're actually going to subtract from it. And over here, we are going to say set the delay. So this goes over here, and this goes a little bit over here, because we are going to get our clamp float. There we go, we are going to clamp this value that we get over here. And the minimum can be 0.0 75. And the maximum is going to be 0.2. And this goes over here and this goes over here. There you go. So Compile and Save that this is going to actually speed up our snake. So this is going to speed up our snake because the delay is how much we are waiting. And when we have a lower value, we are waiting less, which means the snake will move faster. So again, what we are doing is over here for the output, we don't have to do this, we don't have to have the output because this is the last collapse node in this line of sequence that we are going to execute. So taking the delay subtracting from 0.01 value clamping that value, which is not going to allow us to go below the minimum which is 0.0 75. And it will not allow it to go above the maximum which is zero point to set that value over here into the delay and there you go. But we also need to plug in this execution over here, so that it actually executes. So this is our do first sequence. So we are testing for the head collision, updating the score, if we have the head collision with the food, updating the score, destroying the current food, spawning a new snake part destroying, or actually creating a new food and then speeding up the snake we explain everything what it is. But in case if something is not clear, just make sure that you ask in the comment below. Moving forward, there are only two parts left in our game. And they're going to happen over here do seconds. So from this sequence, right click over here, and we are going to create a new sequence. And I'm going to right click on this sequence and collapse the node and this one is going to be check inputs. So we are going to check for the input. If we press the button to move the snake and then we are going to move that snake so we're actually going to move the snake afterwards. So let me go back over here, this goes over here. And there you go. So inside of our check inputs, we are going to have 01, then two, then three, and then four of these sequences. On the fourth sequence, we are gonna go in the output from zero to three, we are going to check for the input. So we are going to check for the input for when up is presence on and so forth. Let me just go and do my thing. So what we're going to do is right click over here and we are going to create a gate. And this gate is going to be controlled with the input up. And over here. This is what we want. So this goes over here in this gate. And let me just double click this bad boy, this goes like this, and this goes over here. And probably we will need to move a little bit upwards for other sequences to have place to you know stay to be visible. So we're here this is our first so when we press the up button on our keyboard so when we press it, we're going to open the gate. When we release it we are going to close the gate. Now, another thing that you can do is you can go into the project settings in the input and over here in the action mappings you can create your own action mappings if you want to move the snake And the W key on other keys, whatever, but you will have to create your own action inputs. Because currently by using this over here, we are only going to move the snake when we press the up arrow key on our keyboard. If I hover over you see events for when the up key is pressed, or released. So this is the up arrow key on the keyboard Anyways, what we are going to do when we enter this sequence, which is this one over here, so do second, we're going to check in the inputs, and we are going to go in this in the sequence, this sequence the sequence, this sequence is going to check if when we enter, so we're going to enter this gate, and I open the gate, the gate implementation, but we don't need that anyways, when we enter the gate, we're going to wait if we press the up arrow key, and when we release it, when we press it, we are going to open the gate and execute what's over here, when we close the gate, all the execution stops. So what's gonna be executed over here? Well, we are going to go inside of a branch. So when we press the up arrow key, we're going to go in the branch. And what we are going to test over here is the direction z. And we are going to test if that is equal to zero. So over here, testing data if it's equal to zero, and from here, we just say, and so we're going to test to Booleans. If direction z is equal to zero, and get can change direction. So if we can change direction, and the direction z is equal to zero, that goes over here plugged in as the condition if that happens, if it's true, we are going to set the direction x to zero. And we're going to set the direction z to one, there you go. And last but not least, after that we are going to set here can change direction, we are going to set it and this goes over here like this. And I'm going to double click this to have this line over here so that we can plug in all of these others. So we're going to plug them in later on, because over here can change direction is going to be false. But we're going to do for all of these for all of our inputs. Because now what we are going to do is I'm going to copy this gate, actually, I can copy all of this here, I can copy it, and I can paste it over here. So now this goes, execution goes over here. But let me just again, select them and move them over here because we do have space now. And what I'm going to do now we have the up key. Now we want the down key. So from here, I'm going to right click, and I'm going to input down. And let me just find it over here. Here it is input down when the down key is pressed. And let me just double click this over here and move this execution like this. And this press goes here, release goes here, same thing, same explanation as what we did. And you can move this a little bit further so that you can distinguish these lines over here. But same explanation, same everything, as for this one above. But this time only when we press the down key, we're going to open the gate when we release it, we're going to close it. If the direction z again is equal to zero, and we can change direction. If that is true, both of these we can copy and paste them again. And we can plug this in. So if it's true, the direction x is going to be zero, the direction z is going to be negative one because we're moving downwards and down is the negative side up is the positive down is the negative right is the positive plus and over here left is the negative. And last but not least, then this goes over here so that we can the note that we cannot change the direction currently. Next, we can copy this gate, so I can paste it over here. And this goes over here the execution flow goes over here like this. Next, we are going to get the input for our right key. So when we press the right key, so over here, I can say something like input, right. And this is the one that we want not right alt bracket command and blah, blah, blah, only where it says right, and this goes over here and this goes over here. There you go. And I can probably do something like this, so it is a little bit more visually clear what we are doing. So now when we have this gate, again, we're going to go inside of a branch, the branch goes up to here, but this time instead of getting the direction z we are going to get the direction x because now we are moving on the left and right side. And if the direction x is equal to zero, and again, we can change direction so we're going to get it over here. So if the direction x is equal to zero and we can change direction. If both of these are true. And by the way, if you're a complete beginner don't know what this end means. It means that this over here needs to be true. And this over here needs to be true. If for example, direction x is not zero, but can change direction is true, this whole thing will be false. When this is true, if direction x is zero, and that is true, and can change direction is true, only then this will return true. And this over here will execute. So basically, both of these conditions needs to be true. So when that happens over here, we're going to say set direction x and the direction x, we are going to set it to be one because now we are moving to the right side in the positive side, and over here, set directions z is going to be equal to zero because we're not moving on the z axis and this goes over here. There you go. Last but not least, we can basically copy all of this, and we can paste it over here like this, and execution goes over here, enter the gate, right click. And now when we right click, so right click again, input left. Again, it's not left command Ctrl Shift, it's only where it says left. So over here, pressed goes into open released goes into clothes. If the direction x is equal to zero, and we can change the direction, if both of these are true, the direction x is going to be negative one. And the direction z is going to be equal to zero. And last but not least, the plug goes over here so that we can set that we cannot change direction. So make sure that you Compile and Save that then last but not least, which is our last sequence, the fifth one, it is going to go into the output so that we can proceed and you know, you can click here instead of then four, you can say next, for example, Compile and Save that so that we can proceed and do the last step, which is actually moving the snake, because this over here is going to only get us the input. So again, I went through all of this, it is pretty self explanatory. It's not hard, this code over here is not hard at all. So we're simply setting based on which button we pressed either for the Z or for the x, we're setting it to one or negative one. That's all what we are doing. But if something is clear, make sure that you ask in the comment below. So over here, we're checking the input. And well the next step is to actually move the snake. So in the last step over here, first we are going to create a for loop and create a four loop, right click on it, collapse the node and this one is going to be move snake and this is going to be used to move our snake double click this bad boy. And the input goes in the for loop. And I'm going to save this go back over here so that I can plug in the execution order and go back inside again, the output, we are not going to need it. This is the last step. So we are getting close. So what's going to happen over here what is the first index is zero, the last index is going to be our snake parts array. And we're going to get the length. So actually simply here type Lang to actually linked with th not HD. Now that we have the length, I am going to subtract from it. So I'm going to say minus integer. There you go. And I'm going to plug this in over here. What am I doing? If I go here, Snake parts array and get the number of items in the array. So we are getting the number of items, how many items do we have, if we have 30 items, we are getting 30 items from that array, the input can go over here. And I'm subtracting one because the last the last index, the last element in the array is always at the length minus one. So from zero up to the length minus one, which is the last element over here, when we complete the movement, we're going to say set can change direction to true, because if you remember a moment ago, we changed over here, we set it to be false. So now we need to set it back to true to be able to move again. And this goes over here because well this is the last step. So when you complete the loop can change direction will be equal to true. Now what is going to happen in the loop body. We are going to go inside of a branch and I can move this over here so you can more visually see this more clearly. Now what's going to happen over here is that I am going to get the snake parts array again. From the snake parts array. I'm going to get the link again. So getting the length last but not least I'm going to say minus integer, so we're going to subtract from it one again. And from here, we're going to say minus integer again. But this minus integer is going to be the index from here, or the current index that's being iterated. So the point here is that we loop through the whole array and get every element that's inside of our get every element that's inside of the snake. And from there, we are going to move that element. And this is how we are going to get those elements. So we are going to get the snake parts that already and the length of it. So length minus one, which is the last element. So let's say we have 10 elements in the array, that means the length will be equal to 10 minus one that is nine. Next, we are going to subtract from nine, the current index that's being iterated that can be 012345, blah, blah, blah, up to when it gets to the number nine, this will allow us in reverse to move the snake parts. So it will not actually move the snake parts from the head. And then the second part and the second part and the third part of the fourth part, instead, it will remove the snake from the last element, then the second to last, then the third to last, and so on and so forth. So this is what we are doing over here. So now what we are going to do from here is again, I'm going to get the snake parts array. And from here, I'm going to see get, which is going to get the element added the current index, which is this one over here. So the index that we have calculated with this that I have just explained next over here are going to test his head. So we are testing each of the elements that we are getting, if it's the head that goes over here inside of our branch condition, because we need to know which one is the head and which one is not the head. Now moving forward, what we are also going to do is I'm going to copy these two and paste them over here. Because again, this goes over here like this, again, we are going to get then what I'm going to do is move this, like this over here. So again, we are going to get the element that's on the current index, and also from here. So from here, again, we are going to say minus integer. And we're going to subtract one from this value. And again, we are going to paste this, and we are going to get this element again. So we're getting the two elements right next to each other this is what we are doing with these two. Now what is going to happen is we have the true and we have the false. If it's true, we have the head, we are going to say over here add actor, world offset. This is if it's true. So this goes over here. If however, it's false, then we're going to say set actor location. So over here, we're going to say set actor, location. And here it is. This is if it's false. And we're going to go over here. And probably we'll need to move these to just a little bit over here. So what is going to happen right now? Well, the target for both of these is going to be this one. So this goes over here as the target and this one goes over here as the target. So make sure that you plug these two in correctly or otherwise it will not work. The next step that we were what we need to do is from here, we are going to get the actor location, there you go. And this location, this actor location goes over here. So we're going to plug it in over here. And last but not least here at the top, I'm going to right click and split the pin structure and we are going to get the direction x get the direction x get the direction z and we are going to multiply these students so this can be moved a little bit over here because x will be multiplied with float and the value that's going to be multiplied is 100. We can copy and paste this over here and multiply z with 100 as well. And now these 2x goes here in the X and Z goes in the Z, the location y we're not going to touch that so location y we are not going to touch it instead, we location y stays as is. Now let me go briefly again what we did over here, so Compile and Save that. So this is explained what we did we get the last element minus one we're looping that many times. From here when all of this completes when the loop completes. When we loop through the whole loop, then what we are going to do is simply set can change direction to true so that we can change the direction again, over here we're getting the snake parts array, and we're subtracting from it the index, which will allow us to get the every element inside of the array. From here, we are checking if the snake parts are the element that's at this array, this index currently, if that is the head, if it's true, we are using actor or add actor world offset, and we are changing the actors location x and z by using the direction x multiplying it with 100 and direction z multiplying that by 100. We know the direction x or z, it's going to be either one or minus one for both of these. So this is going to be negative and positive 100 for the offset of the head of the snake. Moving forward, and over here we are plugging in we are getting the element that's this index. So we are getting that element that we're plugging that in over here is the target and doing the same thing over here for this one for set actor location as well. Moving forward from there, what we are going to do is we are getting the next element in that array. So let's assume this over here. So when we calculate these two, let's assume this has a value of 10. Over here, we say minus one, that means this has a value of nine. So over here we are getting, as you can see, we are getting the element that's add the value or index 10. But we are setting its location to be where the index that has a value, nine to be that way we are moving them so that way we are moving them. So let's assume this is the head of the snake, we're getting that element that's here and setting his location to be over here. And this we're doing with every single one of these. So this one will move the location over here, this one will move on the location over here. If we have more of these over here, this one will move on this location, this one will move on this location, just make sure that you Compile and Save this. And now we can go back and test it out. So if I go back into gameplay, hit the play button, you will see now the snake is moving and bam you see when we hit on or when we touch one of these walls. Well as you can see, we die. So we need to press the R button to restart the game but it's not working. And also if I try to play the game again, I'm moving left and right but it's not working what is happening. Well there is one more thing that we need to do. Over here we need to select the BP main game and scroll down so BP main game which is in the world outliner over here and scroll down and go over here where it says the input as you can see, we need to say out to receive input not disabled but player zero meaning that we will receive this blueprint this actor BB main game will receive the input if it doesn't receive the input. While you saw a moment ago what will happen. So if I hit the play button now if we hit one of these walls, bam, you see we die. Game over press R to restart the game via press the our game is restarted. And now you see I can move the snake you see I can move it up, left and down. And now I have picked up one of these as you can see, picked up one of the foods. Let's try to eat another one and bam we died. So let's try again. So over here, over here, there you go. Let's try it one more time. There you go. We are eating the food pay attention to the score it is moving to 100 now we have score at comma on 210. Again, eating and pay attention every single time The more we eat the larger the snake and the faster the snake is. So let's go over here and I don't know if you're asking me What's this in the middle this like I don't know this over here. I don't know what that is maybe some kind of glitch, whatever. It's not important if somebody knows just tell me so 580 680 and now I can even move the snake a little bit faster and better and more clearer. If you have issues with the control in the beginning that's because of the delay. So you see the lower the delay is the faster the snake is and the better control over it the we have. So there you go. And notice now when I die with the snake It doesn't matter if I hit the wall or if I actually hit the snake body. You see you saw how the snake like this appeared in an animation. Well that animation is if we go if we go let me just see where it was over here. flipbook actually it's in the kill snake. So let's go over here. Let me just find kill snake, here it is. So these are the flip books that we are using our animations, we explain how you can create them. And you can go and check them out and see how they look like. But this is what we are doing. So over here we're adding the flipbook on every one of those animations. So now, you saw the effect of that. So let me just play one more time. The last step that I want to test out is do we actually die if the snake collides with its own body, so let's go back over here try to eat it, it is a little bit harder to control the snake when we didn't want it then when the snake is not big enough, so when it didn't eat enough, so come on, let's try it one more time, we need to get the snake a little bit bigger so that we can actually come on man, I cannot be the game I created. What is this? Actually not beat it I'm trying to die. But I'm trying to die with the with colliding on the snakes by anyways, you can simply set the delay to be a lower value in order for that to work. So the delay can have a lower value as well. In the beginning, that is you see, the larger the snake the faster it is the delay is slower and that means we can control the snake much better. So meaning you can, as I said, set the delay in the beginning to be smaller value. So now we can actually test it out. So pay attention now the snake is moving and we can control it way better. And now bam, you see I collided on my own tail and I died you can restart the game by pressing R to play the game again. And that is that thank you again for watching one or one another one of my Unreal Engine tutorials here on YouTube. And please, if you liked the video, make sure that you share it, subscribe to the channel, comment and leave a like because that helps the algorithm helps my channel grow because we want to spread the roots. We're we want to spread the word so that other people can see and benefit same as like you did. Anyways, thank you again for watching. If you want more Unreal Engine tutorials, I have plenty more inside of my game development Academy link is in the description below. Click on that link enroll you will learn you will help support the channel and it's very cheap, cheaper than any other website. Anyways, I don't have anything else clever to say except again, help the algorithm push the channel forward then the fire here from us who's calm. I will see you guys in the next tutorial.