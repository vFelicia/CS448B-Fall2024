Hey everyone here on the freaker cap channel looking to get some tips on how to make award winning JavaScript games. My name is Andrew Cuba, and I'm a software developer and course creator on YouTube as well as judge for the 2021 gs 13 Games competition. For those of you who have not come across the GS 13 Games competition is the JavaScript coding competition for html5 game developers running yearly since 2012. Each year a theme is given in 2021, it was space and the fun lies in the fact that the total file size limit of your game submissions has to be under 13 KB as per the name. And just what can you make with that in KB of JavaScript? Well, just have a look at some of these awesome games. In this video, we will be looking at the top 20 winners from the GS 13 Kagan competition, as well as hearing from the game creators themselves who will talk you through the game and provide you with some of the game source code so that you can have a look for yourself what it takes to make each game. This video is great for those new to JavaScript game development and those wanting to get in on the next year's competition. So I hope you enjoy it. Now let's get to it. So the rules are simple, all your code and game assets should be smaller than or equal to 13 kilobytes, or to be exact 13,312 Bytes when zipped. Your zip package should contain an index html file and the top level folder structure and when unzipped should work in the browser. Next, you can't use any libraries, images or data files hosted on server are services that provide any type of data. So for example, Google Fonts are not permitted. Analytics and other stack loading scripts are also not allowed, or the game as a to fit in the package size limit. However, the iframe Babylon js and three Gs frameworks are not counted towards that limit, but you can use them only in the WebEx or category. And finally, stick to the theme. This is very much recommended, but also free to interpretation. There are some pretty creative implementations of the theme of space and this year's competition, which I can't wait to share with you. Okay, great. Now that we have the rules covered, let's hear from the competition creator and Joe Mazal. Hello there. My name is Andre Mazur, and I'm the creator of the GST, think a Games competition. If you don't know it's a JavaScript coding competition for html5 game developers, where you have a whole month to create a game within the 13 kilobytes limit. It runs yearly every August since 2012. So recently, we had our 10th edition already receiving an incredible amount of really awesome games submitted over the years, many developers publish making of blog posts, and every single game have its source code published on GitHub, so there's plenty of opportunities to learn from the best. And the top 20 winners from this edition will be presented by developers themselves in this very video, so make sure to check it out. Okay, so let's do it. Let's start the game winner number 20. and work our way up to reveal the number one winner of the GS 13k games 2021 competition. In sport number 20, we have hit the space by combat. If you want to learn how to make a game with movements as smooth as butter, hit the space is definitely worth a look. In this game, you hold spacebar to accelerate your ship, reaching checkpoints to advance while avoiding hitting planets and going near black holes. What is also great about this game is that you can see the remaining fuel in the top left corner at all times. As without any fuel you cannot accelerate any further. The only thing that will replenish your fuel are the different checkpoints you need to hit. If we have a look at the code, we can see how well structured the game is everything from the graphics so the audio has been organized in such a way that is readable to anyone wanting to have a look. Now for those of you who have not had a go at playing around with Web GL, Web GL enables web content to use an API based on OpenGL ES 2.0 to perform 2d and 3d rendering and an HTML canvas in browsers that support it without the use of plugins. Web GL programs consists of control code written in JavaScript and shader code, or GLSL that is executed on a computer's graphic processing unit. You can cipn instantiated here and its methods being used throughout the project. To be exact. This is web GL two. And if you want to learn more about it and its fundamentals, please go here. If you use the JavaScript library three j s, this kind of code might look familiar to you. That's because libraries or frameworks such as three js and Babylon, J. S, encapsulate web jails capabilities, making it easier to build 3d applications and games of this game, Judge Bjorn ritzville said catchy music, I like this slingshot gravity and it feels just about right in terms of difficulty. I wonder how the game would play if it was possible to zoom out and see the target planet before launching. And I said that it was deceptively harder than it looks. Maybe I'm just bad at the game though. If you want to have a go yourself, please check out the link for the game and its source code in the description below. At number 19, we have Galaxy raid by Josep Del Rio. What was great about this game was the fact that there were levels to be unlocked pretty impressive for a game that is only 13 KB in size. In this game, you fight your way through six different missions, collect fragments and upgrade your ship. On desktop, the ship itself will follow your cursor and a bomb will be launched on the click of a button. The game also has a touch option in which you can choose to move the ship with your finger and tap with a second finger to launch a bomb. Don't want to use either those perhaps you want to use the keyboard option. Use the arrows or W A S D on your keyboard to move and the spacebar or enter to launch a bomb. And even more impressively, there's also a gamepad option which supports both analog sticks and directional paths. Use a B X or Y to learn to bond with this method. This game really covered a lot for 13 KB and also managed to make the web monetization part of the competition by allowing coil members to customize the ship color, claim 1000 fragments and unlock all missions. I also enjoyed all the cutscenes if we want to cheat, we can have a quick look at the game code to have a read of all the texts for those scenes. Clearly, a lot of thought has gone into this game and I can't help but be super impressed. And what do the experts have to say? Nathan lie call this a nostalgic send up of games like Gallagher. This game offers a healthy amount of challenges and satisfying progression with the upgrade system. All it really needs is some music to make the action a little punchier, but overall the game was great. The web monetization features are excellent given the amount of challenge present in this game. Normally, I don't like being able to simply bypass gameplay, but in this case, this allows less skilled players to experience the entire game in some form. And ever Mazal said everything is well marked. Both subscribers and non subscribers can read right away what a bonus is, you can clearly see when options are available and when they are not. It's nice that there are several bonuses the subscriber can decide for himself which to choose. Bravo, the perfect implementation of web monetization. At sports number 18 We have the game escape by the judo who go by the name of PA school. Oh, hi, we didn't see you there. I say fun with my dog. This is me hell. And this is stash. And we're actually just playing our trying to play trying to play our game on Xbox here. The game is called Escape, and it's our submission to this year's J S K. There can get Gs 13k games.com Alright, let's talk about escape. What is escape? No. Escape is a short story driven platformer. With puzzles, what kind of puzzles so like environmental puzzles like you what does that mean? Like you push stuff you pull stuff, you jump over stuff jump into cetera. So it's basically walking, jumping, pushing, pulling. The the world that escape is set in happens in near future where it's clear that mankind has destroyed Earth and the only way to To live is to escape Basically too late, or anything else. So we know we've we screwed up, and we need to find a new home. Right? But it's the game is not about finding the home. It's not about the destination, not about humans that escape. It's about whatever we as mankind leave behind, it's about the nature, it's about wildlife. And in fact that you can play as, as a wild animal, right? Yeah, you play as a fox that tries to make it to the ark. Can we call it an arc? I think it's an arc. Yeah, like, last rockets that's supposed to leave Earth. And you're not the only one escaping? Because like, all the animals are escaping, everyone was fine. So we tried to create the sense of urgency and danger. Actually, to be honest, like, since this is all finished, now, I think we can be frank. Like, I'm not entirely sure we succeeded at conveying this sense of urgency. Like, you can see other animals escaped in the background, but I feel like, we also wanted to make this pretty relaxed game, show gameplay. So like, there is no rush. Really. It's like Witcher three, where there is no mechanic of Rush logic of rush in the game. But the environments, kind of, you know, it's kind of forcing you to do to proceed faster and faster, because there's fire everywhere around you. Right? Right. So it's our handler at site, the world is burning. You better hurry up. Exactly. And you have your cubs cubs. Yeah, just escape in random directions at the very beginning of the game, before you even gain control over the main player. So right so so you start outs and like the world is burning. You better find the the last rocket leaving Earth soon. And on top of this, you're your baby, your fox babies escaped, and you have to rescue them. Maybe we can focus more on the technicalities. Now? Yeah, yeah, of course. So yeah, let's let's jump into it. I think one, one thing that I would really like to talk about is, is good luck is the the framework that we use to build this game. In fact, good luck is a project by Neha and myself that we started two years ago. And it's the idea is that we wanted to create this templates, or a set of good defaults that we can use for our games, mostly for our competition games, but not only. And what I think stands out is that this is not your typical library. You're not supposed to install it, and then import from it. It's in a way, like every game is its own engine. The end, like, ever, but at the same time, no, no game has it has the end. Right, instead of including Good luck, like you would include your typical game engine into your project, you just clone the repository, or like use the template ability of GitHub. And you use our bootstrapping utility to create. And you project out of one of the exam, and you get a lot of codes already for free there. So you know, if you're interested in 3d physics, or rendering, of course, but also some utility systems like moving around or in touch inputs, like it's all there, and so ready to be used? Well, maybe we should talk a little bit more what you get, as part of good luck. And to talk about it. I think it's, it's a good idea to talk about ECS. Right. Right. So every entity has has different behaviors attributed to it, right? But But what's interesting about the ECS architecture is that the data for behaviors lives completely separate from the logic of the behavior, right? And that's, so there's a difference between components and systems. And what I like what I like about this architecture is that allows you to compose different behaviors together to build something smarter, right, something unexpected. Yeah, maybe we can show an example of this. I think what's interesting is that's like the, for example, in this and this blueprint, or in this object. Essentially blueprint is just a name that we chose for functions that create objects. The the movement functionality is given by the move components. And in fact, there are other objects in the game that also can move. And the only thing we needed to do is added this very same component to them. And then it just works, right. So here we have is showing the blueprint for a bird, which is just like a decoration in the background. But it doesn't move and it flies away into into the distance. And you can see that it also has the Move component by virtue of which it does the moving. Then, like the Move component, the only thing that defines is is how to move and how fast to move, once some other logic decides that the entity should move. So for example, we have this other component called control control always, which is just a super simple if you think about the super simple version of AI, which, like all it does, is moves or tells the move system that this entity should move forward, every frame forward move in the direction defined by right? That's right. And you can see like, we used lifespan here as well, which means that you know, after 10 seconds, the bird probably flown into the distance in the fog, so you can't see it anymore. And so we just destroy the object. And it's no more. So you can think of this like you, you compose the behavior for an entity out of many different components. And then you have a number of systems that all work on different combinations of these components. So this one is actually very simple. It only works on the lifespan component. But maybe if you show a different one, and shake maybe, yeah, this one. Yeah, so shake expects the entity to have a transform and the shake components, right. So actually, every entity in the entire game, as long as it has these two components will go through the system. And this is very powerful like you can, you can move different things randomly. That's what the system check system does, depending on where you need it and how you need it. So for example, when we implemented the Meier fire, that's an A particle emitter that just moves very quickly, every frame randomly and produces this erratic effect, it looks like the fire is burning in a wide volume of space. All of this is just implemented using a simple for loop. And it's, I think, I love that. And I still love that good luck is so simple, like, that's the entire logic of the game really, is that you have a couple of functions, a number of functions. And all they do is just pretty stupidly iterate over everything in the world and see, do I need to check this? Do I need to check this? Do I need to check this and you can do this 1000s of times per frame. And it's crazy how performant modern browsers and modern computers are like, I think when we profile this, like the entire update part of the game takes two or three milliseconds it's it's it's nuts. Right? So this is how were we where every systems system is being called and every single one of those iterate over every entity inside the game and I think last like concert we we had like 4000 entities in the game. So like this is doing probably 20 or 25 iterations over all 10 for 1000s of entities and again, it's it takes almost no time at all, which maybe is a little bit counterintuitive. You know like I just loved it when we first discovered that the good old fourth loop is actually the most performant way of doing let's jump into to how we build the world of escape. Right so we used blender to build our props. And apart from the farm level we every every prop is built from two primitives I believe. So we use the cube most of parts of this barns cube and we used cylinder cylinder. So as you can see here, those are just batch of cubes we have a cylinder inside. So actually like a single barn What is it like 15 different entities, each one rendering a cube or cylinder and they're all put together, you know, in the right place on the right angle to give the final result result of the bar and. Right. And we did the same for maps. So every element here in the map is, has a name of Prop. Like we have a booth property, we have a box property barn that I showed you earlier. And there's just cubes here in this file, right? But were there just user cylinders here, because of the I don't know what it was in this year. And when we export the file like that, city, okay. It's the the logic here is the same as it was in exporting props, like every this is ground. So for instance, we have a fence instance that's located in some place of, of the world, and it's rotated and scaled, according to how it is in bed. How we set it up in Blender. Right? Yeah, I think that's, that's all I wanted to say about escape. But be sure to you know, play it if you thought this was interesting. And whenever you feel like learning about Game Dev or making your own game, give good luck a try. Yeah, consider it as your next J certain K. Talent tool. tool of choice. All right, thanks. Thanks. Spot 17 We have the game gamut shift by one grumpy dude. The first thing that is hard to miss about this game was the cool transitions and wonderful 3d graphics. Once again, thanks to Web GL to. This game asks you to push stuff around essentially unlock passageways, and reach exit portals. We use the W A S, D keys or arrow keys to move around and the spacebar to undo last push actions, as well as are to restart the current level. Levels are made by creating arrays of symbols or text that symbolizes a game piece. Similar to the approach or newer game libraries such as kaboom J S, you can view some of the levels in this level js file. I like this approach as it makes it easy for us as game developers to visualize what we are working with. Judge crystal chi Tila said phenomenal. When I saw loud audio head warning I knew already this game was going to be polished and thoughtful. Thank you for that. Then was the amazing music faded in and these spectacular transition shaders showed me the world full of awesome detail graphics. My jaw hit the floor we could work the shines the shadows, the reflections, the warp lens effects on completing a level beautiful the gameplay. Well, it's a nice Sokoban game very familiar, but the puzzles were great and difficulty progression was comfy and welcome amazing work. At sports 16 We have adventure in ASC to space by Nicholas loss. Hello, my name is Nicholas. I have a confession to make. I'm a game dev addict for years for 10k. This year, I submitted free entries. And they all ended up in top 50. In this video, I want to talk about two of these games. So the first game I want to talk about is adventure in ASCII space, which was my main entry this year. As a kid I played games like I owe ArmaLite on my Commodore 64 We traveled to space with your ship and shutting down enemies watching out from bullets. And I wanted to make that kind of game this year. So I was very happy when I saw space was actually a theme. So here's the intro text. Most people skip this. If you didn't skip it, you got some instructions and you also get an achievement in iOS 13k. So here is my sheep coming to ask us base, chopping down enemies, collecting resources. It is resources. I have an upgrade panel. I can upgrade tree you need to pick to pick things in the right order or select which one you want to have first Which tree to select If this will increase the laser speed then it became quite boring. I mean, just these random formations. So I started to add in levels. One more upgrade levels, then you couldn't lose. Then I added in checkpoints. And this was a bit problematic, because I couldn't have automatic checkpoints, but then you might lose some of these materials, like I did here. The problem was that some people that didn't read instructional thought that C came towards me it was actually an enemy and avoided them. So yeah, I'm not going to show the whole the whole level. But this is the start and start level. As you could see, the game is ASCII based. So I didn't draw any graphic at all. I had that issue last year. And the texture bit too big, took up too much space and had to remove gameplay from from the game. So I was thinking, Oh, maybe I will just do an ASCII graphic. And ASCII is built into a web browsers because that's just a font. So you can see here, I'm actually just creating canvas, where I'm filling with text. So this is the character, this is actually the ship. I'm a few character hills that I'm using later on as sprites. To pieces actually, the heart, there's an ASCII code for that. So you can get a heart for displaying their health. Also, I'm using some tricks for generating melt fake light. And for that I need circle. So I'm actually adding a circle here as well. I'm using later to create fake light. One issue I had with this technique, most that is font, it's a little bit different in different web browsers. I mean, that's okay. They look a bit different, but actually positions differs a little bit as well. And not even in web browsers on the same operating system. Actually, it was the differ on different windows 10 versions. So I had to add a bit a bit of padding around each character, which ended up as a sprite in the end. But in and I think it worked. I tested on a bunch of different operating system and browsers, and I didn't see anyone complain about it. Everything is Vm GL. I'm using this tiny sprite module that I found on the Yes 14k resource page. So I didn't have to do it every web GL stuff myself needs time. So why do I need them GL? Well, as you can see, there's a lot of things going on particles and bullets. And doing that without Web GL would have caused the game to be where we were very low FPS. One last thing I want to show before moving on to next game is the level. So to generate the level, I actually drew it here in GIMP. And this is actually the level as a PNG file where you can see the level structure to different entities. Also decorations, everything has different colors. In the end, the PNG file is a bit too big actually. So I needed a way to compress it even further. And I wrote a level compiler. This is actually something I did for my game last year. So I'm been reusing my own code. So I'm going to the image data and looking at our Gb colors. When they match. I'm adding a character to a text file. And under do that for every color in in a PNG file. And that will end up as a text file like this. This is much better, this can be compressed a lot. And then in the game, I'm reading this text file, clicking the level character here, I'm adding tiles, or adding formations or whatever I want. So that's a very silly way to make a level. And then I was basically done with the game. And I had almost three weeks left. So I started to play around with another game called running out of space. I didn't mean to submit it, but in the hamlet became quite okay in game. But it's actually not one I'm going to talk about now. It's this one, space block invaders. And I didn't mean to make a game of it. Actually, in the beginning, I just wanted to see how much of a Minecraft clone could be done in 13 kilobytes. So what you see here is basically, the first day I was having blocks added and created, I had noticed functions to create very simple landscape. I didn't have any collisions at all here. So I'm just playing around in a very limited area. Then I was working on the code a bit more, I was adding collisions, and I thought that will be very difficult. But in the end, it turned out fairly easy to do. And I had to collision Stanley in like 30 minutes or so you're seeing a be collisions. So here we can see that I can walk around, I can actually place blocks and remove blocks. And the following day, I added trees microf has a lot of trees. So I was adding increase as well. And as you can see there is some very basic gear shadows underneath the trees. So that's a kind of emulated sunlight. And I worked almost two days on implementing ambient occlusion. So as you can see here, the shadows under the trees is much, much more smooth. And abundantly issues getting this technique, right. And there's actually some bikes still in it. But it's not very visible. This gives the very smooth, smooth shadows this was just three days before deadline. And I actually got a whole day on my own push I didn't plan and I couldn't resist, I added some very simple gameplay to this world. So maybe just the spacing wader character you have to run around shoot them before this they destroyed world is actually not real fun gameplay. There's no go love the game. This was what I had time to hand in one day. So what did I do to make the game run fast in a web browser? Well, first of all, I'm using Web GL. This would have been impossible to do without Web DM. actually reusing code again from my entry last year, when I had some basic mesh generation. So this is normal mgL stuff. I have a mesh builder. So I don't have to fiddle with vertices in other classes. So I can just say, add the left side and right side to the mesh with the right UV values, colors and other light values. Then I think that's all the properties. So the world is basically an empty shell, you only want to render what's visible to the player. So if you have two blocks on top of each other, we don't want to render the top of the bottom block, we don't want to render the bottom of the upper block, if that makes sense, because that would never be visible. So when I'm building the mesh, I'm actually checking here, if the book at the top, if that's not existing, then add the top side. And then we do that for all all the sides of the block. And that makes a huge difference. If we had didn't have this coded, game wouldn't be aware of it, whereas, and this is the texture atlas I'm using. So this is all the textures in the game. But because it's repeating all over, in a 3d world, it looks like much more. And I'm also tinting and using different tricks to reuse the same texture in various ways. After the competition, I continued to work on this for about a week, adding in basically endless terrain rendering until the browser runs out of memory. I add basic crafting and the UI for that and different type of tools. I also added a sheep that walks around very stupid AI. But yeah, gives bit life to the world. I add water, that's just an illusion looks like water, but when you can go through it, but it can can swim. Then I start to do adding in caves. And I didn't get the result I wanted from the caves. And somewhere around that point actually start to stop working on this. But a might reuse the engine or parts of the engine next year. For a certain game, who knows. So that's all I have to show. Well, I could actually talk about this for hours. But I have to keep this short. The music ever heard in the background is my own. There's links here showing my two albums and Spotify. I have a blog. That's very inactive. I have Twitter. Just ping me if you want to talk about something. And see you next year in JS 14k. Plus 15, we have Q one case three by photos lab. Hi, my name is Dominic and this is my j is studying country for 2021. I'm not really sure how to pronounce it. So let's just call it quick. This game was done as a tribute to the original quake from 1996. And it doesn't really match the competition's theme. But I really really wanted to do this. So here we are. Quick features two levels, five types of enemies, three different weapons 30 Different textures. Robots collision detection, not so smart, but not completely dumb AI, some nice ambient music and spatial audio. I want to go into some more detail about how all the data fits into the game, how the textures levels and models are stored. Let's start with the levels. I had some experience with building levels or maps as we call them for Quake three. Since I was aiming to reproduce parts of Quake one, I thought using a map editor for Quake would be a good fit. Back in the day, we used a tool called radiant and while it wasn't really bad, in hindsight, it feels a bit clunky. So this is trench prune. It's a map editor for various Quake engine games made by Kristian daska. And I can't say enough nice words about it. It's really really good. It's completely free and open source so go check it out. While quake maps allow for all kinds of funky geometry I limited myself to only use axis aligned blocks. These blocks can be quite small to allow for stair steps or some details on the maps, but they can also be huge. One block can cover the floor or the ceiling of multiple rooms. I was able to capture most of the famous e one m one map from quake one the slip gate complex, with just about 200 of these blocks. I have to admit, though, that the original map comes with a lot of secret passages and rooms that I wasn't able to fit in. So these 200 blocks can be stored in a binary file with just seven bytes each one byte for the xy and z coordinates of the block and one byte for the width, length and height, and another byte for the texture index. These binary files with all the blocks are loaded in JavaScript into a big array buffer and all the vertices for Web GL are constructed from it. The entities so all the things that are in the map, the light sources, the enemy's ammo, and health boxes, and so on. Start with one byte each for the type ID, three bytes for the position and two extra bytes for some extra attributes. For instance, for the light source as one of these extra bytes is used for the brightness, and one is used for the color value. So with all this, in the end, I managed to squeeze in two maps, using up a whopping 3.2 kilobytes in the zipped file. The models for the game again, I'll start in the simplest way possible, it's just a set of three byte coordinates defining the vertices, and then a list of indices where each three indices define one triangle or phase of the model. For the animated models, the list of vertices, it's just repeated for each animation frame, I was able to get away with very few animation frames by just linearly interpolating between them. I was using Winx 3d to create those models, I exported them as a wavefront object file and converted them into a binary file with a PHP script. It's not really a good workflow, and I really should learn a bit of blender. Next up textures. This was probably the best idea for this game. Instead of creating a textures as PNG files and just saving them in the zip. The textures are created on the fly as canvas elements when you first load up the game. This idea is nothing new. The demo scene has done it since forever, but I falsely assumed that you needed some complex operations to achieve good results with generated textures. Nevertheless, I tinkered a bit with the idea and after some promising first results with drawing random stuff on canvas elements. I built a really simple editor to create those textures. And I mean, really, really simple. This editor just supports five different operations, you can draw a rectangle, you can draw a grid of rectangles, you can draw some random noise, draw text, or draw previous texture. In the end, I was quite surprised myself, with the results you can get with this, it was really unexpected, also turned out to be a lot of fun to build those textures. The result of all this is a JSON array that defines those textures, all 30 of them, and a tiny library that reads this array and spits out canvas elements. The whole thing is on GitHub, it's called Tiny texture tumbler if you want to check it out. I won't go into detail of how the music is stored. But the short version is that it's similar to the textures. It's just a JSON array of nodes that gets rendered into an audio buffer. So with all the data out of the way, I had about 5.9 kilobytes left for the code, I want to show just two things in the code in particular, and one of those things is the render. I'm using Web GL to draw everything onto the screen. And everything in through in the game world is spit out to the GPU for each frame. There is no occlusion culling, or fancy math to figure out the visibility, and doesn't really matter computers are fast. The renderer uses only one shader program for everything. So all the enemies and the whole game world are drawn with the same shader. The vertex shader handles the view rotation, the direction you're looking at. The view position the object position, the objects rotation, and planning between two animation frames for an object. Of course, it's inefficient to draw the static wall geometry shader that can plant animation frames and rotate geometry. But again, it doesn't really matter. Computers are fast. The fragment shader applies a uniform array of light coordinates and light colors to every pixel and does little else dances in a loop one iteration for each light source. So the number of lights in the game is fixed to 32. And to stay within this limits, the lights are faded out after a certain distance. You can see this fade out in a few parts of the game but Honestly, I think it looks cool and adds to the atmosphere. It's a feature, not a bug. Completely unrelated to rendering. Here's the collision detection routine that is executed for each entity for each frame. This is very similar to what I was doing in my previous game and Iran. But this time, I'm doing it in three dimensions instead of two. But the idea is the same. First, you remember the current known good position of an entity, you advance this position according to the entities velocity. And you test if the final exposition of this entity with the old y and old Z position collides? If yes, you roll back the final x position to the old position. And then you do the same thing for the y and z coordinates. Checking each of the three axes individually, instead of just doing one test with the final position allows you to slide along the floor and walls and turned out to be really robust. The real code that is used in the game, there's a bit more stuff in particular checks if we can step up a staircase, or if an entity needs to bounce it off from the ground. This is used for the bouncy credits, for instance, but the gist is the same. It's just a bunch of simple checks, no complex mess. There's one last thing I want to get into and that's keyboard input. If you do ws D movement in your game, I urge you to use the keyboard events code property. This property is keyboard layout agnostic, which means ws D works on French keyboards, and CNY keys are not switched on German keyboards. The current property basically reports the key based on the US keyboard layout. So you're defining your keys by the position on the keyboard, no matter what layout is actually used in the end, so the user's local keyboard layout is completely ignored, which is exactly what you want for your games. That's about it. If you're interested in some more detail about the game I wrote a making off post on my blog fireballs lab.org. Thanks for watching and see you next year. At sport 14 We had the game celestial Lighthouse by Tom Herman's. Hi, I'm Tom for instant games last year, I made a game called actual fonts. This year I made this little lighthouse which is a physics puzzle game about placing blocks in the atmosphere of planets Avada thing will fall into the Klout score. So to achieve this circular gravity I adapted the physics library MatSan as and their attract plugin. So today I'd like to demonstrate the level formance since agile fine was a grid based game, the love performance is quite straightforward there. So lesson Lighthouse also required it since generating all the physic shapes manually, which require a lot of codes. And here's the key, you should usually try to record data in as little space as possible, preferably building in hearts assumptions that reduce file size, where possible. This is why for example actually sensagent up as an array instead of objects with more readable properties property names. So in celestial lighthouse, each level has a lava core and an atmosphere. So since this is a continental level defined, we just define its size here. And the level generation codes just takes care of building the actual shapes of based on the inputs. Furthermore, we define which shapes can appear as random to be placed by a player. So simple shapes as defined here can be a square and rectangle or trapezium. This is then used by the game as a grab bag of sorts. to randomly select the blocks place once you place a certain number of blocks, solve in this case you when the left finally levels have a solid bad forms. Those are these black shapes and the level. These can only be regular polygons like like triangles, squares, and even circles. You've got also good shape in the hall. by making them negative and if you require, you can also change the size, the Starting Angle, the scale. And you can even sense it rotation speeds. And yeah, that's pretty much it, I really enjoyed the staff performance because it makes iterating on the level design properties. So my main takeaway here is to make it easy as possible for yourself to test and improve your game and the levels and it's alright, why and thanks for watching. At number 13, we have Space Jam by Mark Roquette. Hey, folks, I'm Mark rosette. I'm a developer and musician currently based in Austin, Texas. And today, we're going to be talking a bit about my GS 13k entry called Space Jam actually got the idea for Space Jam from playing farming games like Stardew Valley, I began to wonder if it was possible to make a game where you build up a settlement using musical instruments as the building blocks for the game. In Space Jam, the gameplay is pretty simple. We start off with two instruments and this oscillator. Basically, the way it works is you can add new instruments to the board using the notes that you collects when the oscillator strikes an instrument. This way you can build up patterns, beats and ultimately earn more notes to unlock more instruments. You build additional oscillators to kind of expand your repertoire and place them in different areas of the map. So next up, I thought I would talk about the spatial audio in Space Jam. Basically, the way this works at a high level as you have this map, and you've got a grid, and the cameras kind of centered in the middle of the map, and there's instruments that you can place and they're going to be some distance from the camera. And that's kind of where your center is as the player. And so as these move, you know, from left to right, or up and down, I wanted to make sure that I was taking into account their position relative to this point, and controlling the audio effects accordingly. So the first thing that's going to happen is they're going to pan left or right. So this is going to pan slightly to the right, this is going to pin a little bit more to the left. And if an instrument is all the way at the bounds of your viewport, it's going to be panning fully in that direction. So panning is the first thing to come into play. And then the second thing is just going to be based on the absolute distance from the center, that's going to affect the amount of reverb that's applied to that sound. And also just the overall volume of that sound. So what that looks like in code, have basically consolidated all this to this function. And update spatial effects is something that happens up here in this move camera function. So yeah, basically, anytime the camera moves relative to the instruments, you need to update their effects. And so this has got a bunch of other stuff going on. But again, we're just gonna hone in on this function here. So this actually takes the instrument that was affected by this camera move. And then first, it calculates the pan values. So pan x is going to be the instruments, position in the extraction and the delta of that with the cameras position and extraction. So again, just you know, these types of values are here that's in relation to the viewport itself. And you clamp this here, I just have like a utility function that clamps if you don't know about that, look into it. It's super useful for just any type of kind of quantitative coding, but especially creative stuff like games. So basically, what this is saying is the pan X is never going to be less than negative one or greater than one. Same exact thing with the pan y just in the y direction. The radius this is just a simple calculation to agree in theorem right here. And again, the radius is important because it controls the volume. In a number 12 We have fast contact by marketers silk off. Hey people, Marco silk of here. I'm a security enthusiast from Israel. It's Amber silk on GitHub and Twitter and Gmail, what have you. And I'm working for this magnificent little company called noname. Security, we do defensive cyber security for protecting API's. The game I want to talk about today, first contract was written for the GS 13 compiler in 2021. It's a simple clicker game. And I have footage of it here. So yeah, the usual staples of the genre, I'll present its instant gratification base, and the game practically plays itself, it's not skill based. What I attempted to do with this formula was a little story, some of the things just happened and you have no control over them. There are two different endings based on the subtle player choice, that sort of thing. Now for the source code, the thing I'm sufficiently happy with is how its coded to the browser's JavaScript engine. The idea was to avoid problems like performance problems during the high level designs so that we don't need super clever optimizations later, like two days before release, I'll give two small examples of that. First, in JavaScript garbage collector can unpredictably pause the execution of your program and do its thing to free memory. And on a 60 FPS monitor, you have 16 and a half milliseconds to render each frame, meaning that garbage collector can drop frames easily, and make the game stutter. And one workaround for that is to just allocate everything you need ahead of time. So that garbage collector has nothing to do. For example, in the first contact game, there are all these objects that are orbital platforms and cannons and projectiles and of course, the invaders. And every object is a very small state machine with a small number of states. So let me show it here. In the source code, a cannon can be either ready to fire or it can be reloading. What helps with garbage collector is that all objects have an additional state, which is called missing, which you can see right here. And so when we fire rocket, we do not allocate a new object like new rocket, we instead pre allocate all of the rockets at the start of the game seven missing by default. And when we needed to fire, we find the first one that's missing and use that when the rocket hits, it reverts back to the missing state. So we have zero allocations, and garbage collector is very happy with us. So here you can see, for example, like the cannon, which has all these states. And when we, at the start of the application, when we create all of the possible like like cannons and rockets and invaders, we we just allocate them here, there is no allegation, there is no like new counter new rocket anywhere in the code, apart from this specific place at the beginning of the game. Yeah, the second thing is also very small. And it's related to the fact that all drawing in this game is done on HTML, Canvas. And Canvas has great performance. But when you need to render possibly 1000s of objects in every frame at 60 frames per second or more, the rendering costs quickly end up. The trick is very simple. Let's say we have the Space Invaders, drawing one Invader is simple. We'll make a bunch of lines of calls and then we'll go stroke feel or what have you. You're all familiar with the Canvas API. Now, what about drawing 1000 of these? It turns out one way to optimize mass rendering is to first make all of the line to calls for all the invaders. Like here, you can see the render method for the invader. And it has all these line tools and close path. And when we actually invoke this method here, we have a function to render all of the invaders at once. So it first invokes all the line tools and only then it does stroke or feel or anything. This works because the browser scanners implementation, which is actually highperformance C++ code works best if we give it a lot of stuff to rasterize at once. So like all of the invaders or all of the particles at once. The anti pattern here would be a common stroke, like every time for each line segment and this is known to kill performance. So that's all for me. Come participate in Gs 13k competition next year. At number 11 We have shuttle deck by Ariel Wexler. Hi, my name is Arielle, and I'm the creator of shuttle deck. You can find me on Twitter as Ari neon shark I make all sorts of games simulations and fun little procedural animations. Okay, so let's dive right in and take a look at shuttle deck. At its core Federal Bank is an infinite runner crossed with a deck builder game. So I thought that would just be a funny combination of genres. I haven't seen that done before. So he around professors orange lab and we're serving kind of as a space courier will be traveling between planets avoiding obstacles on the way. And we need to help Professor Zorn over here on the right to deliver his package the Xeno transponder. So let's go ahead and help them out. So here we are traveling through space, we see some minerals, we see some asteroids, and have these cards down here, I can press on these cards, and I will actually changed the lane that my spaceship is in, that was a pretty easy run. For me, I didn't have any obstacles that really were in my way. Excellent. In between level, so I just I just moved between two planets there. Every time I reach a new planet, I'll encounter some sort of strange character, in this case, the street merchant, and he's offering me a few cards that I can buy. Now in this case, I don't actually have enough minerals to buy the cars that he's offering. So we're gonna have to go again, let's check out one more stop here and see if we'll actually be able to afford something, just miss that. That's unfortunate. We go. Okay, it's looking pretty good. 16 usually goes a long way. Alright, Kepler missile, no problem, go ahead and grab one of those. But this will help me do is if I have an asteroid in my way, I'll just be able to shoot it, boom, and get it out of my way. Perfect. So that's the core of the game. And now I guess we can dive into a bit of how it all works. And what I'm really excited to share with you guys is the event emitter, I have my own custom implementation of a very, very small event emitter that I use in the game. So we'll we'll look at the code in a moment. But let's just talk quickly about why this is important to the game at all. So you just saw shuttle deck. And the way that it actually works is this, the game engine itself is completely decoupled from all of these other little components, they don't really know about each other. So let's think for a moment about you know, maybe how the main character shoots rockets. So the way that works is if you have the, you know, shoot a rocket card right here, right, so we have that here, the player is going to click this, and what's going to happen is in little event is going to be emitted. And I'll just kind of draw that is a little loudspeaker, you know, some holding a loudspeaker and it's shouting out. Now what's happening is all these other systems in the game, you can think of them as ears, they're essentially listening. So that's, that's what an ear looks like, I guess. So, you know, all these systems are listening. And what they're listening for is events. In this case, the event was, hey, I pressed the shoot of a rocket card. So each one of these systems is actually going to receive that message, but only the relevant one should respond, I'd like to take some time to look at the actual code that, you know, fuels all this. So here we are in the cards definition file. This has all the cards in the game has their color, their name, much cost, to use them or buy them a little code to friend or them. It's a little glyph, that shows up on the card in game. And finally there is the actual code for handling what happens when you use the card. None of the actual implementation of what to do when you use the card lives in here. It actually just outsources all of that using that exact same strategy of just emitting what should happen. And all the relevant systems on the other end are kind of receiving what what what to do with, with these emits. So here we are looking at the Kepler missile, the same thing we've been talking about throughout all the examples. And all it does is says, hey, when you use this card, just emit projectile type one, it just says that out into the world. And the you know, the world of the game needs to then understand what to do with that. So let's go ahead and look at who might receive that. So here we are. I'm looking at the main game engine that's actually listening for projectile offense. And it's listening for the projectile type as the only data parameter that comes into it. So just like the projectile creation code we just looked at here I am in the Audio Manager. And we can see right here that I'm listening to that exact same event, and I receive the actual type. If the type is type one, I play the sound for a missile. So here you can actually see all the sounds for the game. I'm just listening for all sorts of other events that are going on, and I play the correspondingly correct sound. I didn't have to introduce anything intrusive at other parts of the game. But it's all nicely localized right here. So why am I bringing this up at all? Well, mostly because I love using event emitters. And I think they're a very necessary part of making certain types of games. And if we look at, you know, state of the art libraries, like event emitter three, let's say for JavaScript, or node, this thing is getting 15 million weekly downloads, like, Oh, my goodness. So this sounds like the right thing to use, right? Yeah, well, there's only one problem with that, if we go ahead and actually look at the minified code for it, it's, it's kind of massive, and it's a bit more feature rich than we probably need. In fact, this is about, you know, three KB, it could probably compress a bit more using few of our tools. But still, this is way too much code for what we actually need. So we're finally getting to the punchline of what I'm so excited to share with you. And here it is. It's a really, really small version of an event emitter library that compresses really nicely here, it says about 346 bytes. But actually, once this goes through minifier and Uggla fire, this code will go down to close to about 112 bytes. And I guess when you run it through road roller, it'll probably be even less than that in the grand scheme. So thanks for tuning in and checking out shuttle deck. I hope you enjoyed what I had to share about it. At number 10, we have lost a snake in space by Sun raising on behalf Maxine. Hello, I'm Maxime, a web developer and game developer from France and I developed my 10th js 13k game entry this year, you can find me on Twitter here, or on YouTube or on my blog. This year, I made a puzzle game where you control a little snake that visits different worlds, and needs to reproduce the patterns drawn on the floor with his body to progress and eventually reach the moon, where he will find the final hardest puzzles of the game. In each wild, you learn new mechanics like climbing walls, using teleporters, wrapping, moving in 3d and so on. And it becomes quite challenging when you pass the first puzzles. You can play it on PC and mobile right here. In regards to the code, my favorite parts of the code is the graphics. The first is regarding the snake. I spent many days researching a way to represent a cute snake in 3d, and finally found an elegant solution that requires very little code. I use a big circle for the head and many smaller circles for the body. aligning all these circles and making them move together gives a pretty good illusion of a snake body with a real volume. Even if it's just a bunch of flat circles rendered with HTML and CSS. The game is rendered with a little CSS 3d library that I developed before the competition. It is called CSS 3d framework and you can find it here. It allows us to easily draw and animate 3d shapes with very little code. Here is the J S code for the snake. And here is the CSS code for the snake as well. Next up I want to talk about the code I use for the ground textures. During the competition I met fence, he creates gorgeous textures using SVGs. Each of them is about half a kilobyte, which is perfect for Gs 13 games, where the entire game size is very limited. All the textures present in my game were created by Him. The grass, the sun, the moon, and even the lava, or his CSV art can be found just right here. Here are the textures I used in my game and then minified SVG code. Here we have the grass. Here we have the sand. Here we have the moon. And here we have the lava. These techniques and many others are detailed in the games making of right over here. Thanks and see you next year. At number nine, we have black hole square by Quinton Klaus. Hello, my name is Quinton Clauser. It's the first time I submitted something for Gs 13k. I've been following the competition for as long as I can remember. But this is the first year I submitted something. The game is called Black Hole square. As you can see, it's a little bit heavy focus on mobile controls, actually you just step the tiles they move so you have different kinds of tiles that move in different directions. And goal of the game is to put all the tiles into black holes, little black holes, so you need to clear the screen of all the white piles and then you finish a level. So when I'm not participating in the game jam, I keep text documents in which I write game ideas. I have things that come to mind are writable down in this text document. And then when again, jump starts, I'll quickly go over it and see if there are any ideas I can use. Actually, this year's ID was from a sketch, I already scribbled down in my notebooks. So when the gym starts, I create a new document, which will be like the design document for the game. And which I put to do like little notes. I don't actually do all these things. But just if I have any ideas, I just put them in there. And also put a copy in there. So the copy for the game, like little sketches for the levels, the graphics are made with Affinity Designer, and I export them as SVG. And then I use a tool called SVG, oh, you can install it with NPM globally, and then you can compress the SVG s. And then I did I am, I take out the parts. And I and I use part two D to render the different parts of the SVG. One of the most important files in the code base is the entities print Jason. It contains all the data from the game, like the order in which the puzzles are recopy for the game, and The puzzles themselves. So they are just little arrays. This point, I always have a fairly small notebook in my pocket. So I can make little levels. When I'm on the go. While I'm waiting for something, just make little levels, make them on paper first. And then afterwards, I put them in a one of the most important files are where most of the code this is the puzzle part. Yes, it also contains the keys. So there's a comment, which contains the keys, which all the digits are in the arrays of levels, as you can see, contains a lot of lot code, like mostly when I'm working, there's always one file in the code base that starts piling up code. In this project. It's the puzzle that is truly a mess, like No comments. And this thing also contains my favorite part of the code, which is an event listener for the wheel event, which actually makes the swiping like the swiping controls makes them work on a laptop. If you swipe on the trackpad, like it works on all the laptops, I tried to listening for the real event, you can make the swiping work on desktop to on laptops, at least. That's it. If you want to find out more about my work, you can find me on the internet on these URLs. If you have any questions, I'd be happy to answer them. Thank you for listening. And I hope to see you on another edition of Gs 13k Thank you. In spot eight, we have space huggers by Frank force. Howdy. I'm Frank force, also known as killed by pixel, a game developer and generative artist in Austin, Texas. Today I'm gonna share with you some of the secrets by my GS 13k game space huggers. It's a running gun roguelike hybrid with procedurally generated fully destructible levels. It has an explosion and fire propagation system that creates all sorts of unpredictable chaos and chain reactions while you're playing. That's what I'm going to show you today. First, let's take a look at the game and see how it works. You can get the full source code for my game space huggers off the GitHub website. I've already gone ahead and downloaded space huggers and open it up in Visual Studio. The first thing I'm going to do is an app effects. I'm going to enable debug fire. That's going to show us some debug information when a fire event occurs. For an explosion, it's going to show you two circles and a radius and outer radius. The air radius represents what is what is completely destroyed and the outer radius is what's called fire. When something is on fire, it will draw a red circle to represent a fire event. is being sent out to nearby objects to let them know that they might also want to catch on fire. This fire events are not set out every frame, but only periodically for optimization. Let's open up app objects. And I'll show you how some of the fire stuff works. You've got a couple of variables, burn delay, that's how long it is before something starts burning and a burn time. That's how long something burns for. Now, in the update function, it checks if it has a burn time, that means it can catch on fire, then it checks is the burn timer set, that means it's burning. So if the burn time has elapsed, that means it's, you know, a lot of it's pretty burnt out, which means it tries to tries to die. If there's a fire meter, you have to turn that off. There's also a small chance to spread the fire. And this is what causes the really cool chain reactions to happen. You don't want this to happen every frame because it's kind of a slow system to go through each every each and every object and check its radius to see if it's close enough to catch on fire. Of course you can, you can do things to speed that up. But it's always going to be a bit slow. So you don't want to do that kind of thing every single frame. And you don't need to, it's good to have a little bit of randomness and something like this. It also checks the bird delay timer. If the bird delay timer is elapsed, then it starts burning. There's other stuff in here called a burn color percent, which kind of alerts the burn timer to make things darker as they get burnt. And if you want to burn something directly, we just call this burn function. And that sets up the different stuff to create burn system it creates a fire emitter and attaches that as a child sets the burn timer. And there's also a way to extinguish fires. For example, by just rolling you'll put out a fire where you can also be near a water barrel. When you explode a water barrel sort of burning, it actually puts out everything nearby and just extinguishes things in a radius and that sets distinguish timer, it unsets the fire effect then timers and set things back to normal basically. I hope that gives you a good idea about how the fire system and my game works and how you might implement something similar in your own game. I'm gonna give you a quick demonstration to end things out here. I like to tell you to follow me on Twitter also made the game engine for this game open source. You can get that on my GitHub, it's called Little J S. Next year, I'll be using a little J S to make a new game for j s 15k. And I hope that you do too. So thanks for watching, take care of yourselves and have a great day. In seven space, we have the maze of space goblins by Yanni new cannon. The Moses face goblins is a puzzle game that combines Sokoban like gameplay mechanics with match through the graphics are extremely retro and work very well for the type of game that it is the level of care around the intro and the option to have the sound on or off was very much appreciated by the judges. You can play the game by collecting stars to progress to the next level and by matching three or more space goblins of the same color to destroy them as it make space for you to move. The game has made use the arrow keys to move backspace to undo a move or to restart and enter to pause the game. Yanni tested this game on Firefox and various chromium based browsers such as opera and edge. He also tested it on Linux and Windows as to make sure the user had the best possible experience no matter what browser they were using. The bitmap font was one of my favorite fonts that I've seen as competition. This game had also an interesting approach to creating the levels as you can see here with the data tag, and was one of the few projects which use TypeScript to create the game. As you can see by the TSX files, Judge Jupiter Hadleys said he loved the graphics. They were really simple, but a fun game. He loved the challenges in it. Ralph Mertens, the name definitely got my attention funny intro to the game does a good job of getting you engaged and he thinks that the puzzles were excellent and quite challenging. They had him playing for a while great simple puzzle game that's deceptively hard with retro visuals and sound. In sixth place, we have Packer bunches by Mattea fu to natty Hi, I'm Mattea game developer some time for a B sometimes for work, always for passion, because I really really love games and game design. I'm I'm very fond of Gs 13k games, because of all the creativity can push with all the great ideas coming out every year. And so I always try to participate whenever I can. So now let's jump to my 2021 entry Bokoblin. Just like Adventures is a colorful tiling puzzle game in which you have to rescue space creatures by packing them. It is playable from both desktop and mobile. And as for controls, you just use clicks of ducks. I am really proud of this game. And not only because I think it came out to be very nice, but also mainly because I had a great time making it. In fact, my personal goal and approach this year was to fully enjoy the creative experience behind the development of every single part of the game. Let me explain. For example, to create a music I didn't just sit there trying to compose something. Instead, I met with a musician friend of mine, and we spent the whole afternoon listening to puzzle game music from all Nintendo games for inspiration. We had snacks and drinks, sharing ideas in front of the piano. And in the end, we came up with these personal Vish jets each chord progression for puck adventures. So you see like this, whatever the result, I had a great time exploring new things with a friend. Same thing goes for the logo and the mascot created doing some brainstorms with my girlfriend, in which we had fun accentuating shapes and trying different goofy designs with paint for the logo and pen and paper for the little character. As for the gameplay, since the theme this year was based, I get lost for days exploring been packing problems in space management algorithms. To get some inspiration, I eagerly explode from feng shui principles to scientific papers on automated furniture placement. And so I learned many things like furniture, usability rankings, relationships between objects, human navigation, space, and so on. Again, as you can see, I stuck with a more simple polynomial shapes packing game with some Yahwistic brute force for level generation. But it has really been an adventure, believe me. So maybe now you're curious about backbenches code about how it can fit into 10 kilobytes. And you want to check it on GitHub. Well, just don't do it. Like a bunch of code is bad, messy, full of mistakes and unused or redundant workaround ish copy paste the things not really. I couldn't make the code presentable for the deadline. So we stayed you should check this one. This is a basic Gs 15 kg games template which I made post competition which is some water we organized cleaner version, or what they use for puck adventures. It includes some features that I personally see at the moment and standards in this field of making games interesting kilobyte that I like to reuse myself in the future. Many of these solutions are not my own, and every specific owner is credited with links. For example, he has the document setup, we have the middle attack to be sure emojis are shown. And we have the cool cheap trick here to send an emoji is fav icon, which will also be the game icon mobile if you use the Add to Home page feature. Then we have Canvas centering and resizing handle with the wrapping. very readable and very solid. As for the audio part, my tools of choice here are Z FX and the GFX m by Frank force and Keith Clark, which you may already know and which I highly suggest you to go and check out. And so like this, we have a clickable centered fit canvas with emojis audio icon and mobile compatibility. I'd say it's a great starting point to create a game. But the thing that made it really possible to fit backbenches into 13 kilobytes, and that practically remove the sides concentrate is the build process. This year, a new JavaScript compression tool came out making everyone's life easier. And talking about words roller by Kenson goon go check it out. So the suggested bid process here is first use Google Closure Compiler to recompile the code then third sir to crush it. And finally once roller to compress it This will extremely reduce the size of your scripts. So you can now put them inside your already minified. HTML and zip them at maximum compression. And here we have one last three couples leaves using AECT. We can even optimize this final step more reducing the size by semester bytes. My template also features a batch bill to automate all of this, which I deliberately took from Frank for centuries based hargus and modified for my needs. You can find it included in the bill folder, or commented along with a link to the original one. Thank you, Frank. So as you can see, even when talking about code, I've had a great time keeping up to date with the GS 13k games word, discovering and playing with all these great tools. And Willie, Willie, enjoy making puppet bunches. Alright, thanks for listening thanks to the Free Code Camp staff for the opportunity of being here. Thanks to MJ for keeping the competition up every year. And thanks to the ozone community for sharing old ideas, tips and projects. Thank you guys. So yeah. In fifth place, we have Welcome to Space by Matthew tiamont. In this game, we play hero looking to save this space station from evil but kinda cute looking aliens. These wicked aliens are armed to the teeth but so are you. In this game, you can use your vast arsenal to conquer the six different alien types and make your way to the Ultimate Alien boss. The pixel art was adorable for this game, and the variety given to the weapons and evil alien characteristics was very impressive. I was most intrigued about the deciding junk factors that were there for the aliens so had a quick look at the code and must applaud how neat I found it. Here the different types of enemy types in the game. We have the aggro enemy the running gun, the idiot, the pacifists and the Sentinel each have their own color scheme for the skin, horns, eyes and body. You will also see the different ways the enemies act thanks to that enemy personas. To remove your alien in this game you can use the keyboard or you can use controller support such as a controller D pad or joysticks. On the keyboard, you move with either left and right A and D and jump with either up or the W key shift or control as well as shoot with the spacebar. Make sure to give it a go in the description below. In fourth place, we have Galaxy rider by job burns, raising on behalf of Jeremy burns. Hi, I'm Jeremy burns, or John Burns, and you can find me online at javelins dotnet, I bought Galaxy rider for the GS 13k games jam in 2021. This is a game where the goals and mechanisms are simple and the difficulty comes from learning to master the mechanics themselves. I've always liked games where progression comes from a real improvement of the players skill. And this game sticks to the philosophy quite strongly. The goal is simply to collect all the floating dots and then get the skater to the exit as fast as possible. The initial challenge is just to complete the levels at all. And replayability comes from the timer. I was inspired to make this game because I think the physical mechanics of riding a pool or a bowl on a skateboard are quite interesting and fun. And I wanted to capture some of that in a 2d platformer. I thought about doing something like this in 3d. But I just couldn't imagine pulling off a novel 3d movement mechanic in 3d in the confines of the jam. My favorite part of the code is probably the animation editor. It's quite ugly code, but it does exactly what was required of it and nothing more, which is nice in its own kind of way. The way that animation editor works is by simply rendering some Jason specified lines and circles to a large canvas and giving me a text field in which I can input that Jason. It also provides a timeline which I could scrub to see how animation frames could blend together, and some basic mouse handles for position editing. I built a character sprites and all the animations using this tool. The level editor was another minimalist tool I bought for the game. Though it was a bit more sophisticated. It allowed me to place positive and negative shapes into the world, which when combined together, found all the various geometry you find in the game. Overall, I think the game came together quite well and I'm happy that other people seem to enjoy it too. In third place, we have Adventures of Captain Calista by Cody Everson. Hello, my name is Cody person. I am a software engineer in San Francisco, California. And today I'd like to talk about my GS 13k entry. The Adventures of Captain Callisto Callisto is a 3d action platform been set in outer space. This is my third time entering the GS 13k competition. My first entry was J S 13k battlegrounds in 2018, a battle royale first person shooter. My second entry was mini Punk in 2020, cyberpunk third person action game. In those entries, my goal was to make an impressive technical demo. The entries did well graphically, but they weren't considered fun. I also noticed that a significant portion of the GS 13k audience does not really enjoy first person or third person games. So my goals for this year were to make something fun, make something relatively easy, at least for the first few levels and to make something with a more global appeal. The most direct inspiration for Callisto is probably Captain Toad, Treasure Tracker, and Nintendo action platform game. From a technology perspective, the game rendering uses web GL to I extended my previous entries to support instance rendering of cubes and spheres. That means that it's pretty fast and cheap and low code to draw a sphere or a cube on the screen. All the models are simple combinations of spheres and cubes. As an example, let's talk about the main hero character, we can strip everything away, and then add the components of visor, the rest of the helmet, the body, but jetpack arm, another arm, leg and another leg. And that's how the rendering works. We can then rotate those spheres to create the animation effects. You see the spheres all over the place, the dust clouds and the coins. They're just stretched. Here's here's how that looks in the code. You can see how we generate the sphere, then translate it or move it, then scale it or stretch it. And then in some cases, rotate it to create those animation effects. And that is the foundation of how all of the rendering works in the entire game. Okay, that was a quick tour of my entry The Adventures of Captain Cousteau. Thank you so much for watching, and thank you to the Free Code Camp team for putting this together. In second place, we have beat rocks by cause this game allows you to unleash your inner dancer. The aim is to unlock new instruments of destruction and make sure to play them on the beat. Reading on behalf of cars cars said I think this is my third or fourth attempt at making an asteroid game. One attempt failed because I tried too hard at making an entity component system. Another because I didn't come up with any asset pipeline. So I promised that I'll try the next one in 3d with wireframe rendering, so that I can have some nice animations for rotating objects while keeping the retro it's all lines of visuals. The idea was in my mind for a long time, but I wasn't eager to start until fat fish told me that Gs 13 is starting and space is the theme. I couldn't pass over it. I wasn't originally planning to make this a rhythm game. The idea randomly came up later and it seemed to work. I was playing a lot of Tetris effects earlier this year, so I tried toying with the idea of sound effects contributing to the music play test revealed that it is confusing that when the plays and ability the effect triggers immediately, but the sound only plays on the next beat. This led to the conclusion why not require the player to use skills on the beat. I compose the music on a Nintendo Switch then moved over to sandbox. I'm interested in since by have almost zero experience with composing it's my longest song so far. Some tech facts for you about this game is that he also used sandbox for sound effects. The sounds were done as other instruments in the same track so that he could test how everything sounds together. Since soundbox, saves the song as Jason he was able to extract and trim the soundtracks in the game code to separate audio buffers. And in regards to the graphics he use our ETL rgl gives a convenient type interface of a raw Web GL deals away with all the boilerplate. Later, he's written the rendering and roll Web GL to save space. This was planned for the beginning as he knew our AGI would be too big. He then modeled some 3d objects in SketchUp, save to OBJ and provided a simple JSON representation. He also use snippets from Patricio Gonzalez vivos just for the shader noise texture, which made the background a little more interesting. In regards to the build and compression parser was used for the build pipeline. He likes parser because it has zero modules, TypeScript and minification by Tasa was zero setup. He'd never used parcel in production, but he used it for all the toy projects and prototypes. Tasa doesn't touch shaders, so he minified them manually using GLSL X. And finally, let's reveal the number one winner of the GS 13k Ryan says I've always been inspired by the fantasy console community and all the fantastic that uses similar constraints via a simple drawing API and frame buffer I've refined over the years that's heavily inspired by fantasy consoles. In my free time, I've been working on cleaning up retro buffer for a more official release. So other jammas might more easily make a game with it. I'd love to see that. A huge thank you to Andrei and everyone else involved with managing Gs 13k