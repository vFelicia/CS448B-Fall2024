In this course, I'm going to be teaching you everything you need to know to get started writing programs in Ruby. And Ruby is an extremely popular programming language. And it's also the programming language behind one of the most popular web development frameworks called Ruby on Rails. So if you're somebody who's looking to get into Ruby on Rails, or you just want to learn more about Ruby, and come to the right place, in this course, I'm gonna be showing you everything you need to know to get started. So we're going to start off with the basics like installing Ruby, getting Ruby set up with a text editor and executing your first Ruby program. And we're going to look at, you know, some of the bare basics, things like variables, we're going to look at dealing with different types of data, storing data, we're gonna learn things like if statements and loops, and then we're going to get into more advanced stuff. So we're going to talk about the ins and outs of object oriented programming, we're going to talk about things like classes and objects. And all throughout this course, we're going to be using real world examples. So I'm going to be showing you guys different, you know, mini applications that you can build, we're gonna build a couple different games, we'll build like a calculator, we can do all sorts of stuff. So not only are we going to be learning Ruby, but I'm going to be showing you guys how to apply it in a bunch of different situations. So I'm excited for you guys to come along. In this course, I'm covering just about every major topic in Ruby. So by the end of the course, you should have a pretty solid understanding of what this language is about what it can do and what you can do with it. In this tutorial, I'm going to show you how to install Ruby on Windows, it's actually a pretty easy process. Essentially, all we have to do is use a Ruby installer that we can download from like Ruby's official website. And it'll basically walk us through all the installation instructions. So I'm over here on this website, it's Ruby installer.org, forward slash downloads. And this has basically a Windows downloader that we can use. So you'll see down here, there's a bunch of different options, I'm going to be installing the latest version at the current time, which is Ruby 2.4. Just a quick disclaimer, the instructions in this video aren't going to work for Ruby versions below 2.4. So below 2.4, there's actually a different way that you can install it, but after 2.4 and above, then you can follow these instructions. So I'm just gonna click this and it should start downloading. When the download has finished. Now all we have to do is run that program. So I'm going to go over to my downloads folder, and you'll see we have this Ruby installer, let's double click that, and it should open up a window that we can work with. Alright, so I'm just going to click through all the options on this window, I'll accept the license. And now Ruby should start installing on our computer. Alright, when the installer finishes running, all we have to do now is install one more thing. So you'll see over here, there's a checkbox that says run our idk install, you want to make sure this is checked. And I'm just going to click Finish. So this should actually open up another window here, it just says Ruby installer too. And you'll see over here that there's three options. So the first one says ms y s to base installation. Second one says system update. And then here it says ms wise to mA n GW development toolchain. Just for the purposes of being thorough, we're going to go ahead and install MSI as to and the m i n GW development tool chain. And I found doing this, it's best to just enter all these options in order. Sometimes when you enter just three, then you get an error because certain things aren't updated. So I'm going to go ahead and enter in one and then after that's done two and then three. And if we do that, then everything should be able to be downloaded correctly. So I'm just going to click one and we'll go ahead and run this. When that's done running, then we can just click to and we'll run that. And this is going to go ahead and update everything that we just installed. And finally, I just want to click this third option. So I'm going to type in three, and we'll run that. Alright, once you've run all three of those installers, then we're officially done with installing Ruby on our computer. The last thing I want to do is just check to make sure that everything got installed correctly. So I'm going to go down here, and inside of my search bar, I'm just going to type in cmd. So I'm just going to type cmd. And this option for the command prompt should come up. So you just want to click that. The command prompt is basically just a way that we can interact with the computer by giving it text commands. And we can go inside here to check to see what version of Ruby we have installed. So essentially, what I want to do is just type in Ruby hyphen, V. And when I click enter, this should tell me the version of Ruby that I currently have on my computer. As long as you're getting a version with the Ruby hyphen v command, then you have Ruby installed on your computer, and you're ready to start writing some awesome programs. And this tutorial, I'm going to talk to you about installing Ruby on OSX. Now one of the great things about OSX is it actually comes pre installed with Ruby. So basically you don't actually need to install it, you should just already have it. But I just wanted to talk about in this video, like how we can check to make sure that we have Ruby. And then I'll also talk a little bit about updating the version of Ruby that you have on your computer. So, first thing I want to do is come up here to the search bar. And I'm just going to type in Terminal. And basically, this will open up the terminal. The terminal is essentially just a program that allows us to interact with the computer by using text commands. So inside of the terminal, I just want to check to make sure that everything is installed with Ruby. So I'm just going to type out Ruby hyphen, V. And this should spit out a version number of Ruby. In my case, I have Ruby version 2.4. Point two. So as long as you're getting a Ruby version number that's getting printed out onto the screen, then you're good to go. And for the most part, if you're running OSX, you should have some version of Ruby installed on your computer. If you'd like to update this version, though, for example, if you have maybe an outdated version of Ruby, I would recommend using a program called the Ruby version manager. I'm not going to get too into using the Ruby version manager here. But I just wanted to bring it up so that if you are running an outdated version of Ruby, then you'll know kind of what to look for in order to update it. So something called the Ruby version manager and it's basically a program that you can use to update the current version of Ruby that you have on your computer. So if you're trying to update your current version of Ruby, then use the Ruby version manager. But otherwise, you can basically just use whatever Ruby version that you have installed on OSX in order to follow along with this course. In this tutorial, I'm going to talk to you guys about getting a text editor for Ruby. And then we're also going to look at how we can write our first Ruby program and run our Ruby programs from the text editor that we download. And one of the cool things about Ruby is you can basically write Ruby code in any text editor you want. So you can use something simple like Notepad or TextEdit. Or you could use like a dedicated environment that was built just for writing Ruby. In our purposes. For this course, I'm going to be using a special text editor called Adam. And this is basically a text editor. But it's been designed to support Ruby. And so it's going to be an awesome environment where we can write our Ruby code. So I'm going to show you guys how to install Adam, we're going to talk about setting it up and getting it ready to go. But just a quick disclaimer, like you don't have to use Adam, if you don't want, that's what I'm gonna be using for this course. But like I said, you can basically use any text editor that you want to write your Ruby programs. So let's go ahead and install Adam, I'm going to come down here to my web browser. And up here in the URL bar, I just want to type in atom.io. And this is the official website for the atom text editor. What this should do is it should bring you to a page for your operating system. So in my case, I'm on a Mac, so it gives me this download for Mac option. If you're on a Windows machine, then it'll give you a download for Windows option. I'm just going to click this and we'll go ahead and download Adam. When Adam has finished downloading, I'm just going to go into my downloads folder. And I'll just go ahead and double click on this Adam Mac dot zip file. And if you're on Windows, you might have to go through an installer process. If you're on Mac though, now you basically have Adam over here. So you just move it into your Applications folder, and you'll be able to start using it. So I already have Adam installed on my computer. So I'm going to go ahead and open it up. And once we have Adam open, there's a bunch of different stuff that we can do. One thing you might want to do when you first get into atom is go down here into preferences or settings. And over here, you can configure a bunch of stuff. So you'll see over here on the side, we have an option for like editor, you can also configure like a theme. So you know you can change like what the text editor is going to look like. You can do a bunch of stuff over here just to kind of configure out them to your liking. In order to be running Ruby programs on here, we're actually going to have to install one thing, which is a package. So over here on the Settings page, I'm just going to go over here to this install button. And inside of here, we want to search for a program it's just going to be called Adam hyphen runner. And essentially what this plugin is going to allow us to do is it's going to allow us to run our Ruby scripts or our Ruby programs from inside atom, it's going to make it really easy for us to do this. So you'll see right here, it's just atom runner, and I've actually already installed it, but over here there should be an install button just like you see down here. So click the Install button on atom runner. And once that's installed, then we have everything we need to start programming Ruby from inside here. So now that we have Adam runner installed, I'm going to show you guys how to set up your first Ruby file. So the first thing I'm going to do is come over here to file I'm actually going to add a project folder. So I'm just gonna click Add project folder. And I'm just going to add my Documents folder because this is a folder that I'm going to be working with throughout the course. And I'll just click open, you'll see over here, now we have this little like file explorer window. So that can actually be pretty useful just so we can see like, what the different files are that we're working with. So inside this Documents folder, I'm actually just going to click right click, and I'm going to say new file. And I'm going to go ahead and create a new file. And I'm just going to call this file draft.rb. So whenever we're creating a Ruby file, we want to use this.rb extension. And that's basically going to tell our computer that this is going to be a Ruby program. And you can name it whatever you want. I'm just naming it draft. So I'm gonna click Enter. And now we have our first Ruby file up and running. So what I want to do now is just write a simple line of Ruby code inside of here, we'll test it out, we'll make sure everything's working. And that way we know we have our environment set up to go for the rest of the course. So over here, I'm just going to type print. And I'm going to type an open and closed quotation marks. And I'm just going to type hello world. And I'm just going to go ahead and save that. So just print this out. And basically what this does is it just prints a line of text out onto the screen. So now what we want to do is use that atom runner plugin. So remember, we installed that atom runner plugin before. And now I can actually use that to execute this Ruby code. So I'm just going to click Ctrl N r, so Ctrl R, and you'll see this is going to go ahead and run our program. So down here at the bottom of the screen, I actually have this little output window. And you'll see down here that it's printed out hello world. So it's gone ahead and printed out hello world onto the screen. So as long as that's working as long as the ctrl r was able to run that atom runner package, and were able to execute the Ruby code, then everything set up, we're ready to start going in this course and ready to start writing some awesome Ruby code. In this tutorial, I'm going to talk to you guys about the basics of Ruby programs. So we're going to write a very simple Ruby program, we're going to talk about how those programs get executed the order in which the instructions in those programs get executed. We're also going to talk about different ways that we can print things out onto the screen, this is going to be a pretty awesome tutorial, I'm really excited. First thing I want to show you guys is how to print something out onto the screen. So you'll notice over here I have my little atom runner output window. And in the last tutorial, we talked about setting up this basic environment. So what I want to do is show you guys how to print something out onto this little console window over here. So all we have to do to print something out is just type print a space. And then if you want to print out like plain text, we can just make an open and close quotation marks. And we can put any text we want. So I could put like draft Academy here. And now what I run this program by clicking Ctrl R, you'll see that draft Academy gets printed out onto the screen over here. There's also another way that we can print something out onto the screen. So in addition to just saying print, I can also say puts and puts basically works the same way as print, it's going to take whatever we put inside of these quotation marks, and it's going to print it out onto the screen. So for example, I can type my name like Mike. And now this is going to get printed out onto the screen over here. Now you'll notice that draft Academy and Mike are getting printed out right next to each other. And this actually brings me to the first thing I want to talk about, which is the difference between print and puts. So you'll notice here I'm using this print command, I'm printing out draft Academy. And then right below it, I'm printing out Mike using this puts command. And when I use this print command, Mike just gets printed out right next to draft Academy, as you can see over here. But if I was to take this puts command and move it up here right above draft Academy, so now the program is going to execute puts Mike before it executes draft Academy, what you'll notice is that draft Academy gets printed out on a new line. That's because whenever you use this puts command, it's going to print out whatever you put over here. And it's also going to print out a new line afterwards, which basically means that when you use puts, you can print things out on different lines. When you use print however, everything gets printed out on the same line. So if I wanted to print out two things right next to each other, for example, I could print out something over here like is cool. Now these are going to get printed out right next to each other. So you can see it says draft Academy is cool. But if I was to do the same thing with puts, for example, if I did another puts down here and I said is cool. Because I'm using this puts up here, this is actually going to get printed out onto a new line. So you'll see down here that's exactly what happened. So That's the two different ways that we can print something out onto the screen using prints and using puts, again, puts will print out whatever you specify. And then it'll print out a new line, print will just print out whatever you specify no new line. So that's the basic difference between those two. So now what I want to do is just to show you how we can use these print statements to draw a little shape out onto the screen. So over here, I'm just going to say puts, and I'm going to make an open and close quotation mark. And I'm actually going to copy this a couple times. So we'll paste this like a few times down below here, I want to show you guys how we can just draw a basic like triangle shape. So I'm going to start with a forward slash down here. And I'll make another forward slash, another one up here. And another one there. And now I'm just going to make vertical bars going all the way down. And I'm going to make some underscores down here. And now we have a basic little triangle right here. So you can see I'm using this put statement. And individually on each one of these lines, I'm printing out some text. So now if I was to go over here and run my program, you'll notice that we're printing out this triangle. And it looks pretty good. So this is sort of the basics of drawing something out onto the screen, I also want to talk to you guys about how these programs get executed. So when we run our Ruby program or our Ruby script, basically what happens is Ruby is going to go through, and it's going to look at each line individually inside of this script, it's going to start with the first line here. So it's gonna say, Okay, the first instruction that the user wants me to do is print this line of text out onto the screen. So Ruby is going to look at this first instruction, it's going to execute it. And then once it's done with this instruction, it's going to move on to the next instruction that's moving on to the next line. And it's going to go ahead and execute this instruction. And then when it's done with this one, it's going to move on to the next line and the next line, etc. So Ruby is looking through each instruction that we give it inside of our program. And an instruction in Ruby is just something like this, it's like this puts or that print that we saw before, there's tons of these different instructions that we can give Ruby. But the point is, is that Ruby is going to execute them in the order that we write them. So Ruby is going to start with this line move on to this line, etc. So if I was to take this bottom line here, and move it up here to the top, now it's going to execute this line of code first. So you'll see over here, we get this like funky looking shape. So that's sort of like the bare basics of how Ruby is working, we're giving it sets of instructions, right, I'm just writing out a bunch of different instructions, and Ruby's going to execute them in order. And it's going to do essentially whatever we tell it to do. So right now all we're doing is telling Ruby to print something out onto the screen. But as we learn more about Ruby, and as we go forward, and we learn more instructions that we can give it, we can actually make programs to do just about anything. So as long as you can specify specific enough instructions for the computer, you can do anything inside of a programming language. And that's kind of like the core concept that I want to give you today, which is how these programs are structured and how to write essentially a basic program that prints a shape out onto the screen. In this tutorial, I want to talk to you guys about using variables in Ruby. Now in Ruby, you're going to be dealing with a lot of different data. And generally anytime you run a program, there's going to be all sorts of data that you want to maintain and manage. And a lot of times when you're dealing with large amounts of data, it can be difficult to manage, it can be difficult to keep track of it. So in Ruby, we have a special container, where we can store data values called a variable, and a variable those pretty awesome because we can actually take a piece of data or a piece of information in our Ruby programs, we can store it inside of a variable. And then whenever we want to use that piece of data or access it or modify it, we can just refer to its variable container. And you'll see in this tutorial why variables can be really useful. So let's go ahead and jump in down here I have a basic Ruby program written out. Essentially all it does is it prints out a story it says There once was a man named George, he was 70 years old. He really liked the name George, but didn't like being 70. And you'll see I'm just using this puts instruction over here. And here. It's just printing out the story onto the screen. So we're essentially just printing out everything that's over here onto the screen over here. So this is a pretty awesome program, right? It works. It's completely valid. But let's say that I wanted to go inside of my little story here and start modifying some of the information right, let's say that I wanted to change the character's name. So maybe I don't like the name George and I want to change his name to john. So I'm gonna have to go through and I found that first place where the character's name was and I'm the keeps her Through and then Okay, here's another place where we have the characters name. So I'm gonna change it. So now I've officially changed the character's name in the story. Let's say that I'm reading over the story again, and I'm thinking to myself, Hmm, I think we can make the character a little bit younger. So instead of 70, why don't we make him 35? Right. So again, I'm gonna have to look through this entire program. Alright, found the first 70. So I'll change this to 35, I have to keep looking through. And okay, here's the other 70. So we'll change this to 35. Alright, so now updated the name and the age. But here's the problem. What I wanted to change the character's name and the character's age, I had to manually go into my program into the story, and modify each value. So every place where the character's name was mentioned, I had to update it to the new name, every place where the character's age was mentioned, I had to go in and update it. And this is kind of a problem, right? This is a situation where we have two pieces of data, the character's name and the character's age. And we're trying to keep track of that information, right. But imagine that instead of just having a story, that was four lines, I had a story that was hundreds of lines long, right, and they mentioned the character's name, you know, hundreds of times, if I wanted to then go through and change my character's name and my story, it would be a real drag, right, I would have to look through hundreds of lines of code. In order to do that same goes for the age. And this is actually where variables come in. So this is a perfect example of a time where we have two pieces of information the name and age, and we want to be able to keep track of them and maintain them a lot better than we currently are. So what I can actually do is I can create a container, and I can put the character's name inside of its own container, I can put the character's age inside of its own container. And then when I want to access that information and use it, I can just access that container. And that container is called a variable. So I'm going to show you guys how we can use variables to seriously increase the usability of this program. So up here, up above these puts lines, I'm actually going to create a variable. And whenever we create a variable, we need to give Ruby some information. The first piece of information we need to give Ruby is the name of the variable that we want to create. So generally, when we create a container to put information in inside of our programs, we'd like to give it a descriptive name, right? Generally, you want to give the container, a name that will identify what information is inside of it. So the first thing I'm going to go do over here is type in the name of the variable that I want to create. So I'm going to create one called character name. And generally in Ruby, if you're creating a variable, you want to give it a descriptive name. And if there's going to be multiple words like character name, you want to separate them with an underscore. So the next thing I have to do is tell Ruby what I want to store inside of this variable. So I can just say character name, and I can use this equal sign, and I can set it equal to a value. So I can say character name equals, and I'm just gonna say, john, because this is going to be the new characters name. So now I've officially created a variable called the character name, the next thing we can do is create another variable to store the character's age. So I'm going to do the same thing, I'm just gonna say, character age. And I'm going to set this equal to 35. So now we have two variables, both of which are storing values. So down here in my program, what I can actually do, instead of just typing out the character's name like this, you know, manually, I can actually just refer to the variable that is storing the characters name. So over here, instead of saying There once was a man named john, I can actually just get rid of this. And outside of these quotation marks, I'm actually going to make a plus sign. And now I'm going to type out the name of the variable that I want to put in here. So I'm just gonna say, character underscore name, essentially, what I'm doing is I'm saying I want to type out all of this text over here, plus, I want to type out the value that's inside of the characters name. So I want to print out the value that's inside this character name variable. There's one more thing we have to do anytime you're using a string of text like this, and you're also using a variable name, you need to surround this whole thing with parentheses. So I'm going to put a parentheses over there. And I'm going to put a parentheses over here. So now, we'll actually be able to use this program. So let's go ahead and we're going to run this program. And now you'll see that over here, it still says There once was a man named john, he was 35 years old, etc. But you'll notice that we didn't have to manually print like type out the word john. All we had to do was refer to the actual variable name, character name. So I just refer to this variable and it was a Able to insert the value that was stored inside that variable inside of our print statement. So I can basically do this same thing for this guy down here. So I'm just going to copy this. And I'm going to paste this in down here. So now I'm adding in the character name where john was in that other spot. So over here, we're also going to have to put another parentheses. And I'm going to do the same thing for the characters age. So over here, once again, we'll just surround this with parentheses. And now I'm just going to close off both of these. So I have two separate little strings of text inside of quotation marks. And I'm going to put a plus sign, I'm going to type in the variable name, character age. And then I'm going to put another plus sign. Essentially, what I'm doing is I'm telling Ruby that I want to print this out, plus, I want to print out the value inside of the character age variable. Plus, I want to print this out over here. So that's essentially what this is doing. And we can do the same thing down here. So and again, we're going to need to surround this with parentheses. So once we've done this, now we've actually set up our program to use all of these variables. So every place where we mentioned the characters age, we replaced it with the character age variable, every place where we mentioned the character's name, we replaced it with the character name variable. So when I run this program, now, you'll see over here, we get exactly the same output as we did before, we're printing out the same exact story, the only differences now that we're using variables, our program is a lot better. So for example, if I wanted to change the characters name inside of my story, instead of having to go through and manually change it in every single spot where we mentioned it, I can actually come up here and just modify it. So I could change the characters named Mike. And now, without having to modify anything else in my entire program, the characters name is going to be updated to Mike. So you can see now it's using the name, Mike. And that's really why variables are powerful, because they allow us to organize and they allow us to keep track of the information and the data inside of our programs a lot better, the other thing you can do is you can actually modify the value of variables. So let's say halfway through my story, I wanted the character's name to change, I can actually come down here, and I'm just going to put this line of code right after these first two and right before the second two, I can change the value of a variable. So I can say, character name, and I can just set it equal to something else. So I can set it equal to Tom, for example. So now when I go and run my program, you'll see that halfway through the story, the character's name changes. So over here, it's Mike, and then halfway through, it changes to Tom. So you can update and modify the values of these variables throughout your program. And that can be extremely useful. So that's sort of the basics of variables. And these can be really useful, there's a lot more that we can talk about. So for example, over here, I'm just storing text information, right, I'm storing like, the text Mike, I'm storing the text 35. Down here, we're using all this text. But in Ruby, we can actually represent we can store a bunch of different types of data inside of our variables. And that's what I'm going to be talking about. In the next tutorial, we're going to be talking about data types. So there's all different types of data types, we can store like text, data, numbers, true false values, a bunch of different stuff. So stick around for the next tutorial, and we'll talk about that. In this tutorial, I want to talk to you about data types in Ruby. But data type is essentially a type of data that we can represent and use inside of our Ruby programs. And by default, Ruby is going to support a bunch of different data types. So these are basically just types of information that we can use in our programs. And I want to talk to you guys about the different types of data that we can use. And we're going to look at how we can store those different types of data inside of variables. So down here, I'm actually going to create a couple of different variables. And we're going to store some different types of information inside of those variables. And the first and probably most basic type of data that we can represent in our Ruby programs is called a string. And a string is basically just plain text. So anytime we want to represent plain text, in our Ruby programs, we can use a string, so I could just make a string called like name, and I could set it equal to Mike. So this is a good example of a string. It's basically a variable, and we're storing a string value inside of it. So the string is just like any plain text, right? You could also make another one occupation and we can set it equal to like programmer, whatever you can store any like information that you'd want to store as plain text inside of your programs as a string. We could also store numbers so for example, I could store a whole number Like if I wanted to specify someone's age, I could say age is like 75. Right. So someone might be 75 years old, we can represent numbers like this inside of our Ruby programs. And you'll notice that with a number, I didn't need to use these quotation marks, I just had to type out the number that I wanted to type out. You can also use decimal numbers. So this right here, 75 is what will be referred to as an integer. And an integer is basically just a counting number like 234567. Basically a number like a whole number. A decimal number is different because a decimal has decimal points after it. And a lot of times, especially in Ruby, more referred to these numbers as floating point numbers, basically just means that their decimal numbers, so if I wanted to specify a floating point number, I could say like GPA, and we can set it equal to like 3.2. Or you can set it equal to 3.2854, or whatever, like you can set it equal to, you know, whatever decimal point you want to represent inside of Ruby. So using integers and using floats, you can represent different types of numbers, you can also make these negative, so I can make this like a negative 75, or a negative 3.2. And Ruby is going to be just fine with that. In addition to storing numbers, we can also store something called a Boolean. And a Boolean is basically a true or false data type. So a lot of times in programs, we're going to want to represent true or false data. And this might not be something that you're super used to doing in the real world. But in programming, when we're specifying types of data, a lot of data is going to fall into like the true or false category. For example, if I created a variable called is male, this variable can tell us whether or not someone is a male, in which case it's going to be like a true or false value, right? They're either a male, or they're not, it only has two possible values. So I can set this equal to true because I'm a guy, you can also create one, you know, it can be like is tall, and this Boolean variable would tell us whether or not someone's tall, right, so if you're not tall that it would be false. So a lot of information in our programs can be represented with one of two values either true or false, we can also store one more type of information, which is called nil. And the nil data type basically means that it doesn't have a value. So for example, if I created a variable called like flaws, and I set it equal to nil, basically, what this means is this flaws variable doesn't have a value. So we can go out of our way to say that something is nil, like to say that it has no value. So these are the basic data types in Ruby. And there's actually like a couple other like more obscure data types that we can use. But for the most part, these are the data types that you're going to be using as a beginner to the Ruby programming language. So we can store and represent information in either a text form with a string number form with an integer, which is a whole number, or a floating point number, which is like a decimal number. Or we can use true or false values. And we can also use nil, which would mean no value. So these are sort of the basics. And as we go forward in this Ruby course, we're gonna be looking at all sorts of ways that we can work with this type of data. And this tutorial, I want to talk to you guys about working with strings in Ruby. Now strings are one of the most common data types in Ruby. And for good reason. A lot of times in our programs, we're going to want to represent and store and work with plain text data. That's essentially what a string is. So in this tutorial, I want to walk you guys through the basics of using strings, we're going to look at some different things we can do as strings, we're going to also look at different things called methods which we can use on string. So a method is essentially just a little block of code that we can call and it will either modify our string or give us information about our string, so can be pretty awesome. First thing I want to do is just show you guys basically how to print out a string so I could say puts, and over here, to create my string, I just have to put it inside of open and closed quotation marks. So anything I put inside these quotation marks is going to be considered a string. So I could just type out like draft Academy. And now this is going to get printed out over here onto the screen works pretty well. There's a couple things we can do inside of these strings. So one thing you might be wondering is how can I print out a quotation mark. So for example, this string is surrounded by quotation marks, we use the quotation marks to tell Ruby where the string starts and ends. But what if I wanted to use quotation marks inside of this string? If I just tried to put one right here, you'll see that it messes everything up and ends the string. In order to use a quotation mark, I can put a backslash, and then put the quotation mark and this is basically going to tell Ruby, hey, I want to literally enter in the character quotation mark. I don't want to use it to end off my string. So now I should be able to print this out. Over here, you'll see we're printing out a quotation mark. You can also use something similar to print out a new line. So let's say that I want To print out and draft, and then on a new line print out Academy, I can type a backslash n. And I'm actually going to get rid of this space. And now you'll see that this is going to print out draft Academy on two separate lines. So that can be pretty useful. Another thing we can do is we can store strings inside of variables. So if I didn't want to just type this out like this, I could put it inside of a variable inside of a container. And it'll be a little bit easier for me to work with. So why don't we create a variable called phrase, and I'm just going to set it equal to draft Academy. Now, if we wanted to print this out, all I have to do is come down here and just type in the name of the variable that I want to print out. So now we'll just be printing out phrase. And you'll see we're still printing out draft Academy. So using these variables can be pretty useful. And when we're working with strings, we can actually use things called string methods, or sometimes you'll hear people refer to them as string functions. Essentially, what these are little blocks of code. And we can call these blocks of code. And they'll go off and they'll either modify our strings will change it in some way, shape, or form. Or they'll give us information about our strings, these can be really useful. And there's just a few that I want to show you. And you'll kind of get the hang of how to use these. Whenever we are going to use one of these methods, we just want to type out either the name of the variable that storing the string, or just the string itself. And then I want to type out dot. And now I want to type in the name of the method or function that we want to access. So I'm going to show you guys a couple that are pretty useful, I found them in them to be pretty useful. The first is called up case, you're just going to type up case, and then an open and closed parentheses. And actually, this open and close parentheses in a lot of situations is going to be optional. But I'm just going to include it just to be super correct. So when I type phrase.up case, and we run this program, you'll see now it takes our string, it takes our phrase, and converts it entirely into uppercase letters, you can also use another one called down case. So instead of saying upper case, we'll just say down case, and this is going to convert it down to all lowercase letters. So this can be a pretty useful little function, there's also another one called strip. So if I had a string that had a bunch of leading and trailing spaces, right, I wouldn't necessarily want to just print this out. So if I print this out onto my screen, you'll see that we get it printed out all weird, right? There's these, you know, spaces in front, there's these spaces after, you can use a method called strips, I'm just going to type out phrase dot strip. And now when I run my program, all of that leading and trailing whitespace gets deleted. So a lot of cases when you're dealing with a variable, you might not know if it has leading and trailing whitespace. So you can use this strip method to make sure that all that disappears, we can also use these methods to find out information about our strings. For example, instead of saying strip, I could say phrase dot length, and this is going to tell me how many characters are inside of this string. So you see over here, we get 24. And actually, let me get rid of all this whitespace. So now we should get a smaller number 15. So draft Academy has 15 characters in it, that's including any of the spaces that we put inside of it. In addition to figuring out how many characters are in a string, I can also figure out if certain text shows up in my strings. So for example, I could say phrase dot include. So I'm gonna say include, and now I'm going to type a question mark. And then I'm going to type a space. And now I'm going to type a string, I'm going to type another string. Basically, what we're saying is, we're asking this include method whether or not this phrase includes the string that we're going to put over here. So for example, if I put Academy right here, this is going to return a true or a false value, telling us whether or not the word Academy shows up inside of our phrase. So over here, we should get a true value because Academy does show up. If I was to type out like academies, though. So for example, this isn't inside of our phrase, it's gonna give me a false value. So that's a really good way to figure out if a certain string or a certain phrase, or a certain character shows up in the string that you're working with, we can also access individual characters inside of these strings. So for example, let's say that I wanted to just figure out what the first character in the string was. So maybe I was just given this variable phrase, and I don't know what's inside of it. And I want to figure out what the first character is, I can type out the string and then I can make an open and closed square bracket. And inside of the square brackets, I can put the index of the character that I want to access. So if I wanted to access this G, I can actually put a zero inside of here. So now you'll see this is just going to print out that G. If I wanted to access this I, I could put a one in here. And this is going to print out the I if I wanted to access this a for example I can it was going to be 0123. So I'm going to put a three in here and now we'll be able to access that a so if you haven't caught on Already, the way that we assign index positions to strings in Ruby is starting with zero. So if I was going to give these characters index positions, I would say that g is an index position zero is an index position one, r two, a three, f four other f5, e6, etc. So whenever we want to access the first character in a string, we have to access it using index position zero. And this is kind of like a staple of using strings in Ruby, the first character is always at index position zero. So essentially, Ruby starts counting at zero. So anytime we want to use this little method right here, where we're just passing in a number, you always want to start with zero as the first character. So let's do a little experiment. Let's say I wanted to access this capital A, it's going to be 012345678. So I put an eight in here, now we're going to print out that capital A. So play around with these different string indexes. You know, this is obviously not super difficult to understand. But you want to get used to starting indexes at zero as you start programming, you can also print out a range of characters. So let's say I wanted to figure out what the first three characters inside of this string where I can say zero, I can type a comma. And I can basically specify a range. So I can say I want to print out or I want to get access to the characters from position index position zero up to another index position. So we can say zero, let's say we want the first three, I can say zero, up to 0123. And this is actually going to give me the first three characters, so it's going to give me 01. And two, and it's actually not going to give me that third index position character, so I should just get g IR here, you can see that's exactly what we get. So when we specify a range down here, we start the range at the first index position zero, and we end it at three, but we don't include the character at index position three, so we didn't include this a. So that's basically how we can grab like characters in a specific range inside of the string, you can also use another method, and I'm just gonna type phrase dot index. And basically what this is going to do is it's going to tell us what position a specific character in our string starts at. So for example, I could say phrase dot index, and I can type in like a capital G. And this should give me a zero, because zero is where our capital G is at, if I typed in like a capital A here, this should give me the index position where capital H shows up inside of our string. So it's going to be an eight, you can also type in just a normal string here. So I could say, like FFP. And this will tell me where FFP starts inside of my string. And it starts at index position four, so 01234, this index method is actually pretty useful. So these string methods can be extremely useful when you're working with strings. And they basically just allow you to take your strings, and you can either modify them, or you can find out different information about them. And these are going to be very useful. Also just want to point out that you can use these little methods on things other than just variables. So for example, if I came down here, I could print out like a string. And I could say dot, and now I can say like uppercase, and it's still gonna work exactly like it worked when we use it on that variable. So now when I run this, it'll do exactly the same thing. So you don't have to have these inside of variables in order to use these different methods. So those are just a couple of the different methods that you can use with strings in Ruby, what I would recommend is going on Google and just typing in like Ruby string methods. And then there should be like, huge list of all the different methods that you can use with these strings. But I would say for the most part, those are some of the most common methods that you're going to be seeing. And really, I just wanted to give you guys an introduction into how we can work with strings inside of our programs, we're going to talk about how we can use different methods to do different things. Hopefully, you learned something, and hopefully now you can go off and start playing around with strings inside of your programs. In this tutorial, I want to talk to you about working with numbers in Ruby. So we're going to take a deep dive, we're going to look at all the different things you can do with numbers. We're talking about the different types of numbers in Ruby, and we're gonna look at some awesome Ruby methods that we can use on our numbers to do a bunch of different stuff. So this is gonna be a pretty cool tutorial. But down here, I'm just going to show you guys the basics of working with numbers, I can just say like puts in this, we'll just print something onto the screen just so we can kind of see what's going on. When I want to use a number in Ruby, it's really easy. You just type out the number so I can type out like five for example. And now this is going to get printed out onto the screen as five. In addition to just using whole numbers like this, we can also use decimal numbers so I can see like 5.86543 it's going to do exactly the same thing. So now over here, it'll be able to print that out. We can also use negative numbers so I can put a negative in front of here and again, right He's going to have no problem dealing with negative numbers. And it isn't just using numbers though, we can also use basic arithmetic. So for example, I can say like five plus nine, and this will actually be able to go through and print out the answer. So not only is Ruby going to print out five plus nine, it's actually going to do that calculation for us and print the answer out onto the screen, which is pretty cool. So we can use addition, we could use subtraction, we could use multiplication, which is just this Asterix, we could use division. So those are like the four basic types of resin of arithmetic, but we can also use exponential. So for example, let's say I wanted to take two rays to like the third power, I can just do something like this, I can say two, multiplication multiplications, so two Asterix is and then three. And this is basically going to be the same thing as saying two raised to the third power. So now we should get two cubed, which is eight. So it's going to be a really handy operation here, we can also use something else, which is called the modulus operator. So I could say, for example, 10, a percent sign and then three. And what this is going to do is it's going to take 10, it's going to divide it by three, and it's going to spit out the remainder. So 10 divided by three is three, right 369 with a remainder of one. So when I run this, you'll see it prints out a one. So it's basically printing out the remainder that we get from dividing these two numbers. And that can be pretty useful. In addition to just having numbers over here like this, I can also store numbers inside of a variable. So I can come over here and say like, num, this is the name of a variable, and we can set it equal to like 20. And then down here, if I wanted to access that number, I can just print out the variable. So now we're printing out the actual variable. And I want to point out, one cool thing with numbers is you can actually print out numbers and strings inside of the same print statement. So for example, I can say like, my fav num, and over here, I can put a plus sign. And what this is basically going to allow me to do is print out this string alongside this number. But you'll see over here, when I actually print this out, we're going to get a couple errors. And the first thing we have to do is we always want to put this inside of parentheses. So I'm going to surround this whole thing with parentheses, that's because we're referring to this variable. But also, if I want to print out a number alongside of a string, I actually have to convert this number into a string. And I can do that by saying num.to underscore s. And basically, what this is going to do is it's going to take this number, it's going to convert it into a string. And then we'll be able to print both of these side by sides, you can see now it just says my fav num 20. That's a really useful way to do something like that. So in addition to just working with normal numbers, we can actually use special things called methods. The method is essentially just a block of code that we can call, which will either modify our number or it'll give us information about a number. Sometimes it'll also do like mathematical calculations on the number. So now here, I can say like put num, when I want to access one of these number methods, I can say dot and then I can type out the name of the method that I want to use. So for example, I can say num dot abs, and an open and close parentheses. And basically what this is going to do is it's going to tell me the absolute value of num. So if I put like a negative 20, up here, now this is just going to return 20. Because it's giving me the absolute value. There's also some methods that we can use with decimal numbers. So for example, if this was like 20.487, I can use num dot round. And this will actually round the number for me. So over here, you'll see we just get 20. So it's basically rounded the number but if I was to make this like a six, now we should get 21. So it's rounding it up or down, you'd also use a ceiling and a floor function. So a ceiling will always take the higher number and the floor will always take the lower number. So for example, if I said 20.18 cetera, let's just say 20.1. And I said num dot c i L, this is actually just going to return 21. So it's going to give us the highest number, or it's going to give us the next highest number from 20. If I was to say like 20.9, and I said num dot floor, this is just going to give me 20. So it's basically just gonna cut off that decimal point, give me the lower number, in addition to just using these normal methods, or you also hear these referred to sometimes as functions. So in addition to using these methods or functions, we can also use other special methods which are inside of something called the math class. And don't worry too much about what a class is. But essentially, there's this entity inside of our Ruby programs called math. And we can use it to perform specific math operations on numbers. So if I came over here, I could type out math like that with a capital M, I can type a dot, and now inside of this math class, and again, don't worry too much about what a class is. But inside of this math entity in Ruby, there's a bunch of these methods that we can use. So for example, I could say math dot Sq RT and open and close parentheses. Now inside of this open close parentheses, I can give this a number. So for example, I could put like 36 inside of here. And what this is going to do is it's going to give us the square root of this number 36. As you can see, over here, we get six, you could also use something like the logarithmic function. So I could say math dot log, put like a one in here. And now we're going to get 0.0 back. So there's a lot of these different like math operations, you can do a lot of things with like sine, cosine, tangent, like logarithmic stuff. So this can be really useful if you're just trying to work with math inside of Ruby. So the last thing I want to talk to you guys about in this tutorial is working with floating point numbers and working with integer numbers. So there's two basic types of numbers in Ruby, we have integer numbers, which are like whole numbers. So an integer would be like 20, or 21, or 22. We also have decimal numbers, which would be like 22.1 22.2, etc. integers and floats can be used inside of Ruby, basically interchangeably, although there are two, like separate types. So Ruby does distinguish between a whole number and a floating point number, but I want to show you guys how we can use these together. So for example, like if I came down here, and I just added two integers, like I added one plus seven, you'll notice that we're going to get an integer back, so it's going to be eight. But if I added like 1.0, and seven, now you'll see we're getting a floating point number back, so we're getting a decimal back. So whenever you add two integers, you always get an integer back or multiply two integers divide, subtract two integers, you're always going to get an integer back. So for example, if I said like 10, divided by seven, this shouldn't be an integer number. This should be like some long decimal number. But you'll notice that I'm just getting a one back. So I'm only getting an integer back. But if I said like 10 divided by 7.0, now I'm going to get the full number back. So whenever you're using an integer, and a floating point number together to do some operation, you're always going to get a floating point back, if you're using two integers, you'll get an integer back. And if you're using two floats, obviously, you're going to get a floating point number back. So that's kind of the difference between those two. And Ruby doesn't really give you too much of a hassle. When you're using numbers, you know, you can basically use integers and floats interchangeably. But just know that Ruby does distinguish between the two of them. So if you're doing different types of math, with different types of numbers, like integers or floating point numbers, there's going to be a difference in the type of answer that you're going to get. So that's really the basics of working with numbers. I mean, I can spend all day talking about all the different methods and you know, little caveats here and there that you can use with numbers in Ruby. But I think that's kind of a good coverage of the basics. And so now your job is just to go off and play around with all this different stuff. And really just get comfortable working with numbers in your Ruby program. In this tutorial, I'm going to talk to you guys about getting input from users and Ruby, this is going to be awesome, basically going to allow a user to input information into our programs, we're going to store whatever they input into a variable. And then we're going to print out that variable along with a message that basically just says hi to whoever entered the information. So in order to get information from the user, we're actually going to have to do one thing. And if you've been following along with this course, we've been using this atom runner program in order to run our Ruby files. And this is a really awesome convenient way in order to just run a Ruby file. But here's the problem, if we want to get input from a user, inside of our Ruby programs, we actually can't use this little atom runner plug in to do it, we're gonna have to use something called the terminal or the command prompt. And if you're on Windows, this is a program called the command prompt. If you're on Mac, it's called the terminal. Basically, it's an environment where we can interact with our computer using text. And in order to interact with the computer and input information into our Ruby programs, we're going to have to use the terminal. So the first thing I want to do is show you guys how to set that up. And then we'll look at getting input from the user. So this is going to be instructions for doing this inside of atom over here. I'm just going to go over to the preferences inside of atom or the settings. And down here, I'm just going to click this install tab. And I want to search for a package and we're looking for a package which is called platformio hyphen ID e terminal. So search for this. And you'll see it shows up over here and I actually already have it installed, but you want to install this platformio id e terminal. Basically what this is going to allow us to do is use a terminal or a command prompt if you're on Windows straight from inside atom. So install that. And now we're just going to go back over here. You might need to restart your atom program in order to use it but eventually what you should get is a little problem. Sign You see, there's this plus sign down here at the bottom left. And when I hover over it, it says new terminal. So once you have this installed, you want to go ahead and click that. And a little terminal window should pop up down here, you'll notice mine is just black with white text. So this is where we can run our Ruby program in order to get input from a user. And this is also another way that you can run your Ruby programs. So down here, as long as you have your Ruby file open inside of atom, so as long as this file is open, when you open up platformio id terminal into a new terminal, it should automatically open up to the location where your Ruby file is. Now, you know, I'm not going to get too into like using the terminal in this tutorial. But essentially, you can navigate through the different folders and the different files inside of your computer using the terminal or the command prompt. So as long as you have your Ruby file open, like I have this draft Ruby file open, this should automatically open to the correct directory, so you won't have to worry about that. So once we're here, I just want to type in Ruby. And then I want to type in the name of the file that I want to run. So in my case, it's just draft.rb. And what this is going to do is it's going to run the file for us now when I click enter, it's going to run the file and you know, it'll basically stop, we don't have any code up here. So if I was to print out like, Hello, now when I run this, again, I can just type it in and click Enter, and you'll see that we get the program running. So that's basically how we can run a Ruby program from inside of our command line or inside of our terminal. So we're going to have to do this in order to get input from the user. Just so you guys know. Alright, so let's talk about how we can get input from the user. Basically, I'm going to allow the user to input a piece of information, we're going to store that piece of information inside of a variable, and we're going to print it out onto the screen. So first thing I want to do is actually just type out a prompt. So I want to tell the user what I want them to enter. So I can just say puts, and I'm just gonna say enter your name. And now once we've prompted them to enter some information, I can use a special command in Ruby called gets. And basically what this is going to do is it's going to allow the user to enter a piece of information into our program. So it's basically going to stop the execution of the program and wait for the user to enter something. And what I want to do is I want to store whatever the user enters inside of a variable. So I'm actually going to create a variable called name. And I'm going to set it equal to guests. And basically, what this is going to do is it's going to tell Ruby to take whatever the user inputs into the program and store it inside of this name variable. So the last thing I want to do is come down here, I'm just gonna say puts, and I'm going to print out some text, I'm going to say hello, plus name. So basically, I'm printing out hello to whoever entered in information into the program. So I'm going to save this. Now I'm going to come down here and I'm just going to run this program. So you'll notice, if you click the up arrow on your arrow keys on your keyboard, it will actually just insert the last line that you entered. So I just click the up arrow here. And now when I click enter, you'll see that it says enter your name. So I'm going to enter my name is going to be Mike. And now when I click Enter, and actually we're getting an error here, I should actually need puts down here not put, that's my bad. So let's do this again. So I'm going to enter my name, Mike. And now when I click enter, it's going to say, Hello, Mike. So it's basically just saying hi to me. So that's the basics of getting input from the user, you can use this gets in order to get specific information. Now, I do want to talk to you guys about one more thing, which is basically something that happens in Ruby when we enter information. And let me sort of illustrate this. So down here, I'm saying hello, name. And after this, why don't we print something else out. So I'll say like, you are cool. Alright, so I'm basically printing out Hello, name, you are cool. Now I'm going to go ahead and run this program and you guys will see what happens. So I'm running the program, I'm entering in my name, Mike. Now when I click enter, you'll notice that it prints out Hello, Mike, but then it prints out a new line. And it says that other text. basically what's happening here is when I click enter, Ruby is not only taking that as the text that we entered, but also as a new line. So whenever you click enter it basically like is going to insert a new line. So Ruby is essentially printing out Mike, then the newline character and then all the text over here. In order to mitigate that all I have to do is come over here and say name is equal to get dot Chomp, and an open and close parentheses. And this is going to get rid of that new line character that happens when we click enter. So now when I run my program, it's going to be able to work correctly. So I'll say enter your name Mike. And now it just says hello Mike. You are cool. So now our program is working perfectly. So you If you want to keep that new line, when the user clicks enter, you can go ahead and just not put dot chomp here. But in a lot of cases, you're going to want to go ahead and just put that in there. So that's the basics of getting input from a user. And if I wanted, I can get multiple pieces of information. So for example, I could say puts, enter your name. And I'm actually just going to copy this. And now we'll say like, enter your age. And we'll do the same thing. I'll store it in a variable called age. So now we can actually come down here and we can print out like Hello, Mike, you are. And then we could just print out like the age. So now it'll just be printing out age. So now we can get two pieces of input from the user. So let's run our program. And it says, enter your name, Mike. And let's say that I'm like 59. So now it's printing out. Hello, Mike, you are 59. So we're getting input from the user, we're getting two pieces of input from the user. And we're printing them out onto the screen. So that's the basics of getting input. And in the next couple lessons, we're going to talk about other ways that we can do this. And basically ways we can make this work a little bit better. In this tutorial, I'm going to teach you guys how to build a very basic calculator in Ruby, we're basically going to build a little program that will allow the user to enter in two numbers, and then we'll print out the sum of those two numbers. So we'll get the two numbers from the user, we'll add them together, and we'll tell them what the answer is, it's gonna be pretty cool. And it'll kind of give you guys some more information about getting input from users, specifically how we can get numbers from users. So keep in mind, In this lesson, we're going to be using the terminal or the command prompt, in order to get information from the user. So you want to make sure that either if you're using atom, you can use this platformio id terminal plugin that I talked to you guys about in the last lesson. Or you can just use your normal like terminal or your normal command prompt. So I'm going to be using this little atom plug in that I have. So let's talk about how we can get input from the user. Specifically, we need to get to numbers. So down here, in our program, we can just write out the code to do that. So I'm going to first write a prompt, I'm just going to say puts, and we're just going to type out a message for the user. So we'll say enter a number. And then we're basically going to get that number that they entered and store it inside of a variable. So I'm going to create a variable called num one. And I'm going to set it equal to gets dot chomp. And gets is basically going to get whatever information the user enters in, and chomp is going to get rid of the new line that they accidentally enter when they click the Enter buttons. So whenever you click enter in Ruby, and you're inputting information into the program, it's going to add a new line onto the end of whatever you input. So this is just going to get rid of that for us. The next thing I want to say is another prompt, so I'm gonna say puts, and I'm going to tell them to enter another number. And once again, we're going to do the same thing. So I'm just going to say num two is equal to get stop shop. So essentially, we're asking them to enter in two numbers. Now, all we want to do is just print out the result of those two numbers. So I'm going to put, and I'm going to put this inside of parentheses, and I'm going to say num one plus number two, right? Essentially, what we're doing is we're getting two numbers, and then we're printing out the sum of those two numbers onto the screen. So let's go ahead and do that. I'm going to come down here into my terminal window. And I'm just going to run this program. So I'm just going to type out Ruby draft.rb. And this is going to run the program for me. So it says down here, enter a number. So why don't we enter five, enter another number. Let's enter two. And now when I click enter, this should add the two numbers together and print out the answer. So click Enter. And you'll notice down here, we're actually getting a little bit weird of an answer, we're getting the answer 52. The last time I checked, five plus two wasn't 52. Essentially, what we're doing is we're concatenating these two strings together. So here's the problem. When you enter in information into Ruby, Ruby automatically just converts whatever you enter in into a string. So byte you can enter in as many numbers as you want, you can enter in decimal numbers, normal numbers, doesn't matter, Ruby's just going to convert it into a string. And when we add two strings together like this inside of a put statement, it just does what's called concatenating the strings, so it takes the first string and adds the other string onto the end of it, right. So that's why we get five to in order to actually add these two numbers together, we're going to have to convert the strings that the user enters into numbers. So over here we're getting a number num one here we're getting a number num two. But remember, when we actually store those variables, they're getting stored as strings. So all we have to do is take num one, convert it into a number, taking them to convert it into a number, and then we'll be able to run this program successfully. So all I have to do to do that is just say num 1.2 and underscore, and then I, so it's not 1.2 I and basically what this means is we're converting num one into an integer, I'm going to do the same thing over here dot two, I. So now we're basically taking these two strings num one and m two and converting them into integers. So Ruby is going to take whatever the numbers that were inside of those strings, and convert them into integers. So let's go ahead and run our program. So I'm gonna come down here, I'm just going to type in clear. And I'm going to type in Ruby draft.rb. So it says enter a number, we'll enter in five, enter another number, let's enter in two. Now when I click enter, you'll notice that we're getting the answer which is seven. So that's pretty awesome, right, we were able to build our calculator, and it was able to add the numbers together. Here's the problem, though. Let's say I come down here and I run this program again, and I enter in a five. But now I enter in a 2.5. So for example, instead of just entering in two, I'm entering in a decimal number 2.5. When I run this program, Now, you'll notice that we're still getting seven. So our program wasn't able to add this z, this point five on to the answer. That's because over here, we're converting these to integers. So we're saying num, one is going to get converted into an integer, num two is going to get converted into an integer. And so really, all this is doing is it's adding in the integer five, and it's adding in the integer value of 2.5, which is just going to be two together. So if I want to be able to add in decimal numbers in my program, instead of saying two I I'm going to say two F, and to AP is basically going to convert whatever is inside of those strings into floating point numbers, so into decimal numbers. So now when I run this program down here, we'll be able to do that addition. So if I say Ruby, and I'm just gonna enter in a five, and now we'll enter in that 2.5. And now they should give us the number that we wanted. So we're going to get 7.5. So two F or two I or two really useful little functions that we can use on numbers. And in some cases, you're only going to want the user to be able to enter an integer. So you can just say two I. In other cases, though, you want them to use floating points, so we can use to f. So that's the basics of building our little calculator. Now, I also want to point out one way that we can make this program a little bit easier. So instead of saying num 1.2, f down here, I could actually come up here. And I could say gets.chomp.to, F. And I can do the same for this one over here.to F. And now this is going to convert them up here, so we don't have to convert them down here. So this is going to work exactly the same as it worked before. So I can say like 5.6 and 7.2. And it'll be able to add them. So that's, there's another way that we can do that. But that's sort of how we can build a basic calculator inside of our Ruby programs. In this tutorial, I want to talk to you guys about building a Mad Libs game in Ruby. So we're gonna build a little mad libs game. And I'll kind of show you some more about how we can get input from a user. So if you're not familiar with Mad Libs, a Mad Libs is basically just a game where you would enter in like a bunch of random like words maybe like nouns, verbs, adjectives, adverbs, and then you'd take all of those words that you'd enter in and like sort of sprinkle them in inside of a story. And generally like since you're entering in random words, the story is going to be like kind of funny. So over here I have an example of a Madlib you can see down here, it's like telling the user to enter in like a noun, a plural noun, an adjective, and we're actually can build a Mad Libs game inside of our Ruby program. So down here, you'll notice I have a little basic program set up, it's basically printing out this poem. Roses are red, violets are blue. I love you. So this is, you know, kind of a classic poem, but I think we can mix it up a little bit and create a Mad Libs for this poem. So how would we say instead of Roses are red, well let the user enter in a color. Instead of saying violets are blue, we'll let them enter in a plural noun. And instead of saying I love you, why don't we let them enter in like someone else so maybe like a celebrity, instead of having just Roses are red, violets are blue I love you will have roses are and whatever the color the user enters in, whatever the plural noun they enter in, or blue, and then I love a certain celebrity. So this would be kind of funny. So let's set up our program. The first thing I want to do is get input from the user. So I want to be able to get three pieces of information from the user, I want to get the color. I want to get the plural noun and then I want to get the celebrity after we get that input. Then we'll intersperse those variables inside of this little output. So let's get the input from the user, I'm just going to come over here and we'll just print out a prompt, it'll just say, enter a color. So the first thing they'll do is enter the color. And now what we're going to do is store that in a variable called color. So I'll say color is equal to get dot chump. And remember, chomp is just getting rid of the new line that gets entered when you click the enter button. Alright, so we'll enter in a guess. And we're also going to do two more of these, I'm just going to paste this two more times. And then we're going to enter in a plural noun. And we'll make a variable called plural noun. And finally, they're going to enter in a celebrity. So we'll make a variable called celebrity. So now we have three variables that are storing the three pieces of information that the user input. last step is to come down here. And instead of just printing out color inside of curly brackets, I'm actually just going to add in that color variable. So we'll print out color, same thing for the plural noun. And same thing for the celebrity. And now our program is essentially set up, we're getting the input, and then we're just printing out the actual embed libs. So remember, whenever we get input from the user, I have to use my terminal down here. So instead of just using this little like atom runner plugin that we've been using throughout the course, I'm going to use my terminal. And down here, I'm just going to go to the directory where my Ruby file is stored. And I can just run it so I'm just gonna say Ruby draft.rb. That's the name of the file, and I'm gonna run the program. So it's going to ask me to enter a color. So why don't we enter in like magenta? says, enter a plural now and I'm going to enter in microwaves and enter a celebrity. Why don't we do like Tom Hanks. So now what should happen when I click enter is all of that information should get put inside of our Mad Libs, and we should get the finished story. So I'm gonna click Enter. And you'll see down here we get our finished story. So it just says roses are magenta, microwaves are blue. I love Tom Hanks. So basically, the user could run this program, they could enter in all the words for the Madlib. And then we'll basically just be printing out Madeline. So it's actually a pretty simple program, you can see how easy it is to build a game like a Madlib inside of Ruby, it's super easy. And also if you want and you can make this a lot more complex. So you get to have them add in like adverbs, verbs, adjectives, like all sorts of stuff inside of here make obviously the story a little bit longer. And you could essentially replicate any Madlib inside of your Ruby program, which is awesome. And this tutorial, I want to talk to you guys about using arrays in Ruby, and Ruby, we're going to be dealing with lots of information. And a lot of times when you're writing programs, there's going to be a bunch of different values that you want to store and keep track of. And one way that we can keep track of the data inside of our programs is using a simple variable. Here's the problem with the variable, though it can only really store one single value, as I can create a variable, I can store a value inside of it. But what happens when I have a lots of data, it's going to be kind of a pain in the butt to have to create like hundreds of different variables, if I want to keep track of and maintain hundreds of different pieces of information. And this is where arrays come in. An array is essentially a structure or a container, a lot like a normal variable. The only difference being that an array can hold multiple values. So unlike a normal variable, an array can hold like 10, or 20, or 100, or a million different items inside of it. And a lot of times when we're programming in Ruby, and we're dealing with large amounts of information, we're going to want to be able to use arrays. So let's jump in, I'm going to show you guys how to use arrays and talk about you know, what they are, how to create them how to put stuff inside of them all that fun stuff. So down here, if I want to create an array, I created a lot like I would a normal variable, the first thing we have to do is tell Ruby what we want that array to be called. So in my case, why don't we make an array that's going to store a bunch of names of my friends. So I can make an array called friends. And I'm going to set this equal to array with a capital A, and then we're going to make an open and closed square bracket. inside of this open and close square bracket, I can start putting in some of the pieces of data that I want to store in this array. In my case, I'm just going to store a bunch of strings with names of some of my friends. So I can store on like Kevin, Karen, and Oscar. So here we have an array that has three elements inside of it. And each one of these pieces of data are referred to as array elements. Basically what I did is I created a container that can hold multiple pieces of information. So what I can do Now is I can come down here and I can just say like, puts friends. And this is actually going to print out all of the information inside of this array, all the data values on my output over here. So you can see, we're printing out Kevin, Karen and Oscar. So that's the basics of using an array. And if I didn't want to just store strings, I can store any type of data inside here. So I can sort of strings, I can even store like a number, or I can store a boolean value like false, you can put all different types of information, all different data types, inside of these arrays. And if you want, you can even put different data types together in the same array. But for our purposes, let's just stick with strings. So let's say that I wanted to access one specific element inside of this array. Well, if I want to access just one element, I can make an open and close square brackets after I'm referring to the variable name. And I can put an index inside of here. So let's say that I wanted to grab Kevin, let's say I wanted to grab this first string inside of my array, I can put a zero inside of here, and zero refers to the index of this Kevin value. So now when I print this out, you'll see we're just printing out Kevin. And this brings me to a point about arrays, we start indexing arrays of zero. So I would say that this Kevin attribute of this Kevin element inside of the array is at index position zero. Karen is at index position one, and Oscar is at index position two, so the first element is always in index position zero, and then you just basically count up from there. So if I wanted to access Oscar over here, I could put a two inside of here. And now this is going to print out Oscar, another thing I can do is I can access array elements from the back of the array. So for example, another way I could access Oscar would be by putting a negative one in here. Basically, what this is going to do is it's going to grab the item in the array, but it'll start counting from the back. So it'll basically like this would be negative one, Oscar, this would be negative two, and this would be negative three. So if I said negative two in here, now we're going to be grabbing Karen and printing that out. So that's two different ways that we can access elements inside of the array, I can also grab a range of elements. So for example, let's say I only wanted to grab the first two elements inside this array, and I didn't want to grab the third one, I could say zero, and then I could say two. And basically, what this is going to do is it's going to grab index position zero all the way up to but not including index position two, so it's going to grab zero, and one, and it's going to stop at two, so we're not going to grab two. So now we're just going to get Kevin and Karen. And this can be really useful just specifying like a range inside of this square brackets. There's also a bunch of other stuff that we can do with these arrays. So for example, let's say I wanted to modify one of the values inside of the array, I can come down here and I can just say, friends, let's say I wanted to change this first element and exhibitions here, I could say friends, zero, and I can give it a new value. So I can say like Dwight, and now instead of having the value of Kevin, this is going to have the value of Dwight. So when we print it out, we get that new value. And you can access and modify any individual element inside the array, just by referring to its index. There's also going to be situations where you're not going to know exactly what elements you want to put inside of the array right upfront. So for example, over here, I knew exactly what friends I wanted to put in this array. But in some cases, you're not going to know that right off the bat. So we can just say array dot new. And now we're basically telling Ruby that we want friends to be an array, but that we don't want to put any values into it just yet. Then down in my program, I can just start putting stuff in here. So for example, right now, if I printed out friend zero, you'll notice that nothing prints out, it's just a nil value. Right? If I came over down here, though, I could say friends zero, and I can just give this whatever value I want. So I can give this a value of like Michael. And now friend zero is going to be Michael. And you can do that as much as you want. So I can even come down here and say like friends, five, and I can give this a value. So now this is going to be equal to Holly. And what you'll see over here, when I print out just the entire friends array, it's going to fill in all of the elements that are between zero and five, just with blank elements. So those are just going to be nil. So that's kind of how you can create an array and not give it some initial information yet, and then add in information later. There's also a bunch of different methods that we can use with these arrays. So let's go back to that array that we were using before with all the friends. So if I wanted to access specific information about this array, I can use a little method so I could say like friends dot and one really useful one is length. So this will tell me how many elements are inside of this array. So you see over here we have three I can also check to see if certain elements are inside. The array so I can say friends dot include, and I'm gonna put a question mark. And over here, I can type in an element that I would want to check to see if it's in the array. So I could say, like Karen. And now this should give us a true value because Karen is inside of the array. If I put like Karen's, though, so I changed it. Now this is going to give a false value, because that's not in the array, you can also modify the order of the array. So I can say, like friends dot reverse, and this will reverse all the elements. So now it's going to be Oscar, Karen. And then Kevin. As you can see over here, you can also sort of different elements in the array. So for example, if I wanted, I could sort all the elements. So if I were working with strings, we could sort them alphabetically. So if I put something over here, like Andy, and now Andy is going to end up being in the front, because it's going to sort the array alphabetically. So I'll say friends, that sort. And now when we print this out, you'll see Andy care and Kevin Oscar, so moved Andy to the front, because a comes before K and O. It's important to note though, that if you're going to have an array that has multiple data types, so for example, if I put a n number like an integer in here, this is going to throw an error now, because you can't sort it, there's no, there's no way for us to compare, like numbers and strings inside of Ruby. So that's the basics of working with arrays and arrays are super useful, there's going to be tons of situations where we're going to want to store large amounts of information in a single container. And arrays are great at doing that. In this tutorial, I want to talk to you guys about using hashes in Ruby. Now, a hash is basically a type of data structure where we can store a bunch of different pieces of information. If you're familiar with arrays in Ruby, they're very similar to arrays. So a hash is basically doing the same thing. It's allowing us to store multiple pieces of information. The difference is that with hashes, we can actually store something called a key value pair. And a key value pair is basically where we can store of value. And we can give it a key which is kind of like a name. Now a lot of times you'll hear hashes, also called dictionaries. And that's because they act a lot like dictionaries, picture a dictionary, like in a dictionary, you have two parts to every word, right? You have the actual word itself. But then, in addition to the word, you actually have the definition, right, so you could say that the word is the key. And the definition is the value. So that's basically what hash is. And you'll kind of see what this is, as we kind of go through this tutorial. And this tutorial, I want to build a little hash, which will store state codes. So for example, I live in the United States, and we have a bunch of different states. And each state has a specific code. So for example, Pennsylvania, PA, right, New York is NY, California is CA, Michigan is EMI, right, so you can map a state like New York to a specific abbreviation like NY, we can map California to a specific abbreviation ca. And that's basically what I want to represent inside of my hash. So we're going to build a hash, which can store all of those different abbreviations. And you'll see why these data structures are useful and how they're different from arrays. So down here, I want to create my hash. And in order to do that, you basically just have to give the hash a name. So I'm just going to call this states. And I'm going to set it equal to an open and closed curly bracket just like that. And a lot of times when people are making hashes, they'll end up putting a new line here. So inside of here, we can specify a bunch of different key value pairs. Okay, so what I want, I want the keys to be the actual state names. And I want the values to be the abbreviations for those states. So basically, all we have to do is just type out a key and then we can type out a value. So the first thing I'm going to do is type a key. So why don't we map like Pennsylvania. And so Pennsylvania is going to be the key. And now I can map this to a value. So I can just say equals and then a greater than sign. And over here, I can type in a value. So I'm just gonna type PA. Okay. So essentially, what I'm doing is I'm defining the key, and I'm defining the value. Now I'm going to type a comma. And I can go and define another key value pair. So why don't we do New York City, New York. And we're going to map this to and why. And why don't we do another one, Oregon is another state, and we'll map this to o r. So in here, I'm basically have three different states and I'm not going to do all 50 states, but I have a key and then I have a value. Now here's one thing you need to know about these hashes is you can only have unique keys. So for example, I couldn't create another key down here. called Pennsylvania, that's gonna be a big No, no, when we're creating hashes, you always want to have unique keys. Alright, so now that we have these input into here, we can actually start using this hash. So down here, if I wanted, I could just print this out. So I can come down here and say put, and it's just called states. So we can put this and when I print this out, you'll notice that we're printing out this little structure. It's just like Pennsylvania, that gets mapped to PA, New York gets mapped to NY, etc. But one of the most powerful things we can do with these hashes is we can actually give it a key, and it'll tell us the corresponding value. So I can come in here and inside of these square brackets, I can just input a key. So I get input like Oregon. And now this is going to print out the value for Oregon. So it's going to print out, or I could put inside here, New York. And now this is going to print out ny because it maps to New York. So that's like a super useful way that we can store our data, we could give this structure a key, and it would spit out the corresponding value. There's also a couple other ways that we can create these keys. So for example, instead of putting Pennsylvania inside of quotation marks, I could also just put a colon here. And now this is going to be the same thing. So down here, I could specify like Pennsylvania, and actually, this should be capital. And now it'll still give me that same value. So it'll, it'll still give me pa up here. You can also use in addition to like strings, we could also use numbers. So down here, I could say one. And if I put one down here, now we're basically going to get the same thing. So this should still print out pa and you can see that it does over there. So these hashes are extremely useful. And there's a lot of situations where you're going to want to map keys to values. So for example, in this situation, we're mapping a key, which is the state name to a value, which is the state abbreviation. But you could do the same thing for like days of the week, you could do it for a month abbreviations you could do it for I mean, really, there's a tons of situations where this type of structure is going to come in handy. And now I just want to point out how these are different from arrays. So normally, when I create an array, I'm just creating like a list of individual values, right. But when I create a hash, I'm creating a list of key value pairs. And I can give this hash a specific key, and it'll spit out the corresponding value. So this is a very useful data structure. And this is definitely something you're gonna want to play around with and get used to using. In this tutorial, I want to talk to you guys about methods in Ruby. Now, a method is basically just a block of code that we can write, which will perform a specific task for us. A lot of times in Ruby, you're gonna have different groups of code, different groupings of code, they're going to perform specific tasks, or they're going to do certain things. And what we can do in Ruby is we can take all of that code that's, you know, designed to perform one task, we can put it inside something called a method. And what's cool about methods is you can actually call them from other places inside your program. And we can give methods information, and then they can give us information back. So in this tutorial, I'm just going to talk to you guys about the basics of using methods, we're going to write a method, and we're going to look at how they can be useful. So the first thing I'm going to do is create a method. And our method is going to be very simple. all it's going to do is say hi to the user. So our method is going to perform one task and has one goal, and it's going to say hi to the user. So down here, I'm going to create my method. First thing we always want to do when we create a method is type out d f. And this basically means that we're defining a method. Second thing we want to do is give our method a name. So generally, you want to give your methods descriptive names. So it's very obvious what task they're performing. In our case, our method is saying hi to someone, so we can just call it Say hi, just like that. And now what I want to do is hit Enter, and I'm going to come down here and I'm just going to type and so essentially, what I'm doing is I'm defining a method block. And anything that's in between death and end is going to be inside of our method. A lot of times people will indent here just to show that the code is like inside the method. So in here again, we have one goal, we want to say hi, so I'm just going to type puts. And I'll just say hello, user. Cool. So now I'm going to run my program and we'll see if this method works. So I'm just going to run the program. But you'll notice over here, when I run the program, nothing's showing up. And that's because when we define a method, the code inside of the method is only going to get executed when we call it so in other words, we want to execute the code inside this method, we have to call the method, that basically just means we have to say like, Hey method, go do your stuff go perform your task. So I can come down here. And the way I call this method is just by typing out its name. So I can type out, say, hi. And now Ruby is going to execute this method up here. So you can see over here, we have Hello users. So everything's working. And I just want to show you guys one thing. So if I typed out, like, top up here, and then typed out, bottom over here, I want to show you guys the flow of these methods inside of our program. So now when I run this program, you'll see we're printing out top, hello, user. And then bottom, essentially, what's happening is, Ruby is looking at this line of code, it's executing it, then it sees, say, hi. So it knows, okay, the user wants me to execute the say, Hi, method. So Ruby is going to jump up, it's going to execute all of the code inside of this, say, Hi method. And then once it's done executing all of that code, it's going to jump down, back down here, and it's going to print out bottom. And I just want to point out, you can put as many lines of code inside of one of these methods as you want. Obviously, this is like a simple method. So we're just keeping it simple. But that's the basic execution flow of functions or methods. And actually, this brings me to a good point, a lot of times, these are called methods. But you'll also hear people calling these functions. Essentially, in the case of Ruby, these words are basically interchangeable, basically means the same thing. But for the most part in Ruby, we're referring to them as methods. Alright, so let me show you guys some more cool stuff we can do. One thing we can do is we can actually give these methods some information. So I can actually take this Say hi method. And I could actually allow the user to tell it, who to say hi to. And the way that I'm going to do that is after I type the name of the method, say hi, I'm going to make an open and close parentheses. And over here, I just want to specify what's called a parameter. And a parameter is basically a value that whoever is calling this method is going to give to it. So this method can actually accept inputs, it can accept parameters as input. So over here, I can just type out the name of the parameter I want to accept. So in our case, we'll just call this name because it's going to be the name of who we want to say hi to. And then down here, instead of saying, hello user, I can say hello, name. And you'll see in a second, this is going to use whatever variable and whatever piece of information gets passed into this method. So down here, if I want to give this a name, I can make an open and close parentheses. And in here, I could type in name. So I could say, Mike. So now when we run our program, it's going to say, Hello, Mike, essentially, what's happening is the say, Hi, method is specifying that you can give it a name. And down here, I can, when I call the method, I can give it that piece of information, you can also give these things multiple pieces of information. So I can also specify age. And then down here, we can incorporate that into our print statement. So I can say hello, name you are, and now we'll print out their age. So I can just say age. And essentially, this will take in two parameters, and it will print them both out over there. So down here, I can just specify the first parameter Mike. And then I can specify the age. So we can say like, you know, 73, or something. And now it's going to say, Hello, Mike, you are 73. And actually, you'll see we're getting an error over here. And this is actually a good little catch. So age, I'm actually passing in an integer. And whenever we want to print out an integer inside of a print statement like this with strings, we always have to say age.to underscore s. So that's why we're getting that error. And that's something that you always want to watch out for in Ruby. So now when we run our program, it says, Hello, Mike, you are 73. So that's pretty cool. We can pass this two pieces of information. But let's say that I didn't want to pass this in age, right? Maybe I didn't know how old Mike was. So I didn't want to give it an age. Well, now when we're when we run our program, you'll see that we're getting an error, right? So because I didn't include an age, when I call this, it's throwing an error. One way we can mitigate this in Ruby is we can actually give these variables default values, we can give these parameters default value. So I can come over here and say name is equal to no name. And we can just say age is equal to negative one. And essentially, what's going to happen now is if I don't include an age in here, it's just going to print out the default. So it says hello, Mike, you are negative one, right? If I wasn't including the name in here, it's just going to use both of those default values. See, let's see. I'm not passing any parameters. And now it basically just says hello, no name, you are negative one. So sometimes specifying default values can be a good way to control these methods and really, it depends so In some methods, you're going to want whoever's calling them to give you certain pieces of information. But if those pieces of information are like optional, you can just give them default values like that. So that's the basics of working with methods. And there's actually one more thing we can talk about, and I'm going to talk about it in the next video. It's something called return types. Basically, we can give the method information and the method can give us information back. But for now, this is just the basics and hope you guys learned something about methods. In this tutorial, I want to talk to you guys about using returns in Ruby methods. So in the last tutorial, we talked a lot about writing methods, we looked at how we could give methods, some information through parameters. And this is all real, I want to talk to you guys about how methods can give us information back. So when I call a method inside of my program, that method will go off, it'll execute all this code, but then it can actually give us a piece of information or in some cases, multiple pieces of information back. And that can be really useful. So for the purposes of this tutorial, I want to show you guys how we can create a cube function. So in math, when you cube a number, you essentially take it to the third power. So if I was going to cube two, it'd be like to raise to the third power. So essentially, it would just be two times two times two, right? So why don't we write a little method that's going to do that for us. So this method will cube a number, and it's going to be pretty interesting. So down here, I'm just gonna say def, and we'll say cube. And we want to pass in one number, so I'm just gonna specify that they need to pass in a num. And then down here, we're gonna say, and what's cool about these methods, they can actually give us information back. So if I was gonna cube the number, it would basically just be num times num, times num, right? So that's essentially like all we would need to do to cube the number. But what's cool is when I call this cube function, and I give it a number, so like, I give it a two, if I was to print this out, so if I said puts cube two, this is actually going to print out num times num times num. So it's actually going to print out this answer over here. So let's take a look. You'll see here, we're printing out eight, if I was to pass in like three over here, now we should get 27. So basically, what's happening is we're calling this cube method. And this cube method is giving us a value back. So when I call this, this is actually like ends up representing a value and ends up representing the value that was given back to it. And if you want to give a value back, all you have to do is basically just specify it right here. So that's a really cool way that we can use these methods to get information back. But sometimes when you're working in these programs, that might not be super clear what value you want to return. So for example, I have num times num times num here. But if I put a four down here, right below this, or even if I put like a string or whatever, let's put a five, you'll notice that now instead of returning num times num times num, this is actually going to return five. And that's because five is the last line inside of this method. It's basically like the last returnable piece of information that's inside of this method. So in situations like this, you can actually use what's called the return work keyword. So I can say return right before here. And even though there's a value after this, you'll see that this is going to return num times num times num anyway. So we're returning 27. And actually, here's the interesting part is any code that goes before this return keyword, or that goes after this return keyword isn't gonna get executed. So if I put a puts down here, and I printed out Hello, when I run my program, you'll notice that it doesn't print out Hello, like nothing is getting printed out. Basically, what's happening is when we use this return keyword, that's going to signal to Ruby that we're done with the method. So when Ruby sees this return keyword, it's basically going to jump and break out of the method and move on to the next line of code. So essentially, when you're using the return keyword, nothing after it is going to get executed. And that's just a little tip. So in addition to returning just normal numbers like we did over here, we can also return multiple pieces of information and keep mine You can return any data type, it doesn't have to be like a number. It could be a string could be Boolean could be anything. If I wanted though, I can return multiple numbers. So for example, I could return num times num times num. And then if I put a comma here, I can return another value so I can return like 17. And now when I run my program, in addition to returning 27 you'll see that it's also returning 70. So I'm getting two pieces of information. And this is basically just returning like an array so I could access each individual value that got returned by its index. So if I said q three square brackets one that's just going to give Give me 70. They want to be careful when you're returning multiple values just because if you're returning like five or six different values that can get a little bit confusing, especially for, you know, the code that's actually calling these functions, but for the most part that can actually be pretty useful. So that's the basics of using that return keyword and also just returning values. In general, this can be a super powerful way to to make your methods a lot better. In this tutorial, I want to talk to you guys about using if statements in Ruby, an if statement is a special structure that we can use in Ruby in order to help our programs to make decisions. They also have our programs to respond to the different information in the program. So if certain information has certain values, we can do certain things. Other information has different values, we can do different things, basically, if statements make our programs a little bit smarter. So in this tutorial, I'm just going to give you guys a basic overview of if statements, what we can do with them, how we can use them, and essentially just get you guys up and running with if statements. So over here, I just have this little text file. And it actually has some common if statements that human beings every day will encounter. So believe it or not, if statements also apply to like human beings. So let me show you guys a couple of these. The first one up here says I wake up, if I'm hungry, I eat breakfast. So let's break this down a little bit. You'll see right here we have a condition, right? If I'm hungry, this condition is either true or false, right? on the condition that they're hungry, then they're going to go ahead and eat breakfast. If they're not hungry, though, if this condition is false, then we're just going to move on and they're not going to eat breakfast, right? That's something that pretty much every morning, everybody is going to have to like ask themself at some point. Here's another one, it says, I leave my house. If it's cloudy, I bring an umbrella. Otherwise, I bring sunglasses. So up here you'll notice the same pattern, we have another condition, right, the condition is if it's cloudy, if that condition is true, if it is indeed cloudy, then they're going to bring the umbrella. But if the conditions false, in other words, if it's not cloudy, then we're going to come down here and we'll bring the sunglasses. So this one's a little bit different from the one up above. Because if this condition, if it's not cloudy, if this is false, then we're going to do something else. So I have one more down here at the bottom that says I'm at a restaurant. If I want meat, I order a steak. Otherwise, if I want pasta, I order spaghetti and meatballs. Otherwise, I ordered a salad. So this one's even more complex, right we have our condition says if I want meat, if that's true, we order the steak. Otherwise, if that's false, in other words, if you don't want meat, then we check another condition. So we're checking to see if we want pasta. If that's true, we get the spaghetti and meatballs. Finally, though this is false when we get the salad. So these are the three basic if statements. And these are three if statements that we can actually use. And these are the types of things that we can do inside of our program. So we can specify certain conditions. If those conditions are true, we can do certain things, those conditions are not true, we can do other things. So I'm going to show you guys basically how this works. Let's go over here to our Ruby file. So I'm just in my draft.rb file. And I'm going to create a if statement. So I'm going to show you guys how this works. The first thing we're going to do before we actually make the if statement is just make a variable, so I'm just going to call it is male. And this is going to be a boolean variable, it's going to tell us whether or not someone is male. So let's say this is a piece of information that we were storing inside of our program like whether or not someone's male. So in my case, I have a male so I'm going to set it equal to true. So down here we can actually make an if statement. So we can do something depending on the value of this variable is male. So I can say if and over here I want to specify a condition. So remember, when we were looking at those text files, it was like if it's cloudy, or if I'm hungry, or if I want me right we were giving these those statements, different conditions. In this case, we're going to specify our own condition. So I'm going to say if is male, and inside of this condition we need to include either a true or a false value. So bullions are great with this because a Boolean can either have a value of true or false. So I can say if is male, and then down here I just want to type out and now whatever goes in between if an end is going to get executed when is male is true. So over here we can just put you are male, right? So now because is male is true. When I run my program, you'll see over here it says you are male, so the program is working. If I was to change is male to false, however, So I'm just gonna put false. Now you'll see that this code isn't getting executed. So we're not printing anything out. That's the basics of an if statement, right, I can specify a condition. If the condition is true, then we'll execute the code down here. If the condition is false, we just skip over it. So I'm going to show you guys how we can use something called an else. So basically, what happens if we want to do something when the person's not male, right, so we have it covered, if the person's male, we're going to tell them they're a male, but what if they're not a male? Well, I can actually come down here, and I can type out else. So I'm just gonna say else. And then again, below else, I'm going to put code so I can say puts, you are not male. So now we basically have an if statement that will handle both of the possible scenario. So if they're male, it'll tell them they're male. Otherwise, it'll tell them they're not male, so you'll see is male is false. And over here, we were telling them that they're not male. If I was to change this back to true, now, it's gonna say you are male. So it's essentially able to react to the value of that variable. Let's make this if statement a little bit more complex. So why don't we add in another Boolean variable, I'm going to say is tall. And we'll set is tall equal to actually let's set it to true initially, we'll also set this to true. So is tall will tell us whether or not a specific person or a specific entity you know is tall. So what happens down here, if we want to do something when they're male, and they're also tall, I can actually use another keyword in Ruby, which is called and so I could say if is male, and is tall. And basically what this is going to do is it's going to execute the code inside of here, when they're both male. And they're also tall. So here, we could say you are a tall male. And so now this code is only going to execute when is male is true, and is tall is true. So they're both true, right? Now let's run our program, it says you are a tall male. But if I was to set one of these equal to false, so for example, if I set in is tall, equal to false, now, it's not going to tell us that we are a tall male anymore. So it's just gonna say you are not male, although I guess we would have to change this down here. So we can say you are either not male or not tall, or both. And so now it's telling us you're either not male, or not tall, or both, because we know for a fact that they're not male and tall. So that's how we can we can check to conditions. And in addition to using an and I could also use another keyword called or, basically this will execute if they're either male, or if they're tall. So only one of these variables has to be true now, right, this is going to execute if they're male, or if they're tall. So you'll see over here is male is true and is tall is false. But this is still gonna execute, you are a tall male. And obviously, we can change, you know, whatever is getting printed out there. But hopefully, you get the point, when we say and both of the conditions have to be true. So if I was to say, is male, and is tall, these would both have to be true. In order for this code to get executed. If I say or only one of them needs to be true. Now both of them can still be true and will still execute that code. But only one of them has to be true. And if both of them are false, then we'll execute the code down here. So I'm going to go back to is male and is tall. And let's say that I want to check to see the other conditions, right. So we're already checking one condition, we're checking to see if they're male, and they're tall. But what if we wanted to do something when they're male, and they're not tall? Well, I can use something called an else F. And then f is basically another key word in Ruby that will check another condition. So I could say like, LS if and this just stands for elsif. And I want to type in another condition after this. So why don't we check to see if they're male. So I'm going to say elsif is male. And I want to check to see if they're not tall. And the way that I can check to see if they're not something is I can use a exclamation point. So if I said, and exclamation point is tall, this is basically saying not is tall. So when they're not tall, this is going to be true. And we're doing that using this exclamation point. It's called the negation operator. So down here, we can put some more code. So I could just say puts you are a short male, right? basically what's happening is it's going to check this if condition. So Ruby is going to check this if statement up here, if they're either not male or they're not tall. So in other words, if this whole thing is false, it's going to come down here, and it's going to check this next condition and if this is false, it's going to go down to the else. But if this is true, it'll execute the code inside here, there's actually one more scenario that we could cover, which is when they're tall, but they're not a male. So I'm going to use another elsif, I'll say else, if not, is male, so I'm using that exclamation point and is tall. And if this is true, then we can just print out, you are not male, but are tall. And then also down here, if the code inside of this else block is getting executed, then we're going to know that they're not male and not tall. So we can say you are not male and not tall. Alright, so let's go ahead and run our program. So I'm going to set is male equal to true and is tall equal to true right off the bat just to start. So I'm running the program and you'll see it's able to handle that situation says you are a tall male, if I was to set is male equal to false, though, our program is going to be able to handle that situation. So it's going to say you are not male, but are tall, right, our program just by using these if statements was able to give us information based off of these values. If I was to make is tall, false, and is male true, it's going to be able to handle that. So it will say you are a short male. If I make both of these false, it's going to be able to handle that as well. So it's going to say you are not male and not tall. So that's the basics of using if statements, you can see down here, I'm checking a condition. And in a lot of cases, you're going to want to check more than one condition. So you can use either and, or or I'm checking these conditions. If the condition is true, then we'll execute the code down here. And by the way, you can put as much code down here as you'd want. I mean, I could put hundreds of lines of code if I wanted to. So I'm using the if statements. And I'm using these else ifs and I'm using this else in order to catch all of these different scenarios. And these else ifs are really useful because you can check multiple conditions when other conditions are false. So that's the basics of working with if statements, there's actually some more stuff we can learn with these. Instead of just using Boolean like true and false, we can also use things called comparisons. And I'm going to be talking about that in the next tutorial. But for now, this is just kind of been a brief introduction into if statements in Ruby. In this tutorial, I want to talk to you guys some more about if statements. Specifically, we're going to be talking about using comparisons with if statements. So in any if statement, you're going to need a condition. And a condition is basically a true or a false value. One of the cool things about Ruby though, is we can use a comparison in order to get a true or false value. So inside of our condition, or if statement, we can actually compare different values. And depending on the result of that comparison, we'll be able to either execute the code inside of the if statement or move on. So I'm going to show you guys how we can do this. It's really awesome. And it's a super powerful feature, what I want to do in this tutorial is actually create a method. So I want to create a method called max. And this method is going to take three numbers as input. So it's going to take three parameters. And basically what it's going to do is it's going to return whichever number is the largest. So whichever number out of the three is the biggest, it'll basically return that back to the user. And this is a great example of a situation where you'd want to use comparisons inside of your if statements. So let's get started. I'm just going to come down here and we'll start making our function or our method. So I'm just going to say def, and we're going to call it max. And I'm gonna make an open and close parentheses. inside of this parentheses, I can specify any parameters that I want this method to take in. So I'm just gonna say num one, number two and num three. Basically, we're taking in three numbers. Now down here, I'm just gonna say and, and inside of this method, we have to devise an algorithm to figure out which number is the biggest right. So inside of this method, we don't know which of these is the biggest right, we have no idea we have no idea what the user input into here. So we need to use an if statement in order to figure that out. So I can say if now inside of this condition, I can actually compare two numbers. So I could say if num one is greater than or equal to num, two, and num one is greater than or equal to num three. So remember, inside of an if statement, we need to put a condition here. And in the last tutorial, when we were using conditions we were putting in true or false Boolean values, what you'll notice is when I compare two values, when I compare number one and number two, this is actually going to get resolved into a true or a false value. So this comparison is either true or its false. num one is either greater than or equal to num two or it's not. This is actually going to end up being a boolean value, this is going to end up being true or false. Same thing over here, num one is either greater than or equal to num three, or it's not. It's a boolean value, there's only two possible situations here, it's either true or its false, we didn't actually have to put like true or false, here, we were able to use a comparison in order to get a true or false value. So if num one is greater than num, two, and it's greater than num, three, then we can just return num one because we know that's the maximum number. Down here, I'm just going to say elsif. And I want to check another condition. So I'm going to check to see if num two is greater than num one, we're actually greater than or equal to num one. And num two is greater than or equal to num three. So if num two is bigger than num, one and num three. In other words, if the result of both of these comparisons is true, then we know that num two is the biggest number. So we're just going to return that. And finally, we can use an else statement. So I can use that else keyword, I can just say else. And down here we can just return num three. Because if num one isn't the biggest and num two isn't the biggest, then we can be pretty sure that num three is the biggest. So this is basically how we can use comparisons inside of our if statements. I also want you guys to notice that I was able to use this return keyword multiple times, right. So if this condition is true, we can just return the number. Alright, so let's go ahead and run this function. So I'm going to come down here, and I'm going to call this function, I'm gonna say Max, and I'm going to pass it three numbers one, two, and three. So if I print this out, I print out the value that gets returned, actually, I'm gonna put it I should get a three back. So let's go ahead and run this. And actually, you'll see I'm getting an error over here, I forgot to put in the end keyword. So down here, we just have to put an end. So you'll see we have an end keyword here. And this ends off this if statement, we have another end keyword here. And this ends off this function declaration. So that's something to keep in mind, you always want to make sure that you're remembering to include this end keyword, you can see how easy it is to forget, I just forgot it. So I'm going to run this program and you'll see we're getting three. So I pass it three numbers, if I was to make this middle number, the largest, so we'll make it 20. Now it should return 20. If I was to make the first number, the largest, it's going to return that. So we now have a valid working max function that will always tell us what the maximum number is. So I just want to point this out one more time what was happening, instead of putting a true or a false value in there, we actually indirectly put a true or a false value in there by making a comparison. And the result of that comparison is either going to be true or false. There's no other situation right? No one's either bigger, greater than or equal to num two or it's not, I'm also using something called a comparison operator. So this right here is a comparison operator. It's an operator that we can use to compare different values. This one is greater than or equal to, but there's also some other ones. So for example, probably the most basic is a double equals, and this basically means equal to, I can put a exclamation point in equal sign, this means not equal to so this would be like num one is not equal to num two, we can do a greater than sign a greater than or equal to sign a less than sign a less than or equal to sine. And all of those are going to allow us to compare different values. It's also important to note that, in addition to this using numbers, you could also use strings here so you can compare different strings. For example, I can compare two strings for equality, I could check to see if one string was equal to another string. And that's really a powerful way that we can use these if statements is by checking comparisons. A lot of times in your programs, you're going to want to compare different values. And depending on the results of those comparisons do different things. In this tutorial, I want to talk to you guys about creating a better calculator in Ruby. If you've been following along with this course, then you'll know that in the beginning of the course, we created a very simple calculator. Basically, we allow the user to input in two numbers, we took those numbers, added them together and then printed out the answer onto the screen. So it's a really simple calculator. But in this tutorial, we're going to be building an even better calculator. This calculator is not only going to be able to add two numbers, but it'll be able to add, subtract, multiply and divide numbers and will allow the user to choose which one they're going to do. So this is going to be pretty cool. And we're going to use a lot of the stuff that we've learned up to this point in this course in order to do it. So the first order of business when we're creating our calculator As we need to get some input from the user, I need to get certain information, right, we need to get the first number, we need to get the second number, and then we need to get the operation that they want to perform. So they would need to type in like two, and then a plus sign, and then a five, you know, something like that, basically. So let's go ahead and do that down here in my program, the first thing I want to do is, is print out a prompt. So I'm going to say puts, and we're going to print out enter first number, basically, we're prompting them to enter in the first number. And then what I want to do is I want to take whatever number they enter, and I want to store it inside of a variable. So I'm going to create a variable called num one. And I'm just going to set it equal to get dot chunk. And this will basically just get the number that they enter in and remove the new line that gets entered when we click the enter key. So now that we've done this, we can do something similar for the other two pieces of information we need the next the next thing I want to get is the operator. So I'm just going to say enter operator. And basically this is going to be like plus minus division or multiplication, they're going to enter in whatever they want to do. So over here, instead of saying num, one, we can just say Opie, and this is going to Stanford operator, and we're just going to get whatever they input. Finally, I'm going to ask them to enter the second number. So I'll say enter second number, and we're just going to store this as num, two. So essentially, what we're doing is we're asking them to enter in the first number. Once they do that, we're asking them to enter in the operator plus minus division, multiplication, subtraction, whatever, then we're asking them to enter in the second number, and we're storing all of that information inside of variables. Now there's one more thing we have to do. Remember, when the user enters in a number in, when we ask them for input, it automatically gets converted into a string. So what we want to do is want to convert the number that they enter from a string into a floating point number. So I'm just going to say gets.chomp.to underscore F, and this is going to convert it into a floating point number, I'm going to do the same thing down here.to underscore F. So now number one, and number two are going to be floating point numbers, assuming the user entered the number in correctly. Alright, so once we do that, we actually need to do a couple other things. So the first thing we need to do is we need to figure out if they want us to add the numbers, subtract the numbers, multiply the numbers or divide the numbers, right? We have no way of doing that right now. So we need to figure out, how can we figure out if they entered in a plus sign? How can we figure it out, if they entered in a minus sign, we need some way of figuring out what they entered. And this is a perfect scenario where we can use an if statement. Remember, an if statement allows us to respond to the different values in our programs. So if something has a certain value, we can do something it has another value, we can do something else. perfect situation right here. For an if statement, we can check to see if it's a plus sign. If it's a minus sign, if it's a division sign, and depending on the one it is we can do something down here, I'm going to create an if statement, I'm just going to say if. And then we always want to make sure that we end off the if statement down here. And up here we're going to put a condition, I'm going to be checking a couple different conditions in this if block. The first thing I'm going to do is check to see if it's equal to a plus sign. So I can check to see if op. And remember, op was the operator that got entered is equal to I'm going to make those double equals and over here, we'll just make a plus sign. So this is going to be true if the operator they entered was a plus sign. So down here, what we can do is we can just say puts, and we'll just print out the answer. So I'm just going to put num one plus num, two. Awesome. But there's also some other scenarios, right the scenario where they enter a minus sign. So I can say elsif elf if, and I'm going to say oh p is equal to minus sign. If that's true, we're just going to put num one minus num two, we can do the same thing for multiplication and division. So I'm going to go ahead and copy this, this will just make it go by a little quicker. And now instead of checking for subtraction was check for division, which is just going to be a forward slash. Finally, we can check for multiplication. So I'm going to come down here and we'll just check for an Asterix and then down here we'll multiply them. So we're able to basically capture the four types of arithmetic right and respond to them appropriately. There's going to be one more situation though that we want to cover which is that they enter in an operator that's not valid. So I'm just gonna say else. And remember, the code inside of this else is only going to get executed when none of the stuff up here is true. So when none of this stuff is true, in other words, if it's not plus sine minus division or multiplication, we can just print out an error we can say put invalid operator And that's basically going to give them a little error message like, Hey, you messed up, you didn't put in the right operator. So we've essentially written out our program, we get the three pieces of information, we check to see what operator they put in, and we respond to it. So let's run our program and see how it works. Now remember, whenever we're running a program where we need to get input from the user inside of Ruby, we're going to have to use the command line. So normally, in this course, we've been using this little atom plugin over here called atom runner. But now we're going to have to use the command line. So I'm going to come down here and I just have one inside of my atom text editor. And I'm just going to type Ruby draft.rb. That's the name of my file. And I'm just gonna click Enter. And let's go ahead and use this little calculator. So it says enter the first number, we'll enter in a five. And it says, enter the operator. So why don't we enter in a plus sign, and it says, enter the second number. So let's enter in a six. When I click enter, we should hopefully get the correct answer. So you can see down here, five plus six is 11. So our program actually work. That's awesome. All right, let's do it again. Let's try another one. Why don't we try to do some multiplication. So enter the first number, we'll enter in a five, and then we'll multiply by 8.65. And let's see, oh, wait, sorry, this is the operator. So multiplication, we'll multiply it by 8.65. And let's see what we get 42.25. So yeah, that seems about right. So our calculator is functioning correctly. And let's try one more case where we enter an invalid operator. So I'm gonna run the program one more time, enter in a four, and then we'll just enter in like a T as the operator and a five. And okay, so it tells us invalid operator. So we have a four function calculator, we've actually built an awesome four function calculator. What's cool about this calculator, is it's able to respond to the operator that the user enters. And we can do that using if statements. So this is one of those situations where if statements are just going to come in such handy because they're so useful, right, we can check all these different conditions. If one of them's true, we can do something if another one's true, we can do something else. So this is kind of bringing together like getting user input and if statements into one single program, which ends up being a pretty awesome calculator. In this tutorial, I want to talk to you guys about case expressions in Ruby, a case expression is actually just a special type of if statement that we can use to check a bunch of different conditions. So we could use an if statement to check you know, to see if a bunch of different things are equal to other things, or to check the values of different variables. But sometimes when there's a bunch of different things that we need to check, we can use something called a case expression. And it actually makes it a lot easier. So we're going to be creating a method in this tutorial, which is going to map day abbreviations to day names. So for example, each day of the week has an abbreviation like Monday is mo n, and that gets mapped to Monday, right? Tuesday is t ue, and that gets mapped to Tuesday. Wednesday is W Ed that gets mapped to Wednesday, etc, right? The abbreviations get mapped to actual full days of the week. So I want to write a method that can take as a parameter, one input, and it's going to be an abbreviation, and it's going to take that abbreviation and it's going to spit out the actual name of the day. So if we pass it in an MLM, it'll spit out Monday, and we pass in a fri it'll spit out Friday, right. And that's basically going to allow us to convert these abbreviations into the actual days of the week. So let's go ahead and do that. I'm just gonna define this method. So I'm just gonna say def. And we need to also include an end over here and a method name. So why don't we call our method get day name is going to be called get date name. And inside of here, we're going to pass the abbreviation. So I'm just going to call this day and day is going to represent the three letter abbreviation of the specific day, right? Make sense? Alright, so down here, what we need to do is we need to convert day into the actual day name. So the first thing I'm going to do is create a variable and we'll just call it day name. And we're going to store whatever the day name ends up being inside of this variable. So I'm just going to set this initially equal to the empty string. And then down here, right, before we end off the method, I'm going to return day name. So our mission inside of this method now is to give this date name variable, the value of the correct day, right? We need to give it the name of the day that corresponds to this abbreviation. So one way that we could do this would be using an if statement, right? So I can come down here and you know, hopefully at this point you guys are familiar with if statements I could say like, if day is equal to mo n Right, if Daisy with mo and then we can set the day name equal to Monday. Make sense. But there's also a bunch of other conditions we have to check. So if that's not true, we can check to see if the day is equal to Tuesday. And if that's true, then we can set the day name equal to Tuesday. So for each day of the week, I can make a different Elsa frags, like elsif, Daisy will do Wednesday, Thursday, Friday, Saturday. But here's the problem, this is going to get really tedious and really messy really fast, right having to create seven different if statements and you know, seven different else blocks, checking seven different conditions, is going to be really difficult and tedious. And that's why Ruby has something called the case expression. And essentially, what the case expression does is it allows us to take a scenario like this, where we're comparing the same value to a bunch of different values, and put it into a structure of its own. so in this situation, in every single one of these conditions, we're comparing the day variable equal to another value, right? In this condition, we're comparing it to Monday down here, we're comparing it to Tuesday, we could also compare to Wednesday, Thursday, Friday, it's the same comparison with a different value. In a situation like that case expressions are golden, they're gonna help us out so much. So I'm going to get rid of this if block. And over here, we're going to set up a case expression. So the way that I do this is just by typing out case. And now I need to give this something so we're going to give this the value that we want to compare to a bunch of different values. In our case, it's just day. All right, because I want to compare day to month I want to compare data to like TV, I want to compare it to W Ed th view, I want to compare it to all the day abbreviations. So we're gonna need to end this off. Now inside of here, I can create something called a when statement. And a when statement will basically do something when day is equal to a certain value. So I can say when and now I can compare day to something. So I could say when mn and basically what this means is, when de is equal to m o n, then down here, we're going to do something so I can just put some code down here. So what I want to do is set day name equal to Monday, because now we know they're trying to get Monday, I can make another one. So I could say when T, we could say day name is equal to Tuesday. All right. So basically, what we're doing is we're checking to see if day is equal to Monday. And if it is, then we'll do this. If day is equal to Tuesday, then we'll do this, etc. So I can make one of these for every single day of the week. And that's exactly what I'm gonna do. So I'm going to go ahead and do that. And then we'll meet back here, and we'll talk about what happened. Alright, so I went ahead and created one of these for every day of the week. So we have 1234567 of these here. And each one of these is doing something when a different condition is met. So when it's w Ed, or setting de named Wednesday, when it's fri we're setting Danny to Friday, etc. So essentially, we're able to create like a complex if else structure, but without having to like actually write all of it out, we can just say like when, and it's automatically going to check this value with the value up here. So this can be really useful. But there's actually one thing that we want to account for, there's going to be situations where the user enters in an invalid day abbreviation. So if the user enters in a valid abbreviations like su n or sa T, we can cover that right. But what happens if they enter in something invalid. So what happens if they pass a parameter into this get day name method that isn't an actual valid abbreviation? Well, we can use something called the else keyword and the else keyword is a lot like the else keyword. And if statements, I can just say else. And now anything that I put in here is going to execute when none of these guys up here are true. So I can say down here else day name is equal to invalid agree abbreviation, right? So I'm basically telling them, hey, you put an invalid abbreviation in here. So this is going to get executed when there isn't a valid abbreviation. Alright, so essentially, what I'm doing is, in each of these scenarios, I'm giving a name a different value, then down here at the bottom of our method, I'm just returning deigning. So this is a fully functional method. Hopefully everything works. Why don't we come down here and test it? So I'm going to go ahead and just print out the answer that we get back. So I'm gonna say puts, and then it's just called get day name. And we want to pass is an abbreviation so I'm going to pass this mln for Monday, right? And when I pass it this and we run our program. You'll see over here we print out Monday. So our program is giving us Back to the correct answer. If I typed in sh t down here, then we should get back Saturday, just like that. If I typed in th foo, then we're going to get back Thursday. So you can see, we're getting back the correct value if I typed in something invalid, so if I typed in like d o g, like dog now shouldn't yell at us. So it's gonna say invalid abbreviation. And we were able to do this whole thing while keeping it nice and clean and nice and simple. Like this whole thing only took me you know, less than a minute to write out. And I was covering all of these different situations. So this can be extremely useful when you want to check a single value, like de against a bunch of different values and do different things, depending on the situation. So definitely consider using case expressions, here's the thing, these aren't going to be appropriate in every situation. These are appropriate for one specific situation, right, where we're checking the same value against a bunch of different values. But that situation is very common. So when it does come up, don't be afraid to use case statements, they'll make your life a lot easier. In this tutorial, I want to talk to you guys about working with while loops in Ruby. So a while loop is basically a structure that we can use inside of our Ruby programs, which will allow us to loop through a particular block of code a specific number of times. So I can basically like write out my while loop and I could put some code in there. And as long as a certain condition remains true, I'll keep looping over and executing that same code inside that while loop. There's a lot of situations in Ruby, where we're going to want to use loops, we're going to want to do something continuously until we need to stop. And so while he was a great way to do that, and in this tutorial, I just want to give you guys a broad overview of while loops, we'll look at like the most basic type of while loop, you can write what it's talking about the core concepts behind them. So over here, I can actually create a while loop and the first thing I want to do is actually make a variable. And this isn't, you know, 100% necessary when working with while loops. But you'll see how this variable comes in in a second. So I'm just going to call the variable index, and I'm going to set it equal to one. So we have a variable index, and it has a value of one, and down here, I can actually create my wild. So the first thing I'm gonna do is just type out while and then what I need to do is I need to specify a condition. And you always want to make sure that you end these off. So I'm just going to put an end down here. Now here's basically how while loops work all the code in between while and n. So all the code inside of here, that we're going to put inside there is going to get continually executed. So it's going to keep getting looped over and keep getting executed. As long as this condition is true. As long as the condition that we specify right there is true, then we're going to keep executing the code inside of this loop. So over here, I can actually specify a condition. So I'm going to say while index is less than or equal to five. So essentially, what I'm saying is, while index is less than or equal to five, I'm gonna keep looping through the code inside of here. And actually what I can put in here, we can just put, you know, whatever code we want to keep looping over. So the first thing I'm going to do is, I'm gonna take puts, and I'm going to print out the value of index. So I'm say puts index, and then down below here, I'm actually going to increment the value inside of index. So I'm gonna say index is equal to index, plus one. So basically, every time through this loop, I'm printing out the index. And then down here, I'm incrementing, the index. And actually, I want to show you guys something that's cool we can do in Ruby, I have here index is equal to index plus one. But I can actually instead of saying that, I can just say index plus equals one. And whenever I say plus equals, you can also use minus equals, as well, this is basically just going to add the number over here to index. So this is going to add one two index. So that's kind of a little shorthand we can use in Ruby. But back to the while loop, this is going to keep looping through the code inside of here, as long as the index is less than or equal to five. So let's think about what's going to happen here. Actually, let me just show you guys. So why don't we execute this code, I'm going to run the program. And you'll see over here, I'm actually printing out values between one and five. So I'm printing out 1234, and five. So maybe this is what you expect it to happen. Maybe it's not what you expected to happen. Either way, I'm going to walk you guys through exactly what happened. So over here, it says while index is less than or equal to five, so remember, we're going to keep looping through this loop as long as that's true. So here's how the execution of this program goes. Ruby creates this index variable gives it a value of one. The first thing Ruby does when it gets to this while loop is it checks this condition. If this condition is true, then it's going to start looping through. So in our case, this condition is true, right? So Ruby is going to go ahead, it's going to print out the index, and it's going to add one to it. Once Ruby has finished executing the code inside the while loop, the next thing it's going to do is go back up here to the top of the while loop. And it's going to check this condition again. So every time Ruby goes through this loop, every time it loops through the code, right, it's going to go back up, and it's going to check the condition again. So every time through the loop, we're constantly checking the condition. So in this case, we incremented I, we incremented the index, so the index is now equal to two, which is less than or equal to five. So we're good to go. Right, that condition is true. So now we'll execute all of the code inside of here again, and then again, we're going to come back up and check the condition. So every single time we're going, we're checking that condition, eventually, index is going to be equal to six, right, we're going to get to a point where, you know, index was equal to five, so we printed it out, and then we added one to it. So now index is equal to six, we're going to loop all the way back up here. And suddenly, this condition is going to be false. And when this condition is false, we're going to break out of the loop, so we're not going to execute it anymore. And we're just going to move on to the next line of code. So that's basically how while loops work, we specify a condition. As long as that condition is true, we move on. And that's how we can get this output right here. So for example, if I was to change this to like eight, now we're going to print out one through eight, because the condition is only false when we get to nine, right, so we're printing out a times essentially. So this is extremely useful. There's tons of situations where we're going to want to use while loops like this. Now, I want to point out one potential problem that you're going to have with wild loops, and it's basically called an infinite loop. And an infinite loop is a situation where the condition up here never becomes false. So it just loops through infinitely. And this is something that could actually mess up your programs quite a bit. So you always want to make sure that when you're writing a while loop, that eventually the condition up here is going to be false. Now in certain special circumstances, you actually want to use an infinite loop. But I'd say for most cases, especially as a beginner, you're not going to want to infinite loop. So it's just something to keep in mind. But this is where the basics of a while we're specifying a condition, as long as that condition is true, we're going to keep looping through whatever code is inside of here. So like I said, there's tons of ways for us to use this. And in the next lesson, we're actually going to build a program where we're going to use a while loop in order to build a little game. So stick around for that, that's gonna be pretty fun. In this tutorial, I want to talk to you guys about building a guessing game and Ruby. So we're actually going to build a little game. And it's basically a game where the user can try to guess a secret word. So we'll continually prompt the user to guess a secret word. And if they get it right, then they'll get a success message like, Hey, you got the word right, and they get it wrong, then we'll let them keep guessing. So they'll be able to keep guessing what the word is until they get it right. And this, this would be kind of cool. And this will show us how we can use something like a while loop in order to build a little game. So down here, first thing I want to do is create a couple variables, the first variable I want to create is going to be the word that the user has to guess. So remember, we're creating a guessing game. So we need to store a variable that has the word in it, right. So I'm going to say, secret underscore word. And this is just going to store that secret word. And I'm just going to set this equal to draft. So you know, this could really be anything you want, whatever the secret word is going to be for our game. And finally, I want to create one more variable, this is going to be called guests. And we're just going to set guests equal to the empty string for now. So I have two variables, secret word, and guests. And now that I have these two variables, I basically want to create a while loop. And I'm gonna create a while loop that's going to continually loop through and ask the user for input. So I'm just going to say while and over here, we need to specify a condition. So again, this while loop is going to keep asking the user to input the secret word. And as long as they don't get the secret word, right, we're gonna keep asking them. So I'm basically going to say while guess, is not equal to secret word. So as long as the users guess, isn't equal to the secret word, we're going to keep looping. So down here, what I want to do is print out a prompt, so I'm just gonna say puts, and we're just gonna say enter your guess. So this is going to prompt the user to enter a guess. And what we want to do now is we want to store whatever the user guesses inside of this guests variable. So I'm just going to say guess, is equal to get dot shop. And remember, chomp is basically just going to get rid of that new line at the end of whatever user enters. So essentially, what's happening here is, while they, the user hasn't guessed correctly, while their guests isn't equal to the secret word, we're just going to prompt them again for the guests and the guests is just going to get equal to whatever the user types in. So eventually, what's going to happen is they're going to guess the word correctly. And when they do guess the word correctly, then this condition is going to be false. So we're going to come down here, and we'll basically just print out a success message. So I'll just say, like, puts you one. Alright, so this is a pretty simple program. But you'll see this actually allows us to build a guessing game inside of Ruby. So whenever we are getting input from the user in Ruby, we always want to do it through the terminals or through the command line. So I'm going to go ahead and open up my command line down here. And I'm going to run our program. So it's just called draft.rb. So I'm just going to type Ruby draft.rb, and this will start executing our program. So down here, you can see it's asking us to enter a guest. So I'm going to come down here, and I'll enter a guest. So why don't we just enter in some nonsense. So you'll notice as long as I don't guess the word correctly, as long as I'm not entering in the correct guests, the program keeps prompting me to enter a guest right keeps asking me to do that. But here's the thing, if I was to come down here and actually enter in the guest correctly, so if I typed in, like draf, now we should get a success message. So when I click enter, you'll see it says you won because we entered in the secret word correctly. So obviously, this is a very simple program, but it actually works pretty well. And it does everything that we want it to do. This is a very simple game. And one of the problems with this game is that the user gets unlimited guesses, they can keep guessing the word forever until they get it. And that's not the makings of a good game, what would be better is if we imposed some sort of a guess limit on them. So they can only guess the word a certain number of times, otherwise, they lose the game. So let's go ahead and see if we can add that functionality into our program. In order to do that, I'm going to have to create a couple more variables, the first variable I want to create is going to be called guest count. And guest count is going to basically tell us how many times the user has tried to guess the word. So I'm gonna create a variable guests underscore count. And I'm just going to set this equal to zero, because initially, the user won't have guests. So the guest count will just be zero. Now down here, every time the user guesses, I want to increment the guest count. Right? So down here, basically, this code means that the user has tried to guess the word. So every time they do that, I want to increment the guest count, I just want to say guess, count, plus equals one. And this will add one on to the guest count. So every time they guess we're going to increment that. And I want to create two more variables. The first one is going to tell us how many guesses the user can actually take. So it's going to be called gas limit. And why don't we just say the user has three guesses. So three strikes and you're out, so they can't guess the word and three tries, then they're going to lose the game. Alright, finally, I want to create one more variable. And this variable is going to tell us whether or not the user is out of guesses. So I'm just going to say out of guesses, is equal to false. Because Initially, the user is going to have three guesses right? When the user reaches their guests limit, we're going to set this out of guesses variable equal to false. And then we'll be able to tell the user like hey, you lost the game. Alright, so now that we've created these variables, I'm just going to come down here. And inside of this while loop, we want to modify a couple things. The first thing I want to do is every time we ask the user to guess the word, I want to make sure that they're not out of guesses. In other words, I want to make sure that they haven't reached the gas limit. So I'm going to use an if statement. To do that inside this while loop. The first thing we're going to do before we do anything else is just say if. And we want to check to make sure that the guest count is less than the guest limit. So I'm going to if guess count is less than guess limit. In other words, if the guest count is less than the guest limit, then we know they have guesses left, right, we know that they have a certain number of guesses left and they should be able to keep guessing the word. So if this is true, then I want to allow them to guess the word. So I'm just going to take all this code, and we're going to move it up here. Alright, so if the guest count is less than the guest limit, if they have more guesses, then we're gonna do all of this. Otherwise, though, in the situation where the guest count isn't less than the guest limit, then we know for a fact that the user is out of guesses, right? If they that means they have no more guesses. So inside of this else statement, what I want to do is I want to set that out of guesses variable equal to true. And basically, this will tell our program like, hey, the users don't, they're out of guesses, right? We check to see if they were eligible for another guess. And if they weren't, then we're going to say out of guesses is equal to true because they ran out of guesses. All right, there's one more thing we have to do inside of this while loop. And we have to actually modify the while condition. So over here, you can see we have our little condition. And we're going to keep looping while the guess is not equal to the secret word. But now that we've imposed the guessed limit, there's actually one more situation that's going to cause us to stop looping, which is when the users out of guesses. So I want to say I want to keep looping as long as the guest is not equal to the secret word. And as long as the user is not out of guesses, so and not out of guesses. So we're going to keep looping through this loop, we're going to keep asking the user to input information, we're going to keep doing all the code down here, as long as the gas is not equal to the secret word. And as long as the user is not notice I'm using this exclamation point here, out of guesses, right. So now we have our while loop set up, right, we're able to loop through here. As long as the user has guesses left, there's one more thing we have to do down here. So before we just put you one, right before, if the user exited out of that while loop, that means they guessed the word correctly. So we knew for a fact that they won. But now that we're imposing the gas limit, there's actually two situations where the user could exit out of the loop. The first situation is where they got the word right, in which case they won. The second situation, though, is that they ran out of guesses. And if they ran out of guesses, we don't want to tell them they won, we want to tell them they lost. So we can actually check to see which situation caused that loop to end, I can just say if. And I want to check to see if they're out of guesses. And if they are out of guesses, and I'm just going to print out, you lose. But otherwise, if they're not out of guesses, that means that they were able to guess the word correctly within the certain number of guesses. So they win. So this is our basic program. And let's go ahead and test it and see if it works. So again, I'm going to open up the terminal. And over here, I'm just going to run the program. And actually, it looks like I'm getting an error here. Yeah, so I forgot to put an end statement down here. I always forget to do that. So always make sure that you put an end statement down here. And now we'll be able to execute our program correctly. So here we go. Alright, so it says enter a guest. So why don't we just try to lose the game. So I'm just going to enter in one guest. Two guesses. Now I'm on my third guest. So this is my last try if I don't get the secret word on this time, or lose the game, so we're going to not get it and it's going to say you lose. So the program is smart enough to figure out that not only did we run out of guesses, but also that we lost. So let's try it now. But we'll try to win the game. So over here, I'm gonna make a random guess another random guess. So now we're on our last try, it's our last chance to get the guests I'm going to type in the secret word, which is draft. And now the program is going to tell us Hey, you won. So we were able to win the game because we guessed within the guest limit. So that is basically this program. I know this is a lot of codes, I'm just going to step through with you guys one more time just to kind of do a broad overview of what we did. That way you can get a better idea of what's going on. So we have these two variables, secret word and guess. And these two are pretty obvious, right? The secret word stores the word that the user needs to guess, guess is going to end up storing what the user guesses each time through that loop. Right. So we're going to keep looping through this loop as long as the guest is not equal to the secret word. And down here, we're basically going to store whatever the user guesses inside of this guest variable that was like the basic game that we built. Then we added these three new variables and guest count guests limit and out of guesses. Guest count is basically going to tell us how many times the user has guessed. And so every time the user guesses, we're going to come down here and we're going to increment it, right? Guess limit is going to tell us how many times the user can guess in other words, how many guesses they have available to them. And you'll see down here we're using this if statement. So we're checking to see if the guest count is less than the guest limit. If that's true, if they still have some guesses left, then we're going to execute all this code will let them guess. Otherwise, though, we're going to use this out of guesses variable, and we're going to set it equal to true. That's going to tell our program that the user is out of guesses. Up here we also added another condition inside of our while loop so we're saying while the guest is an equal to the secret word And while the user is not out of guesses, so that's going to allow us to control what happens in this loop. Then finally down here, we're checking to see if they're out of guesses. So down here, there was two situations. The first situation was when the user ran out of guesses, so they lost the game. And if that's the case, we're just going to print out you lose. Otherwise, we'll print out you one, stop the basics of building our guessing game. So now your homework is to go off and build a guessing game of your own. In this tutorial, I want to talk to you guys about four loops in Ruby. Now a for loop is basically a structure in Ruby that allows us to loop through a specific collection. So that could be a collection like an array, it could also be a collection of numbers, basically allows us to loop through a connection, a collection, and for each item inside the collection, we can do something. And actually, in this tutorial, we're not just going to be talking about for loops, we're going to be talking about a broad range of different loops, and looping structures, which we can use to loop through different things. Essentially, in Ruby, there's a lot of different ways we can do the same thing. And I'm going to be showing you guys a bunch of different ways to do essentially the same thing. So the first thing I want to show you guys is I have this array set up up here. And it's basically just called friends. And it has a bunch of items in it, you know, basically just a list of someone's friends. And I want to show you guys how we can use a for loop to actually loop through all of the items inside of this friends array. And remember, if I wanted to access a specific item, I could just say friends, and then pass an index. And so if I said friends, one, this is going to print out care and onto the screen, right. So that's kind of how I can access an individual element. But I can also use something called a for loop. And I can say for friend, in friends, and then down here, I also want to end this off. So I'm just going to put end, and inside of this little for loop, I can just say puts friend, and what this is going to do is it's actually going to print out all of the friends inside of this friends array. So now when I run this program, you'll see we're printing out all of the values inside of that array. And essentially, what I'm doing is I'm saying for and I'm specifying the name of a variable. And on every iteration of this for loop, this friend variable is going to represent a different friend. So on the first iteration, it'll represent Kevin, on the second iteration on represented care, etc. And I can actually name this whatever I want it. So I can just say element. And down here, I could print out element, and it doesn't actually matter. So it's all going to be the same. So that's a really easy way that you could loop through all the elements in an array. So for each element inside the array, you could basically do something and really friends could be this could refer to any collection inside of Ruby is basically just a general way to loop through a collection of elements. So this can be really useful when we're dealing with arrays, there's also another way that we could do essentially this same thing. So instead of having this for loop, I could just say friends, dot each, and I can say do and then I want to make two like little vertical bars right here. And I'm just gonna pass in the same thing as we did before, like a variable. And this variable is going to represent a specific friend on each iteration of this loop. So then down here, again, we can just say and, and over here, I can just print out a friend. And so now it's doing the same thing as we did before, we're printing out each one of the friends that was inside of that array. And again, I could, this doesn't have to be friend, this could be anything I want. So that's basically how we can loop through like an array a couple different ways. There's also another thing we can do, we can loop through a range of numbers. So I could specify that I want to go through a loop and go through the code a specific number of times. So I can come down here and I could say like, for index in, let's say zero to five. And I want to do something, so I could just print out the index, this is basically just going to loop through this loop five times. So you'll see over here, it prints out actually I guess it loop through six times. So it prints out 01234 and then five, so it's going to loop through from zero to five. And a lot of times in a lot of cases, you're going to want to go through a loop a specific number of times, and you can do it just like that. There's also another thing we could do, we could say like we could specify a number here, so I can say like six, and I could say dot times do. And inside of these vertical bars, I can just say like index. And again, this doesn't have to be called index, this can be called anything we want. And here it's the same thing. So this is going to loop through something six times. So over here, we're printing out zero through five. So these are all basically different ways that we can loop through other collections or we can loop through something as specific number of times in Ruby and this can come in handy a lot. In this tutorial, I want to talk to you guys about building an exponent method in Ruby, one of the things I wanted to show you guys was how we can use something like a for loop in order to write a little method. And I think one method that could be kind of cool to see how we might be able to write it would be an exponent method. So an exponent method would basically take two numbers, it would take a base number, and it would take a power number, and then it would basically take the base number to the power number. So if we passed in like a two and a three, then this would basically give us like to raise to the third power has essentially like what this method is going to do. And let's just go ahead and create it. So I'm just gonna say def. And why don't we just call this POW for like power, so it'll take a number to a specific power. And then inside of these parentheses, we actually want to have this method accept two parameters as input. So we want the base num, and we also want the pound num. So the base number, and that's going to be taken to the power number. Okay? All right, let's end off this method. Now, inside of here, we need to figure out how can we actually do this, you know, how can we take the base number to the power number, and my solution would be to use a for loop, the first thing I'm going to do actually is create a variable. So I'm just going to call this result and I'm going to set this equal to one, and then down here right before the end of the function, we're just going to return it, so I've just returned result. So ultimately, this variable result is going to represent the value of the base number taken to the power number. So let's use a for loop, essentially, what I want to do is I want to multiply the base number by result, power num times that makes sense. So let's flesh out this for loop. And then we'll kind of see how it's going to work. So I'm going to save this, I'm going to say POW num dot times do. And basically what we're going to do now is we can actually just pass this an index. Now I don't know if we're gonna actually use this index, but it might be good just to pass it in anyway. And down here, I'm just gonna end this off inside of this little loop here, we're basically just going to multiply result times the base node, so I'm just gonna say result is equal to result times base node. So essentially, what's happening is pow, num dot times do index, this is essentially just going to loop through the code inside of here power num times. So if power num is three, we're going to loop through this code three times. If power num is 10, we're going to loop through this code 10 times. And every single time we go through this code, we're gonna multiply the result times the base num. So the first time through the loop, it's just going to be resolved, which is one time as base num, so results gonna end up just being based on second time through, it's gonna end up being like base num squared. Third time through, it's gonna end up being like based on q. So this is essentially how we can go ahead and write this method. Now it's important to note that this is only going to work for positive number exponents. So if power num is a negative number, then this method is actually not going to work. But just for our purposes, In this tutorial, let's just assume that we're always going to use a positive exponent. So once we've multiplied result times, based on as many times as we need to, then we can just return it. So believe it or not, this is actually all we need for this method to work. So let's go ahead and call this method and we'll see what we get. So down here, I'm actually just gonna print this out. So I'll just print out pow, and why don't we take two to the third power. Okay, so let's run this. And you can see over here, we get eight. So two cubed is eight. Let's try another one. Why don't we do four cubed. So now we should get 64. Good. Let's do five squared. So we should get 25. And we do so looks like this methods working. So again, this is going to work for positive number exponent. Now you remember exponents, this won't handle it. But for our purposes, this kind of demonstrates how we can use a little for loop or in this case, we're just saying power num times in order to loop through something a certain number of times. And this can be extremely useful when we want to do something like this. And also I just want to point out over here, I had kind of stored this variable index. But you don't actually have to do that. And in this case, we don't need it inside of this method, but it's not as good to just have it there. So that's to kind of give you an idea of like a situation where we might be able to use one of these looping structures in order to like perform a function. In this tutorial, I want to talk to you guys about comments in Ruby. A comment is basically a little line of code that Ruby is actually going to ignore. So a lot of times when we're writing our Ruby program There's going to be situations where we want to leave like little notes, or really just little comments inside of our files. And a comment is exactly that. It's just a little line of code, a little line of text that is meant to be read by humans. So if you're writing a Ruby file, you can leave a little comment. And then when you come back later, you can read the comment or another developer who's looking at the file can read the comment. And you can basically communicate information that's outside of just the actual code in the file. And there's a lot of situations where comments are going to be useful. The basics of making a comment is you essentially go to a line of code, and you can use this hashtag symbol. And anything that you put after this hashtag symbol is going to be in the comments. So you'll notice that my text editor is actually styling this a little bit differently. So if I was just to come down here and type out some random text, you can see that this is actually going to get rendered by the program. But if I put random text over here, after this hashtag, this is going to be considered a comment. So I can basically write any plain text over here. And when I run the program, you'll notice that nothing gets printed out, you know, that's inside of this comment block. So like I said, comments are really useful for leaving little messages or little reminders inside of your programs. You can also put comments after lines of code. So for example, here, we have just a line of code. If I wanted after this line of code, I can put my hashtag. And I could type a comment after here. And this is something that you'll see a lot in programs like people will include comments either after lines of code, or directly above lines of code. And a lot of times people will use comments in order to like describe what a line of code is doing. So I can say like, this line prints text. So obviously, you know, it's pretty obvious what this line is doing. But if I wanted, I can put a comment there. Another thing that comments are used for is commenting out code. So there's going to be certain situations when you're programming where you might want to run your program, but without a specific line of code. So if you have like this whole, you know, big method, and you want to see what your program would be like without a specific line, Well, one thing you could do would be just to erase the line of code, right, you could get rid of it, and you can go ahead and you can run the file. And, you know, basically the codes gone. But the problem with that is you have to physically delete the line of code, a better way would be just to come over here and right before the line of code, we can put a comment there. And this is what's called commenting out a line of code. And a lot of times developers we'll use this to basically temporarily, like disable a line of code. So now when I run the program, we're not printing out comments or fun anymore, because it's commented out. And the great thing is when I want this line of code back, I can just get rid of the comment and we're back in business. So real really a comment is just kind of like open for business, like whatever you want to do with it, whatever you you know, you think you can accomplish with a comment, you can go ahead and do that. A lot of times people will also put comments on multiple lines. So you'll see some people they'll have like, you know, line one of a comment and then down here, they'll make another hashtag will have line two. This is one way that you can put comments on multiple lines. And honestly, this would probably be the recommended way like the most, you know, Ruby asked way to do it. There is another way that we can do this, though. So yeah, like I said, normally with these hashtags, like it only applies to the one line, right. But if you wanted, you could create a comment block and all you have to do is just say equals begin. And then wherever you want the comment block to end you can just say equals end. And it's important to know that these can't have any whitespace before them. So you see if I put waste whitespace there, it disables the comment. So down here, you can just type whatever you want inside of the comment. And it will be rendered as a comment. But like I said, I think probably a cleaner way to do it is just to put a hashtag on every line, especially you know, if you're moving to other programming languages, a lot of other programming languages will do stuff like this. So you know, just something to keep in mind. One final thought about comments, you want to use comments only when they're absolutely necessary. You know, comments, if you have too many of them and they're too active in the document. A lot of times they can be a little bit distracting. Generally, your goal should be to write code that is as readable and clean as possible, so that you don't need comments to explain it. But a lot of times a comment can come in handy. So if there's a situation where you think you need to comment, don't be afraid to put one in. In this tutorial, I'm going to show you the basics of reading from an external file in Ruby. And one of the useful things we can do with Ruby is we can actually read from external files that are on our computer. So if I had like a file that was on my computer somewhere I could actually read from that file inside of my Ruby program. So I'm gonna show you guys how to do that I actually created a txt file over here. It's in the same directory as this draft dot Ruby file. It's called employees dot txt. So I'm going to open that up. And you can see over here it's just a very simple text file. have employees. So these might be like employees at an office or you know, whatever we have, you know the name. And then we have the position. So Jim is in sales Andes and sales creed is in quality assurance, basically just says their names. And then it says what they do so their jobs. So this is a, you know an example of maybe a text file that you might want to read from inside of your Ruby files. So I'm going to show you guys how we can read from this file over here in my program, I have to use a special command. So I'm just going to say file dot open. And now I'm going to make an open and closed parentheses. And so inside of this open and close parentheses, I want to give this a couple of different parameters, the first one is going to be the name of the file, in my case, I have this file stored in the same directory as this Ruby file. So I can actually just put in the name of the file, so I can say, employees dot txt, but if this isn't in the same directory as the Ruby file, you're gonna have to include either a relative path in here. So for example, if it was in a directory called like files, I could say, forward slash files, or, you know, files forward slash, or you're gonna have to include an absolute path that starts at your hard drive. So that would be if you're on Windows, it could be something like C, you know, users whatever. So basically, it's some sort of path to the file, or if it's in the same directory, you can just put the file name. And we also need one more parameter in here, which is going to be the mode that we want to open the file. And so when you open a file in Ruby, you can actually open it in a couple different modes. And there's maybe like six or seven different modes that you can open files in, the one we're going to be using is called read. So I'm just going to type an R in here. And that's going to tell Ruby that all we want to do is read the files, we don't want to modify it, we don't want to write to it, we don't want to overwrite it, we just want to read it. And now what I can do is I can say do, and over here, I can make two open vertical bars, and I'm just gonna say file. And basically what this is doing is it's storing this file that we just opened inside of this file variable. So I now have a variable called file, which will represent the file that we just opened. And basically, what I want to do is I want to come down here and down below here, I basically just want to say, and so this is one way that we can open up a file. And I think for a beginner, this is probably the easiest way to do it. So you just say file dot open the name of the file, the mode, in our case, our do and then this is now going to store this file inside of this variable. So whenever we want to do with this file, we can do inside of here. And the reason that we need this END block is because this n block is going to signify when we're done working with the file. And when we're done working with the file, it's just going to go ahead and close the file. So we're not going to be using it anymore, we're not going to have it open anymore. So this is going to be good just as a beginner just to kind of, you know play around with working with and reading from files. So inside of here, we can use this file variable that we created over here, and we can actually do some stuff. So the first thing I could do would be just to print this out. So I can just say puts file. And now you'll see over here on the screen, it's printing out like all this information. This is essentially like some like metadata about our file. It's basically like how it's stored in Ruby. But if we want, we can read the file, so I can say puts file dot read. And now we're going to get all the information in the file. So you see we're printing out all the different names all the different employees from our file. So read is basically just like you're reading the entire file. And if you want, you can use any sort of, you know, string methods on this, I mean, this is basically just giving us a string. So I could say like read dot includes, or include, and, you know, we could see if like someone in there is named Jim or whatever. And we get true back so that, you know, essentially, this is just giving us a string with all the information in the file. There's also another thing which we can do, which is called read line. And read line will basically read a line from the file. So if I print out file dot read line, it's going to read the first line of the file. But what this is actually going to do is it's going to read the first line, and then it's basically going to say like, Okay, now we're on the second line. So let me show you guys what that means. So if I was to copy this line, and paste it down here, this is going to print out the first line of the file, and then this one's going to print out the next line in the file. So you'll see when I run this, it prints out Jim and then Andy. So every time we read the line, we're basically telling the file that we want to move on to the next line. So this is a good way if you want to read like each line individually. You can also do the same thing but with the characters. So I could say read char and then down here I could also say to recharge and instead of reading the individual lines, this is just going to read the different characters inside the file one by one so now we'll be able to print out Jim yeah So recharging and relying can both be really useful. Like as you go through a file, there's one more I want to show you, which will allow us to loop through all of the lines in the file. And then for each line in the file, we can like do a specific thing. So I can do is I can actually say, for line in file dot read lines, and read lines is a little method, which is basically just going to return an array of all of the lines. So actually, let me show you guys what this is going to give us, I'm going to print this out. So I'm going to print out file dot read lines. And you'll see it's just printing out all the lines in the file. But this is actually stored as an array, so I get access. Like, if I wanted the third line in the file, then I'll be able to access it like that. So we can loop through this array, like you would normally loop through an array. So we could say like for to line in file dot read lines. And down here, we can just put some code that we want to do for each line. So I mean, obviously, I could just print them out. So I could say put line. And this will print out every line. But in here, we can modify the line, we can look through it, we could do anything we wanted to each individual line in the file. And here's the thing, you know, these are just sort of the basics. You know, I mean, this is everything that you need to basically take a file, you know, a text file, loop through every line, and then you're basically just given a string. So this line over here, I mean, these are all just strings in our program. So you know, you can use all the different string methods to parse through those lines to figure out what they're saying, get information from them. And, you know, really, it's honestly super easy to actually read from a file. So I would say that's all like the main, you know, those are sort of like the most popular the most commonly used methods when we're talking about files, I also do want to show you another way that we can open a file. So you see over here, we said file, dot open the name of the file, and then we did this whole, like do file thing. There's another way that we could actually do this. So instead of saying this stuff over here, I could actually just store this in a variable. So I can say like file is equal to all of this. And we can do exactly the same stuff we did before. So I could say like, puts file dot read and will still be able to print out all the contents of the file. The only thing with this though, is whenever you create a file like this, you always want to make sure that you close the file when you're done with it. Closing the file basically means you're saying that you're done with the file. So you don't want to leave a bunch of files like open and in memory. So if you can just say file dot close, and this will go ahead and close the file. And you won't have to worry about it like taking up any more space in your program. But that's really the basics. And you know, you can really just sort of go from here, right? practice playing around reading different files, practice reading different types of files, these can be, they don't just have to be text files, they can be any type of file. In this tutorial, I want to talk to you guys about writing to files in Ruby. One of the cool things about Ruby is we can read files, but also we can write file, so I can actually write information out to a file. And I can do that right inside of my program. So in the last tutorial, we talked a little bit about reading files. So we kind of opened up a file here, we opened up employees dot txt, which was just this text file that had a bunch of like, I don't know, employees and a company in it. And we basically stored that file inside this file variable, we could do all sorts of stuff with it. Now I want to talk to you guys about actually writing information to files. And the first thing I want to kind of talk to you guys about are the different file modes. So different ways that we can open up a file, you'll see over here, I'm passing in two arguments to this open method, I'm passing in the name of the file, obviously. But then over here, I have this little r. And this is basically a file mode. So this kind of tells Ruby, like when we're opening the file, it kind of gives Ruby an idea of like what we want to be able to do with it, right? If I say R, this stands for read, but there's actually a bunch of other ones. So I'm gonna head over here to my web browser. And I'm just on a Stack Overflow page. And I think this actually gives a pretty good explanation of all the different file modes in Ruby. As you can see, here, R is basically just a read only starts at the beginning of the file, r plus is a read write, W is write only, it truncates the existing file, w plus is read, right? So there's all these different, like file modes that we can open up. And this is a pretty cool list, you know, one thing that's can be fun to do is just play around with a file and opening it and all these different modes just to kind of see what they do. And this tutorial, I'm going to be opening the file in a couple of these different modes. And I think it's going to be pretty fun. So the first thing I want to show you guys is how to append to a file. So over here I have my little list of employees, right, let's say that I wanted to add an employee onto this file. So I didn't want to modify any of the existing employees. I basically just wanted to append one to the bottom of the file. So we want to add In a new employee, well, I can open up this file in what's called the append mode. So I'm just going to put an eight here. And that basically means all we can do to this file is just add information onto the end of it. So we can't read from it, we can't write to it. Well, we can write to it, but we can only write at the end of the file. So we can just append something. So down here, what I could do is I could say file dot write. And inside of the parentheses, we can put whatever we want to write to the file. So why don't we try to add a new employee. So why don't we say well add Oscar who is in accounting, basically, what's gonna happen is when I run this program, this line of text is going to get appended onto the end of the employees dot txt file. So I'm gonna go ahead and run this. And now over here in the employees dot txt file, you'll see we have this Oscar from accounting line, but it actually just got appended right onto the end of the fall. So literally right after the last character, and I want to show you guys what we can do to mitigate that. So I'm just going to get rid of that. And we're going to run this again. This time, though, I'm going to run it with a new line in front. And basically, what this will do is it'll go on to the next line, and then it'll print Oscar from accounting. So now, when I run the program, we should get what we want, which is this. So Oscar, is just on the next line. Here's the thing, when you're appending to a file, it really when you're writing to a file, you need to be careful, because if I was to run this program again, so I'm just going to run it again. And I go back over to this employees dot txt file, you'll notice that Oscar and got a pendant to the end of the file again. Alright, so every time you run your program, it's going to keep modifying the file. So you need to be careful whenever you're writing to files because you're modifying the actual file. So if you, you know, mess up and you run your program one too many times, and your files are basically going to be, you know, if not ruined, they're going to have information in there that you didn't want. So that is the basics of appending, you can just append something onto the end of the file, it's super simple, super straightforward. And that can be really useful. In a lot of different scenarios. Another thing we can do is just write to the file. So instead of a, I'm going to say w here. And this basically gives us the ability to modify information in a file, overwrite information in a file and also create new files, which is pretty cool. So over here, if I was to say file dot write, and I just did Oskar accounting. Now, what this is going to do is it's going to overwrite this entire employees dot txt file. So let's go ahead and do that. I'm going to run this. And you'll see over here, this is actually overwritten the entire file, so we've overwritten everything in this file. And that's basically what happens when we write to a file. So I'm actually going to undo this. And we'll bring this back to how it was I want to show you guys another thing we can do, which is when you're writing to a file, you can actually create new files. So for example, let's say I wanted to create a new file, I can actually come up here, put the name of the new file that I wanted to create. So maybe I want to create like an HTML file, I could call it index dot HTML. Down here, I could actually write out some HTML into this new file. So I could say file dot write. And we can just put some, I mean, we can put like HTML, you know, whatever. So HTML is like another sort of programming language. And now what's going to happen is, when I run this program, a new file called index dot HTML is going to get created. And this is actually going to get written into that file. So you'll see over here, index dot HTML has been created. And it has a header one, and it's just saying, hello, that's pretty cool. You can create all different types of files, you can use all different types of file extensions over here. And that's, you know, really useful way to create files. Another thing I want to show you guys is another file mode. So instead of just writing, we're actually going to read and write, so I'm just gonna say R plus. And basically, what this means is we can read the file, and we can write the file. And when we're doing stuff like this, and makes it really useful. So okay, so we have all of our employees here, I can actually use some of the read methods that we learned in the last tutorial and some of the right methods in order to write information at specific points in the file. So for example, we could insert text at a specific point in the file. So I can say like, file dot read line. And this is basically going to move to the next line in the file. So whenever you're reading a file, there's like something called a file cursor. Or you'll hear people call it like the the file buffer, sometimes, basically like it, when we open the file, we start at a specific place in the file. So if you come back over here, you'll see like read read only starts at beginning of file, right? Our plus read right starts at beginning of the file. So in certain times, when we use these certain modes, they'll start at certain positions in the far right, a little cursor, whatever. When I say file dot read line that moves that little cursor to the next line in the file, right? And so now, essentially, where this cursor is, is that the second line of the file. So I can come over here and I could say file dot write. And I can basically say, like, overridden. And now when I run this, and I go over to my file, and actually, we got to change this back to employees dot txt, my bad. So when I go back over to my file, you'll see that it says overridden down here, right? So I was able to override the text that was on that second line, I can even do the same just for parts of it. So if I just wrote out like, high down here, you'll see that high is going to get inserted only in these first two positions, right? So you're just overriding like the positions right after that little cursor. And so that can be really, you know, useful. And really, you can use this read line. And there's also another one called read, char, and recharge will just read like an individual character. So it'll move that cursor like one character, you can use these different functions to move that cursor on the file and insert text, you know, in very specific places. And that, you know, you can just kind of play around with that to be able to do stuff like that. But I would say those are kind of the basics. You know, we learn how to create new files, we learn how to override existing files, we learn how to insert text into specific places and specific files, we learned about the different modes. So again, you know, go off research some of the different modes where you can open a file, but I would say really writing to files is extremely useful. And there's a lot lot lot of programs that do stuff like this and rely on stuff like this. In this tutorial, I want to talk to you guys about Exception Handling in Ruby. Now, sometimes when you're writing your Ruby programs, you're going to come across certain errors. So a lot of times when we get an error in Ruby, it'll crash our program. In fact, every time we get an error in Ruby, it's going to crash our program. And sometimes when you're writing Ruby code that you want to be able to execute for, you know, months and months, or even like a couple years at a time, you want to make sure that you're able to handle any errors or exceptions that pop up in your program. And I'm going to show you guys how you can do that today using something called a rescue. So let's go ahead and trigger an error in our program, one of the easiest ways to do this is to divide something by zero. So if you're familiar with, you know, math, you can't actually divide something by zero. So if I said like, num is equal to 10, divided by zero, when I run this program, you'll see over here, we're getting a bunch of red, we're getting an error, it says divided by 00 Division error. So Ruby's telling us, you had a zero division error, right? Another area that we could use, and I'm actually just going to comment, this guy out right here, would be trying to access an invalid index in an array. So we can try to access an array index using something like a string. So I just have this array over here of lucky numbers. If I was to say, like lucky nums, like zero, this is going to be fine, this will give me this four. But if I said lucky, nums dog, I can't actually pass a string into here. So I'm going to get another error. And over here, it says no imposition, implicit conversion of string into integer. So I'm getting a type error. And there's a bunch of these different errors in Ruby, you know, they handle a bunch of different situations going wrong. But the point is that if a situation like this comes up in my program, a lot of times, I'm gonna want it to not break the program, like, I'm gonna not want it to explode the program. And then you know, the program is done running. So we can actually watch out for some of these common errors. And we can do what's called catching them. And when we catch an error, or we catch an exception, that means we're basically saying to the program, like, Hey, we know some of them went wrong, but we're handling it, and it's all good, don't worry about it, you don't need to crash and burn. So I'm going to show you guys how you can do that. And really, the most basic way to do it is just to use something called rescue and begin tags. So over here, I'm just going to say begin. And down below here, I'm going to say rescue. And then down here, I'm going to say and so this is the basic structure, any code that I think is going to throw an error or an exception in my program, I want to put it inside of these, this little BEGIN block. So for example, this division by zero, let's grab this, and we can put this in here. As long as this code, like the code that we think might break is inside of that BEGIN block. Then if something does go wrong here, then it's basically just going to go down to the code inside this rescue block and execute that. So I can say down here like puts division by zero error. So now when I run my program, instead of the program just exploding, it's gonna say division by zero error. So the program actually didn't break the program didn't stop executing our program just handled the error. And defaulted down here and basically printed out, hey, there's a division by zero error. Here's the thing, the same thing is going to work for these lucky numbers. So if I was to grab this lucky numbers, and I put this over here, and I'm actually going to comment this out. Now when I run this program, you'll see that the lucky numbers is going to do the same thing. So over here, it says division by zero error. Here's the problem, though. Let's say I have more than one piece of code inside of this BEGIN block that has the potential to break the program. Right. So these two blocks of code will break the program, right? We we know for a fact that they will. But let's say that they'll only break the program some of the time, right. So maybe we have a program where the user can enter in two numbers to divide, and sometimes they're going to enter into zero, in which case, we're going to have to handle this error. And maybe sometimes they won't. The problem is that if I just put division by zero error down here, this is just going to catch any error that gets thrown. So it'll catch this error up here, it will also catch this error. And remember, those are two different types of error. One was a division by zero error, one was a type error. So there's actually a way that we can specify specific rescue blocks for specific types of errors. So for example, that division by zero, if I wanted, I can come down here and I could say rescue, and then I can just type out zero division error. And remember, this is basically the error that got thrown when we divided by zero. And so here's the thing, when I run this num 10 divided by zero thing, it's going to get caught by this division by zero error when I run the program. But if I was to run this lucky numbers, so if I just uncomment, this, this isn't gonna get caught. So this is still going to break the program, you'll see over here, we're still getting a type error. So actually, what I could do is I could create another rescue block for that specific type of error. And we could just say, type error. And then down here, inside of this rescue block, we could, you know, print out a message like, wrong type. And so now this lucky numbers with the dog index is going to get caught. And it's going to say, wrong type. So a lot of times in Ruby, you're going to want to be specific about what errors you want to catch. And so basically, what this means is, in the case of a zero division error, I could do something, I could put a bunch of code inside of here, that's going to do something, in the case of a type error, I could do something else, another thing we can do is we can actually take the error that got thrown, and we can store it in a variable. So I could say type, err, an equal sign and a greater than sign. And then I can just type in the name of a variable, what I want to store the exception that got thrown, so I'm just going to call it E. And down here, I could actually print out E. So when this type error gets called, instead of just typing out, hey, wrong type, it's going to tell us what the actual error was. So it says no implicit conversion of string into integer. And a lot of times this can be useful, because different situations will cause this type error to run. In other words, like different stuff up here might cause the Type error. So by storing the error inside of a variable called E and printing it out, we can tell the user exactly what went wrong. So that's pretty useful. And this is optional, you don't have to do this. But a lot of times, you're going to want to and it's usually a good practice, if you're writing a script or a piece of code that's going to be running for long periods of time. For example, if you need a piece of code to be running for like a couple months, or like even a couple years at a time, like on some server somewhere, using these rescue tags is extremely useful, because you'll basically prevent your program from terminating or your prey program from blowing up when stuff goes wrong. And just one more thought on this. And, you know, different people have different opinions about this. But generally, it's a good idea to specify the specific errors that you want to catch, it's usually not a good idea just to use rescue. The problem is because this is just going to catch any error under the sun. So a lot of times like you're going to want to be able to respond to individual errors differently. So this is kind of like almost too broad in a sense, because you're just casting a huge net, and catching every error in your entire program. But if you want to use that, then it's available to you. So that's the basics of using those begin and rescue tags in order to stop our programs from blowing up. In this tutorial, I want to talk to you guys about classes and objects in Ruby, are classes and objects are a extremely important concept in Ruby. So in this video, I'm going to be giving you a basic overview of what a class is, what an object is, how we can create classes and how we can create objects. So make sure you pay attention because this is a very important topic when it comes to Ruby. Now Ruby is an awesome language because it allows us to use all different types of data inside of our programs. So if you watch the video that I did on data types in Ruby, we looked at some of the basic data types that Ruby gives us things like strings, integers, floating point numbers, things like Booleans. And even like the nil value, right, there's all these different types of data that we can represent. And we can work with him we can use in our Ruby programs. But here's the problem is not all things not all information, not all objects, not all entities in the real world can be represented by just those pieces of information, right? You can't represent everything with just a string, or with just a number, or with just a Boolean, right? There's a lot of things in the real world, like a lot of you know, different things like a person or a phone or a credit card, or a water bottle, or a computer, a keyboard and mouse, like there's a lot of these real world things that can't be represented using just a string or just a number. One of the cool things about Ruby is it allows us to create our own data types. So I could actually create my own data type that it will allow me to represent like a phone inside of my program, or that would allow me to represent a computer or a credit card or a book or a lampshade or a dog, really anything I would want, I could represent inside of my program. And I can essentially just create my own data type. And essentially what that is, it's called a class. So we can create a class in Ruby. And a class is basically just a custom data type. So it's a data type that we can define. So I can basically say, like, I want to represent a book inside of my program. And I can say, here's what a book looks like, in my program, maybe it has like a title it has an author has, like, you know, a certain number of pages associated to it. And then I can take that book data type, and I can create individual books from there. So I can take this book class that we're going to create, and I can create individual books, I can represent individual books inside of my program. So I'm gonna show you guys how we can do that we're going to create a book data type or a book class. And then we're going to create some book objects, this is going to be pretty cool. In order to create a class, I can just come over to my Ruby file, and I'm just going to type out class. And I want to give it a name. And generally, in Ruby, when we create a class, you're gonna want to give it a name with a capital letter. So I could say, like, be okay with capital B. And then I'm going to come down here and just type end. So remember, a class is essentially a custom data type in Ruby. So when we create a class, we're basically modeling a real world entity or a real world object inside of our program. So inside of this book class, I'm basically telling Ruby, what a book is, I'm defining like, here's what a book is. And generally, when we create a class, we're going to give these classes various attributes. And that's how we can create a data type, I can say, Okay, here's my book class, and every book is going to have a title, it's going to have an author, and it's gonna have a number of pages, right? A class is essentially like a blueprint, or a template for a specific entity or object in the real world, like a book is an actual entity in the real world, right? A book is an object that we can interact with and work with. And this class is a template or a blueprint for representing a book inside of our program, we're basically creating our own data type. So inside of this book class, I can actually define a bunch of attributes, and attributes is just going to be information that all books are going to have. So we're essentially telling Ruby, like, hey, all books should have the following information. So inside of this class, I'm just going to type out a TT r underscore, ACC SSR, attribute accessor. And now I'm going to make a space. And over here, I'm going to type in the attributes that a book should have inside of our program. So I'm just going to type a colon, and I'm going to type the name of the attribute I want to define. So all books should have a title, I'm going to put a comma book should have an author. And then book should also have a number of pages. So I'm just going to say pages. So essentially, what I'm doing here is, again, I'm laying out the blueprint for a book inside of my program. So I'm essentially saying like, here's the book datatype. And all books are gonna have a title, they're gonna have an author, and they're gonna have pages. So this is like our overall blueprint, our overall template. So now that we've created this, now that we've told Ruby, what a book is, we can actually go and create individual books inside of our programs. And these are called objects. And an object is essentially just an instance of a book or an instance of a class. So I can create a book object, and that book object would represent an individual book in my program. So I'm going to come down here and you can create objects, essentially the same way that you create variables and actually as we'll learn all variables in Ruby are actually just objects. So I'm going to give this a name. So we'll just call this book one. And I'm going to set it equal to book dot new. And we're gonna make an open and close parentheses. Basically, what this is doing is it's telling Ruby that we want to create a new book. So we want to create an actual book inside of our program. In other words, we want to store the book datatype, inside of this book, one variable. Now down here, what I can do is I can actually give this book attributes. So remember, we defined a book up here that it's going to have a title, an author, and a number of pages. So down here, I can basically say book one dot title, is equal to, and we can make this like a Harry Potter book, right? So I'm basically defining what the title of this book is. And down here, I could say, Book Two dot author. And we'll make the author, JK Rowling. And we can say, actually, whoops, this has to be book one, I'm sorry. And then we can say book one dot pages. And we can set this equal to like, I don't know, maybe has 400 pages or something. So essentially, what I'm doing is I'm creating this book object. And remember, an object is an instance of a class. So when a book object is basically just like a given book inside of our program that's going to have all of these attributes. And I'm giving it all of these different attributes, I'm assigning it some information. So what I can actually do now is I can interact with this object. So I can say puts book one dot title. And this is going to print out the title of book one onto the screen. You see over here, it's printing out Harry Potter. Over here, I could print out book one dot pages, and it's going to print out all of the pages in book one. So there's 400. And we could do the same with the author. So essentially, what I did was I created my own data type up here, I created a template for what a book is, inside of our program, I said the book is going to have these certain attributes, I created a new instance of a book. So I created a book object. And then I gave all of those attributes specific information. So I said, like the title of book one is going to be Harry Potter, the author of book one's going to be JK Rowling. And what's cool about objects is we can create as many of them as we want. So down here, I could actually create another book, I could say, book two is equal to book dot new. And then I can start giving this some attribute. So I could say like, Book Two dot title is equal to Lord of the Rings, you'd say Book Two dot author, is equal to token and book two pages, is equal to, let's say, 500. And so now I'm actually representing another separate book inside of my program. So I can come down here and say, like, puts book to the author. And this is going to print out the author of book two over here in the console. So essentially, what we did again, was we defined the template for what a book is going to be inside of our program. And this is a class. And then we can create instances of that class, which are called objects. And an object is just like an actual book. So we have the Harry Potter book. And we also have the Lord of the Rings book down here. And we can access all the attributes from inside those books by saying book to author book to pages, we can just refer to them directly. And that's one of the cool things about classes and objects is they allow you to create your own custom data types inside of Ruby. And one of the cool things about Ruby is that everything, all data is actually classes and objects. So all data is actually an object, a string is an object. An integer, like a number is an object. a floating point number is not a Boolean is an object. All these different things are objects, and they all have classes which define them. That's really one of the cool things about Ruby. And one thing that sets it apart from a lot of other programming languages is that everything is an object. In this tutorial, I want to talk to you guys about the initialize method in Ruby classes. So in the last tutorial, we looked at creating Ruby classes and then creating objects of those classes. And this tutorial, I'm going to show you a way that we can actually make creating these objects a little bit easier. So notice down here, when I created my two book objects, I said book one is equal to book dot new. And then I had to manually set the book's title, the books author and the books pages. So just to create one book, I had to type out four full lines of code. Right down here, I do the same thing. So when I created the second book, had to type out four full lines of code. And this is kind of a problem because if I wanted to create, for example, like, you know, 10 or 20 different books, it's gonna take up seriously a lot of space inside of my Ruby files. Also just having to go through and manually say like book one title is equal to Harry Potter book, one author like, that gets really tedious after a while, there's actually a way that we can give our objects all this information right up front when we create them, instead of having to do it manually like this. And that's by using something called an initialize method. An initialize method is actually a method that's going to get called whenever we create an object. So remember, up here, we have this class. And this class is basically just a template. It's a blueprint for what a book is, in our program, when I create an object, it stops being a template, it stops being a blueprint, and it becomes an actual book. So this book, one object down here is representing the Harry Potter book, you know, with the author of JK Rowling 400 pages, this is like a physical book that we use that template of there to create. So when we end up creating a book, we can actually give it some default information. And I'm going to show you guys how to do that. So up here in our class, I want to create a method. And it's going to be called initialize. So I'm just going to say def, and it's initialized just like that. And I'm actually going to create this just like I would a normal method. So I'm going to say, and down here, inside of these parentheses, I can actually pass some information. But before I do that, I want to show you guys what's going to happen. So for example, I can put a print statement here, actually, let's do a put statement. And it's going to say, creating book. Now when I run my program, you'll see that over here, it actually types out creating book twice. Essentially, what's happening when I say book dot new, this initialize method up here is getting called. So every time I use this new method down here, and I call it, this initialize method is actually getting called. So if I was to pass a parameter into here, so let's have this initialized method, take a parameter, like we'll have a take name, I could come over here, and I could basically print out like, Hello, name. So I can pass a name into here, I could say, like Mike. And then down here, I could say another name, like Bill or whatever. And when I run my program, you'll see it's printing out Hello, Mike, and Hello, Bill. So this is essentially just a method that we can call just like any other method in any of our programs. But this method special because it gets called when we create an object. So what we can do is we can actually pass this initialize method, some information. And we can use that information to give our object specific information. So essentially, what I can do over here is I can say, initialize is going to accept three parameters. So when we call this new method down here, we're going to have to pass it three things, the first thing we're going to have to pass in is the title of the book that we want to create. The second thing we're going to have to pass it is the author of the book we want to create. And the third thing is going to be the number of pages for the book that we want to create. So now whenever I want to create a book, I have to give it a title, and author and a number of pages. Once I'm inside this initialize method, I can do something special. So I can actually take the values that the user passed in. So I can take the title, the author and the pages. And I can assign them to the attributes of the object. So I can assign them to the title of the object, the title of the author and the title of the pages, I can basically do what I did down here. So I can basically say like book one dot title is equal to whatever the title they passed in was. And this is going to save us tons of time when we're writing our programs. And the way that I can do that as I can, I can just say app, and I can say title is equal to title. So let me walk you guys through this line of code. When I say at title, this is referring to the title attribute in our objects is referring to the title attribute that we defined up here is rented that title of their right, this is saying the title of the object that we're creating is going to be equal to the title that the user passed in. Remember, this title, this is just a parameter that got passed into this new method down here. This is just a parameter just like I pass in the name, it's the same thing. We're passing it a parameter. And I could even name this something else. I can name this like, you know, I couldn't I could name it, you know, whatever I wanted. And, but I'm just calling it title, because that's what it is. It's the title. So I'm setting the title of the object equal to the title that got passed in. I can do that for all of these. So I can say the author of the object is going to be equal to the author that got passed in. And the number of pages is going to be equal to the number of pages that got passed in. And so essentially What I can do now is when I create my new book, instead of having to say like book one title book, one author, I can just take all this information and put it up here. So I can pass it into this initialize method. So I can just say, Harry Potter. And this is going to be JK Rowling rolling, and then the number of pages is just going to be 400. So I can actually get rid of all of this code over here, because I don't need this anymore. And I can do the same thing for this other book down here. So we'll pass in Lord of the Rings, token and 500 pages, and I can actually just get rid of all of this stuff. So now, instead of having all that other stuff, like where I had to like manually set each of those attributes, I can reduce the lines of code, I have to write down to two. And this is going to do exactly the same thing as we were doing before. So I could come down here and I could, you know, print out like Book Two dot title. And it's still going to be able to print it out to see it's printing out Lord of the Rings, I could print out book one dot author. And it's going to be able to print data. So I'm doing exactly what I was doing before, except now I'm making it a lot easier on myself by using this initialize method. And again, whenever we say like book dot new, this means we're calling this initialize method, we're passing it some parameters. And I'm setting the attributes of the current object equal to the attribute that we pass in when we create that object. So that's how we can use that initialize method to make our lives way easier. And you're always going to want to use an initialize method for the most part, just because it makes everything so convenient. In this tutorial, I want to talk to you guys about instance methods in Ruby. Now, sometimes you'll hear people call these instance methods, you'll also hear people call them object methods, sometimes they'll even call them class methods. Essentially, what we're going to do is we're going to come inside of a class that we create in Ruby, and we're going to give it some methods. And then when we're using objects of that class, we can access those methods to get information about our objects. So I want to show you guys my setup over here, I actually have a class here called student. And this class is basically just modeling or it's acting as a blueprint or a template for a student in our program. Essentially, we created like a student data type. So I defined the attributes for a student to be name, Major, and GPA. And down here we have this initialize method. So we're passing in a name a major and a GPA. And we're setting the attributes of this student object have an individual student object to be equal to what gets passed in. So this is like our student class. And down here, I'm creating two student objects. So we're making one, his name is Jim, he's studying business, he has a GPA of 2.6, then we have Pam, who's studying art, and her GPA is 3.6. So these are student one and student two. Now imagine that for each of the students in our program, we wanted to be able to figure out if they had honors or not. So imagine you're writing a program for a college or university, and you want it to be able to figure out whether or not a particular student had honors, let's say that the rules for honors would were constantly changing, right? So one day, maybe you had honors, if you had a GPA over 3.5. And maybe, then they you know, would change it to be like 3.3. In other words, like, imagine, if we wanted to be able to find out which students had honors in which didn't, well, we can actually write a method inside of our student class. And then that method will be able to tell us whether or not a specific object has honors. So I'm gonna show you guys how to do that over here in our class, I'm just going to come down here below this initialize method. And we can actually create a method of our own. So I'm going to go ahead and define a method. And I'm just going to call this has honors. And this method is not going to take in any information. So we're not going to need open and closed parentheses. And down here, we're just going to end it off. So this has honors method is basically going to return either true or false. If the current student if the object that's calling this method has honors and return true, if they don't, it's going to return false. So how can we figure out if the student has honors? Well, we could use an if statement. So I could say if I want to check to see if the student's GPA is greater than or equal to a specific number. So what I can do is I can actually access the GPA attribute inside of our student object and use it here. So I can say if at GPA is greater than or equal to and let's say that in order to have honors we we have to have a 3.5 or above. So if their GPA is greater than or equal to 3.5, then we're going to return true otherwise We're just going to return false. So this is basically our method if the GPA is greater than 3.5, return true, otherwise, we return false. So now what I can actually do is I can use this has honors method on each one of my student objects. So I can come down here, and you'll see I've created these two students, right, Pam. And, Jim. If I wanted, I could print out whether or not they have on him. So I could say puts, and let's check to see if student one, which is Jim has honor. So I could say student one dot has honors. And when I run this, it's going to print out whether or not he has honors. So in our case, it's going to be false. But if I ran this method on student two, so if I ran this method on pam, pam actually does have honors because she has a 3.6. So now this is going to return true. And what I want to point out is this has honors method is going to be different depend or it's going to be using different information depending on what object is calling it. Right. So when student one when Jim is calling this object, Jim has a GPA less than 3.5. So it's going to return false for Jim. So for the gym objects for the gym instance, it's going to return false. But for the PAM object, Pam's GPA is higher than 3.5. So it's going to return true, we can basically define a method that can be used on all of the objects for our specific class. And we can do it using something like this. So you can define as many of these as you want inside of your class. And these can be really useful, a lot of good classes out there and Ruby are going to have a bunch of good methods like this, which are going to allow you to, you know, either find out information about the specific object, or you know, modify the object or do something to the object in some way, shape, or form. So that can be really useful. And just consider, you know, writing some methods inside of your classes when they're appropriate. This is a good example of, you know, where a method can come in handy, because it can tell us whether or not the student has honors, they can tell us something about the student, using the attributes using the information that we've stored about that object. In this tutorial, I'm going to show you guys how we can create a multiple choice quiz in Ruby. So we're going to use some of the stuff that we've learned so far in this course, like classes, we're going to use loops, we're going to use variables. And if statements, in order to create a multiple choice quiz, basically, we're going to be asking the user a series of questions, the user is going to input whatever answers they think are correct, we'll grade the test, and we'll tell the user how they did. So this is going to be pretty fun. First thing I want to do is talk to you guys about some stuff that I already have set up. First thing I did was I wrote out a few questions for our multiple choice test. Down here, I have p one, p two, and P three. And these are all basically prompts. So this is what we're going to prompt the user with. And we're going to ask them the question. So over here, it says, what color apples red, purple or orange? What color are bananas? pink, red, or yellow? What color are pairs? yellow, green, orange. So this is a really easy multiple choice test just asking you about the colors of different fruits. Over here, I've defined a class called question. And this is basically modeling a question in our program. So essentially created like a question data type. And down here, we have these attribute accessors. So we're defining a question has a prompt and an answer. So the prompt is basically what we're asking the user. So it would be like, for example, all these questions down here? And then the answer is the actual answer to the question. So like, we're giving them a prompt that has a bunch of different options, multiple choices, the answer is going to be like what the actual answer is. And then we have this initialize method, which will just initialize the object so we can create like questions inside of our program now. So what I want to do is I want to create an array of questions. And we're going to have one question for each of the prompts that we have up here. So I'm actually just going to create a an array, we're going to call it questions. And I'm just going to set it equal to a bunch of different questions. So actually, inside of this array, we can create a couple different questions. So I'm going to say, question dot new. And I'm going to create this first question. So remember, we need to give this a prompt and we need to give it an answer. So for the first question, I'm going to pass it p one as the prompt, because this is the prompt for the first question. And I want to give it the answer. So the answer to what color or apples is going to be a red, so I'm just going to pass in a now I can create another question. So you'll notice over here, I can just create a question by saying question dot new, and then I can pass in the initial information. So I'm going to say question dot new. And now we'll make one for p two for that second prompt says what color are bananas? And the answer is going to be C Yellow. So we'll put a C inside of here. And finally, we'll make another question. And this is going to be P three. And the answer to what color or pears is going to be be green. So we're going to go ahead and put a B in here. Essentially, what I've done is I've created three questions in my program. And I've stored them inside of this array called questions. So we have an array that stores all the questions for our test. Now the next step is we need to actually be able to run the test. So what I want to do is I want to be able to go through each of the questions in the test, I want to be able to ask the user the question, I want to be able to get their answer. And I want to figure out whether or not they got the answer, right. So what we can do is we can actually create a method. So why don't we create a method that will run the test. So this method will accept one parameter, which is going to be an array of questions. It'll use those questions to run the test. And it'll basically like ask the user all the questions, figure out what their answers were, and score and grade the test. So let's do that down here, I'm going to create a method and we're just going to call it run test. And this method is going to take one parameter, so it's going to be an array of questions. So we could say, questions. And we're just going to call the parameter that we pass in questions. And we can go ahead and end off this method. Now, inside of this method, we want to do a few things, the first thing we want to do is basically just loop through and ask the user all the questions. So what I want to do is create a variable called answer. And I'm just gonna set this equal to the empty string initially. And what we're going to do is we're going to store all of the user's answers inside of that answer variable. So like, we'll store you know the answer to the first question, the second question, the third question, etc. Now, what we want to do is want to loop through all of the questions inside of this questions array. So I'm going to create a loop, I'm just going to say for question, in questions. So for each question inside of this questions array, I want to do something and down here, we'll just end this off. Now inside of here, essentially, what I want to do is ask the user the question, so I'm basically going to say puts, and I'm going to print out the prompt. So I can say puts question dot prompt. So remember, this is going to be an array of question objects. And the question class says, two attributes, it has a prompt, and it has an answer. So essentially, what I'm doing down here, is I'm printing out the prompt for the current question that we're looping through. Once I've printed out the prompt, I can get the input from the user. So I can just say answer is equal to get dot chomp. And this is basically just going to get whatever the user enters and it's going to store it inside of answer. Now what we need to do is we need to be able to keep score. So we need to be able to keep track of how many questions that user gets right, and how many they get wrong. So I'm going to create another variable up here called score. And I'm going to set this equal to zero initially. And whenever a user gets a question, right, we're going to increment the score. So every time they answer the question correctly, score will get incremented. And by the end of the of the test, we'll be able to tell how many questions they got. Right? So down here, I want to check to see if the answer that they gave is equal to the correct answer. So I can just say if answer is equal to and now I want to compare this to the answer to the question. So I can say question dot answer. And remember, this is just another attribute from inside of that questions class. So down here, I'll just end this off. And if the answer is equal to question dot answer, then I can basically just increment the score variable. So I can say score plus equals one, and that will increment the score. Now, finally, down here, after this for loop, I'm just gonna print out how they did. So I'll say puts, and we'll basically just say, like, you got, however, questions out of however, right, so we'll basically be like puts, you got score out of. And now we're just going to type out the total number of questions. So we can say questions dot length. And this is just gonna tell us how many questions were inside of that questions. Right? So this is obviously a lot of code. And you know, this run test method is obviously a lot of code. But everything looks like it's right. So why don't we try to run this, and we'll see how we do. So remember, whenever we're going to get input from the user, we always want to use the command prompt in the terminal to do that. So I'm going to open up my terminal. And I'm going to go ahead and run this Ruby file. So I'm just gonna say Ruby draft.rb, because that's the name of the file. And we'll run this. And so actually, whoops, totally forgot, we have to call this run test methods. So I didn't actually call this run test method. So I need to do that. So let's come down here, and we're just going to call it so I'm just going to say run test and we're just going to pass in that Questions array. So we're passing in the array of questions that we created. Up here, we're passing in this guy. And actually, you know what, there's one more thing we have to change. So down here, I'm printing out the score, I have to say.to S. So we're converting the score into a string. And we're going to have to do the same down here. So I've just saved up to s. And now that we have this, we can actually run our program from inside of the terminal. So let's go ahead and do that. So here in the terminal, I'm just going to run this file, I'm going to say Ruby draft.rb. And you'll see it's asking us the first question. So it says, What color are apples? So let's just try to get them all right, I'm gonna say apples are a red, what color bananas, let's say see yellow, what color are pears, let's say be green. So you can see here, once we entered in all the answers it typed out, you got three out of three, correct. So it's actually telling us how many of these we got correct. And that's pretty awesome. So let's try this again. But let's try to get something wrong. So I'm going to run this same exact file. And let's get the first one wrong, we'll say apples or purple, we'll get the second one wrong, we'll say bananas or pink. And we'll get the third one, right, so we'll say pears are green. So now it's going to say you got one out of three, because we only got one out of three questions correct. So that's basically how we can build a little multiple choice test. In this tutorial, I want to talk to you guys about inheritance in Ruby. And inheritance basically allows us to extend the functionality of one class into other classes. So I can basically define what we would call like a superclass. And then I can create subclasses, from that superclass, which will inherit all of the methods, all the functionality, all the attributes from that original superclass. So that doesn't make sense, don't worry, I'm gonna give you guys a full example of what this is and how it works. But let me show you guys first what I have over here. So I created a class over here, which is called chef. And this chef class, I'm going to expand it, it has three methods inside of it. So the first method over here is called make chicken. And this method basically just prints out the chef makes chicken. And then it has a make salad method, same thing prints out the chef make salad. And then finally, we have the make special dish method, which just prints out, the chef makes barbecue ribs. So essentially, we're just like creating a chef inside of our program. If I wanted, I could come down here and create an instance of the chef. So I can say, chef is equal to chef dot new. And now that I have my chef object, I could say like chef dot make chicken. And now when I run my program, you'll see it says over here, the chef makes chicken. So we're telling the chef to make a chicken, we can tell the chef to make a salad or to make the special dish. Now, let's say that in addition to having this chef class, right, this general overall chef class, we also wanted to define another type of chef, we also wanted to model another type of chef in our program. So let's say that in addition to this generic chef, we wanted to create a more specialized type of chef, so wanting to create an Italian chef. So I could say, Italian chefs, we're creating an Italian chef class, and down here, we'll just end this off. But let's say that our Italian chef can do everything that our normal chef can do. So the Italian chef can also make chicken can also make a salad and can also make a special dish. So the Italian chef can do everything that the normal chef can do. In other words, the Italian chef can have all the same methods as the normal chef, well, I can actually use something called inheritance. And I can pass down all of the functionality from inside of this chef class into the Italian chef class. In order to do that, all I have to do is come down here. And after I say the name of the class, I can just make less than sign. And I can just type out the name of the class that I want to inherit from. So when I say chef right here, that means that the intent of the Italian chef is going to inherit all of the functionality from this chef class. So it's essentially going to inherit all of these methods. So let me demonstrate this. You'll notice there's nothing inside of this class. I didn't type anything inside of there. But I could come down here and I can create an Italian chef object. So I could just say, Italian chef, Chef dot new so I'm creating a new Italian chef. And then down here, I can just say Italian chef dot make salad. So even though I don't have any code up here, inside of this Italian chef class, not a single line of code, I can create an Italian chef object and I can still tell this Italian chef to make salad. Now when I run my program, you see down here in addition to the normal chef making chicken, we're also able to use the Italian chef to make a salad so over here it says the chef makes salad So this Italian chef object has access to all of the functionality from inside of the chef class, because I inherited it. So I'm using inheritance here. And I'm inheriting all the functionality from the chef class. But here's a question right? The normal chef over here has a special dish. So the normal chef makes a special edition that says the chef makes barbecued ribs. But let's say that the Italian chef is going to have a different special dish from the just generic chef, what I can do is I can actually do what's called overriding a method. So I can override the make special dish method inside of this Italian chef class. So I could actually say, make special dish and ended off and then inside of here, I can put what I want the Italian chef's special dish to be. So I could just say puts, and we'll say like, the chef makes eggplant parm. So this is going to be the Italian chef's special dish. So now if I was to come down here and say chef dot make special dish, and Italian chef dot make special dish. You'll see when I print these out, or when I run my program, it says the chef makes barbecued ribs. And the chef makes eggplant parm. So inside of the Italian chef class, I was actually able to override this make special dish method. And that is a super useful thing to do. Another thing I can do is add functionality into this. So let's say that the Italian chef, in addition to doing everything that the normal chef can do, can also make pasta. So I can make a method here it's make pasta. And down here, it's just going to be the chef makes pasta. So now inside of my Italian chef object, I can make some pasta. So I could say Italian chef dot make pasta, and the Italian chef will be able to make pasta. But the normal chef down here doesn't have a make pasta method. So it's not going to be able to make pasta. So let's go over what we did. Essentially, I created this class chef, this chef had a bunch of functionality it can make chicken can make salad can make a special dish, right? Then I created a nother class, Italian chef. And this Italian chef could do all the same stuff as the normal chef. So what I did was I inherited all the functionality from the chef class into here, right. But there was a circumstance where the Italian chef was actually going to have a different special dish than the normal chef. So I overrode this method I basically defined redefined the method inside of the Italian chef class. And I was able to make it do what I wanted it to do. I also extended the functionality. So I was able to actually make the Italian chef different. So the Italian chef, in addition to doing everything that the normal chef could do could also make pasta. And that's the basics of inheritance, we can define what's called a superclass. So this chef up here, this is the superclass. And then we can also define subclasses. So this Italian chef is a subclass. And it's considered a subclass, because it inherits from the chef superclass. And this can be really awesome. So a lot of times in Ruby, you're going to have different hierarchies of classes. So we'll have like the chef class. And then we'll have a subclass and Italian chef, I can also create other subclasses, like a Chinese chef or a French chef, or a Mexican chef, right, I can have different, you know, types of chef different subclasses of chef's that would all inherit the functionality from the generic chef class. So that is super useful feature in Ruby, it's really going to come in handy, especially if you start creating lots and lots of classes. In this tutorial, I'm going to talk to you about using modules in Ruby. Now module is basically just a container where we can store groups of methods. So as you start programming more and more in Ruby, and as your programs get more and more complicated, you're going to want to organize all the different methods that you're using. So a lot of times in a Ruby script, you're going to be writing out a bunch of different methods that are going to do different things in the they'll have different tasks. And one thing we can do is we can take methods that are doing similar things, or that should be grouped together, we can put them inside something called a module. So over here, I have this file open. It's called useful tools.rb. And in here, I've defined a module. So I'm just going to open this up. And you'll see inside of this module, I just said module, and then tools. So whenever we create a module, you can create it by saying module. And generally you're going to want to give modules a name with a capital letter, so you need to do that. And down here, I have two methods. inside of this module, I have a method called Say hi. And it says hi to a user and I have